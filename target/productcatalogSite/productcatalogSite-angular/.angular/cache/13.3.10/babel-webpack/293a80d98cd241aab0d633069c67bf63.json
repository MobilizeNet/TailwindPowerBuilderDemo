{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport BoxElement from './box-element';\nimport FloatElement from './float-element';\nimport Text from './text';\nimport Box from './box';\nimport rectToBox from './utils/rect-to-box';\nimport { getSpacing, deepExtend, defined } from '../common';\nimport { X, Y } from '../common/constants';\nconst ROWS_SPLIT_REGEX = /\\n/m;\n\nclass TextBox extends BoxElement {\n  constructor(content, options, data) {\n    super(options);\n    this.content = content;\n    this.data = data;\n\n    this._initContainer();\n\n    if (this.options._autoReflow !== false) {\n      this.reflow(new Box());\n    }\n  }\n\n  _initContainer() {\n    const options = this.options;\n    const rows = String(this.content).split(ROWS_SPLIT_REGEX);\n    const floatElement = new FloatElement({\n      vertical: true,\n      align: options.align,\n      wrap: false\n    });\n    const textOptions = deepExtend({}, options, {\n      opacity: 1,\n      animation: null\n    });\n    this.container = floatElement;\n    this.append(floatElement);\n\n    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n      let text = new Text(rows[rowIdx].trim(), textOptions);\n      floatElement.append(text);\n    }\n  }\n\n  reflow(targetBox) {\n    const options = this.options;\n    const visualFn = options.visual;\n    this.container.options.align = options.align;\n\n    if (visualFn && !this._boxReflow) {\n      let visualBox = targetBox;\n\n      if (!visualBox.hasSize()) {\n        this._boxReflow = true;\n        this.reflow(visualBox);\n        this._boxReflow = false;\n        visualBox = this.box;\n      }\n\n      const visual = this.visual = visualFn(this.visualContext(visualBox));\n\n      if (visual) {\n        visualBox = rectToBox(visual.clippedBBox() || new geom.Rect());\n        visual.options.zIndex = options.zIndex;\n      }\n\n      this.box = this.contentBox = this.paddingBox = visualBox;\n    } else {\n      super.reflow(targetBox);\n\n      if (options.rotation) {\n        const margin = getSpacing(options.margin);\n        let box = this.box.unpad(margin);\n        this.targetBox = targetBox;\n        this.normalBox = box.clone();\n        box = this.rotate();\n        box.translate(margin.left - margin.right, margin.top - margin.bottom);\n        this.rotatedBox = box.clone();\n        box.pad(margin);\n      }\n    }\n  }\n\n  createVisual() {\n    const options = this.options;\n    this.visual = new draw.Group({\n      transform: this.rotationTransform(),\n      zIndex: options.zIndex,\n      noclip: options.noclip\n    });\n\n    if (this.hasBox()) {\n      const box = draw.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n      this.visual.append(box);\n    }\n  }\n\n  renderVisual() {\n    if (!this.options.visible) {\n      return;\n    }\n\n    if (this.options.visual) {\n      const visual = this.visual;\n\n      if (visual && !defined(visual.options.noclip)) {\n        visual.options.noclip = this.options.noclip;\n      }\n\n      this.addVisual();\n      this.createAnimation();\n    } else {\n      super.renderVisual();\n    }\n  }\n\n  visualContext(targetBox) {\n    const context = {\n      text: this.content,\n      rect: targetBox.toRect(),\n      sender: this.getSender(),\n      options: this.options,\n      createVisual: () => {\n        this._boxReflow = true;\n        this.reflow(targetBox);\n        this._boxReflow = false;\n        return this.getDefaultVisual();\n      }\n    };\n\n    if (this.data) {\n      Object.assign(context, this.data);\n    }\n\n    return context;\n  }\n\n  getDefaultVisual() {\n    this.createVisual();\n    this.renderChildren();\n    const visual = this.visual;\n    delete this.visual;\n    return visual;\n  }\n\n  rotate() {\n    const options = this.options;\n    this.box.rotate(options.rotation);\n    this.align(this.targetBox, X, options.align);\n    this.align(this.targetBox, Y, options.vAlign);\n    return this.box;\n  }\n\n  rotationTransform() {\n    const rotation = this.options.rotation;\n\n    if (!rotation) {\n      return null;\n    }\n\n    const {\n      x: cx,\n      y: cy\n    } = this.normalBox.center();\n    const boxCenter = this.rotatedBox.center();\n    return geom.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);\n  }\n\n}\n\nexport default TextBox;","map":null,"metadata":{},"sourceType":"module"}