{"ast":null,"code":"import { Color } from '@progress/kendo-drawing';\nimport Candlestick from '../candlestick-chart/candlestick';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport { ShapeElement } from '../../core';\nimport { LINE_MARKER_SIZE, BORDER_BRIGHTNESS } from '../constants';\nimport { CROSS, CIRCLE, WHITE } from '../../common/constants';\nimport { deepExtend, defined, setDefaultOptions } from '../../common';\n\nclass BoxPlot extends Candlestick {\n  constructor(value, options) {\n    super(value, options);\n    this.createNote();\n  }\n\n  reflow(box) {\n    const {\n      options,\n      value,\n      owner: chart\n    } = this;\n    const valueAxis = chart.seriesValueAxis(options);\n    let whiskerSlot, boxSlot;\n    this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\n    this.realBody = boxSlot;\n    this.reflowBoxSlot(box);\n    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\n    this.reflowWhiskerSlot(box);\n    const medianSlot = valueAxis.getSlot(value.median);\n\n    if (value.mean) {\n      const meanSlot = valueAxis.getSlot(value.mean);\n      this.meanPoints = this.calcMeanPoints(box, meanSlot);\n    }\n\n    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\n    this.medianPoints = this.calcMedianPoints(box, medianSlot);\n    this.box = whiskerSlot.clone().wrap(boxSlot);\n    this.reflowNote();\n  }\n\n  reflowBoxSlot(box) {\n    this.boxSlot.x1 = box.x1;\n    this.boxSlot.x2 = box.x2;\n  }\n\n  reflowWhiskerSlot(box) {\n    this.whiskerSlot.x1 = box.x1;\n    this.whiskerSlot.x2 = box.x2;\n  }\n\n  calcMeanPoints(box, meanSlot) {\n    return [[[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]];\n  }\n\n  calcWhiskerPoints(boxSlot, whiskerSlot) {\n    const mid = whiskerSlot.center().x;\n    return [[[mid - 5, whiskerSlot.y1], [mid + 5, whiskerSlot.y1], [mid, whiskerSlot.y1], [mid, boxSlot.y1]], [[mid - 5, whiskerSlot.y2], [mid + 5, whiskerSlot.y2], [mid, whiskerSlot.y2], [mid, boxSlot.y2]]];\n  }\n\n  calcMedianPoints(box, medianSlot) {\n    return [[[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]];\n  }\n\n  renderOutliers(options) {\n    const value = this.value;\n    const outliers = value.outliers || [];\n    const outerFence = Math.abs(value.q3 - value.q1) * 3;\n    const elements = [];\n    let markers = options.markers || {};\n\n    for (let i = 0; i < outliers.length; i++) {\n      const outlierValue = outliers[i];\n\n      if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\n        markers = options.outliers;\n      } else {\n        markers = options.extremes;\n      }\n\n      let markersBorder = deepExtend({}, markers.border);\n\n      if (!defined(markersBorder.color)) {\n        if (defined(this.color)) {\n          markersBorder.color = this.color;\n        } else {\n          markersBorder.color = new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex();\n        }\n      }\n\n      const shape = new ShapeElement({\n        type: markers.type,\n        width: markers.size,\n        height: markers.size,\n        rotation: markers.rotation,\n        background: markers.background,\n        border: markersBorder,\n        opacity: markers.opacity\n      });\n      shape.value = outlierValue;\n      elements.push(shape);\n    }\n\n    this.reflowOutliers(elements);\n    return elements;\n  }\n\n  reflowOutliers(outliers) {\n    const valueAxis = this.owner.seriesValueAxis(this.options);\n    const center = this.box.center();\n\n    for (let i = 0; i < outliers.length; i++) {\n      const outlierValue = outliers[i].value;\n      const markerBox = valueAxis.getSlot(outlierValue);\n\n      if (this.options.vertical) {\n        markerBox.move(center.x);\n      } else {\n        markerBox.move(undefined, center.y);\n      }\n\n      this.box = this.box.wrap(markerBox);\n      outliers[i].reflow(markerBox);\n    }\n  }\n\n  mainVisual(options) {\n    const group = super.mainVisual(options);\n    const outliers = this.renderOutliers(options);\n\n    for (let i = 0; i < outliers.length; i++) {\n      const element = outliers[i].getElement();\n\n      if (element) {\n        group.append(element);\n      }\n    }\n\n    return group;\n  }\n\n  createLines(container, options) {\n    this.drawLines(container, options, this.whiskerPoints, options.whiskers);\n    this.drawLines(container, options, this.medianPoints, options.median);\n    this.drawLines(container, options, this.meanPoints, options.mean);\n  }\n\n  getBorderColor() {\n    if ((this.options.border || {}).color) {\n      return this.options.border.color;\n    }\n\n    if (this.color) {\n      return this.color;\n    }\n\n    return super.getBorderColor();\n  }\n\n}\n\nsetDefaultOptions(BoxPlot, {\n  border: {\n    _brightness: 0.8\n  },\n  line: {\n    width: 2\n  },\n  median: {\n    color: \"#f6f6f6\"\n  },\n  mean: {\n    width: 2,\n    dashType: \"dash\",\n    color: \"#f6f6f6\"\n  },\n  overlay: {\n    gradient: \"glass\"\n  },\n  tooltip: {\n    format: \"<table>\" + \"<tr><th colspan='2'>{6:d}</th></tr>\" + \"<tr><td>Lower:</td><td>{0:C}</td></tr>\" + \"<tr><td>Q1:</td><td>{1:C}</td></tr>\" + \"<tr><td>Median:</td><td>{2:C}</td></tr>\" + \"<tr><td>Mean:</td><td>{5:C}</td></tr>\" + \"<tr><td>Q3:</td><td>{3:C}</td></tr>\" + \"<tr><td>Upper:</td><td>{4:C}</td></tr>\" + \"</table>\"\n  },\n  highlight: {\n    opacity: 1,\n    border: {\n      width: 1,\n      opacity: 1\n    },\n    line: {\n      width: 1,\n      opacity: 1\n    }\n  },\n  notes: {\n    visible: true,\n    label: {}\n  },\n  outliers: {\n    visible: true,\n    size: LINE_MARKER_SIZE,\n    type: CROSS,\n    background: WHITE,\n    border: {\n      width: 2,\n      opacity: 1\n    },\n    opacity: 0\n  },\n  extremes: {\n    visible: true,\n    size: LINE_MARKER_SIZE,\n    type: CIRCLE,\n    background: WHITE,\n    border: {\n      width: 2,\n      opacity: 1\n    },\n    opacity: 0\n  }\n});\ndeepExtend(BoxPlot.prototype, PointEventsMixin);\nexport default BoxPlot;","map":null,"metadata":{},"sourceType":"module"}