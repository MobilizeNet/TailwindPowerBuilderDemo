{"ast":null,"code":"import { Class } from '../../common';\nimport { Encoding } from './encoding';\nimport deepExtend from '../../common/deep-extend';\nimport inArray from '../../common/in-array';\nconst numberRegex = /^\\d+$/;\nconst alphanumericRegex = /^[a-z0-9]+$/i;\nconst extend = Object.assign;\nexport class State128 extends Class {\n  constructor(encoding) {\n    super();\n    this.encoding = encoding;\n    this.initProperties();\n  }\n\n  initProperties() {}\n\n  addStart() {}\n\n  is() {}\n\n  isCode() {\n    return false;\n  }\n\n  move() {}\n\n  pushState() {}\n\n}\nexport class State128AB extends State128 {\n  constructor(encoding, states) {\n    super(encoding);\n    this.states = states;\n\n    this._initMoves(states);\n  }\n\n  initProperties() {\n    super.initProperties();\n    deepExtend(this, {\n      FNC4: \"FNC4\",\n      SHIFT: 98\n    });\n  }\n\n  addStart() {\n    this.encoding.addPattern(this.START);\n  }\n\n  is(value, index) {\n    let code = value.charCodeAt(index);\n    return this.isCode(code);\n  }\n\n  move(encodingState) {\n    let idx = 0;\n\n    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {\n      idx++;\n    }\n  }\n\n  pushState(encodingState) {\n    let states = this.states,\n        value = encodingState.value,\n        maxLength = value.length,\n        code;\n\n    if (inArray(\"C\", states)) {\n      let numberMatch = value.substr(encodingState.index).match(/\\d{4,}/g);\n\n      if (numberMatch) {\n        maxLength = value.indexOf(numberMatch[0], encodingState.index);\n      }\n    }\n\n    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {\n      this.encoding.addPattern(this.getValue(code));\n      encodingState.index++;\n    }\n  }\n\n  _initMoves(states) {\n    this._moves = [];\n\n    if (inArray(this.FNC4, states)) {\n      this._moves.push(this._moveFNC);\n    }\n\n    if (inArray(this.shiftKey, states)) {\n      this._moves.push(this._shiftState);\n    }\n\n    this._moves.push(this._moveState);\n  }\n\n  _moveFNC(encodingState) {\n    if (encodingState.fnc) {\n      encodingState.fnc = false;\n      return encodingState.previousState === this.key;\n    }\n  }\n\n  _shiftState(encodingState) {\n    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {\n      this.encoding.addPattern(this.SHIFT);\n      encodingState.shifted = true;\n      return true;\n    }\n  }\n\n  _moveState() {\n    this.encoding.addPattern(this.MOVE);\n    return true;\n  }\n\n}\nconst states128 = {};\nstates128.A = class State128A extends State128AB {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      key: \"A\",\n      shiftKey: \"B\",\n      MOVE: 101,\n      START: 103\n    });\n  }\n\n  isCode(code) {\n    return 0 <= code && code < 96;\n  }\n\n  getValue(code) {\n    if (code < 32) {\n      return code + 64;\n    }\n\n    return code - 32;\n  }\n\n};\nstates128.B = class State128B extends State128AB {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      key: \"B\",\n      shiftKey: \"A\",\n      MOVE: 100,\n      START: 104\n    });\n  }\n\n  isCode(code) {\n    return 32 <= code && code < 128;\n  }\n\n  getValue(code) {\n    return code - 32;\n  }\n\n};\nstates128.C = class State128C extends State128 {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      key: \"C\",\n      MOVE: 99,\n      START: 105\n    });\n  }\n\n  addStart() {\n    this.encoding.addPattern(this.START);\n  }\n\n  is(value, index) {\n    let next4 = getSubstring(value, index, 4);\n    return (index + 4 <= value.length || value.length === 2) && numberRegex.test(next4);\n  }\n\n  move() {\n    this.encoding.addPattern(this.MOVE);\n  }\n\n  pushState(encodingState) {\n    let code;\n\n    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex.test(code) && code.length === 2) {\n      this.encoding.addPattern(parseInt(code, 10));\n      encodingState.index += 2;\n    }\n  }\n\n  getValue(code) {\n    return code;\n  }\n\n};\nstates128.FNC4 = class State128FNC4 extends State128 {\n  constructor(encoding, states) {\n    super(encoding);\n\n    this._initSubStates(states);\n  }\n\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      key: \"FNC4\",\n      dependentStates: [\"A\", \"B\"]\n    });\n  }\n\n  addStart(encodingState) {\n    let code = encodingState.value.charCodeAt(0) - 128,\n        subState = this._getSubState(code);\n\n    this.encoding[subState].addStart();\n  }\n\n  is(value, index) {\n    let code = value.charCodeAt(index);\n    return this.isCode(code);\n  }\n\n  isCode(code) {\n    return 128 <= code && code < 256;\n  }\n\n  pushState(encodingState) {\n    let subState = this._initSubState(encodingState),\n        encoding = this.encoding,\n        length = subState.value.length;\n\n    let code;\n    encodingState.index += length;\n\n    if (length < 3) {\n      for (; subState.index < length; subState.index++) {\n        code = subState.value.charCodeAt(subState.index);\n        subState.state = this._getSubState(code);\n\n        if (subState.previousState !== subState.state) {\n          subState.previousState = subState.state;\n          encoding[subState.state].move(subState);\n        }\n\n        encoding.addPattern(encoding[subState.state].MOVE);\n        encoding.addPattern(encoding[subState.state].getValue(code));\n      }\n    } else {\n      if (subState.state !== subState.previousState) {\n        encoding[subState.state].move(subState);\n      }\n\n      this._pushStart(subState);\n\n      encoding.pushData(subState, this.subStates);\n\n      if (encodingState.index < encodingState.value.length) {\n        this._pushStart(subState);\n      }\n    }\n\n    encodingState.fnc = true;\n    encodingState.state = subState.state;\n  }\n\n  _pushStart(subState) {\n    this.encoding.addPattern(this.encoding[subState.state].MOVE);\n    this.encoding.addPattern(this.encoding[subState.state].MOVE);\n  }\n\n  _initSubState(encodingState) {\n    const subState = {\n      value: this._getAll(encodingState.value, encodingState.index),\n      index: 0\n    };\n    subState.state = this._getSubState(subState.value.charCodeAt(0));\n    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;\n    return subState;\n  }\n\n  _initSubStates(states) {\n    this.subStates = [];\n\n    for (let i = 0; i < states.length; i++) {\n      if (inArray(states[i], this.dependentStates)) {\n        this.subStates.push(states[i]);\n      }\n    }\n  }\n\n  _getSubState(code) {\n    for (let i = 0; i < this.subStates.length; i++) {\n      if (this.encoding[this.subStates[i]].isCode(code)) {\n        return this.subStates[i];\n      }\n    }\n  }\n\n  _getAll(value, index) {\n    let code;\n    let result = \"\";\n    let i = index;\n\n    while ((code = value.charCodeAt(i++)) && this.isCode(code)) {\n      result += String.fromCharCode(code - 128);\n    }\n\n    return result;\n  }\n\n};\nstates128.FNC1 = class States128FNC1 extends State128 {\n  constructor(encoding, states) {\n    super(encoding);\n    this.states = states;\n  }\n\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      key: \"FNC1\",\n      startState: \"C\",\n      startAI: \"(\",\n      endAI: \")\",\n      dependentStates: [\"C\", \"B\"],\n      applicationIdentifiers: {\n        \"22\": {\n          max: 29,\n          type: \"alphanumeric\"\n        },\n        \"402\": {\n          length: 17\n        },\n        \"7004\": {\n          max: 4,\n          type: \"alphanumeric\"\n        },\n        \"242\": {\n          max: 6,\n          type: \"alphanumeric\"\n        },\n        \"8020\": {\n          max: 25,\n          type: \"alphanumeric\"\n        },\n        \"703\": {\n          min: 3,\n          max: 30,\n          type: \"alphanumeric\"\n        },\n        \"8008\": {\n          min: 8,\n          max: 12,\n          type: \"alphanumeric\"\n        },\n        \"253\": {\n          min: 13,\n          max: 17,\n          type: \"alphanumeric\"\n        },\n        \"8003\": {\n          min: 14,\n          max: 30,\n          type: \"alphanumeric\"\n        },\n        multiKey: [{\n          ids: [\"15\", \"17\", \"8005\", \"8100\"],\n          ranges: [[11, 13], [310, 316], [320, 336], [340, 369]],\n          type: {\n            length: 6\n          }\n        }, {\n          ids: [\"240\", \"241\", \"250\", \"251\", \"400\", \"401\", \"403\", \"7002\", \"8004\", \"8007\", \"8110\"],\n          ranges: [[90 - 99]],\n          type: {\n            max: 30,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"7001\"],\n          ranges: [[410, 414]],\n          type: {\n            length: 13\n          }\n        }, {\n          ids: [\"10\", \"21\", \"254\", \"420\", \"8002\"],\n          type: {\n            max: 20,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"00\", \"8006\", \"8017\", \"8018\"],\n          type: {\n            length: 18\n          }\n        }, {\n          ids: [\"01\", \"02\", \"8001\"],\n          type: {\n            length: 14\n          }\n        }, {\n          ids: [\"422\"],\n          ranges: [[424, 426]],\n          type: {\n            length: 3\n          }\n        }, {\n          ids: [\"20\", \"8102\"],\n          type: {\n            length: 2\n          }\n        }, {\n          ids: [\"30\", \"37\"],\n          type: {\n            max: 8,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"390\", \"392\"],\n          type: {\n            max: 15,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"421\", \"423\"],\n          type: {\n            min: 3,\n            max: 15,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"391\", \"393\"],\n          type: {\n            min: 3,\n            max: 18,\n            type: \"alphanumeric\"\n          }\n        }, {\n          ids: [\"7003\", \"8101\"],\n          type: {\n            length: 10\n          }\n        }]\n      },\n      START: 102\n    });\n  }\n\n  addStart() {\n    this.encoding[this.startState].addStart();\n  }\n\n  is() {\n    return inArray(this.key, this.states);\n  }\n\n  pushState(encodingState) {\n    let encoding = this.encoding,\n        value = encodingState.value.replace(/\\s/g, \"\"),\n        regexSeparators = new RegExp(\"[\" + this.startAI + this.endAI + \"]\", \"g\"),\n        index = encodingState.index,\n        subState = {\n      state: this.startState\n    },\n        current,\n        nextStart,\n        separatorLength;\n    encoding.addPattern(this.START);\n    const trueCondition = true;\n\n    while (trueCondition) {\n      subState.index = 0;\n      separatorLength = value.charAt(index) === this.startAI ? 2 : 0;\n      current = separatorLength > 0 ? this.getBySeparator(value, index) : this.getByLength(value, index);\n\n      if (current.ai.length) {\n        nextStart = index + separatorLength + current.id.length + current.ai.length;\n      } else {\n        nextStart = value.indexOf(this.startAI, index + 1);\n\n        if (nextStart < 0) {\n          if (index + current.ai.max + current.id.length + separatorLength < value.length) {\n            throw new Error(\"Separators are required after variable length identifiers\");\n          }\n\n          nextStart = value.length;\n        }\n      }\n\n      subState.value = value.substring(index, nextStart).replace(regexSeparators, \"\");\n      this.validate(current, subState.value);\n      encoding.pushData(subState, this.dependentStates);\n\n      if (nextStart >= value.length) {\n        break;\n      }\n\n      index = nextStart;\n\n      if (subState.state !== this.startState) {\n        encoding[this.startState].move(subState);\n        subState.state = this.startState;\n      }\n\n      if (!current.ai.length) {\n        encoding.addPattern(this.START);\n      }\n    }\n\n    encodingState.index = encodingState.value.length;\n  }\n\n  validate(current, value) {\n    let code = value.substr(current.id.length),\n        ai = current.ai;\n\n    if (!ai.type && !numberRegex.test(code)) {\n      throw new Error(\"Application identifier \" + current.id + \" is numeric only but contains non numeric character(s).\");\n    }\n\n    if (ai.type === \"alphanumeric\" && !alphanumericRegex.test(code)) {\n      throw new Error(\"Application identifier \" + current.id + \" is alphanumeric only but contains non alphanumeric character(s).\");\n    }\n\n    if (ai.length && ai.length !== code.length) {\n      throw new Error(\"Application identifier \" + current.id + \" must be \" + ai.length + \" characters long.\");\n    }\n\n    if (ai.min && ai.min > code.length) {\n      throw new Error(\"Application identifier \" + current.id + \" must be at least \" + ai.min + \" characters long.\");\n    }\n\n    if (ai.max && ai.max < code.length) {\n      throw new Error(\"Application identifier \" + current.id + \" must be at most \" + ai.max + \" characters long.\");\n    }\n  }\n\n  getByLength(value, index) {\n    let id;\n    let applicationIdentifier;\n\n    for (let i = 2; i <= 4; i++) {\n      id = getSubstring(value, index, i);\n      applicationIdentifier = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substring(0, id.length - 1));\n\n      if (applicationIdentifier) {\n        return {\n          id: id,\n          ai: applicationIdentifier\n        };\n      }\n    }\n\n    this.unsupportedAIError(id);\n  }\n\n  unsupportedAIError(id) {\n    throw new Error(\"'\" + id + \"' is not a supported Application Identifier\");\n  }\n\n  getBySeparator(value, index) {\n    let start = value.indexOf(this.startAI, index),\n        end = value.indexOf(this.endAI, start),\n        id = value.substring(start + 1, end),\n        ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));\n\n    if (!ai) {\n      this.unsupportedAIError(id);\n    }\n\n    return {\n      ai: ai,\n      id: id\n    };\n  }\n\n  getApplicationIdentifier(id) {\n    let applicationIdentifier = this.applicationIdentifiers,\n        multiKey = applicationIdentifier.multiKey;\n\n    if (applicationIdentifier[id]) {\n      return applicationIdentifier[id];\n    }\n\n    for (let i = 0; i < multiKey.length; i++) {\n      if (multiKey[i].ids && inArray(id, multiKey[i].ids)) {\n        return multiKey[i].type;\n      } else if (multiKey[i].ranges) {\n        let ranges = multiKey[i].ranges;\n\n        for (let j = 0; j < ranges.length; j++) {\n          if (ranges[j][0] <= id && id <= ranges[j][1]) {\n            return multiKey[i].type;\n          }\n        }\n      }\n    }\n  }\n\n};\nexport class Code128Base extends Encoding {\n  constructor(options) {\n    super(options);\n\n    this._initStates();\n  }\n\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      characterMap: [212222, 222122, 222221, 121223, 121322, 131222, 122213, 122312, 132212, 221213, 221312, 231212, 112232, 122132, 122231, 113222, 123122, 123221, 223211, 221132, 221231, 213212, 223112, 312131, 311222, 321122, 321221, 312212, 322112, 322211, 212123, 212321, 232121, 111323, 131123, 131321, 112313, 132113, 132311, 211313, 231113, 231311, 112133, 112331, 132131, 113123, 113321, 133121, 313121, 211331, 231131, 213113, 213311, 213131, 311123, 311321, 331121, 312113, 312311, 332111, 314111, 221411, 431111, 111224, 111422, 121124, 121421, 141122, 141221, 112214, 112412, 122114, 122411, 142112, 142211, 241211, 221114, 413111, 241112, 134111, 111242, 121142, 121241, 114212, 124112, 124211, 411212, 421112, 421211, 212141, 214121, 412121, 111143, 111341, 131141, 114113, 114311, 411113, 411311, 113141, 114131, 311141, 411131, 211412, 211214, 211232, 2331112],\n      STOP: 106\n    });\n  }\n\n  _initStates() {\n    for (let i = 0; i < this.states.length; i++) {\n      this[this.states[i]] = new states128[this.states[i]](this, this.states);\n    }\n  }\n\n  initValue(value, width, height) {\n    this.pattern = [];\n    this.value = value;\n    this.width = width;\n    this.height = height;\n    this.checkSum = 0;\n    this.totalUnits = 0;\n    this.index = 0;\n    this.position = 1;\n  }\n\n  addData() {\n    let encodingState = {\n      value: this.value,\n      index: 0,\n      state: \"\"\n    };\n\n    if (this.value.length === 0) {\n      return;\n    }\n\n    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);\n    this.addStart(encodingState);\n    this.pushData(encodingState, this.states);\n    this.addCheckSum();\n    this.addStop();\n    this.setBaseUnit();\n  }\n\n  pushData(encodingState, states) {\n    const trueCondition = true;\n\n    while (trueCondition) {\n      this[encodingState.state].pushState(encodingState);\n\n      if (encodingState.index >= encodingState.value.length) {\n        break;\n      }\n\n      if (!encodingState.shifted) {\n        encodingState.previousState = encodingState.state;\n        encodingState.state = this.getNextState(encodingState, states);\n        this[encodingState.state].move(encodingState);\n      } else {\n        let temp = encodingState.state;\n        encodingState.state = encodingState.previousState;\n        encodingState.previousState = temp;\n        encodingState.shifted = false;\n      }\n    }\n  }\n\n  addStart(encodingState) {\n    this[encodingState.state].addStart(encodingState);\n    this.position = 1;\n  }\n\n  addCheckSum() {\n    this.checksum = this.checkSum % 103;\n    this.addPattern(this.checksum);\n  }\n\n  addStop() {\n    this.addPattern(this.STOP);\n  }\n\n  setBaseUnit() {\n    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);\n  }\n\n  addPattern(code) {\n    const pattern = this.characterMap[code].toString();\n    let value;\n\n    for (let i = 0; i < pattern.length; i++) {\n      value = parseInt(pattern.charAt(i), 10);\n      this.pattern.push(value);\n      this.totalUnits += value;\n    }\n\n    this.checkSum += code * this.position++;\n  }\n\n  getNextState(encodingState, states) {\n    for (let i = 0; i < states.length; i++) {\n      if (this[states[i]].is(encodingState.value, encodingState.index)) {\n        return states[i];\n      }\n    }\n\n    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));\n  }\n\n}\nexport class Code128a extends Code128Base {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      name: \"Code 128 A\",\n      states: [\"A\"]\n    });\n  }\n\n}\nexport class Code128b extends Code128Base {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      name: \"Code 128 B\",\n      states: [\"B\"]\n    });\n  }\n\n}\nexport class Code128c extends Code128Base {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      name: \"Code 128 C\",\n      states: [\"C\"]\n    });\n  }\n\n}\nexport class Code128 extends Code128Base {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      name: \"Code 128\",\n      states: [\"C\", \"B\", \"A\", \"FNC4\"]\n    });\n  }\n\n}\nexport class CodeGS1128 extends Code128Base {\n  initProperties() {\n    super.initProperties();\n    extend(this, {\n      name: \"Code GS1-128\",\n      states: [\"FNC1\", \"C\", \"B\"]\n    });\n  }\n\n}\n\nfunction getSubstring(value, index, count) {\n  return value.substring(index, index + count);\n}","map":null,"metadata":{},"sourceType":"module"}