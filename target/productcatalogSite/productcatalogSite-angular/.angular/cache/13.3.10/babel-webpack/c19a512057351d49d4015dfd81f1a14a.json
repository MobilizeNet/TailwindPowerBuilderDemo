{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1659);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1659:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1660)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        kendo.PDFMixin = {\n          extend: function (proto) {\n            proto.events.push(\"pdfExport\");\n            proto.options.pdf = this.options;\n            proto.saveAsPDF = this.saveAsPDF;\n            proto._drawPDF = this._drawPDF;\n            proto._drawPDFShadow = this._drawPDFShadow;\n          },\n          options: {\n            fileName: \"Export.pdf\",\n            proxyURL: \"\",\n            // paperSize can be an usual name, i.e. \"A4\", or an array of two Number-s specifying the\n            // width/height in points (1pt = 1/72in), or strings including unit, i.e. \"10mm\".  Supported\n            // units are \"mm\", \"cm\", \"in\" and \"pt\".  The default \"auto\" means paper size is determined\n            // by content.\n            paperSize: \"auto\",\n            // Export all pages, if applicable\n            allPages: false,\n            // True to reverse the paper dimensions if needed such that width is the larger edge.\n            landscape: false,\n            // An object containing { left, top, bottom, right } margins with units.\n            margin: null,\n            // Optional information for the PDF Info dictionary; all strings except for the date.\n            title: null,\n            author: null,\n            subject: null,\n            keywords: null,\n            creator: \"Kendo UI PDF Generator v.\" + kendo.version,\n            // Creation Date; defaults to new Date()\n            date: null\n          },\n          saveAsPDF: function () {\n            var progress = new $.Deferred();\n            var promise = progress.promise();\n            var args = {\n              promise: promise\n            };\n\n            if (this.trigger(\"pdfExport\", args)) {\n              return;\n            }\n\n            var options = this.options.pdf;\n            options.multiPage = options.multiPage || options.allPages;\n\n            this._drawPDF(progress).then(function (root) {\n              return kendo.drawing.exportPDF(root, options);\n            }).done(function (dataURI) {\n              kendo.saveAs({\n                dataURI: dataURI,\n                fileName: options.fileName,\n                proxyURL: options.proxyURL,\n                forceProxy: options.forceProxy,\n                proxyTarget: options.proxyTarget\n              });\n              progress.resolve();\n            }).fail(function (err) {\n              progress.reject(err);\n            });\n\n            return promise;\n          },\n          _drawPDF: function (progress) {\n            var promise = new $.Deferred();\n            kendo.drawing.drawDOM(this.wrapper).done(function (group) {\n              var args = {\n                page: group,\n                pageNumber: 1,\n                progress: 1,\n                totalPages: 1\n              };\n              progress.notify(args);\n              promise.resolve(args.page);\n            }).fail(function (err) {\n              promise.reject(err);\n            });\n            return promise;\n          },\n          _drawPDFShadow: function (settings, drawOptions) {\n            settings = settings || {};\n            var wrapper = this.wrapper;\n            var shadow = $(\"<div class='k-pdf-export-shadow'>\"); // Content will be allowed to take up to 200\" if no width is given.\n\n            if (settings.width) {\n              shadow.css({\n                width: settings.width,\n                overflow: \"visible\"\n              });\n            }\n\n            wrapper.before(shadow);\n            shadow.append(settings.content || wrapper.clone(true, true));\n            var defer = $.Deferred();\n            /* https://github.com/telerik/kendo/issues/4790 -- We need to\n             * allow a small timeout so that the browser finalizes the\n             * layout of any images here.  Another option would be to pass\n             * forcePageBreak: \"-\" to drawDOM, but that would make it\n             * clone the content as well and look for page breaks;\n             * needless work, so better do it here.\n             */\n\n            setTimeout(function () {\n              var promise = kendo.drawing.drawDOM(shadow, drawOptions);\n              promise.always(function () {\n                shadow.remove();\n              }).then(function () {\n                defer.resolve.apply(defer, arguments);\n              }).fail(function () {\n                defer.reject.apply(defer, arguments);\n              }).progress(function () {\n                defer.progress.apply(defer, arguments);\n              });\n            }, 15);\n            return defer.promise();\n          }\n        };\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1660:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./core\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}