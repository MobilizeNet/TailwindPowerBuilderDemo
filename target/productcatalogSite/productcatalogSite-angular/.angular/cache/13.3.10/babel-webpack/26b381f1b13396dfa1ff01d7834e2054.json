{"ast":null,"code":"import CategoricalChart from '../categorical-chart';\nimport BarChart from '../bar-chart/bar-chart';\nimport Bullet from './bullet';\nimport ClusterLayout from '../layout/cluster-layout';\nimport { BAR } from '../constants';\nimport { MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { deepExtend, defined, isArray, isFunction, isObject, setDefaultOptions } from '../../common';\n\nclass BulletChart extends CategoricalChart {\n  constructor(plotArea, options) {\n    wrapData(options);\n    super(plotArea, options);\n  }\n\n  reflowCategories(categorySlots) {\n    const children = this.children;\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      children[i].reflow(categorySlots[i]);\n    }\n  }\n\n  plotRange(point) {\n    const series = point.series;\n    const valueAxis = this.seriesValueAxis(series);\n    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, point.value.current || axisCrossingValue];\n  }\n\n  createPoint(data, fields) {\n    const {\n      categoryIx,\n      category,\n      series,\n      seriesIx\n    } = fields;\n    const {\n      options,\n      children\n    } = this;\n    const value = data.valueFields;\n    let bulletOptions = deepExtend({\n      vertical: !options.invertAxes,\n      overlay: series.overlay,\n      categoryIx: categoryIx,\n      invertAxes: options.invertAxes\n    }, series);\n    let color = data.fields.color || series.color;\n    bulletOptions = this.evalPointOptions(bulletOptions, value, category, categoryIx, series, seriesIx);\n\n    if (isFunction(series.color)) {\n      color = bulletOptions.color;\n    }\n\n    const bullet = new Bullet(value, bulletOptions);\n    bullet.color = color;\n    let cluster = children[categoryIx];\n\n    if (!cluster) {\n      cluster = new ClusterLayout({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n\n    cluster.append(bullet);\n    return bullet;\n  }\n\n  updateRange(value, fields) {\n    const {\n      current,\n      target\n    } = value;\n    const axisName = fields.series.axis;\n    let axisRange = this.valueAxisRanges[axisName];\n\n    if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, current, target);\n      axisRange.max = Math.max(axisRange.max, current, target);\n    }\n  }\n\n  formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value.current, point.value.target);\n  }\n\n  pointValue(data) {\n    return data.valueFields.current;\n  }\n\n  aboveAxis(point) {\n    const value = point.value.current;\n    return value > 0;\n  }\n\n  createAnimation() {\n    const points = this.points;\n\n    this._setAnimationOptions();\n\n    for (let idx = 0; idx < points.length; idx++) {\n      const point = points[idx];\n      point.options.animation = this.options.animation;\n      point.createAnimation();\n    }\n  }\n\n}\n\nBulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;\nsetDefaultOptions(BulletChart, {\n  animation: {\n    type: BAR\n  }\n});\n\nfunction wrapData(options) {\n  const series = options.series;\n\n  for (let i = 0; i < series.length; i++) {\n    const seriesItem = series[i];\n    const data = seriesItem.data;\n\n    if (data && !isArray(data[0]) && !isObject(data[0])) {\n      seriesItem.data = [data];\n    }\n  }\n}\n\nexport default BulletChart;","map":null,"metadata":{},"sourceType":"module"}