{"ast":null,"code":"import { Class, deepExtend, deg, rad, round, defined } from '../common';\nimport { datums } from './datums';\n\nfunction toSquare(value) {\n  return value * value;\n}\n\nlet math = Math,\n    abs = math.abs,\n    atan = math.atan,\n    atan2 = math.atan2,\n    cos = math.cos,\n    sin = math.sin,\n    tan = math.tan;\nexport class Location extends Class {\n  constructor(lat, lng) {\n    super();\n    this.initProperties();\n\n    if (arguments.length === 1) {\n      this.lat = lat[0];\n      this.lng = lat[1];\n    } else {\n      this.lat = lat;\n      this.lng = lng;\n    }\n  }\n\n  initProperties() {\n    deepExtend(this, {\n      DISTANCE_ITERATIONS: 100,\n      DISTANCE_CONVERGENCE: 1e-12,\n      DISTANCE_PRECISION: 2,\n      FORMAT: '{0:N6}{1:N6}'\n    });\n  }\n\n  toArray() {\n    return [this.lat, this.lng];\n  }\n\n  equals(loc) {\n    return loc && loc.lat === this.lat && loc.lng === this.lng;\n  }\n\n  clone() {\n    return new Location(this.lat, this.lng);\n  }\n\n  round(precision) {\n    this.lng = round(this.lng, precision);\n    this.lat = round(this.lat, precision);\n    return this;\n  }\n\n  wrap() {\n    this.lng = this.lng % 180;\n    this.lat = this.lat % 90;\n    return this;\n  }\n\n  distanceTo(dest, datum) {\n    return this.greatCircleTo(dest, datum).distance;\n  }\n\n  destination(distance, initialBearing, initialDatum) {\n    let bearing = rad(initialBearing);\n    let datum = initialDatum || datums.WGS84;\n    let fromLat = rad(this.lat);\n    let fromLng = rad(this.lng);\n    let dToR = distance / datum.a;\n    let lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));\n    let lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));\n    return new Location(deg(lat), deg(lng));\n  }\n\n  greatCircleTo(initialDest, initialDatum) {\n    let dest = Location.create(dest);\n    let datum = initialDatum || datums.WGS84;\n\n    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {\n      return {\n        distance: 0,\n        azimuthFrom: 0,\n        azimuthTo: 0\n      };\n    } // See http://en.wikipedia.org/wiki/Vincenty's_formulae#Notation\n    // o == sigma\n    // A == alpha\n\n\n    let a = datum.a;\n    let b = datum.b;\n    let f = datum.f;\n    let L = rad(dest.lng - this.lng);\n    let U1 = atan((1 - f) * tan(rad(this.lat)));\n    let sinU1 = sin(U1);\n    let cosU1 = cos(U1);\n    let U2 = atan((1 - f) * tan(rad(dest.lat)));\n    let sinU2 = sin(U2);\n    let cosU2 = cos(U2);\n    let lambda = L;\n    let prevLambda;\n    let i = this.DISTANCE_ITERATIONS;\n    let converged = false;\n    let sinLambda;\n    let cosLambda;\n    let sino;\n    let cosA2;\n    let coso;\n    let cos2om;\n    let sigma;\n\n    while (!converged && i-- > 0) {\n      sinLambda = sin(lambda);\n      cosLambda = cos(lambda);\n      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n      sigma = atan2(sino, coso);\n      let sinA = cosU1 * cosU2 * sinLambda / sino;\n      cosA2 = 1 - toSquare(sinA);\n      cos2om = 0;\n\n      if (cosA2 !== 0) {\n        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;\n      }\n\n      prevLambda = lambda;\n      let C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));\n      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));\n      converged = abs(lambda - prevLambda) <= this.DISTANCE_CONVERGENCE;\n    }\n\n    let u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);\n    let A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n    let B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n    let deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));\n    let azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);\n    let azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);\n    return {\n      distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),\n      azimuthFrom: deg(azimuthFrom),\n      azimuthTo: deg(azimuthTo)\n    };\n  } // IE < 9 doesn't allow to override toString on definition\n\n\n  toString() {\n    // return kendo.format(this.FORMAT, this.lat, this.lng);\n    return String(this.lat) + \",\" + String(this.lng);\n  }\n\n  static fromLngLat(lngAndLat) {\n    return new Location(lngAndLat[1], lngAndLat[0]);\n  }\n\n  static fromLatLng(lngAndLat) {\n    return new Location(lngAndLat[0], lngAndLat[1]);\n  }\n\n  static create(a, b) {\n    if (defined(a)) {\n      if (a instanceof Location) {\n        return a.clone();\n      } else if (arguments.length === 1 && a.length === 2) {\n        return Location.fromLatLng(a);\n      }\n\n      return new Location(a, b);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}