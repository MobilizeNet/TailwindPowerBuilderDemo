{"ast":null,"code":"import { DomEventsBuilder } from '../services';\nimport { DateCategoryAxis, Point } from '../core';\nimport { MOUSEWHEEL_DELAY, MOUSEWHEEL, SELECT_START, SELECT, SELECT_END } from './constants';\nimport { LEFT, RIGHT, MIN_VALUE, MAX_VALUE, X } from '../common/constants';\nimport { addClass, Class, removeClass, eventCoordinates, deepExtend, elementStyles, eventElement, setDefaultOptions, limitValue, round, bindEvents, unbindEvents, mousewheelDelta, hasClasses } from '../common';\nimport { parseDate } from '../date-utils';\nconst ZOOM_ACCELERATION = 3;\nconst SELECTOR_HEIGHT_ADJUST = 0.1;\n\nfunction createDiv(classNames) {\n  const element = document.createElement(\"div\");\n\n  if (classNames) {\n    element.className = classNames;\n  }\n\n  return element;\n}\n\nfunction closestHandle(element) {\n  let current = element;\n\n  while (current && !hasClasses(current, \"k-handle\")) {\n    current = current.parentNode;\n  }\n\n  return current;\n}\n\nclass Selection extends Class {\n  constructor(chart, categoryAxis, options, observer) {\n    super();\n    const chartElement = chart.element;\n    this.options = deepExtend({}, this.options, options);\n    this.chart = chart;\n    this.observer = observer;\n    this.chartElement = chartElement;\n    this.categoryAxis = categoryAxis;\n    this._dateAxis = this.categoryAxis instanceof DateCategoryAxis;\n    this.initOptions();\n    this.visible = this.options.visible && chartElement.offsetHeight;\n\n    if (this.visible) {\n      this.createElements();\n      this.set(this._index(this.options.from), this._index(this.options.to));\n      this.bindEvents();\n    }\n  }\n\n  onPane(pane) {\n    return this.categoryAxis.pane === pane;\n  }\n\n  createElements() {\n    const options = this.options;\n    const wrapper = this.wrapper = createDiv(\"k-selector k-pointer-events-none\");\n    elementStyles(wrapper, {\n      top: options.offset.top,\n      left: options.offset.left,\n      width: options.width,\n      height: options.height,\n      direction: 'ltr'\n    });\n    const selection = this.selection = createDiv(\"k-selection k-pointer-events-none\");\n    this.leftMask = createDiv(\"k-mask k-pointer-events-none\");\n    this.rightMask = createDiv(\"k-mask k-pointer-events-none\");\n    wrapper.appendChild(this.leftMask);\n    wrapper.appendChild(this.rightMask);\n    wrapper.appendChild(selection);\n    const body = this.body = createDiv(\"k-selection-bg k-pointer-events-none\");\n    selection.appendChild(body);\n    const leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle k-pointer-events-auto\");\n    const rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle k-pointer-events-auto\");\n    leftHandle.appendChild(createDiv());\n    rightHandle.appendChild(createDiv());\n    selection.appendChild(leftHandle);\n    selection.appendChild(rightHandle);\n    this.chartElement.appendChild(wrapper);\n    const selectionStyles = elementStyles(selection, [\"borderLeftWidth\", \"borderRightWidth\", \"height\"]);\n    const leftHandleHeight = elementStyles(leftHandle, \"height\").height;\n    const rightHandleHeight = elementStyles(rightHandle, \"height\").height;\n    options.selection = {\n      border: {\n        left: selectionStyles.borderLeftWidth,\n        right: selectionStyles.borderRightWidth\n      }\n    };\n    elementStyles(leftHandle, {\n      top: (selectionStyles.height - leftHandleHeight) / 2\n    });\n    elementStyles(rightHandle, {\n      top: (selectionStyles.height - rightHandleHeight) / 2\n    });\n    wrapper.style.cssText = wrapper.style.cssText;\n  }\n\n  bindEvents() {\n    if (this.options.mousewheel !== false) {\n      this._mousewheelHandler = this._mousewheel.bind(this);\n      bindEvents(this.chartElement, {\n        [MOUSEWHEEL]: this._mousewheelHandler\n      });\n    }\n\n    this._domEvents = DomEventsBuilder.create(this.chartElement, {\n      stopPropagation: true,\n      // applicable for the jQuery UserEvents\n      start: this._start.bind(this),\n      move: this._move.bind(this),\n      end: this._end.bind(this),\n      tap: this._tap.bind(this),\n      press: this._press.bind(this),\n      gesturestart: this._gesturestart.bind(this),\n      gesturechange: this._gesturechange.bind(this),\n      gestureend: this._gestureend.bind(this)\n    });\n  }\n\n  initOptions() {\n    const {\n      options,\n      categoryAxis\n    } = this;\n    const box = categoryAxis.pane.chartsBox();\n    const intlService = this.chart.chartService.intl;\n\n    if (this._dateAxis) {\n      deepExtend(options, {\n        min: parseDate(intlService, options.min),\n        max: parseDate(intlService, options.max),\n        from: parseDate(intlService, options.from),\n        to: parseDate(intlService, options.to)\n      });\n    }\n\n    const {\n      paddingLeft,\n      paddingTop\n    } = elementStyles(this.chartElement, [\"paddingLeft\", \"paddingTop\"]);\n    this.options = deepExtend({}, {\n      width: box.width(),\n      height: box.height() + SELECTOR_HEIGHT_ADJUST,\n      //workaround for sub-pixel hover on the paths in chrome\n      padding: {\n        left: paddingLeft,\n        top: paddingTop\n      },\n      offset: {\n        left: box.x1 + paddingLeft,\n        top: box.y1 + paddingTop\n      },\n      from: options.min,\n      to: options.max\n    }, options);\n  }\n\n  destroy() {\n    if (this._domEvents) {\n      this._domEvents.destroy();\n\n      delete this._domEvents;\n    }\n\n    clearTimeout(this._mwTimeout);\n    this._state = null;\n\n    if (this.wrapper) {\n      if (this._mousewheelHandler) {\n        unbindEvents(this.chartElement, {\n          [MOUSEWHEEL]: this._mousewheelHandler\n        });\n        this._mousewheelHandler = null;\n      }\n\n      this.chartElement.removeChild(this.wrapper);\n      this.wrapper = null;\n    }\n  }\n\n  _rangeEventArgs(range) {\n    return {\n      axis: this.categoryAxis.options,\n      from: this._value(range.from),\n      to: this._value(range.to)\n    };\n  }\n\n  _pointInPane(x, y) {\n    const paneBox = this.categoryAxis.pane.box;\n\n    const modelCoords = this.chart._toModelCoordinates(x, y);\n\n    return paneBox.containsPoint(modelCoords);\n  }\n\n  _start(e) {\n    const options = this.options;\n    const target = eventElement(e);\n\n    if (this._state || !target) {\n      return;\n    }\n\n    const coords = eventCoordinates(e);\n\n    const inPane = this._pointInPane(coords.x, coords.y);\n\n    if (!inPane) {\n      return;\n    }\n\n    const handle = closestHandle(target);\n    const bodyRect = this.body.getBoundingClientRect();\n    const inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;\n\n    this.chart._unsetActivePoint();\n\n    this._state = {\n      moveTarget: handle,\n      startLocation: e.x ? e.x.location : 0,\n      inBody,\n      range: {\n        from: this._index(options.from),\n        to: this._index(options.to)\n      }\n    };\n\n    const args = this._rangeEventArgs({\n      from: this._index(options.from),\n      to: this._index(options.to)\n    });\n\n    if (this.trigger(SELECT_START, args)) {\n      this._state = null;\n    }\n  }\n\n  _press(e) {\n    let handle;\n\n    if (this._state) {\n      handle = this._state.moveTarget;\n    } else {\n      handle = closestHandle(eventElement(e));\n    }\n\n    if (handle) {\n      addClass(handle, \"k-handle-active\");\n    }\n  }\n\n  _move(e) {\n    if (!this._state) {\n      return;\n    }\n\n    const {\n      _state: state,\n      options,\n      categoryAxis\n    } = this;\n    const {\n      range,\n      moveTarget: target\n    } = state;\n    const reverse = categoryAxis.options.reverse;\n\n    const from = this._index(options.from);\n\n    const to = this._index(options.to);\n\n    const min = this._index(options.min);\n\n    const max = this._index(options.max);\n\n    const delta = state.startLocation - e.x.location;\n    const oldRange = {\n      from: range.from,\n      to: range.to\n    };\n    const span = range.to - range.from;\n    const scale = elementStyles(this.wrapper, \"width\").width / (categoryAxis.categoriesCount() - 1);\n    const offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n\n    if (!target && !state.inBody) {\n      return;\n    }\n\n    const leftHandle = target && hasClasses(target, \"k-left-handle\");\n    const rightHandle = target && hasClasses(target, \"k-right-handle\");\n\n    if (state.inBody) {\n      range.from = Math.min(Math.max(min, from - offset), max - span);\n      range.to = Math.min(range.from + span, max);\n    } else if (leftHandle && !reverse || rightHandle && reverse) {\n      range.from = Math.min(Math.max(min, from - offset), max - 1);\n      range.to = Math.max(range.from + 1, range.to);\n    } else if (leftHandle && reverse || rightHandle && !reverse) {\n      range.to = Math.min(Math.max(min + 1, to - offset), max);\n      range.from = Math.min(range.to - 1, range.from);\n    }\n\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.move(range.from, range.to);\n      this.trigger(SELECT, this._rangeEventArgs(range));\n    }\n  }\n\n  _end() {\n    if (this._state) {\n      const moveTarget = this._state.moveTarget;\n\n      if (moveTarget) {\n        removeClass(moveTarget, \"k-handle-active\");\n      }\n\n      const range = this._state.range;\n      this.set(range.from, range.to);\n      this.trigger(SELECT_END, this._rangeEventArgs(range));\n      delete this._state;\n    }\n  }\n\n  _tap(e) {\n    const {\n      options,\n      categoryAxis\n    } = this;\n\n    const coords = this.chart._eventCoordinates(e);\n\n    const categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\n\n    const from = this._index(options.from);\n\n    const to = this._index(options.to);\n\n    const min = this._index(options.min);\n\n    const max = this._index(options.max);\n\n    const span = to - from;\n    const mid = from + span / 2;\n    const range = {};\n    const rightClick = e.event.which === 3;\n    let offset = Math.round(mid - categoryIx);\n\n    if (this._state || rightClick) {\n      return;\n    }\n\n    this.chart._unsetActivePoint();\n\n    if (!categoryAxis.options.justified) {\n      offset--;\n    }\n\n    range.from = Math.min(Math.max(min, from - offset), max - span);\n    range.to = Math.min(range.from + span, max);\n\n    this._start(e);\n\n    if (this._state) {\n      this._state.range = range;\n      this.trigger(SELECT, this._rangeEventArgs(range));\n\n      this._end();\n    }\n  }\n\n  _mousewheel(e) {\n    let delta = mousewheelDelta(e);\n\n    this._start(e);\n\n    if (this._state) {\n      const range = this._state.range;\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (Math.abs(delta) > 1) {\n        delta *= ZOOM_ACCELERATION;\n      }\n\n      if (this.options.mousewheel.reverse) {\n        delta *= -1;\n      }\n\n      if (this.expand(delta)) {\n        this.trigger(SELECT, {\n          axis: this.categoryAxis.options,\n          delta: delta,\n          originalEvent: e,\n          from: this._value(range.from),\n          to: this._value(range.to)\n        });\n      }\n\n      if (this._mwTimeout) {\n        clearTimeout(this._mwTimeout);\n      }\n\n      this._mwTimeout = setTimeout(() => {\n        this._end();\n      }, MOUSEWHEEL_DELAY);\n    }\n  }\n\n  _gesturestart(e) {\n    const options = this.options;\n    const touch = e.touches[0];\n\n    const inPane = this._pointInPane(touch.pageX, touch.pageY);\n\n    if (!inPane) {\n      return;\n    }\n\n    this._state = {\n      range: {\n        from: this._index(options.from),\n        to: this._index(options.to)\n      }\n    };\n\n    const args = this._rangeEventArgs(this._state.range);\n\n    if (this.trigger(SELECT_START, args)) {\n      this._state = null;\n    } else {\n      e.preventDefault();\n    }\n  }\n\n  _gestureend() {\n    if (this._state) {\n      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n      delete this._state;\n    }\n  }\n\n  _gesturechange(e) {\n    if (!this._state) {\n      return;\n    }\n\n    const {\n      chart,\n      _state: state,\n      options,\n      categoryAxis\n    } = this;\n    const range = state.range;\n\n    const p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n\n    const p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n\n    const left = Math.min(p0, p1);\n    const right = Math.max(p0, p1);\n    e.preventDefault();\n    range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\n    range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\n    this.move(range.from, range.to);\n    this.trigger(SELECT, this._rangeEventArgs(range));\n  }\n\n  _index(value) {\n    let index = value;\n\n    if (value instanceof Date) {\n      index = this.categoryAxis.categoryIndex(value);\n    }\n\n    return index;\n  }\n\n  _value(index) {\n    let value = index;\n\n    if (this._dateAxis) {\n      value = this.categoryAxis.categoryAt(index);\n\n      if (value > this.options.max) {\n        value = this.options.max;\n      }\n    }\n\n    return value;\n  }\n\n  _slot(value) {\n    const categoryAxis = this.categoryAxis;\n\n    const index = this._index(value);\n\n    return categoryAxis.getSlot(index, index, true);\n  }\n\n  move(from, to) {\n    const options = this.options;\n    const reverse = this.categoryAxis.options.reverse;\n    const {\n      offset,\n      padding,\n      selection: {\n        border\n      }\n    } = options;\n    const left = reverse ? to : from;\n    const right = reverse ? from : to;\n    const edge = 'x' + (reverse ? 2 : 1);\n\n    let box = this._slot(left);\n\n    const leftMaskWidth = round(box[edge] - offset.left + padding.left);\n    elementStyles(this.leftMask, {\n      width: leftMaskWidth\n    });\n    elementStyles(this.selection, {\n      left: leftMaskWidth\n    });\n    box = this._slot(right);\n    const rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n    elementStyles(this.rightMask, {\n      width: rightMaskWidth\n    });\n    let distance = options.width - rightMaskWidth;\n\n    if (distance !== options.width) {\n      distance += border.right;\n    }\n\n    elementStyles(this.rightMask, {\n      left: distance\n    });\n    elementStyles(this.selection, {\n      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n    });\n  }\n\n  set(from, to) {\n    const options = this.options;\n\n    const min = this._index(options.min);\n\n    const max = this._index(options.max);\n\n    const fromValue = limitValue(this._index(from), min, max);\n    const toValue = limitValue(this._index(to), fromValue + 1, max);\n\n    if (options.visible) {\n      this.move(fromValue, toValue);\n    }\n\n    options.from = this._value(fromValue);\n    options.to = this._value(toValue);\n  }\n\n  expand(delta) {\n    const options = this.options;\n\n    const min = this._index(options.min);\n\n    const max = this._index(options.max);\n\n    const zDir = options.mousewheel.zoom;\n\n    const from = this._index(options.from);\n\n    const to = this._index(options.to);\n\n    let range = {\n      from: from,\n      to: to\n    };\n    const oldRange = deepExtend({}, range);\n\n    if (this._state) {\n      range = this._state.range;\n    }\n\n    if (zDir !== RIGHT) {\n      range.from = limitValue(limitValue(from - delta, 0, to - 1), min, max);\n    }\n\n    if (zDir !== LEFT) {\n      range.to = limitValue(limitValue(to + delta, range.from + 1, max), min, max);\n    }\n\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.set(range.from, range.to);\n      return true;\n    }\n  }\n\n  zoom(delta, coords) {\n    const options = this.options;\n\n    const min = this._index(options.min);\n\n    const max = this._index(options.max);\n\n    const from = this._index(options.from);\n\n    const to = this._index(options.to);\n\n    let range = {\n      from: from,\n      to: to\n    };\n    const oldRange = deepExtend({}, range);\n    const {\n      reverse\n    } = this.categoryAxis.options;\n    const origin = X + (reverse ? '2' : '1');\n    const lineBox = this.categoryAxis.lineBox();\n    const relative = Math.abs(lineBox[origin] - coords[X]);\n    const size = lineBox.width();\n    const position = round(relative / size, 2);\n    const minDelta = round(position * delta);\n    const maxDelta = round((1 - position) * delta);\n\n    if (this._state) {\n      range = this._state.range;\n    }\n\n    range.from = limitValue(limitValue(from - minDelta, 0, to - 1), min, max);\n    range.to = limitValue(limitValue(to + maxDelta, range.from + 1, max), min, max);\n\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.set(range.from, range.to);\n      return true;\n    }\n  }\n\n  trigger(name, args) {\n    return (this.observer || this.chart).trigger(name, args);\n  }\n\n}\n\nsetDefaultOptions(Selection, {\n  visible: true,\n  mousewheel: {\n    zoom: \"both\"\n  },\n  min: MIN_VALUE,\n  max: MAX_VALUE\n});\nexport default Selection;","map":null,"metadata":{},"sourceType":"module"}