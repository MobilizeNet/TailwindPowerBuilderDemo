{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(938);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  922:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./location\");\n    /***/\n  },\n\n  /***/\n  938:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(939), __webpack_require__(922)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var doc = document,\n            math = Math,\n            min = math.min,\n            pow = math.pow,\n            kendo = window.kendo,\n            Widget = kendo.ui.Widget,\n            deepExtend = kendo.deepExtend,\n            dataviz = kendo.dataviz,\n            ui = dataviz.ui,\n            g = kendo.geometry,\n            Point = g.Point,\n            map = dataviz.map,\n            Extent = map.Extent,\n            Location = map.Location,\n            EPSG3857 = map.crs.EPSG3857,\n            util = kendo.util,\n            renderPos = util.renderPos,\n            drawingUtil = kendo.drawing.util,\n            defined = drawingUtil.defined,\n            limit = drawingUtil.limitValue,\n            valueOrDefault = drawingUtil.valueOrDefault; // Constants ==============================================================\n\n        var CSS_PREFIX = \"k-\",\n            FRICTION = 0.90,\n            FRICTION_MOBILE = 0.93,\n            MOUSEWHEEL = \"DOMMouseScroll mousewheel\",\n            VELOCITY_MULTIPLIER = 5,\n            DEFAULT_ZOOM_RATE = 1; // Map widget =============================================================\n\n        var Map = Widget.extend({\n          init: function (element, options) {\n            kendo.destroy(element);\n            Widget.fn.init.call(this, element);\n\n            this._initOptions(options);\n\n            this.bind(this.events, options);\n            this.crs = new EPSG3857();\n            this.element.addClass(CSS_PREFIX + this.options.name.toLowerCase()).css(\"position\", \"relative\").empty().append(doc.createElement(\"div\"));\n            this._viewOrigin = this._getOrigin();\n\n            this._initScroller();\n\n            this._initMarkers();\n\n            this._initControls();\n\n            this._initLayers();\n\n            this._reset();\n\n            this._mousewheel = this._mousewheel.bind(this);\n            this.element.on(MOUSEWHEEL, this._mousewheel);\n          },\n          options: {\n            name: \"Map\",\n            controls: {\n              attribution: true,\n              navigator: {\n                panStep: 100\n              },\n              zoom: true\n            },\n            layers: [],\n            layerDefaults: {\n              shape: {\n                style: {\n                  fill: {\n                    color: \"#fff\"\n                  },\n                  stroke: {\n                    color: \"#aaa\",\n                    width: 0.5\n                  }\n                }\n              },\n              bubble: {\n                style: {\n                  fill: {\n                    color: \"#fff\",\n                    opacity: 0.5\n                  },\n                  stroke: {\n                    color: \"#aaa\",\n                    width: 0.5\n                  }\n                }\n              },\n              marker: {\n                shape: \"pinTarget\",\n                tooltip: {\n                  position: \"top\"\n                }\n              }\n            },\n            center: [0, 0],\n            zoom: 3,\n            minSize: 256,\n            minZoom: 1,\n            maxZoom: 19,\n            markers: [],\n            markerDefaults: {\n              shape: \"pinTarget\",\n              tooltip: {\n                position: \"top\"\n              }\n            },\n            wraparound: true,\n            messages: {\n              tileTitle: \"Map tile\"\n            }\n          },\n          events: [\"beforeReset\", \"click\", \"markerActivate\", \"markerClick\", \"markerCreated\", \"pan\", \"panEnd\", \"reset\", \"shapeClick\", \"shapeCreated\", \"shapeFeatureCreated\", \"shapeMouseEnter\", \"shapeMouseLeave\", \"zoomEnd\", \"zoomStart\"],\n          destroy: function () {\n            this.scroller.destroy();\n\n            if (this.navigator) {\n              this.navigator.destroy();\n            }\n\n            if (this.attribution) {\n              this.attribution.destroy();\n            }\n\n            if (this.zoomControl) {\n              this.zoomControl.destroy();\n            }\n\n            this.markers.destroy();\n\n            for (var i = 0; i < this.layers.length; i++) {\n              this.layers[i].destroy();\n            }\n\n            Widget.fn.destroy.call(this);\n          },\n          zoom: function (level) {\n            var options = this.options;\n\n            if (defined(level)) {\n              level = math.round(limit(level, options.minZoom, options.maxZoom));\n\n              if (options.zoom !== level) {\n                options.zoom = level;\n\n                this._reset();\n              }\n\n              return this;\n            } else {\n              return options.zoom;\n            }\n          },\n          center: function (center) {\n            if (center) {\n              this.options.center = Location.create(center).toArray();\n\n              this._reset();\n\n              return this;\n            } else {\n              return Location.create(this.options.center);\n            }\n          },\n          extent: function (extent) {\n            if (extent) {\n              this._setExtent(extent);\n\n              return this;\n            } else {\n              return this._getExtent();\n            }\n          },\n          setOptions: function (options) {\n            Widget.fn.setOptions.call(this, options);\n\n            this._reset();\n          },\n          locationToLayer: function (location, zoom) {\n            var clamp = !this.options.wraparound;\n            location = Location.create(location);\n            return this.crs.toPoint(location, this._layerSize(zoom), clamp);\n          },\n          layerToLocation: function (point, zoom) {\n            var clamp = !this.options.wraparound;\n            point = Point.create(point);\n            return this.crs.toLocation(point, this._layerSize(zoom), clamp);\n          },\n          locationToView: function (location) {\n            location = Location.create(location);\n            var origin = this.locationToLayer(this._viewOrigin);\n            var point = this.locationToLayer(location);\n            return point.translateWith(origin.scale(-1));\n          },\n          viewToLocation: function (point, zoom) {\n            var origin = this.locationToLayer(this._getOrigin(), zoom);\n            point = Point.create(point);\n            point = point.clone().translateWith(origin);\n            return this.layerToLocation(point, zoom);\n          },\n          eventOffset: function (e) {\n            var point;\n            var x;\n            var y;\n            var offset = this.element.offset();\n\n            if (e.x || e.y) {\n              var field = \"location\";\n              x = e.x[field] - offset.left;\n              y = e.y[field] - offset.top;\n              point = new g.Point(x, y);\n            } else {\n              var event = e.originalEvent || e;\n              x = valueOrDefault(event.pageX, event.clientX) - offset.left;\n              y = valueOrDefault(event.pageY, event.clientY) - offset.top;\n              point = new g.Point(x, y);\n            }\n\n            return point;\n          },\n          eventToView: function (e) {\n            var cursor = this.eventOffset(e);\n            return this.locationToView(this.viewToLocation(cursor));\n          },\n          eventToLayer: function (e) {\n            return this.locationToLayer(this.eventToLocation(e));\n          },\n          eventToLocation: function (e) {\n            var cursor = this.eventOffset(e);\n            return this.viewToLocation(cursor);\n          },\n          viewSize: function () {\n            var element = this.element;\n\n            var scale = this._layerSize();\n\n            var width = element.width();\n\n            if (!this.options.wraparound) {\n              width = min(scale, width);\n            }\n\n            return {\n              width: width,\n              height: min(scale, element.height())\n            };\n          },\n          exportVisual: function () {\n            this._reset();\n\n            return false;\n          },\n          _setOrigin: function (origin, zoom) {\n            var size = this.viewSize(),\n                topLeft;\n            origin = this._origin = Location.create(origin);\n            topLeft = this.locationToLayer(origin, zoom);\n            topLeft.x += size.width / 2;\n            topLeft.y += size.height / 2;\n            this.options.center = this.layerToLocation(topLeft, zoom).toArray();\n            return this;\n          },\n          _getOrigin: function (invalidate) {\n            var size = this.viewSize(),\n                topLeft;\n\n            if (invalidate || !this._origin) {\n              topLeft = this.locationToLayer(this.center());\n              topLeft.x -= size.width / 2;\n              topLeft.y -= size.height / 2;\n              this._origin = this.layerToLocation(topLeft);\n            }\n\n            return this._origin;\n          },\n          _setExtent: function (extent) {\n            var raw = Extent.create(extent);\n            var se = raw.se.clone();\n\n            if (this.options.wraparound && se.lng < 0 && extent.nw.lng > 0) {\n              se.lng = 180 + (180 + se.lng);\n            }\n\n            extent = new Extent(raw.nw, se);\n            this.center(extent.center());\n            var width = this.element.width();\n            var height = this.element.height();\n\n            for (var zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {\n              var topLeft = this.locationToLayer(extent.nw, zoom);\n              var bottomRight = this.locationToLayer(extent.se, zoom);\n              var layerWidth = math.abs(bottomRight.x - topLeft.x);\n              var layerHeight = math.abs(bottomRight.y - topLeft.y);\n\n              if (layerWidth <= width && layerHeight <= height) {\n                break;\n              }\n            }\n\n            this.zoom(zoom);\n          },\n          _getExtent: function () {\n            var nw = this._getOrigin();\n\n            var bottomRight = this.locationToLayer(nw);\n            var size = this.viewSize();\n            bottomRight.x += size.width;\n            bottomRight.y += size.height;\n            var se = this.layerToLocation(bottomRight);\n            return new Extent(nw, se);\n          },\n          _zoomAround: function (pivot, level) {\n            this._setOrigin(this.layerToLocation(pivot, level), level);\n\n            this.zoom(level);\n          },\n          _initControls: function () {\n            var controls = this.options.controls;\n\n            if (ui.Attribution && controls.attribution) {\n              this._createAttribution(controls.attribution);\n            }\n\n            if (!kendo.support.mobileOS) {\n              if (ui.Navigator && controls.navigator) {\n                this._createNavigator(controls.navigator);\n              }\n\n              if (ui.ZoomControl && controls.zoom) {\n                this._createZoomControl(controls.zoom);\n              }\n            }\n          },\n          _createControlElement: function (options, defaultPos) {\n            var pos = options.position || defaultPos;\n            var posSelector = \".\" + renderPos(pos).replace(\" \", \".\");\n            var wrap = $(\".k-map-controls\" + posSelector, this.element);\n\n            if (wrap.length === 0) {\n              wrap = $(\"<div>\").addClass(\"k-map-controls \" + renderPos(pos)).appendTo(this.element);\n            }\n\n            return $(\"<div>\").appendTo(wrap);\n          },\n          _createAttribution: function (options) {\n            var element = this._createControlElement(options, \"bottomRight\");\n\n            this.attribution = new ui.Attribution(element, options);\n          },\n          _createNavigator: function (options) {\n            var element = this._createControlElement(options, \"topLeft\");\n\n            var navigator = this.navigator = new ui.Navigator(element, options);\n            this._navigatorPan = this._navigatorPan.bind(this);\n            navigator.bind(\"pan\", this._navigatorPan);\n            this._navigatorCenter = this._navigatorCenter.bind(this);\n            navigator.bind(\"center\", this._navigatorCenter);\n          },\n          _navigatorPan: function (e) {\n            var map = this;\n            var scroller = map.scroller;\n            var x = scroller.scrollLeft + e.x;\n            var y = scroller.scrollTop - e.y;\n            var bounds = this._virtualSize;\n            var height = this.element.height();\n            var width = this.element.width(); // TODO: Move limits in scroller\n\n            x = limit(x, bounds.x.min, bounds.x.max - width);\n            y = limit(y, bounds.y.min, bounds.y.max - height);\n            map.scroller.one(\"scroll\", function (e) {\n              map._scrollEnd(e);\n            });\n            map.scroller.scrollTo(-x, -y);\n          },\n          _navigatorCenter: function () {\n            this.center(this.options.center);\n          },\n          _createZoomControl: function (options) {\n            var element = this._createControlElement(options, \"topLeft\");\n\n            var zoomControl = this.zoomControl = new ui.ZoomControl(element, options);\n            this._zoomControlChange = this._zoomControlChange.bind(this);\n            zoomControl.bind(\"change\", this._zoomControlChange);\n          },\n          _zoomControlChange: function (e) {\n            if (!this.trigger(\"zoomStart\", {\n              originalEvent: e\n            })) {\n              this.zoom(this.zoom() + e.delta);\n              this.trigger(\"zoomEnd\", {\n                originalEvent: e\n              });\n            }\n          },\n          _initScroller: function () {\n            var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n            var zoomable = this.options.zoomable !== false;\n            var scroller = this.scroller = new kendo.mobile.ui.Scroller(this.element.children(0), {\n              friction: friction,\n              velocityMultiplier: VELOCITY_MULTIPLIER,\n              zoom: zoomable,\n              mousewheelScrolling: false,\n              supportDoubleTap: true\n            });\n            scroller.bind(\"scroll\", this._scroll.bind(this));\n            scroller.bind(\"scrollEnd\", this._scrollEnd.bind(this));\n            scroller.userEvents.bind(\"gesturestart\", this._scaleStart.bind(this));\n            scroller.userEvents.bind(\"gestureend\", this._scale.bind(this));\n            scroller.userEvents.bind(\"doubleTap\", this._doubleTap.bind(this));\n            scroller.userEvents.bind(\"tap\", this._tap.bind(this));\n            this.scrollElement = scroller.scrollElement;\n          },\n          _initLayers: function () {\n            var defs = this.options.layers,\n                layers = this.layers = [];\n\n            for (var i = 0; i < defs.length; i++) {\n              var options = defs[i];\n              var type = options.type || \"shape\";\n              var defaults = this.options.layerDefaults[type];\n              var impl = dataviz.map.layers[type];\n              layers.push(new impl(this, deepExtend({}, defaults, options)));\n            }\n          },\n          _initMarkers: function () {\n            this.markers = new map.layers.MarkerLayer(this, this.options.markerDefaults);\n            this.markers.add(this.options.markers);\n          },\n          _scroll: function (e) {\n            var origin = this.locationToLayer(this._viewOrigin).round();\n            var movable = e.sender.movable;\n            var offset = new g.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);\n            origin.x += offset.x;\n            origin.y += offset.y;\n            this._scrollOffset = offset;\n\n            this._setOrigin(this.layerToLocation(origin));\n\n            this.trigger(\"pan\", {\n              originalEvent: e,\n              origin: this._getOrigin(),\n              center: this.center()\n            });\n          },\n          _scrollEnd: function (e) {\n            if (!this._scrollOffset || !this._panComplete()) {\n              return;\n            }\n\n            this._scrollOffset = null;\n            this._panEndTS = new Date();\n            this.trigger(\"panEnd\", {\n              originalEvent: e,\n              origin: this._getOrigin(),\n              center: this.center()\n            });\n          },\n          _panComplete: function () {\n            return new Date() - (this._panEndTS || 0) > 50;\n          },\n          _scaleStart: function (e) {\n            if (this.trigger(\"zoomStart\", {\n              originalEvent: e\n            })) {\n              var touch = e.touches[1];\n\n              if (touch) {\n                touch.cancel();\n              }\n            }\n          },\n          _scale: function (e) {\n            var scale = this.scroller.movable.scale;\n\n            var zoom = this._scaleToZoom(scale);\n\n            var gestureCenter = new g.Point(e.center.x, e.center.y);\n            var centerLocation = this.viewToLocation(gestureCenter, zoom);\n            var centerPoint = this.locationToLayer(centerLocation, zoom);\n            var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);\n\n            this._zoomAround(originPoint, zoom);\n\n            this.trigger(\"zoomEnd\", {\n              originalEvent: e\n            });\n          },\n          _scaleToZoom: function (scaleDelta) {\n            var scale = this._layerSize() * scaleDelta;\n            var tiles = scale / this.options.minSize;\n            var zoom = math.log(tiles) / math.log(2);\n            return math.round(zoom);\n          },\n          _reset: function () {\n            if (this.attribution) {\n              this.attribution.filter(this.center(), this.zoom());\n            }\n\n            this._viewOrigin = this._getOrigin(true);\n\n            this._resetScroller();\n\n            this.trigger(\"beforeReset\");\n            this.trigger(\"reset\", {\n              tileTitle: this.options.messages.tileTitle\n            });\n          },\n          _resetScroller: function () {\n            var scroller = this.scroller;\n            var x = scroller.dimensions.x;\n            var y = scroller.dimensions.y;\n\n            var scale = this._layerSize();\n\n            var nw = this.extent().nw;\n            var topLeft = this.locationToLayer(nw).round();\n            scroller.movable.round = true;\n            scroller.reset();\n            scroller.userEvents.cancel();\n            var zoom = this.zoom();\n            scroller.dimensions.forcedMinScale = pow(2, this.options.minZoom - zoom);\n            scroller.dimensions.maxScale = pow(2, this.options.maxZoom - zoom);\n            var xBounds = {\n              min: -topLeft.x,\n              max: scale - topLeft.x\n            };\n            var yBounds = {\n              min: -topLeft.y,\n              max: scale - topLeft.y\n            };\n\n            if (this.options.wraparound) {\n              xBounds.max = 20 * scale;\n              xBounds.min = -xBounds.max;\n            }\n\n            if (this.options.pannable === false) {\n              var viewSize = this.viewSize();\n              xBounds.min = yBounds.min = 0;\n              xBounds.max = viewSize.width;\n              yBounds.max = viewSize.height;\n            }\n\n            x.makeVirtual();\n            y.makeVirtual();\n            x.virtualSize(xBounds.min, xBounds.max);\n            y.virtualSize(yBounds.min, yBounds.max);\n            this._virtualSize = {\n              x: xBounds,\n              y: yBounds\n            };\n          },\n          _renderLayers: function () {\n            var defs = this.options.layers,\n                layers = this.layers = [],\n                scrollWrap = this.scrollWrap;\n            scrollWrap.empty();\n\n            for (var i = 0; i < defs.length; i++) {\n              var options = defs[i];\n              var type = options.type || \"shape\";\n              var defaults = this.options.layerDefaults[type];\n              var impl = dataviz.map.layers[type];\n              layers.push(new impl(this, deepExtend({}, defaults, options)));\n            }\n          },\n          _layerSize: function (zoom) {\n            zoom = valueOrDefault(zoom, this.options.zoom);\n            return this.options.minSize * pow(2, zoom);\n          },\n          _tap: function (e) {\n            if (!this._panComplete()) {\n              return;\n            }\n\n            var cursor = this.eventOffset(e);\n            this.trigger(\"click\", {\n              originalEvent: e,\n              location: this.viewToLocation(cursor)\n            });\n          },\n          _doubleTap: function (e) {\n            var options = this.options;\n\n            if (options.zoomable !== false) {\n              if (!this.trigger(\"zoomStart\", {\n                originalEvent: e\n              })) {\n                var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;\n                var cursor = this.eventOffset(e);\n                var location = this.viewToLocation(cursor);\n                var postZoom = this.locationToLayer(location, toZoom);\n                var origin = postZoom.translate(-cursor.x, -cursor.y);\n\n                this._zoomAround(origin, toZoom);\n\n                this.trigger(\"zoomEnd\", {\n                  originalEvent: e\n                });\n              }\n            }\n          },\n          _mousewheel: function (e) {\n            e.preventDefault();\n            var delta = dataviz.mwDelta(e) > 0 ? -1 : 1;\n            var options = this.options;\n            var fromZoom = this.zoom();\n            var toZoom = limit(fromZoom + delta, options.minZoom, options.maxZoom);\n\n            if (options.zoomable !== false && toZoom !== fromZoom) {\n              if (!this.trigger(\"zoomStart\", {\n                originalEvent: e\n              })) {\n                var cursor = this.eventOffset(e);\n                var location = this.viewToLocation(cursor);\n                var postZoom = this.locationToLayer(location, toZoom);\n                var origin = postZoom.translate(-cursor.x, -cursor.y);\n\n                this._zoomAround(origin, toZoom);\n\n                this.trigger(\"zoomEnd\", {\n                  originalEvent: e\n                });\n              }\n            }\n          }\n        }); // Exports ================================================================\n\n        dataviz.ui.plugin(Map);\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  939:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./crs\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}