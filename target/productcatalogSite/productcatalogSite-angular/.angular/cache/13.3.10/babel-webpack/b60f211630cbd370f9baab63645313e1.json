{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport BoxElement from './box-element';\nimport TextBox from './text-box';\nimport ShapeElement from './shape-element';\nimport Box from './box';\nimport { CIRCLE, TOP, BOTTOM, LEFT, RIGHT, CENTER, INSIDE, OUTSIDE, NOTE_CLICK, NOTE_HOVER, NOTE_LEAVE } from '../common/constants';\nimport { alignPathToPixel, defined, deepExtend, eventElement, getTemplate, inArray, setDefaultOptions } from '../common';\nconst DEFAULT_ICON_SIZE = 7;\nconst DEFAULT_LABEL_COLOR = \"#fff\";\n\nclass Note extends BoxElement {\n  constructor(fields, options, chartService) {\n    super(options);\n    this.fields = fields;\n    this.chartService = chartService;\n    this.render();\n  }\n\n  hide() {\n    this.options.visible = false;\n  }\n\n  show() {\n    this.options.visible = true;\n  }\n\n  render() {\n    const options = this.options;\n\n    if (options.visible) {\n      const {\n        label,\n        icon\n      } = options;\n      const box = new Box();\n\n      const childAlias = () => this;\n\n      let size = icon.size;\n      let text = this.fields.text;\n      let width, height;\n\n      if (defined(label) && label.visible) {\n        const noteTemplate = getTemplate(label);\n\n        if (noteTemplate) {\n          text = noteTemplate(this.fields);\n        } else if (label.format) {\n          text = this.chartService.format.auto(label.format, text);\n        }\n\n        if (!label.color) {\n          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n        }\n\n        this.label = new TextBox(text, deepExtend({}, label));\n        this.label.aliasFor = childAlias;\n\n        if (label.position === INSIDE && !defined(size)) {\n          if (icon.type === CIRCLE) {\n            size = Math.max(this.label.box.width(), this.label.box.height());\n          } else {\n            width = this.label.box.width();\n            height = this.label.box.height();\n          }\n\n          box.wrap(this.label.box);\n        }\n      }\n\n      icon.width = width || size || DEFAULT_ICON_SIZE;\n      icon.height = height || size || DEFAULT_ICON_SIZE;\n      const marker = new ShapeElement(deepExtend({}, icon));\n      marker.aliasFor = childAlias;\n      this.marker = marker;\n      this.append(marker);\n\n      if (this.label) {\n        this.append(this.label);\n      }\n\n      marker.reflow(new Box());\n      this.wrapperBox = box.wrap(marker.box);\n    }\n  }\n\n  reflow(targetBox) {\n    const {\n      options,\n      label,\n      marker,\n      wrapperBox\n    } = this;\n    const center = targetBox.center();\n    const length = options.line.length;\n    const position = options.position; // TODO: Review\n\n    if (options.visible) {\n      let lineStart, box, contentBox;\n\n      if (inArray(position, [LEFT, RIGHT])) {\n        if (position === LEFT) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n          if (options.line.visible) {\n            lineStart = [targetBox.x1, center.y];\n            this.linePoints = [lineStart, [contentBox.x2, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n          if (options.line.visible) {\n            lineStart = [targetBox.x2, center.y];\n            this.linePoints = [lineStart, [contentBox.x1, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      } else {\n        if (position === BOTTOM) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y2];\n            this.linePoints = [lineStart, [center.x, contentBox.y1]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y1];\n            this.linePoints = [lineStart, [center.x, contentBox.y2]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      }\n\n      if (marker) {\n        marker.reflow(contentBox);\n      }\n\n      if (label) {\n        label.reflow(contentBox);\n\n        if (marker) {\n          if (options.label.position === OUTSIDE) {\n            label.box.alignTo(marker.box, position);\n          }\n\n          label.reflow(label.box);\n        }\n      }\n\n      this.contentBox = contentBox;\n      this.targetBox = targetBox;\n      this.box = box || contentBox;\n    }\n  }\n\n  createVisual() {\n    super.createVisual();\n    this.visual.options.noclip = this.options.noclip;\n\n    if (this.options.visible) {\n      this.createLine();\n    }\n  }\n\n  renderVisual() {\n    const options = this.options;\n    const customVisual = options.visual;\n\n    if (options.visible && customVisual) {\n      this.visual = customVisual(Object.assign(this.fields, {\n        sender: this.getSender(),\n        rect: this.targetBox.toRect(),\n        options: {\n          background: options.background,\n          border: options.background,\n          icon: options.icon,\n          label: options.label,\n          line: options.line,\n          position: options.position,\n          visible: options.visible\n        },\n        createVisual: () => {\n          this.createVisual();\n          this.renderChildren();\n          const defaultVisual = this.visual;\n          delete this.visual;\n          return defaultVisual;\n        }\n      }));\n      this.addVisual();\n    } else {\n      super.renderVisual();\n    }\n  }\n\n  createLine() {\n    const options = this.options.line;\n\n    if (this.linePoints) {\n      const path = draw.Path.fromPoints(this.linePoints, {\n        stroke: {\n          color: options.color,\n          width: options.width,\n          dashType: options.dashType\n        }\n      });\n      alignPathToPixel(path);\n      this.visual.append(path);\n    }\n  }\n\n  click(widget, e) {\n    const args = this.eventArgs(e);\n\n    if (!widget.trigger(NOTE_CLICK, args)) {\n      e.preventDefault();\n    }\n  }\n\n  over(widget, e) {\n    const args = this.eventArgs(e);\n\n    if (!widget.trigger(NOTE_HOVER, args)) {\n      e.preventDefault();\n    }\n  }\n\n  out(widget, e) {\n    const args = this.eventArgs(e);\n    widget.trigger(NOTE_LEAVE, args);\n  }\n\n  eventArgs(e) {\n    const options = this.options;\n    return Object.assign(this.fields, {\n      element: eventElement(e),\n      text: defined(options.label) ? options.label.text : \"\",\n      visual: this.visual\n    });\n  }\n\n}\n\nsetDefaultOptions(Note, {\n  icon: {\n    visible: true,\n    type: CIRCLE\n  },\n  label: {\n    position: INSIDE,\n    visible: true,\n    align: CENTER,\n    vAlign: CENTER\n  },\n  line: {\n    visible: true\n  },\n  visible: true,\n  position: TOP,\n  zIndex: 2\n});\nexport default Note;","map":null,"metadata":{},"sourceType":"module"}