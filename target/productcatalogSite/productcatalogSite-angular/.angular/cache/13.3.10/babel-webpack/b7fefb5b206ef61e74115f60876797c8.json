{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1549);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1052:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.popup\");\n    /***/\n  },\n\n  /***/\n  1136:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.draganddrop\");\n    /***/\n  },\n\n  /***/\n  1549:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1136), __webpack_require__(1052)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"window\",\n        name: \"Window\",\n        category: \"web\",\n        description: \"The Window widget displays content in a modal or non-modal HTML window.\",\n        depends: [\"draganddrop\", \"popup\"],\n        features: [{\n          id: \"window-fx\",\n          name: \"Animation\",\n          description: \"Support for animation\",\n          depends: [\"fx\"]\n        }]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            Widget = kendo.ui.Widget,\n            TabKeyTrap = kendo.ui.Popup.TabKeyTrap,\n            Draggable = kendo.ui.Draggable,\n            isPlainObject = $.isPlainObject,\n            activeElement = kendo._activeElement,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            each = $.each,\n            template = kendo.template,\n            BODY = \"body\",\n            templates,\n            NS = \".kendoWindow\",\n            MODAL_NS = \".kendoWindowModal\",\n            // classNames\n        KWINDOW = \".k-window\",\n            KWINDOWTITLE = \".k-window-title\",\n            KWINDOWTITLEBAR = KWINDOWTITLE + \"bar\",\n            KWINDOWCONTENT = \".k-window-content\",\n            KDIALOGCONTENT = \".k-dialog-content\",\n            KWINDOWRESIZEHANDLES = \".k-resize-handle\",\n            KOVERLAY = \".k-overlay\",\n            KCONTENTFRAME = \"k-content-frame\",\n            LOADING = \"k-i-loading\",\n            KHOVERSTATE = \"k-hover\",\n            KFOCUSEDSTATE = \"k-state-focused\",\n            MAXIMIZEDSTATE = \"k-window-maximized\",\n            INLINE_FLEX = \"k-display-inline-flex\",\n            // constants\n        VISIBLE = \":visible\",\n            HIDDEN = \"hidden\",\n            CURSOR = \"cursor\",\n            // events\n        OPEN = \"open\",\n            ACTIVATE = \"activate\",\n            DEACTIVATE = \"deactivate\",\n            CLOSE = \"close\",\n            REFRESH = \"refresh\",\n            MINIMIZE = \"minimize\",\n            MAXIMIZE = \"maximize\",\n            RESIZESTART = \"resizeStart\",\n            RESIZE = \"resize\",\n            RESIZEEND = \"resizeEnd\",\n            DRAGSTART = \"dragstart\",\n            DRAGEND = \"dragend\",\n            RESTORE = \"restore\",\n            KENDOKEYDOWN = \"kendoKeydown\",\n            ERROR = \"error\",\n            OVERFLOW = \"overflow\",\n            DATADOCOVERFLOWRULE = \"original-overflow-rule\",\n            ZINDEX = \"zIndex\",\n            MINIMIZE_MAXIMIZE = \".k-window-actions .k-i-window-minimize,.k-window-actions .k-i-window-maximize\",\n            KPIN = \".k-i-pin\",\n            KUNPIN = \".k-i-unpin\",\n            PIN_UNPIN = KPIN + \",\" + KUNPIN,\n            TITLEBAR_BUTTONS = \".k-window-titlebar .k-window-action\",\n            REFRESHICON = \".k-window-titlebar .k-i-refresh\",\n            WINDOWEVENTSHANDLED = \"WindowEventsHandled\",\n            zero = /^0[a-z]*$/i,\n            isLocalUrl = kendo.isLocalUrl,\n            SIZE = {\n          small: \"k-window-sm\",\n          medium: \"k-window-md\",\n          large: \"k-window-lg\"\n        };\n\n        function defined(x) {\n          return typeof x != \"undefined\";\n        }\n\n        function toInt(element, property) {\n          return parseInt(element.css(property), 10) || 0;\n        }\n\n        function constrain(value, low, high) {\n          var normalizedValue;\n\n          if (value && isNaN(value) && value.toString().indexOf(\"px\") < 0) {\n            normalizedValue = value;\n          } else {\n            normalizedValue = Math.max(Math.min(parseInt(value, 10), high === Infinity ? high : parseInt(high, 10)), low === -Infinity ? low : parseInt(low, 10));\n          }\n\n          return normalizedValue;\n        }\n\n        function executableScript() {\n          return !this.type || this.type.toLowerCase().indexOf(\"script\") >= 0;\n        }\n\n        function getPosition(elem) {\n          var result = {\n            top: elem.offsetTop,\n            left: elem.offsetLeft\n          },\n              parent = elem.offsetParent;\n\n          while (parent) {\n            result.top += parent.offsetTop;\n            result.left += parent.offsetLeft;\n            var parentOverflowX = $(parent).css(\"overflowX\");\n            var parentOverflowY = $(parent).css(\"overflowY\");\n\n            if (parentOverflowY === \"auto\" || parentOverflowY === \"scroll\") {\n              result.top -= parent.scrollTop;\n            }\n\n            if (parentOverflowX === \"auto\" || parentOverflowX === \"scroll\") {\n              result.left -= parent.scrollLeft;\n            }\n\n            parent = parent.offsetParent;\n          }\n\n          return result;\n        }\n\n        var Window = Widget.extend({\n          init: function (element, options) {\n            var that = this,\n                wrapper,\n                offset = {},\n                visibility,\n                display,\n                position,\n                isVisible = false,\n                content,\n                windowContent,\n                windowFrame,\n                globalWindow,\n                suppressActions = options && options.actions && !options.actions.length,\n                id;\n            Widget.fn.init.call(that, element, options);\n            options = that.options;\n            position = options.position;\n            element = that.element;\n            content = options.content;\n            globalWindow = $(window);\n\n            if (suppressActions) {\n              options.actions = [];\n            }\n\n            that.appendTo = $(options.appendTo);\n            that.containment = options.draggable.containment ? $(options.draggable.containment).first() : null;\n\n            if (content && !isPlainObject(content)) {\n              content = options.content = {\n                url: content\n              };\n            } // remove script blocks to prevent double-execution\n\n\n            element.find(\"script\").filter(executableScript).remove();\n\n            if (!element.parent().is(that.appendTo) && !that.containment && (position.top === undefined || position.left === undefined)) {\n              if (element.is(VISIBLE)) {\n                offset = element.offset();\n                isVisible = true;\n              } else {\n                visibility = element.css(\"visibility\");\n                display = element.css(\"display\");\n                element.css({\n                  visibility: HIDDEN,\n                  display: \"\"\n                });\n\n                if (document.body.contains(element[0])) {\n                  offset = element.offset();\n                } else {\n                  offset = {\n                    top: 0,\n                    left: 0\n                  };\n                }\n\n                element.css({\n                  visibility: visibility,\n                  display: display\n                });\n              }\n\n              if (position.top === undefined) {\n                position.top = offset.top;\n              }\n\n              if (position.left === undefined) {\n                position.left = offset.left;\n              }\n            }\n\n            if (!defined(options.visible) || options.visible === null) {\n              options.visible = element.is(VISIBLE);\n            }\n\n            wrapper = that.wrapper = element.closest(KWINDOW);\n\n            if (!element.is(\".k-window-content\") || !wrapper[0]) {\n              element.addClass(\"k-window-content\");\n\n              that._createWindow(element, options);\n\n              wrapper = that.wrapper = element.closest(KWINDOW);\n              that.title(that.options.title);\n\n              that._dimensions();\n            }\n\n            that.minTop = that.minLeft = -Infinity;\n            that.maxTop = that.maxLeft = Infinity;\n\n            that._position();\n\n            if (content) {\n              that.refresh(content);\n            }\n\n            if (options.visible) {\n              that.toFront(null, !options.modal);\n            }\n\n            windowContent = wrapper.children(KWINDOWCONTENT);\n\n            if (options.visible && options.modal) {\n              that._overlay(wrapper.is(VISIBLE)).css({\n                opacity: 0.5\n              });\n            }\n\n            wrapper.on(\"mouseenter\" + NS, TITLEBAR_BUTTONS, that._buttonEnter.bind(that)).on(\"mouseleave\" + NS, TITLEBAR_BUTTONS, that._buttonLeave.bind(that)).on(\"click\" + NS, \"> \" + TITLEBAR_BUTTONS, that._windowActionHandler.bind(that)).on(\"keydown\" + NS, that, that._keydown.bind(that)).on(\"focus\" + NS, that._focus.bind(that)).on(\"blur\" + NS, that._blur.bind(that));\n            windowContent.on(\"keydown\" + NS, that, that._keydownContent.bind(that));\n            windowFrame = windowContent.find(\".\" + KCONTENTFRAME)[0];\n\n            if (windowFrame && !globalWindow.data(WINDOWEVENTSHANDLED)) {\n              globalWindow.on(\"blur\" + NS, function () {\n                var element = $(document.activeElement).parent(KWINDOWCONTENT);\n\n                if (element.length) {\n                  var windowInstance = kendo.widgetInstance(element);\n\n                  windowInstance._focus();\n                }\n              });\n              globalWindow.on(\"focus\" + NS, function () {\n                $(KWINDOWCONTENT).not(KDIALOGCONTENT).each(function (i, element) {\n                  kendo.widgetInstance($(element))._blur();\n                });\n              });\n              globalWindow.data(WINDOWEVENTSHANDLED, true);\n            }\n\n            this._resizable();\n\n            this._draggable();\n\n            if (options.pinned && this.wrapper.is(\":visible\")) {\n              that.pin();\n            }\n\n            id = element.attr(\"id\");\n\n            if (id) {\n              id = id + \"_wnd_title\";\n              wrapper.attr({\n                \"role\": \"dialog\",\n                \"aria-labelledby\": id\n              }).children(KWINDOWTITLEBAR).children(KWINDOWTITLE).attr(\"id\", id);\n            }\n\n            wrapper.add(wrapper.children(\".k-resize-handle,\" + KWINDOWTITLEBAR)).on(kendo.support.mousedown + NS, that.toFront.bind(that));\n            that.touchScroller = kendo.touchScroller(element);\n            that._resizeHandler = that._onDocumentResize.bind(that);\n            that._marker = kendo.guid().substring(0, 8);\n            $(window).on(\"resize\" + NS + that._marker, that._resizeHandler);\n\n            if (options.visible) {\n              that.trigger(OPEN);\n              that.trigger(ACTIVATE);\n            }\n\n            kendo.notify(that);\n\n            if (this.options.modal) {\n              this._tabKeyTrap = new TabKeyTrap(wrapper);\n\n              this._tabKeyTrap.trap();\n\n              this._tabKeyTrap.shouldTrap = function () {\n                return wrapper.data(\"isFront\");\n              };\n            }\n          },\n          _buttonEnter: function (e) {\n            $(e.currentTarget).addClass(KHOVERSTATE);\n          },\n          _buttonLeave: function (e) {\n            $(e.currentTarget).removeClass(KHOVERSTATE);\n          },\n          _focus: function () {\n            this.wrapper.addClass(KFOCUSEDSTATE);\n          },\n          _blur: function () {\n            this.wrapper.removeClass(KFOCUSEDSTATE);\n          },\n          _dimensions: function () {\n            var wrapper = this.wrapper;\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var maxHeight = options.maxHeight;\n            var sizeClass = options.size;\n            var dimensions = [\"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\"];\n            var contentBoxSizing = wrapper.css(\"box-sizing\") == \"content-box\";\n            var lrBorderWidth = contentBoxSizing ? toInt(wrapper, \"border-left-width\") + toInt(wrapper, \"border-right-width\") : 0;\n            var tbBorderWidth = contentBoxSizing ? toInt(wrapper, \"border-top-width\") + toInt(wrapper, \"border-bottom-width\") : 0;\n            var paddingTop = contentBoxSizing ? toInt(wrapper, \"padding-top\") : 0;\n\n            if (this.containment && !this._isPinned) {\n              this._updateBoundaries();\n\n              options.maxHeight = Math.min(this.containment.height - (tbBorderWidth + paddingTop), maxHeight);\n              options.maxWidth = Math.min(this.containment.width - lrBorderWidth, options.maxWidth);\n            }\n\n            for (var i = 0; i < dimensions.length; i++) {\n              var value = options[dimensions[i]] || \"\";\n\n              if (value != Infinity) {\n                wrapper.css(dimensions[i], value);\n              }\n            }\n\n            if (maxHeight != Infinity) {\n              this.element.css(\"maxHeight\", maxHeight);\n            }\n\n            if (width) {\n              wrapper.outerWidth(constrain(width, options.minWidth, options.maxWidth));\n            } else {\n              wrapper.outerWidth(\"\");\n            }\n\n            if (height) {\n              wrapper.outerHeight(constrain(height, options.minHeight, options.maxHeight));\n            } else {\n              wrapper.outerHeight(\"\");\n            }\n\n            if (!options.visible) {\n              wrapper.removeClass(INLINE_FLEX).hide();\n            }\n\n            if (sizeClass && SIZE[sizeClass]) {\n              wrapper.addClass(SIZE[sizeClass]);\n            }\n          },\n          _position: function () {\n            var wrapper = this.wrapper,\n                position = this.options.position,\n                containmentTop,\n                containmentLeft;\n\n            this._updateBoundaries();\n\n            if (this.containment) {\n              position.top = position.top || 0;\n              position.left = position.left || 0;\n              containmentTop = position.top.toString().indexOf(\"%\") > 0 ? parseInt(this.containment.height * (parseFloat(position.top) / 100), 10) : position.top;\n              containmentLeft = position.left.toString().indexOf(\"%\") > 0 ? parseInt(this.containment.width * (parseFloat(position.left) / 100), 10) : position.left;\n              position.top = constrain(containmentTop, this.minTop, this.maxTop);\n              position.left = constrain(containmentLeft, this.minLeft, this.maxLeft);\n            }\n\n            if (position.top && position.top.toString().indexOf(\"px\") > 0) {\n              position.top = Number(position.top.replace(\"px\", \"\"));\n            }\n\n            if (position.left && position.left.toString().indexOf(\"px\") > 0) {\n              position.left = Number(position.left.replace(\"px\", \"\"));\n            }\n\n            if (position.top === 0) {\n              position.top = position.top.toString();\n            }\n\n            if (position.left === 0) {\n              position.left = position.left.toString();\n            }\n\n            wrapper.css({\n              top: position.top || \"\",\n              left: position.left || \"\"\n            });\n          },\n          _updateBoundaries: function () {\n            var containment = this.containment;\n\n            if (!containment) {\n              return null;\n            }\n\n            containment.width = containment.innerWidth();\n            containment.height = containment.innerHeight();\n\n            if (parseInt(containment.width, 10) > containment[0].clientWidth) {\n              containment.width -= kendo.support.scrollbar();\n            }\n\n            if (parseInt(containment.height, 10) > containment[0].clientHeight) {\n              containment.height -= kendo.support.scrollbar();\n            }\n\n            containment.position = getPosition(containment[0]);\n\n            if (this._isPinned) {\n              this.minTop = this.minLeft = -Infinity;\n              this.maxTop = this.maxLeft = Infinity;\n            } else {\n              this.minTop = containment.scrollTop();\n              this.minLeft = containment.scrollLeft();\n              this.maxLeft = this.minLeft + containment.width - outerWidth(this.wrapper, true);\n              this.maxTop = this.minTop + containment.height - outerHeight(this.wrapper, true);\n            }\n          },\n          _animationOptions: function (id) {\n            var animation = this.options.animation;\n            var basicAnimation = {\n              open: {\n                effects: {}\n              },\n              close: {\n                hide: true,\n                effects: {}\n              }\n            };\n            return animation && animation[id] || basicAnimation[id];\n          },\n          _resize: function () {\n            kendo.resize(this.element.children());\n          },\n          _resizable: function () {\n            var resizable = this.options.resizable;\n            var wrapper = this.wrapper;\n\n            if (this.resizing) {\n              wrapper.off(\"dblclick\" + NS).children(KWINDOWRESIZEHANDLES).remove();\n              this.resizing.destroy();\n              this.resizing = null;\n            }\n\n            if (resizable) {\n              wrapper.on(\"dblclick\" + NS, KWINDOWTITLEBAR, function (e) {\n                if (!$(e.target).closest(\".k-window-action\").length) {\n                  this.toggleMaximization();\n                }\n              }.bind(this));\n              each(\"n e s w se sw ne nw\".split(\" \"), function (index, handler) {\n                wrapper.append(templates.resizeHandle(handler));\n              });\n              this.resizing = new WindowResizing(this);\n            }\n\n            wrapper = null;\n          },\n          _draggable: function () {\n            var draggable = this.options.draggable;\n\n            if (this.dragging) {\n              this.dragging.destroy();\n              this.dragging = null;\n            }\n\n            if (draggable) {\n              this.dragging = new WindowDragging(this, draggable.dragHandle || KWINDOWTITLEBAR);\n            }\n          },\n          _actions: function () {\n            var options = this.options;\n            var actions = options.actions;\n            var pinned = options.pinned;\n            var titlebar = this.wrapper.children(KWINDOWTITLEBAR);\n            var container = titlebar.find(\".k-window-actions\");\n            var windowSpecificCommands = [\"maximize\", \"minimize\"];\n            actions = $.map(actions, function (action) {\n              action = pinned && action.toLowerCase() === \"pin\" ? \"unpin\" : action;\n              return {\n                name: windowSpecificCommands.indexOf(action.toLowerCase()) > -1 ? \"window-\" + action : action\n              };\n            });\n            container.html(kendo.render(templates.action, actions));\n          },\n          setOptions: function (options) {\n            var that = this;\n            var sizeClass = that.options.size;\n            var doc = this.containment && !that._isPinned ? this.containment : $(document); // make a deep extend over options.position telerik/kendo-ui-core#844\n\n            var cachedOptions = JSON.parse(JSON.stringify(options));\n            extend(options.position, that.options.position);\n            extend(options.position, cachedOptions.position);\n            that._containerScrollTop = doc.scrollTop();\n            that._containerScrollLeft = doc.scrollLeft();\n            Widget.fn.setOptions.call(that, options);\n            var scrollable = that.options.scrollable !== false;\n            that.restore();\n\n            if (typeof options.title !== \"undefined\") {\n              that.title(options.title);\n            }\n\n            that.wrapper.removeClass(SIZE[sizeClass]);\n\n            that._dimensions();\n\n            that._position();\n\n            that._resizable();\n\n            that._draggable();\n\n            that._actions();\n\n            if (typeof options.modal !== \"undefined\") {\n              var visible = that.options.visible !== false;\n\n              that._enableDocumentScrolling();\n\n              that._overlay(options.modal && visible);\n            }\n\n            that.element.css(OVERFLOW, scrollable ? \"\" : \"hidden\");\n          },\n          events: [OPEN, ACTIVATE, DEACTIVATE, CLOSE, MINIMIZE, MAXIMIZE, REFRESH, RESTORE, RESIZESTART, RESIZE, RESIZEEND, DRAGSTART, DRAGEND, KENDOKEYDOWN, ERROR],\n          options: {\n            name: \"Window\",\n            animation: {\n              open: {\n                effects: {\n                  zoom: {\n                    direction: \"in\"\n                  },\n                  fade: {\n                    direction: \"in\"\n                  }\n                },\n                duration: 350\n              },\n              close: {\n                effects: {\n                  zoom: {\n                    direction: \"out\",\n                    properties: {\n                      scale: 0.7\n                    }\n                  },\n                  fade: {\n                    direction: \"out\"\n                  }\n                },\n                duration: 350,\n                hide: true\n              }\n            },\n            title: \"\",\n            actions: [\"Close\"],\n            autoFocus: true,\n            modal: false,\n            size: \"auto\",\n            resizable: true,\n            draggable: true,\n            minWidth: 90,\n            minHeight: 50,\n            maxWidth: Infinity,\n            maxHeight: Infinity,\n            pinned: false,\n            scrollable: true,\n            position: {},\n            content: null,\n            visible: null,\n            height: null,\n            width: null,\n            appendTo: \"body\",\n            isMaximized: false,\n            isMinimized: false\n          },\n          _closable: function () {\n            return $.inArray(\"close\", $.map(this.options.actions, function (x) {\n              return x.toLowerCase();\n            })) > -1;\n          },\n          _keydownContent: function (e) {\n            var that = this,\n                keys = kendo.keys,\n                keyCode = e.keyCode;\n\n            if (keyCode == keys.ESC && that._closable()) {\n              e.stopPropagation();\n\n              that._close(false);\n            }\n          },\n          _keydown: function (e) {\n            var that = this,\n                options = that.options,\n                keys = kendo.keys,\n                keyCode = e.keyCode,\n                wrapper = that.wrapper,\n                offset,\n                handled,\n                distance = 10,\n                isMaximized = options.isMaximized,\n                isMinimized = options.isMinimized,\n                newWidth,\n                newHeight,\n                w,\n                h;\n\n            if (keyCode == keys.ESC && that._closable()) {\n              e.stopPropagation();\n\n              that._close(false);\n            }\n\n            if (e.target != e.currentTarget || that._closing) {\n              return;\n            } // Refresh\n\n\n            if (e.altKey && keyCode == 82) {\n              // Alt + R\n              that.refresh();\n            } // Pin/Unpin\n\n\n            if (e.altKey && keyCode == 80) {\n              // Alt + P\n              if (that.options.pinned) {\n                that.unpin();\n              } else {\n                that.pin();\n              }\n            } // Maximize/Restore/Miminimize\n\n\n            if (e.altKey && keyCode == keys.UP) {\n              if (isMinimized) {\n                that.restore();\n                that.wrapper.trigger(\"focus\");\n              } else if (!isMaximized) {\n                that.maximize();\n                that.wrapper.trigger(\"focus\");\n              }\n            } else if (e.altKey && keyCode == keys.DOWN) {\n              if (!isMinimized && !isMaximized) {\n                that.minimize();\n                that.wrapper.trigger(\"focus\");\n              } else if (isMaximized) {\n                that.restore();\n                that.wrapper.trigger(\"focus\");\n              }\n            }\n\n            offset = kendo.getOffset(wrapper);\n\n            if (that.containment && !that._isPinned) {\n              offset = that.options.position;\n            }\n\n            if (options.draggable && !e.ctrlKey && !e.altKey && !isMaximized) {\n              that._updateBoundaries();\n\n              if (keyCode == keys.UP) {\n                offset.top = constrain(offset.top - distance, that.minTop, that.maxTop);\n                handled = wrapper.css(\"top\", offset.top);\n              } else if (keyCode == keys.DOWN) {\n                offset.top = constrain(offset.top + distance, that.minTop, that.maxTop);\n                handled = wrapper.css(\"top\", offset.top);\n              } else if (keyCode == keys.LEFT) {\n                offset.left = constrain(offset.left - distance, that.minLeft, that.maxLeft);\n                handled = wrapper.css(\"left\", offset.left);\n              } else if (keyCode == keys.RIGHT) {\n                offset.left = constrain(offset.left + distance, that.minLeft, that.maxLeft);\n                handled = wrapper.css(\"left\", offset.left);\n              }\n            }\n\n            if (options.resizable && e.ctrlKey && !isMaximized && !isMinimized) {\n              if (keyCode == keys.UP) {\n                handled = true;\n                newHeight = wrapper.outerHeight() - distance;\n              } else if (keyCode == keys.DOWN) {\n                handled = true;\n\n                if (that.containment && !that._isPinned) {\n                  newHeight = Math.min(wrapper.outerHeight() + distance, that.containment.height - offset.top - toInt(wrapper, \"padding-top\") - toInt(wrapper, \"borderBottomWidth\") - toInt(wrapper, \"borderTopWidth\"));\n                } else {\n                  newHeight = wrapper.outerHeight() + distance;\n                }\n              }\n\n              if (keyCode == keys.LEFT) {\n                handled = true;\n                newWidth = wrapper.outerWidth() - distance;\n              } else if (keyCode == keys.RIGHT) {\n                handled = true;\n\n                if (that.containment && !that._isPinned) {\n                  newWidth = Math.min(wrapper.outerWidth() + distance, that.containment.width - offset.left - toInt(wrapper, \"borderLeftWidth\") - toInt(wrapper, \"borderRightWidth\"));\n                } else {\n                  newWidth = wrapper.outerWidth() + distance;\n                }\n              }\n\n              if (handled) {\n                w = constrain(newWidth, options.minWidth, options.maxWidth);\n                h = constrain(newHeight, options.minHeight, options.maxHeight);\n\n                if (!isNaN(w)) {\n                  wrapper.outerWidth(w);\n                  that.options.width = w + \"px\";\n                }\n\n                if (!isNaN(h)) {\n                  wrapper.outerHeight(h);\n                  that.options.height = h + \"px\";\n                }\n\n                that.resize();\n              }\n            }\n\n            if (handled) {\n              e.preventDefault();\n            }\n          },\n          _overlay: function (visible) {\n            var overlay = this.containment ? this.containment.children(KOVERLAY) : this.appendTo.children(KOVERLAY),\n                wrapper = this.wrapper,\n                display = visible ? \"block\" : \"none\",\n                zIndex = parseInt(wrapper.css(ZINDEX), 10) - 1;\n\n            if (!overlay.length) {\n              overlay = $(\"<div class='k-overlay' />\");\n            }\n\n            overlay.insertBefore(wrapper[0]).css({\n              zIndex: zIndex,\n              display: display\n            });\n\n            if (this.options.modal.preventScroll && !this.containment) {\n              this._stopDocumentScrolling();\n            }\n\n            return overlay;\n          },\n          _actionForIcon: function (icon) {\n            var iconClass = /\\bk-i(-\\w+)+\\b/.exec(icon[0].className)[0];\n            return {\n              \"k-i-close\": \"_close\",\n              \"k-i-window-maximize\": \"maximize\",\n              \"k-i-window-minimize\": \"minimize\",\n              \"k-i-window-restore\": \"restore\",\n              \"k-i-refresh\": \"refresh\",\n              \"k-i-pin\": \"pin\",\n              \"k-i-unpin\": \"unpin\"\n            }[iconClass];\n          },\n          _windowActionHandler: function (e) {\n            if (this._closing) {\n              return;\n            }\n\n            var icon = $(e.target).closest(\".k-window-action\").find(\".k-icon\");\n\n            var action = this._actionForIcon(icon);\n\n            if (action) {\n              e.preventDefault();\n              this[action]();\n              return false;\n            }\n          },\n          _modals: function () {\n            var that = this,\n                windowElements = $(KWINDOW + VISIBLE),\n                windowInstance,\n                modals = [];\n\n            for (var i = 0; i < windowElements.length; i += 1) {\n              windowInstance = that._object($(windowElements[i]));\n\n              if (windowInstance && windowInstance.options && windowInstance.options.modal && windowInstance.options.visible && windowInstance.options.appendTo === that.options.appendTo && (!windowInstance.containment || that.containment && windowInstance.containment[0] === that.containment[0])) {\n                modals.push(windowInstance.wrapper[0]);\n              }\n            }\n\n            modals.sort(function (a, b) {\n              return a.style.zIndex - b.style.zIndex;\n            });\n            that = null;\n            return $(modals);\n          },\n          _object: function (element) {\n            var content = element.children(KWINDOWCONTENT);\n            var widget = kendo.widgetInstance(content);\n\n            if (widget) {\n              return widget;\n            }\n\n            return undefined;\n          },\n          center: function () {\n            var that = this,\n                position = that.options.position,\n                wrapper = that.wrapper,\n                documentWindow = $(window),\n                scrollTop = 0,\n                scrollLeft = 0,\n                newTop,\n                newLeft;\n\n            if (that.options.isMaximized) {\n              return that;\n            }\n\n            if (that.options.pinned && !that._isPinned) {\n              that.pin();\n            }\n\n            if (!that.options.pinned) {\n              scrollTop = documentWindow.scrollTop();\n              scrollLeft = documentWindow.scrollLeft();\n            }\n\n            if (this.containment && !that.options.pinned) {\n              newTop = this.minTop + (this.maxTop - this.minTop) / 2;\n              newLeft = this.minLeft + (this.maxLeft - this.minLeft) / 2;\n            } else {\n              that._scrollIsAppended = true;\n              newLeft = scrollLeft + Math.max(0, (documentWindow.width() - wrapper.outerWidth()) / 2);\n              newTop = scrollTop + Math.max(0, (documentWindow.height() - wrapper.outerHeight() - toInt(wrapper, \"paddingTop\")) / 2);\n            }\n\n            wrapper.css({\n              left: newLeft,\n              top: newTop\n            });\n            position.top = newTop;\n            position.left = newLeft;\n            return that;\n          },\n          title: function (title) {\n            var that = this,\n                value,\n                encoded = true,\n                wrapper = that.wrapper,\n                titleBar = wrapper.children(KWINDOWTITLEBAR),\n                titleElement = titleBar.children(KWINDOWTITLE);\n\n            if (!arguments.length) {\n              return titleElement.html();\n            }\n\n            if ($.isPlainObject(title)) {\n              value = typeof title.text !== \"undefined\" ? title.text : \"\";\n              encoded = title.encoded !== false;\n            } else {\n              value = title;\n            }\n\n            if (value === false) {\n              wrapper.addClass(\"k-window-titleless\");\n              wrapper.css(\"padding-top\", 0);\n              titleBar.remove();\n            } else {\n              if (!titleBar.length) {\n                wrapper.prepend(templates.titlebar({\n                  title: encoded ? kendo.htmlEncode(value) : value\n                }));\n\n                that._actions();\n\n                titleBar = wrapper.children(KWINDOWTITLEBAR);\n              } else {\n                titleElement.html(encoded ? kendo.htmlEncode(value) : value);\n              }\n            }\n\n            that.options.title = value;\n            return that;\n          },\n          content: function (html, data) {\n            var content = this.wrapper.children(KWINDOWCONTENT),\n                scrollContainer = content.children(\".km-scroll-container\");\n            content = scrollContainer[0] ? scrollContainer : content;\n\n            if (!defined(html)) {\n              return content.html();\n            }\n\n            this.angular(\"cleanup\", function () {\n              return {\n                elements: content.children()\n              };\n            });\n            kendo.destroy(this.element.children());\n            content.empty().html(html);\n            this.angular(\"compile\", function () {\n              var a = [];\n\n              for (var i = content.length; --i >= 0;) {\n                a.push({\n                  dataItem: data\n                });\n              }\n\n              return {\n                elements: content.children(),\n                data: a\n              };\n            });\n            return this;\n          },\n          open: function () {\n            var that = this,\n                wrapper = that.wrapper,\n                options = that.options,\n                showOptions = this._animationOptions(\"open\"),\n                contentElement = wrapper.children(KWINDOWCONTENT),\n                overlay,\n                otherModalsVisible,\n                containmentContext = this.containment && !that._isPinned,\n                doc = containmentContext ? this.containment : $(document);\n\n            if (!that.trigger(OPEN)) {\n              if (that._closing) {\n                wrapper.kendoStop(true, true);\n              }\n\n              that._closing = false;\n              that.toFront();\n\n              if (options.autoFocus) {\n                that.wrapper.trigger(\"focus\");\n              }\n\n              options.visible = true;\n\n              if (options.modal) {\n                otherModalsVisible = !!that._modals().length;\n                overlay = that._overlay(otherModalsVisible);\n                overlay.kendoStop(true, true);\n\n                if (showOptions.duration && kendo.effects.Fade && !otherModalsVisible) {\n                  var overlayFx = kendo.fx(overlay).fadeIn();\n                  overlayFx.duration(showOptions.duration || 0);\n                  overlayFx.endValue(0.5);\n                  overlayFx.play();\n                } else {\n                  overlay.css(\"opacity\", 0.5);\n                }\n\n                overlay.show();\n                $(window).on(\"focus\" + MODAL_NS, function () {\n                  if (wrapper.data(\"isFront\") && !$(document.activeElement).closest(wrapper).length) {\n                    that.wrapper.trigger(\"focus\");\n                  }\n                });\n              }\n\n              if (!wrapper.is(VISIBLE)) {\n                contentElement.css(OVERFLOW, HIDDEN);\n                that.wrapper.find(TITLEBAR_BUTTONS).addClass(\"k-button-flat\");\n                wrapper.addClass(INLINE_FLEX).kendoStop().kendoAnimate({\n                  effects: showOptions.effects,\n                  duration: showOptions.duration,\n                  complete: this._activate.bind(this)\n                });\n              }\n            }\n\n            if (options.isMaximized) {\n              that._containerScrollTop = doc.scrollTop();\n              that._containerScrollLeft = doc.scrollLeft();\n\n              that._stopDocumentScrolling();\n            }\n\n            if (this.options.pinned && !this._isPinned) {\n              this.pin();\n            }\n\n            return that;\n          },\n          _activate: function () {\n            var scrollable = this.options.scrollable !== false;\n\n            if (this.options.autoFocus) {\n              this.wrapper.trigger(\"focus\");\n            }\n\n            this.element.css(OVERFLOW, scrollable ? \"\" : \"hidden\");\n            kendo.resize(this.element.children());\n            this.trigger(ACTIVATE);\n          },\n          _removeOverlay: function (suppressAnimation) {\n            var modals = this._modals();\n\n            var options = this.options;\n            var hideOverlay = options.modal && !modals.length;\n\n            var hideOptions = this._animationOptions(\"close\");\n\n            if (hideOverlay) {\n              if (!suppressAnimation && hideOptions.duration && kendo.effects.Fade) {\n                var overlayFx = kendo.fx(options.modal ? this._overlay(true) : $(undefined)).fadeOut();\n                overlayFx.duration(hideOptions.duration || 0);\n                overlayFx.startValue(0.5);\n                overlayFx.play();\n              } else {\n                this._overlay(false).remove();\n              }\n\n              if (options.modal.preventScroll) {\n                this._enableDocumentScrolling();\n              }\n            } else if (modals.length) {\n              this._object(modals.last())._overlay(true);\n\n              if (options.modal.preventScroll) {\n                this._stopDocumentScrolling();\n              }\n            }\n          },\n          _close: function (systemTriggered) {\n            var that = this,\n                wrapper = that.wrapper,\n                options = that.options,\n                showOptions = this._animationOptions(\"open\"),\n                hideOptions = this._animationOptions(\"close\"),\n                containmentContext = this.containment && !that._isPinned,\n                doc = containmentContext ? this.containment : $(document),\n                defaultPrevented;\n\n            if (that._closing) {\n              return;\n            }\n\n            defaultPrevented = that.trigger(CLOSE, {\n              userTriggered: !systemTriggered\n            });\n            that._closing = !defaultPrevented;\n\n            if (wrapper.is(VISIBLE) && !defaultPrevented) {\n              options.visible = false;\n              $(KWINDOW).each(function (i, element) {\n                var contentElement = $(element).children(KWINDOWCONTENT); // Remove overlay set by toFront\n\n                if (element != wrapper && contentElement.find(\"> .\" + KCONTENTFRAME).length > 0) {\n                  contentElement.children(KOVERLAY).remove();\n                }\n              });\n\n              this._removeOverlay(); // Prevent close animation from stopping\n\n\n              that.wrapper.find(TITLEBAR_BUTTONS).removeClass(\"k-button-flat\");\n              wrapper.kendoStop().kendoAnimate({\n                effects: hideOptions.effects || showOptions.effects,\n                reverse: hideOptions.reverse === true,\n                duration: hideOptions.duration,\n                complete: this._deactivate.bind(this)\n              });\n              $(window).off(MODAL_NS);\n            }\n\n            if (that.options.isMaximized) {\n              that._enableDocumentScrolling();\n\n              if (that._containerScrollTop && that._containerScrollTop > 0) {\n                doc.scrollTop(that._containerScrollTop);\n              }\n\n              if (that._containerScrollLeft && that._containerScrollLeft > 0) {\n                doc.scrollLeft(that._containerScrollLeft);\n              }\n            }\n\n            if (that.options.iframe) {\n              that.wrapper.trigger(\"blur\");\n            }\n          },\n          _deactivate: function () {\n            var that = this;\n            that.wrapper.removeClass(INLINE_FLEX).hide().css(\"opacity\", \"\");\n            that.trigger(DEACTIVATE);\n\n            if (that.options.modal) {\n              var lastModal = that._object(that._modals().last());\n\n              if (lastModal) {\n                lastModal.toFront();\n              }\n            }\n          },\n          close: function () {\n            this._close(true);\n\n            return this;\n          },\n          _actionable: function (element) {\n            return $(element).is(TITLEBAR_BUTTONS + \",\" + TITLEBAR_BUTTONS + \" .k-icon, :input, a, .k-input, .k-icon, [role='gridcell']\");\n          },\n          _shouldFocus: function (target) {\n            var active = activeElement(),\n                element = this.wrapper;\n            return this.options.autoFocus && !$(active).is(element) && !this._actionable(target) && (!element.find(active).length || !element.find(target).length);\n          },\n          toFront: function (e, avoidFocus) {\n            var that = this,\n                wrapper = that.wrapper,\n                currentWindow = wrapper[0],\n                containmentContext = that.containment && !that._isPinned,\n                openAnimation = this._animationOptions(\"open\"),\n                zIndex = +wrapper.css(ZINDEX),\n                originalZIndex = zIndex,\n                target = e && e.target || null;\n\n            $(KWINDOW).each(function (i, element) {\n              var windowObject = $(element),\n                  zIndexNew = windowObject.css(ZINDEX),\n                  contentElement = windowObject.children(KWINDOWCONTENT);\n\n              if (!isNaN(zIndexNew)) {\n                zIndex = Math.max(+zIndexNew, zIndex);\n              }\n\n              wrapper.data(\"isFront\", element == currentWindow); // Add overlay to windows with iframes and lower z-index to prevent\n              // trapping of events when resizing / dragging\n\n              if (element != currentWindow && contentElement.find(\".\" + KCONTENTFRAME).length && !contentElement.find(KOVERLAY).length) {\n                contentElement.append(templates.overlay);\n              }\n            });\n\n            if (!wrapper[0].style.zIndex || originalZIndex < zIndex) {\n              wrapper.css(ZINDEX, zIndex + 2);\n            }\n\n            that.element.find(\"> .k-overlay\").remove();\n\n            if (that._shouldFocus(target)) {\n              if (!avoidFocus) {\n                setTimeout(function () {\n                  that.wrapper.focus();\n                }, openAnimation ? openAnimation.duration : 0);\n              }\n\n              var scrollTop = containmentContext ? that.containment.scrollTop() : $(window).scrollTop(),\n                  windowTop = parseInt(wrapper.position().top, 10);\n\n              if (!that.options.pinned && windowTop > 0 && windowTop < scrollTop) {\n                if (scrollTop > 0) {\n                  $(window).scrollTop(windowTop);\n                } else {\n                  wrapper.css(\"top\", scrollTop);\n                }\n              }\n            }\n\n            wrapper = null;\n            return that;\n          },\n          toggleMaximization: function () {\n            if (this._closing) {\n              return this;\n            }\n\n            return this[this.options.isMaximized ? \"restore\" : \"maximize\"]();\n          },\n          restore: function () {\n            var that = this;\n            var options = that.options;\n            var minHeight = options.minHeight;\n            var restoreOptions = that.restoreOptions;\n            var shouldRestrictTop;\n            var container = that.containment && !that._isPinned ? that.containment : $(document);\n\n            if (!options.isMaximized && !options.isMinimized) {\n              return that;\n            }\n\n            if (minHeight && minHeight != Infinity) {\n              that.wrapper.css(\"min-height\", minHeight);\n            }\n\n            if (restoreOptions && !options.isMaximized) {\n              restoreOptions.height = constrain(restoreOptions.height, that.options.minHeight, that.options.maxHeight);\n              shouldRestrictTop = options.position.top + parseInt(restoreOptions.height, 10) > that.maxTop;\n\n              if (shouldRestrictTop) {\n                options.position.top = constrain(options.position.top, that.minTop, that.maxTop - parseInt(restoreOptions.height, 10));\n                extend(restoreOptions, {\n                  left: options.position.left,\n                  top: options.position.top\n                });\n              }\n            }\n\n            that.wrapper.css({\n              position: options.pinned ? \"fixed\" : \"absolute\",\n              left: restoreOptions.left,\n              top: restoreOptions.top,\n              width: restoreOptions.width,\n              height: restoreOptions.height\n            }).removeClass(MAXIMIZEDSTATE).find(\".k-window-content,.k-resize-handle\").show().end().find(\".k-window-titlebar .k-i-window-restore\").parent().remove().end().end().find(MINIMIZE_MAXIMIZE).parent().show().end().end().find(PIN_UNPIN).parent().show();\n\n            if (options.isMaximized) {\n              that.wrapper.find(\".k-i-window-maximize\").parent().trigger(\"focus\");\n            } else if (options.isMinimized) {\n              that.wrapper.find(\".k-i-window-minimize\").parent().trigger(\"focus\");\n            }\n\n            that.options.width = restoreOptions.width;\n            that.options.height = restoreOptions.height;\n\n            if (!that.options.modal.preventScroll) {\n              that._enableDocumentScrolling();\n            }\n\n            if (that._containerScrollTop && that._containerScrollTop > 0) {\n              container.scrollTop(that._containerScrollTop);\n            }\n\n            if (that._containerScrollLeft && that._containerScrollLeft > 0) {\n              container.scrollLeft(that._containerScrollLeft);\n            }\n\n            options.isMaximized = options.isMinimized = false;\n            that.wrapper.removeAttr(\"aria-labelled-by\");\n            that.resize();\n            that.trigger(RESTORE);\n            return that;\n          },\n          _sizingAction: function (actionId, callback) {\n            var that = this,\n                wrapper = that.wrapper,\n                style = wrapper[0].style,\n                options = that.options;\n\n            if (options.isMaximized || options.isMinimized) {\n              return that;\n            }\n\n            that.restoreOptions = {\n              width: style.width,\n              height: style.height\n            };\n            wrapper.children(KWINDOWRESIZEHANDLES).hide().end().children(KWINDOWTITLEBAR).find(MINIMIZE_MAXIMIZE).parent().hide().eq(0).before(templates.action({\n              name: \"window-restore\"\n            }));\n            callback.call(that);\n            that.wrapper.children(KWINDOWTITLEBAR).find(PIN_UNPIN).parent().toggle(actionId !== \"maximize\");\n            that.trigger(actionId);\n            wrapper.find(\".k-i-window-restore\").parent().trigger(\"focus\");\n            return that;\n          },\n          maximize: function () {\n            this._sizingAction(\"maximize\", function () {\n              var that = this,\n                  wrapper = that.wrapper,\n                  containmentContext = this.containment && !that._isPinned,\n                  position = wrapper.position(),\n                  doc = $(document);\n              extend(that.restoreOptions, {\n                left: position.left + (containmentContext ? this.containment.scrollLeft() : 0),\n                top: position.top + (containmentContext ? this.containment.scrollTop() : 0)\n              });\n              this._containerScrollTop = containmentContext ? this.containment.scrollTop() : doc.scrollTop();\n              this._containerScrollLeft = containmentContext ? this.containment.scrollLeft() : doc.scrollLeft();\n\n              that._stopDocumentScrolling();\n\n              wrapper.css({\n                top: containmentContext ? this.containment.scrollTop() : 0,\n                left: containmentContext ? this.containment.scrollLeft() : 0,\n                position: containmentContext ? \"absolute\" : \"fixed\"\n              }).addClass(MAXIMIZEDSTATE);\n              that.options.isMaximized = true;\n\n              that._onDocumentResize();\n            });\n\n            return this;\n          },\n          _stopDocumentScrolling: function () {\n            var that = this;\n            var containment = that.containment;\n\n            if (containment && !that._isPinned) {\n              that._storeOverflowRule(containment);\n\n              containment.css(OVERFLOW, HIDDEN);\n              that.wrapper.css({\n                maxWidth: containment.innerWidth(),\n                maxHeight: containment.innerHeight()\n              });\n              return;\n            }\n\n            var $body = $(\"body\");\n\n            that._storeOverflowRule($body);\n\n            $body.css(OVERFLOW, HIDDEN);\n            var $html = $(\"html\");\n\n            that._storeOverflowRule($html);\n\n            $html.css(OVERFLOW, HIDDEN);\n          },\n          _enableDocumentScrolling: function () {\n            var that = this;\n            var containment = that.containment;\n\n            if (containment && !that._isPinned) {\n              that._restoreOverflowRule(containment);\n\n              that.wrapper.css({\n                maxWidth: containment.width,\n                maxHeight: containment.height\n              });\n              return;\n            }\n\n            that._restoreOverflowRule($(document.body));\n\n            that._restoreOverflowRule($(\"html\"));\n          },\n          _storeOverflowRule: function ($element) {\n            if (this._isOverflowStored($element)) {\n              return;\n            }\n\n            var overflowRule = $element.get(0).style.overflow;\n\n            if (typeof overflowRule === \"string\") {\n              $element.data(DATADOCOVERFLOWRULE, overflowRule);\n            }\n          },\n          _isOverflowStored: function ($element) {\n            return typeof $element.data(DATADOCOVERFLOWRULE) === \"string\";\n          },\n          _restoreOverflowRule: function ($element) {\n            var overflowRule = $element.data(DATADOCOVERFLOWRULE);\n\n            if (overflowRule !== null && overflowRule !== undefined) {\n              $element.css(OVERFLOW, overflowRule);\n              $element.removeData(DATADOCOVERFLOWRULE);\n            } else {\n              $element.css(OVERFLOW, \"\");\n            }\n          },\n          isMaximized: function () {\n            return this.options.isMaximized;\n          },\n          minimize: function () {\n            this._sizingAction(\"minimize\", function () {\n              var that = this;\n              that.wrapper.css({\n                height: \"\",\n                minHeight: \"\"\n              });\n              that.element.hide();\n              that.options.isMinimized = true;\n            });\n\n            this.wrapper.attr(\"aria-labelled-by\", this.element.attr(\"aria-labelled-by\"));\n\n            this._updateBoundaries();\n\n            return this;\n          },\n          isMinimized: function () {\n            return this.options.isMinimized;\n          },\n          pin: function () {\n            var that = this,\n                win = $(window),\n                wrapper = that.wrapper,\n                options = that.options,\n                position = options.position,\n                top = this.containment ? getPosition(wrapper[0]).top + toInt(this.containment, \"borderTopWidth\") : toInt(wrapper, \"top\"),\n                left = this.containment ? getPosition(wrapper[0]).left + toInt(this.containment, \"borderLeftWidth\") : toInt(wrapper, \"left\");\n\n            if (!that.options.isMaximized) {\n              position.top = top;\n              position.left = left;\n\n              if (that._scrollIsAppended && (!this.containment || this.containment.css(\"position\") !== \"fixed\")) {\n                position.top -= win.scrollTop();\n                position.left -= win.scrollLeft();\n                that._scrollIsAppended = false;\n              }\n\n              wrapper.css(extend(position, {\n                position: \"fixed\"\n              }));\n              wrapper.children(KWINDOWTITLEBAR).find(KPIN).addClass(\"k-i-unpin\").removeClass(\"k-i-pin\");\n              that._isPinned = true;\n              that.options.pinned = true;\n\n              if (this.containment) {\n                options.maxWidth = options.maxHeight = Infinity;\n                wrapper.css({\n                  maxWidth: \"\",\n                  maxHeight: \"\"\n                });\n              }\n            }\n          },\n          unpin: function () {\n            var that = this,\n                win = $(window),\n                wrapper = that.wrapper,\n                options = that.options,\n                position = that.options.position,\n                containment = that.containment,\n                top = parseInt(wrapper.css(\"top\"), 10) + win.scrollTop(),\n                left = parseInt(wrapper.css(\"left\"), 10) + win.scrollLeft();\n\n            if (!that.options.isMaximized) {\n              that._isPinned = false;\n              that._scrollIsAppended = true;\n              that.options.pinned = false;\n\n              if (containment) {\n                that._updateBoundaries();\n\n                options.maxWidth = Math.min(containment.width, options.maxWidth);\n                options.maxHeight = Math.min(containment.height - toInt(wrapper, \"padding-top\"), options.maxHeight);\n                wrapper.css({\n                  maxWidth: options.maxWidth,\n                  maxHeight: options.maxHeight\n                });\n\n                if (top < containment.position.top) {\n                  top = that.minTop;\n                } else if (top > containment.position.top + containment.height) {\n                  top = that.maxTop;\n                } else {\n                  top = top + containment.scrollTop() - (containment.position.top + toInt(containment, \"border-top-width\"));\n                }\n\n                if (left < containment.position.left) {\n                  left = that.minLeft;\n                } else if (left > containment.position.left + containment.width) {\n                  left = that.maxLeft;\n                } else {\n                  left = left + containment.scrollLeft() - (containment.position.left + toInt(containment, \"border-left-width\"));\n                }\n              }\n\n              position.top = constrain(top, that.minTop, that.maxTop);\n              position.left = constrain(left, that.minLeft, that.maxLeft);\n              wrapper.css(extend(position, {\n                position: \"\"\n              }));\n              wrapper.children(KWINDOWTITLEBAR).find(KUNPIN).addClass(\"k-i-pin\").removeClass(\"k-i-unpin\");\n            }\n          },\n          _onDocumentResize: function () {\n            var that = this,\n                wrapper = that.wrapper,\n                wnd = $(window),\n                zoomLevel = kendo.support.zoomLevel(),\n                contentBoxSizing = wrapper.css(\"box-sizing\") == \"content-box\",\n                w,\n                h;\n\n            if (!that.options.isMaximized) {\n              return;\n            }\n\n            var lrBorderWidth = contentBoxSizing ? toInt(wrapper, \"border-left-width\") + toInt(wrapper, \"border-right-width\") : 0;\n            var tbBorderWidth = contentBoxSizing ? toInt(wrapper, \"border-top-width\") + toInt(wrapper, \"border-bottom-width\") : 0;\n            var paddingTop = contentBoxSizing ? toInt(wrapper, \"padding-top\") : 0;\n\n            if (that.containment && !that._isPinned) {\n              w = that.containment.innerWidth() - lrBorderWidth;\n              h = that.containment.innerHeight() - (tbBorderWidth + paddingTop);\n            } else {\n              w = wnd.width() / zoomLevel - lrBorderWidth;\n              h = wnd.height() / zoomLevel - (tbBorderWidth + paddingTop);\n            }\n\n            wrapper.css({\n              width: w,\n              height: h\n            });\n            that.options.width = w;\n            that.options.height = h;\n            that.resize();\n          },\n          refresh: function (options) {\n            var that = this,\n                initOptions = that.options,\n                element = $(that.element),\n                iframe,\n                showIframe,\n                url;\n\n            if (!isPlainObject(options)) {\n              options = {\n                url: options\n              };\n            }\n\n            options = extend(initOptions.content, options);\n            showIframe = defined(initOptions.iframe) ? initOptions.iframe : options.iframe;\n            url = options.url;\n\n            if (url) {\n              if (!defined(showIframe)) {\n                showIframe = !isLocalUrl(url);\n              }\n\n              if (!showIframe) {\n                // perform AJAX request\n                that._ajaxRequest(options);\n              } else {\n                iframe = element.find(\".\" + KCONTENTFRAME)[0];\n\n                if (iframe) {\n                  // refresh existing iframe\n                  iframe.src = url || iframe.src;\n                } else {\n                  // render new iframe\n                  element.html(templates.contentFrame(extend({}, initOptions, {\n                    content: options\n                  })));\n                }\n\n                element.find(\".\" + KCONTENTFRAME).off(\"load\" + NS).on(\"load\" + NS, this._triggerRefresh.bind(this));\n              }\n            } else {\n              if (options.template) {\n                // refresh template\n                that.content(template(options.template)({}));\n              }\n\n              that.trigger(REFRESH);\n            }\n\n            element.toggleClass(\"k-window-iframecontent\", !!showIframe);\n            return that;\n          },\n          _triggerRefresh: function () {\n            this.trigger(REFRESH);\n          },\n          _ajaxComplete: function () {\n            clearTimeout(this._loadingIconTimeout);\n            this.wrapper.find(REFRESHICON).removeClass(LOADING);\n          },\n          _ajaxError: function (xhr, status) {\n            this.trigger(ERROR, {\n              status: status,\n              xhr: xhr\n            });\n          },\n          _ajaxSuccess: function (contentTemplate) {\n            return function (data) {\n              var html = data;\n\n              if (contentTemplate) {\n                html = template(contentTemplate)(data || {});\n              }\n\n              this.content(html, data);\n              this.element.prop(\"scrollTop\", 0);\n              this.trigger(REFRESH);\n            };\n          },\n          _showLoading: function () {\n            this.wrapper.find(REFRESHICON).addClass(LOADING);\n          },\n          _ajaxRequest: function (options) {\n            this._loadingIconTimeout = setTimeout(this._showLoading.bind(this), 100);\n            $.ajax(extend({\n              type: \"GET\",\n              dataType: \"html\",\n              cache: false,\n              error: this._ajaxError.bind(this),\n              complete: this._ajaxComplete.bind(this),\n              success: this._ajaxSuccess(options.template).bind(this)\n            }, options));\n          },\n          _destroy: function () {\n            if (this.resizing) {\n              this.resizing.destroy();\n            }\n\n            if (this.dragging) {\n              this.dragging.destroy();\n            }\n\n            this.wrapper.off(NS).children(KWINDOWCONTENT).off(NS).end().find(\".k-resize-handle,.k-window-titlebar\").off(NS);\n            $(window).off(\"resize\" + NS + this._marker);\n            $(window).off(MODAL_NS);\n            $(window).off(NS);\n            clearTimeout(this._loadingIconTimeout);\n            Widget.fn.destroy.call(this);\n            this.unbind(undefined);\n            kendo.destroy(this.wrapper);\n          },\n          destroy: function () {\n            this._destroy();\n\n            if (this.options.modal) {\n              this._removeOverlay(true);\n            }\n\n            this.wrapper.empty().remove();\n            this.wrapper = this.appendTo = this.element = $();\n          },\n          _createWindow: function () {\n            var contentHtml = this.element,\n                options = this.options,\n                iframeSrcAttributes,\n                wrapper,\n                isRtl = kendo.support.isRtl(contentHtml);\n\n            if (options.scrollable === false) {\n              contentHtml.css(\"overflow\", \"hidden\");\n            }\n\n            wrapper = $(templates.wrapper(options)); // Collect the src attributes of all iframes and then set them to empty string.\n            // This seems to fix this IE9 \"feature\": http://msdn.microsoft.com/en-us/library/gg622929%28v=VS.85%29.aspx?ppud=4\n\n            iframeSrcAttributes = contentHtml.find(\"iframe:not(.k-content-frame)\").map(function () {\n              var src = this.getAttribute(\"src\");\n              this.src = \"\";\n              return src;\n            }); // Make sure the wrapper is appended to the body only once. IE9+ will throw exceptions if you move iframes in DOM\n\n            wrapper.toggleClass(\"k-rtl\", isRtl).attr(\"tabindex\", 0).append(contentHtml).find(\"iframe:not(.k-content-frame)\").each(function (index) {\n              // Restore the src attribute of the iframes when they are part of the live DOM tree\n              this.src = iframeSrcAttributes[index];\n            });\n\n            if (this.containment) {\n              this.containment.prepend(wrapper);\n            } else if (this.appendTo) {\n              wrapper.appendTo(this.appendTo);\n            }\n\n            wrapper.find(\".k-window-title\").css(isRtl ? \"left\" : \"right\", outerWidth(wrapper.find(\".k-window-actions\")) + 10);\n            contentHtml.css(\"visibility\", \"\").show();\n            contentHtml.find(\"[data-role=editor]\").each(function () {\n              var editor = $(this).data(\"kendoEditor\");\n\n              if (editor) {\n                editor.refresh();\n              }\n            });\n            wrapper = contentHtml = null;\n          }\n        });\n        templates = {\n          wrapper: template(\"<div class='k-widget k-window'></div>\"),\n          action: template(\"<a role='button' href='\\\\#' class='k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-window-action' aria-label='#= name #'>\" + \"<span class='k-button-icon k-icon k-i-#= name.toLowerCase() #'></span>\" + \"</a>\"),\n          titlebar: template(\"<div class='k-window-titlebar k-hstack'>\" + \"<span class='k-window-title'>#= title #</span>\" + \"<div class='k-window-actions k-hstack'></div>\" + \"</div>\"),\n          overlay: \"<div class='k-overlay'></div>\",\n          contentFrame: template(\"<iframe frameborder='0' title='#= title #' class='\" + KCONTENTFRAME + \"' \" + \"src='#= content.url #'>\" + \"This page requires frames in order to show content\" + \"</iframe>\"),\n          resizeHandle: template(\"<div aria-hidden='true' class='k-resize-handle k-resize-#= data #'></div>\")\n        };\n\n        function WindowResizing(wnd) {\n          var that = this;\n          that.owner = wnd;\n          that._preventDragging = false;\n          that._draggable = new Draggable(wnd.wrapper, {\n            filter: \">\" + KWINDOWRESIZEHANDLES,\n            group: wnd.wrapper.id + \"-resizing\",\n            dragstart: that.dragstart.bind(that),\n            drag: that.drag.bind(that),\n            dragend: that.dragend.bind(that)\n          });\n\n          that._draggable.userEvents.bind(\"press\", that.addOverlay.bind(that));\n\n          that._draggable.userEvents.bind(\"release\", that.removeOverlay.bind(that));\n        }\n\n        WindowResizing.prototype = {\n          addOverlay: function () {\n            this.owner.wrapper.append(templates.overlay);\n          },\n          removeOverlay: function () {\n            this.owner.wrapper.find(KOVERLAY).remove();\n          },\n          dragstart: function (e) {\n            var that = this;\n            var wnd = that.owner;\n            var wrapper = wnd.wrapper;\n            that._preventDragging = wnd.trigger(RESIZESTART);\n\n            if (that._preventDragging) {\n              return;\n            }\n\n            that.elementPadding = parseInt(wrapper.css(\"padding-top\"), 10);\n            that.initialPosition = kendo.getOffset(wrapper, \"position\");\n            that.resizeDirection = e.currentTarget.prop(\"className\").replace(\"k-resize-handle k-resize-\", \"\");\n            that.initialSize = {\n              width: wrapper.outerWidth(),\n              height: wrapper.outerHeight()\n            };\n\n            wnd._updateBoundaries();\n\n            that.containerOffset = wnd.containment ? wnd.containment.position : kendo.getOffset(wnd.appendTo);\n            var offsetParent = wrapper.offsetParent();\n\n            if (offsetParent.is(\"html\")) {\n              that.containerOffset.top = that.containerOffset.left = 0;\n            } else {\n              var marginTop = offsetParent.css(\"margin-top\");\n              var marginLeft = offsetParent.css(\"margin-left\");\n              var hasMargin = !zero.test(marginTop) || !zero.test(marginLeft);\n\n              if (hasMargin) {\n                var wrapperPosition = getPosition(wrapper[0]);\n                var relativeElMarginLeft = wrapperPosition.left - that.containerOffset.left - that.initialPosition.left;\n                var relativeElMarginTop = wrapperPosition.top - that.containerOffset.top - that.initialPosition.top;\n                that._relativeElMarginLeft = relativeElMarginLeft > 1 ? relativeElMarginLeft : 0;\n                that._relativeElMarginTop = relativeElMarginTop > 1 ? relativeElMarginTop : 0;\n                that.initialPosition.left += that._relativeElMarginLeft;\n                that.initialPosition.top += that._relativeElMarginTop;\n              }\n            }\n\n            wrapper.children(KWINDOWRESIZEHANDLES).not(e.currentTarget).hide();\n            $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));\n          },\n          drag: function (e) {\n            if (this._preventDragging) {\n              return;\n            }\n\n            var that = this,\n                wnd = that.owner,\n                wrapper = wnd.wrapper,\n                options = wnd.options,\n                position = options.position,\n                direction = that.resizeDirection,\n                containerOffset = that.containerOffset,\n                initialPosition = that.initialPosition,\n                initialSize = that.initialSize,\n                containmentContext = wnd.containment && !wnd._isPinned,\n                rtl = kendo.support.isRtl(wnd.containment),\n                leftRtlOffset = containmentContext && rtl && wnd.containment.innerWidth() > wnd.containment.width ? kendo.support.scrollbar() : 0,\n                scrollOffset = containmentContext ? {\n              top: wnd.containment.scrollTop(),\n              left: wnd.containment.scrollLeft()\n            } : {\n              top: 0,\n              left: 0\n            },\n                newWidth,\n                newHeight,\n                windowBottom,\n                windowRight,\n                x = Math.max(e.x.location, 0),\n                y = Math.max(e.y.location, 0);\n\n            if (direction.indexOf(\"e\") >= 0) {\n              if (wnd.containment && x - initialSize.width >= wnd.maxLeft - scrollOffset.left + containerOffset.left + leftRtlOffset) {\n                newWidth = wnd.maxLeft + leftRtlOffset - initialPosition.left + initialSize.width - scrollOffset.left;\n              } else {\n                newWidth = x - initialPosition.left - containerOffset.left;\n              }\n\n              wrapper.outerWidth(constrain(newWidth, options.minWidth, options.maxWidth));\n            } else if (direction.indexOf(\"w\") >= 0) {\n              windowRight = initialPosition.left + initialSize.width + containerOffset.left;\n              newWidth = constrain(windowRight - x, options.minWidth, options.maxWidth);\n              position.left = windowRight - newWidth - containerOffset.left - leftRtlOffset - (that._relativeElMarginLeft || 0) + scrollOffset.left;\n\n              if (wnd.containment && position.left <= wnd.minLeft) {\n                position.left = wnd.minLeft;\n                newWidth = constrain(windowRight - leftRtlOffset - position.left - containerOffset.left + scrollOffset.left, options.minWidth, options.maxWidth);\n              }\n\n              wrapper.css({\n                left: position.left,\n                width: newWidth\n              });\n            }\n\n            var newWindowTop = y;\n\n            if (wnd.options.pinned) {\n              newWindowTop -= $(window).scrollTop();\n            }\n\n            if (direction.indexOf(\"s\") >= 0) {\n              newHeight = newWindowTop - initialPosition.top - that.elementPadding - containerOffset.top;\n\n              if (newWindowTop - initialSize.height - that.elementPadding >= wnd.maxTop + containerOffset.top - scrollOffset.top) {\n                newHeight = wnd.maxTop - initialPosition.top + initialSize.height - scrollOffset.top;\n              }\n\n              wrapper.outerHeight(constrain(newHeight, options.minHeight, options.maxHeight));\n            } else if (direction.indexOf(\"n\") >= 0) {\n              windowBottom = initialPosition.top + initialSize.height + containerOffset.top;\n              newHeight = constrain(windowBottom - newWindowTop, options.minHeight, options.maxHeight);\n              position.top = windowBottom - newHeight - containerOffset.top - (that._relativeElMarginTop || 0) + scrollOffset.top;\n\n              if (position.top <= wnd.minTop && wnd.containment) {\n                position.top = wnd.minTop;\n                newHeight = constrain(windowBottom - position.top - containerOffset.top + scrollOffset.top, options.minHeight, options.maxHeight);\n              }\n\n              wrapper.css({\n                top: position.top,\n                height: newHeight\n              });\n            }\n\n            if (newWidth) {\n              wnd.options.width = newWidth + \"px\";\n            }\n\n            if (newHeight) {\n              wnd.options.height = newHeight + \"px\";\n            }\n\n            wnd.resize();\n          },\n          dragend: function (e) {\n            if (this._preventDragging) {\n              return;\n            }\n\n            var that = this,\n                wnd = that.owner,\n                wrapper = wnd.wrapper;\n            wrapper.children(KWINDOWRESIZEHANDLES).not(e.currentTarget).show();\n            $(BODY).css(CURSOR, \"\");\n\n            if (wnd.touchScroller) {\n              wnd.touchScroller.reset();\n            }\n\n            if (e.keyCode == 27) {\n              wrapper.css(that.initialPosition).css(that.initialSize);\n            }\n\n            wnd.trigger(RESIZEEND);\n            return false;\n          },\n          destroy: function () {\n            if (this._draggable) {\n              this._draggable.destroy();\n            }\n\n            this._draggable = this.owner = null;\n          }\n        };\n\n        function WindowDragging(wnd, dragHandle) {\n          var that = this;\n          that.owner = wnd;\n          that._preventDragging = false;\n          that._draggable = new Draggable(wnd.wrapper, {\n            filter: dragHandle,\n            group: wnd.wrapper.id + \"-moving\",\n            dragstart: that.dragstart.bind(that),\n            drag: that.drag.bind(that),\n            dragend: that.dragend.bind(that),\n            dragcancel: that.dragcancel.bind(that)\n          });\n          that._draggable.userEvents.stopPropagation = false;\n        }\n\n        WindowDragging.prototype = {\n          dragstart: function (e) {\n            var wnd = this.owner,\n                draggable = wnd.options.draggable,\n                element = wnd.element,\n                actions = element.find(\".k-window-actions\"),\n                containerOffset = kendo.getOffset(wnd.appendTo);\n            this._preventDragging = wnd.trigger(DRAGSTART) || !draggable;\n\n            if (this._preventDragging || wnd.isMaximized()) {\n              return;\n            }\n\n            wnd.initialWindowPosition = kendo.getOffset(wnd.wrapper, \"position\");\n            wnd.initialPointerPosition = {\n              left: wnd.options.position.left,\n              top: wnd.options.position.top\n            };\n            wnd.startPosition = {\n              left: e.x.client - wnd.initialWindowPosition.left,\n              top: e.y.client - wnd.initialWindowPosition.top\n            };\n\n            wnd._updateBoundaries();\n\n            if (!wnd.containment) {\n              if (actions.length > 0) {\n                wnd.minLeft = outerWidth(actions) + parseInt(actions.css(\"right\"), 10) - outerWidth(element);\n              } else {\n                wnd.minLeft = 20 - outerWidth(element); // at least 20px remain visible\n              }\n\n              wnd.minLeft -= containerOffset.left;\n              wnd.minTop = -containerOffset.top;\n            }\n\n            $(templates.overlay).appendTo(wnd.wrapper).css({\n              opacity: 0\n            });\n            wnd.wrapper.children(KWINDOWRESIZEHANDLES).hide();\n            $(BODY).css(CURSOR, e.currentTarget.css(CURSOR));\n          },\n          drag: function (e) {\n            var wnd = this.owner;\n            var position = wnd.options.position;\n            var axis = wnd.options.draggable.axis;\n            var left;\n            var top;\n\n            if (this._preventDragging || wnd.isMaximized()) {\n              return;\n            }\n\n            if (!axis || axis.toLowerCase() === \"x\") {\n              left = e.x.client - wnd.startPosition.left;\n\n              if (wnd.containment && !wnd._isPinned) {\n                left += wnd.containment.scrollLeft();\n              }\n\n              position.left = constrain(left, wnd.minLeft, wnd.maxLeft);\n            }\n\n            if (!axis || axis.toLowerCase() === \"y\") {\n              top = e.y.client - wnd.startPosition.top;\n\n              if (wnd.containment && !wnd._isPinned) {\n                top += wnd.containment.scrollTop();\n              }\n\n              position.top = constrain(top, wnd.minTop, wnd.maxTop);\n            }\n\n            if (kendo.support.transforms) {\n              $(wnd.wrapper).css(\"transform\", \"translate(\" + (position.left - wnd.initialPointerPosition.left) + \"px, \" + (position.top - wnd.initialPointerPosition.top) + \"px)\");\n            } else {\n              $(wnd.wrapper).css(position);\n            }\n          },\n          _finishDrag: function () {\n            var wnd = this.owner;\n            wnd.wrapper.children(KWINDOWRESIZEHANDLES).toggle(!wnd.options.isMinimized).end().find(KOVERLAY).remove();\n            $(BODY).css(CURSOR, \"\");\n          },\n          dragcancel: function (e) {\n            if (this._preventDragging) {\n              return;\n            }\n\n            this._finishDrag();\n\n            e.currentTarget.closest(KWINDOW).css(this.owner.initialWindowPosition);\n          },\n          dragend: function () {\n            var wnd = this.owner;\n\n            if (this._preventDragging || wnd.isMaximized()) {\n              return;\n            }\n\n            $(wnd.wrapper).css(wnd.options.position).css(\"transform\", \"\");\n\n            this._finishDrag();\n\n            wnd.trigger(DRAGEND);\n            return false;\n          },\n          destroy: function () {\n            if (this._draggable) {\n              this._draggable.destroy();\n            }\n\n            this._draggable = this.owner = null;\n          }\n        };\n        kendo.ui.plugin(Window);\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}