{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1713);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  958:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../util/text-metrics\");\n    /***/\n  },\n\n  /***/\n  973:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./range\");\n    /***/\n  },\n\n  /***/\n  1691:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./sheet\");\n    /***/\n  },\n\n  /***/\n  1706:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./references\");\n    /***/\n  },\n\n  /***/\n  1713:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1714), __webpack_require__(1691), __webpack_require__(973), __webpack_require__(1706), __webpack_require__(1715), __webpack_require__(958)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\";\n\n      var spreadsheet = kendo.spreadsheet;\n      var CellRef = spreadsheet.CellRef;\n      var kdrw = kendo.drawing;\n      var formatting = spreadsheet.formatting;\n      var geo = kendo.geometry;\n      var GUIDELINE_WIDTH = 0.8;\n      /* jshint eqnull:true, laxbreak:true, shadow:true, -W054 */\n\n      /* jshint latedef: nofunc */\n      // This takes a list of row heights and the page height, and\n      // produces a list of Y coordinates for each row, such that rows\n      // are not truncated across pages.  However, the algorithm will\n      // decide to truncate a row in the event that more than\n      // `maxEmpty` (default 0.2) of the available space would\n      // otherwise be left blank.\n      //\n      // It will be used for horizontal splitting too (will receive\n      // column widths and page width, and produce a list of X coords).\n      //\n      // If the third argument (headerRows) is not null, it specifies a\n      // number of rows to repeat on each page.  On pages other than the\n      // first, the necessary space will be skipped at the top.  Header\n      // coordinates (except for the first page) are pushed in\n      // headerCoords.\n\n      function distributeCoords(heights, pageHeight, maxEmpty, headerRows, headerCoords) {\n        var curr = 0;\n        var out = [];\n        var bottom = pageHeight;\n        var header = 0;\n\n        if (pageHeight && maxEmpty) {\n          maxEmpty *= pageHeight;\n        }\n\n        heights.forEach(function (h, i) {\n          if (headerRows != null && i < headerRows) {\n            header += h;\n          }\n\n          if (pageHeight && curr + h > bottom) {\n            if (bottom - curr < maxEmpty) {\n              // align to next page\n              curr = pageHeight * Math.ceil(curr / pageHeight) + header;\n\n              if (header > 0) {\n                headerCoords.push(curr - header);\n              }\n            } // update bottom anyway; don't just add pageHeight, as\n            // we might need multiple pages for the pathological\n            // case of one row higher than the page.\n\n\n            bottom += pageHeight * Math.ceil(h / pageHeight);\n          }\n\n          out.push(curr);\n          curr += h;\n        });\n        out.push(curr);\n        return out;\n      }\n\n      function doLayout(sheet, range, options) {\n        // normalize reference so we don't have to deal with Infinity here.\n        var grid = sheet._grid;\n        range = grid.normalize(range);\n        var wholeRect = grid.rectangle(range);\n        var drawings = [];\n\n        sheet._drawings.forEach(function (d) {\n          var box = sheet.drawingBoundingBox(d);\n\n          if (box.intersects(wholeRect)) {\n            drawings.push({\n              drawing: d,\n              box: box.offset(-wholeRect.left, -wholeRect.top)\n            });\n          }\n        }); // 1. obtain the list of cells that need to be printed, the\n        //    row heights and column widths.  Place in each cell row,\n        //    col (relative to range, i.e. first is 0,0), rowspan,\n        //    colspan and merged.  also place a list of drawings\n        //    anchored to that cell.\n\n\n        var cells = [];\n        var rowHeights = [];\n        var colWidths = [];\n\n        var mergedCells = sheet._getMergedCells(range);\n\n        var maxRow = -1,\n            maxCol = -1;\n        sheet.forEach(range, function (row, col, cell) {\n          var relrow = row - range.topLeft.row;\n          var relcol = col - range.topLeft.col;\n          var rh = sheet.rowHeight(row);\n          var cw = sheet.columnWidth(col);\n\n          if (!options.forScreen) {\n            // for printing we'll need the list of anchored\n            // drawings so that we can adjust them after page\n            // splitting.\n            cell.drawings = drawings.filter(function (d) {\n              var tl = d.drawing.topLeftCell;\n\n              if (tl && tl.row == row && tl.col == col) {\n                maxRow = Math.max(maxRow, sheet._rows.index(d.box.bottom));\n                maxCol = Math.max(maxCol, sheet._columns.index(d.box.right));\n                return true;\n              }\n            });\n          }\n\n          if (!relcol) {\n            rowHeights.push(rh);\n          }\n\n          if (!relrow) {\n            colWidths.push(cw);\n          }\n\n          var id = new CellRef(row, col).print();\n\n          if (mergedCells.secondary[id]) {\n            return;\n          }\n\n          cell.row = relrow;\n          cell.col = relcol;\n          var m = mergedCells.primary[id];\n\n          if (m) {\n            delete mergedCells.primary[id];\n            cell.merged = true;\n            cell.rowspan = m.height();\n            cell.colspan = m.width();\n\n            if (options.forScreen) {\n              cell.width = sheet._columns.sum(m.topLeft.col, m.bottomRight.col);\n              cell.height = sheet._rows.sum(m.topLeft.row, m.bottomRight.row);\n            }\n          } else {\n            cell.rowspan = 1;\n            cell.colspan = 1;\n          }\n\n          if (!sheet._grid._columns.sum(col, col + cell.colspan - 1) || !sheet._grid._rows.sum(row, row + cell.rowspan - 1)) {\n            return;\n          }\n\n          var nonEmpty = options.forScreen || shouldDrawCell(cell);\n\n          if (!(options.emptyCells || nonEmpty)) {\n            return;\n          }\n\n          if (nonEmpty) {\n            maxRow = Math.max(maxRow, relrow + cell.rowspan - 1);\n            maxCol = Math.max(maxCol, relcol + cell.colspan - 1);\n          } else {\n            cell.empty = true;\n          }\n\n          cells.push(cell);\n        });\n\n        if (!options.forScreen) {\n          // keep only the drawable area\n          rowHeights = rowHeights.slice(0, maxRow + 1);\n          colWidths = colWidths.slice(0, maxCol + 1);\n        }\n\n        var pageWidth = options.pageWidth;\n        var pageHeight = options.pageHeight;\n        var scaleFactor = options.scale || 1; // when fitWidth is requested, we must update the page size\n        // with the corresponding scale factor; the algorithm below\n        // (2) will continue to work, just drawing on a bigger page.\n\n        if (options.fitWidth) {\n          var width = colWidths.reduce(sum, 0);\n\n          if (width > pageWidth) {\n            scaleFactor = pageWidth / width;\n          }\n        }\n\n        pageWidth = Math.ceil(pageWidth / scaleFactor);\n        pageHeight = Math.ceil(pageHeight / scaleFactor); // 2. calculate top, left, bottom, right, width and height for\n        //    printable cells.  Merged cells will be split across\n        //    pages, unless the first row/col is shifted to next page.\n        //    boxWidth and boxHeight get the complete drawing size.\n        //    Note that cell coordinates keep increasing, i.e. they\n        //    are not reset to zero for a new page.  The print\n        //    function translates the view to current page.\n\n        var hyCoords = []; // will receive header Y coordinates, if needed\n\n        var yCoords = distributeCoords(rowHeights, pageHeight || 0, options.maxEmpty, options.headerRows, hyCoords);\n        var xCoords = distributeCoords(colWidths, pageWidth || 0, options.maxEmpty);\n        var boxWidth = 0;\n        var boxHeight = 0;\n        var headerCells = [];\n        cells = cells.filter(function (cell) {\n          if (cell.empty && (cell.row > maxRow || cell.col > maxCol)) {\n            return false;\n          }\n\n          if (options.headerRows && cell.row < options.headerRows) {\n            headerCells.push(cell);\n          }\n\n          cell.left = xCoords[cell.col];\n          cell.top = yCoords[cell.row];\n\n          if (cell.merged) {\n            if (!options.forScreen) {\n              cell.right = orlast(xCoords, cell.col + cell.colspan);\n              cell.bottom = orlast(yCoords, cell.row + cell.rowspan);\n              cell.width = cell.right - cell.left;\n              cell.height = cell.bottom - cell.top;\n            } else {\n              cell.right = cell.left + cell.width;\n              cell.bottom = cell.top + cell.height;\n            }\n          } else {\n            cell.width = colWidths[cell.col];\n            cell.height = rowHeights[cell.row];\n            cell.bottom = cell.top + cell.height;\n            cell.right = cell.left + cell.width;\n          }\n\n          if (!options.forScreen) {\n            // page breaking will shift cell coordinates.  adjust\n            // anchored drawings.\n            cell.drawings.forEach(function (d) {\n              var box = d.box;\n              box.left = cell.left + d.drawing.offsetX;\n              box.top = cell.top + d.drawing.offsetY;\n              box.right = box.left + box.width;\n              box.bottom = box.top + box.height;\n            });\n          }\n\n          boxWidth = Math.max(boxWidth, cell.right);\n          boxHeight = Math.max(boxHeight, cell.bottom);\n          return true;\n        }); // 3. if any merged cells remain in \"primary\", they start\n        //    outside the printed range and we should still display\n        //    them partially.\n\n        Object.keys(mergedCells.primary).forEach(function (id) {\n          var ref = mergedCells.primary[id];\n          sheet.forEach(ref.topLeft.toRangeRef(), function (row, col, cell) {\n            var relrow = row - range.topLeft.row;\n            var relcol = col - range.topLeft.col;\n            cell.merged = true;\n            cell.colspan = ref.width();\n            cell.rowspan = ref.height();\n\n            if (relrow < 0) {\n              cell.top = -sheet._rows.sum(row, row - relrow - 1);\n            } else {\n              cell.top = yCoords[relrow];\n            }\n\n            if (relcol < 0) {\n              cell.left = -sheet._columns.sum(col, col - relcol - 1);\n            } else {\n              cell.left = xCoords[relcol];\n            }\n\n            cell.height = sheet._rows.sum(ref.topLeft.row, ref.bottomRight.row);\n            cell.width = sheet._columns.sum(ref.topLeft.col, ref.bottomRight.col);\n\n            if (cell.height > 0 && cell.width > 0) {\n              // zero means a fully hidden merged cell (all rows/columns are hidden)\n              // https://github.com/telerik/kendo-ui-core/issues/1794\n              cell.right = cell.left + cell.width;\n              cell.bottom = cell.top + cell.height;\n              cell.row = relrow;\n              cell.col = relcol;\n              cells.push(cell);\n            }\n          });\n        }); // 4. replicate header rows on all pages\n\n        if (options.headerRows) {\n          hyCoords.forEach(function (y) {\n            headerCells.forEach(function (cell) {\n              cell = clone(cell);\n              cell.top += y;\n              cell.bottom = cell.top + cell.height;\n              cells.push(cell);\n            });\n            yCoords.push(y);\n          });\n          yCoords.sort(orderCoords);\n        }\n\n        return {\n          width: boxWidth,\n          height: boxHeight,\n          cells: cells.sort(orderCells),\n          scale: scaleFactor,\n          xCoords: xCoords,\n          yCoords: yCoords,\n          drawings: drawings\n        };\n      }\n\n      function clone(hash, target) {\n        if (!target) {\n          target = {};\n        }\n\n        if (Object.assign) {\n          return Object.assign(target, hash);\n        }\n\n        return Object.keys(hash).reduce(function (copy, key) {\n          copy[key] = hash[key];\n          return copy;\n        }, target);\n      }\n\n      function sameBorder(a, b) {\n        return a.size === b.size && a.color === b.color;\n      }\n\n      function sum(a, b) {\n        return a + b;\n      }\n\n      function orlast(a, i) {\n        return i < a.length ? a[i] : a[a.length - 1];\n      }\n\n      function shouldDrawCell(cell) {\n        return cell.value != null || cell.merged || cell.background != null || cell.borderRight != null || cell.borderBottom != null || cell.validation != null && !cell.validation.value || cell.drawings && cell.drawings.length;\n      }\n\n      function orderCells(a, b) {\n        if (a.top < b.top) {\n          return -1;\n        } else if (a.top == b.top) {\n          if (a.left < b.left) {\n            return -1;\n          } else if (a.left == b.left) {\n            return 0;\n          } else {\n            return 1;\n          }\n        } else {\n          return 1;\n        }\n      }\n\n      function orderCoords(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n      }\n\n      function drawLayout(sheet, layout, group, options) {\n        // options:\n        // - pageWidth\n        // - pageHeight\n        // - fitWidth\n        // - hCenter\n        // - vCenter\n        var ncols = Math.ceil(layout.width / options.pageWidth);\n        var nrows = Math.ceil(layout.height / options.pageHeight);\n        var pageWidth = Math.ceil(options.pageWidth / layout.scale);\n        var pageHeight = Math.ceil(options.pageHeight / layout.scale);\n\n        for (var j = 0; j < nrows; ++j) {\n          for (var i = 0; i < ncols; ++i) {\n            addPage(j, i);\n          }\n        }\n\n        function addPage(row, col) {\n          var left = col * pageWidth;\n          var right = left + pageWidth;\n          var top = row * pageHeight;\n          var bottom = top + pageHeight;\n          var endbottom = 0,\n              endright = 0;\n\n          function isInside(box) {\n            if (box.right <= left || box.left >= right || box.bottom <= top || box.top >= bottom) {\n              return false;\n            }\n\n            endbottom = Math.max(box.bottom, endbottom);\n            endright = Math.max(box.right, endright);\n            return true;\n          } // XXX: this can be optimized - discard cells that won't\n          // be used again, and don't walk cells that stand no\n          // chance to fit.\n\n\n          var cells = layout.cells.filter(isInside);\n          var drawings = layout.drawings.filter(function (d) {\n            return isInside(d.box);\n          }); // merged cells might stretch beyond page; limit to that\n\n          endbottom = Math.min(endbottom, bottom);\n          endright = Math.min(endright, right);\n\n          if (cells.length || drawings.length) {\n            var page = new kdrw.Group();\n            group.append(page); // page.clip(drawing.Path.fromRect(\n            //     new geo.Rect([ 0, 0 ],\n            //                  [ options.pageWidth, options.pageHeight ])));\n\n            var content = new kdrw.Group();\n            page.append(content);\n            content.clip(kdrw.Path.fromRect(new geo.Rect([left - 1, top - 1], [endright + 1, endbottom + 1])));\n            var matrix = geo.Matrix.scale(layout.scale, layout.scale).multiplyCopy(geo.Matrix.translate(-left, -top));\n\n            if (options.hCenter || options.vCenter) {\n              matrix = matrix.multiplyCopy(geo.Matrix.translate(options.hCenter ? (right - endright) / 2 : 0, options.vCenter ? (bottom - endbottom) / 2 : 0));\n            }\n\n            content.transform(matrix);\n\n            if (options.guidelines) {\n              var prev = null;\n              layout.xCoords.forEach(function (x) {\n                x = Math.min(x, endright);\n\n                if (x !== prev && x >= left && x <= right) {\n                  prev = x;\n                  content.append(new kdrw.Path().moveTo(x, top).lineTo(x, endbottom).close().stroke(options.guideColor, GUIDELINE_WIDTH));\n                }\n              });\n              var prev = null;\n              layout.yCoords.forEach(function (y) {\n                y = Math.min(y, endbottom);\n\n                if (y !== prev && y >= top && y <= bottom) {\n                  prev = y;\n                  content.append(new kdrw.Path().moveTo(left, y).lineTo(endright, y).close().stroke(options.guideColor, GUIDELINE_WIDTH));\n                }\n              });\n            }\n\n            var borders = Borders(); // jshint ignore: line\n\n            cells.forEach(function (cell) {\n              drawCell(cell, content, options);\n              borders.add(cell, sheet);\n            });\n            var bordersGroup = new kdrw.Group();\n            borders.vert.forEach(function (a) {\n              a.forEach(function (b) {\n                if (!b.rendered) {\n                  b.rendered = true;\n                  bordersGroup.append(new kdrw.Path().moveTo(b.x, b.top).lineTo(b.x, b.bottom).close().stroke(b.color, b.size));\n                }\n              });\n            });\n            borders.horiz.forEach(function (a) {\n              a.forEach(function (b) {\n                if (!b.rendered) {\n                  b.rendered = true;\n                  bordersGroup.append(new kdrw.Path().moveTo(b.left, b.y).lineTo(b.right, b.y).close().stroke(b.color, b.size));\n                }\n              });\n            });\n            content.append(bordersGroup);\n            drawings.forEach(function (d) {\n              var drawing = d.drawing;\n              var image = drawing.image;\n\n              if (image != null) {\n                var box = d.box;\n\n                var url = sheet._workbook.imageUrl(image);\n\n                content.append(new kdrw.Image(url, new geo.Rect([box.left, box.top], [box.width, box.height])).opacity(drawing.opacity));\n              }\n            });\n          }\n        }\n      }\n\n      function drawCell(cell, content, options) {\n        var g = new kdrw.Group();\n        content.append(g);\n        var rect = new geo.Rect([cell.left, cell.top], [cell.width, cell.height]);\n\n        if (cell.background || cell.merged) {\n          var r2d2 = rect;\n\n          if (options.guidelines) {\n            r2d2 = rect.clone();\n            r2d2.origin.x += GUIDELINE_WIDTH / 2 + 0.1;\n            r2d2.origin.y += GUIDELINE_WIDTH / 2 + 0.1;\n            r2d2.size.width -= GUIDELINE_WIDTH + 0.2;\n            r2d2.size.height -= GUIDELINE_WIDTH + 0.2;\n          }\n\n          g.append(new kdrw.Rect(r2d2).fill(cell.background || \"#fff\").stroke(null));\n        }\n\n        var val = cell.value;\n\n        if (val != null) {\n          var type = typeof val == \"number\" ? \"number\" : null;\n          var clip = new kdrw.Group();\n          clip.clip(kdrw.Path.fromRect(rect));\n          g.append(clip);\n          var f,\n              format = cell.format;\n\n          if (!format && type == \"number\" && val != Math.floor(val)) {\n            format = \"0.##############\";\n          }\n\n          if (format) {\n            f = formatting.textAndColor(val, format);\n            val = f.text;\n\n            if (f.type) {\n              type = f.type;\n            }\n          } else {\n            val += \"\";\n          }\n\n          if (!cell.textAlign) {\n            switch (type) {\n              case \"number\":\n              case \"date\":\n              case \"percent\":\n              case \"currency\":\n                cell.textAlign = \"right\";\n                break;\n\n              case \"boolean\":\n                cell.textAlign = \"center\";\n                break;\n            }\n          }\n\n          drawText(val, f && f.color || cell.color || \"#000\", cell, clip);\n        }\n      }\n\n      function applyIndent(cell, style) {\n        if (cell.indent) {\n          // OOXML spec states the indent is \"An integer value,\n          // where an increment of 1 represents 3 spaces\".  This, of\n          // course, bears no resemblance to what Excel actually\n          // does, so we need magic numbers here.\n          var indent = 1.4 * cell.indent;\n\n          switch (style.textAlign) {\n            case null:\n            case \"left\":\n              style.paddingLeft = indent + \"ch\";\n              break;\n\n            case \"right\":\n              style.paddingRight = indent + \"ch\";\n              break;\n\n            case \"center\":\n              style.paddingLeft = indent / 2 + \"ch\";\n              style.paddingRight = indent / 2 + \"ch\";\n              break;\n          }\n        }\n      }\n\n      var CONT;\n\n      function drawText(text, color, cell, group) {\n        if (!CONT) {\n          CONT = document.createElement(\"div\");\n          CONT.style.position = \"fixed\";\n          CONT.style.left = \"0px\";\n          CONT.style.top = \"0px\";\n          CONT.style.visibility = \"hidden\";\n          CONT.style.overflow = \"hidden\";\n          CONT.style.boxSizing = \"border-box\";\n          CONT.style.lineHeight = \"normal\";\n          document.body.appendChild(CONT);\n        }\n\n        if (CONT.firstChild) {\n          CONT.removeChild(CONT.firstChild);\n        }\n\n        CONT.style.padding = \"2px 4px\";\n        CONT.style.color = color;\n        CONT.style.font = makeFontDef(cell);\n        CONT.style.width = cell.width + \"px\";\n        CONT.style.textAlign = cell.textAlign || \"left\";\n        CONT.style.textDecoration = cell.underline ? \"underline\" : \"none\";\n        applyIndent(cell, CONT.style);\n\n        if (cell.wrap) {\n          CONT.style.whiteSpace = \"pre-wrap\";\n          CONT.style.overflowWrap = CONT.style.wordWrap = \"break-word\";\n        } else {\n          CONT.style.whiteSpace = \"pre\";\n          CONT.style.overflowWrap = CONT.style.wordWrap = \"normal\";\n        }\n\n        CONT.appendChild(document.createTextNode(text));\n        var vtrans = 0;\n\n        switch (cell.verticalAlign) {\n          case \"center\":\n            vtrans = cell.height - CONT.offsetHeight >> 1;\n            break;\n\n          case undefined:\n          case null:\n          case \"bottom\":\n            vtrans = cell.height - CONT.offsetHeight;\n            break;\n        }\n\n        if (vtrans < 0) {\n          vtrans = 0;\n        }\n\n        var text_group = kendo.drawing.drawDOM.drawText(CONT);\n        text_group.transform(geo.Matrix.translate(cell.left, cell.top + vtrans));\n        group.append(text_group);\n      }\n\n      function makeFontDef(cell) {\n        var font = [];\n\n        if (cell.italic) {\n          font.push(\"italic\");\n        }\n\n        if (cell.bold) {\n          font.push(\"bold\");\n        }\n\n        font.push((cell.fontSize || 12) + \"px\");\n        font.push(cell.fontFamily || \"Arial\");\n        return font.join(\" \");\n      }\n\n      function draw(sheet, range, options, callback) {\n        if (options == null && callback == null) {\n          callback = range;\n          options = {};\n          range = spreadsheet.SHEETREF;\n        }\n\n        if (callback == null) {\n          callback = options;\n\n          if (range instanceof spreadsheet.Range || range instanceof spreadsheet.Ref || typeof range == \"string\") {\n            options = {};\n          } else {\n            options = range;\n            range = spreadsheet.SHEETREF;\n          }\n        }\n\n        options = kendo.jQuery.extend({\n          paperSize: \"A4\",\n          landscape: true,\n          margin: \"1cm\",\n          guidelines: true,\n          guideColor: \"#aaa\",\n          emptyCells: true,\n          fitWidth: false,\n          center: false,\n          headerRows: null,\n          maxEmpty: 0.2,\n          scale: 1\n        }, options);\n        var group = new kdrw.Group();\n        var paper = kendo.pdf.getPaperOptions(options);\n        group.options.set(\"pdf\", {\n          author: options.author,\n          creator: options.creator,\n          date: options.date,\n          keywords: options.keywords,\n          margin: paper.margin,\n          multiPage: true,\n          paperSize: paper.paperSize,\n          subject: options.subject,\n          title: options.title,\n          autoPrint: options.autoPrint\n        });\n        var pageWidth = paper.paperSize[0];\n        var pageHeight = paper.paperSize[1];\n\n        if (paper.margin) {\n          pageWidth -= paper.margin.left + paper.margin.right + 1;\n          pageHeight -= paper.margin.top + paper.margin.bottom + 1;\n        }\n\n        options.pageWidth = pageWidth;\n        options.pageHeight = pageHeight;\n        var layout = doLayout(sheet, sheet._ref(range), options);\n        drawLayout(sheet, layout, group, options);\n        callback(group);\n      }\n\n      spreadsheet.Sheet.prototype.draw = function (range, options, callback) {\n        var sheet = this;\n\n        if (sheet._workbook) {\n          sheet.recalc(sheet._workbook._context, function () {\n            draw(sheet, range, options, callback);\n          });\n        } else {\n          draw(sheet, range, options, callback);\n        }\n      }; // Hack: since we index the border arrays by relative row/col we\n      // could end up with negative indexes, i.e. horiz[-2] = border.\n      // Array forEach will ignore these, so we provide a simple\n      // container here (outside code only needs forEach at this time).\n\n\n      function Container() {}\n\n      Container.prototype = {\n        forEach: function (f) {\n          Object.keys(this).forEach(function (key) {\n            f(this[key], key, this);\n          }, this);\n        }\n      };\n\n      function Borders() {\n        var horiz = new Container();\n        var vert = new Container();\n\n        function add(cell, sheet) {\n          if (sheet) {\n            // reset borders here; the propertybag doesn't keep track of merged cells :-/ this\n            // is ugly, but the inner details of data storage have leaked everywhere anyway.\n            var pb = sheet._properties;\n            var grid = sheet._grid;\n            cell.borderLeft = pb.get(\"vBorders\", grid.index(cell.row, cell.col));\n            cell.borderRight = pb.get(\"vBorders\", grid.index(cell.row, cell.col + cell.colspan));\n            cell.borderTop = pb.get(\"hBorders\", grid.index(cell.row, cell.col));\n            cell.borderBottom = pb.get(\"hBorders\", grid.index(cell.row + cell.rowspan, cell.col));\n          }\n\n          if (cell.borderLeft) {\n            addVert(cell.row, cell.col, cell.borderLeft, cell.left, cell.top, cell.bottom);\n          }\n\n          if (cell.borderRight) {\n            addVert(cell.row, cell.col + cell.colspan, cell.borderRight, cell.right, cell.top, cell.bottom);\n          }\n\n          if (cell.borderTop) {\n            addHoriz(cell.row, cell.col, cell.borderTop, cell.top, cell.left, cell.right);\n          }\n\n          if (cell.borderBottom) {\n            addHoriz(cell.row + cell.rowspan, cell.col, cell.borderBottom, cell.bottom, cell.left, cell.right);\n          }\n        }\n\n        function addVert(row, col, border, x, top, bottom) {\n          var a = vert[col] || (vert[col] = new Container());\n          var prev = row > 0 && a[row - 1];\n\n          if (prev && sameBorder(prev, border)) {\n            a[row] = prev;\n            prev.bottom = bottom;\n          } else {\n            a[row] = {\n              size: border.size,\n              color: border.color,\n              x: x,\n              top: top,\n              bottom: bottom\n            };\n          }\n        }\n\n        function addHoriz(row, col, border, y, left, right) {\n          var a = horiz[row] || (horiz[row] = new Container());\n          var prev = col > 0 && a[col - 1];\n\n          if (prev && sameBorder(prev, border)) {\n            a[col] = prev;\n            prev.right = right;\n          } else {\n            a[col] = {\n              size: border.size,\n              color: border.color,\n              y: y,\n              left: left,\n              right: right\n            };\n          }\n        }\n\n        return {\n          add: add,\n          horiz: horiz,\n          vert: vert\n        };\n      }\n\n      function drawTabularData(options) {\n        var progress = new $.Deferred();\n        var promise = progress.promise();\n        options = clone(options, {\n          dataSource: null,\n          guidelines: true,\n          guideColor: \"#000\",\n          columns: null,\n          headerBackground: \"#999\",\n          headerColor: \"#000\",\n          oddBackground: null,\n          evenBackground: null,\n          fontFamily: \"Arial\",\n          fontSize: 12,\n          paperSize: \"A4\",\n          margin: \"1cm\",\n          landscape: true,\n          fitWidth: false,\n          scale: 1,\n          rowHeight: 20,\n          maxEmpty: 1,\n          useGridFormat: true\n        }); // retrieve fonts; custom fonts should be already loaded\n\n        kendo.drawing.pdf.defineFont(kendo.drawing.drawDOM.getFontFaces(document));\n        var charWidth = charWidthFunction(options.fontFamily, options.fontSize);\n\n        function textWidth(value) {\n          if (value != null) {\n            var width = 12; // magic numbers :-/\n\n            for (var i = value.length; --i >= 0;) {\n              width += charWidth(value.charAt(i));\n            }\n\n            return width;\n          }\n\n          return 0;\n        }\n\n        var border = options.guidelines ? {\n          size: 1,\n          color: options.guideColor\n        } : null;\n\n        function mkCell(data) {\n          if (!border) {\n            return data;\n          }\n\n          return clone(data, {\n            borderLeft: border,\n            borderTop: border,\n            borderRight: border,\n            borderBottom: border\n          });\n        }\n\n        options.dataSource.fetch(function () {\n          var data = options.dataSource.data();\n\n          if (!data.length) {\n            return progress.reject(\"Empty dataset\");\n          } // this really must be present\n\n\n          var columns = options.columns.map(function (col) {\n            if (typeof col == \"string\") {\n              return {\n                title: col,\n                field: col\n              };\n            } else {\n              return col;\n            }\n          });\n          var columnTitles = columns.map(function (col) {\n            return col.title || col.field;\n          });\n          var columnWidths = columnTitles.map(textWidth); // prepare data for a Sheet object's fromJSON method\n\n          var rows = data.map(function (row, rowIndex) {\n            return {\n              cells: columns.map(function (col, colIndex) {\n                var value = row[col.field]; // NOTE: value might not be string.  I added option useGridFormat (default\n                // true), which will use a column's format, if present, to convert the value\n                // to a string, so that we can measure the width right now.\n\n                if (options.useGridFormat) {\n                  if (value != null) {\n                    if (col.format) {\n                      value = kendo.format(col.format, value);\n                    } else {\n                      value += \"\";\n                    }\n                  } // adjust the column widths while we're at it\n\n\n                  columnWidths[colIndex] = Math.max(textWidth(value), columnWidths[colIndex]);\n                } // if options.useGridFormat is false and col.format is present, pass it over\n                // to the spreadsheet.  In that case we should calculate the widths after\n                // the spreadsheet is created (XXX to be implemented when someone needs it).\n\n\n                return mkCell({\n                  value: value,\n                  format: options.useGridFormat ? null : col.format,\n                  background: rowIndex % 2 ? options.evenBackground : options.oddBackground\n                });\n              })\n            };\n          }); // insert header line\n\n          rows.unshift({\n            cells: columnTitles.map(function (label) {\n              return mkCell({\n                value: label,\n                background: options.headerBackground,\n                color: options.headerColor\n              });\n            })\n          }); // init a Sheet object.  Note that we have to add one\n          // extra-row and column, because the very last ones can't\n          // have right/bottom borders (known limitation).\n\n          var sheet = new kendo.spreadsheet.Sheet(rows.length + 1, // rows\n          columns.length + 1, // columns\n          options.rowHeight, // row height\n          50, // column width\n          20, // header height\n          20, // header width,\n          {\n            // default cell style\n            fontFamily: options.fontFamily,\n            fontSize: options.fontSize,\n            verticalAlign: \"center\"\n          }); // load data\n\n          sheet.fromJSON({\n            name: \"Sheet1\",\n            rows: rows,\n            columns: columnWidths.map(function (w, i) {\n              return {\n                index: i,\n                width: w\n              };\n            })\n          });\n          sheet.draw({\n            paperSize: options.paperSize,\n            landscape: options.landscape,\n            margin: options.margin,\n            guidelines: false,\n            // using borders instead (better contrast)\n            scale: options.scale,\n            fitWidth: options.fitWidth,\n            maxEmpty: options.maxEmpty,\n            headerRows: 1\n          }, progress.resolve.bind(progress));\n        });\n        return promise;\n      }\n\n      var CACHE_CHAR_WIDTH = {};\n\n      var charWidthFunction = function (fontFamily, fontSize) {\n        var id = fontSize + \":\" + fontFamily;\n        var func = CACHE_CHAR_WIDTH[id];\n\n        if (!func) {\n          var span,\n              div = document.createElement(\"div\");\n          div.style.position = \"fixed\";\n          div.style.left = \"-10000px\";\n          div.style.top = \"-10000px\";\n          div.style.fontFamily = fontFamily;\n          div.style.fontSize = fontSize + \"px\";\n          div.style.whiteSpace = \"pre\";\n\n          for (var i = 32; i < 128; ++i) {\n            span = document.createElement(\"span\");\n            span.appendChild(document.createTextNode(String.fromCharCode(i)));\n            div.appendChild(span);\n          }\n\n          document.body.appendChild(div);\n          var widths = {};\n\n          for (i = 32, span = div.firstChild; i < 128 && span; ++i, span = span.nextSibling) {\n            widths[i] = span.offsetWidth;\n          }\n\n          while (span = div.firstChild) {\n            div.removeChild(span);\n          }\n\n          func = CACHE_CHAR_WIDTH[id] = function (ch) {\n            var code = ch.charCodeAt(0);\n            var width = widths[code];\n\n            if (width == null) {\n              // probably not an ASCII character, let's cache its width as well\n              span = document.createElement(\"span\");\n              span.appendChild(document.createTextNode(String.fromCharCode(code)));\n              div.appendChild(span);\n              width = widths[code] = span.offsetWidth;\n              div.removeChild(span);\n            }\n\n            return width;\n          };\n        }\n\n        return func;\n      };\n\n      spreadsheet.draw = {\n        Borders: Borders,\n        doLayout: doLayout,\n        applyIndent: applyIndent\n      };\n      spreadsheet.drawTabularData = drawTabularData;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1714:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.pdf\");\n    /***/\n  },\n\n  /***/\n  1715:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./numformat\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}