{"ast":null,"code":"import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\nconst AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n  if (series.missingValues) {\n    return series.missingValues;\n  }\n\n  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n  const fields = SeriesBinder.current.bindPoint(series, null, item);\n  const valueFields = fields.valueFields;\n\n  for (let field in valueFields) {\n    if (convertableToNumber(valueFields[field])) {\n      return true;\n    }\n  }\n}\n\nfunction findNext({\n  start,\n  dir,\n  min,\n  max,\n  getter,\n  hasItem,\n  series\n}) {\n  let pointHasValue, outPoint;\n  let idx = start;\n\n  do {\n    idx += dir; //aggregating and binding the item takes too much time for large number of categories\n    //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n\n    if (hasItem(idx)) {\n      outPoint = getter(idx);\n      pointHasValue = hasValue(series, outPoint.item);\n    }\n  } while (min <= idx && idx <= max && !pointHasValue);\n\n  if (pointHasValue) {\n    return outPoint;\n  }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n  const {\n    min,\n    max\n  } = range;\n  const hasMinPoint = min > 0 && min < count;\n  const hasMaxPoint = max + 1 < count;\n\n  if (hasMinPoint || hasMaxPoint) {\n    const missingValues = seriesMissingValues(series);\n    let minPoint, maxPoint;\n\n    if (missingValues !== INTERPOLATE) {\n      if (hasMinPoint) {\n        minPoint = getter(min - 1);\n      }\n\n      if (hasMaxPoint) {\n        maxPoint = getter(max + 1);\n      }\n    } else {\n      let outPoint, pointHasValue;\n\n      if (hasMinPoint) {\n        outPoint = getter(min - 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          minPoint = findNext({\n            start: min,\n            dir: -1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          minPoint = outPoint;\n        }\n      }\n\n      if (hasMaxPoint) {\n        outPoint = getter(max + 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          maxPoint = findNext({\n            start: max,\n            dir: 1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          maxPoint = outPoint;\n        }\n      }\n    }\n\n    if (minPoint) {\n      series._outOfRangeMinPoint = minPoint;\n    }\n\n    if (maxPoint) {\n      series._outOfRangeMaxPoint = maxPoint;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}