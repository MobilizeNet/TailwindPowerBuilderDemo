{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, NgZone, Directive, Optional, Component, Input, ContentChildren, EventEmitter, ElementRef, ViewChild, HostBinding, forwardRef, Output, isDevMode, NgModule, ContentChild } from '@angular/core';\nimport * as i3 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { PreventableEvent as PreventableEvent$1, hasObservers, isDocumentAvailable, Keys } from '@progress/kendo-angular-common';\nimport * as i6 from '@progress/kendo-angular-popup';\nimport { PopupService, POPUP_CONTAINER, PopupModule } from '@progress/kendo-angular-popup';\nimport * as i5 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * @hidden\n */\n\nconst _c0 = [\"kendoMenuList\", \"\"];\n\nfunction ListComponent_ng_container_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"li\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    const idx_r2 = ctx_r5.index;\n    const item_r1 = ctx_r5.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-first\", idx_r2 === 0)(\"k-last\", idx_r2 === ctx_r3.items.length - 1)(\"k-state-disabled\", item_r1.disabled);\n    i0.ɵɵproperty(\"item\", item_r1)(\"level\", ctx_r3.level)(\"vertical\", ctx_r3.vertical)(\"animate\", ctx_r3.animate)(\"rtl\", ctx_r3.rtl)(\"itemTemplate\", ctx_r3.itemTemplate)(\"itemLinkTemplate\", ctx_r3.itemLinkTemplate)(\"openOnClick\", ctx_r3.openOnClick)(\"index\", ctx_r3.hierarchyIndex(idx_r2))(\"siblingIndex\", idx_r2)(\"ngClass\", item_r1.cssClass)(\"ngStyle\", item_r1.cssStyle);\n    i0.ɵɵattribute(\"data-kendo-menu-index\", ctx_r3.hierarchyIndex(idx_r2));\n  }\n}\n\nfunction ListComponent_ng_container_0_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 4);\n    i0.ɵɵtext(1, \" \\xA0 \");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", item_r1.cssClass)(\"ngStyle\", item_r1.cssStyle);\n  }\n}\n\nfunction ListComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ListComponent_ng_container_0_li_1_Template, 1, 19, \"li\", 1);\n    i0.ɵɵtemplate(2, ListComponent_ng_container_0_li_2_Template, 2, 2, \"li\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r1.separator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r1.separator);\n  }\n}\n\nconst _c1 = [\"link\"];\nconst _c2 = [\"popupTemplate\"];\nconst _c3 = [\"kendoMenuItem\", \"\"];\n\nfunction ItemComponent_span_0_ng_template_2_Template(rf, ctx) {}\n\nfunction ItemComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6, 7);\n    i0.ɵɵtemplate(2, ItemComponent_span_0_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(7);\n\n    i0.ɵɵclassProp(\"k-state-active\", ctx_r0.opened);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\n\nfunction ItemComponent_a_1_ng_template_2_Template(rf, ctx) {}\n\nfunction ItemComponent_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 9, 7);\n    i0.ɵɵtemplate(2, ItemComponent_a_1_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(7);\n\n    i0.ɵɵclassProp(\"k-state-active\", ctx_r1.opened);\n    i0.ɵɵattribute(\"href\", ctx_r1.item.url, i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\n\nfunction ItemComponent_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c4 = function (a0, a1) {\n  return {\n    item: a0,\n    index: a1\n  };\n};\n\nfunction ItemComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ItemComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.linkTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c4, ctx_r2.item, ctx_r2.index));\n  }\n}\n\nfunction ItemComponent_div_3_ng_template_1_Template(rf, ctx) {}\n\nfunction ItemComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtemplate(1, ItemComponent_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.item.content)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c4, ctx_r3.item.owner, ctx_r3.item.ownerIndex));\n  }\n}\n\nfunction ItemComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"animate\", ctx_r5.animate)(\"rtl\", ctx_r5.rtl)(\"vertical\", ctx_r5.vertical)(\"openOnClick\", ctx_r5.openOnClick)(\"items\", ctx_r5.children)(\"level\", ctx_r5.level + 1)(\"index\", ctx_r5.index)(\"itemTemplate\", ctx_r5.itemTemplate)(\"itemLinkTemplate\", ctx_r5.itemLinkTemplate);\n    i0.ɵɵattribute(\"id\", ctx_r5.childId);\n  }\n}\n\nfunction ItemComponent_ng_template_6_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r14.iconClass);\n  }\n}\n\nfunction ItemComponent_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 16);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r15.item.text);\n  }\n}\n\nfunction ItemComponent_ng_template_6_2_ng_template_0_Template(rf, ctx) {}\n\nfunction ItemComponent_ng_template_6_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ItemComponent_ng_template_6_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r16.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c4, ctx_r16.item, ctx_r16.index));\n  }\n}\n\nfunction ItemComponent_ng_template_6_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"k-i-arrow-60-down\", !ctx_r17.horizontal)(\"k-i-arrow-60-right\", ctx_r17.horizontal && !ctx_r17.rtl)(\"k-i-arrow-60-left\", ctx_r17.horizontal && ctx_r17.rtl);\n  }\n}\n\nfunction ItemComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ItemComponent_ng_template_6_span_0_Template, 1, 1, \"span\", 13);\n    i0.ɵɵtemplate(1, ItemComponent_ng_template_6_ng_container_1_Template, 3, 1, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, ItemComponent_ng_template_6_2_Template, 1, 5, null, 2);\n    i0.ɵɵtemplate(3, ItemComponent_ng_template_6_span_3_Template, 1, 6, \"span\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.item.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.hasContent);\n  }\n}\n\nconst _c5 = [\"default\"];\n\nfunction ContextMenuComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-menu\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"items\", ctx_r1.rootItems)(\"vertical\", ctx_r1.vertical)(\"openOnClick\", ctx_r1.openOnClick)(\"hoverDelay\", ctx_r1.hoverDelay)(\"animate\", ctx_r1.animate)(\"menuItemTemplate\", ctx_r1.itemTemplate.first == null ? null : ctx_r1.itemTemplate.first.templateRef)(\"menuItemLinkTemplate\", ctx_r1.itemLinkTemplate.first == null ? null : ctx_r1.itemLinkTemplate.first.templateRef);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-menu',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1650441247,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst PARENT_REGEX = /_?\\d+$/;\nconst SEPARATOR = '_';\nlet id = 0;\n\nconst itemIndexComparer = (a, b) => a.siblingIndex - b.siblingIndex;\n\nconst next = (idx, items, dir) => {\n  let current = items[idx + dir];\n\n  while (!current) {\n    if (idx < 0) {\n      idx = items.length - 1;\n    } else if (idx >= items.length) {\n      idx = 0;\n    } else {\n      idx += dir;\n    }\n\n    current = items[idx];\n  }\n\n  return current;\n};\n/**\n * @hidden\n */\n\n\nlet ItemsService = /*#__PURE__*/(() => {\n  class ItemsService {\n    constructor() {\n      this.items = {};\n      this.lists = [];\n      this.idPrefix = `k-menu${id++}`;\n    }\n\n    get hasItems() {\n      return Object.keys(this.items).length > 0;\n    }\n\n    childId(index) {\n      return `${this.idPrefix}-child${index}`;\n    }\n\n    itemIndex(parentIndex, index) {\n      return (parentIndex ? parentIndex + SEPARATOR : '') + index;\n    }\n\n    get(index) {\n      return this.items[index];\n    }\n\n    add(item) {\n      this.items[item.index] = item;\n    }\n\n    remove(item) {\n      if (this.items[item.index] === item) {\n        delete this.items[item.index];\n      }\n    }\n\n    addList(list) {\n      this.lists.push(list);\n    }\n\n    removeList(list) {\n      const index = this.lists.indexOf(list);\n\n      if (index >= 0) {\n        this.lists.splice(index, 1);\n      }\n    }\n\n    containsList(element) {\n      return Boolean(this.lists.find(list => list.element.nativeElement === element));\n    }\n\n    siblings(item) {\n      const parentIndex = this.parentIndex(item.index);\n      return this.filter(index => this.parentIndex(index) === parentIndex);\n    }\n\n    otherSiblings(item) {\n      const parentIndex = this.parentIndex(item.index);\n      return this.filter(index => this.parentIndex(index) === parentIndex && index !== item.index);\n    }\n\n    children(item) {\n      return this.filter(index => this.parentIndex(index) === item.index);\n    }\n\n    parent(item) {\n      return this.items[this.parentIndex(item.index)];\n    }\n\n    root(item) {\n      return this.items[this.indices(item.index)[0]];\n    }\n\n    indices(index) {\n      return index.split(SEPARATOR);\n    }\n\n    filter(predicate) {\n      const result = [];\n      const items = this.items;\n\n      for (let index in items) {\n        if (predicate(index, items[index])) {\n          result.push(items[index]);\n        }\n      }\n\n      return result.sort(itemIndexComparer);\n    }\n\n    previous(item) {\n      const siblings = this.siblings(item);\n      const itemIndex = siblings.indexOf(item);\n      return next(itemIndex, siblings, -1);\n    }\n\n    next(item) {\n      const siblings = this.siblings(item);\n      const itemIndex = siblings.indexOf(item);\n      return next(itemIndex, siblings, 1);\n    }\n\n    hasParent(item, parent) {\n      return item.index.startsWith(parent.index);\n    }\n\n    areSiblings(item1, item2) {\n      return item1 !== item2 && this.parent(item1) === this.parent(item2);\n    }\n\n    forEach(callback) {\n      const items = this.items;\n\n      for (let index in items) {\n        if (items.hasOwnProperty(index)) {\n          callback(items[index]);\n        }\n      }\n    }\n\n    parentIndex(index) {\n      return index.replace(PARENT_REGEX, '');\n    }\n\n  }\n\n  ItemsService.ɵfac = function ItemsService_Factory(t) {\n    return new (t || ItemsService)();\n  };\n\n  ItemsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ItemsService,\n    factory: ItemsService.ɵfac\n  });\n  return ItemsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst canPerformAction = (item, action) => !(action === 'open' && item.opened || action === 'close' && !item.opened);\n/**\n * Used to remove cyclic dependency error. Dublicates MenuEvent\n * @hidden\n */\n\n\nclass MenuStateEvent extends PreventableEvent$1 {\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet ActionsService = /*#__PURE__*/(() => {\n  class ActionsService {\n    constructor(ngZone, items) {\n      this.ngZone = ngZone;\n      this.items = items;\n      this.actions = [];\n    }\n\n    open(item, finished) {\n      if (item.disabled) {\n        return;\n      }\n\n      if (item.hasContent && !item.opened) {\n        this.actions.push({\n          name: 'open',\n          requiresZone: item.hasContentTemplates(),\n          item,\n          finished\n        });\n      } else if (finished) {\n        finished();\n      }\n    }\n\n    close(item) {\n      this.closeChildren(item);\n      this.closeItem(item);\n    }\n\n    closeItem(item) {\n      if (item.opened) {\n        this.actions.push({\n          name: 'close',\n          item\n        });\n      }\n    }\n\n    closeToRoot(item) {\n      this.closeChildren(item);\n      let current = item;\n\n      do {\n        this.closeItem(current);\n        current = this.items.parent(current);\n      } while (current);\n    }\n\n    closeOthers(item) {\n      this.closeChildren(item);\n      let current = item;\n\n      while (current) {\n        const siblings = this.items.otherSiblings(current);\n        this.closeItems(siblings);\n        current = this.items.parent(current);\n      }\n    }\n\n    closeAll() {\n      this.items.forEach(item => {\n        if (item.opened && item.level === 0) {\n          this.close(item);\n        }\n      });\n    }\n\n    select(item, domEvent, prevented, finished) {\n      this.actions.push({\n        name: 'select',\n        item,\n        prevented,\n        finished,\n        domEvent\n      });\n    }\n\n    emit(name, item, domEvent) {\n      const owner = this.owner;\n      const eventArgs = new MenuStateEvent({\n        sender: owner,\n        item: item.item,\n        index: item.index,\n        originalEvent: domEvent,\n        hasContent: item.hasContent\n      });\n      owner[name].emit(eventArgs);\n\n      if (owner.contextService) {\n        owner.contextService.emit(name, eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    get hasPending() {\n      return this.actions.length > 0;\n    }\n\n    execute(toExecute) {\n      if (!this.hasPending && !toExecute) {\n        return;\n      }\n\n      const actions = toExecute || this.clear();\n\n      if (!NgZone.isInAngularZone() && this.requiresZone(actions)) {\n        this.ngZone.run(() => {\n          this.executeActions(actions);\n        });\n      } else {\n        this.executeActions(actions);\n      }\n    }\n\n    clear() {\n      const actions = this.actions;\n      this.actions = [];\n      return actions;\n    }\n\n    executeActions(actions) {\n      for (let idx = 0; idx < actions.length; idx++) {\n        const {\n          item,\n          name,\n          prevented,\n          finished,\n          domEvent\n        } = actions[idx];\n\n        if (!canPerformAction(item, name)) {\n          continue;\n        }\n\n        if (!this.emit(name, item, domEvent)) {\n          if (item[name]) {\n            item[name]();\n          }\n\n          if (finished) {\n            finished();\n          }\n        } else if (prevented) {\n          prevented();\n        }\n      }\n    }\n\n    requiresZone(toExecute) {\n      const actions = toExecute || this.actions;\n      const owner = this.owner;\n      const contextService = owner.contextService;\n\n      for (let idx = 0; idx < actions.length; idx++) {\n        const action = actions[idx];\n        const name = action.name;\n\n        if (action.requiresZone || name && (hasObservers(owner[name]) || contextService && contextService.hasObservers(name))) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    closeChildren(item) {\n      if (!item.opened) {\n        return;\n      }\n\n      const children = this.items.children(item);\n      this.closeItems(children);\n    }\n\n    closeItems(items) {\n      for (let idx = 0; idx < items.length; idx++) {\n        this.close(items[idx]);\n      }\n    }\n\n  }\n\n  ActionsService.ɵfac = function ActionsService_Factory(t) {\n    return new (t || ActionsService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(ItemsService));\n  };\n\n  ActionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActionsService,\n    factory: ActionsService.ɵfac\n  });\n  return ActionsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_ACTIVE = '0';\nconst NO_SPACE_REGEX = /\\S/;\nconst handlers = {};\nhandlers['37'] = 'left';\nhandlers['39'] = 'right';\nhandlers['38'] = 'up';\nhandlers['40'] = 'down';\nhandlers['36'] = 'home';\nhandlers['35'] = 'end';\nhandlers['32'] = 'enter';\nhandlers['13'] = 'enter';\nhandlers['27'] = 'esc';\nhandlers['9'] = 'tab';\nconst handlersRTL = Object.assign({}, handlers, {\n  '37': 'right',\n  '39': 'left'\n});\n\nfunction isPrintableCharacter(key) {\n  return key.length === 1 && NO_SPACE_REGEX.test(key);\n}\n\nconst resolvedPromise = Promise.resolve(null);\n/**\n * @hidden\n */\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(items, actions, localization, ngZone) {\n      this.items = items;\n      this.actions = actions;\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.vertical = false;\n      this.activeIndex = DEFAULT_ACTIVE;\n    }\n\n    get focusedItem() {\n      return this.items.get(this.focusedIdx);\n    }\n\n    get activeItem() {\n      return this.items.get(this.activeIndex);\n    }\n\n    get handlers() {\n      return this.localization.rtl ? handlersRTL : handlers;\n    }\n\n    focus(item) {\n      if (item.index === this.focusedIdx) {\n        return;\n      }\n\n      if (!this.activeItem || !this.items.hasParent(item, this.activeItem)) {\n        this.setActive(item);\n      }\n\n      this.setFocus(item);\n    }\n\n    setFocus(item) {\n      this.focusedIdx = item.index;\n      item.focus();\n    }\n\n    focusLeave() {\n      const focused = this.focusedItem;\n\n      if (focused) {\n        this.actions.closeToRoot(focused);\n        this.actions.execute();\n      }\n\n      this.focusedIdx = null;\n    }\n\n    updateActive() {\n      if (!this.activeItem && this.items.hasItems) {\n        const firstItem = this.items.get(DEFAULT_ACTIVE);\n        firstItem.toggleActive(true);\n        this.ngZone.runOutsideAngular(() => {\n          resolvedPromise.then(() => {\n            this.activeIndex = DEFAULT_ACTIVE;\n          });\n        });\n      }\n    }\n\n    keydown(e) {\n      const current = this.focusedItem || this.activeItem;\n      const handler = this.handlers[e.keyCode];\n\n      if (!current) {\n        return;\n      }\n\n      if (handler) {\n        if (handler !== 'tab') {\n          e.preventDefault();\n        }\n\n        this[handler](current, e);\n      } else if (isPrintableCharacter(e.key)) {\n        this.search(current, e.key);\n      }\n\n      this.actions.execute();\n    }\n\n    focusIndex(index) {\n      if (!index && this.activeItem) {\n        this.setFocus(this.activeItem);\n      } else if (index === 'first') {\n        this.focusFirst();\n      } else if (index === 'last') {\n        this.focusLast();\n      } else {\n        const item = this.items.get(index);\n\n        if (item) {\n          this.focus(item);\n        }\n      }\n    }\n\n    focusFirst() {\n      const items = this.items.siblings(this.items.get('0'));\n      this.focus(items[0]);\n    }\n\n    focusLast() {\n      const items = this.items.siblings(this.items.get('0'));\n      this.focus(items[items.length - 1]);\n    }\n\n    search(current, key) {\n      const siblings = this.items.siblings(current);\n      const startIndex = siblings.indexOf(current);\n      const items = siblings.slice(startIndex + 1).concat(siblings.slice(0, startIndex));\n\n      for (let idx = 0; idx < items.length; idx++) {\n        const sibling = items[idx];\n        const text = sibling.item.text || \"\";\n\n        if (text.toLowerCase().startsWith(key.toLowerCase())) {\n          this.focus(sibling);\n          break;\n        }\n      }\n    }\n\n    down(current) {\n      if (current.level === 0 && !this.vertical) {\n        if (current.hasContent) {\n          this.actions.open(current, this.focusChild(current, 0));\n        }\n      } else {\n        this.focus(this.items.next(current));\n      }\n    }\n\n    up(current) {\n      if (current.level === 0 && !this.vertical) {\n        if (current.hasContent) {\n          this.actions.open(current, this.focusChild(current, current.children.length - 1));\n        }\n      } else {\n        this.focus(this.items.previous(current));\n      }\n    }\n\n    left(current) {\n      if (this.vertical && current.level === 0 && current.disabled) {\n        return;\n      }\n\n      if (current.level > 1 || this.vertical && current.level > 0) {\n        const parent = this.items.parent(current);\n        this.focus(parent);\n        this.actions.close(parent);\n      } else if (this.vertical && current.level === 0 && !current.disabled) {\n        if (current.hasContent) {\n          this.actions.open(current, this.focusChild(current, current.children.length - 1));\n        }\n      } else {\n        this.focus(this.items.previous(this.activeItem));\n      }\n    }\n\n    right(current) {\n      if (this.vertical && current.level === 0 && current.disabled) {\n        return;\n      }\n\n      if (current.horizontal && !current.disabled) {\n        if (current.hasContent) {\n          this.actions.open(current, this.focusChild(current, 0));\n        } else if (!this.vertical || current.level > 0) {\n          this.focus(this.items.next(this.activeItem));\n        }\n      } else {\n        this.focus(this.items.next(this.activeItem));\n      }\n    }\n\n    home(current) {\n      const siblings = this.items.siblings(current);\n      this.focus(siblings[0]);\n    }\n\n    end(current) {\n      const siblings = this.items.siblings(current);\n      this.focus(siblings[siblings.length - 1]);\n    }\n\n    enter(current, domEvent) {\n      const actions = this.actions;\n\n      if (current.disabled) {\n        return;\n      }\n\n      if (current.hasContent) {\n        actions.select(current, domEvent);\n        actions.open(current, this.focusChild(current, 0));\n      } else {\n        actions.select(current, domEvent, null, () => {\n          current.navigate();\n        });\n        this.focus(this.items.root(current));\n        actions.closeToRoot(current);\n      }\n    }\n\n    esc(current) {\n      if (current.level > 0) {\n        const parent = this.items.parent(current);\n        this.actions.close(parent);\n        this.focus(parent);\n      }\n    }\n\n    tab(current) {\n      if (current.level > 0) {\n        this.activeItem.focus();\n      }\n    }\n\n    focusChild(item, index) {\n      return () => {\n        const child = this.items.children(item)[index];\n        this.setFocus(child);\n      };\n    }\n\n    setActive(item) {\n      const focused = this.focusedItem;\n      const active = this.items.root(item);\n\n      if (this.activeItem) {\n        this.activeItem.toggleActive(false);\n      }\n\n      this.activeIndex = active.index;\n      active.toggleActive(true);\n\n      if (focused) {\n        this.actions.closeToRoot(focused);\n\n        if (focused.level > 0) {\n          this.actions.open(active);\n        }\n      }\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(ItemsService), i0.ɵɵinject(ActionsService), i0.ɵɵinject(i3.LocalizationService), i0.ɵɵinject(i0.NgZone));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DISABLE_OPEN_ON_OVER_DELAY = 500;\n/**\n * @hidden\n */\n\nlet HoverService = /*#__PURE__*/(() => {\n  class HoverService {\n    constructor(actions, items) {\n      this.actions = actions;\n      this.items = items;\n      this.delay = 100;\n      this._openOnOver = true;\n      this.scheduled = [];\n    }\n\n    get openOnOver() {\n      return this._openOnOver;\n    }\n\n    set openOnOver(value) {\n      this.cancelActions();\n      this._openOnOver = value;\n    }\n\n    get hovered() {\n      return this.items.get(this.hoveredIdx);\n    }\n\n    set hovered(item) {\n      this.hoveredIdx = item ? item.index : null;\n    }\n\n    ngOnDestroy() {\n      this.cancelActions();\n    }\n\n    over(item) {\n      this.cancelActions(action => action.name === 'openOnOver');\n\n      if (!this.hovered || this.hovered !== item) {\n        this.actions.closeOthers(item);\n        this.hovered = item;\n\n        if ((item.level > 0 || this.openOnOver) && !item.disabled) {\n          this.actions.open(item);\n          this.cancelActions(action => action.name === 'close' && (item === action.item || this.items.hasParent(item, action.item)) || action.name === 'open' && !this.items.hasParent(item, action.item));\n        }\n\n        this.scheduleActions();\n      }\n    }\n\n    leave(disableOpenOnOver) {\n      const hovered = this.hovered;\n\n      if (hovered) {\n        this.actions.closeToRoot(hovered);\n        this.cancelActions(action => action.name === 'open');\n        this.scheduleActions();\n      }\n\n      if (disableOpenOnOver && this._openOnOver) {\n        this.scheduleDisableOpenOnOver();\n      }\n\n      this.hovered = null;\n    }\n\n    closeCurrent() {\n      const hovered = this.hovered;\n\n      if (hovered) {\n        this.actions.closeToRoot(hovered);\n        this.hovered = null;\n      }\n    }\n\n    scheduleActions() {\n      if (this.actions.hasPending) {\n        const item = {};\n        item.actions = this.actions.clear();\n        item.id = setTimeout(() => {\n          this.actions.execute(item.actions);\n          this.removeScheduled(item);\n        }, this.delay);\n        this.scheduled.push(item);\n      }\n    }\n\n    scheduleDisableOpenOnOver() {\n      const item = {\n        actions: [{\n          name: 'openOnOver'\n        }]\n      };\n      item.id = setTimeout(() => {\n        this._openOnOver = false;\n        this.removeScheduled(item);\n      }, Math.max(this.delay, DISABLE_OPEN_ON_OVER_DELAY));\n      this.scheduled.push(item);\n    }\n\n    removeScheduled(item) {\n      const scheduled = this.scheduled;\n\n      for (let idx = 0; idx < scheduled.length; idx++) {\n        if (scheduled[idx] === item) {\n          scheduled.splice(idx, 1);\n          return;\n        }\n      }\n    }\n\n    cancelActions(predicate) {\n      const scheduled = this.scheduled;\n\n      for (let idx = scheduled.length - 1; idx >= 0; idx--) {\n        const item = scheduled[idx];\n        const actions = item.actions;\n\n        if (predicate) {\n          for (let actionIdx = actions.length - 1; actionIdx >= 0; actionIdx--) {\n            if (predicate(actions[actionIdx])) {\n              actions.splice(actionIdx, 1);\n            }\n          }\n        }\n\n        if (!predicate || actions.length === 0) {\n          clearTimeout(item.id);\n          scheduled.splice(idx, 1);\n        }\n      }\n    }\n\n  }\n\n  HoverService.ɵfac = function HoverService_Factory(t) {\n    return new (t || HoverService)(i0.ɵɵinject(ActionsService), i0.ɵɵinject(ItemsService));\n  };\n\n  HoverService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HoverService,\n    factory: HoverService.ɵfac\n  });\n  return HoverService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst normalize = settings => settings && Object.assign({\n  toggle: 'select'\n}, settings);\n/**\n * @hidden\n */\n\n\nconst NODE_INDEX = 'data-kendo-menu-index';\nconst DEFAULT_ID = 'kendo-matches-container';\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n\nconst matches = (element, selector) => (element.matches || element.msMatchesSelector).call(element, selector);\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n\n    return focusable;\n  }\n\n  return false;\n};\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\n\n\nconst hasClass = (element, name) => {\n  return toClassList(element.className).indexOf(name) >= 0;\n};\n/**\n * @hidden\n */\n\n\nconst matchesClasses = classes => {\n  const list = toClassList(classes);\n  return element => {\n    const classList = toClassList(element.className);\n    return Boolean(list.find(name => classList.indexOf(name) >= 0));\n  };\n};\n/**\n * @hidden\n */\n\n\nconst nodeIndex = node => node.getAttribute(NODE_INDEX);\n/**\n * @hidden\n */\n\n\nconst closestItem = (node, scope) => closestInScope(node, nodeIndex, scope);\n/**\n * @hidden\n */\n\n\nconst closestList = node => {\n  let list = closest(node, matchesClasses('k-menu-popup k-menu k-menu-group'));\n\n  if (list && hasClass(list, 'k-menu-popup')) {\n    list = list.querySelector('.k-menu-group');\n  }\n\n  return list;\n};\n/**\n * @hidden\n */\n\n\nconst inMenu = (node, itemsService) => {\n  if (node === itemsService.lists[0].element.nativeElement) {\n    return false;\n  }\n\n  const list = closestList(node);\n  return list && itemsService.containsList(list);\n};\n/**\n * @hidden\n */\n\n\nconst findInContainer = (element, selector, container) => {\n  const id = container.getAttribute('id');\n\n  if (!id) {\n    container.setAttribute('id', DEFAULT_ID);\n  }\n\n  const contextSelector = `#${id || DEFAULT_ID} ${selector}`;\n  const match = closestInScope(element, node => matches(node, contextSelector), container);\n\n  if (!id) {\n    container.removeAttribute('id');\n  }\n\n  return match;\n};\n/**\n * Represents a template for the Menu items ([see example]({% slug templates_menu %})). To define a template\n * for an item, nest an `<ng-template>` tag with the `kendoMenuItemTemplate` directive inside a `<kendo-menu-item>`\n * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.\n *\n * The available fields in the template context are:\n * - `item`&mdash;The item data.\n * - `index`&mdash;The item index.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-menu>\n *          <kendo-menu-item text=\"item2\">\n *              <ng-template kendoMenuItemTemplate let-item=\"item\" let-index=\"index\">\n *                  <div style=\"padding: 10px;\">\n *                      My Template for: {{ item.text }} at index: {{ index }}\n *                  </div>\n *              </ng-template>\n *          </kendo-menu-item>\n *        </kendo-menu>\n *    `\n * })\n *\n * class AppComponent {\n * }\n * ```\n */\n\n\nlet ItemTemplateDirective = /*#__PURE__*/(() => {\n  class ItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ItemTemplateDirective.ɵfac = function ItemTemplateDirective_Factory(t) {\n    return new (t || ItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ItemTemplateDirective,\n    selectors: [[\"\", \"kendoMenuItemTemplate\", \"\"]]\n  });\n  return ItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template for the links of the Menu items ([see example]({% slug templates_menu %})). To define a template\n * for an item, nest an `<ng-template>` tag with the `kendoMenuItemLinkTemplate` directive inside a `<kendo-menu-item>`\n * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.\n *\n * The available fields in the template context are:\n * - `item`&mdash;The item data.\n * - `index`&mdash;The item index.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-menu>\n *          <kendo-menu-item text=\"item2\">\n *              <ng-template kendoMenuItemLinkTemplate let-item=\"item\" let-index=\"index\">\n *                  <span [kendoMenuItemLink]=\"index\">\n *                      {{ item.text }}\n *                      <span *ngIf=\"item.items && item.items.length\" [kendoMenuExpandArrow]=\"index\"></span>\n *                  </span>\n *              </ng-template>\n *          </kendo-menu-item>\n *        </kendo-menu>\n *    `\n * })\n *\n * class AppComponent {\n * }\n * ```\n */\n\n\nlet ItemLinkTemplateDirective = /*#__PURE__*/(() => {\n  class ItemLinkTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ItemLinkTemplateDirective.ɵfac = function ItemLinkTemplateDirective_Factory(t) {\n    return new (t || ItemLinkTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ItemLinkTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ItemLinkTemplateDirective,\n    selectors: [[\"\", \"kendoMenuItemLinkTemplate\", \"\"]]\n  });\n  return ItemLinkTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template for the content of the Menu items ([see example]({% slug templates_menu %})). To define the template,\n * nest an `<ng-template>` tag with the `kendoMenuItemContentTemplate` directive inside a `<kendo-menu-item>` component.\n *\n * The available fields in the template context are:\n * - `item`&mdash;The item data.\n * - `index`&mdash;The item index.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-menu>\n *          <kendo-menu-item text=\"item2\">\n *              <ng-template kendoMenuItemContentTemplate let-item=\"item\" let-index=\"index\">\n *                  <div style=\"padding: 10px;\">\n *                      My Content Template for: {{ item.text }} at index: {{ index }}\n *                  </div>\n *              </ng-template>\n *          </kendo-menu-item>\n *        </kendo-menu>\n *    `\n * })\n *\n * class AppComponent {\n * }\n * ```\n */\n\n\nlet ItemContentTemplateDirective = /*#__PURE__*/(() => {\n  class ItemContentTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ItemContentTemplateDirective.ɵfac = function ItemContentTemplateDirective_Factory(t) {\n    return new (t || ItemContentTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ItemContentTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ItemContentTemplateDirective,\n    selectors: [[\"\", \"kendoMenuItemContentTemplate\", \"\"]]\n  });\n  return ItemContentTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component that can be used to specify the Menu items\n * ([more information and examples]({% slug items_menu %})).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-menu>\n *          <kendo-menu-item text=\"item1\">\n *              <kendo-menu-item text=\"item1.1\" url=\"https://example.com\">\n *              </kendo-menu-item>\n *              <kendo-menu-item text=\"item1.2\" [disabled]=\"true\">\n *              </kendo-menu-item>\n *          </kendo-menu-item>\n *          <kendo-menu-item text=\"item2\">\n *              <ng-template kendoMenuItemContentTemplate let-item=\"item\">\n *                  <div style=\"padding: 10px;\">\n *                      My Content Template: {{ item.text }}\n *                  </div>\n *              </ng-template>\n *              <ng-template kendoMenuItemTemplate let-item=\"item\">\n *                  <div style=\"padding: 10px;\">\n *                      My Template: {{ item.text }}\n *                  </div>\n *              </ng-template>\n *          </kendo-menu-item>\n *          <kendo-menu-item text=\"item3\">\n *              <ng-template kendoMenuItemLinkTemplate let-item=\"item\" let-index=\"index\">\n *                  <span [kendoMenuItemLink]=\"index\">\n *                      {{ item.text }}\n *                      <span *ngIf=\"item.items && item.items.length\" [kendoMenuExpandArrow]=\"index\"></span>\n *                  </span>\n *              </ng-template>\n *          </kendo-menu-item>\n *        </kendo-menu>\n *    `\n * })\n *\n * class AppComponent {\n * }\n * ```\n */\n\n\nlet MenuItemComponent = /*#__PURE__*/(() => {\n  class MenuItemComponent {\n    /**\n     * @hidden\n     */\n    get template() {\n      if (this.itemTemplate && this.itemTemplate.length) {\n        return this.itemTemplate.first.templateRef;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get linkTemplate() {\n      if (this.itemLinkTemplate && this.itemLinkTemplate.length) {\n        return this.itemLinkTemplate.first.templateRef;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get contentTemplate() {\n      if (this.itemContentTemplate && this.itemContentTemplate.length) {\n        return this.itemContentTemplate.first.templateRef;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get items() {\n      if (this.children.length) {\n        return this.children.toArray().filter(c => c !== this);\n      }\n    }\n\n  }\n\n  MenuItemComponent.ɵfac = function MenuItemComponent_Factory(t) {\n    return new (t || MenuItemComponent)();\n  };\n\n  MenuItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MenuItemComponent,\n    selectors: [[\"kendo-menu-item\"]],\n    contentQueries: function MenuItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ItemContentTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, MenuItemComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemContentTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    inputs: {\n      text: \"text\",\n      url: \"url\",\n      disabled: \"disabled\",\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\",\n      icon: \"icon\",\n      data: \"data\",\n      separator: \"separator\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function MenuItemComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MenuItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet MenuBase = /*#__PURE__*/(() => {\n  class MenuBase {\n    constructor() {\n      /**\n       * Specifies if the Menu will be vertical ([see example]({% slug vertical_menu %})).\n       */\n      this.vertical = false;\n      /**\n       * Specifies that the root items can be opened only on click\n       * ([see example]({% slug openclose_menu %}#toc-opening-on-click)).\n       */\n\n      this.openOnClick = false;\n      /**\n       * Specifies the delay in milliseconds before the Menu items are opened or closed on item hover\n       * or leave ([see example]({% slug openclose_menu %}#toc-delay-on-hover)). Used to avoid the accidental\n       * opening or closing of the items.\n       */\n\n      this.hoverDelay = 100;\n      /**\n       * Sets the Menu animation.\n       */\n\n      this.animate = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get rootItems() {\n      return this.items || (this.children ? this.children.toArray() : []);\n    }\n\n  }\n\n  MenuBase.ɵfac = function MenuBase_Factory(t) {\n    return new (t || MenuBase)();\n  };\n\n  MenuBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MenuBase,\n    selectors: [[\"kendo-menu-base\"]],\n    contentQueries: function MenuBase_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, MenuItemComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    inputs: {\n      items: \"items\",\n      vertical: \"vertical\",\n      openOnClick: \"openOnClick\",\n      hoverDelay: \"hoverDelay\",\n      animate: \"animate\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function MenuBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MenuBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ContextMenuService = /*#__PURE__*/(() => {\n  class ContextMenuService {\n    constructor() {\n      this.keydown = new EventEmitter();\n    }\n\n    emit(name, args) {\n      this.owner.emitMenuEvent(name, args);\n    }\n\n    hasObservers(name) {\n      return this.owner && hasObservers(this.owner[name]);\n    }\n\n    leaveMenu(e) {\n      return this.items ? !inMenu(e.target, this.items) : true;\n    }\n\n  }\n\n  ContextMenuService.ɵfac = function ContextMenuService_Factory(t) {\n    return new (t || ContextMenuService)();\n  };\n\n  ContextMenuService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContextMenuService,\n    factory: ContextMenuService.ɵfac\n  });\n  return ContextMenuService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst defined = value => typeof value !== 'undefined';\n/**\n * @hidden\n */\n\n\nconst bodyFactory = () => {\n  if (isDocumentAvailable()) {\n    return new ElementRef(document.body);\n  }\n};\n\nconst POPUP_ALIGN = {\n  vertical: 'top',\n  horizontal: 'left'\n};\nconst POPUP_ALIGN_RTL = {\n  vertical: 'top',\n  horizontal: 'right'\n};\nconst VERTICAL_COLLISION = {\n  vertical: 'flip',\n  horizontal: 'fit'\n};\nconst HORIZONTAL_COLLISION = {\n  vertical: 'fit',\n  horizontal: 'flip'\n};\n/**\n * @hidden\n */\n\nconst POPUP_SETTINGS_RTL = {\n  vertical: {\n    anchor: {\n      vertical: 'bottom',\n      horizontal: 'right'\n    },\n    popup: POPUP_ALIGN_RTL,\n    collision: VERTICAL_COLLISION,\n    animate: 'down'\n  },\n  horizontal: {\n    anchor: {\n      vertical: 'top',\n      horizontal: 'left'\n    },\n    popup: POPUP_ALIGN_RTL,\n    collision: HORIZONTAL_COLLISION,\n    animate: 'left'\n  }\n};\n/**\n * @hidden\n */\n\nconst POPUP_SETTINGS = {\n  vertical: {\n    anchor: {\n      vertical: 'bottom',\n      horizontal: 'left'\n    },\n    popup: POPUP_ALIGN,\n    collision: VERTICAL_COLLISION,\n    animate: 'down'\n  },\n  horizontal: {\n    anchor: {\n      vertical: 'top',\n      horizontal: 'right'\n    },\n    popup: POPUP_ALIGN,\n    collision: HORIZONTAL_COLLISION,\n    animate: 'right'\n  }\n};\n/* eslint-disable @angular-eslint/component-selector */\n\n/**\n * @hidden\n */\n\nlet ListComponent = /*#__PURE__*/(() => {\n  class ListComponent {\n    constructor(itemsService, hover, actions, navigation, renderer, ngZone, element) {\n      this.itemsService = itemsService;\n      this.hover = hover;\n      this.actions = actions;\n      this.navigation = navigation;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.element = element;\n      this.animate = true;\n    }\n\n    hierarchyIndex(index) {\n      return this.itemsService.itemIndex(this.index, index);\n    }\n\n    ngOnInit() {\n      this.itemsService.addList(this);\n      this.initDomEvents();\n    }\n\n    ngOnDestroy() {\n      this.itemsService.removeList(this);\n\n      if (this.domSubscriptions) {\n        this.domSubscriptions();\n      }\n    }\n\n    initDomEvents() {\n      if (!isDocumentAvailable() || !this.element) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        const element = this.element.nativeElement;\n        const container = this.level > 0 ? closest(element, node => hasClass(node, 'k-popup')) : element;\n        const overSubscription = this.renderer.listen(element, 'mouseover', e => {\n          if (e.target === element && this.level === 0) {\n            this.onLeave();\n          } else {\n            const item = this.nodeItem(e.target) || this.itemsService.get(this.index);\n\n            if (item && !(this.openOnClick && this.openOnClick.toggle === 'click' && item.level === 0 && !item.hasContent)) {\n              this.hover.over(item);\n            }\n          }\n        });\n        const leaveSubscription = this.renderer.listen(container, 'mouseleave', e => {\n          if (this.leavesMenu(e)) {\n            this.onLeave();\n          }\n        });\n        const keydownSubscription = this.renderer.listen(element, 'keydown', e => {\n          if (hasClass(e.target, 'k-menu-item')) {\n            this.navigation.keydown(e);\n          }\n        });\n        const blurSubscription = this.renderer.listen(element, 'focusout', e => {\n          if (this.leavesMenu(e)) {\n            this.navigation.focusLeave();\n          }\n        });\n        /**\n         * Handle focus/blur open/close for iOS devices since it behaves inconsistently with the rest\n         * Refer to: https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n         */\n\n        const touchSubscription = this.renderer.listen(document, 'touchstart', e => {\n          if (inMenu(e.target, this.itemsService)) {\n            const item = this.nodeItem(e.target); // Needs to be called because the 'click' handler will be called only on secondary tap and the item will remain unfocused\n\n            this.navigation.focus(item); // This is needed since the 'mouseover' event is not always dispatched\n\n            if (!item.opened) {\n              this.hover.over(item);\n            }\n          } else if (this.navigation.focusedIdx) {\n            // If the touch is outside of the menu and the menu is not currently in focus\n            const activeItem = this.itemsService.get(this.navigation.activeIndex);\n            this.onLeave(); // needs to be called explicitly since mouseleave event is not triggered\n\n            activeItem.blur(); // needs to be called explicitly otherwise the item remains focused => triggers focusout\n          }\n        });\n        const clickSubscription = this.renderer.listen(element, 'click', this.clickHandler.bind(this));\n\n        this.domSubscriptions = () => {\n          overSubscription();\n          leaveSubscription();\n          keydownSubscription();\n          blurSubscription();\n          clickSubscription();\n          touchSubscription();\n        };\n      });\n    }\n\n    leavesMenu(e) {\n      if (!e.relatedTarget) {\n        return true;\n      }\n\n      return !inMenu(e.relatedTarget, this.itemsService);\n    }\n\n    onLeave() {\n      const openOnClick = this.openOnClick;\n\n      if (!openOnClick || openOnClick.toggle !== 'click') {\n        this.hover.leave(openOnClick && openOnClick.toggle === 'leave');\n      }\n    }\n\n    nodeItem(target) {\n      const node = closestItem(target, this.element.nativeElement);\n\n      if (node) {\n        const index = nodeIndex(node);\n        return this.itemsService.get(index);\n      }\n    }\n\n    clickHandler(e) {\n      if (isFocusable(e.target) && !hasClass(e.target, 'k-menu-item')) {\n        return;\n      }\n\n      const item = this.nodeItem(e.target);\n\n      if (!item || item.isContent || item.navigating) {\n        return;\n      }\n\n      if (item.disabled) {\n        e.preventDefault();\n        return;\n      }\n\n      this.actions.select(item, e, () => {\n        e.preventDefault();\n      });\n      this.navigation.focus(item);\n\n      if (item.level > 0 && !item.hasContent) {\n        this.actions.closeToRoot(item);\n      }\n\n      if (this.openOnClick) {\n        const hover = this.hover;\n\n        if (item.opened) {\n          if (item.level === 0) {\n            hover.openOnOver = false;\n            this.actions.close(item);\n          }\n        } else if (item.hasContent) {\n          hover.openOnOver = true;\n          this.actions.closeOthers(item);\n          this.actions.open(item);\n        } else {\n          hover.openOnOver = false;\n\n          if (item.level === 0 && this.openOnClick.toggle === 'click') {\n            this.hover.closeCurrent();\n          }\n        }\n      }\n\n      this.actions.execute();\n    }\n\n  }\n\n  ListComponent.ɵfac = function ListComponent_Factory(t) {\n    return new (t || ListComponent)(i0.ɵɵdirectiveInject(ItemsService), i0.ɵɵdirectiveInject(HoverService), i0.ɵɵdirectiveInject(ActionsService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ListComponent,\n    selectors: [[\"\", \"kendoMenuList\", \"\"]],\n    inputs: {\n      items: \"items\",\n      level: \"level\",\n      index: \"index\",\n      animate: \"animate\",\n      vertical: \"vertical\",\n      rtl: \"rtl\",\n      openOnClick: \"openOnClick\",\n      itemTemplate: \"itemTemplate\",\n      itemLinkTemplate: \"itemLinkTemplate\"\n    },\n    attrs: _c0,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoMenuItem\", \"\", \"role\", \"menuitem\", \"class\", \"k-item k-menu-item\", 3, \"item\", \"level\", \"vertical\", \"animate\", \"rtl\", \"itemTemplate\", \"itemLinkTemplate\", \"openOnClick\", \"index\", \"siblingIndex\", \"ngClass\", \"ngStyle\", \"k-first\", \"k-last\", \"k-state-disabled\", 4, \"ngIf\"], [\"class\", \"k-separator k-item\", \"role\", \"separator\", 3, \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoMenuItem\", \"\", \"role\", \"menuitem\", 1, \"k-item\", \"k-menu-item\", 3, \"item\", \"level\", \"vertical\", \"animate\", \"rtl\", \"itemTemplate\", \"itemLinkTemplate\", \"openOnClick\", \"index\", \"siblingIndex\", \"ngClass\", \"ngStyle\"], [\"role\", \"separator\", 1, \"k-separator\", \"k-item\", 3, \"ngClass\", \"ngStyle\"]],\n    template: function ListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ListComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    directives: function () {\n      return [ItemComponent, i5.NgForOf, i5.NgIf, i5.NgClass, i5.NgStyle];\n    },\n    encapsulation: 2\n  });\n  return ListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ItemComponent = /*#__PURE__*/(() => {\n  class ItemComponent {\n    constructor(itemsService, navigation, changeDetector, renderer, popupService, element) {\n      this.itemsService = itemsService;\n      this.navigation = navigation;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.popupService = popupService;\n      this.element = element;\n      this.animate = true;\n      this.openOnClick = false;\n      this.opened = false;\n      this.navigating = false;\n      this.destroyed = false;\n    }\n\n    set index(index) {\n      if (this._index && this._index !== index) {\n        this.itemsService.remove(this);\n        this._index = index;\n        this.itemsService.add(this);\n      } else {\n        this._index = index;\n      }\n\n      this.childId = this.itemsService.childId(index);\n    }\n\n    get index() {\n      return this._index;\n    }\n\n    get disabled() {\n      return this.item.disabled;\n    }\n\n    get hasPopup() {\n      return this.hasContent ? true : null;\n    }\n\n    get expanded() {\n      return this.hasContent ? this.opened : null;\n    }\n\n    get label() {\n      return this.item.text ? this.item.text : null;\n    }\n\n    get activeId() {\n      return this.index === this.navigation.activeIndex ? '0' : '-1';\n    }\n\n    get popupSettings() {\n      const settings = this.rtl ? POPUP_SETTINGS_RTL : POPUP_SETTINGS;\n      return this.horizontal ? settings.horizontal : settings.vertical;\n    }\n\n    get horizontal() {\n      return this.vertical || this.level > 0;\n    }\n\n    get hasLink() {\n      return Boolean(this.item.url);\n    }\n\n    get linkTemplate() {\n      return this.item.linkTemplate || this.itemLinkTemplate;\n    }\n\n    get hasContent() {\n      const items = this.item.items;\n      return items && items.length || this.item.contentTemplate;\n    }\n\n    get isContent() {\n      return Boolean(this.item.content);\n    }\n\n    get iconClass() {\n      return `k-i-${this.item.icon}`;\n    }\n\n    get children() {\n      const item = this.item;\n\n      if (item.contentTemplate) {\n        if (!this.contentItems) {\n          this.contentItems = [{\n            content: item.contentTemplate,\n            owner: item,\n            ownerIndex: this.index\n          }];\n        }\n\n        return this.contentItems;\n      }\n\n      return item.items;\n    }\n\n    get template() {\n      return this.item.template || this.itemTemplate;\n    }\n\n    hasContentTemplates() {\n      const item = this.item;\n      return this.itemTemplate || item.contentTemplate || this.itemLinkTemplate || item.items && item.items.find(current => current.template || current.linkTemplate);\n    }\n\n    ngOnInit() {\n      this.itemsService.add(this);\n    }\n\n    ngOnDestroy() {\n      this.itemsService.remove(this);\n      this.destroyed = true;\n\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    focus() {\n      this.element.nativeElement.focus();\n    }\n\n    blur() {\n      this.element.nativeElement.blur();\n    }\n\n    toggleActive(isActive) {\n      if (isActive) {\n        this.setAttribute('tabindex', '0');\n      } else {\n        this.setAttribute('tabindex', '-1');\n      }\n    }\n\n    open() {\n      if (!this.destroyed && this.hasContent && !this.opened) {\n        const popupSettings = this.popupSettings;\n        const animate = this.animate ? Object.assign({}, this.animate, {\n          direction: popupSettings.animate\n        }) : false;\n        this.opened = true;\n        this.popupRef = this.popupService.open({\n          popupAlign: popupSettings.popup,\n          anchorAlign: popupSettings.anchor,\n          collision: popupSettings.collision,\n          anchor: this.element,\n          positionMode: 'absolute',\n          content: this.popupTemplate,\n          popupClass: {\n            'k-rtl': this.rtl,\n            'k-menu-popup': true\n          },\n          animate: animate\n        });\n        this.setAttribute('aria-expanded', 'true');\n        this.setAttribute('aria-owns', this.childId);\n        this.changeDetector.detectChanges();\n      }\n    }\n\n    close() {\n      if (!this.destroyed && this.opened) {\n        this.opened = false;\n\n        if (this.popupRef) {\n          this.popupRef.close();\n          this.popupRef = null;\n        }\n\n        this.changeDetector.detectChanges();\n        this.setAttribute('aria-expanded', 'false');\n        this.renderer.removeAttribute(this.element.nativeElement, 'aria-owns');\n      }\n    }\n\n    navigate() {\n      let link;\n\n      if (this.linkTemplate) {\n        link = this.element.nativeElement.querySelector('a.k-menu-link');\n      } else if (this.hasLink) {\n        link = this.link.nativeElement;\n      }\n\n      if (link) {\n        this.navigating = true;\n        link.click();\n        this.navigating = false;\n      }\n    }\n\n    setAttribute(name, value) {\n      this.renderer.setAttribute(this.element.nativeElement, name, value);\n    }\n\n  }\n\n  ItemComponent.ɵfac = function ItemComponent_Factory(t) {\n    return new (t || ItemComponent)(i0.ɵɵdirectiveInject(ItemsService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i6.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ItemComponent,\n    selectors: [[\"\", \"kendoMenuItem\", \"\"]],\n    viewQuery: function ItemComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.link = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function ItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-haspopup\", ctx.hasPopup)(\"aria-expanded\", ctx.expanded)(\"aria-label\", ctx.label)(\"tabindex\", ctx.activeId);\n      }\n    },\n    inputs: {\n      item: \"item\",\n      level: \"level\",\n      index: \"index\",\n      siblingIndex: \"siblingIndex\",\n      animate: \"animate\",\n      vertical: \"vertical\",\n      rtl: \"rtl\",\n      openOnClick: \"openOnClick\",\n      itemTemplate: \"itemTemplate\",\n      itemLinkTemplate: \"itemLinkTemplate\"\n    },\n    features: [i0.ɵɵProvidersFeature([PopupService, {\n      provide: POPUP_CONTAINER,\n      useFactory: bodyFactory\n    }])],\n    attrs: _c3,\n    decls: 8,\n    vars: 4,\n    consts: [[\"class\", \"k-link k-menu-link\", \"role\", \"presentation\", 3, \"k-state-active\", 4, \"ngIf\"], [\"class\", \"k-link k-menu-link\", \"tabindex\", \"-1\", \"role\", \"presentation\", 3, \"k-state-active\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-content\", \"role\", \"presentation\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"itemcontent\", \"\"], [\"role\", \"presentation\", 1, \"k-link\", \"k-menu-link\"], [\"link\", \"\"], [3, \"ngTemplateOutlet\"], [\"tabindex\", \"-1\", \"role\", \"presentation\", 1, \"k-link\", \"k-menu-link\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"role\", \"presentation\", 1, \"k-content\"], [\"kendoMenuList\", \"\", \"role\", \"menu\", 1, \"k-group\", \"k-menu-group\", \"k-reset\", 3, \"animate\", \"rtl\", \"vertical\", \"openOnClick\", \"items\", \"level\", \"index\", \"itemTemplate\", \"itemLinkTemplate\"], [\"class\", \"k-icon\", \"role\", \"presentation\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-icon k-menu-expand-arrow\", \"role\", \"presentation\", 3, \"k-i-arrow-60-down\", \"k-i-arrow-60-right\", \"k-i-arrow-60-left\", 4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-icon\", 3, \"ngClass\"], [1, \"k-menu-link-text\"], [\"role\", \"presentation\", 1, \"k-icon\", \"k-menu-expand-arrow\"]],\n    template: function ItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ItemComponent_span_0_Template, 3, 3, \"span\", 0);\n        i0.ɵɵtemplate(1, ItemComponent_a_1_Template, 3, 4, \"a\", 1);\n        i0.ɵɵtemplate(2, ItemComponent_2_Template, 1, 5, null, 2);\n        i0.ɵɵtemplate(3, ItemComponent_div_3_Template, 2, 5, \"div\", 3);\n        i0.ɵɵtemplate(4, ItemComponent_ng_template_4_Template, 1, 10, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, ItemComponent_ng_template_6_Template, 4, 4, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.hasLink && !ctx.item.content && !ctx.linkTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.item.url && !ctx.linkTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.linkTemplate && !ctx.item.content);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.item.content);\n      }\n    },\n    directives: [ListComponent, i5.NgIf, i5.NgTemplateOutlet, i5.NgClass],\n    encapsulation: 2\n  });\n  return ItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Menu component for Angular]({% slug overview_menu %}).\n *\n * @example\n * ```ts\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-menu [items]=\"items\">\n *        </kendo-menu>\n *    `\n * })\n * class AppComponent {\n *    public items: any[] = [{ text: 'item1', items: [{ text: 'item1.1' }] }, { text: 'item2', disabled: true }];\n * }\n * ```\n */\n\n\nlet MenuComponent = /*#__PURE__*/(() => {\n  class MenuComponent extends MenuBase {\n    constructor(itemsService, hover, actions, navigation, localization, ngZone, renderer, contextService) {\n      super();\n      this.itemsService = itemsService;\n      this.hover = hover;\n      this.actions = actions;\n      this.navigation = navigation;\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.contextService = contextService;\n      /**\n       * Fires when a Menu item is selected ([see example]({% slug routing_menu %})).\n       */\n\n      this.select = new EventEmitter();\n      /**\n       * Fires when a Menu item is opened.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires when a Menu item is closed.\n       */\n\n      this.close = new EventEmitter();\n      validatePackage(packageMetadata);\n      this.actions.owner = this;\n\n      if (contextService) {\n        contextService.items = this.itemsService;\n        this.contextKeyDownSubscription = contextService.keydown.subscribe(this.contextKeyDown.bind(this));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get ariaOrientation() {\n      if (this.vertical) {\n        return 'vertical';\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get contextMenuClass() {\n      return Boolean(this.contextService);\n    }\n\n    get direction() {\n      return this.rtl;\n    }\n\n    get rtl() {\n      return this.localization.rtl;\n    }\n    /**\n     * Opens or closes the specified Menu items.\n     *\n     * @param open - A Boolean value which indicates if the items will be opened or closed.\n     * @param indices - One or more values which represent the hierarchical indices of the items that will be opened or closed.\n     */\n\n\n    toggle(open, ...indices) {\n      for (let idx = 0; idx < indices.length; idx++) {\n        const item = this.itemsService.get(indices[idx]);\n\n        if (item && !item.disabled) {\n          if (open) {\n            item.open();\n          } else {\n            item.close();\n          }\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus(index) {\n      this.navigation.focusIndex(index);\n    }\n\n    ngOnChanges(changes) {\n      this.navigation.vertical = this.vertical;\n      this.hover.delay = this.hoverDelay;\n\n      if (changes.openOnClick) {\n        const openOnClick = this.openOnClick = normalize(this.openOnClick);\n        this.hover.openOnOver = !openOnClick;\n\n        if (openOnClick && openOnClick.toggle === 'click') {\n          this.attachCloseClick();\n        } else {\n          this.unsubscribeClick();\n        }\n      }\n    }\n\n    ngAfterViewChecked() {\n      this.navigation.updateActive();\n    }\n\n    ngOnDestroy() {\n      this.unsubscribeClick();\n\n      if (this.contextService) {\n        this.contextService.items = null;\n        this.contextKeyDownSubscription.unsubscribe();\n      }\n    }\n\n    attachCloseClick() {\n      if (!this.closeClickSubscription && isDocumentAvailable()) {\n        this.ngZone.runOutsideAngular(() => {\n          this.closeClickSubscription = this.renderer.listen('document', 'click', e => {\n            if (!inMenu(e.target, this.itemsService)) {\n              this.hover.openOnOver = false;\n              this.actions.closeAll();\n              this.actions.execute();\n            }\n          });\n        });\n      }\n    }\n\n    unsubscribeClick() {\n      if (this.closeClickSubscription) {\n        this.closeClickSubscription();\n      }\n    }\n\n    contextKeyDown(e) {\n      if (!this.itemsService.hasItems) {\n        return;\n      }\n\n      const keyCode = e.keyCode;\n      const rtl = this.localization.rtl;\n      const first = keyCode === Keys.ArrowDown || keyCode === Keys.ArrowRight;\n      const last = keyCode === Keys.ArrowUp || keyCode === Keys.ArrowLeft;\n      let index;\n\n      if (first && !rtl || last && rtl) {\n        index = 'first';\n      } else if (first && rtl || last && !rtl) {\n        index = 'last';\n      }\n\n      if (index) {\n        e.preventDefault();\n        this.focus(index);\n      }\n    }\n\n  }\n\n  MenuComponent.ɵfac = function MenuComponent_Factory(t) {\n    return new (t || MenuComponent)(i0.ɵɵdirectiveInject(ItemsService), i0.ɵɵdirectiveInject(HoverService), i0.ɵɵdirectiveInject(ActionsService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i3.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ContextMenuService, 8));\n  };\n\n  MenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MenuComponent,\n    selectors: [[\"kendo-menu\"]],\n    hostVars: 2,\n    hostBindings: function MenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-rtl\", ctx.direction);\n      }\n    },\n    inputs: {\n      menuItemTemplate: \"menuItemTemplate\",\n      menuItemLinkTemplate: \"menuItemLinkTemplate\"\n    },\n    outputs: {\n      select: \"select\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoMenu\"],\n    features: [i0.ɵɵProvidersFeature([ItemsService, ActionsService, NavigationService, HoverService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.menu'\n    }, {\n      provide: MenuBase,\n      useExisting: forwardRef(() => MenuComponent)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 15,\n    consts: [[\"role\", \"menubar\", \"kendoMenuList\", \"\", 1, \"k-widget\", \"k-reset\", \"k-header\", \"k-menu\", 3, \"items\", \"level\", \"vertical\", \"rtl\", \"animate\", \"openOnClick\", \"itemTemplate\", \"itemLinkTemplate\"]],\n    template: function MenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"ul\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-menu-horizontal\", !ctx.vertical)(\"k-menu-vertical\", ctx.vertical)(\"k-context-menu\", ctx.contextMenuClass);\n        i0.ɵɵproperty(\"items\", ctx.rootItems)(\"level\", 0)(\"vertical\", ctx.vertical)(\"rtl\", ctx.rtl)(\"animate\", ctx.animate)(\"openOnClick\", ctx.openOnClick)(\"itemTemplate\", (ctx.itemTemplate.first == null ? null : ctx.itemTemplate.first.templateRef) || ctx.menuItemTemplate)(\"itemLinkTemplate\", (ctx.itemLinkTemplate.first == null ? null : ctx.itemLinkTemplate.first.templateRef) || ctx.menuItemLinkTemplate);\n        i0.ɵɵattribute(\"aria-orientation\", ctx.ariaOrientation);\n      }\n    },\n    directives: [ListComponent],\n    encapsulation: 2\n  });\n  return MenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})\n * of the items to apply the default styling and behavior.\n */\n\n\nlet LinkDirective = /*#__PURE__*/(() => {\n  class LinkDirective {\n    constructor(itemsService) {\n      this.itemsService = itemsService;\n      this.hostClasses = true;\n      this.role = 'presentation';\n      this.tabindex = '-1';\n    }\n\n    get activeClass() {\n      return this.item.opened;\n    }\n\n    ngOnInit() {\n      if (isDevMode() && !this.index) {\n        throw new Error('The kendoMenuItemLink directive requires the item index to be set.');\n      }\n\n      this.item = this.itemsService.get(this.index) || {};\n    }\n\n  }\n\n  LinkDirective.ɵfac = function LinkDirective_Factory(t) {\n    return new (t || LinkDirective)(i0.ɵɵdirectiveInject(ItemsService));\n  };\n\n  LinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LinkDirective,\n    selectors: [[\"\", \"kendoMenuItemLink\", \"\"]],\n    hostVars: 8,\n    hostBindings: function LinkDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex);\n        i0.ɵɵclassProp(\"k-link\", ctx.hostClasses)(\"k-menu-link\", ctx.hostClasses)(\"k-state-active\", ctx.activeClass);\n      }\n    },\n    inputs: {\n      index: [\"kendoMenuItemLink\", \"index\"]\n    }\n  });\n  return LinkDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})\n * of the items to render the default expand arrow.\n */\n\n\nlet ExpandArrowDirective = /*#__PURE__*/(() => {\n  class ExpandArrowDirective {\n    constructor(itemsService) {\n      this.itemsService = itemsService;\n      this.hostClasses = true;\n      this.role = 'presentation';\n    }\n\n    get arrowDown() {\n      return !this.item.horizontal;\n    }\n\n    get arrowRight() {\n      return this.item.horizontal && !this.item.rtl;\n    }\n\n    get arrowLeft() {\n      return this.item.horizontal && this.item.rtl;\n    }\n\n    ngOnInit() {\n      if (isDevMode() && !this.index) {\n        throw new Error('The kendoMenuExpandArrow directive requires the item index to be set.');\n      }\n\n      this.item = this.itemsService.get(this.index) || {};\n    }\n\n  }\n\n  ExpandArrowDirective.ɵfac = function ExpandArrowDirective_Factory(t) {\n    return new (t || ExpandArrowDirective)(i0.ɵɵdirectiveInject(ItemsService));\n  };\n\n  ExpandArrowDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExpandArrowDirective,\n    selectors: [[\"\", \"kendoMenuExpandArrow\", \"\"]],\n    hostVars: 11,\n    hostBindings: function ExpandArrowDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-icon\", ctx.hostClasses)(\"k-menu-expand-arrow\", ctx.hostClasses)(\"k-i-arrow-60-down\", ctx.arrowDown)(\"k-i-arrow-60-right\", ctx.arrowRight)(\"k-i-arrow-60-left\", ctx.arrowLeft);\n      }\n    },\n    inputs: {\n      index: [\"kendoMenuExpandArrow\", \"index\"]\n    }\n  });\n  return ExpandArrowDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    this.prevented = false;\n    Object.assign(this, args);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Arguments for the `open` and `close` events of the Menu.\n */\n\n\nclass MenuEvent extends PreventableEvent {}\n/**\n * Arguments for the `select` event of the Menu.\n */\n\n\nclass MenuSelectEvent extends MenuEvent {}\n\nconst ITEM_FIELDS = ['textField', 'urlField', 'iconField', 'disabledField', 'cssClassField', 'cssStyleField', 'separatorField'];\n/**\n * @hidden\n */\n\nlet BindingDirectiveBase = /*#__PURE__*/(() => {\n  class BindingDirectiveBase {\n    constructor(menu) {\n      this.menu = menu;\n    }\n\n    ngOnChanges() {\n      this.rebind();\n    }\n    /**\n     *  Rebinds the Menu items.\n     */\n\n\n    rebind() {\n      const fields = this.fields = [];\n\n      for (let idx = 0; idx < ITEM_FIELDS.length; idx++) {\n        const inputName = ITEM_FIELDS[idx];\n        const inputValue = this[inputName];\n\n        if (inputValue) {\n          fields.push({\n            target: inputName.replace('Field', ''),\n            source: inputValue\n          });\n        }\n      }\n\n      this.menu.items = this.data ? this.mapItems(this.data) : [];\n    }\n\n  }\n\n  BindingDirectiveBase.ɵfac = function BindingDirectiveBase_Factory(t) {\n    return new (t || BindingDirectiveBase)(i0.ɵɵdirectiveInject(MenuBase));\n  };\n\n  BindingDirectiveBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BindingDirectiveBase,\n    selectors: [[\"kendoBindingBase\"]],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return BindingDirectiveBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\nconst getterCache = {};\n\ngetterCache['undefined'] = obj => obj;\n/**\n * @hidden\n */\n\n\nconst getter = field => {\n  if (getterCache[field]) {\n    return getterCache[field];\n  }\n\n  const fields = [];\n  field.replace(FIELD_REGEX, (_match, index, indexAccessor, name) => {\n    fields.push(index !== undefined ? index : indexAccessor || name);\n  });\n\n  getterCache[field] = obj => {\n    let result = obj;\n\n    for (let idx = 0; idx < fields.length && result; idx++) {\n      result = result[fields[idx]];\n    }\n\n    return result;\n  };\n\n  return getterCache[field];\n};\n/**\n * @hidden\n */\n\n\nconst last = arr => arr[arr.length - 1];\n\nconst getField = (field, level) => Array.isArray(field) ? field[level] || last(field) : field;\n/**\n * A directive that converts the provided hierarchical data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.\n */\n\n\nlet HierarchyBindingDirective = /*#__PURE__*/(() => {\n  class HierarchyBindingDirective extends BindingDirectiveBase {\n    constructor(menu) {\n      super(menu);\n    }\n\n    mapItems(items, level = 0) {\n      return items.map(item => {\n        const menuItem = this.createItem(item, level);\n        const children = this.getChildren(item, level);\n\n        if (children) {\n          menuItem.items = this.mapItems(children, level + 1);\n        }\n\n        return menuItem;\n      });\n    }\n\n    createItem(item, level) {\n      const result = {\n        data: item\n      };\n      const fields = this.fields;\n\n      for (let idx = 0; idx < fields.length; idx++) {\n        const {\n          target,\n          source\n        } = fields[idx];\n        result[target] = getter(getField(source, level))(item);\n      }\n\n      return result;\n    }\n\n    getChildren(item, level) {\n      if (this.childrenField) {\n        const field = getField(this.childrenField, level);\n        return item[field];\n      }\n    }\n\n  }\n\n  HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) {\n    return new (t || HierarchyBindingDirective)(i0.ɵɵdirectiveInject(MenuBase));\n  };\n\n  HierarchyBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HierarchyBindingDirective,\n    selectors: [[\"\", \"kendoMenuHierarchyBinding\", \"\"]],\n    inputs: {\n      data: [\"kendoMenuHierarchyBinding\", \"data\"],\n      textField: \"textField\",\n      urlField: \"urlField\",\n      iconField: \"iconField\",\n      disabledField: \"disabledField\",\n      cssClassField: \"cssClassField\",\n      cssStyleField: \"cssStyleField\",\n      separatorField: \"separatorField\",\n      childrenField: \"childrenField\"\n    },\n    exportAs: [\"kendoMenuHierarchyBinding\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return HierarchyBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that converts the provided flat data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.\n */\n\n\nlet FlatBindingDirective = /*#__PURE__*/(() => {\n  class FlatBindingDirective extends BindingDirectiveBase {\n    constructor(menu) {\n      super(menu);\n    }\n\n    mapItems(items) {\n      if (!this.idField || !this.parentIdField) {\n        return items.map(item => this.createItem(item));\n      }\n\n      const result = [];\n      const map = {};\n\n      for (let idx = 0; idx < items.length; idx++) {\n        const item = items[idx];\n        const menuItem = this.createItem(item);\n        const id = getter(this.idField)(item);\n        const parentId = getter(this.parentIdField)(item);\n\n        if (parentId === null || parentId === undefined) {\n          result.push(menuItem);\n        } else {\n          const parent = map[parentId] = map[parentId] || {};\n          parent.items = parent.items || [];\n          parent.items.push(menuItem);\n        }\n\n        if (map[id]) {\n          menuItem.items = map[id].items;\n        }\n\n        map[id] = menuItem;\n      }\n\n      return result;\n    }\n\n    createItem(dataItem) {\n      const result = {\n        data: dataItem\n      };\n      const fields = this.fields;\n\n      for (let idx = 0; idx < fields.length; idx++) {\n        const {\n          source,\n          target\n        } = fields[idx];\n        result[target] = getter(source)(dataItem);\n      }\n\n      return result;\n    }\n\n  }\n\n  FlatBindingDirective.ɵfac = function FlatBindingDirective_Factory(t) {\n    return new (t || FlatBindingDirective)(i0.ɵɵdirectiveInject(MenuBase));\n  };\n\n  FlatBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FlatBindingDirective,\n    selectors: [[\"\", \"kendoMenuFlatBinding\", \"\"]],\n    inputs: {\n      data: [\"kendoMenuFlatBinding\", \"data\"],\n      textField: \"textField\",\n      urlField: \"urlField\",\n      iconField: \"iconField\",\n      disabledField: \"disabledField\",\n      cssClassField: \"cssClassField\",\n      cssStyleField: \"cssStyleField\",\n      separatorField: \"separatorField\",\n      idField: \"idField\",\n      parentIdField: \"parentIdField\"\n    },\n    exportAs: [\"kendoMenuFlatBinding\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return FlatBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_EXPORTS = [MenuComponent, MenuItemComponent, ItemTemplateDirective, ItemLinkTemplateDirective, ItemContentTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, LinkDirective, ExpandArrowDirective];\nconst COMPONENT_DIRECTIVES$1 = [...COMPONENT_EXPORTS, ListComponent, ItemComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Menu component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Menu module\n * import { MenuModule } from '@progress/kendo-angular-menu';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, MenuModule], // import Menu module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet MenuModule = /*#__PURE__*/(() => {\n  class MenuModule {}\n\n  MenuModule.ɵfac = function MenuModule_Factory(t) {\n    return new (t || MenuModule)();\n  };\n\n  MenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MenuModule\n  });\n  MenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[PopupModule, CommonModule]]\n  });\n  return MenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `open` and `close` events of the ContextMenu.\n */\n\n\nclass ContextMenuEvent {}\n/**\n * Arguments for the `select` event of the ContextMenu.\n */\n\n\nclass ContextMenuSelectEvent extends ContextMenuEvent {}\n/**\n * Arguments for the `popupOpen` and `popupClose` events of the ContextMenu.\n */\n\n\nclass ContextMenuPopupEvent extends PreventableEvent {}\n/**\n * Represents a template for the content of the ContextMenu. To define a template, nest an `<ng-template>`\n * tag with the `kendoContextMenuTemplate` directive inside a `<kendo-contextmenu>` component\n * ([more information and examples]({% slug templates_contextmenu %})).\n *\n * {% meta height:200 %}\n * {% embed_file context-menu/template/app.component.ts preview %}\n * {% embed_file shared/app.module.ts %}\n * {% embed_file shared/main.ts %}\n * {% endmeta %}\n */\n\n\nlet ContextMenuTemplateDirective = /*#__PURE__*/(() => {\n  class ContextMenuTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ContextMenuTemplateDirective.ɵfac = function ContextMenuTemplateDirective_Factory(t) {\n    return new (t || ContextMenuTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ContextMenuTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ContextMenuTemplateDirective,\n    selectors: [[\"\", \"kendoContextMenuTemplate\", \"\"]]\n  });\n  return ContextMenuTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ContextMenuItemsService = /*#__PURE__*/(() => {\n  class ContextMenuItemsService {\n    constructor(contextService) {\n      this.contextService = contextService;\n    }\n\n    get(index) {\n      if (this.contextService.items) {\n        return this.contextService.items.get(index);\n      }\n    }\n\n  }\n\n  ContextMenuItemsService.ɵfac = function ContextMenuItemsService_Factory(t) {\n    return new (t || ContextMenuItemsService)(i0.ɵɵinject(ContextMenuService));\n  };\n\n  ContextMenuItemsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContextMenuItemsService,\n    factory: ContextMenuItemsService.ɵfac\n  });\n  return ContextMenuItemsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ContextMenuTargetService = /*#__PURE__*/(() => {\n  class ContextMenuTargetService {\n    constructor() {\n      this.targets = [];\n    }\n\n    add(target) {\n      this.targets.push(target);\n    }\n\n    remove(target) {\n      const index = this.targets.indexOf(target);\n      this.targets.splice(index, 1);\n    }\n\n    find(targetElement) {\n      return this.targets.find(target => target.element === targetElement);\n    }\n\n  }\n\n  ContextMenuTargetService.ɵfac = function ContextMenuTargetService_Factory(t) {\n    return new (t || ContextMenuTargetService)();\n  };\n\n  ContextMenuTargetService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContextMenuTargetService,\n    factory: ContextMenuTargetService.ɵfac\n  });\n  return ContextMenuTargetService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies a container for the [targets]({% slug api_menu_contextmenutargetdirective %}) of the ContextMenu.\n */\n\n\nlet ContextMenuTargetContainerDirective = /*#__PURE__*/(() => {\n  class ContextMenuTargetContainerDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef, targetService) {\n      this.targetService = targetService;\n\n      if (elementRef) {\n        this.element = elementRef.nativeElement;\n      }\n    }\n\n  }\n\n  ContextMenuTargetContainerDirective.ɵfac = function ContextMenuTargetContainerDirective_Factory(t) {\n    return new (t || ContextMenuTargetContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ContextMenuTargetService));\n  };\n\n  ContextMenuTargetContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ContextMenuTargetContainerDirective,\n    selectors: [[\"\", \"kendoContextMenuTargetContainer\", \"\"]],\n    exportAs: [\"kendoContextMenuTargetContainer\"],\n    features: [i0.ɵɵProvidersFeature([ContextMenuTargetService])]\n  });\n  return ContextMenuTargetContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst TARGET_CLASS = 'k-contextmenu-target';\n/**\n * Specifies a [target]({% slug api_menu_contextmenutargetdirective %}) for the ContextMenu\n * ([see example]({% slug target_contextmenu %}#toc-directives)).\n */\n\nlet ContextMenuTargetDirective = /*#__PURE__*/(() => {\n  class ContextMenuTargetDirective {\n    constructor(elementRef, targetService) {\n      this.targetService = targetService;\n      /**\n       * @hidden\n       */\n\n      this.hostClass = true;\n\n      if (elementRef) {\n        this.element = elementRef.nativeElement;\n      }\n\n      targetService.add(this);\n    }\n\n    ngOnDestroy() {\n      this.targetService.remove(this);\n    }\n\n  }\n\n  ContextMenuTargetDirective.ɵfac = function ContextMenuTargetDirective_Factory(t) {\n    return new (t || ContextMenuTargetDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ContextMenuTargetService));\n  };\n\n  ContextMenuTargetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ContextMenuTargetDirective,\n    selectors: [[\"\", \"kendoContextMenuTarget\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ContextMenuTargetDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-contextmenu-target\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      data: [\"kendoContextMenuTarget\", \"data\"]\n    },\n    exportAs: [\"kendoContextMenuTarget\"]\n  });\n  return ContextMenuTargetDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst CONTEXT_MENU = 'contextmenu';\nconst DEFAULT_ANCHOR_ALIGN = {\n  horizontal: 'left',\n  vertical: 'bottom'\n};\nconst DEFAULT_POPUP_ALIGN = {\n  horizontal: 'left',\n  vertical: 'top'\n};\nconst DEFAULT_COLLISION = {\n  horizontal: 'fit',\n  vertical: 'flip'\n};\n\nconst preventDefault = e => e.preventDefault();\n/**\n * Represents the [Kendo UI ContextMenu component for Angular]({% slug overview_contextmenu %}).\n *\n * @example\n * ```ts\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *    <div #target>\n *        Right-click to open Context menu</p>\n *    </div>\n *    <kendo-contextmenu [target]=\"target\" [items]=\"items\"> </kendo-contextmenu>\n *    `\n * })\n * class AppComponent {\n *    public items: any[] = [{ text: 'item1', items: [{ text: 'item1.1' }] }, { text: 'item2', disabled: true }];\n * }\n * ```\n */\n\n\nlet ContextMenuComponent = /*#__PURE__*/(() => {\n  class ContextMenuComponent extends MenuBase {\n    constructor(popupService, service, ngZone, renderer) {\n      super();\n      this.popupService = popupService;\n      this.service = service;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      /**\n       * Specifies the event on which the ContextMenu will open ([see example]({% slug showon_contextmenu %})).\n       * Accepts the name of a native DOM event. Defaults to `contextmenu` which opens the ContextMenu for the target element.\n       */\n\n      this.showOn = CONTEXT_MENU;\n      /**\n       * Indicates that the ContextMenu will be aligned to the target or to the `filter` element (if specified).\n       */\n\n      this.alignToAnchor = false;\n      /**\n       * Specifies if the Menu will be vertically rendered ([see example]({% slug orientation_contextmenu %})).\n       * @default true\n       */\n\n      this.vertical = true;\n      /**\n       * Fires when the Menu is opened ([see example]({% slug target_contextmenu %}#toc-changing-items-for-specified-targets)).\n       */\n\n      this.popupOpen = new EventEmitter();\n      /**\n       * Fires when the Menu is closed.\n       */\n\n      this.popupClose = new EventEmitter();\n      /**\n       * Fires when a Menu item is selected.\n       */\n\n      this.select = new EventEmitter();\n      /**\n       * Fires when a Menu item is opened.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires when a Menu item is closed.\n       */\n\n      this.close = new EventEmitter();\n      this.service.owner = this;\n      this.popupKeyDownHandler = this.popupKeyDownHandler.bind(this);\n    }\n    /**\n     * Hides the ContextMenu.\n     */\n\n\n    hide() {\n      this.removePopup();\n    }\n    /**\n     * Shows the ContextMenu for the specified target.\n     * @param target - The offset or the target element for which the ContextMenu will open.\n     */\n\n\n    show(target) {\n      if (!target) {\n        return;\n      }\n\n      const showTarget = target;\n      this.removePopup();\n\n      if (defined(showTarget.left) && defined(showTarget.top)) {\n        this.createPopup({\n          offset: showTarget\n        });\n      } else {\n        this.currentTarget = showTarget.nativeElement || showTarget;\n        this.createPopup({\n          anchor: this.currentTarget\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.target || changes.showOn) {\n        this.bindShowHandler();\n      }\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        const closeClickSubscription = this.renderer.listen('document', 'mousedown', e => {\n          if (this.popupRef && !closest(e.target, node => node === this.popupRef.popupElement) && this.service.leaveMenu(e)) {\n            this.closePopup(e);\n          }\n        });\n        const closeBlurSubscription = this.renderer.listen('window', 'blur', e => {\n          if (this.popupRef) {\n            this.closePopup(e);\n          }\n        });\n\n        this.closeSubscription = () => {\n          closeClickSubscription();\n          closeBlurSubscription();\n        };\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.closeSubscription) {\n        this.closeSubscription();\n        this.closeSubscription = null;\n      }\n\n      this.unbindShowHandler();\n      this.removePopup();\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitMenuEvent(name, args) {\n      args.target = this.currentTarget;\n      args.sender = this;\n      this[name].emit(args);\n\n      if (name === 'select' && !args.hasContent) {\n        this.closeAndFocus(args.originalEvent);\n      }\n    }\n\n    bindShowHandler() {\n      this.unbindShowHandler();\n      this.ngZone.runOutsideAngular(() => {\n        const element = this.targetElement();\n\n        if (!element) {\n          return;\n        }\n\n        const eventName = this.showOn || CONTEXT_MENU;\n        this.showSubscription = this.renderer.listen(element, this.showOn || CONTEXT_MENU, e => {\n          this.showContextMenu(e, element);\n        });\n\n        if (eventName === CONTEXT_MENU) {\n          this.keydownSubscription = this.renderer.listen(element, 'keydown', e => {\n            if (e.shiftKey && e.keyCode === Keys.F10) {\n              this.showContextMenu(e, element);\n            }\n          });\n        }\n      });\n    }\n\n    showContextMenu(e, element) {\n      const filter = this.targetFilter();\n      let currentTarget = element;\n\n      if (filter) {\n        currentTarget = findInContainer(e.target, filter, element);\n\n        if (currentTarget && currentTarget !== e.target && isFocusable(e.target)) {\n          return;\n        }\n\n        if (currentTarget && this.directiveTarget) {\n          currentTarget = this.target.targetService.find(currentTarget);\n        }\n      }\n\n      if (!currentTarget) {\n        this.closePopup(e);\n        return;\n      }\n\n      this.ngZone.run(() => {\n        if (!this.closePopup(e)) {\n          this.currentTarget = currentTarget;\n          this.openPopup(e);\n        }\n      });\n    }\n\n    unbindShowHandler() {\n      if (this.showSubscription) {\n        this.showSubscription();\n        this.showSubscription = null;\n      }\n\n      if (this.keydownSubscription) {\n        this.keydownSubscription();\n        this.keydownSubscription = null;\n      }\n    }\n\n    targetElement() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.directiveTarget = false;\n      let target = this.target;\n\n      if (typeof target === 'string') {\n        target = document.querySelector(target); // maybe querySelectorAll?\n      } else if (target && target.nativeElement) {\n        target = target.nativeElement;\n      } else if (target instanceof ContextMenuTargetContainerDirective) {\n        target = target.element;\n        this.directiveTarget = true;\n      }\n\n      return target;\n    }\n\n    targetFilter() {\n      if (this.directiveTarget) {\n        return `.${TARGET_CLASS}`;\n      }\n\n      return this.filter;\n    }\n\n    closePopup(e) {\n      if (!this.popupRef) {\n        return;\n      }\n\n      return this.popupAction('popupClose', e, () => {\n        this.removePopup();\n      });\n    }\n\n    removePopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.currentTarget = null;\n      }\n\n      if (this.popupSubscriptions) {\n        this.popupSubscriptions();\n        this.popupSubscriptions = null;\n      }\n    }\n\n    openPopup(e) {\n      this.popupAction('popupOpen', e, () => {\n        e.preventDefault();\n        let anchor, offset;\n\n        if (this.alignToAnchor || e.type === 'keydown') {\n          anchor = this.currentTargetElement;\n        } else {\n          offset = {\n            left: e.pageX,\n            top: e.pageY\n          };\n        }\n\n        this.createPopup({\n          anchor,\n          offset\n        });\n      });\n    }\n\n    createPopup(options) {\n      this.popupRef = this.popupService.open(Object.assign({\n        animate: defined(this.popupAnimate) ? this.popupAnimate : true,\n        appendTo: this.appendTo,\n        collision: this.collision || DEFAULT_COLLISION,\n        popupAlign: this.popupAlign || DEFAULT_POPUP_ALIGN,\n        anchorAlign: this.anchorAlign || DEFAULT_ANCHOR_ALIGN,\n        content: this.contentTemplate ? this.contentTemplate.templateRef : this.defaultContentTemplate,\n        popupClass: 'k-menu-popup'\n      }, options));\n      const element = this.popupRef.popupElement;\n      this.renderer.addClass(element, 'k-context-menu-popup');\n      this.renderer.setAttribute(element, 'tabindex', '-1');\n      this.renderer.setStyle(element, 'outline', '0'); //possibly move to styles\n\n      if (this.ariaLabel) {\n        this.renderer.setAttribute(element, 'aria-label', this.ariaLabel);\n      }\n\n      this.activeTarget = this.currentTargetElement === document.activeElement;\n      this.ngZone.runOutsideAngular(() => {\n        const unbindKeyDown = this.renderer.listen(element, 'keydown', this.popupKeyDownHandler);\n        const unbindContextmenu = this.renderer.listen(element, 'contextmenu', preventDefault);\n\n        this.popupSubscriptions = () => {\n          unbindKeyDown();\n          unbindContextmenu();\n        };\n      });\n      element.focus();\n    }\n\n    closeAndFocus(e) {\n      const currentTarget = this.currentTargetElement;\n\n      if (!this.closePopup(e) && this.activeTarget) {\n        currentTarget.focus();\n      }\n    }\n\n    popupKeyDownHandler(e) {\n      const element = this.popupRef.popupElement;\n\n      if (e.keyCode === Keys.Escape && (hasClass(e.target, 'k-menu-item') || e.target === element)) {\n        this.closeAndFocus(e);\n      } else if (e.target === element) {\n        this.service.keydown.emit(e);\n      }\n    }\n\n    popupAction(name, originalEvent, callback) {\n      const emitter = this[name];\n      let prevented = false;\n\n      if (hasObservers(emitter)) {\n        this.ngZone.run(() => {\n          const args = new ContextMenuPopupEvent({\n            originalEvent: originalEvent,\n            sender: this,\n            target: this.currentTarget\n          });\n          emitter.emit(args);\n\n          if (!args.isDefaultPrevented()) {\n            callback();\n          }\n\n          prevented = args.isDefaultPrevented();\n        });\n      } else {\n        callback();\n      }\n\n      return prevented;\n    }\n\n    get currentTargetElement() {\n      return this.directiveTarget && this.currentTarget ? this.currentTarget.element : this.currentTarget;\n    }\n\n  }\n\n  ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(t) {\n    return new (t || ContextMenuComponent)(i0.ɵɵdirectiveInject(i6.PopupService), i0.ɵɵdirectiveInject(ContextMenuService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ContextMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ContextMenuComponent,\n    selectors: [[\"kendo-contextmenu\"]],\n    contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ContextMenuTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n      }\n    },\n    viewQuery: function ContextMenuComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultContentTemplate = _t.first);\n      }\n    },\n    inputs: {\n      showOn: \"showOn\",\n      target: \"target\",\n      filter: \"filter\",\n      alignToAnchor: \"alignToAnchor\",\n      vertical: \"vertical\",\n      popupAnimate: \"popupAnimate\",\n      popupAlign: \"popupAlign\",\n      anchorAlign: \"anchorAlign\",\n      collision: \"collision\",\n      appendTo: \"appendTo\",\n      ariaLabel: \"ariaLabel\"\n    },\n    outputs: {\n      popupOpen: \"popupOpen\",\n      popupClose: \"popupClose\",\n      select: \"select\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoContextMenu\"],\n    features: [i0.ɵɵProvidersFeature([ContextMenuService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.contextmenu'\n    }, {\n      provide: ItemsService,\n      useClass: ContextMenuItemsService\n    }, {\n      provide: MenuBase,\n      useExisting: forwardRef(() => ContextMenuComponent)\n    }, PopupService, {\n      provide: POPUP_CONTAINER,\n      useFactory: bodyFactory\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"default\", \"\"], [3, \"items\", \"vertical\", \"openOnClick\", \"hoverDelay\", \"animate\", \"menuItemTemplate\", \"menuItemLinkTemplate\"]],\n    template: function ContextMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ContextMenuComponent_ng_template_0_Template, 1, 7, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [MenuComponent],\n    encapsulation: 2\n  });\n  return ContextMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [ContextMenuComponent, ContextMenuTemplateDirective, ContextMenuTargetDirective, ContextMenuTargetContainerDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ContextMenu component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the ContextMenu module\n * import { ContextMenuModule } from '@progress/kendo-angular-menu';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, ContextMenuModule], // import ContextMenuModule module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet ContextMenuModule = /*#__PURE__*/(() => {\n  class ContextMenuModule {}\n\n  ContextMenuModule.ɵfac = function ContextMenuModule_Factory(t) {\n    return new (t || ContextMenuModule)();\n  };\n\n  ContextMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ContextMenuModule\n  });\n  ContextMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[PopupModule, CommonModule, MenuModule], MenuModule]\n  });\n  return ContextMenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Menu and ContextMenu components and directives.\n * Imports the MenusModule into your application [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)\n * or any other sub-module that will use the Menu and ContextMenu components.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n * import { MenusModule } from '@progress/kendo-angular-menu';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, BrowserAnimationsModule, MenusModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\n\n\nlet MenusModule = /*#__PURE__*/(() => {\n  class MenusModule {}\n\n  MenusModule.ɵfac = function MenusModule_Factory(t) {\n    return new (t || MenusModule)();\n  };\n\n  MenusModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MenusModule\n  });\n  MenusModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [MenuModule, ContextMenuModule]\n  });\n  return MenusModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ContextMenuComponent, ContextMenuEvent, ContextMenuModule, ContextMenuPopupEvent, ContextMenuSelectEvent, ContextMenuService, ContextMenuTargetContainerDirective, ContextMenuTargetDirective, ContextMenuTemplateDirective, ExpandArrowDirective, FlatBindingDirective, HierarchyBindingDirective, ItemComponent, ItemContentTemplateDirective, ItemLinkTemplateDirective, ItemTemplateDirective, LinkDirective, ListComponent, MenuComponent, MenuEvent, MenuItemComponent, MenuModule, MenuSelectEvent, MenusModule };","map":null,"metadata":{},"sourceType":"module"}