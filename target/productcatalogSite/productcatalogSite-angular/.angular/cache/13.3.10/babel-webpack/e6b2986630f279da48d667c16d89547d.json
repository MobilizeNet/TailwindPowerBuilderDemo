{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport GridLinesMixin from './mixins/grid-lines-mixin';\nimport CategoryAxis from './category-axis';\nimport ShapeBuilder from './shape-builder';\nimport Ring from './ring';\nimport Box from './box';\nimport { COORD_PRECISION, ARC } from '../common/constants';\nimport { deepExtend, getSpacing, inArray, limitValue, map, rad, round, setDefaultOptions } from '../common';\n\nclass RadarCategoryAxis extends CategoryAxis {\n  range() {\n    return {\n      min: 0,\n      max: this.options.categories.length\n    };\n  }\n\n  reflow(box) {\n    this.box = box;\n    this.reflowLabels();\n  }\n\n  lineBox() {\n    return this.box;\n  }\n\n  reflowLabels() {\n    const {\n      labels,\n      options: {\n        labels: labelOptions\n      }\n    } = this;\n    const skip = labelOptions.skip || 0;\n    const step = labelOptions.step || 1;\n    const measureBox = new Box();\n\n    for (let i = 0; i < labels.length; i++) {\n      labels[i].reflow(measureBox);\n      const labelBox = labels[i].box;\n      labels[i].reflow(this.getSlot(skip + i * step).adjacentBox(0, labelBox.width(), labelBox.height()));\n    }\n  }\n\n  intervals(size, skipOption, stepOption, skipAngles = false) {\n    const options = this.options;\n    const categories = options.categories.length;\n    const divCount = categories / size || 1;\n    const divAngle = 360 / divCount;\n    const skip = skipOption || 0;\n    const step = stepOption || 1;\n    const divs = [];\n    let angle = 0;\n\n    for (let i = skip; i < divCount; i += step) {\n      if (options.reverse) {\n        angle = 360 - i * divAngle;\n      } else {\n        angle = i * divAngle;\n      }\n\n      angle = round(angle, COORD_PRECISION) % 360;\n\n      if (!(skipAngles && inArray(angle, skipAngles))) {\n        divs.push(angle);\n      }\n    }\n\n    return divs;\n  }\n\n  majorIntervals() {\n    return this.intervals(1);\n  }\n\n  minorIntervals() {\n    return this.intervals(0.5);\n  }\n\n  intervalAngle(interval) {\n    return (360 + interval + this.options.startAngle) % 360;\n  }\n\n  majorAngles() {\n    return map(this.majorIntervals(), interval => this.intervalAngle(interval));\n  }\n\n  createLine() {\n    return [];\n  }\n\n  majorGridLineAngles(altAxis) {\n    const majorGridLines = this.options.majorGridLines;\n    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n  }\n\n  minorGridLineAngles(altAxis, skipMajor) {\n    const {\n      minorGridLines,\n      majorGridLines\n    } = this.options;\n    const majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n  }\n\n  radiusCallback(radius, altAxis, skipMajor) {\n    if (altAxis.options.type !== ARC) {\n      const minorAngle = rad(360 / (this.options.categories.length * 2));\n      const minorRadius = Math.cos(minorAngle) * radius;\n      const majorAngles = this.majorAngles();\n\n      const radiusCallback = function (angle) {\n        if (!skipMajor && inArray(angle, majorAngles)) {\n          return radius;\n        }\n\n        return minorRadius;\n      };\n\n      return radiusCallback;\n    }\n  }\n\n  createPlotBands() {\n    const plotBands = this.options.plotBands || [];\n    const group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n\n    for (let i = 0; i < plotBands.length; i++) {\n      const band = plotBands[i];\n      const slot = this.plotBandSlot(band);\n      const singleSlot = this.getSlot(band.from);\n      const head = band.from - Math.floor(band.from);\n      slot.startAngle += head * singleSlot.angle;\n      const tail = Math.ceil(band.to) - band.to;\n      slot.angle -= (tail + head) * singleSlot.angle;\n      const ring = ShapeBuilder.current.createRing(slot, {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      });\n      group.append(ring);\n    }\n\n    this.appendVisual(group);\n  }\n\n  plotBandSlot(band) {\n    return this.getSlot(band.from, band.to - 1);\n  }\n\n  getSlot(from, to) {\n    const options = this.options;\n    const justified = options.justified;\n    const box = this.box;\n    const divs = this.majorAngles();\n    const totalDivs = divs.length;\n    const slotAngle = 360 / totalDivs;\n    let fromValue = from;\n\n    if (options.reverse && !justified) {\n      fromValue = (fromValue + 1) % totalDivs;\n    }\n\n    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n    let slotStart = divs[fromValue];\n\n    if (justified) {\n      slotStart = slotStart - slotAngle / 2;\n\n      if (slotStart < 0) {\n        slotStart += 360;\n      }\n    }\n\n    const toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n    const slots = toValue - fromValue + 1;\n    const angle = slotAngle * slots;\n    return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n  }\n\n  slot(from, to) {\n    const slot = this.getSlot(from, to);\n    const startAngle = slot.startAngle + 180;\n    const endAngle = startAngle + slot.angle;\n    return new geom.Arc([slot.center.x, slot.center.y], {\n      startAngle: startAngle,\n      endAngle: endAngle,\n      radiusX: slot.radius,\n      radiusY: slot.radius\n    });\n  }\n\n  pointCategoryIndex(point) {\n    const length = this.options.categories.length;\n    let index = null;\n\n    for (let i = 0; i < length; i++) {\n      const slot = this.getSlot(i);\n\n      if (slot.containsPoint(point)) {\n        index = i;\n        break;\n      }\n    }\n\n    return index;\n  }\n\n}\n\nsetDefaultOptions(RadarCategoryAxis, {\n  startAngle: 90,\n  labels: {\n    margin: getSpacing(10)\n  },\n  majorGridLines: {\n    visible: true\n  },\n  justified: true\n});\ndeepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\nexport default RadarCategoryAxis;","map":null,"metadata":{},"sourceType":"module"}