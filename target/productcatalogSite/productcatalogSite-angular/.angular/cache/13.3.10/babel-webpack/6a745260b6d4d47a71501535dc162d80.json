{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, limitValue } from '../../common';\nimport { ANGULAR_SPEED, DEGREE, DEFAULT_LINE_WIDTH, RADIAL_POINTER } from '../constants';\nimport Pointer from '../pointer';\nimport RadialPointerAnimation from './radial-pointer-animation';\nconst CAP_SIZE = 0.05;\nconst {\n  Circle,\n  Group,\n  Path\n} = drawing;\n\nclass RadialPointer extends Pointer {\n  setAngle(angle) {\n    this.elements.transform(geo.transform().rotate(angle, this.center));\n  }\n\n  repaint() {\n    const {\n      scale,\n      options\n    } = this;\n    const oldAngle = scale.slotAngle(options._oldValue);\n    const newAngle = scale.slotAngle(options.value);\n\n    if (options.animation.transitions === false) {\n      this.setAngle(newAngle);\n    } else {\n      new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n        oldAngle: oldAngle,\n        newAngle: newAngle\n      })).play();\n    }\n  }\n\n  render() {\n    const {\n      scale,\n      options\n    } = this;\n    const elements = new Group();\n\n    if (options.animation !== false) {\n      deepExtend(options.animation, {\n        startAngle: 0,\n        center: scale.arc.center,\n        reverse: scale.options.reverse\n      });\n    }\n\n    elements.append(this._renderNeedle(), this._renderCap());\n    this.elements = elements;\n    this.setAngle(DEGREE);\n    return elements;\n  }\n\n  reflow(arc) {\n    const center = this.center = arc.center;\n    const length = limitValue(this.options.length || 1, 0.1, 1.5);\n    const radius = this.radius = arc.getRadiusX() * length;\n    const capSize = this.capSize = Math.round(radius * this.options.cap.size);\n    this.bbox = geo.Rect.fromPoints(new geo.Point(center.x - capSize, center.y - capSize), new geo.Point(center.x + capSize, center.y + capSize));\n  }\n\n  _renderNeedle() {\n    const minorTickSize = this.scale.options.minorTicks.size;\n    const center = this.center;\n    const needleColor = this.options.color;\n    const needlePath = new Path({\n      fill: {\n        color: needleColor\n      },\n      stroke: {\n        color: needleColor,\n        width: DEFAULT_LINE_WIDTH\n      }\n    });\n    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();\n    return needlePath;\n  }\n\n  _renderCap() {\n    const options = this.options;\n    const capColor = options.cap.color || options.color;\n    const circle = new geo.Circle(this.center, this.capSize);\n    const cap = new Circle(circle, {\n      fill: {\n        color: capColor\n      },\n      stroke: {\n        color: capColor\n      }\n    });\n    return cap;\n  }\n\n}\n\nsetDefaultOptions(RadialPointer, {\n  cap: {\n    size: CAP_SIZE\n  },\n  arrow: {\n    width: 16,\n    height: 14\n  },\n  animation: {\n    type: RADIAL_POINTER,\n    duration: ANGULAR_SPEED\n  }\n});\nexport default RadialPointer;","map":null,"metadata":{},"sourceType":"module"}