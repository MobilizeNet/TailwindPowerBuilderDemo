{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1005);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  997:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./formatblock\");\n    /***/\n  },\n\n  /***/\n  1005:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(997), __webpack_require__(1006)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            dom = Editor.Dom,\n            EditorUtils = Editor.EditorUtils,\n            RangeUtils = Editor.RangeUtils,\n            Command = Editor.Command,\n            NS = \"kendoEditor\",\n            ACTIVESTATE = \"k-state-active\",\n            SELECTEDSTATE = \"k-state-selected\",\n            SCOPE = \"scope\",\n            ROW = \"row\",\n            COL = \"col\",\n            ROWGROUP = \"rowgroup\",\n            COLGROUP = \"colgroup\",\n            COLSPAN = \"colspan\",\n            ROWSPAN = \"rowspan\",\n            TABLE = \"table\",\n            THEAD = \"thead\",\n            TBODY = \"tbody\",\n            TR = \"tr\",\n            TD = \"td\",\n            TH = \"th\",\n            Tool = Editor.Tool,\n            ToolTemplate = Editor.ToolTemplate,\n            InsertHtmlCommand = Editor.InsertHtmlCommand,\n            BlockFormatFinder = Editor.BlockFormatFinder,\n            BlockFormatTool = Editor.BlockFormatTool,\n            FormatCommand = Editor.FormatCommand,\n            registerTool = Editor.EditorUtils.registerTool,\n            registerFormat = Editor.EditorUtils.registerFormat,\n            formats = kendo.ui.Editor.fn.options.formats,\n            getTouches = kendo.getTouches;\n        var template = kendo.template;\n        var columnTemplate = \"<td style='width:#=width#%;'>#=content#</td>\";\n        var tableFormatFinder = new BlockFormatFinder([{\n          tags: [TABLE]\n        }]);\n        var TableCommand = InsertHtmlCommand.extend({\n          init: function (options) {\n            var o = $.extend({\n              postProcess: this.postProcess,\n              skipCleaners: true\n            }, options || {});\n            InsertHtmlCommand.fn.init.call(this, o);\n          },\n          _tableHtml: function (rows, columns) {\n            rows = rows || 1;\n            columns = columns || 1;\n            var columnHtml = template(columnTemplate)({\n              width: 100 / columns,\n              content: Editor.emptyTableCellContent\n            });\n            var rowHeight = 100 / rows;\n            return \"<table class='k-table' data-last>\" + new Array(rows + 1).join(\"<tr style='height:\" + rowHeight + \"%;'>\" + new Array(columns + 1).join(columnHtml) + \"</tr>\") + \"</table>\";\n          },\n          postProcess: function (editor, range) {\n            var insertedTable = $(\"table[data-last]\", editor.document).removeAttr(\"data-last\");\n            range.setStart(insertedTable.find(TD)[0], 0);\n            range.collapse(true);\n            editor.selectRange(range);\n          },\n          exec: function () {\n            var options = this.options;\n            options.html = this._tableHtml(options.rows, options.columns);\n            InsertHtmlCommand.fn.exec.call(this);\n          }\n        });\n        var PopupTool = Tool.extend({\n          initialize: function (ui, options) {\n            Tool.fn.initialize.call(this, ui, options);\n            var popup = $(this.options.popupTemplate).appendTo(\"body\").kendoPopup({\n              anchor: ui,\n              copyAnchorStyles: false,\n              open: this._open.bind(this),\n              activate: this._activate.bind(this),\n              close: this._close.bind(this)\n            }).data(\"kendoPopup\");\n            ui.on(\"click\", this._toggle.bind(this)).on(\"keydown\", this._keydown.bind(this));\n            var editor = this._editor = options.editor;\n            this._popup = popup;\n            var tableWizard = new Editor.TableWizardTool({\n              template: new ToolTemplate({\n                template: EditorUtils.tableWizardButtonTemplate,\n                title: editor.options.messages.tableWizard\n              }),\n              command: Editor.TableWizardCommand,\n              insertNewTable: true\n            });\n            registerTool(\"tableWizardInsert\", tableWizard);\n            var twTool = $(\"<div>\" + tableWizard.options.template.getHtml() + \"</div>\");\n            twTool.appendTo(popup.element);\n\n            if (editor.toolbar) {\n              editor.toolbar.attachToolsEvents(twTool);\n            }\n          },\n          popup: function () {\n            return this._popup;\n          },\n          _activate: $.noop,\n          _open: function () {\n            this._popup.options.anchor.addClass(ACTIVESTATE);\n          },\n          _close: function () {\n            this._popup.options.anchor.removeClass(ACTIVESTATE);\n          },\n          _keydown: function (e) {\n            var that = this,\n                keys = kendo.keys,\n                key = e.keyCode,\n                shouldContinue = true;\n\n            if (key == keys.DOWN && e.altKey || key == keys.ENTER || key == keys.SPACEBAR) {\n              that._popup.open();\n\n              shouldContinue = false;\n            } else if (key == keys.ESC) {\n              that._popup.close();\n            }\n          },\n          _toggle: function (e) {\n            var button = $(e.target).closest(\".k-tool\");\n\n            if (!button.hasClass(\"k-disabled\")) {\n              this.popup().toggle();\n            }\n          },\n          update: function (ui) {\n            var popup = this.popup();\n\n            if (popup.wrapper && popup.wrapper.css(\"display\") == \"block\") {\n              popup.close();\n            }\n\n            ui.removeClass(\"k-hover\");\n          },\n          destroy: function () {\n            this._popup.destroy();\n          }\n        });\n        var InsertTableTool = PopupTool.extend({\n          init: function (options) {\n            this.cols = 8;\n            this.rows = 6;\n            PopupTool.fn.init.call(this, $.extend(options, {\n              command: TableCommand,\n              popupTemplate: \"<div class='k-ct-popup'>\" + \"<div>\" + new Array(this.cols * this.rows + 1).join(\"<span class='k-ct-cell k-state-disabled'></span>\") + \"</div>\" + \"<div class='k-status'></div>\" + \"</div>\"\n            }));\n          },\n          _activate: function () {\n            var that = this,\n                element = that._popup.element,\n                cells = element.find(\".k-ct-cell\"),\n                firstCell = cells.eq(0),\n                lastCell = cells.eq(cells.length - 1),\n                start = kendo.getOffset(firstCell),\n                end = kendo.getOffset(lastCell),\n                cols = that.cols,\n                rows = that.rows,\n                cellWidth,\n                cellHeight;\n            element.find(\"*\").addBack().attr(\"unselectable\", \"on\");\n            end.left += lastCell[0].offsetWidth;\n            end.top += lastCell[0].offsetHeight;\n            cellWidth = (end.left - start.left) / cols;\n            cellHeight = (end.top - start.top) / rows;\n\n            function tableFromLocation(e) {\n              var w = $(window);\n              return {\n                row: Math.floor((e.clientY + w.scrollTop() - start.top) / cellHeight) + 1,\n                col: Math.floor((e.clientX + w.scrollLeft() - start.left) / cellWidth) + 1\n              };\n            }\n\n            element.autoApplyNS(NS).on(\"mousemove\", \".k-ct-cell\", function (e) {\n              that._setTableSize(tableFromLocation(e));\n            }).on(\"mouseleave\", \".k-ct-cell\", function () {\n              that._setTableSize();\n            }).on(\"down\", \".k-ct-cell\", function (e) {\n              e.preventDefault();\n              var touch = getTouches(e)[0];\n\n              that._exec(tableFromLocation(touch.location));\n            });\n          },\n          _valid: function (size) {\n            return size && size.row > 0 && size.col > 0 && size.row <= this.rows && size.col <= this.cols;\n          },\n          _exec: function (size) {\n            if (this._valid(size)) {\n              this._editor.exec(\"createTable\", {\n                rows: size.row,\n                columns: size.col\n              });\n\n              this._popup.close();\n            }\n          },\n          _setTableSize: function (size) {\n            var element = this._popup.element;\n            var status = element.find(\".k-status\");\n            var cells = element.find(\".k-ct-cell\");\n            var cols = this.cols;\n            var messages = this._editor.options.messages;\n\n            if (this._valid(size)) {\n              status.text(kendo.format(messages.createTableHint, size.row, size.col));\n              cells.each(function (i) {\n                $(this).toggleClass(SELECTEDSTATE, i % cols < size.col && i / cols < size.row);\n              });\n            } else {\n              status.text(messages.createTable);\n              cells.removeClass(SELECTEDSTATE);\n            }\n          },\n          _keydown: function (e) {\n            var initiallyVisible = this._popup.visible();\n\n            PopupTool.fn._keydown.call(this, e);\n\n            if (!this._popup.visible()) {\n              return;\n            }\n\n            var keys = kendo.keys;\n            var key = e.keyCode;\n\n            var cells = this._popup.element.find(\".k-ct-cell\");\n\n            var focus = Math.max(cells.filter(\".k-state-selected\").last().index(), 0);\n            var selectedRows = Math.floor(focus / this.cols);\n            var selectedColumns = focus % this.cols;\n            var changed = false,\n                button;\n\n            if (key == keys.DOWN && !e.altKey) {\n              changed = true;\n              selectedRows++;\n            } else if (key == keys.UP) {\n              changed = true;\n              selectedRows--;\n            } else if (key == keys.RIGHT) {\n              changed = true;\n              selectedColumns++;\n            } else if (key == keys.LEFT) {\n              changed = true;\n              selectedColumns--;\n            } else if (key == keys.TAB) {\n              button = this._popup.element.find(\".k-button\");\n\n              if (button.length > 0) {\n                changed = true;\n                button.trigger(\"focus\");\n              }\n            }\n\n            var tableSize = {\n              row: Math.max(1, Math.min(this.rows, selectedRows + 1)),\n              col: Math.max(1, Math.min(this.cols, selectedColumns + 1))\n            };\n\n            if (key == keys.ENTER && initiallyVisible) {\n              this._exec(tableSize);\n            } else {\n              this._setTableSize(tableSize);\n            }\n\n            if (changed) {\n              e.preventDefault();\n              e.stopImmediatePropagation();\n            }\n          },\n          _open: function () {\n            var messages = this._editor.options.messages;\n\n            PopupTool.fn._open.call(this);\n\n            this.popup().element.find(\".k-status\").text(messages.createTable).end().find(\".k-ct-cell\").removeClass(SELECTEDSTATE);\n          },\n          _close: function () {\n            PopupTool.fn._close.call(this);\n\n            this.popup().element.off(\".\" + NS);\n          }\n        });\n        var TableModificationCommand = Command.extend({\n          undo: function () {\n            var point = this.restorePoint;\n            point.restoreHtml();\n            $(this.editor.body).find(\".k-element-resize-handle-wrapper\").each(function (index, el) {\n              el.remove();\n            });\n            this.editor.selectRange(point.toRange());\n          },\n          _clearColIndexAttr: function (table) {\n            dom.clearTableMappings(table, \"col-index\");\n          },\n          _mapColIndices: function (table) {\n            dom.reMapTableColumns(table, \"col-index\");\n          },\n          _findRowSpanCell: function (parent, rowIndex, colIndex) {\n            var row, cell;\n\n            for (var i = rowIndex; i >= 0; i--) {\n              row = parent.rows[i];\n              cell = $(row).find(\"[col-index=\" + colIndex + \"]\");\n\n              if (cell.length) {\n                return cell;\n              }\n            }\n          },\n          _resetElementResizing: function (editor) {\n            editor._destroyResizings();\n\n            editor._initializeColumnResizing();\n\n            editor._initializeRowResizing();\n\n            editor._initializeElementResizing();\n          },\n          _findNextTdInRow: function (row, colIndex) {\n            var lastTd = row.find(\"td:last-child\"),\n                lastIndex = parseInt(lastTd.attr(\"col-index\"), 10) + lastTd.prop(\"colSpan\") - 1,\n                td;\n\n            for (var i = colIndex; i <= lastIndex; i++) {\n              td = row.find(\"[col-index=\" + i + \"]\");\n\n              if (td.length) {\n                return td;\n              }\n            }\n          },\n          _adjustColgroups: function (row, table) {\n            var colElements = table.getElementsByTagName(COL),\n                colgroupElements = table.getElementsByTagName(COLGROUP),\n                cells = row.cells,\n                numberOfCells = cells.length,\n                i,\n                colgroup,\n                cell;\n\n            while (colElements.length > 0) {\n              colElements[0].remove();\n            }\n\n            while (colgroupElements.length > 0) {\n              colgroupElements[0].remove();\n            }\n\n            for (i = numberOfCells - 1; i >= 0; i--) {\n              cell = cells[i];\n\n              if (cell.getAttribute(SCOPE) === COLGROUP) {\n                colgroup = dom.createEmptyNode(this.editor.document, COLGROUP);\n                colgroup.setAttribute(\"span\", cell.getAttribute(COLSPAN));\n                table.prepend(colgroup);\n              } else {\n                table.prepend(dom.createEmptyNode(this.editor.document, COL));\n              }\n            }\n          },\n          _associateHeaderIds: function (table) {\n            dom.clearTableMappings(table, \"col-index\");\n            dom.reMapTableColumns(table, \"col-index\");\n            $(table).find(\"th, td\").removeAttr(\"id headers\");\n            dom.associateWithIds(table);\n          },\n          _getNumberOfColumns: function (table) {\n            return dom._getNumberOfColumns(table, \"td, th\");\n          }\n        });\n        var InsertRowCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(true),\n                td = dom.closest(range.endContainer, [TD, TH]),\n                table = dom.closest(td, TABLE),\n                position = this.options.position || \"after\",\n                cellCount,\n                row,\n                cell,\n                newRow,\n                rowIndex,\n                rowSpanIndex,\n                createdCell;\n\n            if (!table || this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            this._mapColIndices(table);\n\n            row = td.parentNode;\n            rowIndex = dom.findNodeIndex(row, true);\n\n            if (td.rowSpan > 1 && position === \"after\") {\n              row = table.rows[rowIndex + td.rowSpan - 1];\n            }\n\n            cellCount = this._getNumberOfColumns(table);\n            newRow = row.cloneNode(true);\n            $(newRow).empty();\n\n            for (var i = 0; i < cellCount; i = i + cell.prop(\"colSpan\")) {\n              cell = $(row).find(\"[col-index=\" + i + \"]\");\n\n              if (cell.length) {\n                if (cell.prop(\"rowSpan\") > 1 && position === \"after\" && cell) {\n                  cell.attr(ROWSPAN, cell.prop(\"rowSpan\") + 1);\n                } else {\n                  this._appendCell(newRow, cell);\n                }\n              } else {\n                rowIndex = dom.findNodeIndex(row, true);\n                cell = this._findRowSpanCell(row.parentElement, rowIndex, i);\n                rowSpanIndex = cell.closest(TR).index();\n\n                if (rowSpanIndex + cell.prop(\"rowSpan\") - 1 === rowIndex && position === \"after\") {\n                  this._appendCell(newRow, cell);\n                } else {\n                  cell.attr(ROWSPAN, cell.prop(\"rowSpan\") + 1);\n                }\n              }\n\n              createdCell = $(newRow).find(\"[col-index=\" + i + \"]\");\n\n              if (createdCell.attr(SCOPE) === ROWGROUP && !createdCell.attr(ROWSPAN)) {\n                createdCell.attr(SCOPE, ROW);\n              }\n            }\n\n            if (position == \"before\") {\n              dom.insertBefore(newRow, row);\n            } else {\n              dom.insertAfter(newRow, row);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            this._clearColIndexAttr(table);\n\n            this.releaseRange(range);\n\n            this._resetElementResizing(this.editor);\n          },\n          _appendCell: function (row, cell) {\n            var newCell;\n            newCell = cell.clone();\n            newCell.html(Editor.emptyTableCellContent);\n            newCell.removeAttr(ROWSPAN);\n            newCell.appendTo(row);\n          }\n        });\n        var InsertColumnCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(true),\n                td = dom.closest(range.endContainer, [TD, TH]),\n                table = dom.closest(td, TABLE),\n                colElements = table.getElementsByTagName(COL),\n                colgroupElements = table.getElementsByTagName(COLGROUP),\n                columnIndex,\n                i,\n                rows = table && table.rows,\n                cell,\n                newCell,\n                position = this.options.position || \"after\";\n\n            if (!td || this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            this._mapColIndices(table);\n\n            columnIndex = parseInt(td.getAttribute(\"col-index\"), 10);\n\n            if (td.colSpan > 1 && position === \"after\") {\n              td.setAttribute(\"col-index\", columnIndex + td.colSpan - 1);\n              columnIndex = columnIndex + td.colSpan - 1;\n            }\n\n            for (i = 0; i < rows.length; i++) {\n              cell = this._processForColSpan(rows[i], columnIndex, position, td);\n\n              if (!cell) {\n                continue;\n              }\n\n              newCell = cell.cloneNode();\n              newCell.innerHTML = Editor.emptyTableCellContent;\n              newCell.removeAttribute(COLSPAN);\n\n              if (newCell.getAttribute(SCOPE) && newCell.getAttribute(SCOPE) === COLGROUP) {\n                newCell.setAttribute(SCOPE, COL);\n              }\n\n              if (position == \"before\") {\n                dom.insertBefore(newCell, cell);\n              } else {\n                dom.insertAfter(newCell, cell);\n              }\n\n              this._resizeCells(newCell, cell);\n            }\n\n            if (colElements.length > 0 || colgroupElements.length > 0) {\n              this._adjustColgroups(rows[0], table);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            this._clearColIndexAttr(table);\n\n            this.releaseRange(range);\n\n            this._resetElementResizing(this.editor);\n          },\n          _processForColSpan: function (row, columnIndex, position, selectedCell) {\n            var cell,\n                colSpanEffect,\n                index = columnIndex - 1;\n            cell = $(row).find(\"[col-index=\" + columnIndex + \"]\")[0];\n\n            if (cell && cell.colSpan > 1 && position === \"after\" && cell !== selectedCell) {\n              cell.colSpan += 1;\n              return;\n            }\n\n            if (cell) {\n              return cell;\n            }\n\n            for (index; index >= 0; index--) {\n              cell = $(row).find(\"[col-index=\" + index + \"]\")[0];\n\n              if (cell && cell.colSpan > 1) {\n                break;\n              }\n            }\n\n            if (!cell) {\n              return;\n            }\n\n            colSpanEffect = parseInt(cell.getAttribute(\"col-index\"), 10) + cell.colSpan - 1;\n\n            if (colSpanEffect === columnIndex && position === \"after\") {\n              return cell;\n            } else if (columnIndex <= colSpanEffect) {\n              cell.setAttribute(COLSPAN, cell.colSpan + 1);\n            }\n          },\n          _resizeCells: function (newCell, cell) {\n            var width = newCell.style.width,\n                parsedWidth,\n                unit,\n                calculatedWidth;\n\n            if (!width) {\n              return;\n            }\n\n            parsedWidth = parseFloat(width);\n            unit = width.slice(parsedWidth.toString().length);\n            calculatedWidth = parsedWidth / 2 + unit;\n            newCell.style.width = calculatedWidth;\n            cell.style.width = calculatedWidth;\n          }\n        });\n        var DeleteRowCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange();\n            var rows = RangeUtils.mapAll(range, function (node) {\n              return $(node).closest(TR)[0];\n            });\n            var td = dom.closest(range.endContainer, [TD, TH]);\n            var row = rows[0];\n            var rowSpan = td ? td.rowSpan : 1;\n            var rowIndex = $(rows[0]).index();\n            var table = dom.closest(row, TABLE);\n            var rowParent = row.parentElement;\n            var focusElement;\n\n            if (!table || this.immutables() && Editor.Immutables.immutableParent(row)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            for (var x = 0; x < rowSpan; x++) {\n              if (rows.indexOf(rowParent.rows[rowIndex + x]) < 0) {\n                rows.push(rowParent.rows[rowIndex + x]);\n              }\n            }\n\n            if (table.rows.length <= rows.length) {\n              focusElement = dom.next(table);\n\n              if (!focusElement || dom.insignificant(focusElement)) {\n                focusElement = dom.prev(table);\n              }\n\n              if (focusElement && focusElement.rows) {\n                focusElement = focusElement.rows[0].cells[0];\n              }\n\n              dom.remove(table);\n\n              this._resetElementResizing(this.editor);\n            } else if (rowParent.rows.length <= rows.length) {\n              focusElement = rowParent.nextSibling;\n\n              if (!focusElement) {\n                focusElement = rowParent.previousSibling;\n              }\n\n              dom.remove(rowParent);\n            } else {\n              this._mapColIndices(table);\n\n              for (var i = 0; i < rows.length; i++) {\n                row = rows[i];\n                dom.removeTextSiblings(row);\n                focusElement = dom.next(row) || dom.prev(row);\n                focusElement = focusElement.cells[0]; // IE needs to focus the new row before removing the old one\n\n                this._focusElement(range, focusElement);\n\n                focusElement = null;\n\n                this._handleRowSpanCells(table, row);\n\n                dom.remove(row);\n              }\n\n              this._clearColIndexAttr(table);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            } else if (dom.is(rowParent, THEAD) && $(table).find(\"[scope]\").length > 0) {\n              this._adjustColgroups(rowParent.rows[0], table);\n            }\n\n            if (focusElement) {\n              this._focusElement(range, focusElement);\n            }\n\n            this._resetElementResizing(this.editor);\n          },\n          _focusElement: function (range, node) {\n            range.setStart(node, 0);\n            range.collapse(true);\n            this.editor.selectRange(range);\n          },\n          _handleRowSpanCells: function (table, row) {\n            var index,\n                cell,\n                adjacentCell,\n                nextRow,\n                rowIndex = dom.findNodeIndex(row, true),\n                firstRow = table.rows[0],\n                lastCell = firstRow.cells[firstRow.cells.length - 1],\n                lastIndex = parseInt(lastCell.getAttribute(\"col-index\"), 10) + lastCell.colSpan - 1;\n\n            for (index = 0; index <= lastIndex; index = index + cell.prop(\"colSpan\")) {\n              cell = $(row).find(\"[col-index=\" + index + \"]\");\n\n              if (cell.length && cell.prop(\"rowSpan\") > 1) {\n                nextRow = table.rows[rowIndex + 1];\n                adjacentCell = $(nextRow).find(\"[col-index=\" + (index + 1) + \"]\");\n\n                if (adjacentCell.length) {\n                  adjacentCell.before(cell);\n                } else {\n                  $(nextRow).append(cell);\n                }\n\n                this._reduceRowSpan(cell);\n              }\n\n              if (!cell.length) {\n                cell = this._findRowSpanCell(row.parentElement, rowIndex, index);\n\n                this._reduceRowSpan(cell);\n              }\n            }\n          },\n          _reduceRowSpan: function (td) {\n            var rowSpanValue = td.prop(\"rowSpan\") - 1;\n\n            if (rowSpanValue <= 1) {\n              td.removeAttr(ROWSPAN);\n\n              if (td.attr(SCOPE) === ROWGROUP) {\n                td.attr(SCOPE, ROW);\n              }\n            } else {\n              td.attr(ROWSPAN, rowSpanValue);\n            }\n          }\n        });\n        var DeleteColumnCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(),\n                td = dom.closest(range.endContainer, [TD, TH]),\n                table = dom.closest(td, TABLE),\n                rows = table && table.rows,\n                columnIndex = dom.findNodeIndex(td, true),\n                columnCount = rows && rows[0].cells.length,\n                colElements = table.getElementsByTagName(COL),\n                colgroupElements = table.getElementsByTagName(COLGROUP),\n                focusElement,\n                i,\n                cell,\n                x;\n\n            if (!td || this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            if (columnCount == 1 || td.colSpan == columnCount) {\n              focusElement = dom.next(table);\n\n              if (!focusElement || dom.insignificant(focusElement)) {\n                focusElement = dom.prev(table);\n              }\n\n              if (focusElement && focusElement.rows) {\n                focusElement = focusElement.rows[0].cells[0];\n              }\n\n              dom.remove(table);\n\n              this._resetElementResizing(this.editor);\n            } else {\n              dom.removeTextSiblings(td);\n              focusElement = dom.next(td) || dom.prev(td);\n\n              this._mapColIndices(table);\n\n              columnIndex = parseInt(td.getAttribute(\"col-index\"), 10);\n\n              for (x = 0; x < td.colSpan; x++) {\n                for (i = 0; i < rows.length; i = i + (cell.prop(\"rowSpan\") || 1)) {\n                  cell = $(rows[i]).find(\"[col-index=\" + (columnIndex + x) + \"]\");\n\n                  if (cell.length && cell.prop(\"colSpan\") <= 1) {\n                    cell.remove();\n                  } else {\n                    this._handleColSpanCells(rows[i], columnIndex + x);\n                  }\n                }\n              }\n\n              this._clearColIndexAttr(table);\n            }\n\n            if (colElements.length > 0 || colgroupElements.length > 0) {\n              this._adjustColgroups(rows[0], table);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            if (focusElement) {\n              range.setStart(focusElement, 0);\n              range.collapse(true);\n              this.editor.selectRange(range);\n            }\n\n            this._resetElementResizing(this.editor);\n          },\n          _handleColSpanCells: function (row, colIndex) {\n            var cell = $(row).find(\"[col-index=\" + colIndex + \"]\");\n\n            if (cell.length && cell.prop(\"colSpan\") > 1) {\n              var clone = cell.clone(true);\n              cell.after(clone);\n\n              this._reduceColSpan(clone);\n\n              clone.attr(\"col-index\", parseInt(cell.attr(\"col-index\"), 10) + 1);\n              cell.remove();\n              return;\n            }\n\n            for (var i = colIndex; i >= 0; i--) {\n              cell = $(row).find(\"[col-index=\" + i + \"]\");\n\n              if (cell.length) {\n                this._reduceColSpan(cell);\n\n                cell.attr(\"col-index\", parseInt(cell.attr(\"col-index\"), 10) + 1);\n                return;\n              }\n            }\n          },\n          _reduceColSpan: function (td) {\n            var colSpanValue = td.prop(\"colSpan\") - 1;\n\n            if (colSpanValue <= 1) {\n              td.removeAttr(COLSPAN);\n\n              if (td.attr(SCOPE) === COLGROUP) {\n                td.attr(SCOPE, COL);\n              }\n            } else {\n              td.attr(COLSPAN, colSpanValue);\n            }\n          }\n        });\n        var MergeCellsHorizontallyCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(),\n                td = dom.closest(range.endContainer, [TD, TH]),\n                table,\n                row,\n                columnIndex,\n                nextTd,\n                colspan;\n\n            if (!td) {\n              this.releaseRange(range);\n              return;\n            }\n\n            table = dom.closest(td, TABLE);\n            row = td.parentNode;\n            columnIndex = dom.findNodeIndex(td, true);\n            nextTd = row.children[columnIndex + 1];\n\n            if (this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            this._mapColIndices(table);\n\n            columnIndex = parseInt($(td).attr(\"col-index\"), 10);\n            nextTd = $(row).find(\"[col-index=\" + (columnIndex + 1 + this._getColspan(td) - 1) + \"]\").get(0);\n\n            if (!nextTd || nextTd.rowSpan !== td.rowSpan || td.tagName !== nextTd.tagName) {\n              this._clearColIndexAttr(table);\n\n              this.releaseRange(range);\n              return;\n            }\n\n            colspan = this._getColspan(td) + this._getColspan(nextTd);\n            $(td).prop(COLSPAN, colspan).append(dom.emptyNode(nextTd) ? \"\" : \"<br/>\" + nextTd.innerHTML);\n            $(td).width(td.offsetWidth);\n            $(nextTd).remove();\n\n            if (td.getAttribute(SCOPE) === COL) {\n              td.setAttribute(SCOPE, COLGROUP);\n            }\n\n            if (td.getAttribute(SCOPE) === COLGROUP) {\n              this._adjustColgroups(row, table);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            this._clearColIndexAttr(table);\n\n            this.releaseRange(range);\n\n            this._resetElementResizing(this.editor);\n          },\n          _getColspan: function (td) {\n            return parseInt(td.getAttribute(COLSPAN), 10) || 1;\n          }\n        });\n        var MergeCellsVerticallyCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(),\n                td = dom.closest(range.endContainer, [TD, TH]),\n                tr,\n                parent,\n                table,\n                columnIndex,\n                rowIndex,\n                targetRow,\n                bottomTd;\n\n            if (!td) {\n              this.releaseRange(range);\n              return;\n            }\n\n            tr = dom.closest(td, TR);\n            parent = dom.closest(td, [THEAD, TBODY]);\n            table = dom.closest(td, TABLE);\n            columnIndex = dom.findNodeIndex(td, true);\n            rowIndex = dom.findNodeIndex(tr, true);\n\n            if (rowIndex + 1 === parent.rows.length) {\n              this.releaseRange(range);\n              return;\n            }\n\n            targetRow = parent.rows[rowIndex + this._getRowspan(td)];\n            bottomTd = targetRow && targetRow.children[columnIndex];\n\n            if (this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            this._mapColIndices(table);\n\n            columnIndex = $(td).attr(\"col-index\");\n            bottomTd = $(targetRow).find(\"[col-index=\" + columnIndex + \"]\").get(0);\n\n            if (!bottomTd || bottomTd.colSpan !== td.colSpan || td.tagName !== bottomTd.tagName) {\n              this._clearColIndexAttr(table);\n\n              this.releaseRange(range);\n              return;\n            }\n\n            $(td).prop(ROWSPAN, this._getRowspan(td) + this._getRowspan(bottomTd)).append(dom.emptyNode(bottomTd) ? \"\" : \"<br/>\" + bottomTd.innerHTML);\n\n            if (td.getAttribute(SCOPE) === ROW) {\n              td.setAttribute(SCOPE, ROWGROUP);\n            }\n\n            $(bottomTd).remove();\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            this._clearColIndexAttr(table);\n\n            this.releaseRange(range);\n          },\n          _getRowspan: function (td) {\n            return parseInt(td.getAttribute(ROWSPAN), 10) || 1;\n          }\n        });\n        var SplitCellCommand = TableModificationCommand.extend({\n          exec: function () {\n            var range = this.lockRange(),\n                type = this.options.type,\n                attr = type === \"row\" ? COLSPAN : ROWSPAN,\n                td = dom.closest(range.endContainer, [TD, TH]),\n                parent = dom.closest(td, [THEAD, TBODY]),\n                table = dom.closest(td, TABLE),\n                emptyTd = dom.createEmptyNode(this.editor.document, td.nodeName.toLowerCase());\n\n            if (!td || this.immutables() && Editor.Immutables.immutableParent(td)) {\n              this.releaseRange(range);\n              return;\n            }\n\n            this._mapColIndices(table);\n\n            if (type === \"row\" && $(td).is(\"[\" + attr + \"]\")) {\n              this._splitCellHorizontally(td, parent, attr, emptyTd);\n            } else if (type === \"column\" && $(td).is(\"[\" + attr + \"]\")) {\n              this._splitCellVertically(td, parent, attr, emptyTd);\n            }\n\n            if ($(td).prop(attr.toLowerCase()) <= 1) {\n              $(td).removeAttr(attr);\n            }\n\n            if ($(table).find(\"[headers]\").length > 0) {\n              this._associateHeaderIds(table);\n            }\n\n            this._clearColIndexAttr(table);\n\n            this.releaseRange(range);\n          },\n          _getRowspanValue: function (td) {\n            return parseInt(td.getAttribute(ROWSPAN), 10);\n          },\n          _getColspanValue: function (td) {\n            return parseInt(td.getAttribute(COLSPAN), 10);\n          },\n          _splitCellHorizontally: function (td, parent, attr, emptyTd) {\n            var rowSpan = td.rowSpan,\n                colSpan = td.colSpan,\n                tdToAdd = $(emptyTd),\n                colSpanResult = Math.floor(colSpan / 2);\n\n            if (colSpanResult > 1) {\n              tdToAdd.attr(COLSPAN, colSpanResult);\n            }\n\n            if (rowSpan > 1) {\n              tdToAdd.attr(ROWSPAN, rowSpan);\n            }\n\n            $(td).prop(attr, colSpan - colSpanResult).after(tdToAdd);\n            $(td).width(td.offsetWidth);\n            tdToAdd.width(tdToAdd[0].offsetWidth);\n\n            if (td.hasAttribute(SCOPE)) {\n              if (td.getAttribute(SCOPE) === COLGROUP) {\n                tdToAdd.attr(SCOPE, COL);\n\n                if (!td.getAttribute(COLSPAN) || td.getAttribute(COLSPAN) === \"1\") {\n                  td.setAttribute(SCOPE, COL);\n                }\n\n                this._adjustColgroups(td.parentNode, parent.parentNode);\n              } else {\n                tdToAdd.attr(SCOPE, td.getAttribute(SCOPE));\n              }\n            }\n          },\n          _splitCellVertically: function (td, parent, attr, emptyTd) {\n            var tr = dom.closest(td, TR),\n                columnIndex = parseInt($(td).attr(\"col-index\"), 10),\n                rowIndex = dom.findNodeIndex(tr, true),\n                rowSpan = td.rowSpan,\n                colSpan = td.colSpan,\n                rowSpanResult = Math.floor(rowSpan / 2),\n                targetRow = $(parent).find(TR).eq(rowIndex + rowSpan - rowSpanResult),\n                nextTd = this._findNextTdInRow(targetRow, columnIndex + colSpan),\n                tdToAdd = $(emptyTd);\n\n            if (rowSpanResult > 1) {\n              tdToAdd.attr(ROWSPAN, rowSpanResult);\n            }\n\n            if (colSpan > 1) {\n              tdToAdd.attr(COLSPAN, colSpan);\n            }\n\n            if (nextTd && nextTd.length) {\n              nextTd.before(tdToAdd);\n            } else {\n              targetRow.append(tdToAdd);\n            }\n\n            $(td).prop(attr, rowSpan - rowSpanResult);\n\n            if (td.hasAttribute(SCOPE)) {\n              if (td.getAttribute(SCOPE) === ROWGROUP) {\n                tdToAdd.attr(SCOPE, ROW);\n\n                if (!td.getAttribute(ROWSPAN) || td.getAttribute(ROWSPAN) === \"1\") {\n                  td.setAttribute(SCOPE, ROW);\n                }\n              } else {\n                tdToAdd.attr(SCOPE, td.getAttribute(SCOPE));\n              }\n            }\n          }\n        });\n        var TableModificationTool = Tool.extend({\n          command: function (options) {\n            var commandsMap = {\n              row: {\n                insert: InsertRowCommand,\n                \"delete\": DeleteRowCommand,\n                merge: MergeCellsHorizontallyCommand,\n                split: SplitCellCommand\n              },\n              column: {\n                insert: InsertColumnCommand,\n                \"delete\": DeleteColumnCommand,\n                merge: MergeCellsVerticallyCommand,\n                split: SplitCellCommand\n              }\n            };\n            options = extend(options, this.options);\n            options.action = options.action || \"insert\";\n            return new commandsMap[options.type][options.action](options);\n          },\n          initialize: function (ui, options) {\n            Tool.fn.initialize.call(this, ui, options);\n            ui.addClass(\"k-disabled\");\n            ui.attr(\"disabled\", \"disabled\");\n          },\n          update: function (ui, nodes) {\n            var isFormatted = !tableFormatFinder.isFormatted(nodes);\n\n            if (isFormatted === true) {\n              ui.parent().addClass(\"k-hidden k-disabled\");\n              ui.attr(\"disabled\", \"disabled\");\n              ui.addClass(\"k-disabled\");\n            } else {\n              ui.parent().removeClass(\"k-hidden k-disabled\");\n              ui.prop(\"disabled\", false);\n              ui.removeClass(\"k-disabled\");\n            }\n          }\n        });\n        var TableFormatCommand = FormatCommand.extend({\n          exec: function () {\n            var that = this;\n            var editor = that.editor;\n            FormatCommand.fn.exec.call(this);\n\n            if (editor.elementResizing) {\n              editor.elementResizing._showResizeHandles();\n            }\n          }\n        }); // var tableAlignFormatFinder = BlockFormatFinder.extend({\n        // });\n\n        var TableFormatTool = BlockFormatTool.extend({\n          initialize: function (ui, options) {\n            BlockFormatTool.fn.initialize.call(this, ui, options);\n            ui.addClass(\"k-disabled\");\n            ui.attr(\"disabled\", \"disabled\");\n          },\n          update: function (ui, nodes) {\n            var isTable = !tableFormatFinder.isFormatted(nodes);\n            var isFormatted = this.options.finder.isFormatted(nodes, this.isTable);\n\n            if (isTable === true) {\n              ui.parent().addClass(\"k-hidden k-disabled\");\n              ui.attr(\"disabled\", \"disabled\");\n              ui.addClass(\"k-disabled\");\n            } else {\n              ui.parent().removeClass(\"k-hidden k-disabled\");\n              ui.prop(\"disabled\", false);\n              ui.removeClass(\"k-disabled\");\n            }\n\n            ui.toggleClass(\"k-selected\", isFormatted);\n            ui.attr(\"aria-pressed\", isFormatted);\n          },\n          command: function (commandArguments) {\n            var that = this;\n            return new TableFormatCommand(extend(commandArguments, {\n              formatter: that.options.formatter\n            }));\n          },\n          isTable: function (node) {\n            return dom.is(node, \"table\");\n          }\n        });\n        extend(kendo.ui.editor, {\n          PopupTool: PopupTool,\n          TableCommand: TableCommand,\n          InsertTableTool: InsertTableTool,\n          TableFormatTool: TableFormatTool,\n          TableFormatCommand: TableFormatCommand,\n          TableModificationTool: TableModificationTool,\n          InsertRowCommand: InsertRowCommand,\n          InsertColumnCommand: InsertColumnCommand,\n          DeleteRowCommand: DeleteRowCommand,\n          DeleteColumnCommand: DeleteColumnCommand,\n          MergeCellsHorizontallyCommand: MergeCellsHorizontallyCommand,\n          MergeCellsVerticallyCommand: MergeCellsVerticallyCommand,\n          SplitCellCommand: SplitCellCommand\n        });\n        registerTool(\"createTable\", new InsertTableTool({\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            popup: true,\n            title: \"Create table\"\n          })\n        }));\n        registerTool(\"addColumnLeft\", new TableModificationTool({\n          type: \"column\",\n          position: \"before\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Add column on the left\"\n          })\n        }));\n        registerTool(\"addColumnRight\", new TableModificationTool({\n          type: \"column\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Add column on the right\"\n          })\n        }));\n        registerTool(\"addRowAbove\", new TableModificationTool({\n          type: \"row\",\n          position: \"before\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Add row above\"\n          })\n        }));\n        registerTool(\"addRowBelow\", new TableModificationTool({\n          type: \"row\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Add row below\"\n          })\n        }));\n        registerTool(\"deleteRow\", new TableModificationTool({\n          type: \"row\",\n          action: \"delete\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Delete row\"\n          })\n        }));\n        registerTool(\"deleteColumn\", new TableModificationTool({\n          type: \"column\",\n          action: \"delete\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Delete column\"\n          })\n        }));\n        registerTool(\"mergeCellsHorizontally\", new TableModificationTool({\n          type: \"row\",\n          action: \"merge\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Merge Cell Right\"\n          })\n        }));\n        registerTool(\"mergeCellsVertically\", new TableModificationTool({\n          type: \"column\",\n          action: \"merge\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Merge Cell Down\"\n          })\n        }));\n        registerTool(\"splitCellHorizontally\", new TableModificationTool({\n          type: \"row\",\n          action: \"split\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Split Cell\"\n          })\n        }));\n        registerTool(\"splitCellVertically\", new TableModificationTool({\n          type: \"column\",\n          action: \"split\",\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Split Cell\"\n          })\n        }));\n        registerFormat(\"tableAlignLeft\", [{\n          tags: [\"table\"],\n          attr: {\n            style: {\n              marginLeft: \"\",\n              marginRight: \"auto\"\n            }\n          }\n        }, {\n          tags: [\"table\"],\n          attr: {\n            align: \"left\"\n          }\n        }]);\n        registerTool(\"tableAlignLeft\", new TableFormatTool({\n          format: formats.tableAlignLeft,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Table Align Left\"\n          })\n        }));\n        registerFormat(\"tableAlignCenter\", [{\n          tags: [\"table\"],\n          attr: {\n            style: {\n              marginLeft: \"auto\",\n              marginRight: \"auto\"\n            }\n          }\n        }, {\n          tags: [\"table\"],\n          attr: {\n            align: \"center\"\n          }\n        }]);\n        registerTool(\"tableAlignCenter\", new TableFormatTool({\n          format: formats.tableAlignCenter,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Table Align Center\"\n          })\n        }));\n        registerFormat(\"tableAlignRight\", [{\n          tags: [\"table\"],\n          attr: {\n            style: {\n              marginLeft: \"auto\",\n              marginRight: \"\"\n            }\n          }\n        }, {\n          tags: [\"table\"],\n          attr: {\n            align: \"right\"\n          }\n        }]);\n        registerTool(\"tableAlignRight\", new TableFormatTool({\n          format: formats.tableAlignRight,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Table Align Left\"\n          })\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1006:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./insert\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}