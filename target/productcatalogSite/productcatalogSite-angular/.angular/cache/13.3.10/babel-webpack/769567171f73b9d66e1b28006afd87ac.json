{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\nconst DEFAULT_MAJOR_UNIT = 10;\nconst MIN_VALUE_RANGE = 1e-6;\n\nclass LogarithmicAxis extends Axis {\n  constructor(seriesMin, seriesMax, options, chartService) {\n    const axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    const base = axisOptions.majorUnit;\n    const autoMax = autoAxisMax(seriesMax, base);\n    const autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    const range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    super(axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n\n  clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  }\n\n  startValue() {\n    return this.options.min;\n  }\n\n  getSlot(a, b, limit) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      majorUnit: base,\n      min,\n      max\n    } = options;\n    const {\n      axis,\n      axisDir,\n      lineBox,\n      lineSize,\n      lineStart\n    } = this.lineInfo();\n    const step = axisDir * (lineSize / (logMax - logMin));\n    let start = valueOrDefault(a, b || 1);\n    let end = valueOrDefault(b, a || 1);\n\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n\n    if (limit) {\n      start = limitValue(start, min, max);\n      end = limitValue(end, min, max);\n    }\n\n    start = log(start, base);\n    end = log(end, base);\n    const p1 = Math.min(start, end) - logMin;\n    const p2 = Math.max(start, end) - logMin;\n    const slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n    return slotBox;\n  }\n\n  getValue(point) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      majorUnit: base\n    } = options;\n    const {\n      axis,\n      axisDir,\n      lineStart,\n      lineSize\n    } = this.lineInfo();\n    const step = (logMax - logMin) / lineSize;\n    const offset = axisDir * (point[axis] - lineStart);\n    const valueOffset = offset * step;\n\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n\n    const value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  }\n\n  range() {\n    const options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  }\n\n  translateRange(delta) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      reverse,\n      vertical,\n      majorUnit: base\n    } = options;\n    const lineBox = this.lineBox();\n    const size = vertical ? lineBox.height() : lineBox.width();\n    const scale = size / (logMax - logMin);\n    let offset = round(delta / scale, DEFAULT_PRECISION);\n\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  }\n\n  labelsCount() {\n    const floorMax = Math.floor(this.logMax);\n    const count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  }\n\n  getMajorTickPositions() {\n    const ticks = [];\n    this.traverseMajorTicksPositions(position => {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  }\n\n  createTicks(lineGroup) {\n    const options = this.options;\n    const {\n      majorTicks,\n      minorTicks,\n      vertical\n    } = options;\n    const mirror = options.labels.mirror;\n    const lineBox = this.lineBox();\n    const ticks = [];\n    const tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n\n    return ticks;\n  }\n\n  createGridLines(altAxis) {\n    const options = this.options;\n    const {\n      minorGridLines,\n      majorGridLines,\n      vertical\n    } = options;\n    const lineBox = altAxis.lineBox();\n    const lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    const majorTicks = [];\n    const container = this.gridLinesVisual();\n\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n\n    return container.children;\n  }\n\n  traverseMajorTicksPositions(callback, tickOptions) {\n    const {\n      lineStart,\n      step\n    } = this.lineInfo();\n    const {\n      logMin,\n      logMax\n    } = this;\n\n    for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  }\n\n  traverseMinorTicksPositions(callback, tickOptions) {\n    const {\n      min,\n      max,\n      minorUnit,\n      majorUnit: base\n    } = this.options;\n    const {\n      lineStart,\n      step\n    } = this.lineInfo();\n    const {\n      logMin,\n      logMax\n    } = this;\n    const start = Math.floor(logMin);\n\n    for (let power = start; power < logMax; power++) {\n      const minorOptions = this._minorIntervalOptions(power);\n\n      for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        const value = minorOptions.value + idx * minorOptions.minorStep;\n\n        if (value > max) {\n          break;\n        }\n\n        if (value >= min) {\n          const position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  }\n\n  createAxisLabel(index, labelOptions, labelContext) {\n    const power = Math.ceil(this.logMin + index);\n    const value = Math.pow(this.options.majorUnit, power);\n    const text = this.axisLabelText(value, labelOptions, labelContext);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  }\n\n  shouldRenderNote(value) {\n    const range = this.range();\n    return range.min <= value && value <= range.max;\n  }\n\n  pan(delta) {\n    const range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  }\n\n  pointsRange(start, end) {\n    const startValue = this.getValue(start);\n    const endValue = this.getValue(end);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  scaleRange(scale, cursor) {\n    const {\n      majorUnit: base\n    } = this.options;\n    const logMin = log(this.options.min, base);\n    const logMax = log(this.options.max, base);\n    const position = Math.abs(this.pointOffset(cursor));\n    const range = logMax - logMin;\n    const delta = this.scaleToDelta(scale, range);\n    const min = Math.pow(base, logMin + position * delta);\n    let max = Math.pow(base, logMax - (1 - position) * delta);\n\n    if (max - min < MIN_VALUE_RANGE) {\n      max = min + MIN_VALUE_RANGE;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  zoomRange(scale, cursor) {\n    const range = this.scaleRange(scale, cursor);\n    const {\n      totalMin,\n      totalMax\n    } = this;\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  }\n\n  _minorIntervalOptions(power) {\n    const {\n      minorUnit,\n      majorUnit: base\n    } = this.options;\n    const value = Math.pow(base, power);\n    const nextValue = Math.pow(base, power + 1);\n    const difference = nextValue - value;\n    const minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  }\n\n  lineInfo() {\n    const info = super.lineInfo();\n    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n    return info;\n  }\n\n}\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  let {\n    min,\n    max\n  } = axisOptions;\n\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction autoAxisMin(min, max, options) {\n  const base = options.majorUnit;\n  let autoMin = min;\n\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n\n  return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n  const logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  let autoMax;\n\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n\n  return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(x, base) {\n  return Math.log(x) / Math.log(base);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":null,"metadata":{},"sourceType":"module"}