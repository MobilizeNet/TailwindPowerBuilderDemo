{"ast":null,"code":"import { Class, grep } from '../../common';\nimport { proxy, noop, applyEventMap, getEventMap, on, off, now, getSupportedFeatures } from '../utils';\nimport { Observable } from './observable';\nconst extend = Object.assign;\n\nconst preventDefault = e => {\n  e.preventDefault();\n};\n\nlet DEFAULT_MIN_HOLD = 800,\n    CLICK_DELAY = 300,\n    // DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0,\nDEFAULT_THRESHOLD = 0,\n    PRESS = 'press',\n    HOLD = 'hold',\n    SELECT = 'select',\n    START = 'start',\n    MOVE = 'move',\n    END = 'end',\n    CANCEL = 'cancel',\n    TAP = 'tap',\n    DOUBLETAP = 'doubleTap',\n    RELEASE = 'release',\n    GESTURESTART = 'gesturestart',\n    GESTURECHANGE = 'gesturechange',\n    GESTUREEND = 'gestureend',\n    GESTURETAP = 'gesturetap';\nlet THRESHOLD = {\n  'api': 0,\n  'touch': 0,\n  'mouse': 9,\n  'pointer': 9\n};\n\nfunction touchDelta(touch1, touch2) {\n  let x1 = touch1.x.location,\n      y1 = touch1.y.location,\n      x2 = touch2.x.location,\n      y2 = touch2.y.location,\n      dx = x1 - x2,\n      dy = y1 - y2;\n  return {\n    center: {\n      x: (x1 + x2) / 2,\n      y: (y1 + y2) / 2\n    },\n    distance: Math.sqrt(dx * dx + dy * dy)\n  };\n}\n\nfunction getTouches(e) {\n  const support = getSupportedFeatures();\n  let touches = [],\n      originalEvent = e.originalEvent || e,\n      currentTarget = e.currentTarget,\n      idx = 0,\n      length,\n      changedTouches,\n      touch;\n\n  if (e.api) {\n    touches.push({\n      id: 2,\n      event: e,\n      target: e.target,\n      currentTarget: e.target,\n      location: e,\n      type: 'api'\n    });\n  } else if (e.type.match(/touch/)) {\n    changedTouches = originalEvent ? originalEvent.changedTouches : [];\n\n    for (length = changedTouches.length; idx < length; idx++) {\n      touch = changedTouches[idx];\n      touches.push({\n        location: touch,\n        event: e,\n        target: touch.target,\n        currentTarget: currentTarget,\n        id: touch.identifier,\n        type: 'touch'\n      });\n    }\n  } else if (support.pointers || support.msPointers) {\n    touches.push({\n      location: originalEvent,\n      event: e,\n      target: e.target,\n      currentTarget: currentTarget,\n      id: originalEvent.pointerId,\n      type: 'pointer'\n    });\n  } else {\n    touches.push({\n      id: 1,\n      event: e,\n      target: e.target,\n      currentTarget: currentTarget,\n      location: e,\n      type: 'mouse'\n    });\n  }\n\n  return touches;\n}\n\nexport class TouchAxis extends Class {\n  constructor(axis, location) {\n    super();\n    let that = this;\n    that.support = getSupportedFeatures();\n    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;\n    that.axis = axis;\n\n    that._updateLocationData(location);\n\n    that.startLocation = that.location;\n    that.velocity = that.delta = 0;\n    that.timeStamp = now();\n  }\n\n  move(location) {\n    let that = this,\n        offset = location['page' + that.axis],\n        timeStamp = now(),\n        timeDelta = timeStamp - that.timeStamp || 1;\n\n    if (!offset && this.invalidZeroEvents) {\n      return;\n    }\n\n    that.delta = offset - that.location;\n\n    that._updateLocationData(location);\n\n    that.initialDelta = offset - that.startLocation;\n    that.velocity = that.delta / timeDelta;\n    that.timeStamp = timeStamp;\n  }\n\n  _updateLocationData(location) {\n    let that = this,\n        axis = that.axis;\n    that.location = location['page' + axis];\n    that.client = location['client' + axis];\n    that.screen = location['screen' + axis];\n  }\n\n}\nexport class Touch extends Class {\n  constructor(userEvents, target, touchInfo) {\n    super();\n    extend(this, {\n      x: new TouchAxis('X', touchInfo.location),\n      y: new TouchAxis('Y', touchInfo.location),\n      type: touchInfo.type,\n      useClickAsTap: userEvents.useClickAsTap,\n      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n      userEvents: userEvents,\n      target: target,\n      currentTarget: touchInfo.currentTarget,\n      initialTouch: touchInfo.target,\n      id: touchInfo.id,\n      pressEvent: touchInfo,\n      _clicks: userEvents._clicks,\n      supportDoubleTap: userEvents.supportDoubleTap,\n      _moved: false,\n      _finished: false\n    });\n  }\n\n  press() {\n    // this._holdTimeout = setTimeout($.proxy(this, '_hold'), this.userEvents.minHold);\n    this._holdTimeout = setTimeout(proxy(this._hold, this), this.userEvents.minHold);\n\n    this._trigger(PRESS, this.pressEvent);\n  }\n\n  _tap(touchInfo) {\n    let that = this;\n    that.userEvents._clicks++;\n\n    if (that.userEvents._clicks === 1) {\n      that._clickTimeout = setTimeout(function () {\n        if (that.userEvents._clicks === 1) {\n          that._trigger(TAP, touchInfo);\n        } else {\n          that._trigger(DOUBLETAP, touchInfo);\n        }\n\n        that.userEvents._clicks = 0;\n      }, CLICK_DELAY);\n    }\n  }\n\n  _hold() {\n    this._trigger(HOLD, this.pressEvent);\n  }\n  /* eslint-disable consistent-return */\n\n\n  move(touchInfo) {\n    let that = this;\n    let preventMove = touchInfo.type !== 'api' && that.userEvents._shouldNotMove;\n\n    if (that._finished || preventMove) {\n      return;\n    }\n\n    that.x.move(touchInfo.location);\n    that.y.move(touchInfo.location);\n\n    if (!that._moved) {\n      if (that._withinIgnoreThreshold()) {\n        return;\n      }\n\n      if (!UserEvents.current || UserEvents.current === that.userEvents) {\n        that._start(touchInfo);\n      } else {\n        return that.dispose();\n      }\n    }\n\n    if (!that._finished) {\n      that._trigger(MOVE, touchInfo);\n    }\n  }\n  /* eslint-enable consistent-return */\n\n\n  end(touchInfo) {\n    this.endTime = now();\n\n    if (this._finished) {\n      return;\n    }\n\n    this._finished = true;\n\n    this._trigger(RELEASE, touchInfo);\n\n    if (this._moved) {\n      this._trigger(END, touchInfo);\n    } else {\n      if (!this.useClickAsTap) {\n        if (this.supportDoubleTap) {\n          this._tap(touchInfo);\n        } else {\n          this._trigger(TAP, touchInfo);\n        }\n      }\n    }\n\n    clearTimeout(this._holdTimeout);\n    this.dispose();\n  }\n\n  dispose() {\n    let userEvents = this.userEvents,\n        activeTouches = userEvents.touches || [];\n    this._finished = true;\n    this.pressEvent = null;\n    clearTimeout(this._holdTimeout); // activeTouches.splice($.inArray(this, activeTouches), 1);\n\n    const activeTouchIndex = activeTouches.indexOf(this);\n    activeTouches.splice(activeTouchIndex, 1);\n  }\n\n  skip() {\n    this.dispose();\n  }\n\n  cancel() {\n    this.dispose();\n  }\n\n  isMoved() {\n    return this._moved;\n  }\n\n  _start(touchInfo) {\n    clearTimeout(this._holdTimeout);\n    this.startTime = now();\n    this._moved = true;\n\n    this._trigger(START, touchInfo);\n  }\n\n  _trigger(name, touchInfo) {\n    let that = this,\n        jQueryEvent = touchInfo.event,\n        data = {\n      touch: that,\n      x: that.x,\n      y: that.y,\n      target: that.target,\n      event: jQueryEvent\n    };\n\n    if (that.userEvents.notify(name, data)) {\n      jQueryEvent.preventDefault();\n    }\n  }\n\n  _withinIgnoreThreshold() {\n    let xDelta = this.x.initialDelta,\n        yDelta = this.y.initialDelta;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n  }\n\n}\n\nfunction withEachUpEvent(callback) {\n  const eventMap = getEventMap(navigator.userAgent);\n  let downEvents = eventMap.up.split(' '),\n      idx = 0,\n      length = downEvents.length;\n\n  for (; idx < length; idx++) {\n    callback(downEvents[idx]);\n  }\n}\n\nexport class UserEvents extends Observable {\n  constructor(element, options) {\n    super();\n    let that = this;\n    let filter;\n    const support = getSupportedFeatures();\n    this.support = support;\n    /* eslint-disable no-param-reassign */\n\n    options = options || {};\n    /* eslint-enable no-param-reassign */\n\n    this.options = options;\n    filter = that.filter = options.filter;\n    that.threshold = options.threshold || DEFAULT_THRESHOLD;\n    that.minHold = options.minHold || DEFAULT_MIN_HOLD;\n    that.touches = [];\n    that._maxTouches = options.multiTouch ? 2 : 1;\n    that.allowSelection = options.allowSelection;\n    that.captureUpIfMoved = options.captureUpIfMoved;\n    that.useClickAsTap = !options.fastTap && !support.delayedClick();\n    that._clicks = 0;\n    that.supportDoubleTap = options.supportDoubleTap;\n    const enableGlobalSurface = !support.touch || support.mouseAndTouchPresent;\n    extend(that, {\n      element: element,\n      surface: options.global && enableGlobalSurface ? element.ownerDocument.documentElement : options.surface || element,\n      stopPropagation: options.stopPropagation,\n      pressed: false\n    });\n    this._surfaceMoveHandler = proxy(this._move, this);\n    on(that.surface, applyEventMap('move'), this._surfaceMoveHandler);\n    this._surfaceEndHandler = proxy(this._end, this);\n    on(that.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n    this._elementStartHandler = proxy(this._start, this);\n    on(element, applyEventMap('down'), filter, this._elementStartHandler);\n\n    if (that.useClickAsTap) {\n      this._elementClickHandler = proxy(this._click, this);\n      on(element, applyEventMap('click'), filter, this._elementClickHandler);\n    }\n\n    if (support.pointers || support.msPointers) {\n      if (support.browser.version < 11) {\n        let defaultAction = 'pinch-zoom double-tap-zoom';\n        element.style['-ms-touch-action'] = options.touchAction && options.touchAction !== 'none' ? defaultAction + ' ' + options.touchAction : defaultAction;\n      } else {\n        element.style['touch-action'] = options.touchAction || 'none';\n      }\n    }\n\n    if (options.preventDragEvent) {\n      this._elementDragStartHandler = preventDefault;\n      on(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n    } // element.on(kendo.applyEventMap('mousedown'), filter, {\n    //     root: element\n    // } '_select');\n    // todo: use root\n\n\n    this._elementSelectHandler = proxy(this._select, this);\n    on(element, applyEventMap('mousedown'), filter, this._elementSelectHandler);\n\n    if (that.captureUpIfMoved && support.eventCapture) {\n      let surfaceElement = that.surface,\n          preventIfMovingProxy = proxy(that.preventIfMoving, that);\n      withEachUpEvent(function (eventName) {\n        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\n      });\n    }\n\n    that.bind([PRESS, HOLD, TAP, DOUBLETAP, START, MOVE, END, RELEASE, CANCEL, GESTURESTART, GESTURECHANGE, GESTUREEND, GESTURETAP, SELECT], options);\n  }\n\n  preventIfMoving(e) {\n    if (this._isMoved()) {\n      e.preventDefault();\n    }\n  }\n\n  destroy() {\n    let that = this;\n    const options = this.options;\n    const element = this.element;\n\n    if (that._destroyed) {\n      return;\n    }\n\n    that._destroyed = true;\n\n    if (that.captureUpIfMoved && this.support.eventCapture) {\n      let surfaceElement = that.surface;\n      withEachUpEvent(function (eventName) {\n        surfaceElement.removeEventListener(eventName, that.preventIfMoving);\n      });\n    }\n\n    off(that.surface, applyEventMap('move'), this._surfaceMoveHandler);\n    off(that.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n    off(element, applyEventMap('down'), this._elementStartHandler);\n\n    if (that.useClickAsTap) {\n      off(element, applyEventMap('click'), this._elementClickHandler);\n    }\n\n    if (options.preventDragEvent) {\n      off(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n    }\n\n    off(element, applyEventMap('mousedown'), this._elementSelectHandler);\n\n    that._disposeAll();\n\n    that.unbind();\n    delete that.surface;\n    delete that.element;\n    delete that.currentTarget;\n  }\n\n  capture() {\n    UserEvents.current = this;\n  }\n\n  cancel() {\n    this._disposeAll();\n\n    this.trigger(CANCEL);\n  }\n  /* eslint-disable indent */\n\n\n  notify(event, data) {\n    let that = this,\n        touches = that.touches;\n    let eventName = event;\n\n    if (this._isMultiTouch()) {\n      switch (eventName) {\n        case MOVE:\n          eventName = GESTURECHANGE;\n          break;\n\n        case END:\n          eventName = GESTUREEND;\n          break;\n\n        case TAP:\n          eventName = GESTURETAP;\n          break;\n\n        default:\n          break;\n      }\n\n      extend(data, {\n        touches: touches\n      }, touchDelta(touches[0], touches[1]));\n    }\n\n    return this.trigger(eventName, extend(data, {\n      type: eventName\n    }));\n  }\n  /* eslint-enable indent */\n\n\n  press(x, y, target) {\n    this._apiCall('_start', x, y, target);\n  }\n\n  move(x, y) {\n    this._apiCall('_move', x, y);\n  }\n\n  end(x, y) {\n    this._apiCall('_end', x, y);\n  }\n\n  _isMultiTouch() {\n    return this.touches.length > 1;\n  }\n\n  _maxTouchesReached() {\n    return this.touches.length >= this._maxTouches;\n  }\n\n  _disposeAll() {\n    let touches = this.touches;\n\n    while (touches.length > 0) {\n      touches.pop().dispose();\n    }\n  }\n\n  _isMoved() {\n    return grep(this.touches, function (touch) {\n      return touch.isMoved();\n    }).length;\n  }\n\n  _select(e) {\n    if (!this.allowSelection || this.trigger(SELECT, {\n      event: e\n    })) {\n      e.preventDefault();\n    }\n  }\n\n  _start(e) {\n    let that = this,\n        idx = 0,\n        filter = that.filter,\n        target,\n        touches = getTouches(e),\n        length = touches.length,\n        touch,\n        which = e.which;\n\n    if (which && which > 1 || that._maxTouchesReached()) {\n      return;\n    }\n\n    UserEvents.current = null;\n    that.currentTarget = e.currentTarget;\n\n    if (that.stopPropagation) {\n      e.stopPropagation();\n    }\n\n    for (; idx < length; idx++) {\n      if (that._maxTouchesReached()) {\n        break;\n      }\n\n      touch = touches[idx];\n\n      if (filter) {\n        target = touch.currentTarget;\n      } else {\n        target = that.element;\n      }\n\n      if (target && target.length === 0) {\n        continue;\n      }\n\n      touch = new Touch(that, target, touch);\n      that.touches.push(touch);\n      touch.press();\n\n      if (that._isMultiTouch()) {\n        that.notify('gesturestart', {});\n      }\n    }\n  }\n\n  _move(e) {\n    this._eachTouch('move', e);\n  }\n\n  _end(e) {\n    this._eachTouch('end', e);\n  }\n\n  _click(e) {\n    let data = {\n      touch: {\n        initialTouch: e.target,\n        target: e.currentTarget,\n        endTime: now(),\n        x: {\n          location: e.pageX,\n          client: e.clientX\n        },\n        y: {\n          location: e.pageY,\n          client: e.clientY\n        }\n      },\n      x: e.pageX,\n      y: e.pageY,\n      target: e.currentTarget,\n      event: e,\n      type: 'tap'\n    };\n\n    if (this.trigger('tap', data)) {\n      e.preventDefault();\n    }\n  }\n\n  _eachTouch(methodName, e) {\n    let that = this,\n        dict = {},\n        touches = getTouches(e),\n        activeTouches = that.touches,\n        idx,\n        touch,\n        touchInfo,\n        matchingTouch;\n\n    for (idx = 0; idx < activeTouches.length; idx++) {\n      touch = activeTouches[idx];\n      dict[touch.id] = touch;\n    }\n\n    for (idx = 0; idx < touches.length; idx++) {\n      touchInfo = touches[idx];\n      matchingTouch = dict[touchInfo.id];\n\n      if (matchingTouch) {\n        matchingTouch[methodName](touchInfo);\n      }\n    }\n  }\n\n  _apiCall(type, x, y, target) {\n    this[type]({\n      api: true,\n      pageX: x,\n      pageY: y,\n      clientX: x,\n      clientY: y,\n      target: target || this.element,\n      stopPropagation: noop,\n      preventDefault: noop\n    });\n  }\n\n  static defaultThreshold(value) {\n    DEFAULT_THRESHOLD = value;\n  }\n\n  static minHold(value) {\n    DEFAULT_MIN_HOLD = value;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}