{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { ChartElement, Box } from '../../core';\nimport Crosshair from '../crosshair/crosshair';\nimport Pane from '../pane';\nimport { hasValue } from '../utils';\nimport { WHITE, BLACK, X, Y, COORD_PRECISION, TOP, BOTTOM, LEFT, RIGHT, START, END } from '../../common/constants';\nimport { append, deepExtend, defined, getSpacing, getTemplate, inArray, isFunction, isString, limitValue, round, setDefaultOptions } from '../../common';\n\nclass PlotAreaBase extends ChartElement {\n  constructor(series, options, chartService) {\n    super(options);\n    this.initFields(series, options);\n    this.series = series;\n    this.initSeries();\n    this.charts = [];\n    this.options.legend = this.options.legend || {};\n    this.options.legend.items = [];\n    this.axes = [];\n    this.crosshairs = [];\n    this.chartService = chartService;\n    this.originalOptions = options;\n    this.createPanes();\n    this.render();\n    this.createCrosshairs();\n  }\n\n  initFields() {}\n\n  initSeries() {\n    const series = this.series;\n\n    for (let i = 0; i < series.length; i++) {\n      series[i].index = i;\n    }\n  }\n\n  createPanes() {\n    const titleOptions = this.options.title || {};\n    const paneDefaults = this.options.paneDefaults;\n    const paneOptions = this.options.panes || [];\n    const panesLength = Math.max(paneOptions.length, 1);\n    const panes = [];\n    const defaults = deepExtend({\n      title: {\n        color: titleOptions.color\n      }\n    }, paneDefaults);\n\n    for (let i = 0; i < panesLength; i++) {\n      const options = deepExtend({}, defaults, paneOptions[i]);\n\n      if (isString(options.title)) {\n        options.title = deepExtend({\n          text: options.title\n        }, defaults.title);\n      }\n\n      const currentPane = new Pane(options);\n      currentPane.paneIndex = i;\n      panes.push(currentPane);\n      this.append(currentPane);\n    }\n\n    this.panes = panes;\n  }\n\n  crosshairOptions(axis) {\n    return axis.options.crosshair;\n  }\n\n  createCrosshairs(panes = this.panes) {\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n\n      for (let j = 0; j < pane.axes.length; j++) {\n        const axis = pane.axes[j];\n        const options = this.crosshairOptions(axis);\n\n        if (options && options.visible) {\n          const currentCrosshair = new Crosshair(this.chartService, axis, options);\n          this.crosshairs.push(currentCrosshair);\n          pane.content.append(currentCrosshair);\n        }\n      }\n    }\n  }\n\n  removeCrosshairs(pane) {\n    const crosshairs = this.crosshairs;\n    const axes = pane.axes;\n\n    for (let i = crosshairs.length - 1; i >= 0; i--) {\n      for (let j = 0; j < axes.length; j++) {\n        if (crosshairs[i].axis === axes[j]) {\n          crosshairs.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  hideCrosshairs() {\n    const crosshairs = this.crosshairs;\n\n    for (let idx = 0; idx < crosshairs.length; idx++) {\n      crosshairs[idx].hide();\n    }\n  }\n\n  findPane(name) {\n    const panes = this.panes;\n    let matchingPane;\n\n    for (let i = 0; i < panes.length; i++) {\n      if (panes[i].options.name === name) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n\n    return matchingPane || panes[0];\n  }\n\n  findPointPane(point) {\n    const panes = this.panes;\n    let matchingPane;\n\n    for (let i = 0; i < panes.length; i++) {\n      if (panes[i].box.containsPoint(point)) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n\n    return matchingPane;\n  }\n\n  appendAxis(axis) {\n    const pane = this.findPane(axis.options.pane);\n    pane.appendAxis(axis);\n    this.axes.push(axis);\n    axis.plotArea = this;\n  }\n\n  removeAxis(axisToRemove) {\n    const filteredAxes = [];\n\n    for (let i = 0; i < this.axes.length; i++) {\n      const axis = this.axes[i];\n\n      if (axisToRemove !== axis) {\n        filteredAxes.push(axis);\n      } else {\n        axis.destroy();\n      }\n    }\n\n    this.axes = filteredAxes;\n  }\n\n  appendChart(chart, pane) {\n    this.charts.push(chart);\n\n    if (pane) {\n      pane.appendChart(chart);\n    } else {\n      this.append(chart);\n    }\n  }\n\n  removeChart(chartToRemove) {\n    const filteredCharts = [];\n\n    for (let i = 0; i < this.charts.length; i++) {\n      const chart = this.charts[i];\n\n      if (chart !== chartToRemove) {\n        filteredCharts.push(chart);\n      } else {\n        chart.destroy();\n      }\n    }\n\n    this.charts = filteredCharts;\n  }\n\n  addToLegend(series) {\n    const count = series.length;\n    const legend = this.options.legend;\n    const labels = legend.labels || {};\n    const inactiveItems = legend.inactiveItems || {};\n    const inactiveItemsLabels = inactiveItems.labels || {};\n    const data = [];\n\n    for (let i = 0; i < count; i++) {\n      const currentSeries = series[i];\n      const seriesVisible = currentSeries.visible !== false;\n\n      if (currentSeries.visibleInLegend === false) {\n        continue;\n      }\n\n      let text = currentSeries.name;\n      const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: hasValue(text) ? text : \"\",\n          series: currentSeries\n        });\n      }\n\n      const defaults = currentSeries._defaults;\n      let color = currentSeries.color;\n\n      if (isFunction(color) && defaults) {\n        color = defaults.color;\n      }\n\n      let itemLabelOptions, markerColor;\n\n      if (seriesVisible) {\n        itemLabelOptions = {};\n        markerColor = color;\n      } else {\n        itemLabelOptions = {\n          color: inactiveItemsLabels.color,\n          font: inactiveItemsLabels.font\n        };\n        markerColor = inactiveItems.markers.color;\n      }\n\n      if (hasValue(text) && text !== \"\") {\n        data.push({\n          text: text,\n          labels: itemLabelOptions,\n          markerColor: markerColor,\n          series: currentSeries,\n          active: seriesVisible\n        });\n      }\n    }\n\n    append(legend.items, data);\n  }\n\n  groupAxes(panes) {\n    const xAxes = [];\n    const yAxes = [];\n\n    for (let paneIx = 0; paneIx < panes.length; paneIx++) {\n      const paneAxes = panes[paneIx].axes;\n\n      for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n        const axis = paneAxes[axisIx];\n\n        if (axis.options.vertical) {\n          yAxes.push(axis);\n        } else {\n          xAxes.push(axis);\n        }\n      }\n    }\n\n    return {\n      x: xAxes,\n      y: yAxes,\n      any: xAxes.concat(yAxes)\n    };\n  }\n\n  groupSeriesByPane() {\n    const series = this.series;\n    const seriesByPane = {};\n\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      const pane = this.seriesPaneName(currentSeries);\n\n      if (seriesByPane[pane]) {\n        seriesByPane[pane].push(currentSeries);\n      } else {\n        seriesByPane[pane] = [currentSeries];\n      }\n    }\n\n    return seriesByPane;\n  }\n\n  filterVisibleSeries(series) {\n    const result = [];\n\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n\n      if (currentSeries.visible !== false) {\n        result.push(currentSeries);\n      }\n    }\n\n    return result;\n  }\n\n  reflow(targetBox) {\n    const options = this.options.plotArea;\n    const panes = this.panes;\n    const margin = getSpacing(options.margin);\n    this.box = targetBox.clone().unpad(margin);\n    this.reflowPanes();\n    this.detachLabels();\n    this.reflowAxes(panes);\n    this.reflowCharts(panes);\n  }\n\n  redraw(panes) {\n    const panesArray = [].concat(panes);\n    this.initSeries(); //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n\n    const root = this.getRoot();\n\n    if (root) {\n      root.cleanGradients();\n    }\n\n    for (let i = 0; i < panesArray.length; i++) {\n      this.removeCrosshairs(panesArray[i]);\n      panesArray[i].empty();\n    }\n\n    this.render(panesArray);\n    this.detachLabels();\n    this.reflowAxes(this.panes);\n    this.reflowCharts(panesArray);\n    this.createCrosshairs(panesArray);\n\n    for (let i = 0; i < panesArray.length; i++) {\n      panesArray[i].refresh();\n    }\n  }\n\n  axisCrossingValues(axis, crossingAxes) {\n    const options = axis.options;\n    const crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    const valuesToAdd = crossingAxes.length - crossingValues.length;\n    const defaultValue = crossingValues[0] || 0;\n\n    for (let i = 0; i < valuesToAdd; i++) {\n      crossingValues.push(defaultValue);\n    }\n\n    return crossingValues;\n  }\n\n  alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {\n    const slot = axis.getSlot(crossingValue, crossingValue, true);\n    const slotEdge = axis.options.reverse ? 2 : 1;\n    const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n    const targetEdge = targetAxis.options.reverse ? 2 : 1;\n    const axisBox = axis.box.translate(targetSlot[X + targetEdge] - slot[X + slotEdge], targetSlot[Y + targetEdge] - slot[Y + slotEdge]);\n\n    if (axis.pane !== targetAxis.pane) {\n      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n    }\n\n    axis.reflow(axisBox);\n  }\n\n  alignAxes(xAxes, yAxes) {\n    const xAnchor = xAxes[0];\n    const yAnchor = yAxes[0];\n    const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n    const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n    const leftAnchors = {};\n    const rightAnchors = {};\n    const topAnchors = {};\n    const bottomAnchors = {};\n\n    for (let i = 0; i < yAxes.length; i++) {\n      const axis = yAxes[i];\n      const pane = axis.pane;\n      const paneId = pane.id;\n      const visible = axis.options.visible !== false; // Locate pane anchor, if any, and use its axisCrossingValues\n\n      const anchor = paneAnchor(xAxes, pane) || xAnchor;\n      let anchorCrossings = xAnchorCrossings;\n\n      if (anchor !== xAnchor) {\n        anchorCrossings = this.axisCrossingValues(anchor, yAxes);\n      }\n\n      this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n      if (axis.options._overlap) {\n        continue;\n      }\n\n      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n        // Push the axis to the left the previous y-axis so they don't overlap\n        if (leftAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0));\n        }\n\n        if (visible) {\n          leftAnchors[paneId] = axis;\n        }\n      }\n\n      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n        // Flip the labels on the right if we're at the right end of the pane\n        if (!axis._mirrored) {\n          axis.options.labels.mirror = !axis.options.labels.mirror;\n          axis._mirrored = true;\n        }\n\n        this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]); // Push the axis to the right the previous y-axis so they don't overlap\n\n        if (rightAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0));\n        }\n\n        if (visible) {\n          rightAnchors[paneId] = axis;\n        }\n      }\n\n      if (i !== 0 && yAnchor.pane === axis.pane) {\n        axis.alignTo(yAnchor);\n        axis.reflow(axis.box);\n      }\n    }\n\n    for (let i = 0; i < xAxes.length; i++) {\n      const axis = xAxes[i];\n      const pane = axis.pane;\n      const paneId = pane.id;\n      const visible = axis.options.visible !== false; // Locate pane anchor and use its axisCrossingValues\n\n      const anchor = paneAnchor(yAxes, pane) || yAnchor;\n      let anchorCrossings = yAnchorCrossings;\n\n      if (anchor !== yAnchor) {\n        anchorCrossings = this.axisCrossingValues(anchor, xAxes);\n      }\n\n      this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n      if (axis.options._overlap) {\n        continue;\n      }\n\n      if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {\n        // Flip the labels on top if we're at the top of the pane\n        if (!axis._mirrored) {\n          axis.options.labels.mirror = !axis.options.labels.mirror;\n          axis._mirrored = true;\n        }\n\n        this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]); // Push the axis above the previous x-axis so they don't overlap\n\n        if (topAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(topAnchors[paneId].box, TOP).translate(0, -axis.options.margin));\n        }\n\n        if (visible) {\n          topAnchors[paneId] = axis;\n        }\n      }\n\n      if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {\n        // Push the axis below the previous x-axis so they don't overlap\n        if (bottomAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(bottomAnchors[paneId].box, BOTTOM).translate(0, axis.options.margin));\n        }\n\n        if (visible) {\n          bottomAnchors[paneId] = axis;\n        }\n      }\n\n      if (i !== 0) {\n        axis.alignTo(xAnchor);\n        axis.reflow(axis.box);\n      }\n    }\n  }\n\n  shrinkAxisWidth(panes) {\n    const axes = this.groupAxes(panes).any;\n    const axisBox = axisGroupBox(axes);\n    let overflowX = 0;\n\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n\n      if (currentPane.axes.length > 0) {\n        overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());\n      }\n    }\n\n    if (overflowX !== 0) {\n      for (let i = 0; i < axes.length; i++) {\n        const currentAxis = axes[i];\n\n        if (!currentAxis.options.vertical) {\n          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n        }\n      }\n    }\n  }\n\n  shrinkAxisHeight(panes) {\n    let shrinked;\n\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      const axes = currentPane.axes;\n      const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n      if (overflowY !== 0) {\n        for (let j = 0; j < axes.length; j++) {\n          const currentAxis = axes[j];\n\n          if (currentAxis.options.vertical) {\n            currentAxis.reflow(currentAxis.box.shrink(0, overflowY));\n          }\n        }\n\n        shrinked = true;\n      }\n    }\n\n    return shrinked;\n  }\n\n  fitAxes(panes) {\n    const axes = this.groupAxes(panes).any;\n    let offsetX = 0;\n\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      const paneAxes = currentPane.axes;\n      const paneBox = currentPane.contentBox;\n\n      if (paneAxes.length > 0) {\n        const axisBox = axisGroupBox(paneAxes); // OffsetY is calculated and applied per pane\n\n        const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2); // OffsetX is calculated and applied globally\n\n        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n        for (let j = 0; j < paneAxes.length; j++) {\n          const currentAxis = paneAxes[j];\n          currentAxis.reflow(currentAxis.box.translate(0, offsetY));\n        }\n      }\n    }\n\n    for (let i = 0; i < axes.length; i++) {\n      const currentAxis = axes[i];\n      currentAxis.reflow(currentAxis.box.translate(offsetX, 0));\n    }\n  }\n\n  reflowAxes(panes) {\n    const axes = this.groupAxes(panes);\n\n    for (let i = 0; i < panes.length; i++) {\n      this.reflowPaneAxes(panes[i]);\n    }\n\n    if (axes.x.length > 0 && axes.y.length > 0) {\n      this.alignAxes(axes.x, axes.y);\n      this.shrinkAxisWidth(panes);\n      this.autoRotateAxisLabels(axes);\n      this.alignAxes(axes.x, axes.y);\n\n      if (this.shrinkAxisWidth(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n\n      this.shrinkAxisHeight(panes);\n      this.alignAxes(axes.x, axes.y);\n\n      if (this.shrinkAxisHeight(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n\n      this.fitAxes(panes);\n    }\n  }\n\n  autoRotateAxisLabels(groupedAxes) {\n    const {\n      panes\n    } = this;\n    const axes = allPaneAxes(panes);\n    let rotated;\n\n    for (let idx = 0; idx < axes.length; idx++) {\n      const axis = axes[idx];\n\n      if (axis.autoRotateLabels()) {\n        rotated = true;\n      }\n    }\n\n    if (rotated) {\n      for (let idx = 0; idx < panes.length; idx++) {\n        this.reflowPaneAxes(panes[idx]);\n      }\n\n      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n        this.alignAxes(groupedAxes.x, groupedAxes.y);\n        this.shrinkAxisWidth(panes);\n      }\n    }\n  }\n\n  reflowPaneAxes(pane) {\n    const axes = pane.axes;\n    const length = axes.length;\n\n    if (length > 0) {\n      for (let i = 0; i < length; i++) {\n        axes[i].reflow(pane.contentBox);\n      }\n    }\n  }\n\n  reflowCharts(panes) {\n    const charts = this.charts;\n    const count = charts.length;\n    const box = this.box;\n\n    for (let i = 0; i < count; i++) {\n      const chartPane = charts[i].pane;\n\n      if (!chartPane || inArray(chartPane, panes)) {\n        charts[i].reflow(box);\n      }\n    }\n  }\n\n  reflowPanes() {\n    const {\n      box,\n      panes\n    } = this;\n    const panesLength = panes.length;\n    let remainingHeight = box.height();\n    let remainingPanes = panesLength;\n    let autoHeightPanes = 0;\n    let top = box.y1;\n\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n      const height = currentPane.options.height;\n      currentPane.options.width = box.width();\n\n      if (!currentPane.options.height) {\n        autoHeightPanes++;\n      } else {\n        if (height.indexOf && height.indexOf(\"%\")) {\n          const percents = parseInt(height, 10) / 100;\n          currentPane.options.height = percents * box.height();\n        }\n\n        currentPane.reflow(box.clone());\n        remainingHeight -= currentPane.options.height;\n      }\n    }\n\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n\n      if (!currentPane.options.height) {\n        currentPane.options.height = remainingHeight / autoHeightPanes;\n      }\n    }\n\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n      const paneBox = box.clone().move(box.x1, top);\n      currentPane.reflow(paneBox);\n      remainingPanes--;\n      top += currentPane.options.height;\n    }\n  }\n\n  backgroundBox() {\n    const axes = this.axes;\n    const axesCount = axes.length;\n    let box;\n\n    for (let i = 0; i < axesCount; i++) {\n      const axisA = axes[i];\n\n      for (let j = 0; j < axesCount; j++) {\n        const axisB = axes[j];\n\n        if (axisA.options.vertical !== axisB.options.vertical) {\n          const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n          if (!box) {\n            box = lineBox;\n          } else {\n            box = box.wrap(lineBox);\n          }\n        }\n      }\n    }\n\n    return box || this.box;\n  }\n\n  chartsBoxes() {\n    const panes = this.panes;\n    const boxes = [];\n\n    for (let idx = 0; idx < panes.length; idx++) {\n      boxes.push(panes[idx].chartsBox());\n    }\n\n    return boxes;\n  }\n\n  addBackgroundPaths(multipath) {\n    const boxes = this.chartsBoxes();\n\n    for (let idx = 0; idx < boxes.length; idx++) {\n      multipath.paths.push(draw.Path.fromRect(boxes[idx].toRect()));\n    }\n  }\n\n  backgroundContainsPoint(point) {\n    const boxes = this.chartsBoxes();\n\n    for (let idx = 0; idx < boxes.length; idx++) {\n      if (boxes[idx].containsPoint(point)) {\n        return true;\n      }\n    }\n  }\n\n  createVisual() {\n    super.createVisual();\n    const options = this.options.plotArea;\n    let {\n      opacity,\n      background,\n      border = {}\n    } = options;\n\n    if (isTransparent(background)) {\n      background = WHITE;\n      opacity = 0;\n    }\n\n    const bg = this._bgVisual = new draw.MultiPath({\n      fill: {\n        color: background,\n        opacity: opacity\n      },\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      },\n      zIndex: -1\n    });\n    this.addBackgroundPaths(bg);\n    this.appendVisual(bg);\n  }\n\n  pointsByCategoryIndex(categoryIndex) {\n    const charts = this.charts;\n    const result = [];\n\n    if (categoryIndex !== null) {\n      for (let i = 0; i < charts.length; i++) {\n        const chart = charts[i];\n\n        if (chart.pane.options.name === \"_navigator\") {\n          continue;\n        }\n\n        const points = charts[i].categoryPoints[categoryIndex];\n\n        if (points && points.length) {\n          for (let j = 0; j < points.length; j++) {\n            const point = points[j];\n\n            if (point && defined(point.value) && point.value !== null) {\n              result.push(point);\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  pointsBySeriesIndex(seriesIndex) {\n    return this.filterPoints(function (point) {\n      return point.series.index === seriesIndex;\n    });\n  }\n\n  pointsBySeriesName(name) {\n    return this.filterPoints(function (point) {\n      return point.series.name === name;\n    });\n  }\n\n  filterPoints(callback) {\n    const charts = this.charts;\n    const result = [];\n\n    for (let i = 0; i < charts.length; i++) {\n      const chart = charts[i];\n      const points = chart.points;\n\n      for (let j = 0; j < points.length; j++) {\n        const point = points[j];\n\n        if (point && point.visible !== false && callback(point)) {\n          result.push(point);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  findPoint(callback) {\n    const charts = this.charts;\n\n    for (let i = 0; i < charts.length; i++) {\n      const chart = charts[i];\n      const points = chart.points;\n\n      for (let j = 0; j < points.length; j++) {\n        const point = points[j];\n\n        if (point && point.visible !== false && callback(point)) {\n          return point;\n        }\n      }\n    }\n  }\n\n  paneByPoint(point) {\n    const panes = this.panes;\n\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n\n      if (pane.box.containsPoint(point)) {\n        return pane;\n      }\n    }\n  }\n\n  detachLabels() {\n    const axes = this.groupAxes(this.panes);\n    const xAxes = axes.x;\n    const yAxes = axes.y;\n    this.detachAxisGroupLabels(yAxes, xAxes);\n    this.detachAxisGroupLabels(xAxes, yAxes);\n  }\n\n  detachAxisGroupLabels(axes, crossingAxes) {\n    let labelAxisCount = 0;\n\n    for (let i = 0; i < axes.length; i++) {\n      const axis = axes[i];\n      const pane = axis.pane;\n      const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n      const axisIndex = i + labelAxisCount;\n      const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);\n\n      if (labelAxis) {\n        labelAxisCount++;\n        const pos = pane.axes.indexOf(axis) + labelAxisCount;\n        pane.appendAxisAt(labelAxis, pos);\n      }\n    }\n  }\n\n  createLabelAxis(axis, axisIndex, anchor) {\n    const labelOptions = axis.options.labels;\n    const position = labelOptions.position;\n    const onAxis = position !== END && position !== START;\n    const visible = labelOptions.visible;\n\n    if (onAxis || visible === false) {\n      return null;\n    }\n\n    const allAxes = this.groupAxes(this.panes);\n    const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n    const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n    const end = position === END;\n    const range = anchor.range();\n    const edge = end ? range.max : range.min;\n    const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n    if (crossingValue - edge === 0) {\n      return null;\n    }\n\n    anchorCrossings.splice(axisIndex + 1, 0, edge);\n    anchor.options.axisCrossingValues = anchorCrossings;\n    const labelAxis = axis.clone();\n    axis.clear();\n    labelAxis.options.name = undefined;\n    labelAxis.options.line.visible = false;\n    labelAxis.options.crosshair = undefined;\n    labelAxis.options.notes = undefined;\n    labelAxis.options.plotBands = undefined;\n    return labelAxis;\n  }\n\n}\n\nfunction isSingleAxis(axis) {\n  return !axis.pane.axes.some(a => a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false);\n}\n\nfunction axisGroupBox(axes) {\n  const length = axes.length;\n  let box;\n\n  for (let i = 0; i < length; i++) {\n    const axis = axes[i];\n    const visible = axis.options.visible !== false;\n\n    if (visible || isSingleAxis(axis)) {\n      const axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n      if (!box) {\n        box = axisBox.clone();\n      } else {\n        box.wrap(axisBox);\n      }\n    }\n  }\n\n  return box || new Box();\n}\n\nfunction paneAnchor(axes, pane) {\n  for (let i = 0; i < axes.length; i++) {\n    const anchor = axes[i];\n\n    if (anchor && anchor.pane === pane) {\n      return anchor;\n    }\n  }\n}\n\nfunction isTransparent(color) {\n  return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n}\n\nconst allPaneAxes = panes => panes.reduce((acc, pane) => acc.concat(pane.axes), []);\n\nsetDefaultOptions(PlotAreaBase, {\n  series: [],\n  plotArea: {\n    margin: {}\n  },\n  background: \"\",\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  paneDefaults: {\n    title: {}\n  },\n  legend: {\n    inactiveItems: {\n      labels: {\n        color: \"#919191\"\n      },\n      markers: {\n        color: \"#919191\"\n      }\n    }\n  }\n});\nexport default PlotAreaBase;","map":null,"metadata":{},"sourceType":"module"}