{"ast":null,"code":"import { drawing as draw, Color } from '@progress/kendo-drawing';\nimport { ChartElement, Point } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport NoteMixin from '../mixins/note-mixin';\nimport { TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { WHITE, LEFT, TOP } from '../../common/constants';\nimport { alignPathToPixel, deepExtend, defined, setDefaultOptions, valueOrDefault } from '../../common';\n\nclass Candlestick extends ChartElement {\n  constructor(value, options) {\n    super(options);\n    this.value = value;\n  }\n\n  reflow(box) {\n    const {\n      options,\n      value,\n      owner: chart\n    } = this;\n    const valueAxis = chart.seriesValueAxis(options);\n    const ocSlot = valueAxis.getSlot(value.open, value.close);\n    const lhSlot = valueAxis.getSlot(value.low, value.high);\n    ocSlot.x1 = lhSlot.x1 = box.x1;\n    ocSlot.x2 = lhSlot.x2 = box.x2;\n    this.realBody = ocSlot;\n    const mid = lhSlot.center().x;\n    const points = [];\n    points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);\n    points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);\n    this.lines = points;\n    this.box = lhSlot.clone().wrap(ocSlot);\n\n    if (!this._rendered) {\n      this._rendered = true;\n      this.createNote();\n    }\n\n    this.reflowNote();\n  }\n\n  reflowNote() {\n    if (this.note) {\n      this.note.reflow(this.box);\n    }\n  }\n\n  createVisual() {\n    super.createVisual();\n    this._mainVisual = this.mainVisual(this.options);\n    this.visual.append(this._mainVisual);\n    this.createOverlay();\n  }\n\n  mainVisual(options) {\n    const group = new draw.Group();\n    this.createBody(group, options);\n    this.createLines(group, options);\n    return group;\n  }\n\n  createBody(container, options) {\n    const body = draw.Path.fromRect(this.realBody.toRect(), {\n      fill: {\n        color: this.color,\n        opacity: options.opacity\n      },\n      stroke: null\n    });\n\n    if (options.border.width > 0) {\n      body.options.set(\"stroke\", {\n        color: this.getBorderColor(),\n        width: options.border.width,\n        dashType: options.border.dashType,\n        opacity: valueOrDefault(options.border.opacity, options.opacity)\n      });\n    }\n\n    alignPathToPixel(body);\n    container.append(body);\n\n    if (hasGradientOverlay(options)) {\n      container.append(this.createGradientOverlay(body, {\n        baseColor: this.color\n      }, deepExtend({\n        end: !options.vertical ? [0, 1] : undefined\n      }, options.overlay)));\n    }\n  }\n\n  createLines(container, options) {\n    this.drawLines(container, options, this.lines, options.line);\n  }\n\n  drawLines(container, options, lines, lineOptions) {\n    if (!lines) {\n      return;\n    }\n\n    const lineStyle = {\n      stroke: {\n        color: lineOptions.color || this.color,\n        opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n        width: lineOptions.width,\n        dashType: lineOptions.dashType,\n        lineCap: \"butt\"\n      }\n    };\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = draw.Path.fromPoints(lines[i], lineStyle);\n      alignPathToPixel(line);\n      container.append(line);\n    }\n  }\n\n  getBorderColor() {\n    const border = this.options.border;\n    let borderColor = border.color;\n\n    if (!defined(borderColor)) {\n      borderColor = new Color(this.color).brightness(border._brightness).toHex();\n    }\n\n    return borderColor;\n  }\n\n  createOverlay() {\n    const overlay = draw.Path.fromRect(this.box.toRect(), {\n      fill: {\n        color: WHITE,\n        opacity: 0\n      },\n      stroke: null\n    });\n    this.visual.append(overlay);\n  }\n\n  createHighlight() {\n    const highlight = this.options.highlight;\n    const normalColor = this.color;\n    this.color = highlight.color || this.color;\n    const overlay = this.mainVisual(deepExtend({}, this.options, {\n      line: {\n        color: this.getBorderColor()\n      }\n    }, highlight));\n    this.color = normalColor;\n    return overlay;\n  }\n\n  highlightVisual() {\n    return this._mainVisual;\n  }\n\n  highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this._mainVisual\n    };\n  }\n\n  tooltipAnchor() {\n    const box = this.box;\n    const clipBox = this.owner.pane.clipBox() || box;\n    return {\n      point: new Point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\n      align: {\n        horizontal: LEFT,\n        vertical: TOP\n      }\n    };\n  }\n\n  formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  }\n\n  overlapsBox(box) {\n    return this.box.overlaps(box);\n  }\n\n}\n\nsetDefaultOptions(Candlestick, {\n  vertical: true,\n  border: {\n    _brightness: 0.8\n  },\n  line: {\n    width: 2\n  },\n  overlay: {\n    gradient: \"glass\"\n  },\n  tooltip: {\n    format: \"<table>\" + \"<tr><th colspan='2'>{4:d}</th></tr>\" + \"<tr><td>Open:</td><td>{0:C}</td></tr>\" + \"<tr><td>High:</td><td>{1:C}</td></tr>\" + \"<tr><td>Low:</td><td>{2:C}</td></tr>\" + \"<tr><td>Close:</td><td>{3:C}</td></tr>\" + \"</table>\"\n  },\n  highlight: {\n    opacity: 1,\n    border: {\n      width: 1,\n      opacity: 1\n    },\n    line: {\n      width: 1,\n      opacity: 1\n    }\n  },\n  notes: {\n    visible: true,\n    label: {}\n  }\n});\ndeepExtend(Candlestick.prototype, PointEventsMixin);\ndeepExtend(Candlestick.prototype, NoteMixin);\nexport default Candlestick;","map":null,"metadata":{},"sourceType":"module"}