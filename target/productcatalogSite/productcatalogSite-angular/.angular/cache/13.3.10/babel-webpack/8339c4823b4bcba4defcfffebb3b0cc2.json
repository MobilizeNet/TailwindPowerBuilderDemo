{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport { ChartElement, ShapeBuilder, TextBox, Box } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport { OUTSIDE_END, INSIDE_END, PIE, FADEIN, TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { TOP, BOTTOM, LEFT, RIGHT, DEFAULT_FONT, CIRCLE, WHITE, CENTER, DEFAULT_PRECISION } from '../../common/constants';\nimport { autoTextColor, setDefaultOptions, getSpacing, getTemplate, deepExtend, round, rad } from '../../common';\n\nclass PieSegment extends ChartElement {\n  constructor(value, sector, options) {\n    super(options);\n    this.value = value;\n    this.sector = sector;\n  }\n\n  render() {\n    const labels = this.options.labels;\n    const chartService = this.owner.chartService;\n    let labelText = this.value;\n\n    if (this._rendered || this.visible === false) {\n      return;\n    }\n\n    this._rendered = true;\n    const labelTemplate = getTemplate(labels);\n    const pointData = this.pointData();\n\n    if (labelTemplate) {\n      labelText = labelTemplate(pointData);\n    } else if (labels.format) {\n      labelText = chartService.format.auto(labels.format, labelText);\n    }\n\n    if (labels.visible && (labelText || labelText === 0)) {\n      if (labels.position === CENTER || labels.position === INSIDE_END) {\n        if (!labels.color) {\n          labels.color = autoTextColor(this.options.color);\n        }\n\n        if (!labels.background) {\n          labels.background = this.options.color;\n        }\n      } else {\n        const themeLabels = chartService.theme.seriesDefaults.labels;\n        labels.color = labels.color || themeLabels.color;\n        labels.background = labels.background || themeLabels.background;\n      }\n\n      this.label = new TextBox(labelText, deepExtend({}, labels, {\n        align: CENTER,\n        vAlign: \"\",\n        animation: {\n          type: FADEIN,\n          delay: this.animationDelay\n        }\n      }), pointData);\n      this.append(this.label);\n    }\n  }\n\n  reflow(targetBox) {\n    this.render();\n    this.box = targetBox;\n    this.reflowLabel();\n  }\n\n  reflowLabel() {\n    const {\n      options: {\n        labels: labelsOptions\n      },\n      label\n    } = this;\n    const sector = this.sector.clone();\n    const labelsDistance = labelsOptions.distance;\n    const angle = sector.middle();\n\n    if (label) {\n      const labelHeight = label.box.height();\n      const labelWidth = label.box.width();\n      let lp;\n\n      if (labelsOptions.position === CENTER) {\n        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n        lp = sector.point(angle);\n        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n      } else if (labelsOptions.position === INSIDE_END) {\n        sector.radius = sector.radius - labelHeight / 2;\n        lp = sector.point(angle);\n        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n      } else {\n        let x1;\n        lp = sector.clone().expand(labelsDistance).point(angle);\n\n        if (lp.x >= sector.center.x) {\n          x1 = lp.x + labelWidth;\n          label.orientation = RIGHT;\n        } else {\n          x1 = lp.x - labelWidth;\n          label.orientation = LEFT;\n        }\n\n        label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\n      }\n    }\n  }\n\n  createVisual() {\n    const {\n      sector,\n      options\n    } = this;\n    super.createVisual();\n\n    if (this.value) {\n      if (options.visual) {\n        const startAngle = (sector.startAngle + 180) % 360;\n        const visual = options.visual({\n          category: this.category,\n          dataItem: this.dataItem,\n          value: this.value,\n          series: this.series,\n          percentage: this.percentage,\n          center: new geom.Point(sector.center.x, sector.center.y),\n          radius: sector.radius,\n          innerRadius: sector.innerRadius,\n          startAngle: startAngle,\n          endAngle: startAngle + sector.angle,\n          options: options,\n          sender: this.getSender(),\n          createVisual: () => {\n            const group = new draw.Group();\n            this.createSegmentVisual(group);\n            return group;\n          }\n        });\n\n        if (visual) {\n          this.visual.append(visual);\n        }\n      } else {\n        this.createSegmentVisual(this.visual);\n      }\n    }\n  }\n\n  createSegmentVisual(group) {\n    const {\n      sector,\n      options\n    } = this;\n    const borderOptions = options.border || {};\n    const border = borderOptions.width > 0 ? {\n      stroke: {\n        color: borderOptions.color,\n        width: borderOptions.width,\n        opacity: borderOptions.opacity,\n        dashType: borderOptions.dashType\n      }\n    } : {};\n    const color = options.color;\n    const fill = {\n      color: color,\n      opacity: options.opacity\n    };\n    const visual = this.createSegment(sector, deepExtend({\n      fill: fill,\n      stroke: {\n        opacity: options.opacity\n      },\n      zIndex: options.zIndex\n    }, border));\n    group.append(visual);\n\n    if (hasGradientOverlay(options)) {\n      group.append(this.createGradientOverlay(visual, {\n        baseColor: color,\n        fallbackFill: fill\n      }, deepExtend({\n        center: [sector.center.x, sector.center.y],\n        innerRadius: sector.innerRadius,\n        radius: sector.radius,\n        userSpace: true\n      }, options.overlay)));\n    }\n  }\n\n  createSegment(sector, options) {\n    if (options.singleSegment) {\n      return new draw.Circle(new geom.Circle(new geom.Point(sector.center.x, sector.center.y), sector.radius), options);\n    }\n\n    return ShapeBuilder.current.createRing(sector, options);\n  }\n\n  createAnimation() {\n    const {\n      options,\n      sector: {\n        center\n      }\n    } = this;\n    deepExtend(options, {\n      animation: {\n        center: [center.x, center.y],\n        delay: this.animationDelay\n      }\n    });\n    super.createAnimation();\n  }\n\n  createHighlight(options) {\n    const highlight = this.options.highlight || {};\n    const border = highlight.border || {};\n    return this.createSegment(this.sector, deepExtend({}, options, {\n      fill: {\n        color: highlight.color,\n        opacity: highlight.opacity\n      },\n      stroke: {\n        opacity: border.opacity,\n        width: border.width,\n        color: border.color\n      }\n    }));\n  }\n\n  highlightVisual() {\n    return this.visual.children[0];\n  }\n\n  highlightVisualArgs() {\n    const sector = this.sector;\n    return {\n      options: this.options,\n      radius: sector.radius,\n      innerRadius: sector.innerRadius,\n      center: new geom.Point(sector.center.x, sector.center.y),\n      startAngle: sector.startAngle,\n      endAngle: sector.angle + sector.startAngle,\n      visual: this.visual\n    };\n  }\n\n  tooltipAnchor() {\n    const sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n    const midAndle = sector.middle();\n    const midPoint = sector.point(midAndle);\n    return {\n      point: midPoint,\n      align: tooltipAlignment(midAndle + 180)\n    };\n  }\n\n  formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  }\n\n  pointData() {\n    return {\n      dataItem: this.dataItem,\n      category: this.category,\n      value: this.value,\n      series: this.series,\n      percentage: this.percentage\n    };\n  }\n\n}\n\nconst RAD_30 = round(rad(30), DEFAULT_PRECISION);\nconst RAD_60 = round(rad(60), DEFAULT_PRECISION);\n\nfunction tooltipAlignment(angle) {\n  const radians = rad(angle);\n  const sine = round(Math.sin(radians), DEFAULT_PRECISION);\n  const cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n  let horizontal;\n\n  if (Math.abs(sine) > RAD_60) {\n    horizontal = CENTER;\n  } else if (cosine < 0) {\n    horizontal = RIGHT;\n  } else {\n    horizontal = LEFT;\n  }\n\n  let vertical;\n\n  if (Math.abs(sine) < RAD_30) {\n    vertical = CENTER;\n  } else if (sine < 0) {\n    vertical = BOTTOM;\n  } else {\n    vertical = TOP;\n  }\n\n  return {\n    horizontal: horizontal,\n    vertical: vertical\n  };\n}\n\nsetDefaultOptions(PieSegment, {\n  color: WHITE,\n  overlay: {\n    gradient: \"roundedBevel\"\n  },\n  border: {\n    width: 0.5\n  },\n  labels: {\n    visible: false,\n    distance: 35,\n    font: DEFAULT_FONT,\n    margin: getSpacing(0.5),\n    align: CIRCLE,\n    zIndex: 1,\n    position: OUTSIDE_END\n  },\n  animation: {\n    type: PIE\n  },\n  highlight: {\n    visible: true,\n    border: {\n      width: 1\n    }\n  },\n  visible: true\n});\ndeepExtend(PieSegment.prototype, PointEventsMixin);\nexport default PieSegment;","map":null,"metadata":{},"sourceType":"module"}