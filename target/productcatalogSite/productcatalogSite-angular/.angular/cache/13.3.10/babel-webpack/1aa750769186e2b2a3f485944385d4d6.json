{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1677);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  973:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./range\");\n    /***/\n  },\n\n  /***/\n  1677:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1678), __webpack_require__(973)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\"; // jshint eqnull:true\n\n      var spreadsheet = kendo.spreadsheet;\n      var Range = spreadsheet.Range;\n      var runtime = spreadsheet.calc.runtime;\n      var Formula = runtime.Formula;\n      var ERR_INCOMPATIBLE = \"incompatibleRanges\";\n      var ERR_NO_DIRECTION = \"noFillDirection\";\n\n      var FillError = Range.FillError = function (msg) {\n        this.code = msg;\n      }; // `srcRange`: the range containing data that we wish to fill.  `direction`: 0↓, 1→, 2↑, 3←.  So\n      // when bit 0 is set we're doing horizontal filling, and when bit 1 is set we're doing it in\n      // reverse order.\n\n\n      Range.prototype._previewFillFrom = function (srcRange, direction) {\n        var destRange = this,\n            sheet = destRange._sheet;\n\n        if (typeof srcRange == \"string\") {\n          srcRange = sheet.range(srcRange);\n        }\n\n        var src = srcRange._ref.toRangeRef().clone().setSheet(sheet.name());\n\n        var dest = destRange._ref.toRangeRef().clone().setSheet(sheet.name());\n\n        if (src.intersects(dest)) {\n          // the UI will send e.g. C2:C8.fillFrom(C7:D8) (intersecting ranges).  this figures out\n          // the actual destination range.\n          if (src.eq(dest)) {\n            return null; // nothing to do\n          }\n\n          dest = dest.clone();\n\n          if (src.topLeft.eq(dest.topLeft)) {\n            if (src.width() == dest.width()) {\n              dest.topLeft.row += src.height();\n              direction = 0;\n            } else if (src.height() == dest.height()) {\n              dest.topLeft.col += src.width();\n              direction = 1;\n            } else {\n              throw new FillError(ERR_INCOMPATIBLE);\n            }\n          } else if (src.bottomRight.eq(dest.bottomRight)) {\n            if (src.width() == dest.width()) {\n              dest.bottomRight.row -= src.height();\n              direction = 2;\n            } else if (src.height() == dest.height()) {\n              dest.bottomRight.col -= src.width();\n              direction = 3;\n            } else {\n              throw new FillError(ERR_INCOMPATIBLE);\n            }\n          } else {\n            throw new FillError(ERR_INCOMPATIBLE);\n          }\n\n          return sheet.range(dest)._previewFillFrom(srcRange, direction);\n        }\n\n        if (direction == null) {\n          // try to determine based on ranges location/geometry\n          if (src.topLeft.col == dest.topLeft.col) {\n            // assume vertical filling\n            direction = src.topLeft.row < dest.topLeft.row ? 0 : 2;\n          } else if (src.topLeft.row == dest.topLeft.row) {\n            direction = src.topLeft.col < dest.topLeft.col ? 1 : 3;\n          } else {\n            throw new FillError(ERR_NO_DIRECTION);\n          }\n        }\n\n        var horizontal = direction & 1;\n        var descending = direction & 2;\n\n        if (horizontal && src.height() != dest.height() || !horizontal && src.width() != dest.width()) {\n          throw new FillError(ERR_INCOMPATIBLE);\n        }\n\n        var data = srcRange._properties(),\n            n;\n\n        if (!horizontal) {\n          data = transpose(data);\n          n = dest.height();\n        } else {\n          n = dest.width();\n        }\n\n        var fill = new Array(data.length);\n        var hint = null;\n\n        for (var i = 0; i < data.length; ++i) {\n          var s = data[i];\n          var f = findSeries(s);\n          var a = fill[i] = new Array(n);\n\n          for (var j = 0; j < n; ++j) {\n            var idx = descending ? -j - 1 : s.length + j;\n            var srcIdx = descending ? s.length - j % s.length - 1 : j % s.length;\n            var cell = a[descending ? n - j - 1 : j] = f(idx, srcIdx);\n\n            if (cell.value != null) {\n              hint = cell.value;\n            }\n          }\n        }\n\n        if (!horizontal) {\n          fill = transpose(fill);\n        }\n\n        return {\n          props: fill,\n          direction: direction,\n          dest: destRange,\n          hint: hint\n        };\n      };\n\n      Range.prototype.fillFrom = function (srcRange, direction) {\n        var x = this._previewFillFrom(srcRange, direction);\n\n        x.dest._properties(x.props, true);\n\n        return x.dest;\n      }; // This is essentially the FORECAST function, see ./runtime.functions.2.js.\n      // It receives an array of values, and returns a function that \"predicts\"\n      // the value in cell N.\n\n\n      function linearRegression(data) {\n        var N = data.length;\n        var mx = (N + 1) / 2,\n            my = data.reduce(function (a, b) {\n          return a + b;\n        }, 0) / N;\n        var s1 = 0,\n            s2 = 0;\n\n        for (var i = 0; i < N; i++) {\n          var t1 = i + 1 - mx,\n              t2 = data[i] - my;\n          s1 += t1 * t2;\n          s2 += t1 * t1;\n        }\n\n        if (!s2) {\n          return function (N) {\n            return data[N % data.length];\n          };\n        }\n\n        var b = s1 / s2,\n            a = my - b * mx;\n        return function (N) {\n          return a + b * (N + 1);\n        };\n      }\n\n      function findSeries(properties) {\n        function findStep(a) {\n          var diff = a[1] - a[0];\n\n          for (var i = 2; i < a.length; ++i) {\n            if (a[i] - a[i - 1] != diff) {\n              return null;\n            }\n          }\n\n          return diff;\n        }\n\n        function getData(a) {\n          return a.map(function (v) {\n            return v.number;\n          });\n        }\n\n        var series = [];\n        var data = properties.map(function (x) {\n          return x.formula || x.value;\n        });\n        forEachSeries(data, function (begin, end, type, a) {\n          var f, values;\n\n          if (type == \"number\") {\n            values = getData(a); // This code would increase a date even if a single cell was selected.  Seems it's\n            // not desirable so I commented it out.\n            // https://github.com/telerik/kendo-ui-core/issues/3565\n            //\n            // if (values.length == 1 && (begin > 0 || end < data.length ||\n            //                            formatType(values[0], properties[begin].format) == \"date\")) {\n            //     values.push(values[0] + 1);\n            // }\n\n            f = linearRegression(values);\n          } else if (type == \"string\" || type == \"formula\" || type == \"boolean\") {\n            // formulas are simply copied over; the sheet will internally clone the objects\n            f = function (N, i) {\n              return data[i];\n            };\n          } else if (Array.isArray(type)) {\n            if (a.length == 1) {\n              f = function (N) {\n                return type[(a[0].number + N) % type.length];\n              };\n            } else {\n              // figure out the step\n              var diff = findStep(getData(a));\n\n              if (diff == null) {\n                // seemingly no pattern, just repeat those strings\n                f = function (N) {\n                  return a[N % a.length].value;\n                };\n              } else {\n                f = function (N) {\n                  var idx = a[0].number + diff * N;\n                  return type[idx % type.length];\n                };\n              }\n            }\n          } else if (type != \"null\") {\n            values = getData(a);\n\n            if (values.length == 1) {\n              values.push(values[0] + 1);\n            }\n\n            values = linearRegression(values);\n\n            f = function (N, i) {\n              return data[i].replace(/^(.*\\D)\\d+/, \"$1\" + values(N, i));\n            };\n          } else {\n            f = function () {\n              return null;\n            };\n          }\n\n          var s = {\n            f: f,\n            begin: begin,\n            end: end,\n            len: end - begin\n          };\n\n          for (var i = begin; i < end; ++i) {\n            series[i] = s;\n          }\n        });\n        return function (N, i) {\n          var s = series[i];\n          var q = N / data.length | 0;\n          var r = N % data.length;\n          var n = q * s.len + r - s.begin;\n          var value = s.f(n, i);\n          var props = clone(properties[i]);\n          delete props.enable;\n\n          if (value instanceof Formula) {\n            props.formula = value;\n          } else {\n            props.value = value;\n          }\n\n          return props;\n        };\n      } // function formatType(value, format) {\n      //     if (format != null) {\n      //         return spreadsheet.formatting.type(value, format);\n      //     }\n      // }\n\n\n      function clone(obj) {\n        var copy = {};\n        Object.keys(obj || {}).forEach(function (key) {\n          copy[key] = obj[key];\n        });\n        return copy;\n      }\n\n      function forEachSeries(data, f) {\n        var prev = null,\n            start = 0,\n            a = [],\n            type;\n\n        for (var i = 0; i < data.length; ++i) {\n          type = getType(data[i]);\n          a.push(type);\n\n          if (prev != null && type.type !== prev.type) {\n            f(start, i, prev.type, a.slice(start, i));\n            start = i;\n          }\n\n          prev = type;\n        }\n\n        f(start, i, prev.type, a.slice(start, i));\n      }\n\n      function getType(el) {\n        if (typeof el == \"number\") {\n          return {\n            type: \"number\",\n            number: el\n          };\n        }\n\n        if (typeof el == \"string\") {\n          var lst = findStringList(el);\n\n          if (lst) {\n            return lst;\n          }\n\n          var m = /^(.*\\D)(\\d+)/.exec(el);\n\n          if (m) {\n            el = el.replace(/^(.*\\D)\\d+/, \"$1-######\");\n            return {\n              type: el,\n              match: m,\n              number: parseFloat(m[2])\n            };\n          }\n\n          return {\n            type: \"string\"\n          };\n        }\n\n        if (typeof el == \"boolean\") {\n          return {\n            type: \"boolean\"\n          };\n        }\n\n        if (el == null) {\n          return {\n            type: \"null\"\n          };\n        }\n\n        if (el instanceof Formula) {\n          return {\n            type: \"formula\"\n          };\n        }\n\n        window.console.error(el);\n        throw new Error(\"Cannot fill data\");\n      }\n\n      function stringLists() {\n        var culture = kendo.culture();\n        return [culture.calendars.standard.days.namesAbbr, culture.calendars.standard.days.names, culture.calendars.standard.months.namesAbbr, culture.calendars.standard.months.names];\n      }\n\n      function findStringList(str) {\n        var strl = str.toLowerCase();\n        var lists = stringLists();\n\n        for (var i = 0; i < lists.length; ++i) {\n          var a = lists[i];\n\n          for (var j = a.length; --j >= 0;) {\n            var el = a[j].toLowerCase();\n\n            if (el == strl) {\n              return {\n                type: a,\n                number: j,\n                value: str\n              };\n            }\n          }\n        }\n      }\n\n      function transpose(a) {\n        var height = a.length,\n            width = a[0].length;\n        var t = [];\n\n        for (var i = 0; i < width; ++i) {\n          t[i] = [];\n\n          for (var j = 0; j < height; ++j) {\n            t[i][j] = a[j][i];\n          }\n        }\n\n        return t;\n      }\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}