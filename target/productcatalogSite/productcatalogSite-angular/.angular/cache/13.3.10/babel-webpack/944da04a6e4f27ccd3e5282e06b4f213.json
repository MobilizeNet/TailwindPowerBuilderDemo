{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1496);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1058:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.dom\");\n    /***/\n  },\n\n  /***/\n  1063:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data\");\n    /***/\n  },\n\n  /***/\n  1092:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.selectable\");\n    /***/\n  },\n\n  /***/\n  1119:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.filtermenu\");\n    /***/\n  },\n\n  /***/\n  1217:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.resizable\");\n    /***/\n  },\n\n  /***/\n  1218:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.window\");\n    /***/\n  },\n\n  /***/\n  1279:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.editable\");\n    /***/\n  },\n\n  /***/\n  1294:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.treeview.draganddrop\");\n    /***/\n  },\n\n  /***/\n  1298:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.columnsorter\");\n    /***/\n  },\n\n  /***/\n  1299:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.filtercell\");\n    /***/\n  },\n\n  /***/\n  1300:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.columnmenu\");\n    /***/\n  },\n\n  /***/\n  1302:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.pager\");\n    /***/\n  },\n\n  /***/\n  1496:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1058), __webpack_require__(1063), __webpack_require__(1298), __webpack_require__(1279), __webpack_require__(1218), __webpack_require__(1119), __webpack_require__(1300), __webpack_require__(1092), __webpack_require__(1217), __webpack_require__(1294), __webpack_require__(1302), __webpack_require__(1299)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"treelist\",\n        name: \"TreeList\",\n        category: \"web\",\n        description: \"The TreeList widget displays self-referencing data and offers rich support for interacting with data, sorting, filtering, and selection.\",\n        depends: [\"dom\", \"data\", \"pager\"],\n        features: [{\n          id: \"treelist-sorting\",\n          name: \"Sorting\",\n          description: \"Support for column sorting\",\n          depends: [\"columnsorter\"]\n        }, {\n          id: \"treelist-filtering\",\n          name: \"Filtering\",\n          description: \"Support for record filtering\",\n          depends: [\"filtermenu\"]\n        }, {\n          id: \"treelist-columnmenu\",\n          name: \"Column menu\",\n          description: \"Support for header column menu\",\n          depends: [\"columnmenu\"]\n        }, {\n          id: \"treelist-editing\",\n          name: \"Editing\",\n          description: \"Support for record editing\",\n          depends: [\"editable\", \"window\"]\n        }, {\n          id: \"treelist-selection\",\n          name: \"Selection\",\n          description: \"Support for row selection\",\n          depends: [\"selectable\"]\n        }, {\n          id: \"treelist-column-resize\",\n          name: \"Column resizing\",\n          description: \"Support for column resizing\",\n          depends: [\"resizable\"]\n        }, {\n          id: \"treelist-dragging\",\n          name: \"Drag & Drop\",\n          description: \"Support for drag & drop of rows\",\n          depends: [\"treeview.draganddrop\"]\n        }, {\n          id: \"treelist-excel-export\",\n          name: \"Excel export\",\n          description: \"Export data as Excel spreadsheet\",\n          depends: [\"excel\"]\n        }, {\n          id: \"treelist-pdf-export\",\n          name: \"PDF export\",\n          description: \"Export data as PDF\",\n          depends: [\"pdf\", \"drawing\"]\n        }, {\n          id: \"treelist-paging\",\n          name: \"Paging\",\n          description: \"Support for treelist paging\",\n          depends: [\"pager\"]\n        }]\n      };\n\n      (function ($, undefined) {\n        var data = kendo.data;\n        var kendoDom = kendo.dom;\n        var kendoDomElement = kendoDom.element;\n        var kendoTextElement = kendoDom.text;\n        var kendoHtmlElement = kendoDom.html;\n        var outerWidth = kendo._outerWidth;\n        var keys = kendo.keys;\n        var outerHeight = kendo._outerHeight;\n        var ui = kendo.ui;\n        var DataBoundWidget = ui.DataBoundWidget;\n        var DataSource = data.DataSource;\n        var ObservableArray = data.ObservableArray;\n        var Query = data.Query;\n        var Model = data.Model;\n        var browser = kendo.support.browser;\n        var kendoTemplate = kendo.template;\n        var activeElement = kendo._activeElement;\n        var touchDevice = kendo.support.touch;\n        var isArray = Array.isArray;\n        var extend = $.extend;\n        var map = $.map;\n        var grep = $.grep;\n        var inArray = $.inArray;\n        var isPlainObject = $.isPlainObject;\n        var push = Array.prototype.push;\n        var STRING = \"string\";\n        var CHANGE = \"change\";\n        var ITEM_CHANGE = \"itemChange\";\n        var ERROR = \"error\";\n        var PROGRESS = \"progress\";\n        var DOT = \".\";\n        var NS = \".kendoTreeList\";\n        var CLICK = \"click\";\n        var INPUT = \"input\";\n        var BEFORE_EDIT = \"beforeEdit\";\n        var EDIT = \"edit\";\n        var PAGE = \"page\";\n        var PAGE_CHANGE = \"pageChange\";\n        var SAVE = \"save\";\n        var SAVE_CHANGES = \"saveChanges\";\n        var SORT = \"sort\";\n        var EXPAND = \"expand\";\n        var COLLAPSE = \"collapse\";\n        var CELL_CLOSE = \"cellClose\";\n        var REMOVE = \"remove\";\n        var DATA_CELL = \"td:not(.k-group-cell):not(.k-hierarchy-cell):visible\";\n        var FILTER_CELL = \".k-filter-row th:not(.k-group-cell):not(.k-hierarchy-cell):visible\";\n        var DATABINDING = \"dataBinding\";\n        var DATABOUND = \"dataBound\";\n        var CANCEL = \"cancel\";\n        var TABINDEX = \"tabIndex\";\n        var FILTERMENUINIT = \"filterMenuInit\";\n        var FILTERMENUOPEN = \"filterMenuOpen\";\n        var COLUMNHIDE = \"columnHide\";\n        var COLUMNSHOW = \"columnShow\";\n        var HEADERCELLS = \"th.k-header\";\n        var COLUMNREORDER = \"columnReorder\";\n        var COLUMNRESIZE = \"columnResize\";\n        var COLUMNMENUINIT = \"columnMenuInit\";\n        var COLUMNMENUOPEN = \"columnMenuOpen\";\n        var COLUMNLOCK = \"columnLock\";\n        var COLUMNUNLOCK = \"columnUnlock\";\n        var PARENTIDFIELD = \"parentId\";\n        var DRAGSTART = \"dragstart\";\n        var DRAG = \"drag\";\n        var DROP = \"drop\";\n        var DRAGEND = \"dragend\";\n        var NAVROW = \"tr:visible\";\n        var NAVCELL = \"td:visible\";\n        var NAVHEADER = \"th:visible\";\n        var NORECORDSCLASS = \"k-grid-norecords\";\n        var ITEMROW = \"tr:not(.k-footer-template):visible\";\n        var isRtl = false;\n        var HEIGHT = \"height\";\n        var INCELL = \"incell\";\n        var INLINE = \"inline\";\n        var POPUP = \"popup\";\n        var TABLE = \"table\";\n        var CHECKBOX = \"k-checkbox\";\n        var CHECKBOXINPUT = \"input[data-role='checkbox'].\" + CHECKBOX;\n        var SELECTCOLUMNTMPL = '<input class=\"' + CHECKBOX + ' k-checkbox-md k-rounded-md\" data-role=\"checkbox\" aria-label=\"Select row\" aria-checked=\"false\" type=\"checkbox\">';\n        var SELECTCOLUMNHEADERTMPL = '<input class=\"' + CHECKBOX + ' k-checkbox-md k-rounded-md\" data-role=\"checkbox\" aria-label=\"Select all rows\" aria-checked=\"false\" type=\"checkbox\">';\n        var SELECTED = \"k-state-selected\";\n        var whitespaceRegExp = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n        var filterRowRegExp = new RegExp(\"(^|\" + whitespaceRegExp + \")\" + \"(k-filter-row)\" + \"(\" + whitespaceRegExp + \"|$)\");\n        var classNames = {\n          wrapper: \"k-treelist k-grid k-widget k-grid-display-block\",\n          header: \"k-header\",\n          button: \"k-button\",\n          alt: \"k-alt\",\n          editCell: \"k-edit-cell\",\n          editRow: \"k-grid-edit-row\",\n          dirtyCell: \"k-dirty-cell\",\n          group: \"k-treelist-group\",\n          toolbar: \"k-toolbar\",\n          gridToolbar: \"k-grid-toolbar\",\n          gridHeader: \"k-grid-header\",\n          gridHeaderWrap: \"k-grid-header-wrap\",\n          gridContent: \"k-grid-content\",\n          gridContentWrap: \"k-grid-content\",\n          gridFilter: \"k-grid-filter\",\n          footerTemplate: \"k-footer-template\",\n          focused: \"k-state-focused\",\n          loading: \"k-i-loading\",\n          refresh: \"k-i-reload\",\n          retry: \"k-request-retry\",\n          selected: \"k-state-selected\",\n          status: \"k-status\",\n          link: \"k-link\",\n          filterable: \"k-filterable\",\n          icon: \"k-icon\",\n          iconFilter: \"k-i-filter\",\n          iconCollapse: \"k-i-collapse\",\n          iconExpand: \"k-i-expand\",\n          iconHidden: \"k-i-none\",\n          iconPlaceHolder: \"k-icon k-i-none\",\n          input: \"k-input\",\n          dropPositions: \"k-i-insert-up k-i-insert-down k-i-plus k-i-insert-middle\",\n          dropTop: \"k-i-insert-up\",\n          dropBottom: \"k-i-insert-down\",\n          dropAdd: \"k-i-plus\",\n          dropMiddle: \"k-i-insert-middle\",\n          dropDenied: \"k-i-cancel\",\n          dragStatus: \"k-drag-status\",\n          dragClue: \"k-drag-clue\",\n          dragClueText: \"k-clue-text\",\n          headerCellInner: \"k-cell-inner\",\n          columnTitle: \"k-column-title\"\n        };\n        var defaultCommands = {\n          create: {\n            imageClass: \"k-i-plus\",\n            className: \"k-grid-add\",\n            methodName: \"addRow\"\n          },\n          createchild: {\n            imageClass: \"k-i-plus\",\n            className: \"k-grid-add\",\n            methodName: \"addRow\"\n          },\n          destroy: {\n            imageClass: \"k-i-close\",\n            className: \"k-grid-delete\",\n            methodName: \"removeRow\"\n          },\n          edit: {\n            imageClass: \"k-i-edit\",\n            className: \"k-grid-edit\",\n            methodName: \"editRow\"\n          },\n          update: {\n            imageClass: \"k-i-check\",\n            className: \"k-button-solid-primary k-grid-update\",\n            methodName: \"saveRow\"\n          },\n          canceledit: {\n            imageClass: \"k-i-cancel\",\n            className: \"k-grid-cancel\",\n            methodName: \"_cancelEdit\"\n          },\n          cancel: {\n            imageClass: \"k-icon k-i-cancel\",\n            text: \"Cancel changes\",\n            className: \"k-grid-cancel-changes\",\n            methodName: \"cancelChanges\"\n          },\n          save: {\n            imageClass: \"k-icon k-i-check\",\n            text: \"Save changes\",\n            className: \"k-grid-save-changes\",\n            methodName: \"saveChanges\"\n          },\n          excel: {\n            imageClass: \"k-i-file-excel\",\n            className: \"k-grid-excel\",\n            methodName: \"saveAsExcel\"\n          },\n          pdf: {\n            imageClass: \"k-i-file-pdf\",\n            className: \"k-grid-pdf\",\n            methodName: \"saveAsPDF\"\n          },\n          search: {\n            template: \"<span class='k-spacer'></span>\" + \"<span class='k-searchbox k-input k-input-md k-rounded-md k-input-solid k-grid-search'>\" + \"<span class='k-input-icon k-icon k-i-search'></span>\" + \"<input autocomplete='off' placeholder='\" + \"#= message #\" + \"' title='\" + \"#= message #\" + \"' class='k-input-inner' />\" + \"</span>\"\n          }\n        };\n        var TreeView = kendo.Class.extend({\n          init: function (data, options) {\n            var that = this;\n            that.data = data || [];\n            that.options = extend(that.options, options);\n          },\n          options: {\n            defaultParentId: null,\n            idField: \"id\",\n            parentIdField: PARENTIDFIELD\n          },\n          childrenMap: function () {\n            var that = this;\n            var childrenMap = {};\n            var dataLength = that.data.length;\n            var dataItem;\n            var dataItemId;\n            var dataItemParentId;\n            var idField = that.options.idField;\n            var parentIdField = that.options.parentIdField;\n\n            if (that._childrenMap) {\n              return that._childrenMap;\n            }\n\n            for (var i = 0; i < dataLength; i++) {\n              dataItem = this.data[i];\n              dataItemId = dataItem[idField];\n              dataItemParentId = dataItem[parentIdField];\n              childrenMap[dataItemId] = childrenMap[dataItemId] || [];\n              childrenMap[dataItemParentId] = childrenMap[dataItemParentId] || [];\n              childrenMap[dataItemParentId].push(dataItem);\n            }\n\n            that._childrenMap = childrenMap;\n            return childrenMap;\n          },\n          idsMap: function () {\n            var that = this;\n            var idsMap = {};\n            var data = that.data;\n            var dataLength = data.length;\n            var dataItem;\n            var idField = that.options.idField;\n\n            if (that._idMap) {\n              return that._idMap;\n            }\n\n            for (var i = 0; i < dataLength; i++) {\n              dataItem = data[i];\n              idsMap[dataItem[idField]] = dataItem;\n            }\n\n            that.idsMap = idsMap;\n            return idsMap;\n          },\n          dataMaps: function () {\n            var that = this;\n            var childrenMap = {};\n            var data = that.data;\n            var dataLength = data.length;\n            var idsMap = {};\n            var dataItem;\n            var dataItemId;\n            var dataItemParentId;\n            var idField = that.options.idField;\n            var parentIdField = that.options.parentIdField;\n\n            if (that._dataMaps) {\n              return that._dataMaps;\n            }\n\n            for (var i = 0; i < dataLength; i++) {\n              dataItem = data[i];\n              dataItemId = dataItem[idField];\n              dataItemParentId = dataItem[parentIdField];\n              idsMap[dataItemId] = dataItem;\n              childrenMap[dataItemId] = childrenMap[dataItemId] || [];\n              childrenMap[dataItemParentId] = childrenMap[dataItemParentId] || [];\n              childrenMap[dataItemParentId].push(dataItem);\n            }\n\n            that._dataMaps = {\n              children: childrenMap,\n              ids: idsMap\n            };\n            return that._dataMaps;\n          },\n          rootNodes: function () {\n            var that = this;\n            var data = that.data;\n            var defaultParentId = that.options.defaultParentId;\n            var dataLength = data.length;\n            var rootNodes = [];\n            var dataItem;\n            var parentIdField = that.options.parentIdField;\n\n            for (var i = 0; i < dataLength; i++) {\n              dataItem = data[i];\n\n              if (dataItem[parentIdField] === defaultParentId) {\n                rootNodes.push(dataItem);\n              }\n            }\n\n            return rootNodes;\n          },\n          removeCollapsedSubtreesFromRootNodes: function (options) {\n            options = options || {};\n            var that = this;\n            var rootNodes = that.rootNodes();\n            var result = [];\n            var prunedTree;\n            that._childrenMap = options.childrenMap = options.childrenMap || that.childrenMap();\n            options.maxDepth = options.maxDepth || Infinity;\n\n            for (var i = 0; i < rootNodes.length; i++) {\n              prunedTree = that.removeCollapsedSubtrees(rootNodes[i], options);\n              result = result.concat(prunedTree);\n            }\n\n            return result;\n          },\n          removeCollapsedSubtrees: function (rootNode, options) {\n            options = options || {};\n            var that = this;\n            var result = [];\n            var childIdx;\n            var prunedTree;\n            var childrenMap = options.childrenMap || {};\n            var maxDepth = options.maxDepth || Infinity;\n            var idField = that.options.idField;\n            var children = childrenMap[rootNode[idField]] || [];\n            var expanded = isUndefined(rootNode.expanded) ? options.expanded : rootNode.expanded;\n            result.push(rootNode);\n\n            if (children && expanded) {\n              for (childIdx = 0; childIdx < children.length; childIdx++) {\n                if (result.length >= maxDepth) {\n                  break;\n                }\n\n                prunedTree = that.removeCollapsedSubtrees(children[childIdx], options);\n                result = result.concat(prunedTree);\n              }\n            }\n\n            return result;\n          }\n        });\n\n        var TreeQuery = function (data) {\n          this.data = data || [];\n        };\n\n        TreeQuery.prototype = new Query();\n        TreeQuery.prototype.constructor = TreeQuery;\n\n        TreeQuery.process = function (data, options, inPlace) {\n          options = options || {};\n          var query = new TreeQuery(data);\n          var group = options.group;\n          var sort = Query.normalizeGroup(group || []).concat(Query.normalizeSort(options.sort || []));\n          var filterCallback = options.filterCallback;\n          var filter = options.filter;\n          var skip = options.skip;\n          var take = options.take;\n          var total;\n          var childrenMap;\n          var filteredChildrenMap;\n          var view;\n          var prunedData;\n\n          if (sort && inPlace) {\n            query = query.sort(sort, undefined, undefined, inPlace);\n          }\n\n          if (filter) {\n            query = query.filter(filter);\n\n            if (filterCallback) {\n              query = filterCallback(query);\n            }\n\n            total = query.toArray().length;\n          }\n\n          if (sort && !inPlace) {\n            query = query.sort(sort);\n\n            if (group) {\n              data = query.toArray();\n            }\n          }\n\n          if (options.processFromRootNodes) {\n            view = new TreeView(query.toArray(), options);\n\n            if (filter) {\n              filteredChildrenMap = view.childrenMap();\n            }\n\n            prunedData = view.removeCollapsedSubtreesFromRootNodes({\n              // filtering or sorting requires changes to childrenMap\n              childrenMap: filter || sort && sort.length ? undefined : options.childrenMap,\n              expanded: options.expanded,\n              maxDepth: skip + take || Infinity\n            });\n            childrenMap = view.childrenMap();\n            query = new TreeQuery(prunedData);\n          }\n\n          if (skip !== undefined && take !== undefined) {\n            query = query.range(skip, take);\n          }\n\n          if (group) {\n            query = query.group(group, data);\n          }\n\n          return {\n            total: total,\n            data: query.toArray(),\n            childrenMap: childrenMap,\n            filteredChildrenMap: filteredChildrenMap\n          };\n        };\n\n        var TreeListModel = Model.define({\n          id: \"id\",\n          parentId: PARENTIDFIELD,\n          fields: {\n            id: {\n              type: \"number\"\n            },\n            parentId: {\n              type: \"number\",\n              nullable: true\n            }\n          },\n          init: function (value) {\n            Model.fn.init.call(this, value);\n            this._loaded = false;\n\n            if (!this.parentIdField) {\n              this.parentIdField = PARENTIDFIELD;\n            }\n\n            this.parentId = this.get(this.parentIdField);\n          },\n          accept: function (data) {\n            Model.fn.accept.call(this, data);\n            this.parentId = this.get(this.parentIdField);\n          },\n          set: function (field, value, initiator) {\n            if (field == PARENTIDFIELD && this.parentIdField != PARENTIDFIELD) {\n              this[this.parentIdField] = value;\n            }\n\n            Model.fn.set.call(this, field, value, initiator);\n\n            if (field == this.parentIdField) {\n              this.parentId = this.get(this.parentIdField);\n            }\n          },\n          loaded: function (value) {\n            if (value !== undefined) {\n              this._loaded = value;\n            } else {\n              return this._loaded;\n            }\n          },\n          shouldSerialize: function (field) {\n            return Model.fn.shouldSerialize.call(this, field) && field !== \"_loaded\" && field != \"_error\" && field != \"_edit\" && !(this.parentIdField !== \"parentId\" && field === \"parentId\");\n          }\n        });\n        TreeListModel.parentIdField = PARENTIDFIELD;\n\n        TreeListModel.define = function (base, options) {\n          if (options === undefined) {\n            options = base;\n            base = TreeListModel;\n          }\n\n          var parentId = options.parentId || PARENTIDFIELD;\n          options.parentIdField = parentId;\n          var model = Model.define(base, options);\n\n          if (parentId) {\n            model.parentIdField = parentId;\n          }\n\n          return model;\n        };\n\n        function is(field) {\n          return function (object) {\n            return object[field];\n          };\n        }\n\n        function not(func) {\n          return function (object) {\n            return !func(object);\n          };\n        }\n\n        var TreeListDataSource = DataSource.extend({\n          init: function (options) {\n            options = options || {};\n            var that = this;\n            that._dataMaps = that._getDataMaps();\n            options.schema = extend(true, {}, {\n              modelBase: TreeListModel,\n              model: TreeListModel\n            }, options.schema);\n            DataSource.fn.init.call(this, options);\n          },\n          _addRange: function () {// empty override for performance - the treelist does not support virtualization\n          },\n          _createNewModel: function (data) {\n            var that = this;\n            var model = {};\n            var fromModel = data instanceof Model;\n\n            var parentIdField = this._modelParentIdField();\n\n            if (fromModel) {\n              model = data;\n            }\n\n            model = DataSource.fn._createNewModel.call(this, model);\n\n            if (!fromModel) {\n              if (data.parentId) {\n                data[model.parentIdField] = data.parentId;\n              } else if (that._isPageable() && data[parentIdField]) {\n                data[model.parentIdField] = data[parentIdField];\n              }\n\n              model.accept(data);\n            }\n\n            return model;\n          },\n          _shouldWrap: function () {\n            return true;\n          },\n          _push: function (result, operation) {\n            var data = DataSource.fn._readData.call(this, result);\n\n            if (!data) {\n              data = result;\n            }\n\n            this[operation](data);\n          },\n          _getData: function () {\n            // do not use .data(), which wraps the data items\n            return this._data || [];\n          },\n          _readData: function (newData) {\n            var that = this;\n            var data = that._isPageable() ? that._getData().toJSON() : that.data();\n            newData = DataSource.fn._readData.call(this, newData);\n\n            this._replaceData((data.toJSON ? data.toJSON() : data).concat(newData), data);\n\n            if (newData instanceof ObservableArray) {\n              return newData;\n            }\n\n            return data;\n          },\n          _replaceData: function (source, target) {\n            var sourceLength = source.length;\n\n            for (var i = 0; i < sourceLength; i++) {\n              target[i] = source[i];\n            }\n\n            target.length = sourceLength;\n          },\n          _readAggregates: function (data) {\n            var result = extend(this._aggregateResult, this.reader.aggregates(data));\n\n            if (\"\" in result) {\n              result[this._defaultParentId()] = result[\"\"];\n              delete result[\"\"];\n            }\n\n            return result;\n          },\n          read: function (data) {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._dataMaps = {};\n\n              if (!that._modelOptions().expanded) {\n                that._skip = 0;\n                that._page = 1;\n                that._collapsedTotal = undefined;\n              }\n            }\n\n            return DataSource.fn.read.call(that, data);\n          },\n          remove: function (root) {\n            this._removeChildData(root);\n\n            this._removeFromDataMaps(root);\n\n            return DataSource.fn.remove.call(this, root);\n          },\n          _removeChildData: function (model, removePristine) {\n            var that = this;\n\n            var pageable = that._isPageable();\n\n            var data = pageable ? this._getData() : this.data();\n            var childrenMap = pageable ? that._getChildrenMap() || that.childrenMap(data) : that._childrenMap(data);\n\n            var items = this._subtree(childrenMap, model.id);\n\n            var shouldRemovePristine = isUndefined(removePristine) ? false : removePristine;\n\n            var removedItems = this._removeItems(items, shouldRemovePristine);\n\n            that._removeFromDataMaps(removedItems);\n          },\n          pushDestroy: function (items) {\n            var that = this;\n\n            if (!isArray(items)) {\n              items = [items];\n            }\n\n            for (var i = 0; i < items.length; i++) {\n              that._removeChildData(items[i], true);\n\n              that._removeFromDataMaps(items[i]);\n            }\n\n            DataSource.fn.pushDestroy.call(that, items);\n          },\n          insert: function (index, model) {\n            var that = this;\n\n            var newModel = that._createNewModel(model);\n\n            that._insertInDataMaps(newModel);\n\n            return DataSource.fn.insert.call(that, index, newModel);\n          },\n          _filterCallback: function (query) {\n            var that = this;\n            var i, item;\n            var map = {};\n            var result = [];\n            var data = query.toArray();\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var pageable = that._isPageable();\n\n            var parentSubtree = [];\n            var parent;\n\n            for (i = 0; i < data.length; i++) {\n              item = data[i];\n\n              if (pageable) {\n                // return view from root nodes to child nodes\n                parentSubtree = [];\n\n                if (!map[item[idField]]) {\n                  map[item[idField]] = true;\n                  parentSubtree.push(item);\n                }\n\n                parent = that._parentNode(item);\n\n                while (parent) {\n                  if (!map[parent[idField]]) {\n                    map[parent[idField]] = true;\n                    parentSubtree.unshift(parent);\n                    parent = that._parentNode(parent);\n                  } else {\n                    // the parent chain is already processed\n                    break;\n                  }\n                }\n\n                if (parentSubtree.length) {\n                  result = result.concat(parentSubtree);\n                }\n              } else {\n                while (item) {\n                  if (!map[item[idField]]) {\n                    map[item[idField]] = true;\n                    result.push(item);\n                  }\n\n                  if (!map[item[parentIdField]]) {\n                    map[item[parentIdField]] = true;\n                    item = this.parentNode(item);\n\n                    if (item) {\n                      result.push(item);\n                    }\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n\n            return new Query(result);\n          },\n          _subtree: function (map, id) {\n            var that = this;\n            var result = map[id] || [];\n\n            var defaultParentId = that._defaultParentId();\n\n            var idField = that._modelIdField();\n\n            for (var i = 0, len = result.length; i < len; i++) {\n              if (result[i][idField] !== defaultParentId) {\n                result = result.concat(that._subtree(map, result[i][idField]));\n              }\n            }\n\n            return result;\n          },\n          // builds hash id -> children\n          _childrenMap: function (data) {\n            var map = {};\n            var i, item, id, parentId;\n            data = this._observeView(data);\n\n            for (i = 0; i < data.length; i++) {\n              item = data[i];\n              id = item.id;\n              parentId = item.parentId;\n              map[id] = map[id] || [];\n              map[parentId] = map[parentId] || [];\n              map[parentId].push(item);\n            }\n\n            return map;\n          },\n          childrenMap: function (data) {\n            var view = this._createTreeView(data);\n\n            var map = view.childrenMap();\n            return map;\n          },\n          _getChildrenMap: function () {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            return dataMaps.children;\n          },\n          _initIdsMap: function (data) {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            if (isUndefined(dataMaps.ids)) {\n              dataMaps.ids = that._idsMap(data);\n            }\n\n            return dataMaps.ids;\n          },\n          _idsMap: function (data) {\n            var view = this._createTreeView(data);\n\n            var map = view.idsMap();\n            return map;\n          },\n          _getIdsMap: function () {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            return dataMaps.ids || {};\n          },\n          _getFilteredChildrenMap: function () {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            return dataMaps.filteredChildren;\n          },\n          _setFilteredChildrenMap: function (map) {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            dataMaps.filteredChildren = map;\n          },\n          _initDataMaps: function (data) {\n            var that = this;\n\n            var view = that._createTreeView(data);\n\n            that._dataMaps = view.dataMaps();\n            return that._dataMaps;\n          },\n          _initChildrenMapForParent: function (parent) {\n            var that = this;\n\n            var data = that._getData();\n\n            var childrenMap = that._getChildrenMap();\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var parentId = (parent || {})[idField];\n\n            if (childrenMap && parent) {\n              childrenMap[parentId] = [];\n\n              for (var i = 0; i < data.length; i++) {\n                if (data[i][parentIdField] === parentId) {\n                  childrenMap[parentId].push(data[i]);\n                }\n              }\n            }\n          },\n          _getDataMaps: function () {\n            var that = this;\n            that._dataMaps = that._dataMaps || {};\n            return that._dataMaps;\n          },\n          _createTreeView: function (data, options) {\n            var view = new TreeView(data, extend(options, this._defaultTreeModelOptions()));\n            return view;\n          },\n          _defaultTreeModelOptions: function () {\n            var that = this;\n\n            var modelOptions = that._modelOptions();\n\n            return {\n              defaultParentId: that._defaultParentId(),\n              idField: that._modelIdField(),\n              parentIdField: that._modelParentIdField(),\n              expanded: modelOptions.expanded\n            };\n          },\n          _defaultDataItemType: function () {\n            return this.reader.model || kendo.data.ObservableObject;\n          },\n          _calculateAggregates: function (data, options) {\n            options = options || {};\n            var that = this;\n            var result = {};\n            var item, subtree, i;\n            var filter = options.filter;\n            var skip = options.skip;\n            var take = options.take;\n            var maxDepth = !isUndefined(skip) && !isUndefined(take) ? skip + take : Infinity;\n\n            var pageable = that._isPageable();\n\n            var filteredChildrenMap = options.filteredChildrenMap;\n            var childrenMap = options.childrenMap;\n            var pageableChildrenMap;\n\n            if (pageable) {\n              if (isUndefined(options.aggregate)) {\n                return result;\n              }\n\n              if (filteredChildrenMap) {\n                pageableChildrenMap = filteredChildrenMap;\n              } else if (childrenMap) {\n                pageableChildrenMap = childrenMap;\n              } else {\n                pageableChildrenMap = that.childrenMap(that._getData());\n              }\n            }\n\n            if (!pageable && filter) {\n              data = Query.process(data, {\n                filter: filter,\n                filterCallback: this._filterCallback.bind(this)\n              }).data;\n            }\n\n            var map = pageable ? pageableChildrenMap : that._childrenMap(data); // calculate aggregates for each subtree\n\n            result[this._defaultParentId()] = new Query(this._subtree(map, this._defaultParentId())).aggregate(options.aggregate);\n\n            for (i = 0; i < data.length; i++) {\n              if (i >= maxDepth) {\n                break;\n              }\n\n              item = data[i];\n              subtree = this._subtree(map, item.id);\n              result[item.id] = new Query(subtree).aggregate(options.aggregate);\n            }\n\n            return result;\n          },\n          _queryProcess: function (data, options) {\n            var that = this;\n            var result = {};\n            options = options || {};\n            options.filterCallback = this._filterCallback.bind(this);\n\n            if (that._isPageable()) {\n              return that._processPageableQuery(data, options);\n            } else {\n              var defaultParentId = this._defaultParentId();\n\n              result = Query.process(data, options);\n\n              var map = this._childrenMap(result.data);\n\n              var hasLoadedChildren, i, item, children;\n              data = map[defaultParentId] || [];\n\n              for (i = 0; i < data.length; i++) {\n                item = data[i];\n\n                if (item.id === defaultParentId) {\n                  continue;\n                }\n\n                children = map[item.id];\n                hasLoadedChildren = !!(children && children.length);\n\n                if (!item.loaded()) {\n                  item.loaded(hasLoadedChildren || !item.hasChildren);\n                }\n\n                if (item.loaded() || item.hasChildren !== true) {\n                  item.hasChildren = hasLoadedChildren;\n                }\n\n                if (hasLoadedChildren) {\n                  //cannot use splice due to IE8 bug\n                  data = data.slice(0, i + 1).concat(children, data.slice(i + 1));\n                }\n              }\n\n              result.data = data;\n            }\n\n            return result;\n          },\n          _processPageableQuery: function (data, options) {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            var result;\n            var filteredChildrenMap;\n\n            if (that._getData() !== data || !dataMaps.children || !dataMaps.ids) {\n              dataMaps = that._initDataMaps(that._getData());\n            }\n\n            options.childrenMap = dataMaps.children || {};\n            options.idsMap = dataMaps.ids || {};\n            result = that._processTreeQuery(data, options);\n\n            that._replaceWithObservedData(result.data, data);\n\n            that._processDataItemsState(result.data, result.childrenMap);\n\n            that._replaceItemsInDataMaps(result.data);\n\n            result.dataToAggregate = that._dataToAggregate(result.data, options);\n\n            if (options.filter || that.filter()) {\n              filteredChildrenMap = result.filteredChildrenMap;\n\n              that._replaceInMapWithObservedData(filteredChildrenMap, data);\n\n              that._setFilteredChildrenMap(filteredChildrenMap);\n\n              options.filteredChildrenMap = filteredChildrenMap;\n\n              that._calculateCollapsedTotal(result.data);\n            } else {\n              that._collapsedTotal = undefined;\n            }\n\n            return result;\n          },\n          _dataToAggregate: function (data) {\n            var that = this;\n            var firstDataItem = data[0] || {};\n\n            var firstItemParents = that._parentNodes(firstDataItem);\n\n            var dataToAggregate = firstItemParents.concat(data);\n            return dataToAggregate;\n          },\n          _replaceItemsInDataMaps: function (observableArray) {\n            var that = this;\n            var view = isArray(observableArray) ? observableArray : [observableArray];\n\n            var itemType = that._defaultDataItemType();\n\n            var defaultParentId = that._defaultParentId();\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var dataMaps = that._getDataMaps();\n\n            var item;\n            var parents;\n            var directParent;\n\n            for (var viewIndex = 0; viewIndex < view.length; viewIndex++) {\n              item = view[viewIndex];\n\n              if (!(item instanceof itemType)) {\n                continue;\n              }\n\n              that._insertInIdsMap(item);\n\n              parents = that._parentNodes(item);\n              directParent = parents && parents.length ? parents[parents.length - 1] : undefined;\n\n              if (item[parentIdField] === defaultParentId) {\n                that._replaceInMap(dataMaps.children, defaultParentId, item, itemType);\n              } else if (directParent) {\n                that._replaceInMap(dataMaps.children, directParent[idField], item, itemType);\n              }\n            }\n          },\n          _replaceInMap: function (map, id, replacement, itemType) {\n            var idField = this._modelIdField();\n\n            map[id] = map[id] || [];\n            itemType = itemType || this._defaultDataItemType();\n            var itemInArray = map[id].filter(function (element) {\n              return replacement[idField] === element[idField];\n            })[0];\n            var itemIndex = itemInArray ? map[id].indexOf(itemInArray) : -1;\n\n            if (itemIndex !== -1 && !(itemInArray instanceof itemType)) {\n              map[id][itemIndex] = replacement;\n            }\n          },\n          _replaceWithObservedData: function (dataToReplace, replacementArray) {\n            var that = this;\n            var idsMap = that._getDataMaps().ids || {};\n\n            var idField = that._modelIdField();\n\n            var itemType = that._defaultDataItemType();\n\n            var itemToReplace;\n            var itemToReplaceId;\n            var dataItem;\n            var dataItemIndex;\n            var observableItem;\n\n            for (var i = 0; i < dataToReplace.length; i++) {\n              itemToReplace = dataToReplace[i];\n              itemToReplaceId = itemToReplace[idField];\n\n              if (!(itemToReplace instanceof itemType)) {\n                if (!(idsMap[itemToReplaceId] instanceof itemType)) {\n                  dataItem = that._getById(itemToReplaceId);\n                  dataItemIndex = replacementArray.indexOf(dataItem);\n\n                  if (dataItem && dataItemIndex !== -1) {\n                    observableItem = replacementArray.at(dataItemIndex);\n                    dataToReplace[i] = observableItem;\n                  }\n                } else {\n                  dataToReplace[i] = idsMap[itemToReplaceId];\n                }\n              }\n            }\n          },\n          _replaceInMapWithObservedData: function (map, replacementArray) {\n            var that = this;\n\n            for (var key in map) {\n              that._replaceWithObservedData(map[key], replacementArray);\n            }\n          },\n          _insertInDataMaps: function (item) {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._insertInIdsMap(item);\n\n              that._insertInChildrenMap(item);\n            }\n          },\n          _insertInIdsMap: function (item) {\n            var that = this;\n\n            var idsMap = that._getIdsMap();\n\n            var idField = that._modelIdField();\n\n            if (!isUndefined(item[idField])) {\n              idsMap[item[idField]] = item;\n            }\n          },\n          _insertInChildrenMap: function (item, index) {\n            var that = this;\n            var childrenMap = that._getChildrenMap() || {};\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var itemId = item[idField];\n            var parentId = item[parentIdField];\n            index = index || 0;\n            childrenMap[itemId] = childrenMap[itemId] || [];\n            childrenMap[parentId] = childrenMap[parentId] || [];\n            childrenMap[parentId].splice(index, 0, item);\n          },\n          _removeFromDataMaps: function (items) {\n            var that = this;\n            items = isArray(items) ? items : [items];\n\n            if (that._isPageable()) {\n              for (var i = 0; i < items.length; i++) {\n                that._removeFromIdsMap(items[i]);\n\n                that._removeFromChildrenMap(items[i]);\n              }\n            }\n          },\n          _removeFromIdsMap: function (item) {\n            var that = this;\n\n            var idsMap = that._getIdsMap();\n\n            var idField = that._modelIdField();\n\n            if (!isUndefined(item[idField])) {\n              idsMap[item[idField]] = undefined;\n            }\n          },\n          _removeFromChildrenMap: function (item) {\n            var that = this;\n            var childrenMap = that._getChildrenMap() || {};\n\n            var parentIdField = that._modelParentIdField();\n\n            var parentId = item[parentIdField];\n            childrenMap[parentId] = childrenMap[parentId] || [];\n\n            var itemIndex = that._indexInChildrenMap(item);\n\n            if (itemIndex !== -1) {\n              childrenMap[parentId].splice(itemIndex, 1);\n            }\n          },\n          _indexInChildrenMap: function (item) {\n            var that = this;\n            return that._itemIndexInMap(item, that._getChildrenMap());\n          },\n          _itemIndexInMap: function (item, dataMap) {\n            var that = this;\n            var map = dataMap || {};\n\n            var parentIdField = that._modelParentIdField();\n\n            var parentId = item[parentIdField];\n            map[parentId] = map[parentId] || [];\n            var itemInArray = map[parentId].filter(function (element) {\n              return item.uid === element.uid;\n            })[0];\n            var itemIndex = itemInArray ? map[parentId].indexOf(itemInArray) : -1;\n            return itemIndex;\n          },\n          _getById: function (id) {\n            var that = this;\n\n            var idField = that._modelIdField();\n\n            var data = that._getData();\n\n            for (var i = 0; i < data.length; i++) {\n              if (data[i][idField] === id) {\n                return data[i];\n              }\n            }\n          },\n          _isLastItemInView: function (dataItem) {\n            var view = this.view();\n            return view.length && view[view.length - 1] === dataItem;\n          },\n          _defaultPageableQueryOptions: function () {\n            var that = this;\n\n            var dataMaps = that._getDataMaps();\n\n            var options = {\n              skip: that.skip(),\n              take: that.take(),\n              page: that.page(),\n              pageSize: that.pageSize(),\n              sort: that.sort(),\n              filter: that.filter(),\n              group: that.group(),\n              aggregate: that.aggregate(),\n              filterCallback: that._filterCallback.bind(that),\n              childrenMap: dataMaps.children,\n              idsMap: dataMaps.ids\n            };\n            return options;\n          },\n          _isPageable: function () {\n            var pageSize = this.pageSize();\n            return !isUndefined(pageSize) && pageSize > 0 && !this.options.serverPaging;\n          },\n          _updateTotalForAction: function (action, items) {\n            var that = this;\n\n            DataSource.fn._updateTotalForAction.call(that, action, items);\n\n            if (that._isPageable()) {\n              that._updateCollapsedTotalForAction(action, items);\n            }\n          },\n          _updateCollapsedTotalForAction: function (action, items) {\n            var that = this;\n            var total = parseInt(that._collapsedTotal, 10);\n\n            if (!isNumber(that._collapsedTotal)) {\n              that._calculateCollapsedTotal();\n\n              return;\n            }\n\n            if (action === \"add\") {\n              total += items.length;\n            } else if (action === \"remove\") {\n              total -= items.length;\n            } else if (action !== \"itemchange\" && action !== \"sync\" && !that.options.serverPaging) {\n              total = that._calculateCollapsedTotal();\n            } else if (action === \"sync\") {\n              total = that._calculateCollapsedTotal();\n            }\n\n            that._collapsedTotal = total;\n          },\n          _setFilterTotal: function (filterTotal, setDefaultValue) {\n            var that = this;\n\n            DataSource.fn._setFilterTotal.call(that, filterTotal, setDefaultValue);\n          },\n          collapsedTotal: function () {\n            var that = this;\n\n            if (!isUndefined(that._collapsedTotal)) {\n              return that._collapsedTotal;\n            }\n\n            return that._calculateCollapsedTotal();\n          },\n          _calculateCollapsedTotal: function (filteredData) {\n            var that = this;\n\n            var data = that._dataWithoutCollapsedSubtrees(filteredData); //\n\n\n            if (data.length) {\n              that._collapsedTotal = data.length;\n            }\n\n            return that._collapsedTotal;\n          },\n          _dataWithoutCollapsedSubtrees: function (filteredData) {\n            return this._removeCollapsedSubtrees(filteredData || this._getData());\n          },\n          _removeCollapsedSubtrees: function (data) {\n            var that = this;\n\n            var view = that._createTreeView(data);\n\n            var result = view.removeCollapsedSubtreesFromRootNodes({\n              expanded: that._modelOptions().expanded,\n              childrenMap: that.filter() ? that._getFilteredChildrenMap() : that._getChildrenMap()\n            });\n            return result;\n          },\n          _processTreeQuery: function (data, options) {\n            var result = TreeQuery.process(data, extend(options, this._defaultTreeModelOptions(), {\n              processFromRootNodes: true\n            }));\n            return result;\n          },\n          _processDataItemsState: function (data, childrenMap) {\n            var dataLength = data.length;\n            var i;\n\n            for (i = 0; i < dataLength; i++) {\n              this._processDataItemState(data[i], childrenMap);\n            }\n          },\n          _processDataItemState: function (dataItem, childrenMap) {\n            var defaultParentId = this._defaultParentId();\n\n            if (dataItem.id === defaultParentId) {\n              return;\n            }\n\n            var children = childrenMap[dataItem.id] || [];\n            var hasLoadedChildren = !!(children && children.length);\n\n            if (!dataItem.loaded) {\n              return;\n            }\n\n            if (!dataItem.loaded()) {\n              dataItem.loaded(hasLoadedChildren || !dataItem.hasChildren);\n            }\n\n            if (dataItem.loaded() || dataItem.hasChildren !== true) {\n              dataItem.hasChildren = hasLoadedChildren;\n            }\n          },\n          _queueRequest: function (options, callback) {\n            // allow simultaneous requests (loading multiple items at the same time)\n            callback.call(this);\n          },\n          _modelLoaded: function (id) {\n            var model = this.get(id);\n            model.loaded(true);\n            model.hasChildren = this.childNodes(model).length > 0;\n          },\n          _modelError: function (id, e) {\n            this.get(id)._error = e;\n          },\n          success: function (data, requestParams) {\n            if (!requestParams || typeof requestParams.id == \"undefined\") {\n              this._data = this._observe([]);\n            }\n\n            DataSource.fn.success.call(this, data, requestParams);\n            this._total = this._data.length;\n          },\n          load: function (model) {\n            var method = \"_query\";\n            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\n            var defaultPromise = $.Deferred().resolve().promise();\n\n            if (model.loaded()) {\n              if (remote) {\n                return defaultPromise;\n              }\n            } else if (model.hasChildren) {\n              method = \"read\";\n\n              this._removeChildData(model);\n            }\n\n            return this[method]({\n              id: model.id\n            }).done(this._modelLoaded.bind(this, model.id)).fail(this._modelError.bind(this, model.id));\n          },\n          contains: function (root, child) {\n            var that = this;\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var rootId = root[idField];\n\n            var pageable = that._isPageable();\n\n            while (child) {\n              if (child[parentIdField] === rootId) {\n                return true;\n              }\n\n              child = pageable ? that._parentNode(child) : that.parentNode(child);\n            }\n\n            return false;\n          },\n          _byParentId: function (id, defaultId) {\n            var result = [];\n            var view = this.view();\n            var current;\n\n            if (id === defaultId) {\n              return [];\n            }\n\n            for (var i = 0; i < view.length; i++) {\n              current = view.at(i);\n\n              if (current.parentId == id) {\n                result.push(current);\n              }\n            }\n\n            return result;\n          },\n          _defaultParentId: function () {\n            return this.reader.model.fn.defaults[this.reader.model.parentIdField];\n          },\n          _modelOptions: function () {\n            var modelOptions = (this.options.schema || {}).model || {};\n            return modelOptions;\n          },\n          _modelIdField: function () {\n            var modelOptions = this._modelOptions();\n\n            return modelOptions.id || \"id\";\n          },\n          _modelParentIdField: function () {\n            var modelOptions = this._modelOptions();\n\n            return modelOptions.parentId || PARENTIDFIELD;\n          },\n          childNodes: function (model) {\n            return this._byParentId(model.id, this._defaultParentId());\n          },\n          allChildNodes: function (model, result) {\n            var directChildren = this.data().filter(function (item) {\n              return item.parentId === model.id;\n            });\n\n            for (var i = 0; i < directChildren.length; i++) {\n              result.push(directChildren[i]);\n              this.allChildNodes(directChildren[i], result);\n            }\n          },\n          rootNodes: function () {\n            return this._byParentId(this._defaultParentId());\n          },\n          _rootNode: function (child) {\n            return this._parentNodes(child)[0];\n          },\n          _pageableRootNodes: function (options) {\n            options = options || {};\n            var that = this;\n\n            var defaultParentId = that._defaultParentId();\n\n            var parentIdField = that._modelParentIdField();\n\n            var result = [];\n\n            var nodesWithoutParentInView = that._nodesWithoutParentInView(options);\n\n            var node;\n            var root;\n\n            for (var i = 0; i < nodesWithoutParentInView.length; i++) {\n              node = nodesWithoutParentInView[i];\n\n              if (node[parentIdField] === defaultParentId) {\n                result.push(node);\n              } else {\n                root = that._rootNode(node);\n\n                if (root && result.indexOf(root) === -1) {\n                  result.push(root);\n                }\n              }\n            }\n\n            return result;\n          },\n          parentNode: function (model) {\n            return this.get(model.parentId);\n          },\n          _parentNode: function (child) {\n            var that = this;\n\n            var parentIdField = that._modelParentIdField();\n\n            var idsMap = that._initIdsMap(that._getData());\n\n            var parentId = child[parentIdField];\n\n            var parent = idsMap[parentId] || that._getById(parentId);\n\n            return parent;\n          },\n          _parentNodes: function (child) {\n            var that = this;\n\n            var parent = that._parentNode(child);\n\n            var parents = [];\n\n            while (parent) {\n              parents.unshift(parent);\n              parent = that._parentNode(parent);\n            }\n\n            return parents;\n          },\n          _parentNodesNotInView: function () {\n            var that = this;\n            var view = that.view();\n            var result = [];\n\n            var defaultParentId = that._defaultParentId();\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var parentInView;\n            var parents = [];\n            var directParent;\n            var dataItem;\n            var dataItemId;\n            var dataItemParentId;\n\n            for (var i = 0; i < view.length; i++) {\n              dataItem = view[i];\n              dataItemId = dataItem[idField];\n              dataItemParentId = dataItem[parentIdField];\n              parentInView = that._parentInView(dataItemParentId);\n\n              if (!parentInView && dataItemParentId !== defaultParentId) {\n                parents = that._parentNodes(dataItem);\n                directParent = parents && parents.length ? parents[parents.length - 1] : that._getById(dataItemParentId);\n\n                if (directParent && result.indexOf(directParent) === -1) {\n                  result.push(directParent);\n                }\n              }\n            }\n\n            return result;\n          },\n          _nodesWithoutParentInView: function (options) {\n            options = options || {};\n            var that = this;\n            var view = that.view();\n            var childrenMap = options.childrenMap || that.childrenMap(that._getData());\n\n            var idField = that._modelIdField();\n\n            var parentIdField = that._modelParentIdField();\n\n            var dataItem;\n            var parentInView;\n            var children = [];\n            var result = [];\n\n            for (var i = 0; i < view.length; i++) {\n              dataItem = view[i];\n              children = childrenMap[dataItem[idField]];\n              parentInView = that._parentInView(dataItem[parentIdField]);\n\n              if (!parentInView) {\n                result.push(dataItem);\n              }\n            }\n\n            return result;\n          },\n          _parentInView: function (parentId) {\n            var view = this.view();\n\n            for (var i = 0; i < view.length; i++) {\n              if (view[i].id === parentId) {\n                return view[i];\n              }\n            }\n          },\n          level: function (model) {\n            var result = -1;\n\n            if (!(model instanceof TreeListModel)) {\n              model = this.get(model);\n            }\n\n            do {\n              model = this.parentNode(model);\n              result++;\n            } while (model);\n\n            return result;\n          },\n          _pageableModelLevel: function (model) {\n            var that = this;\n\n            if (!model || !that._isPageable()) {\n              return 0;\n            }\n\n            var parents = that._parentNodes(model);\n\n            return parents.length;\n          },\n          filter: function (value) {\n            var baseFilter = DataSource.fn.filter;\n\n            if (value === undefined) {\n              return baseFilter.call(this, value);\n            }\n\n            baseFilter.call(this, value);\n          },\n          _pageableQueryOptions: function (options) {\n            var dataMaps = this._getDataMaps();\n\n            options.childrenMap = dataMaps.children;\n            options.idsMap = dataMaps.ids;\n            return options;\n          },\n          _flatData: function (data, skip) {\n            skip = this._isPageable() ? true : skip;\n            return DataSource.fn._flatData.call(this, data, skip);\n          },\n          data: function (data) {\n            var that = this;\n            var result = DataSource.fn.data.call(that, data);\n\n            if (that._isPageable()) {\n              that._initDataMaps(that._getData());\n\n              that._calculateCollapsedTotal();\n            }\n\n            return result;\n          },\n          cancelChanges: function (model) {\n            var that = this;\n            DataSource.fn.cancelChanges.call(that, model);\n\n            that._restorePageSizeAfterAddChild();\n          },\n          _modelCanceled: function (model) {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._removeFromDataMaps(model);\n            }\n          },\n          _changesCanceled: function () {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._initDataMaps(that._getData());\n            }\n          },\n          _setAddChildPageSize: function () {\n            var that = this;\n            var queryOptions = {};\n\n            if (that._isPageable()) {\n              // increase the page size to make the new item visible in view\n              that._addChildPageSize = that.pageSize() + 1;\n              queryOptions = that._defaultPageableQueryOptions();\n              queryOptions.take = that._addChildPageSize;\n              queryOptions.pageSize = that._addChildPageSize;\n\n              that._query(queryOptions);\n            }\n          },\n          _restorePageSizeAfterAddChild: function () {\n            var that = this;\n            var queryOptions = {};\n\n            if (that._isPageable()) {\n              if (!isUndefined(that._addChildPageSize)) {\n                queryOptions = that._defaultPageableQueryOptions();\n                queryOptions.take = that._addChildPageSize - 1;\n                queryOptions.pageSize = that._addChildPageSize - 1;\n\n                that._query(queryOptions);\n              }\n            }\n\n            that._addChildPageSize = undefined;\n          },\n          sync: function () {\n            var that = this;\n            return DataSource.fn.sync.call(that).then(function () {\n              that._restorePageSizeAfterAddChild();\n            });\n          },\n          _syncEnd: function () {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._initDataMaps(that._getData());\n            }\n          }\n        });\n\n        TreeListDataSource.create = function (options) {\n          if (Array.isArray(options)) {\n            options = {\n              data: options\n            };\n          } else if (options instanceof ObservableArray) {\n            options = {\n              data: options.toJSON()\n            };\n          }\n\n          return options instanceof TreeListDataSource ? options : new TreeListDataSource(options);\n        };\n\n        function isCellVisible() {\n          return this.style.display !== \"none\";\n        }\n\n        function sortCells(cells) {\n          var indexAttr = kendo.attr(\"index\");\n          return cells.sort(function (a, b) {\n            a = $(a);\n            b = $(b);\n            var indexA = a.attr(indexAttr);\n            var indexB = b.attr(indexAttr);\n\n            if (indexA === undefined) {\n              indexA = $(a).index();\n            }\n\n            if (indexB === undefined) {\n              indexB = $(b).index();\n            }\n\n            indexA = parseInt(indexA, 10);\n            indexB = parseInt(indexB, 10);\n            return indexA > indexB ? 1 : indexA < indexB ? -1 : 0;\n          });\n        }\n\n        function leafDataCells(container) {\n          var rows = container.find(\">tr:not(.k-filter-row)\");\n\n          var filter = function () {\n            var el = $(this);\n            return !el.hasClass(\"k-group-cell\") && !el.hasClass(\"k-hierarchy-cell\");\n          };\n\n          var cells = $();\n\n          if (rows.length > 1) {\n            cells = rows.find(\"th[data-index]\").filter(filter);\n          }\n\n          cells = cells.add(rows.last().find(\"th\").filter(filter));\n          return sortCells(cells);\n        }\n\n        function createPlaceholders(options) {\n          var spans = [];\n          var className = options.className;\n\n          for (var i = 0, level = options.level; i < level; i++) {\n            spans.push(kendoDomElement(\"span\", {\n              className: className\n            }));\n          }\n\n          return spans;\n        }\n\n        function columnsWidth(cols) {\n          var colWidth,\n              width = 0;\n\n          for (var idx = 0, length = cols.length; idx < length; idx++) {\n            colWidth = cols[idx].style.width;\n\n            if (colWidth && colWidth.indexOf(\"%\") == -1) {\n              width += parseInt(colWidth, 10);\n            }\n          }\n\n          return width;\n        }\n\n        function syncTableHeight(table1, table2) {\n          table1 = table1[0];\n          table2 = table2[0];\n\n          if (table1.rows.length && table2.rows.length && table1.rows.length !== table2.rows.length) {\n            var lockedHeigth = table1.offsetHeight;\n            var tableHeigth = table2.offsetHeight;\n            var row;\n            var diff;\n\n            if (lockedHeigth > tableHeigth) {\n              row = table2.rows[table2.rows.length - 1];\n\n              if (filterRowRegExp.test(row.className)) {\n                row = table2.rows[table2.rows.length - 2];\n              }\n\n              diff = lockedHeigth - tableHeigth;\n            } else {\n              row = table1.rows[table1.rows.length - 1];\n\n              if (filterRowRegExp.test(row.className)) {\n                row = table1.rows[table1.rows.length - 2];\n              }\n\n              diff = tableHeigth - lockedHeigth;\n            }\n\n            row.style.height = row.offsetHeight + diff + \"px\";\n          }\n        }\n\n        var TreeListPager = ui.Pager.extend({\n          options: {\n            name: \"TreeListPager\"\n          },\n          totalPages: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            if (dataSource && dataSource._filter) {\n              return ui.Pager.fn.totalPages.call(that);\n            }\n\n            return Math.ceil((that._collapsedTotal() || 0) / (that.pageSize() || 1));\n          },\n          _createDataSource: function (options) {\n            this.dataSource = kendo.data.TreeListDataSource.create(options.dataSource);\n          },\n          _collapsedTotal: function () {\n            var dataSource = this.dataSource;\n            return dataSource ? dataSource.collapsedTotal() || 0 : 0;\n          }\n        });\n        var Editor = kendo.Observable.extend({\n          init: function (element, options) {\n            kendo.Observable.fn.init.call(this);\n            options = this.options = extend(true, {}, this.options, options);\n            this.element = element;\n            this.bind(this.events, options);\n            this.model = this.options.model;\n            this.fields = this._fields(this.options.columns);\n\n            this._initContainer();\n\n            this.createEditable();\n          },\n          events: [],\n          _initContainer: function () {\n            this.wrapper = this.element;\n          },\n          createEditable: function () {\n            var options = this.options;\n            this.editable = new ui.Editable(this.wrapper, {\n              fields: this.fields,\n              target: options.target,\n              clearContainer: options.clearContainer,\n              model: this.model,\n              change: options.change\n            });\n          },\n          _isEditable: function (column) {\n            return isColumnEditable(column, this.model);\n          },\n          _fields: function (columns) {\n            var fields = [];\n            var idx, length, column;\n\n            for (idx = 0, length = columns.length; idx < length; idx++) {\n              column = columns[idx];\n\n              if (this._isEditable(column)) {\n                fields.push({\n                  field: column.field,\n                  format: column.format,\n                  editor: column.editor\n                });\n              }\n            }\n\n            return fields;\n          },\n          end: function () {\n            return this.editable.end();\n          },\n          close: function () {\n            this.destroy();\n          },\n          destroy: function () {\n            this.editable.destroy();\n            this.editable.element.find(\"[\" + kendo.attr(\"container-for\") + \"]\").empty().end().removeAttr(kendo.attr(\"role\"));\n            this.model = this.wrapper = this.element = this.columns = this.editable = null;\n          }\n        });\n        var PopupEditor = Editor.extend({\n          init: function (element, options) {\n            Editor.fn.init.call(this, element, options);\n\n            this._attachHandlers();\n\n            kendo.cycleForm(this.wrapper);\n            this.open();\n          },\n          events: [CANCEL, SAVE],\n          options: {\n            window: {\n              modal: true,\n              resizable: false,\n              draggable: true,\n              title: \"Edit\",\n              visible: false\n            }\n          },\n          _initContainer: function () {\n            var options = this.options;\n            var formContent = [];\n            this.wrapper = $('<div class=\"k-popup-edit-form\"/>').attr(kendo.attr(\"uid\"), this.model.uid).append('<div class=\"k-edit-form-container\"/>');\n\n            if (options.template) {\n              this._appendTemplate(formContent);\n\n              this.fields = [];\n            } else {\n              this._appendFields(formContent);\n            }\n\n            this._appendButtons(formContent);\n\n            new kendoDom.Tree(this.wrapper.children()[0]).render(formContent);\n            this.wrapper.appendTo(options.appendTo);\n            this.window = new ui.Window(this.wrapper, options.window);\n          },\n          _appendTemplate: function (form) {\n            var template = this.options.template;\n\n            if (typeof template === STRING) {\n              template = kendo.unescape(template);\n            }\n\n            template = kendo.template(template)(this.model);\n            form.push(kendoHtmlElement(template));\n          },\n          _appendFields: function (form) {\n            var idx, length, column;\n            var columns = this.options.columns;\n\n            for (idx = 0, length = columns.length; idx < length; idx++) {\n              column = columns[idx];\n\n              if (column.selectable) {\n                continue;\n              }\n\n              if (column.command) {\n                continue;\n              }\n\n              form.push(kendoHtmlElement('<div class=\"k-edit-label\"><label for=\"' + column.field + '\">' + (column.title || column.field || \"\") + '</label></div>'));\n\n              if (this._isEditable(column)) {\n                form.push(kendoHtmlElement('<div ' + kendo.attr(\"container-for\") + '=\"' + column.field + '\" class=\"k-edit-field\"></div>'));\n              } else {\n                form.push(kendoDomElement(\"div\", {\n                  \"class\": \"k-edit-field\"\n                }, [this.options.fieldRenderer(column, this.model)]));\n              }\n            }\n          },\n          _appendButtons: function (form) {\n            form.push(kendoDomElement(\"div\", {\n              \"class\": \"k-edit-buttons\"\n            }, this.options.commandRenderer()));\n          },\n          _attachHandlers: function () {\n            var closeHandler = this._cancelProxy = this._cancel.bind(this);\n\n            this.wrapper.on(CLICK + NS, \".k-grid-cancel\", this._cancelProxy);\n            this._saveProxy = this._save.bind(this);\n            this.wrapper.on(CLICK + NS, \".k-grid-update\", this._saveProxy);\n            this.window.bind(\"close\", function (e) {\n              if (e.userTriggered) {\n                closeHandler(e);\n              }\n            });\n          },\n          _detachHandlers: function () {\n            this._cancelProxy = null;\n            this._saveProxy = null;\n            this.wrapper.off(NS);\n          },\n          _cancel: function (e) {\n            this.trigger(CANCEL, e);\n          },\n          _save: function () {\n            this.trigger(SAVE);\n          },\n          open: function () {\n            this.window.center().open();\n          },\n          close: function () {\n            this.window.bind(\"deactivate\", this.destroy.bind(this)).close();\n          },\n          destroy: function () {\n            this.window.destroy();\n            this.window = null;\n\n            this._detachHandlers();\n\n            Editor.fn.destroy.call(this);\n          }\n        });\n        var IncellEditor = Editor.extend({\n          destroy: function () {\n            var that = this;\n            that.editable.destroy();\n            that.editable.element.off().empty().removeAttr(kendo.attr(\"role\"));\n            that.model = that.wrapper = that.element = that.columns = that.editable = null;\n          }\n        });\n        var TreeList = DataBoundWidget.extend({\n          init: function (element, options, events) {\n            DataBoundWidget.fn.init.call(this, element, options);\n\n            if (events) {\n              this._events = events;\n            }\n\n            isRtl = kendo.support.isRtl(element);\n\n            this._dataSource(this.options.dataSource);\n\n            this._aria();\n\n            this._columns();\n\n            this._layout();\n\n            this._navigatable();\n\n            this._selectable();\n\n            this._sortable();\n\n            this._resizable();\n\n            this._filterable();\n\n            this._filterRow();\n\n            this._attachEvents();\n\n            this._toolbar();\n\n            this._scrollable();\n\n            this._reorderable();\n\n            this._columnMenu();\n\n            this._minScreenSupport();\n\n            this._draggable();\n\n            this._pageable();\n\n            if (this.options.autoBind) {\n              this.dataSource.fetch();\n            }\n\n            if (this._hasLockedColumns) {\n              var widget = this;\n              this.wrapper.addClass(\"k-grid-lockedcolumns\");\n\n              this._resizeHandler = function () {\n                widget.resize();\n              };\n\n              $(window).on(\"resize\" + NS, this._resizeHandler);\n            }\n\n            kendo.notify(this);\n          },\n          _draggable: function () {\n            var that = this;\n            var editable = this.options.editable;\n            var dataSource = that.dataSource;\n\n            var idField = dataSource._modelIdField();\n\n            var parentIdField = dataSource._modelParentIdField();\n\n            var pageable = that._isPageable();\n\n            var reorderable;\n\n            if (!editable || !editable.move) {\n              return;\n            }\n\n            reorderable = editable.move.reorderable;\n            this._dragging = new kendo.ui.HierarchicalDragAndDrop(this.wrapper, {\n              $angular: this.$angular,\n              autoScroll: true,\n              holdToDrag: touchDevice,\n              filter: \"tbody>tr\",\n              itemSelector: \"tr\",\n              allowedContainers: this.wrapper,\n              hintText: function (row) {\n                var text = function () {\n                  return $(this).text();\n                };\n\n                var separator = \"<span class='k-drag-separator'></span>\";\n                return row.children(\"td\").map(text).toArray().join(separator);\n              },\n              contains: function (source, destination) {\n                var dest = this.dataItem(destination);\n                var src = this.dataItem(source);\n                return src == dest || this.dataSource.contains(src, dest);\n              }.bind(this),\n              itemFromTarget: function (target) {\n                var tr = target.closest(\"tr\");\n                var prevRow = tr.prev();\n                var nextRow = tr.next();\n                var first;\n                var last;\n\n                if (prevRow) {\n                  first = !that.sameLevel(prevRow, tr);\n                }\n\n                if (nextRow) {\n                  last = !that.sameLevel(nextRow, tr);\n                }\n\n                return {\n                  item: tr,\n                  content: tr,\n                  first: first,\n                  last: last\n                };\n              },\n              dragstart: function (source) {\n                this.wrapper.addClass(\"k-treelist-dragging\");\n\n                if (this.wrapper.find('.k-grid-content').length) {\n                  this.wrapper.find('.k-grid-content table, .k-grid-content-locked table').css(\"position\", \"relative\");\n                }\n\n                var model = this.dataItem(source);\n                return this.trigger(DRAGSTART, {\n                  source: model\n                });\n              }.bind(this),\n              drag: function (e) {\n                e.source = this.dataItem(e.source);\n                this.trigger(DRAG, e);\n              }.bind(this),\n              drop: function (e) {\n                e.source = this.dataItem(e.source);\n                e.destination = this.dataItem(e.destination);\n                this.wrapper.removeClass(\"k-treelist-dragging\");\n\n                if (this.wrapper.find('.k-grid-content').length) {\n                  this.wrapper.find('.k-grid-content table, .k-grid-content-locked table').css(\"position\", \"static\");\n                }\n\n                return this.trigger(DROP, e);\n              }.bind(this),\n              dragend: function (e) {\n                var dest = this.dataItem(e.destination);\n                var src = this.dataItem(e.source);\n                var originalSrcParentId = src[parentIdField];\n\n                var originalSrcIndex = dataSource._indexInChildrenMap(src);\n\n                var position = e.position;\n\n                if (position == \"over\") {\n                  if (pageable) {\n                    dataSource._removeFromChildrenMap(src);\n\n                    src[parentIdField] = dest ? dest[idField] : null;\n\n                    dataSource._initChildrenMapForParent(dest); // src.set() below will not work as the parent id is already set\n\n\n                    src[parentIdField] = originalSrcParentId;\n                  }\n\n                  var isPrevented = src.set(\"parentId\", dest ? dest.id : null);\n\n                  if (pageable && isPrevented) {\n                    dataSource._removeFromChildrenMap(src);\n\n                    src[parentIdField] = originalSrcParentId;\n\n                    dataSource._removeFromChildrenMap(src);\n\n                    dataSource._insertInChildrenMap(src, originalSrcIndex);\n                  }\n                } else {\n                  if (position == \"before\") {\n                    that.insertBefore(src, dest);\n                  } else if (position == \"after\") {\n                    that.insertAfter(src, dest);\n                  }\n                }\n\n                e.source = src;\n                e.destination = dest;\n                this.trigger(DRAGEND, e);\n              }.bind(this),\n              reorderable: reorderable,\n              dropHintContainer: function (item) {\n                return item.children(\"td:visible\").eq(0);\n              },\n              dropPositionFrom: function (dropHint) {\n                var contents;\n                var length;\n                var i;\n                var dropHintElement;\n                var isAfterText = false;\n\n                if (dropHint.parent().find('.k-i-none').length) {\n                  return dropHint.prevAll(\".k-i-none\").length > 0 ? \"after\" : \"before\";\n                } else {\n                  contents = dropHint.parent().contents();\n                  length = contents.length;\n                  dropHintElement = dropHint[0];\n\n                  for (i = 0; i < length; i++) {\n                    if (contents[i] === dropHintElement) {\n                      break;\n                    }\n\n                    if (contents[i].nodeType === 3) {\n                      isAfterText = true;\n                    }\n                  }\n\n                  return isAfterText ? \"after\" : \"before\";\n                }\n              }\n            });\n          },\n          sameLevel: function () {\n            return arguments[0].find(\".\" + classNames.iconHidden).length === arguments[1].find(\".\" + classNames.iconHidden).length;\n          },\n          insertAfter: function (nodeData, referenceNode) {\n            this.insertAction(nodeData, referenceNode, 1);\n          },\n          insertBefore: function (nodeData, referenceNode) {\n            this.insertAction(nodeData, referenceNode, 0);\n          },\n          insertAction: function (nodeData, referenceNode, indexOffset) {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            var parentIdField = dataSource._modelParentIdField();\n\n            var referenceNodeIndex;\n            var nodeDataIndex = dataSource.indexOf(nodeData);\n\n            var pageable = that._isPageable();\n\n            var originalDestIndex = dataSource._indexInChildrenMap(referenceNode);\n\n            var destIndex;\n            var childrenMap = dataSource._getChildrenMap() || {};\n            var parentId = nodeData[parentIdField];\n\n            that._unbindDataSource();\n\n            that._unbindDataChange();\n\n            if (pageable) {\n              dataSource._removeFromChildrenMap(nodeData);\n            }\n\n            if (nodeData[parentIdField] != referenceNode[parentIdField]) {\n              nodeData.set(\"parentId\", referenceNode && referenceNode.parentId ? referenceNode.parentId : null);\n            }\n\n            dataSource._data.splice(nodeDataIndex, 1);\n\n            referenceNodeIndex = dataSource.indexOf(referenceNode);\n            destIndex = referenceNodeIndex + indexOffset;\n\n            if (pageable) {\n              originalDestIndex += indexOffset;\n\n              if (childrenMap[parentId].length <= originalDestIndex) {\n                originalDestIndex = childrenMap[parentId].length;\n              }\n\n              dataSource._insertInChildrenMap(nodeData, originalDestIndex);\n            }\n\n            dataSource._data.splice(destIndex, 0, nodeData);\n\n            dataSource._destroyed.pop();\n\n            that._bindDataChange();\n\n            that._bindDataSource();\n\n            that.refresh();\n          },\n          _bindDataChange: function () {\n            var dataSource = this.dataSource;\n\n            if (dataSource._data && dataSource._changeHandler) {\n              dataSource._data.bind(CHANGE, dataSource._changeHandler);\n\n              dataSource._data.trigger(CHANGE);\n            }\n          },\n          _unbindDataChange: function () {\n            var dataSource = this.dataSource;\n\n            if (dataSource._data && dataSource._changeHandler) {\n              dataSource._data.unbind(CHANGE, dataSource._changeHandler);\n            }\n          },\n          _bindDataSource: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            if (dataSource) {\n              dataSource.bind(CHANGE, that._refreshHandler);\n            }\n          },\n          _unbindDataSource: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            if (dataSource) {\n              dataSource.unbind(CHANGE, that._refreshHandler);\n            }\n          },\n          itemFor: function (model) {\n            if (typeof model == \"number\") {\n              model = this.dataSource.get(model);\n            }\n\n            return this.tbody.find(\"[\" + kendo.attr(\"uid\") + \"=\" + model.uid + \"]\");\n          },\n          _itemFor: function (model) {\n            var that = this;\n            var table = that.lockedContent ? that.lockedTable : that.table;\n\n            if (typeof model == \"number\") {\n              model = this.dataSource.get(model);\n            }\n\n            return table.find(\"[\" + kendo.attr(\"uid\") + \"=\" + model.uid + \"]\");\n          },\n          _scrollable: function () {\n            if (this.options.scrollable) {\n              var scrollables = this.thead.closest(\".k-grid-header-wrap\");\n              var lockedContent = $(this.lockedContent).on(\"DOMMouseScroll\" + NS + \" mousewheel\" + NS, this._wheelScroll.bind(this));\n              this.content.on(\"scroll\" + NS, function () {\n                kendo.scrollLeft(scrollables, this.scrollLeft);\n                lockedContent.scrollTop(this.scrollTop);\n              });\n              var touchScroller = kendo.touchScroller(this.content);\n\n              if (touchScroller && touchScroller.movable) {\n                this._touchScroller = touchScroller;\n                touchScroller.movable.bind(\"change\", function (e) {\n                  kendo.scrollLeft(scrollables, -e.sender.x);\n\n                  if (lockedContent) {\n                    lockedContent.scrollTop(-e.sender.y);\n                  }\n                });\n              }\n            }\n          },\n          _wheelScroll: function (e) {\n            if (e.ctrlKey) {\n              return;\n            }\n\n            var delta = kendo.wheelDeltaY(e);\n            var lockedDiv = $(e.currentTarget);\n\n            if (delta) {\n              if (lockedDiv[0].scrollHeight > lockedDiv[0].clientHeight && (lockedDiv[0].scrollTop < lockedDiv[0].scrollHeight - lockedDiv[0].clientHeight && delta < 0 || lockedDiv[0].scrollTop > 0 && delta > 0)) {\n                e.preventDefault();\n              } //In Firefox DOMMouseScroll event cannot be canceled\n\n\n              lockedDiv.one(\"wheel\" + NS, false);\n              this.content.scrollTop(this.content.scrollTop() + -delta);\n            }\n          },\n          _progress: function () {\n            var messages = this.options.messages;\n\n            if (!this.tbody.find(\"tr\").length) {\n              this._showStatus(kendo.template(\"<span class='#= className #'></span> #: messages.loading #\")({\n                className: classNames.icon + \" \" + classNames.loading,\n                messages: messages\n              }));\n            }\n          },\n          _error: function (e) {\n            if (!this.dataSource.rootNodes().length) {\n              this._render({\n                error: e\n              });\n            }\n          },\n          refresh: function (e) {\n            var that = this;\n            e = e || {};\n\n            if (e.action == \"itemchange\" && this.editor) {\n              return;\n            }\n\n            if (this.trigger(DATABINDING)) {\n              return;\n            }\n\n            var current = $(this.current());\n            var isCurrentInHeader = false;\n            var currentIndex;\n\n            this._cancelEditor();\n\n            this._render();\n\n            this._adjustHeight();\n\n            if (this.options.navigatable) {\n              if (this._isActiveInTable() || this.editor) {\n                isCurrentInHeader = current.is(\"th\");\n                currentIndex = Math.max(this.cellIndex(current), 0);\n              }\n\n              this._restoreCurrent(currentIndex, isCurrentInHeader);\n            }\n\n            if (that._checkBoxSelection) {\n              that._deselectCheckRows(that.items(), true);\n            }\n\n            this.trigger(DATABOUND);\n          },\n          _angularFooters: function (command) {\n            var i, footer, aggregates;\n            var allAggregates = this.dataSource.aggregates();\n\n            var footerRows = this._footerItems();\n\n            for (i = 0; i < footerRows.length; i++) {\n              footer = footerRows.eq(i);\n              aggregates = allAggregates[footer.attr(\"data-parentId\")];\n\n              this._angularFooter(command, footer.find(\"td\").get(), aggregates);\n            }\n          },\n          _angularFooter: function (command, cells, aggregates) {\n            var columns = this.columns;\n            this.angular(command, function () {\n              return {\n                elements: cells,\n                data: map(columns, function (col) {\n                  return {\n                    column: col,\n                    aggregate: aggregates && aggregates[col.field]\n                  };\n                })\n              };\n            });\n          },\n          items: function () {\n            if (this._hasLockedColumns) {\n              return this._items(this.tbody).add(this._items(this.lockedTable));\n            } else {\n              return this._items(this.tbody);\n            }\n          },\n          _items: function (container) {\n            return container.find(\"tr[data-uid]\").filter(function () {\n              return !$(this).hasClass(classNames.footerTemplate);\n            });\n          },\n          _footerItems: function () {\n            var container = this.tbody;\n\n            if (this._hasLockedColumns) {\n              container = container.add(this.lockedTable);\n            }\n\n            return container.find(\"tr\").filter(function () {\n              return $(this).hasClass(classNames.footerTemplate);\n            });\n          },\n          dataItems: function () {\n            var dataItems = kendo.ui.DataBoundWidget.fn.dataItems.call(this);\n\n            if (this._hasLockedColumns) {\n              var n = dataItems.length,\n                  tmp = new Array(2 * n);\n\n              for (var i = n; --i >= 0;) {\n                tmp[i] = tmp[i + n] = dataItems[i];\n              }\n\n              dataItems = tmp;\n            }\n\n            return dataItems;\n          },\n          _showNoRecordsTemplate: function () {\n            var wrapper = '<div class=\"{0}\">{1}</div>';\n            var defaultTemplate = '<div class=\"k-grid-norecords-template\"{1}>{0}</div>';\n            var scrollableNoGridHeightStyles = this.options.scrollable && !this.wrapper[0].style.height ? ' style=\"margin:0 auto;position:static;\"' : '';\n            var template;\n\n            this._contentTree.render([]);\n\n            if (this._hasLockedColumns) {\n              this._lockedContentTree.render([]);\n            }\n\n            template = kendo.format(defaultTemplate, this.options.messages.noRows, scrollableNoGridHeightStyles);\n            $(kendo.template(kendo.format(wrapper, NORECORDSCLASS, template))({})).insertAfter(this.table);\n          },\n          _showStatus: function (message) {\n            var status = this.element.find(\".k-status\");\n            var content = $(this.content).add(this.lockedContent);\n\n            if (!status.length) {\n              status = $(\"<div class='k-status' role='alert' aria-live='polite' />\").appendTo(this.element);\n            }\n\n            this._contentTree.render([]);\n\n            if (this._hasLockedColumns) {\n              this._lockedContentTree.render([]);\n            }\n\n            content.hide();\n            status.html(message);\n          },\n          _hideStatus: function () {\n            this.element.find(\".k-status\").remove();\n\n            this._hideNoRecordsTempalte();\n\n            $(this.content).add(this.lockedContent).show();\n          },\n          _hideNoRecordsTempalte: function () {\n            this.element.find(\".\" + NORECORDSCLASS).remove();\n          },\n          _adjustHeight: function () {\n            var that = this;\n            var element = this.element;\n            var contentWrap = element.find(DOT + classNames.gridContentWrap);\n            var header = element.find(DOT + classNames.gridHeader);\n            var toolbar = element.find(DOT + classNames.gridToolbar);\n            var status = element.find(DOT + classNames.status);\n            var pagerHeight = that._isPageable() && that.pager && that.pager.element.is(\":visible\") ? outerHeight(that.pager.element) : 0;\n            var height;\n            var scrollbar = kendo.support.scrollbar();\n            element.css(HEIGHT, this.options.height); // identical code found in grid & scheduler :(\n\n            var isHeightSet = function (el) {\n              var initialHeight, newHeight;\n\n              if (el[0].style.height) {\n                return true;\n              } else {\n                initialHeight = el.height();\n              }\n\n              el.height(\"auto\");\n              newHeight = el.height();\n              el.height(\"\");\n              return initialHeight != newHeight;\n            };\n\n            if (isHeightSet(element)) {\n              height = element.height() - outerHeight(header) - outerHeight(toolbar) - outerHeight(status) - pagerHeight;\n              contentWrap.height(height);\n\n              if (this._hasLockedColumns) {\n                scrollbar = this.table[0].offsetWidth > this.table.parent()[0].clientWidth ? scrollbar : 0;\n                this.lockedContent.height(height - scrollbar);\n              }\n            }\n          },\n          _resize: function (size, force) {\n            this._applyLockedContainersWidth();\n\n            this._adjustHeight();\n\n            if (this.pager && this.pager.element) {\n              this.pager.resize(force);\n            }\n          },\n          _minScreenSupport: function () {\n            var any = this.hideMinScreenCols();\n\n            if (any) {\n              this.minScreenResizeHandler = this.hideMinScreenCols.bind(this);\n              $(window).on(\"resize\", this.minScreenResizeHandler);\n            }\n          },\n          _iterateMinScreenCols: function (cols, screenWidth) {\n            var any = false;\n\n            for (var i = 0; i < cols.length; i++) {\n              var col = cols[i];\n              var minWidth = col.minScreenWidth;\n\n              if (minWidth !== undefined && minWidth !== null) {\n                any = true;\n\n                if (minWidth > screenWidth) {\n                  this.hideColumn(col);\n                } else {\n                  this.showColumn(col);\n                }\n              }\n\n              if (!col.hidden && col.columns) {\n                any = this._iterateMinScreenCols(col.columns, screenWidth) || any;\n              }\n            }\n\n            return any;\n          },\n          hideMinScreenCols: function () {\n            var cols = this.columns,\n                screenWidth = window.innerWidth > 0 ? window.innerWidth : screen.width;\n            return this._iterateMinScreenCols(cols, screenWidth);\n          },\n          destroy: function () {\n            this._destroyColumnAttachments();\n\n            DataBoundWidget.fn.destroy.call(this);\n            var dataSource = this.dataSource;\n            dataSource.unbind(CHANGE, this._refreshHandler);\n            dataSource.unbind(ERROR, this._errorHandler);\n            dataSource.unbind(PROGRESS, this._progressHandler);\n            this._navigatableTables = null;\n            this._current = null;\n\n            if (this._resizeHandler) {\n              $(window).off(\"resize\" + NS, this._resizeHandler);\n            }\n\n            if (this._dragging) {\n              this._dragging.destroy();\n\n              this._dragging = null;\n            }\n\n            if (this.resizable) {\n              this.resizable.destroy();\n              this.resizable = null;\n            }\n\n            if (this.reorderable) {\n              this.reorderable.destroy();\n              this.reorderable = null;\n            }\n\n            if (this._draggableInstance && this._draggableInstance.element) {\n              this._draggableInstance.destroy();\n\n              this._draggableInstance = null;\n            }\n\n            if (this.selectable) {\n              this.selectable.destroy();\n            }\n\n            if (this._userEvents) {\n              this._userEvents.destroy();\n\n              this._userEvents = null;\n            }\n\n            if (this.minScreenResizeHandler) {\n              $(window).off(\"resize\", this.minScreenResizeHandler);\n            }\n\n            this._destroyEditor();\n\n            this.element.off(NS);\n\n            if (this.wrapper) {\n              this.wrapper.off(NS);\n            }\n\n            if (this._touchScroller) {\n              this._touchScroller.destroy();\n            }\n\n            this._destroyPager();\n\n            if (dataSource) {\n              dataSource._dataMaps = null;\n            }\n\n            this._autoExpandable = null;\n            this._refreshHandler = this._errorHandler = this._progressHandler = this._dataSourceFetchProxy = null;\n            this.thead = this.content = this.tbody = this.table = this.element = this.lockedHeader = this.lockedContent = null;\n            this._statusTree = this._headerTree = this._contentTree = this._lockedHeaderColsTree = this._lockedContentColsTree = this._lockedHeaderTree = this._lockedContentTree = null;\n            kendo.destroy(this.wrapper);\n          },\n          options: {\n            name: \"TreeList\",\n            columns: [],\n            autoBind: true,\n            scrollable: true,\n            selectable: false,\n            sortable: false,\n            toolbar: null,\n            height: null,\n            columnMenu: false,\n            messages: {\n              noRows: \"No records to display\",\n              loading: \"Loading...\",\n              requestFailed: \"Request failed.\",\n              retry: \"Retry\",\n              commands: {\n                edit: \"Edit\",\n                update: \"Update\",\n                canceledit: \"Cancel\",\n                create: \"Add new record\",\n                createchild: \"Add child record\",\n                destroy: \"Delete\",\n                excel: \"Export to Excel\",\n                pdf: \"Export to PDF\",\n                search: \"Search...\"\n              }\n            },\n            excel: {\n              hierarchy: true\n            },\n            resizable: false,\n            search: false,\n            filterable: false,\n            editable: false,\n            reorderable: false,\n            pageable: false,\n            renderAllRows: true,\n            rowTemplate: \"\",\n            altRowTemplate: \"\"\n          },\n          events: [CHANGE, BEFORE_EDIT, EDIT, PAGE, SAVE, SAVE_CHANGES, REMOVE, EXPAND, COLLAPSE, DATABINDING, DATABOUND, CANCEL, DRAGSTART, DRAG, DROP, DRAGEND, FILTERMENUINIT, ITEM_CHANGE, CELL_CLOSE, FILTERMENUOPEN, COLUMNHIDE, COLUMNSHOW, COLUMNREORDER, COLUMNRESIZE, COLUMNMENUINIT, COLUMNMENUOPEN, COLUMNLOCK, COLUMNUNLOCK],\n          getOptions: function () {\n            var options = this.options;\n            options.dataSource = null;\n            var result = extend(true, {}, this.options);\n            result.columns = kendo.deepExtend([], this.columns);\n            var dataSource = this.dataSource;\n            var initialData = dataSource.options.data && dataSource._data;\n            dataSource.options.data = null;\n            result.dataSource = $.extend(true, {}, dataSource.options);\n            dataSource.options.data = initialData;\n            result.dataSource.data = initialData;\n            result.dataSource.page = dataSource.page();\n            result.dataSource.filter = $.extend(true, {}, dataSource.filter());\n            result.dataSource.pageSize = dataSource.pageSize();\n            result.dataSource.sort = dataSource.sort();\n            result.dataSource.group = dataSource.group();\n            result.dataSource.aggregate = dataSource.aggregate();\n\n            if (result.dataSource.transport) {\n              result.dataSource.transport.dataSource = null;\n            }\n\n            if (result.pageable && result.pageable.pageSize) {\n              result.pageable.pageSize = dataSource.pageSize();\n            }\n\n            result.$angular = undefined;\n            return result;\n          },\n          setOptions: function (options) {\n            var currentOptions = this.getOptions();\n            kendo.deepExtend(currentOptions, options);\n\n            if (!options.dataSource) {\n              currentOptions.dataSource = this.dataSource;\n            }\n\n            var wrapper = this.wrapper;\n            var events = this._events;\n            var element = this.element;\n            this.destroy();\n            this.options = null;\n\n            if (wrapper[0] !== element[0]) {\n              wrapper.before(element);\n              wrapper.remove();\n            }\n\n            element.empty();\n            this.init(element, currentOptions, events);\n\n            this._setEvents(currentOptions);\n          },\n          _destroyColumnAttachments: function () {\n            var that = this;\n\n            if (!that.thead) {\n              return;\n            }\n\n            this.angular(\"cleanup\", function () {\n              return {\n                elements: that.thead.get()\n              };\n            });\n            that.thead.add(that.lockedHeader).find(\"th\").each(function () {\n              var th = $(this),\n                  filterMenu = th.data(\"kendoFilterMenu\"),\n                  sortable = th.data(\"kendoColumnSorter\"),\n                  columnMenu = th.data(\"kendoColumnMenu\");\n\n              if (filterMenu) {\n                filterMenu.destroy();\n              }\n\n              if (sortable) {\n                sortable.destroy();\n              }\n\n              if (columnMenu) {\n                columnMenu.destroy();\n              }\n            });\n          },\n          _toggle: function (model, expand) {\n            var that = this;\n            var defaultPromise = $.Deferred().resolve().promise();\n            var loaded = model.loaded();\n\n            if (that._isIncellEditable() && that.editor) {\n              // manually trigger change as the expand/collapse icons are not focusable\n              $(activeElement()).change();\n              that.closeCell();\n            } // reset error state\n\n\n            if (model._error) {\n              model.expanded = false;\n              model._error = undefined;\n            } // do not load items that are currently loading\n\n\n            if (!loaded && model.expanded) {\n              return defaultPromise;\n            } // toggle expanded state\n\n\n            if (typeof expand == \"undefined\") {\n              expand = !model.expanded;\n            }\n\n            model.expanded = expand;\n\n            function afterModelLoaded() {\n              that._toggleData();\n\n              if (that._isPageable()) {\n                that.refresh();\n              } else {\n                that._render();\n              }\n\n              that._syncLockedContentHeight();\n            }\n\n            if (!loaded) {\n              defaultPromise = this.dataSource.load(model).always(function () {\n                afterModelLoaded();\n              }.bind(this));\n            }\n\n            afterModelLoaded();\n            return defaultPromise;\n          },\n          _toggleData: function () {\n            var that = this;\n\n            if (that._isPageable()) {\n              that._togglePageableData();\n            }\n          },\n          _togglePageableData: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            var data = dataSource._getData();\n\n            var result;\n\n            var queryOptions = dataSource._defaultPageableQueryOptions();\n\n            that._renderProgress(true);\n\n            var childrenMap = dataSource._getChildrenMap() || dataSource.childrenMap(dataSource._getData());\n\n            dataSource._processDataItemsState(data, childrenMap);\n\n            result = dataSource._processPageableQuery(data, queryOptions);\n            queryOptions.childrenMap = result.childrenMap;\n            queryOptions.filteredChildrenMap = result.filteredChildrenMap;\n            dataSource._aggregateResult = dataSource._calculateAggregates(result.dataToAggregate, queryOptions);\n            dataSource.view(result.data);\n\n            if (!dataSource.filter()) {\n              dataSource._calculateCollapsedTotal();\n            }\n\n            that._refreshPager();\n\n            that._renderProgress(false);\n          },\n          _refreshPager: function () {\n            var pager = this.pager;\n\n            if (pager) {\n              pager.refresh();\n            }\n          },\n          expand: function (row) {\n            return this._toggle(this.dataItem(row), true);\n          },\n          collapse: function (row) {\n            return this._toggle(this.dataItem(row), false);\n          },\n          _toggleChildren: function (e) {\n            var icon = $(e.target);\n            var model = this.dataItem(icon);\n\n            if (!model) {\n              return;\n            }\n\n            var event = !model.expanded ? EXPAND : COLLAPSE;\n\n            if (!this.trigger(event, {\n              model: model\n            })) {\n              this._toggle(model);\n            }\n\n            e.preventDefault();\n          },\n          _navigatable: function () {\n            var that = this;\n\n            if (!that.options.navigatable) {\n              return;\n            }\n\n            var tables = that.table.add(that.lockedTable);\n            var headerTables = that.thead.parent().add($(\">table\", that.lockedHeader));\n\n            if (that.options.scrollable) {\n              //add the header table when the widget is scrollable\n              tables = tables.add(headerTables); //data tables will recive first focus on TAB\n\n              headerTables.attr(TABINDEX, -1);\n            }\n\n            this._navigatableTables = tables;\n            tables //handle click on tables, will attempt to focus the table\n            .on(kendo.support.touch ? \"touchstart\" + NS : \"mousedown\" + NS, NAVROW + \">:visible\", that._tableClick.bind(that)).on(\"focus\" + NS, that._tableFocus.bind(that)).on(\"focusout\" + NS, that._tableBlur.bind(that)).on(\"keydown\" + NS, that._tableKeyDown.bind(that));\n          },\n          cellIndex: function (td) {\n            var lockedColumnOffset = 0;\n\n            if (this.lockedTable && !$.contains(this.lockedTable[0], td[0])) {\n              lockedColumnOffset = leafColumns(lockedColumns(this.columns)).length;\n            }\n\n            return $(td).parent().children().index(td) + lockedColumnOffset;\n          },\n          _isActiveInTable: function () {\n            var active = kendo._activeElement();\n\n            if (!active) {\n              return false;\n            }\n\n            return this.table[0] === active || $.contains(this.table[0], active) || this.lockedTable && (this.lockedTable[0] === active || $.contains(this.lockedTable[0], active));\n          },\n          _restoreCurrent: function (currentIndex, isCurrentInHeader) {\n            var rowIndex;\n            var row;\n            var td;\n\n            if (currentIndex === undefined || currentIndex < 0) {\n              return;\n            }\n\n            if (this._current) {\n              this._current.removeClass(\"k-state-focused\");\n            }\n\n            if (isCurrentInHeader) {\n              this.current(this.thead.find(\"th\").eq(currentIndex));\n            } else {\n              rowIndex = 0;\n              currentIndex = 0;\n              row = $();\n\n              if (this.lockedTable) {\n                row = this.lockedTable.find(\">tbody>tr:visible\").eq(rowIndex);\n              }\n\n              row = row.add(this.tbody.children().eq(rowIndex));\n              td = row.find(\">td:visible\").eq(currentIndex);\n              this.current(td);\n            }\n\n            if (this._current) {\n              focusTable(this._current.closest(\"table\")[0], true);\n            }\n          },\n          current: function (newCurrent) {\n            var current = this._current;\n            newCurrent = $(newCurrent);\n\n            if (newCurrent.length && (!current || current[0] !== newCurrent[0])) {\n              this._updateCurrentAttr(current, newCurrent);\n\n              this._scrollCurrent();\n            }\n\n            if (newCurrent && newCurrent.length) {\n              this._lastCellIndex = newCurrent.parent().children(DATA_CELL).index(newCurrent);\n            }\n\n            return this._current;\n          },\n          _setCurrent: function (newCurrent) {\n            var that = this;\n            newCurrent = $(newCurrent);\n\n            if (newCurrent[0]) {\n              that._current = newCurrent;\n\n              that._updateCurrentAttr(that._current, newCurrent);\n\n              that._scrollCurrent();\n            }\n\n            return that._current;\n          },\n          _scrollCurrent: function () {\n            var current = this._current;\n            var scrollable = this.options.scrollable;\n\n            if (!current || !scrollable) {\n              return;\n            }\n\n            var row = current.parent();\n            var tableContainer = row.closest(\"table\").parent();\n            var isInLockedContainer = tableContainer.is(\".k-grid-content-locked,.k-grid-header-locked\");\n            var isInContent = tableContainer.is(\".k-grid-content-locked,.k-grid-content\");\n            var scrollableContainer = $(this.content)[0]; //adjust scroll vertically\n\n            if (isInContent) {\n              this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n            }\n\n            if (this.lockedContent) {\n              //sync locked and non-locked content scrollTop\n              this.lockedContent[0].scrollTop = scrollableContainer.scrollTop;\n            } //adjust scroll horizontally, if not inside locked tables\n\n\n            if (!isInLockedContainer) {\n              this._scrollTo(current[0], scrollableContainer);\n            }\n          },\n          _findCurrentCell: function () {\n            var that = this;\n            var current = that.current();\n            var elements = $(that.table).add(that.header).add(that.lockedTable).add(that.lockedHeader);\n\n            if (current && elements.find(current).length > 0) {\n              return current;\n            } else {\n              return elements.find(DOT + classNames.focused);\n            }\n          },\n          _scrollTo: function (element, container) {\n            var elementToLowercase = element.tagName.toLowerCase();\n            var isHorizontal = elementToLowercase === \"td\" || elementToLowercase === \"th\";\n            var table = $(element).closest(\"table\")[0];\n            var elementOffsetDir = element[isHorizontal ? \"offsetWidth\" : \"offsetHeight\"];\n            var containerScroll = container[isHorizontal ? \"scrollLeft\" : \"scrollTop\"];\n            var containerOffsetDir = container[isHorizontal ? \"clientWidth\" : \"clientHeight\"];\n            var elementOffset = $(element).css(\"position\") === \"relative\" && isRtl && isHorizontal ? Math.abs(table.offsetLeft - element.offsetLeft) : element[isHorizontal ? \"offsetLeft\" : \"offsetTop\"];\n            var bottomDistance = elementOffset + elementOffsetDir;\n            var result = 0;\n            var ieCorrection = 0;\n            var firefoxCorrection = 0;\n\n            if (isRtl && isHorizontal) {\n              if (browser.msie || browser.edge) {\n                ieCorrection = table.offsetLeft;\n              } else if (browser.mozilla || browser.webkit && browser.version > 85) {\n                firefoxCorrection = table.offsetLeft - kendo.support.scrollbar();\n              }\n            }\n\n            containerScroll = Math.abs(containerScroll + ieCorrection - firefoxCorrection);\n\n            if (containerScroll > elementOffset) {\n              result = elementOffset;\n            } else if (bottomDistance > containerScroll + containerOffsetDir) {\n              if (elementOffsetDir <= containerOffsetDir) {\n                result = bottomDistance - containerOffsetDir;\n              } else {\n                result = elementOffset;\n              }\n            } else {\n              result = containerScroll;\n            }\n\n            result = Math.abs(result + ieCorrection) + firefoxCorrection;\n            container[isHorizontal ? \"scrollLeft\" : \"scrollTop\"] = result;\n          },\n          _aria: function () {\n            var id = this.element.attr(\"id\") || \"aria\";\n\n            if (id) {\n              this._elementId = id + \"_active_element\";\n            }\n          },\n          _currentDataIndex: function (table, current) {\n            var index = current.attr(\"data-index\");\n\n            if (!index) {\n              return undefined;\n            }\n\n            var lockedColumnsCount = lockedColumns(this.columns).length;\n\n            if (lockedColumnsCount && !table.closest(\"div\").hasClass(\"k-grid-content-locked\")[0]) {\n              return index - lockedColumnsCount;\n            }\n\n            return index;\n          },\n          _prevVerticalCell: function (container, current) {\n            var cells;\n            var row = current.parent();\n            var rows = container.children(NAVROW);\n            var rowIndex = rows.index(row); //get data-index in case of last level of multi-level columns\n\n            var index = this._currentDataIndex(container, current);\n\n            var cellSelector = DATA_CELL + \",\" + FILTER_CELL; //current is in the header, but not at the last level of multi-level columns\n\n            if (index || current.hasClass(\"k-header\")) {\n              cells = parentColumnsCells(current);\n              return cells.eq(cells.length - 2);\n            }\n\n            index = Math.max(row.children(cellSelector).index(current), this._lastCellIndex || 0); //if current is inside filter row\n\n            if (row.hasClass(\"k-filter-row\")) {\n              return leafDataCells(container).filter(isCellVisible).eq(index);\n            } //move up to header container\n\n\n            if (rowIndex == -1) {\n              //is there filter row in the header container\n              row = container.find(\"tr.k-filter-row:visible\");\n\n              if (!row[0]) {\n                return leafDataCells(container).filter(isCellVisible).eq(index);\n              }\n            } else {\n              row = rowIndex === 0 ? $() : rows.eq(rowIndex - 1);\n            }\n\n            cells = row.children(cellSelector);\n\n            if (cells.length > index) {\n              return cells.eq(index);\n            }\n\n            return cells.eq(0);\n          },\n          _nextVerticalCell: function (container, current) {\n            var cells;\n            var row = current.parent();\n            var rows = container.children(NAVROW);\n            var rowIndex = rows.index(row); //get data-index in case of last level of multi-level columns\n\n            var index = this._currentDataIndex(container, current);\n\n            var cellSelector = DATA_CELL + \",\" + FILTER_CELL; //current is in the header, but not at the last level of multi-level columns\n            //and we are not changing the table\n\n            if (rowIndex != -1 && index === undefined && current.hasClass(\"k-header\")) {\n              return childColumnsCells(current).eq(1);\n            }\n\n            index = index ? parseInt(index, 10) : row.children(cellSelector).index(current);\n            index = Math.max(index, this._lastCellIndex || 0); //move down to data container\n\n            if (rowIndex == -1) {\n              row = rows.eq(0);\n            } else {\n              row = rows.eq(rowIndex + current[0].rowSpan);\n            }\n\n            var tmpIndex = index; //in case of last level of multi-level columns the index should be updated depending on the hidden columns\n\n            if (this._currentDataIndex(container, current) !== undefined) {\n              var currentRowCells = row.children(\":not(.k-group-cell):not(.k-hierarchy-cell)\");\n              var hiddenColumns = currentRowCells.filter(\":hidden\");\n\n              for (var idx = 0, length = hiddenColumns.length; idx < length; idx++) {\n                if (currentRowCells.index(hiddenColumns[idx]) < index) {\n                  tmpIndex--;\n                }\n              }\n            }\n\n            index = tmpIndex;\n            cells = row.children(cellSelector);\n\n            if (cells.length > index) {\n              return cells.eq(index);\n            }\n\n            return cells.eq(0);\n          },\n          _verticalContainer: function (container, up) {\n            var table = container.parent();\n            var length = this._navigatableTables.length;\n            var step = Math.floor(length / 2);\n            var index = inArray(table[0], this._navigatableTables);\n\n            if (up) {\n              step *= -1;\n            }\n\n            index += step;\n\n            if (index >= 0 || index < length) {\n              table = this._navigatableTables.eq(index);\n            }\n\n            return table.find(up ? \"thead\" : \"tbody\");\n          },\n          _updateCurrentAttr: function (current, next) {\n            var headerId = $(current).data(\"headerId\");\n            $(current).removeClass(classNames.focused).closest(\"table\").removeAttr(\"aria-activedescendant\");\n\n            if (headerId) {\n              headerId = headerId.replace(this._elementId, \"\");\n              $(current).attr(\"id\", headerId);\n            } else {\n              $(current).removeAttr(\"id\");\n            }\n\n            next.data(\"headerId\", next.attr(\"id\")).attr(\"id\", this._elementId).addClass(classNames.focused).closest(\"table\").attr(\"aria-activedescendant\", this._elementId);\n            this._current = next;\n          },\n          _tableKeyDown: function (e) {\n            var handled = false;\n            var current = this.current();\n            var target = $(e.target);\n            var canHandle = !e.isDefaultPrevented() && !target.is(\":button,a,:input,a>.k-icon\");\n            current = current ? current : $(this.lockedTable).add(this.table).find(NAVROW + \" > td:visible\").first();\n\n            if (canHandle && e.keyCode == keys.UP) {\n              handled = this._moveUp(current, e.shiftKey);\n            }\n\n            if (canHandle && e.keyCode == keys.DOWN) {\n              handled = this._moveDown(current, e.shiftKey);\n            }\n\n            if (canHandle && e.keyCode == (isRtl ? keys.LEFT : keys.RIGHT)) {\n              if (e.altKey) {\n                handled = this._handleExpand(current);\n              } else {\n                handled = this._moveRight(current);\n              }\n            }\n\n            if (canHandle && e.keyCode == (isRtl ? keys.RIGHT : keys.LEFT)) {\n              if (e.altKey) {\n                handled = this._handleCollapse(current);\n              } else {\n                handled = this._moveLeft(current);\n              }\n            }\n\n            if (canHandle && e.keyCode == keys.PAGEDOWN) {\n              handled = this._handlePageDown();\n            }\n\n            if (canHandle && e.keyCode == keys.PAGEUP) {\n              handled = this._handlePageUp();\n            }\n\n            if (e.keyCode == keys.ENTER || e.keyCode == keys.F2) {\n              handled = this._handleEnterKey(current, e.currentTarget, target);\n            }\n\n            if (e.keyCode == keys.ESC) {\n              handled = this._handleEscKey(current, e.currentTarget);\n            }\n\n            if (canHandle && e.keyCode == keys.HOME) {\n              handled = this._handleHome(current, e.ctrlKey);\n            }\n\n            if (canHandle && e.keyCode == keys.END) {\n              handled = this._handleEnd(current, e.ctrlKey);\n            }\n\n            if (e.keyCode == keys.TAB) {\n              handled = this._handleTabKey(current, e.currentTarget, e.shiftKey);\n            }\n\n            if (handled) {\n              //prevent scrolling while pressing the keys\n              e.preventDefault(); //required in hierarchy\n\n              e.stopPropagation();\n            }\n          },\n          _handleExpand: function (current) {\n            var that = this;\n            var row = current.parent();\n            var model = that.dataItem(row);\n\n            if (current.hasClass(\"k-header\")) {\n              return false;\n            }\n\n            if (model && model.hasChildren && !model.expanded && !that.trigger(EXPAND, {\n              model: model\n            })) {\n              this.expand(row);\n              return true;\n            }\n\n            return false;\n          },\n          _handleCollapse: function (current) {\n            var that = this;\n            var row = current.parent();\n            var model = that.dataItem(row);\n\n            if (current.hasClass(\"k-header\")) {\n              return false;\n            }\n\n            if (model && model.hasChildren && model.expanded && !that.trigger(COLLAPSE, {\n              model: model\n            })) {\n              that.collapse(row);\n              return true;\n            }\n\n            return false;\n          },\n          _handleHome: function (current, ctrl) {\n            var row = current.parent();\n            var rowContainer = row.parent();\n            var isInLockedTable = this.lockedTable && this.lockedTable.children(\"tbody\")[0] === rowContainer[0];\n            var isInBody = rowContainer[0] === this.tbody[0];\n            var prev;\n\n            if (ctrl) {\n              if (this.lockedTable) {\n                prev = this.lockedTable.find(NAVROW + \" > td:visible\").first();\n              } else {\n                prev = this.table.find(NAVROW + \" > td:visible\").first();\n              }\n            } else if (isInBody || isInLockedTable) {\n              if (isInBody && this.lockedTable) {\n                row = this._relatedRow(row);\n              }\n\n              prev = row.children(NAVCELL).first();\n            }\n\n            if (prev && prev.length) {\n              this.current(prev);\n              return true;\n            }\n          },\n          _handleEnd: function (current, ctrl) {\n            var row = current.parent();\n            var rowContainer = row.parent();\n            var isInLockedTable = this.lockedTable && this.lockedTable.children(\"tbody\")[0] === rowContainer[0];\n            var isInBody = rowContainer[0] === this.tbody[0];\n            var next;\n\n            if (ctrl) {\n              next = this.table.find(ITEMROW).last().children(NAVCELL).last();\n            } else if (isInBody || isInLockedTable) {\n              if (!isInBody && this.lockedTable) {\n                row = this._relatedRow(row);\n              }\n\n              next = row.children(NAVCELL).last();\n            }\n\n            if (next && next.length) {\n              this.current(next);\n              return true;\n            }\n          },\n          _handlePageDown: function () {\n            var that = this;\n\n            if (!that._isPageable()) {\n              return false;\n            }\n\n            that.dataSource._restorePageSizeAfterAddChild();\n\n            that.dataSource.page(that.dataSource.page() + 1);\n            return true;\n          },\n          _handlePageUp: function () {\n            var that = this;\n\n            if (!that._isPageable()) {\n              return false;\n            }\n\n            that.dataSource._restorePageSizeAfterAddChild();\n\n            that.dataSource.page(that.dataSource.page() - 1);\n            return true;\n          },\n          _handleEscKey: function (current, currentTable) {\n            var active = kendo._activeElement();\n\n            var currentIndex;\n            var that = this;\n            var row;\n            var rowIndex;\n            var cellIndex;\n            var tbody;\n\n            if (!current || !current.parent().hasClass(\"k-grid-edit-row\")) {\n              if (current.has(active).length) {\n                // return focus back to the table\n                focusTable(currentTable, true);\n                return true;\n              }\n\n              return false;\n            }\n\n            if (that._isIncellEditable()) {\n              row = current.parent();\n              cellIndex = current.index();\n              rowIndex = row.index();\n              tbody = row.closest(\"tbody\");\n              that.closeCell(true); // refresh the current element as the DOM element reference can be changed after render()\n              // moving this to closeCell() causes flickering when clicking on a cell and then on another\n              // as 'k-state-focused' is shown for the closing cell and then added to the newly edited cell\n\n              that._setCurrent(tbody.children().eq(rowIndex).children().eq(cellIndex));\n            } else {\n              currentIndex = $(current).parent().index();\n\n              if (active) {\n                active.blur();\n              }\n\n              this.cancelRow();\n\n              if (currentIndex >= 0) {\n                this.current(this.items().eq(currentIndex).children(NAVCELL).first());\n              }\n            }\n\n            focusTable(currentTable, true);\n            return true;\n          },\n          _handleEnterKey: function (current, currentTable, target) {\n            var editable = this.options.editable;\n            var container = target.closest(\"[role=gridcell]\");\n            var focusable;\n\n            if (!target.is(\"table\") && !$.contains(current[0], target[0])) {\n              current = container;\n            }\n\n            if (current.is(\"th\")) {\n              // sort the column, if possible\n              current.find(\".k-link\").click();\n              return true;\n            }\n\n            focusable = current.find(\":kendoFocusable\").first();\n\n            if (focusable[0] && current.hasClass(\"k-state-focused\")) {\n              focusable.trigger(\"focus\");\n              return true;\n            }\n\n            if (editable && !target.is(\":button,.k-button,textarea\")) {\n              if (!container[0]) {\n                container = current;\n              }\n\n              this._handleEditing(container, false, currentTable);\n\n              return true;\n            }\n\n            return false;\n          },\n          _handleTabKey: function (current, currentTable, shiftKey) {\n            var that = this;\n\n            var incellEditing = that.options.editable && that._isIncellEditable();\n\n            var cell;\n\n            if (!incellEditing || current.is(\"th\")) {\n              return false;\n            }\n\n            cell = $(activeElement()).closest(DOT + classNames.editCell);\n\n            if (cell[0] && cell[0] !== current[0]) {\n              current = cell;\n            }\n\n            cell = that._tabNext(current, currentTable, shiftKey);\n\n            if (cell.length) {\n              that._handleEditing(current, cell, cell.closest(TABLE));\n\n              return true;\n            } else {\n              that._preventPageSizeRestore = false;\n            }\n\n            return false;\n          },\n          _tabNext: function (current, currentTable, back) {\n            var that = this;\n            var switchRow = true;\n            var next = back ? current.prevAll(DATA_CELL).first() : current.nextAll(\":visible\").first();\n\n            if (!next.length) {\n              next = current.parent();\n\n              if (that.lockedTable) {\n                switchRow = back && currentTable == that.lockedTable[0] || !back && currentTable == that.table[0];\n                next = that._relatedRow(next);\n              }\n\n              if (switchRow) {\n                next = next[back ? \"prevAll\" : \"nextAll\"](\"tr:not(.k-grouping-row):not(.k-detail-row):visible\").first();\n              }\n\n              if (back) {\n                next = next.children(DATA_CELL).last();\n              } else {\n                next = next.children(DATA_CELL).first();\n              }\n\n              that.dataSource._restorePageSizeAfterAddChild();\n            }\n\n            return next;\n          },\n          _handleEditing: function (current, next, table) {\n            var that = this,\n                active = $(kendo._activeElement()),\n                isIE = browser.msie,\n                editContainer,\n                focusable,\n                isEdited;\n            var editable = that.options.editable && that.options.editable.update !== false;\n\n            var incellEditing = that._isIncellEditable();\n\n            var nextFocusableCellRowIndex = $(next).parents(\"tr\").index();\n            var nextFocusableCellIndex = $(next).index();\n            var currentFocusedCellRowIndex = $(current).parents(\"tr\").index();\n            var currentFocusedCellIndex = current.index();\n            var editedCell;\n            table = $(table);\n\n            if (incellEditing) {\n              isEdited = current.hasClass(classNames.editCell);\n            } else {\n              isEdited = current.parent().hasClass(\"k-grid-edit-row\");\n            }\n\n            if (that.editor) {\n              editContainer = that.editor.wrapper;\n\n              if (editContainer && $.contains(editContainer[0], active[0])) {\n                if (browser.opera) {\n                  active.trigger(\"blur\").change().triggerHandler(\"blur\");\n                } else {\n                  active.trigger(\"blur\");\n\n                  if (isIE) {\n                    //IE10 with jQuery 1.9.x does not trigger blur handler\n                    //numeric textbox does trigger change\n                    active.trigger(\"blur\");\n                  }\n                }\n              }\n\n              if (!that.editor) {\n                focusTable(table);\n                return;\n              }\n\n              if (that.editor.end()) {\n                if (incellEditing) {\n                  that._preventPageSizeRestore = true;\n                  that.closeCell();\n                  that._preventPageSizeRestore = false;\n\n                  if ($(that.table).add(that.lockedTable).find(DOT + classNames.editCell).length === 0) {\n                    that.current(table.find(\"tbody\").children().eq(currentFocusedCellRowIndex).children().eq(currentFocusedCellIndex));\n                  }\n                } else {\n                  that.saveRow();\n                  isEdited = true;\n                }\n              } else {\n                if (incellEditing) {\n                  that.current(editContainer);\n                } else {\n                  that.current(editContainer.children().filter(NAVCELL).first());\n                }\n\n                focusable = editContainer.find(\":kendoFocusable\").first()[0];\n\n                if (focusable) {\n                  focusable.focus();\n                }\n\n                return;\n              }\n            } // the next cell to focus might be re-rendered, so update the reference to it if it is an element\n\n\n            next = $(next).length && table.find(next).length === 0 ? table.find(\"tbody\").children().eq(nextFocusableCellRowIndex).children().eq(nextFocusableCellIndex) : next;\n\n            if (next) {\n              that.current(next);\n            }\n\n            focusTable(table, true);\n\n            if (!editable) {\n              return;\n            }\n\n            if (!isEdited && !next || next) {\n              var currentIndex = that.current().index();\n\n              if (incellEditing) {\n                that.editCell(that.current());\n                editedCell = $(that.table).add(that.lockedTable).find(DOT + classNames.editCell)[0];\n\n                if (editedCell) {\n                  that._current = $(editedCell);\n                } else {\n                  that.current(that._findCurrentCell());\n                }\n              } else {\n                that.editRow(that.current().parent());\n                that.current(that.editor.wrapper.children().eq(currentIndex));\n                that.current().removeClass(\"k-state-focused\");\n              }\n            } else {\n              that.dataSource._restorePageSizeAfterAddChild();\n            }\n          },\n          _moveRight: function (current) {\n            var next = current.nextAll(NAVCELL).first();\n            var row = current.parent();\n            var rowIndex = row.index();\n\n            if (current.hasClass(\"k-header\") || row.is('.k-filter-row')) {\n              next = current.nextAll(NAVHEADER).first();\n\n              if (!next[0] && this.lockedTable && current.closest(\"table\")[0] === this.lockedHeader.find(\"table\")[0]) {\n                next = this.thead.find(\"tr\").eq(rowIndex).find(NAVHEADER).first();\n              }\n            }\n\n            if (!next[0] && this.lockedTable && current.closest(\"table\")[0] === this.lockedTable[0]) {\n              next = this._relatedRow(row).children(NAVCELL).first();\n            }\n\n            if (next[0] && next[0] !== current[0]) {\n              focusTable(next.closest(\"table\"), true);\n            }\n\n            this.current(next);\n            return true;\n          },\n          _moveLeft: function (current) {\n            var prev = current.prevAll(NAVCELL).first();\n            var row = current.parent();\n            var rowIndex = row.index();\n\n            if (current.hasClass(\"k-header\") || row.is('.k-filter-row')) {\n              prev = current.prevAll(NAVHEADER).first();\n\n              if (!prev[0] && this.lockedTable && current.closest(\"table\")[0] === this.thead.parent()[0]) {\n                prev = this.lockedHeader.find(\">table>thead>tr\").eq(rowIndex).children(NAVHEADER).last();\n              }\n            }\n\n            if (!prev[0] && this.lockedTable && current.closest(\"table\")[0] === this.table[0]) {\n              prev = this._relatedRow(row).children(NAVCELL).last();\n            }\n\n            if (prev[0] && prev[0] !== current[0]) {\n              focusTable(prev.closest(\"table\"), true);\n            }\n\n            this.current(prev);\n            return true;\n          },\n          _moveUp: function (current, shiftKey) {\n            var container = current.parent().parent();\n            var prev;\n\n            if (shiftKey) {\n              prev = current.parent();\n              prev = prev.prevAll(ITEMROW).first();\n              prev = current.parent().is(ITEMROW) ? prev.children().eq(current.index()) : prev.children(DATA_CELL).last();\n            } else {\n              prev = this._prevVerticalCell(container, current);\n\n              if (!prev[0]) {\n                this._lastCellIndex = 0;\n                container = this._verticalContainer(container, true);\n                prev = this._prevVerticalCell(container, current);\n\n                if (prev[0]) {\n                  focusTable(container.parent(), true);\n                }\n              }\n            }\n\n            var tmp = this._lastCellIndex || 0;\n            this.current(prev);\n            this._lastCellIndex = tmp;\n            return true;\n          },\n          _moveDown: function (current, shiftKey) {\n            var container = current.parent().parent();\n            var next;\n\n            if (shiftKey) {\n              next = current.parent();\n              next = next.nextAll(ITEMROW).first();\n              next = current.parent().is(ITEMROW) ? next.children().eq(current.index()) : next.children(DATA_CELL).first();\n            } else {\n              next = this._nextVerticalCell(container, current);\n\n              if (!next[0]) {\n                this._lastCellIndex = 0;\n                container = this._verticalContainer(container);\n                next = this._nextVerticalCell(container, current);\n\n                if (next[0]) {\n                  focusTable(container.parent(), true);\n                }\n              }\n            }\n\n            var tmp = this._lastCellIndex || 0;\n            this.current(next);\n            this._lastCellIndex = tmp;\n            return true;\n          },\n          _tableClick: function (e) {\n            var currentTarget = $(e.currentTarget),\n                isHeader = currentTarget.is(\"th\"),\n                table = this.table.add(this.lockedTable),\n                headerTable = this.thead.parent().add($(\">table\", this.lockedHeader)),\n                isInput = isInputElement(e.target),\n                currentTable = currentTarget.closest(\"table\")[0];\n\n            if (kendo.support.touch) {\n              return;\n            }\n\n            if (currentTable !== table[0] && currentTable !== table[1] && currentTable !== headerTable[0] && currentTable !== headerTable[1]) {\n              return;\n            }\n\n            if (this.options.navigatable) {\n              this.current(currentTarget);\n            }\n\n            if (isHeader || !isInput) {\n              setTimeout(function () {\n                if (!isInputElement(kendo._activeElement()) || !$.contains(currentTable, kendo._activeElement())) {\n                  focusTable(currentTable, true);\n                }\n              });\n            }\n\n            if (isHeader) {\n              e.preventDefault(); //if any problem occurs, call preventDefault only for the clicked header links\n            }\n          },\n          _setTabIndex: function (table) {\n            this._navigatableTables.attr(TABINDEX, -1);\n\n            table.attr(TABINDEX, 0);\n          },\n          _tableFocus: function (e) {\n            var current = this.current();\n            var table = $(e.currentTarget);\n\n            if (current && current.is(\":visible\")) {\n              current.addClass(classNames.focused);\n            } else {\n              this.current(table.find(NAVROW + \" > td:visible\").first());\n            }\n\n            this._setTabIndex(table);\n          },\n          _tableBlur: function () {\n            var current = this.current();\n\n            if (current) {\n              current.removeClass(classNames.focused);\n            }\n          },\n          _attachEvents: function () {\n            var that = this;\n            var retryButton = DOT + classNames.retry;\n            that._userEvents = new kendo.UserEvents(that.element, {\n              press: that._onPress.bind(that),\n              allowSelection: true\n            });\n            this.element.on(CLICK + NS, retryButton, this._dataSourceFetchProxy).on(CLICK + NS, \".k-button[data-command]\", this._commandClick.bind(this)).on(INPUT + NS, \".k-grid-search input\", this._search.bind(this));\n\n            this._attachCellEditingEventHandlers();\n          },\n          _onPress: function (e) {\n            var that = this;\n            var icons = DOT + classNames.iconCollapse + \", .\" + classNames.iconExpand + \", .\" + classNames.refresh;\n\n            if ($(e.event.target).is(icons)) {\n              that._toggleChildren.call(that, e.event);\n            }\n          },\n          _attachCellEditingEventHandlers: function () {\n            var that = this;\n            var editable = that.options.editable;\n            var selectable = that.selectable && that.selectable.options.multiple;\n\n            var closeCell = function (e) {\n              var target = activeElement();\n              var editor = that.editor || {};\n              var cell = editor.element;\n\n              if (cell && !$.contains(cell[0], target) && cell[0] !== target && !$(target).closest(\".k-animation-container\").length) {\n                if (editor.end()) {\n                  if (!e.relatedTarget && that._isPageable() && !isUndefined(that.dataSource._addChildPageSize)) {\n                    that._preventPageSizeRestore = false;\n                  }\n\n                  that.closeCell();\n                }\n              }\n\n              that._preventPageSizeRestore = false;\n            };\n\n            if (that._isIncellEditable() && editable.update !== false) {\n              that.wrapper.on(CLICK + NS, \"tr:not(.k-grouping-row) > td\", function (e) {\n                var td = $(this),\n                    isLockedCell = that.lockedTable && td.closest(\"table\")[0] === that.lockedTable[0];\n\n                if (td.hasClass(classNames.editCell) || td.has(\"a.k-grid-delete\").length || td.has(\"button.k-grid-delete\").length || td.closest(\"tbody\")[0] !== that.tbody[0] && !isLockedCell || $(e.target).is(\":input\") || $(e.target).hasClass(classNames.iconExpand) || $(e.target).hasClass(classNames.iconCollapse)) {\n                  if (!that.editor) {\n                    that.dataSource._restorePageSizeAfterAddChild();\n                  }\n\n                  that._preventPageSizeRestore = false;\n                  return;\n                }\n\n                if (that.editor) {\n                  if (that.editor.end()) {\n                    if (selectable) {\n                      $(activeElement()).trigger(\"blur\");\n                    }\n\n                    that.closeCell();\n                    that.editCell(td);\n                  }\n                } else {\n                  that.editCell(td);\n                }\n              }).on(\"mousedown\" + NS, \"tr:not(.k-grouping-row) > td\", function (e) {\n                // cache the result on \"mousedown\", which is fired before \"focusout\" and \"click\"\n                if (that.editor && that._isPageable() && !isUndefined(that.dataSource._addChildPageSize)) {\n                  that._preventPageSizeRestore = $(e.target).parents(DOT + classNames.editRow).length > 0;\n                } else {\n                  that._preventPageSizeRestore = false;\n                }\n              }).on(\"focusin\" + NS, function () {\n                // fix focus issue in IE\n                if (!$.contains(this, activeElement())) {\n                  clearTimeout(that._closeCellTimeout);\n                  that._closeCellTimeout = null;\n                }\n              }).on(\"focusout\" + NS, function (e) {\n                that._closeCellTimeout = setTimeout(function () {\n                  closeCell(e);\n                }, 1);\n              });\n            }\n          },\n          _commandByName: function (name) {\n            var columns = this.columns;\n            var toolbar = Array.isArray(this.options.toolbar) ? this.options.toolbar : [];\n            var i, j, commands, currentName;\n            name = name.toLowerCase();\n\n            if (defaultCommands[name]) {\n              return defaultCommands[name];\n            } // command not found in defaultCommands, must be custom\n\n\n            for (i = 0; i < columns.length; i++) {\n              commands = columns[i].command;\n\n              if (commands) {\n                for (j = 0; j < commands.length; j++) {\n                  currentName = commands[j].name;\n\n                  if (!currentName) {\n                    continue;\n                  }\n\n                  if (currentName.toLowerCase() == name) {\n                    return commands[j];\n                  }\n                }\n              }\n            } // custom command in toolbar\n\n\n            for (i = 0; i < toolbar.length; i++) {\n              currentName = toolbar[i].name;\n\n              if (!currentName) {\n                continue;\n              }\n\n              if (currentName.toLowerCase() == name) {\n                return toolbar[i];\n              }\n            }\n          },\n          _commandClick: function (e) {\n            var button = $(e.currentTarget);\n            var commandName = button.attr(\"data-command\");\n\n            var command = this._commandByName(commandName);\n\n            var row = button.parentsUntil(this.wrapper, \"tr\");\n            row = row.length ? row : undefined;\n\n            if (command) {\n              if (command.methodName) {\n                this[command.methodName](row);\n              } else if (command.click) {\n                command.click.call(this, e);\n              }\n\n              e.preventDefault();\n            }\n          },\n          _search: function (e) {\n            var that = this;\n            var input = e.currentTarget;\n            clearTimeout(that._searchTimeOut);\n            that._searchTimeOut = setTimeout(function () {\n              that._searchTimeOut = null;\n              var options = that.options;\n              var searchFields = options.search ? options.search.fields : null;\n              var expression = {\n                filters: [],\n                logic: \"or\"\n              };\n              var value = input.value;\n\n              if (!searchFields) {\n                searchFields = getColumnsFields(options.columns);\n              }\n\n              if (value) {\n                for (var i = 0; i < searchFields.length; i++) {\n                  expression.filters.push({\n                    field: searchFields[i],\n                    operator: \"contains\",\n                    value: value\n                  });\n                }\n              } else {\n                expression = {};\n              }\n\n              that.dataSource.filter(expression);\n            }, 300);\n          },\n          _ensureExpandableColumn: function () {\n            if (this._autoExpandable) {\n              delete this._autoExpandable.expandable;\n            }\n\n            var visibleColumns = grep(this.columns, not(is(\"hidden\")));\n            visibleColumns = grep(visibleColumns, not(is(\"command\")));\n            visibleColumns = grep(visibleColumns, not(is(\"selectable\")));\n            var expandableColumns = grep(visibleColumns, is(\"expandable\"));\n\n            if (this.columns.length && !expandableColumns.length) {\n              this._autoExpandable = visibleColumns[0];\n              visibleColumns[0].expandable = true;\n            }\n          },\n          _columns: function () {\n            var that = this;\n            var columns = this.options.columns || [];\n            this.columns = map(columns, function (column) {\n              column = typeof column === \"string\" ? {\n                field: column\n              } : column;\n              return extend({\n                encoded: true\n              }, column);\n            });\n            var lockedCols = lockedColumns(columns);\n\n            if (lockedCols.length > 0) {\n              if (this.options.rowTemplate || this.options.altRowTemplate) {\n                throw new Error(\"Having both row template and locked columns is not supported\");\n              }\n\n              this._hasLockedColumns = true;\n              this.columns = lockedCols.concat(nonLockedColumns(this.columns));\n            }\n\n            this.columns = normalizeColumns(this.columns);\n\n            this._ensureExpandableColumn();\n\n            this._columnTemplates();\n\n            this._columnAttributes();\n\n            if ($.grep(leafColumns(that.columns), function (col) {\n              if (col.selectable) {\n                that._includeChildren = col.includeChildren;\n              }\n\n              return col.selectable;\n            }).length) {\n              that._checkBoxSelection = true;\n              that.element.on(CLICK + NS, \"tbody > tr \" + CHECKBOXINPUT, that._checkboxClick.bind(that));\n              that.element.on(CLICK + NS, \"thead > tr \" + CHECKBOXINPUT, that._headerCheckboxClick.bind(that));\n            }\n          },\n          _columnTemplates: function () {\n            var idx, length, column;\n            var columns = leafColumns(this.columns);\n\n            for (idx = 0, length = columns.length; idx < length; idx++) {\n              column = columns[idx];\n\n              if (column.template) {\n                column.template = kendo.template(column.template);\n              }\n\n              if (this._isIncellEditable()) {\n                column.dirtyCellTemplate = this._createDirtyColumnTemplate(column);\n                column.dirtyIndicatorTemplate = this._createIndicatorTemplate(column);\n              }\n\n              if (column.headerTemplate) {\n                column.headerTemplate = kendo.template(column.headerTemplate);\n              }\n\n              if (column.footerTemplate) {\n                column.footerTemplate = kendo.template(column.footerTemplate);\n              }\n            }\n          },\n          _columnAttributes: function () {\n            // column style attribute is string, kendo.dom expects object\n            var idx, length;\n            var columns = this.columns;\n\n            function convertStyle(attr) {\n              var properties, i, declaration;\n\n              if (attr && attr.style && attr.style.split) {\n                properties = attr.style.split(\";\");\n                attr.style = {};\n\n                for (i = 0; i < properties.length; i++) {\n                  declaration = properties[i].split(\":\");\n                  var name = kendo.trim(declaration[0]);\n\n                  if (name) {\n                    attr.style[$.camelCase(name)] = kendo.trim(declaration[1]);\n                  }\n                }\n              }\n            }\n\n            for (idx = 0, length = columns.length; idx < length; idx++) {\n              convertStyle(columns[idx].attributes);\n              convertStyle(columns[idx].headerAttributes);\n            }\n          },\n          _clearSortClasses: function () {\n            var that = this;\n\n            if (that.content) {\n              that.content.find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").removeClass(\"k-sorted\");\n            }\n\n            if (that.lockedContent) {\n              that.lockedContent.find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").removeClass(\"k-sorted\");\n            }\n          },\n          _layout: function () {\n            var columns = this.columns;\n            var element = this.element;\n            var layout = \"\";\n            this.wrapper = element.addClass(classNames.wrapper);\n            layout = \"<div class='#= gridHeader #'>\";\n\n            if (this._hasLockedColumns) {\n              layout += \"<div class='k-grid-header-locked'>\" + \"<table role='grid'>\" + \"<colgroup></colgroup>\" + \"<thead role='rowgroup'></thead>\" + \"</table>\" + \"</div>\";\n            }\n\n            layout += \"<div class='#= gridHeaderWrap #'>\" + \"<table role='grid'>\" + \"<colgroup></colgroup>\" + \"<thead role='rowgroup'></thead>\" + \"</table>\" + \"</div>\" + \"</div>\";\n\n            if (this._hasLockedColumns) {\n              layout += \"<div class='k-grid-content-locked'>\" + \"<table role='treegrid' tabindex='0'>\" + \"<colgroup></colgroup>\" + \"<tbody></tbody>\" + \"</table>\" + \"</div>\";\n            }\n\n            layout += \"<div class='#= gridContentWrap # k-auto-scrollable'>\" + \"<table role='treegrid' tabindex='0'>\" + \"<colgroup></colgroup>\" + \"<tbody></tbody>\" + \"</table>\" + \"</div>\";\n\n            if (!this.options.scrollable) {\n              layout = \"<table role='treegrid' tabindex='0'>\" + \"<colgroup></colgroup>\" + \"<thead class='#= gridHeader #' role='rowgroup'></thead>\" + \"<tbody></tbody>\" + \"</table>\";\n            }\n\n            if (this.options.toolbar) {\n              layout = \"<div class='#= toolbar # #= gridToolbar #'></div>\" + layout;\n            }\n\n            element.append(kendo.template(layout)(classNames) + \"<div class='k-status' role='alert' aria-live='polite'></div>\");\n            this.toolbar = element.find(DOT + classNames.gridToolbar);\n            var header = element.find(DOT + classNames.gridHeader).find(\"thead\").addBack().filter(\"thead\");\n            this.thead = header.last();\n\n            if (this.options.scrollable) {\n              var rtl = kendo.support.isRtl(element);\n              element.find(\"div.\" + classNames.gridHeader).css(rtl ? \"padding-left\" : \"padding-right\", kendo.support.scrollbar());\n            }\n\n            var content = element.find(DOT + classNames.gridContentWrap);\n\n            if (!content.length) {\n              content = element;\n            } else {\n              this.content = content;\n            }\n\n            this.table = content.find(\">table\");\n            this.tbody = this.table.find(\">tbody\");\n\n            if (this._hasLockedColumns) {\n              this.lockedHeader = header.first().closest(\".k-grid-header-locked\");\n              this.lockedContent = element.find(\".k-grid-content-locked\");\n              this.lockedTable = this.lockedContent.children();\n            }\n\n            this._initVirtualTrees();\n\n            this._renderCols();\n\n            this._renderHeader();\n\n            this.angular(\"compile\", function () {\n              return {\n                elements: header.find(\"th.k-header\").get(),\n                data: map(columns, function (col) {\n                  return {\n                    column: col\n                  };\n                })\n              };\n            });\n          },\n          _initVirtualTrees: function () {\n            this._headerColsTree = new kendoDom.Tree(this.thead.prev()[0]);\n            this._contentColsTree = new kendoDom.Tree(this.tbody.prev()[0]);\n            this._headerTree = new kendoDom.Tree(this.thead[0]);\n            this._contentTree = new kendoDom.Tree(this.tbody[0]);\n            this._statusTree = new kendoDom.Tree(this.element.children(\".k-status\")[0]);\n\n            if (this.lockedHeader) {\n              this._lockedHeaderColsTree = new kendoDom.Tree(this.lockedHeader.find(\"colgroup\")[0]);\n              this._lockedContentColsTree = new kendoDom.Tree(this.lockedTable.find(\">colgroup\")[0]);\n              this._lockedHeaderTree = new kendoDom.Tree(this.lockedHeader.find(\"thead\")[0]);\n              this._lockedContentTree = new kendoDom.Tree(this.lockedTable.find(\">tbody\")[0]);\n            }\n          },\n          _toolbar: function () {\n            var options = this.options.toolbar;\n            var toolbar = this.toolbar;\n\n            if (!options) {\n              return;\n            }\n\n            if (Array.isArray(options)) {\n              var buttons = this._buildCommands(options);\n\n              new kendoDom.Tree(toolbar[0]).render(buttons);\n            } else {\n              toolbar.append(kendo.template(options)({}));\n            }\n\n            this.angular(\"compile\", function () {\n              return {\n                elements: toolbar.get()\n              };\n            });\n          },\n          _lockedColumns: function () {\n            return grep(this.columns, is(\"locked\"));\n          },\n          _nonLockedColumns: function () {\n            return grep(this.columns, not(is(\"locked\")));\n          },\n          _templateColumns: function () {\n            return grep(this.columns, is(\"template\"));\n          },\n          _flushCache: function () {\n            if (this.options.$angular && this._templateColumns().length) {\n              this._contentTree.render([]);\n\n              if (this._hasLockedColumns) {\n                this._lockedContentTree.render([]);\n              }\n            }\n          },\n          _render: function (options) {\n            var that = this;\n            options = options || {};\n            options = that._renderOptions(options);\n            var messages = this.options.messages;\n\n            var pageable = that._isPageable();\n\n            var dataSource = that.dataSource;\n            var maps = {\n              children: options.filteredChildrenMap || options.childrenMap,\n              ids: options.idsMap\n            };\n            var dataMaps = pageable ? maps && maps.children && maps.ids ? maps : dataSource._initDataMaps(dataSource._getData()) : {};\n            var childrenMap = dataMaps.children;\n            var idsMap = dataMaps.ids;\n            options.childrenMap = childrenMap;\n            options.idsMap = idsMap;\n\n            var data = that._dataToRender(options);\n\n            var level = that._renderedModelLevel(data[0], options);\n\n            var uidAttr = kendo.attr(\"uid\");\n            var hasFooterTemplate;\n            var selected = this.select().removeClass(\"k-state-selected\").map(function (_, row) {\n              return $(row).attr(uidAttr);\n            });\n            var viewChildrenMap;\n            this._absoluteIndex = 0;\n\n            this._angularItems(\"cleanup\");\n\n            this._angularFooters(\"cleanup\");\n\n            this._flushCache();\n\n            that._clearRenderMap();\n\n            if (options.error) {\n              // root-level error message\n              this._showStatus(kendo.template(\"#: messages.requestFailed # \" + \"<button class='#= buttonClass # k-button-md k-rounded-md k-button-solid k-button-solid-base'><span class='k-button-text'>#: messages.retry #</span></button>\")({\n                buttonClass: [classNames.button, classNames.retry].join(\" \"),\n                messages: messages\n              }));\n            } else if (!data.length) {\n              // no rows message\n              this._hideStatus();\n\n              this._showNoRecordsTemplate();\n            } else {\n              if (pageable) {\n                viewChildrenMap = that._viewChildrenMap(options);\n              } // render rows\n\n\n              this._hideStatus();\n\n              hasFooterTemplate = this._hasFooterTemplate();\n\n              this._contentTree.render(this._trs({\n                columns: leafColumns(nonLockedColumns(this.columns)),\n                editedColumn: options.editedColumn,\n                editedColumnIndex: options.editedColumnIndex,\n                aggregates: options.aggregates,\n                selected: selected,\n                data: data,\n                childrenMap: childrenMap,\n                viewChildrenMap: viewChildrenMap,\n                hasFooterTemplate: hasFooterTemplate,\n                visible: true,\n                level: 0\n              }));\n\n              if (this._hasLockedColumns) {\n                this._absoluteIndex = 0;\n\n                this._lockedContentTree.render(this._trs({\n                  columns: leafColumns(lockedColumns(this.columns)),\n                  editedColumn: options.editedColumn,\n                  editedColumnIndex: options.editedColumnIndex,\n                  aggregates: options.aggregates,\n                  selected: selected,\n                  data: data,\n                  childrenMap: childrenMap,\n                  viewChildrenMap: viewChildrenMap,\n                  hasFooterTemplate: hasFooterTemplate,\n                  visible: true,\n                  level: level\n                }));\n              }\n            }\n\n            if (this._touchScroller) {\n              this._touchScroller.contentResized();\n            }\n\n            this._muteAngularRebind(function () {\n              this._angularItems(\"compile\");\n\n              this._angularFooters(\"compile\");\n            });\n\n            this.items().filter(function () {\n              return $.inArray($(this).attr(uidAttr), selected) >= 0;\n            }).addClass(\"k-state-selected\");\n\n            this._syncLockedContentHeight();\n\n            that._togglePagerVisibility();\n\n            that._setExpanderElement();\n          },\n          _setExpanderElement: function () {\n            var that = this,\n                hiddenDivClass = 'k-grid-content-expander',\n                hiddenDiv = '<div class=\"' + hiddenDivClass + '\"></div>',\n                expander;\n\n            if (that.options.scrollable && that.wrapper.is(\":visible\")) {\n              expander = that.table.parent().children('.' + hiddenDivClass);\n\n              if (!that.dataSource || !that.dataSource.view().length) {\n                if (!expander[0]) {\n                  expander = $(hiddenDiv).appendTo(that.table.parent());\n                }\n\n                if (that.thead) {\n                  expander.width(that.thead.width());\n                }\n              } else if (expander[0]) {\n                expander.remove();\n              }\n            }\n          },\n          _renderProgress: function (toggle) {\n            kendo.ui.progress(this.wrapper, toggle);\n          },\n          _renderOptions: function (options) {\n            options = options || {};\n            var that = this;\n\n            var dataMaps = that.dataSource._getDataMaps();\n\n            var filter = that.dataSource.filter();\n\n            if (that._isPageable()) {\n              options.childrenMap = dataMaps.children;\n              options.idsMap = dataMaps.ids;\n\n              if (filter) {\n                options.filteredChildrenMap = dataMaps.filteredChildren;\n              }\n            }\n\n            return options;\n          },\n          _renderedModelLevel: function (model, options) {\n            return !this._isPageable() ? 0 : this.dataSource._pageableModelLevel(model, options);\n          },\n          _viewChildrenMap: function (options) {\n            options = options || {};\n            var that = this;\n            var dataSource = that.dataSource;\n            var viewChildrenMap = dataSource.childrenMap(dataSource.view());\n\n            var idField = dataSource._modelIdField();\n\n            var parentsNotInView = dataSource._parentNodesNotInView();\n\n            var parentNotInView;\n            var parentNotInViewId;\n            var parents;\n            var parent;\n            var parentId;\n            var child;\n            var childId;\n            var parentsCopy;\n\n            that._clearRenderMap();\n\n            for (var i = 0; i < parentsNotInView.length; i++) {\n              parentNotInView = parentsNotInView[i];\n              parentNotInViewId = parentNotInView[idField];\n\n              that._markNodeAsNonRenderable(parentNotInViewId);\n\n              viewChildrenMap[parentNotInViewId] = viewChildrenMap[parentNotInViewId] || [];\n              parents = dataSource._parentNodes(parentNotInView); // copy the items to avoid mutating the original collection\n\n              parentsCopy = parents.slice();\n              parentsCopy.push(parentNotInView);\n\n              for (var parentIndex = 0; parentIndex < parentsCopy.length - 1; parentIndex++) {\n                parent = parentsCopy[parentIndex];\n                parentId = parent[idField];\n\n                that._markNodeAsNonRenderable(parentId);\n\n                viewChildrenMap[parentId] = viewChildrenMap[parentId] || [];\n                child = parentsCopy[parentIndex + 1];\n                childId = child[idField];\n\n                that._markNodeAsNonRenderable(childId);\n\n                viewChildrenMap[childId] = viewChildrenMap[childId] || [];\n\n                if (viewChildrenMap[parentId].indexOf(child) === -1) {\n                  viewChildrenMap[parentId].unshift(child);\n                }\n              }\n            }\n\n            return viewChildrenMap;\n          },\n          _clearRenderMap: function () {\n            this._skipRenderingMap = {};\n          },\n          _dataToRender: function (options) {\n            var that = this;\n\n            if (that._isPageable()) {\n              return that.dataSource._pageableRootNodes(options);\n            }\n\n            return that.dataSource.rootNodes();\n          },\n          _markNodeAsNonRenderable: function (nodeId) {\n            this._skipRenderingMap[nodeId] = true;\n          },\n          _adjustRowsHeight: function (table1, table2) {\n            if (!this._hasLockedColumns) {\n              return;\n            }\n\n            var rows = table1[0].rows;\n            var length = rows.length;\n            var idx;\n            var rows2 = table2[0].rows;\n            var containers = table1.add(table2);\n            var containersLength = containers.length;\n            var heights = [];\n\n            for (idx = 0; idx < length; idx++) {\n              if (!rows2[idx]) {\n                break;\n              }\n\n              if (rows[idx].style.height) {\n                rows[idx].style.height = rows2[idx].style.height = \"\";\n              }\n            }\n\n            for (idx = 0; idx < length; idx++) {\n              if (!rows2[idx]) {\n                break;\n              }\n\n              var offsetHeight1 = rows[idx].offsetHeight;\n              var offsetHeight2 = rows2[idx].offsetHeight;\n              var height = 0;\n\n              if (offsetHeight1 > offsetHeight2) {\n                height = offsetHeight1;\n              } else if (offsetHeight1 < offsetHeight2) {\n                height = offsetHeight2;\n              }\n\n              heights.push(height);\n            }\n\n            for (idx = 0; idx < containersLength; idx++) {\n              containers[idx].style.display = \"none\";\n            }\n\n            for (idx = 0; idx < length; idx++) {\n              if (heights[idx]) {\n                //add one to resolve row misalignment in IE\n                rows[idx].style.height = rows2[idx].style.height = heights[idx] + 1 + \"px\";\n              }\n            }\n\n            for (idx = 0; idx < containersLength; idx++) {\n              containers[idx].style.display = \"\";\n            }\n          },\n          _ths: function (columns, rowSpan) {\n            var ths = [];\n            var column, title, children, cellClasses, attr, headerContent;\n            var index;\n            var leafs;\n\n            for (var i = 0, length = columns.length; i < length; i++) {\n              column = columns[i];\n              children = [];\n              cellClasses = [classNames.header];\n\n              if (column.selectable) {\n                leafs = leafColumns(columns);\n                index = inArray(column, leafs);\n                attr = {\n                  scope: \"col\",\n                  role: \"columnheader\",\n                  className: cellClasses.join(\" \")\n                };\n\n                if (column.headerTemplate) {\n                  title = column.headerTemplate({});\n                }\n\n                title = column.headerTemplate ? title : kendo.template(SELECTCOLUMNHEADERTMPL)({});\n\n                if (rowSpan && !column.colSpan) {\n                  attr.rowSpan = rowSpan;\n                }\n\n                if (index > -1) {\n                  attr[kendo.attr(\"index\")] = index;\n                }\n\n                children.push(kendoHtmlElement(title));\n                ths.push(kendoDomElement(\"th\", $.extend(true, {}, attr, column.headerAttributes), children));\n                continue;\n              }\n\n              if (column.headerTemplate) {\n                title = column.headerTemplate({});\n              } else {\n                title = column.title || column.field || \"\";\n              }\n\n              if (column.headerTemplate) {\n                headerContent = kendoHtmlElement(title);\n              } else {\n                headerContent = kendoTextElement(title);\n              }\n\n              if (this.options.sortable) {\n                children.push(kendoDomElement(\"span\", {\n                  className: classNames.headerCellInner\n                }, [kendoDomElement(\"span\", {\n                  className: classNames.link\n                }, [kendoDomElement(\"span\", {\n                  className: classNames.columnTitle\n                }, [headerContent])])]));\n              } else {\n                children.push(headerContent);\n              }\n\n              attr = {\n                \"data-field\": column.field,\n                \"data-title\": column.title,\n                \"style\": column.hidden === true ? {\n                  \"display\": \"none\"\n                } : {},\n                className: cellClasses.join(\" \"),\n                \"role\": \"columnheader\"\n              };\n\n              if (!column.columns) {\n                attr.rowSpan = rowSpan ? rowSpan : 1;\n              }\n\n              if (column.headerAttributes) {\n                if (column.headerAttributes.colSpan === 1) {\n                  delete column.headerAttributes.colSpan;\n                }\n\n                if (column.headerAttributes[\"class\"]) {\n                  attr.className += \" \" + column.headerAttributes[\"class\"];\n                  delete column.headerAttributes[\"class\"];\n                }\n              }\n\n              if (column[\"data-index\"] > -1) {\n                attr[\"data-index\"] = column[\"data-index\"];\n              }\n\n              attr = extend(true, {}, attr, column.headerAttributes);\n              ths.push(kendoDomElement(\"th\", attr, children));\n            }\n\n            return ths;\n          },\n          _cols: function (columns) {\n            var cols = [];\n            var width, attr;\n\n            for (var i = 0; i < columns.length; i++) {\n              if (columns[i].hidden === true) {\n                continue;\n              }\n\n              width = columns[i].width;\n              attr = {};\n\n              if (width && parseInt(width, 10) !== 0) {\n                attr.style = {\n                  width: typeof width === \"string\" ? width : width + \"px\"\n                };\n              }\n\n              cols.push(kendoDomElement(\"col\", attr));\n            }\n\n            return cols;\n          },\n          _clearColsCache: function () {\n            this._headerColsTree.render([]);\n\n            if (this.options.scrollable) {\n              this._contentColsTree.render([]);\n            }\n\n            if (this._hasLockedColumns) {\n              this._lockedHeaderColsTree.render([]);\n\n              this._lockedContentColsTree.render([]);\n            }\n          },\n          _renderCols: function () {\n            var columns = nonLockedColumns(this.columns);\n\n            this._headerColsTree.render(this._cols(leafColumns(columns)));\n\n            if (this.options.scrollable) {\n              this._contentColsTree.render(this._cols(leafColumns(columns)));\n            }\n\n            if (this._hasLockedColumns) {\n              columns = lockedColumns(this.columns);\n\n              this._lockedHeaderColsTree.render(this._cols(leafColumns(columns)));\n\n              this._lockedContentColsTree.render(this._cols(leafColumns(columns)));\n            }\n          },\n          _retrieveFirstColumn: function (columns, rows) {\n            var result = $();\n\n            if (rows.length && columns[0]) {\n              var column = columns[0];\n\n              while (column.columns && column.columns.length) {\n                column = column.columns[0];\n                rows = rows.filter(\":not(:first)\");\n              }\n\n              result = result.add(rows);\n            }\n\n            return result;\n          },\n          _updateFirstColumnClass: function () {\n            var that = this;\n            var columns = that.columns || [];\n            var tr = that.thead.find(\">tr:not(:first, .k-filter-row)\");\n            var rows;\n            columns = nonLockedColumns(columns);\n            rows = that._retrieveFirstColumn(columns, tr);\n\n            if (that.lockedHeader) {\n              tr = that.lockedHeader.find(\"thead>tr:not(.k-filter-row):not(:first)\");\n              columns = lockedColumns(that.columns);\n              rows = rows.add(that._retrieveFirstColumn(columns, tr));\n            }\n\n            rows.each(function () {\n              var ths = $(this).find(\"th\");\n              ths.removeClass(\"k-first\");\n              ths.eq(0).addClass(\"k-first\");\n            });\n          },\n          _updateRowSpans: function (rows) {\n            for (var i = rows.length - 1; i >= 0; i--) {\n              var included = visibleChildColumns(rows[i].cells).length > 0;\n\n              if (included) {\n                rows[i].rowSpan = rows.length - i;\n              }\n            }\n          },\n          _setColumnDataIndexes: function (columns) {\n            for (var i = 0; i < columns.length; i++) {\n              columns[i][\"data-index\"] = i;\n            }\n          },\n          _updateColumnCellIndex: function () {\n            var header;\n            var offset = 0;\n\n            if (this.lockedHeader) {\n              header = this.lockedHeader.find(\"thead\");\n              offset = updateCellIndex(header, lockedColumns(this.columns));\n            }\n\n            updateCellIndex(this.thead, nonLockedColumns(this.columns), offset);\n          },\n          _setParentsVisibility: function (column, visible) {\n            var columns = this.columns;\n            var idx;\n            var parents = [];\n            var parent;\n            var predicate = visible ? function (p) {\n              return visibleColumns(p.columns).length && p.hidden;\n            } : function (p) {\n              return !visibleColumns(p.columns).length && !p.hidden;\n            };\n\n            if (columnParents(column, columns, parents) && parents.length) {\n              for (idx = parents.length - 1; idx >= 0; idx--) {\n                parent = parents[idx];\n\n                if (predicate(parent)) {\n                  parent.hidden = !visible;\n                }\n              }\n            }\n          },\n          _prepareColumns: function (rows, columns, parentCell, parentRow, parentColumn) {\n            var row = parentRow || rows[rows.length - 1];\n            var childRow = rows[row.index + 1];\n            var totalColSpan = 0;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              var cell = $.extend({}, columns[idx], {\n                headerAttributes: columns[idx].headerAttributes || {}\n              });\n              row.cells.push(cell);\n\n              if (columns[idx].columns && columns[idx].columns.length) {\n                if (!childRow) {\n                  childRow = {\n                    rowSpan: 0,\n                    cells: [],\n                    index: rows.length\n                  };\n                  rows.push(childRow);\n                }\n\n                if (columns[idx].columns.length) {\n                  cell.headerAttributes.colSpan = visibleChildColumns(columns[idx].columns).length || 1;\n                  cell.headerAttributes[\"data-colspan\"] = leafColumns(columns[idx].columns).length;\n                }\n\n                this._prepareColumns(rows, columns[idx].columns, cell, childRow, columns[idx]);\n\n                if (!cell.hidden) {\n                  totalColSpan += cell.headerAttributes.colSpan - 1;\n                }\n\n                row.rowSpan = rows.length - row.index;\n              }\n\n              columns[idx].rowIndex = row.index;\n\n              if (parentColumn) {\n                columns[idx].parentColumn = parentColumn;\n              }\n\n              columns[idx].cellIndex = row.cells.length - 1;\n            }\n\n            if (parentCell) {\n              parentCell.headerAttributes.colSpan += totalColSpan;\n            }\n          },\n          _renderHeaderTree: function (tree, columns, hasMultiColumnHeaders) {\n            var idx;\n            var rows = [];\n            var rowsToRender = [];\n            var filterThs = [];\n\n            if (hasMultiColumnHeaders) {\n              rows = [{\n                rowSpan: 1,\n                cells: [],\n                index: 0\n              }];\n\n              this._prepareColumns(rows, columns);\n\n              this._updateRowSpans(rows);\n\n              for (idx = 0; idx < rows.length; idx++) {\n                rowsToRender.push(kendoDomElement(\"tr\", {\n                  \"role\": \"row\"\n                }, this._ths(rows[idx].cells, rows[idx].rowSpan)));\n              }\n            } else {\n              rowsToRender.push(kendoDomElement(\"tr\", {\n                \"role\": \"row\"\n              }, this._ths(columns)));\n            }\n\n            if (this._hasFilterRow()) {\n              this._filterThs(columns, filterThs);\n\n              rowsToRender.push(kendoDomElement(\"tr\", {\n                \"class\": \"k-filter-row\"\n              }, filterThs));\n            }\n\n            tree.render(rowsToRender);\n          },\n          _renderHeader: function () {\n            var columns = nonLockedColumns(this.columns);\n            var hasMultiColumnHeaders = grep(this.columns, function (item) {\n              return item.columns !== undefined;\n            }).length > 0;\n\n            this._setColumnDataIndexes(leafColumns(this.columns));\n\n            this._renderHeaderTree(this._headerTree, columns, hasMultiColumnHeaders);\n\n            if (this._hasLockedColumns) {\n              columns = lockedColumns(this.columns);\n\n              this._renderHeaderTree(this._lockedHeaderTree, columns, hasMultiColumnHeaders);\n\n              this._applyLockedContainersWidth();\n\n              this._syncLockedHeaderHeight();\n            }\n\n            this._updateFirstColumnClass();\n          },\n          _filterThs: function (columns, ths) {\n            var column;\n            var attr;\n            var uidAttr = kendo.attr('uid');\n\n            for (var i = 0, length = columns.length; i < length; i++) {\n              column = columns[i];\n\n              if (column.columns) {\n                this._filterThs(column.columns, ths);\n              }\n\n              if (column.columns && column.columns.length) {\n                continue;\n              }\n\n              attr = {\n                \"style\": column.hidden === true ? {\n                  \"display\": \"none\"\n                } : {}\n              };\n              attr[uidAttr] = column.headerAttributes.id;\n              ths.push(kendoDomElement(\"th\", attr));\n            }\n          },\n          _updateFilterThs: function (before, column, refColumn) {\n            var columns = leafColumns([column]);\n            var filterRowThs = $(this.lockedHeader).add(this.thead).find(\"tr.k-filter-row th\");\n            var refIndex;\n            var currIndex;\n            var uidAttr = kendo.attr('uid');\n\n            function thIndex(ths, uid) {\n              for (var i = 0; i < ths.length; i++) {\n                if (ths.eq(i).attr(uidAttr) === uid) {\n                  return i;\n                }\n              }\n            }\n\n            for (var i = columns.length - 1; i >= 0; i--) {\n              column = columns[i];\n              currIndex = thIndex(filterRowThs, column.headerAttributes.id);\n              refIndex = thIndex(filterRowThs, refColumn.headerAttributes.id);\n              filterRowThs.eq(currIndex)[before ? \"insertBefore\" : \"insertAfter\"](filterRowThs.eq(refIndex));\n            }\n          },\n          _applyLockedContainersWidth: function () {\n            if (!this._hasLockedColumns) {\n              return;\n            }\n\n            var lockedWidth = columnsWidth(this.lockedHeader.find(\">table>colgroup>col\"));\n            var headerTable = this.thead.parent();\n            var nonLockedWidth = columnsWidth(headerTable.find(\">colgroup>col\"));\n            var wrapperWidth = this.wrapper[0].clientWidth;\n            var scrollbar = kendo.support.scrollbar();\n\n            if (lockedWidth >= wrapperWidth) {\n              lockedWidth = wrapperWidth - 3 * scrollbar;\n            }\n\n            this.lockedHeader.add(this.lockedContent).width(lockedWidth);\n            headerTable.add(this.table).width(nonLockedWidth);\n            var width = wrapperWidth - lockedWidth;\n            this.content.width(width - 1);\n            headerTable.parent().width(width - scrollbar - 2);\n          },\n          _trs: function (options) {\n            var that = this;\n            var model, attr, className, hasChildren, childNodes, i, length;\n            var modelId;\n            var rows = [];\n            var level = options.level;\n            var data = options.data;\n            var dataSource = this.dataSource;\n            var aggregates = dataSource.aggregates() || {};\n\n            var idField = dataSource._modelIdField();\n\n            var parentIdField = dataSource._modelParentIdField();\n\n            var columns = options.columns;\n\n            var pageable = that._isPageable();\n\n            var childrenMap = options.childrenMap || dataSource.childrenMap(dataSource._getData());\n\n            for (i = 0, length = data.length; i < length; i++) {\n              className = [];\n              model = data[i];\n              modelId = model[idField];\n              childNodes = pageable ? childrenMap[modelId] : model.loaded() ? dataSource.childNodes(model) : [];\n              hasChildren = childNodes && childNodes.length;\n              attr = {\n                \"role\": \"row\"\n              };\n              attr[kendo.attr(\"uid\")] = model.uid;\n\n              if (hasChildren) {\n                attr[\"aria-expanded\"] = !!model.expanded;\n              }\n\n              if (options.visible) {\n                if (!pageable || pageable && !that._skipRenderingMap[modelId]) {\n                  if (this._absoluteIndex % 2 !== 0) {\n                    className.push(classNames.alt);\n                  }\n\n                  this._absoluteIndex++;\n                }\n              } else {\n                attr.style = {\n                  display: \"none\"\n                };\n              }\n\n              if ($.inArray(model.uid, options.selected) >= 0) {\n                className.push(classNames.selected);\n              }\n\n              if (hasChildren) {\n                className.push(classNames.group);\n              }\n\n              if (model._edit) {\n                className.push(\"k-grid-edit-row\");\n              }\n\n              attr.className = className.join(\" \");\n\n              if (!that._skipRenderingMap[modelId]) {\n                var row;\n                var rowOptions = {\n                  model: model,\n                  attr: attr,\n                  level: pageable ? that._renderedModelLevel(model, options) : level,\n                  editedColumn: options.editedColumn,\n                  editedColumnIndex: options.editedColumnIndex,\n                  hasChildren: hasChildren,\n                  visible: options.visible,\n                  isAlt: this._absoluteIndex % 2 === 0\n                };\n\n                if (that.options.rowTemplate) {\n                  row = this._trFromTemplate(rowOptions);\n                } else {\n                  row = this._tds(rowOptions, columns, this._td.bind(this));\n                }\n\n                rows.push(row);\n              }\n\n              if (hasChildren && (that.options.renderAllRows || !!model.expanded)) {\n                if (pageable) {\n                  // render the child nodes in the paged view only\n                  childNodes = (options.viewChildrenMap || {})[modelId] || [];\n                }\n\n                if (childNodes.length === 0) {\n                  continue;\n                }\n\n                rows = rows.concat(this._trs({\n                  columns: columns,\n                  editedColumn: options.editedColumn,\n                  editedColumnIndex: options.editedColumnIndex,\n                  aggregates: aggregates,\n                  selected: options.selected,\n                  visible: pageable ? options.visible : options.visible && !!model.expanded,\n                  data: childNodes,\n                  childrenMap: options.childrenMap || childrenMap,\n                  hasFooterTemplate: options.hasFooterTemplate,\n                  viewChildrenMap: options.viewChildrenMap,\n                  level: level + 1\n                }));\n              }\n            }\n\n            if (options.hasFooterTemplate && model) {\n              attr = {\n                className: classNames.footerTemplate,\n                \"data-parentId\": model[parentIdField]\n              };\n\n              if (!options.visible) {\n                attr.style = {\n                  display: \"none\"\n                };\n              }\n\n              rows.push(this._tds({\n                model: aggregates[model[parentIdField]],\n                attr: attr,\n                level: level,\n                editedColumn: options.editedColumn,\n                editedColumnIndex: options.editedColumnIndex\n              }, columns, this._footerId));\n            }\n\n            return rows;\n          },\n          _trFromTemplate: function (options) {\n            var rowTemplate = this.options.rowTemplate;\n            var altRowTemplate = this.options.altRowTemplate;\n            var row;\n            var template;\n            altRowTemplate = altRowTemplate ? altRowTemplate : rowTemplate;\n\n            if (!kendo.isFunction(rowTemplate)) {\n              rowTemplate = kendo.template(rowTemplate);\n            }\n\n            if (!kendo.isFunction(altRowTemplate)) {\n              altRowTemplate = kendo.template(altRowTemplate);\n            }\n\n            if (this._absoluteIndex % 2 !== 0) {\n              template = rowTemplate(options);\n            } else {\n              template = altRowTemplate(options);\n            }\n\n            if (!$(template).length) {\n              return kendoTextElement(template);\n            }\n\n            row = this.parseRowTemplate($(template)[0], options);\n            return row;\n          },\n          parseRowTemplate: function (element, options) {\n            var nodeName = element.nodeName.toLocaleLowerCase();\n            var childNodes = element.childNodes;\n            var children = [];\n            var currElement;\n            var attributes;\n            attributes = this.parseAttributes(element);\n\n            for (var i = 0; i < childNodes.length; i++) {\n              if (!/\\S/.test(childNodes[i].nodeValue)) {\n                continue;\n              }\n\n              if (childNodes[i].nodeName.toLocaleLowerCase() === \"td\") {\n                children.push(this._createCellElement(childNodes[i]));\n              }\n            }\n\n            if (options && !options.visible) {\n              attributes.style = attributes.style || {};\n              attributes.style = $.extend(true, attributes.style, {\n                display: \"none\"\n              });\n            }\n\n            if (this._isTextNode(nodeName)) {\n              currElement = kendoTextElement(element.nodeValue);\n            } else {\n              currElement = kendoDomElement(nodeName, attributes, children);\n            }\n\n            return currElement;\n          },\n          _createCellElement: function (element) {\n            var attributes = this.parseAttributes(element);\n            var spaceElements = $(element).find('.' + classNames.iconHidden).remove();\n            var iconElement = $(element).find('.' + classNames.iconExpand + ',.' + classNames.iconCollapse).remove()[0];\n            var children = [];\n\n            for (var i = 0; i < spaceElements.length; i++) {\n              children.push(kendoDomElement(\"span\", this.parseAttributes(spaceElements[i])));\n            }\n\n            if (iconElement) {\n              children.push(kendoDomElement(\"span\", this.parseAttributes(iconElement)));\n            }\n\n            children.push(kendoHtmlElement($(element).html()));\n            return kendoDomElement(\"td\", attributes, children);\n          },\n          parseAttributes: function (element) {\n            if (this._isTextNode(element.nodeName)) {\n              return null;\n            }\n\n            element = $(element)[0];\n            var attributes = element.attributes;\n            var length = attributes.length;\n            var result = {};\n\n            for (var i = 0; i < length; i++) {\n              result[attributes[i].name] = attributes[i].value;\n            }\n\n            return result;\n          },\n          _isTextNode: function (nodeName) {\n            return nodeName.indexOf('text') >= 0;\n          },\n          _footerId: function (options) {\n            var content = [];\n            var column = options.column;\n            var template = options.column.footerTemplate || $.noop;\n            var aggregates = options.model[column.field] || {};\n            var attr = {\n              \"role\": \"gridcell\",\n              \"style\": column.hidden === true ? {\n                \"display\": \"none\"\n              } : {}\n            };\n\n            if (column.expandable) {\n              content = content.concat(createPlaceholders({\n                level: options.level + 1,\n                className: classNames.iconPlaceHolder\n              }));\n            }\n\n            if (column.attributes) {\n              extend(true, attr, column.attributes, {\n                \"style\": column.hidden === true ? {\n                  \"display\": \"none\"\n                } : {}\n              });\n            }\n\n            content.push(kendoHtmlElement(template(aggregates) || \"\"));\n            return kendoDomElement(\"td\", attr, content);\n          },\n          _hasFooterTemplate: function () {\n            return !!grep(leafColumns(this.columns), function (c) {\n              return c.footerTemplate;\n            }).length;\n          },\n          _tds: function (options, columns, renderer) {\n            var children = [];\n            var column;\n            var editedColumnField = (options.editedColumn || {}).field;\n\n            var incellEditing = this._isIncellEditable();\n\n            var length = columns.length;\n\n            for (var i = 0; i < length; i++) {\n              column = columns[i];\n              var col = renderer({\n                model: options.model,\n                column: column,\n                editColumn: !incellEditing || incellEditing && column.field === editedColumnField && options.editedColumnIndex === i,\n                level: options.level\n              });\n              children.push(col);\n            }\n\n            return kendoDomElement(\"tr\", options.attr, children);\n          },\n          _td: function (options) {\n            var children = [];\n            var model = options.model;\n            var column = options.column;\n            var iconClass;\n            var attr = {\n              \"role\": \"gridcell\",\n              \"style\": column.hidden === true ? {\n                \"display\": \"none\"\n              } : {}\n            };\n\n            var incellEditing = this._isIncellEditable();\n\n            var columnHasEditCommand = false;\n\n            if (column.attributes) {\n              extend(true, attr, column.attributes);\n            }\n\n            if (!!column.headerAttributes && !!column.headerAttributes.id) {\n              attr[\"aria-describedby\"] = column.headerAttributes.id;\n            }\n\n            if (model._edit && column.field && options.editColumn && (incellEditing || !incellEditing && isColumnEditable(column, model))) {\n              attr[kendo.attr(\"container-for\")] = column.field;\n\n              if (incellEditing) {\n                if (attr.className && attr.className.indexOf(classNames.editCell) !== -1) {\n                  attr.className += \" \" + classNames.editCell;\n                } else if (!attr.className) {\n                  attr.className = classNames.editCell;\n                }\n              }\n            } else {\n              if (column.expandable) {\n                children = createPlaceholders({\n                  level: options.level,\n                  className: classNames.iconPlaceHolder\n                });\n                iconClass = [classNames.icon];\n\n                if (model.hasChildren) {\n                  iconClass.push(model.expanded ? classNames.iconCollapse : classNames.iconExpand);\n                } else {\n                  iconClass.push(classNames.iconHidden);\n                }\n\n                if (model._error) {\n                  iconClass.push(classNames.refresh);\n                } else if (!model.loaded() && model.expanded) {\n                  iconClass.push(classNames.loading);\n                  attr[\"aria-busy\"] = true;\n                }\n\n                children.push(kendoDomElement(\"span\", {\n                  className: iconClass.join(\" \")\n                }));\n                attr.style[\"white-space\"] = \"nowrap\";\n              }\n\n              if (isDirtyColumn(column, model)) {\n                if (attr.className) {\n                  attr.className += classNames.dirtyCell;\n                } else if (!attr.className) {\n                  attr.className = classNames.dirtyCell;\n                }\n              }\n\n              if (column.command) {\n                if (attr.className && attr.className.indexOf(\"k-command-cell\") !== -1) {\n                  attr.className += \" k-command-cell\";\n                } else if (!attr.className) {\n                  attr.className = \"k-command-cell\";\n                }\n\n                columnHasEditCommand = grep(column.command, function (command) {\n                  return command === EDIT || command.name === EDIT;\n                }).length > 0;\n\n                if (model._edit && !this._isIncellEditable() && columnHasEditCommand) {\n                  children = this._buildCommands([\"update\", \"canceledit\"]);\n                } else {\n                  children = this._buildCommands(column.command);\n                }\n              } else {\n                children.push(this._cellContent(column, model));\n              }\n\n              attr.className = [attr[\"class\"], attr.className].join(\" \").trim();\n            }\n\n            return kendoDomElement(\"td\", attr, children);\n          },\n          _cellContent: function (column, model) {\n            var that = this;\n            var value;\n\n            var incellEditing = that._isIncellEditable();\n\n            var dirtyIndicator;\n\n            if (column.selectable) {\n              return kendoHtmlElement(SELECTCOLUMNTMPL);\n            }\n\n            if (column.template) {\n              value = that._evalColumnTemplate(column, model);\n            } else if (column.field) {\n              value = model.get(column.field);\n              dirtyIndicator = incellEditing ? column.dirtyIndicatorTemplate(model) : \"\";\n\n              if (value !== null && !isUndefined(value)) {\n                if (column.format) {\n                  value = kendo.format(column.format, value);\n                }\n\n                value = dirtyIndicator + value;\n              } else {\n                value = dirtyIndicator;\n              }\n            } else if (value === null || isUndefined(value)) {\n              value = \"\";\n            }\n\n            if (column.template || !column.encoded) {\n              return kendoHtmlElement(value);\n            } else {\n              if (incellEditing) {\n                return kendoHtmlElement(value);\n              } else {\n                return kendoTextElement(value);\n              }\n            }\n          },\n          _evalColumnTemplate: function (column, model) {\n            if (this._isIncellEditable()) {\n              return column.dirtyCellTemplate(model);\n            } else {\n              return column.template(model);\n            }\n          },\n          _createDirtyColumnTemplate: function (column) {\n            var that = this;\n\n            var templateSettings = that._customTemplateSettings();\n\n            var columnTemplateAlias = \"#=this.columnTemplate(\" + templateSettings.paramName + \")#\";\n            var templateString = that._dirtyIndicatorTemplate(column.field) + columnTemplateAlias;\n            var templateFunction = kendoTemplate(templateString, templateSettings).bind({\n              columnTemplate: column.template\n            });\n            return templateFunction;\n          },\n          _createIndicatorTemplate: function (column) {\n            var dirtyIndicatorTemplate = this._dirtyIndicatorTemplate(column.field);\n\n            return kendoTemplate(dirtyIndicatorTemplate);\n          },\n          _dirtyIndicatorTemplate: function (field) {\n            var that = this;\n            var dirtyField;\n\n            var templateSettings = that._customTemplateSettings();\n\n            var paramName = templateSettings.paramName;\n\n            if (field && paramName) {\n              dirtyField = field.charAt(0) === \"[\" ? kendo.expr(field, paramName + \".dirtyFields\") : paramName + \".dirtyFields['\" + field + \"']\";\n              return \"#= \" + paramName + \" && \" + paramName + \".dirty && \" + paramName + \".dirtyFields && \" + dirtyField + \" ? '<span class=\\\"k-dirty\\\"></span>' : '' #\";\n            }\n\n            return \"\";\n          },\n          _customTemplateSettings: function () {\n            return extend({}, kendo.Template, this.options.templateSettings);\n          },\n          _buildCommands: function (commands) {\n            var i,\n                result = [];\n\n            for (i = 0; i < commands.length; i++) {\n              result.push(this._handleCommand(commands[i]));\n            }\n\n            return result;\n          },\n          _handleCommand: function (command) {\n            var name = (command.name || command).toLowerCase();\n            var text = this.options.messages.commands[name];\n            var icon = [];\n            command = extend({}, defaultCommands[name], {\n              text: text\n            }, command);\n\n            if (command.imageClass) {\n              icon.push(kendoDomElement(\"span\", {\n                className: [\"k-icon\", \"k-button-icon\", command.imageClass].join(\" \")\n              }));\n            }\n\n            if (command.template) {\n              return kendoHtmlElement(kendo.template(command.template)({\n                message: command.text || this.options.messages.commands.search\n              }));\n            } else {\n              return this._button(command, name, icon);\n            }\n          },\n          _button: function (command, name, icon) {\n            if (command.className && command.className.indexOf(\"k-primary\") > -1) {\n              command.className = command.className.replace(\"k-primary\", \"k-button-solid-primary\");\n            }\n\n            if (!command.className || command.className.indexOf(\"k-button-solid-primary\") === -1) {\n              command.className += \" k-button-solid-base\";\n            }\n\n            var button = kendoDomElement(\"button\", {\n              \"type\": \"button\",\n              \"data-command\": name,\n              className: [\"k-button k-button-md k-rounded-md k-button-solid\", command.className].join(\" \")\n            }, icon.concat([kendoDomElement(\"span\", {\n              type: \"span\",\n              className: \"k-button-text\"\n            }, [kendoTextElement(command.text || command.name)])]));\n            return button;\n          },\n          _positionResizeHandle: function (e) {\n            var th = $(e.currentTarget);\n            var resizeHandle = this.resizeHandle;\n            var position = th.position();\n            var left;\n            var rtlCorrection = 0;\n            var headerWrap;\n            var ieCorrection;\n            var webkitCorrection;\n            var firefoxCorrection;\n            var leftMargin;\n            var invisibleSpace;\n            var leftBorderWidth;\n            var scrollLeft;\n            var cellWidth = outerWidth(th);\n            var container = th.closest(\"div\");\n            var button = typeof e.buttons !== \"undefined\" ? e.buttons : e.which || e.button;\n            var indicatorWidth = this.options.columnResizeHandleWidth || 3;\n            var halfResizeHandle = indicatorWidth * 3 / 2;\n            left = cellWidth;\n\n            if (typeof button !== \"undefined\" && button !== 0) {\n              //do not create a new resize handle if a mouse button is still pressed\n              //this happens during resizing or before UserEvents trigger \"start\"\n              return;\n            }\n\n            if (!resizeHandle) {\n              resizeHandle = this.resizeHandle = $('<div class=\"k-resize-handle\"><div class=\"k-resize-handle-inner\"></div></div>');\n            }\n\n            var cells = leafDataCells(th.closest(\"thead\")).filter(\":visible\");\n\n            if (isRtl) {\n              scrollLeft = kendo.scrollLeft(container);\n\n              if (browser.mozilla || browser.webkit && browser.version >= 85) {\n                scrollLeft = scrollLeft * -1;\n              }\n\n              leftBorderWidth = parseFloat(container.css(\"borderLeftWidth\"));\n              left = th.offset().left + scrollLeft - parseFloat(th.css(\"marginLeft\")) - (container.offset().left + leftBorderWidth);\n              rtlCorrection = left <= scrollLeft ? halfResizeHandle : 0; // when shown on first column headers are misaligned due to the width of the resize handler\n\n              headerWrap = th.closest(\".k-grid-header-wrap, .k-grid-header-locked\");\n              invisibleSpace = headerWrap[0].scrollWidth - headerWrap[0].offsetWidth; // the difference between the entire width and the visible area\n\n              leftMargin = parseFloat(headerWrap.css(\"marginLeft\"));\n              ieCorrection = browser.msie ? 2 * kendo.scrollLeft(headerWrap) + leftBorderWidth - leftMargin - rtlCorrection : 0;\n              webkitCorrection = browser.webkit && browser.version < 85 ? invisibleSpace - rtlCorrection - leftMargin + leftBorderWidth : -rtlCorrection; //margin left is added due to a margin that avoids double borders\n\n              firefoxCorrection = browser.mozilla ? leftBorderWidth - leftMargin - rtlCorrection : 0;\n              left -= webkitCorrection + firefoxCorrection + ieCorrection;\n            } else {\n              for (var idx = 0; idx < cells.length; idx++) {\n                if (cells[idx] == th[0]) {\n                  break;\n                }\n\n                left += cells[idx].offsetWidth;\n              }\n            }\n\n            container.append(resizeHandle);\n            resizeHandle.show().css({\n              top: position.top,\n              left: left - halfResizeHandle,\n              height: outerHeight(th),\n              width: indicatorWidth * 3\n            }).data(\"th\", th);\n            var that = this;\n            resizeHandle.off(\"dblclick\" + NS).on(\"dblclick\" + NS, function () {\n              //TODO handle frozen columns index\n              var index = th.index();\n\n              if ($.contains(that.thead[0], th[0])) {\n                index += grep(that.columns, function (val) {\n                  return val.locked && !val.hidden;\n                }).length;\n              }\n\n              that.autoFitColumn(index);\n            });\n          },\n          autoFitColumn: function (column) {\n            var that = this,\n                options = that.options,\n                columns = that.columns,\n                index,\n                th,\n                headerTable,\n                isLocked,\n                visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(\">table>thead\")).filter(isCellVisible).length : 0,\n                col; //  retrieve the column object, depending on the method argument\n\n            if (typeof column == \"number\") {\n              column = columns[column];\n            } else if (isPlainObject(column)) {\n              column = grep(columns, function (item) {\n                return item === column;\n              })[0];\n            } else {\n              column = grep(columns, function (item) {\n                return item.field === column;\n              })[0];\n            }\n\n            if (!column || column.hidden) {\n              return;\n            }\n\n            index = inArray(column, columns);\n            isLocked = column.locked;\n\n            if (isLocked) {\n              headerTable = that.lockedHeader.children(\"table\");\n            } else {\n              headerTable = that.thead.parent();\n            }\n\n            th = headerTable.find(\"[data-index='\" + index + \"']\");\n            var contentTable = isLocked ? that.lockedTable : that.table,\n                footer = that.footer || $();\n\n            if (that.footer && that.lockedContent) {\n              footer = isLocked ? that.footer.children(\".k-grid-footer-locked\") : that.footer.children(\".k-grid-footer-wrap\");\n            }\n\n            var footerTable = footer.find(\"table\").first();\n\n            if (that.lockedHeader && visibleLocked >= index && !isLocked) {\n              index -= visibleLocked;\n            } // adjust column index, depending on previous hidden columns\n\n\n            for (var j = 0; j < columns.length; j++) {\n              if (columns[j] === column) {\n                break;\n              } else {\n                if (columns[j].hidden) {\n                  index--;\n                }\n              }\n            } // get col elements\n\n\n            if (options.scrollable) {\n              col = headerTable.find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index).add(contentTable.children(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index)).add(footerTable.find(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index));\n            } else {\n              col = contentTable.children(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index);\n            }\n\n            var tables = headerTable.add(contentTable).add(footerTable);\n            var oldColumnWidth = outerWidth(th); // reset the table and autofitted column widths\n            // if scrolling is disabled, we need some additional repainting of the table\n\n            col.width(\"\");\n            tables.css(\"table-layout\", \"fixed\");\n            col.width(\"auto\");\n            tables.addClass(\"k-autofitting\");\n            tables.css(\"table-layout\", \"\");\n            var newColumnWidth = Math.ceil(Math.max(outerWidth(th), outerWidth(contentTable.find(\"tr\").eq(0).children(\"td:visible\").eq(index)), outerWidth(footerTable.find(\"tr\").eq(0).children(\"td:visible\").eq(index))));\n            col.width(newColumnWidth);\n            column.width = newColumnWidth; // if all visible columns have widths, the table needs a pixel width as well\n\n            if (options.scrollable) {\n              var cols = headerTable.find(\"col\"),\n                  colWidth,\n                  totalWidth = 0;\n\n              for (var idx = 0, length = cols.length; idx < length; idx += 1) {\n                colWidth = cols[idx].style.width;\n\n                if (colWidth && colWidth.indexOf(\"%\") == -1) {\n                  totalWidth += parseInt(colWidth, 10);\n                } else {\n                  totalWidth = 0;\n                  break;\n                }\n              }\n\n              if (totalWidth) {\n                tables.each(function () {\n                  this.style.width = totalWidth + \"px\";\n                });\n              }\n            }\n\n            tables.removeClass(\"k-autofitting\");\n            that.trigger(COLUMNRESIZE, {\n              column: column,\n              oldWidth: oldColumnWidth,\n              newWidth: newColumnWidth\n            });\n\n            that._applyLockedContainersWidth();\n\n            that._syncLockedContentHeight();\n\n            that._syncLockedHeaderHeight();\n          },\n          _adjustLockedHorizontalScrollBar: function () {\n            var table = this.table,\n                content = table.parent();\n            var scrollbar = table[0].offsetWidth > content[0].clientWidth ? kendo.support.scrollbar() : 0;\n            this.lockedContent.height(outerHeight(content) - scrollbar);\n          },\n          _syncLockedContentHeight: function () {\n            if (this.lockedTable) {\n              if (!this._touchScroller) {\n                this._adjustLockedHorizontalScrollBar();\n              }\n\n              this._adjustRowsHeight(this.table, this.lockedTable);\n\n              this._syncLockedScroll();\n            }\n          },\n          _syncLockedHeaderHeight: function () {\n            if (this.lockedHeader) {\n              var lockedTable = this.lockedHeader.children(\"table\");\n              var table = this.thead.parent();\n\n              this._adjustRowsHeight(lockedTable, table);\n\n              syncTableHeight(lockedTable, table);\n            }\n          },\n          _syncLockedScroll: function () {\n            if (!this.options.scrollable) {\n              return;\n            }\n\n            this.lockedContent[0].scrollTop = this.content[0].scrollTop;\n          },\n          _resizable: function () {\n            if (!this.options.resizable) {\n              return;\n            }\n\n            if (this.resizable) {\n              this.resizable.destroy();\n            }\n\n            var treelist = this;\n            $(this.lockedHeader).find(\"thead\").add(this.thead).on(\"mousemove\" + NS, \"tr:not(.k-filter-row) > th\", this._positionResizeHandle.bind(this));\n            this.resizable = new kendo.ui.Resizable(this.wrapper, {\n              handle: \".k-resize-handle\",\n              start: function (e) {\n                var th = $(e.currentTarget).data(\"th\");\n                var index = $.inArray(th[0], leafDataCells(th.closest(\"thead\")).filter(\":visible\"));\n                var header, contentTable;\n                treelist.wrapper.addClass(\"k-grid-column-resizing\");\n\n                if (treelist.lockedHeader && $.contains(treelist.lockedHeader[0], th[0])) {\n                  header = treelist.lockedHeader;\n                  contentTable = treelist.lockedTable;\n                } else {\n                  header = treelist.thead.parent();\n                  contentTable = treelist.table;\n                }\n\n                this.col = contentTable.children(\"colgroup\").find(\"col\").eq(index).add(header.find(\"col\").eq(index));\n                this.th = th;\n                this.startLocation = e.x.location;\n                this.columnWidth = outerWidth(th);\n                this.table = this.col.closest(\"table\");\n                this.totalWidth = this.table.width();\n              },\n              resize: function (e) {\n                var rtlModifier = isRtl ? -1 : 1;\n                var minColumnWidth = 11;\n                var delta = e.x.location * rtlModifier - this.startLocation * rtlModifier;\n\n                if (this.columnWidth + delta < minColumnWidth) {\n                  delta = minColumnWidth - this.columnWidth;\n                }\n\n                this.table.width(this.totalWidth + delta);\n                this.col.width(this.columnWidth + delta);\n              },\n              resizeend: function () {\n                treelist.wrapper.removeClass(\"k-grid-column-resizing\");\n                var field = this.th.attr(\"data-field\");\n                var column = grep(leafColumns(treelist.columns), function (c) {\n                  return c.field == field;\n                });\n                var newWidth = Math.floor(outerWidth(this.th));\n                column[0].width = newWidth;\n\n                treelist._resize();\n\n                treelist._syncLockedContentHeight();\n\n                treelist._syncLockedHeaderHeight();\n\n                treelist.trigger(COLUMNRESIZE, {\n                  column: column,\n                  oldWidth: this.columnWidth,\n                  newWidth: newWidth\n                });\n                this.table = this.col = this.th = null;\n              }\n            });\n          },\n          _sortable: function () {\n            var columns;\n            var column;\n            var sortableInstance;\n            var cells;\n            var cell, idx, length;\n            var sortable = this.options.sortable;\n            var hasMultiColumnHeaders = grep(this.columns, function (item) {\n              return item.columns !== undefined;\n            }).length > 0;\n\n            if (!sortable) {\n              return;\n            }\n\n            if (hasMultiColumnHeaders) {\n              if (this.lockedHeader) {\n                cells = sortCells(leafDataCells(this.lockedHeader.find(\">table>thead\")).add(leafDataCells(this.thead)));\n              } else {\n                cells = leafDataCells(this.thead);\n              }\n            } else {\n              cells = $(this.lockedHeader).add(this.thead).find(\"tr:not(.k-filter-row) th\");\n            }\n\n            columns = leafColumns(this.columns);\n\n            for (idx = 0, length = cells.length; idx < length; idx++) {\n              column = columns[idx];\n\n              if (column.sortable !== false && !column.command && column.field && !column.selectable) {\n                cell = cells.eq(idx);\n                sortableInstance = cell.data(\"kendoColumnSorter\");\n\n                if (sortableInstance) {\n                  sortableInstance.destroy();\n                }\n\n                cell.kendoColumnSorter(extend({}, sortable, column.sortable, {\n                  dataSource: this.dataSource\n                }));\n              }\n            }\n          },\n          _filterable: function () {\n            var cells;\n            var filterable = this.options.filterable;\n            var idx;\n            var length;\n            var columns;\n            var column;\n            var cell;\n            var filterMenuInstance;\n            var hasMultiColumnHeaders = grep(this.columns, function (item) {\n              return item.columns !== undefined;\n            }).length > 0;\n\n            if (!filterable || this.options.columnMenu) {\n              return;\n            }\n\n            var filterInit = function (e) {\n              this.trigger(FILTERMENUINIT, {\n                field: e.field,\n                container: e.container\n              });\n            }.bind(this);\n\n            var filterOpen = function (e) {\n              this.trigger(FILTERMENUOPEN, {\n                field: e.field,\n                container: e.container\n              });\n            }.bind(this);\n\n            if (hasMultiColumnHeaders) {\n              if (this.lockedHeader) {\n                cells = leafDataCells(this.lockedHeader.find(\">table>thead\").add(this.thead));\n              } else {\n                cells = leafDataCells(this.thead);\n              }\n            } else {\n              cells = $(this.lockedHeader).add(this.thead).find(\"tr:not(.k-filter-row) th\");\n            }\n\n            columns = leafColumns(this.columns);\n\n            if (filterable && typeof filterable.mode == STRING && filterable.mode.indexOf(\"menu\") == -1) {\n              filterable = false;\n            }\n\n            if (!filterable) {\n              return;\n            }\n\n            for (idx = 0, length = cells.length; idx < length; idx++) {\n              column = columns[idx];\n              cell = cells.eq(idx);\n              filterMenuInstance = cell.data(\"kendoFilterMenu\");\n\n              if (filterMenuInstance) {\n                filterMenuInstance.destroy();\n              }\n\n              if (column.command || column.filterable === false || column.selectable) {\n                continue;\n              }\n\n              cell.kendoFilterMenu(extend(true, {}, filterable, column.filterable, {\n                dataSource: this.dataSource,\n                init: filterInit,\n                open: filterOpen,\n                appendTo: DOT + classNames.headerCellInner\n              }));\n            }\n          },\n          _filterRow: function () {\n            var that = this;\n\n            if (!that._hasFilterRow()) {\n              return;\n            }\n\n            var settings;\n            var $angular = that.options.$angular;\n            var uidAttr = kendo.attr('uid');\n\n            var columns = leafColumns(that.columns),\n                filterable = that.options.filterable,\n                filterHandler = function (e) {\n              if (that.trigger(\"filter\", {\n                filter: e.filter,\n                field: e.field\n              })) {\n                e.preventDefault();\n              }\n            },\n                existingInstance;\n\n            for (var i = 0; i < columns.length; i++) {\n              var suggestDataSource,\n                  col = columns[i],\n                  operators = that.options.filterable.operators,\n                  customDataSource = false,\n                  th = this.wrapper.find('.k-grid-header .k-filter-row th[' + uidAttr + '=\"' + col.headerAttributes.id + '\"]'),\n                  field = col.field,\n                  parentColumn = col.parentColumn;\n              delete col.parentColumn;\n\n              if (field && col.filterable !== false) {\n                var cellOptions = col.filterable && col.filterable.cell || {};\n                existingInstance = th.find('.k-filtercell').data('kendoFilterCell');\n\n                if (existingInstance) {\n                  existingInstance.destroy();\n                  th.empty();\n                }\n\n                suggestDataSource = that.options.dataSource;\n\n                if (suggestDataSource instanceof DataSource) {\n                  suggestDataSource = that.options.dataSource.options;\n                }\n\n                var messages = extend(true, {}, filterable.messages);\n\n                if (col.filterable) {\n                  extend(true, messages, col.filterable.messages);\n                }\n\n                if (cellOptions.enabled === false) {\n                  th.html(\"&nbsp;\");\n                  continue;\n                }\n\n                if (cellOptions.dataSource) {\n                  suggestDataSource = cellOptions.dataSource;\n                  customDataSource = true;\n                }\n\n                if (col.filterable && col.filterable.operators) {\n                  operators = col.filterable.operators;\n                }\n\n                settings = {\n                  column: col,\n                  dataSource: that.dataSource,\n                  suggestDataSource: suggestDataSource,\n                  customDataSource: customDataSource,\n                  field: field,\n                  messages: messages,\n                  values: col.values,\n                  template: cellOptions.template,\n                  delay: cellOptions.delay,\n                  inputWidth: cellOptions.inputWidth,\n                  suggestionOperator: cellOptions.suggestionOperator,\n                  minLength: cellOptions.minLength,\n                  dataTextField: cellOptions.dataTextField,\n                  operator: cellOptions.operator,\n                  operators: operators,\n                  showOperators: cellOptions.showOperators,\n                  change: filterHandler\n                };\n\n                if ($angular) {\n                  settings.$angular = $angular;\n                }\n\n                $(\"<span/>\").attr(kendo.attr(\"field\"), field).appendTo(th).kendoFilterCell(settings);\n                col.parentColumn = parentColumn;\n              } else {\n                th.html(\"&nbsp;\");\n              }\n            }\n          },\n          _hasFilterRow: function () {\n            var filterable = this.options.filterable;\n            var hasFiltering = filterable && typeof filterable.mode == STRING && filterable.mode.indexOf(\"row\") != -1;\n            var columns = this.columns;\n            var columnsWithoutFiltering = $.grep(columns, function (col) {\n              return col.filterable === false;\n            });\n\n            if (columns.length && columnsWithoutFiltering.length == columns.length) {\n              hasFiltering = false;\n            }\n\n            return hasFiltering;\n          },\n          _change: function () {\n            var that = this;\n            var selectedValues;\n\n            if (that._checkBoxSelection) {\n              selectedValues = that.selectable.value();\n\n              that._uncheckCheckBoxes();\n\n              that._checkRows(selectedValues);\n\n              if (selectedValues.length && selectedValues.length === that.items().length) {\n                that._toggleHeaderCheckState(true);\n              } else {\n                that._toggleHeaderCheckState(false);\n              }\n            }\n\n            this.trigger(CHANGE);\n          },\n          _isLocked: function () {\n            return this.lockedHeader !== null;\n          },\n          _selectable: function () {\n            var that = this;\n            var selectable = this.options.selectable;\n            var filter;\n            var element = this.table;\n            var useAllItems;\n\n            var isLocked = that._isLocked();\n\n            var multi;\n            var cell;\n\n            if (selectable) {\n              selectable = kendo.ui.Selectable.parseOptions(selectable);\n\n              if (this._hasLockedColumns) {\n                element = element.add(this.lockedTable);\n                useAllItems = selectable.multiple && selectable.cell;\n              }\n\n              filter = \">tbody>tr:not(.k-footer-template)\";\n\n              if (selectable.cell) {\n                filter = filter + \">td\";\n              }\n\n              this.selectable = new kendo.ui.Selectable(element, {\n                filter: filter,\n                aria: true,\n                multiple: selectable.multiple,\n                change: this._change.bind(this),\n                useAllItems: useAllItems,\n                continuousItems: this._continuousItems.bind(this, filter, selectable.cell),\n                relatedTarget: !selectable.cell && this._hasLockedColumns ? this._selectableTarget.bind(this) : undefined\n              });\n\n              if (that.options.navigatable) {\n                multi = selectable.multiple;\n                cell = selectable.cell;\n                element.on(\"keydown\" + NS, function (e) {\n                  var current = that.current();\n                  var target = e.target;\n\n                  if (e.keyCode === keys.SPACEBAR && !e.shiftKey && $.inArray(target, element) > -1 && !current.is(\".k-header\")) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    current = cell ? current : current.parent();\n\n                    if (isLocked && !cell) {\n                      current = current.add(that._relatedRow(current));\n                    }\n\n                    if (multi) {\n                      if (!e.ctrlKey) {\n                        that.selectable.clear();\n                      } else {\n                        if (current.hasClass(classNames.selected)) {\n                          current.removeClass(classNames.selected);\n                          that.trigger(CHANGE);\n                          return;\n                        }\n                      }\n                    } else {\n                      that.selectable.clear();\n                    }\n\n                    if (!cell) {\n                      that.selectable._lastActive = current;\n                    }\n\n                    that.selectable.value(current);\n                  } else if (!cell && (e.shiftKey && e.keyCode == keys.LEFT || e.shiftKey && e.keyCode == keys.RIGHT || e.shiftKey && e.keyCode == keys.UP || e.shiftKey && e.keyCode == keys.DOWN || e.keyCode === keys.SPACEBAR && e.shiftKey)) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    current = current.parent();\n\n                    if (isLocked) {\n                      current = current.add(that._relatedRow(current));\n                    }\n\n                    if (multi) {\n                      if (!that.selectable._lastActive) {\n                        that.selectable._lastActive = current;\n                      }\n\n                      that.selectable.selectRange(that.selectable._firstSelectee(), current);\n                    } else {\n                      that.selectable.clear();\n                      that.selectable.value(current);\n                    }\n                  }\n                });\n              }\n            }\n          },\n          _continuousItems: function (filter, cell) {\n            if (!this.lockedContent) {\n              return;\n            }\n\n            var lockedItems = $(filter, this.lockedTable);\n            var nonLockedItems = $(filter, this.table);\n            var columns = cell ? lockedColumns(this.columns).length : 1;\n            var nonLockedColumns = cell ? this.columns.length - columns : 1;\n            var result = [];\n\n            for (var idx = 0; idx < lockedItems.length; idx += columns) {\n              push.apply(result, lockedItems.slice(idx, idx + columns));\n              push.apply(result, nonLockedItems.splice(0, nonLockedColumns));\n            }\n\n            return result;\n          },\n          _selectableTarget: function (items) {\n            var related;\n            var result = $();\n\n            for (var idx = 0, length = items.length; idx < length; idx++) {\n              related = this._relatedRow(items[idx]);\n\n              if (inArray(related[0], items) < 0) {\n                result = result.add(related);\n              }\n            }\n\n            return result;\n          },\n          _relatedRow: function (row) {\n            var lockedTable = this.lockedTable;\n            row = $(row);\n\n            if (!lockedTable) {\n              return row;\n            }\n\n            var table = row.closest(this.table.add(this.lockedTable));\n            var index = table.find(\">tbody>tr\").index(row);\n            table = table[0] === this.table[0] ? lockedTable : this.table;\n            return table.find(\">tbody>tr\").eq(index);\n          },\n          select: function (value) {\n            var that = this;\n            var selectable = this.selectable;\n\n            if (that._checkBoxSelection) {\n              if (value) {\n                that._checkRows(value);\n\n                if (that.select().length === that.items().length) {\n                  that._toggleHeaderCheckState(true);\n                }\n              }\n\n              return that.items().filter(\".\" + SELECTED);\n            }\n\n            if (!selectable) {\n              return $();\n            }\n\n            if (typeof value !== \"undefined\") {\n              if (!selectable.options.multiple) {\n                selectable.clear();\n                value = value.first();\n              }\n\n              if (this._hasLockedColumns) {\n                value = value.add($.map(value, this._relatedRow.bind(this)));\n              }\n            }\n\n            return selectable.value(value);\n          },\n          clearSelection: function () {\n            var that = this;\n\n            if (that.selectable && !that._checkBoxSelection) {\n              that.selectable.clear();\n            }\n\n            if (that._checkBoxSelection) {\n              that._deselectCheckRows(that.select(), true);\n\n              return;\n            }\n          },\n          _uncheckCheckBoxes: function () {\n            var that = this;\n            var tables = that.table.add(that.lockedTable);\n            tables.find(\"tbody \" + CHECKBOXINPUT).attr(\"aria-checked\", false).prop(\"checked\", false).attr(\"aria-label\", \"Select row\");\n          },\n          _deselectCheckRows: function (items, preventChange) {\n            var that = this;\n            items = that.table.add(that.lockedTable).find(items);\n\n            if (that._isLocked()) {\n              items = items.add(items.map(function () {\n                return that._relatedRow(this);\n              }));\n            }\n\n            items.each(function () {\n              $(this).removeClass(SELECTED).find(CHECKBOXINPUT).attr(\"aria-checked\", false).prop(\"checked\", false).attr(\"aria-label\", \"Select row\");\n            });\n\n            that._toggleHeaderCheckState(false);\n\n            if (!preventChange) {\n              that.trigger(CHANGE);\n            }\n          },\n          _headerCheckboxClick: function (e) {\n            var that = this,\n                checkBox = $(e.target),\n                checked = checkBox.prop(\"checked\"),\n                parentGrid = checkBox.closest(\".k-grid.k-widget\").getKendoTreeList();\n\n            if (that !== parentGrid) {\n              return;\n            }\n\n            if (checked) {\n              that.select(parentGrid.items());\n            } else {\n              that.clearSelection();\n            }\n\n            that.trigger(CHANGE);\n          },\n          _checkboxClick: function (e) {\n            var that = this,\n                row = $(e.target).closest(\"tr\"),\n                isSelecting = !row.hasClass(SELECTED),\n                dataItem = that.dataItem(row),\n                children = [],\n                selector = \"\";\n\n            if (that !== row.closest(\".k-grid.k-widget\").getKendoTreeList()) {\n              return;\n            }\n\n            if (that._includeChildren) {\n              that.dataSource.allChildNodes(dataItem, children);\n\n              for (var i = 0; i < children.length; i++) {\n                selector += \"tr[data-uid='\" + children[i].uid + \"'],\";\n              }\n            }\n\n            selector += \"tr[data-uid='\" + dataItem.uid + \"']\";\n            row = $(selector);\n\n            if (isSelecting) {\n              that.select(row);\n              that.trigger(CHANGE);\n            } else {\n              that._deselectCheckRows(row);\n            }\n          },\n          _checkRows: function (items) {\n            items.each(function () {\n              $(this).addClass(SELECTED).find(CHECKBOXINPUT).prop(\"checked\", true).attr(\"aria-label\", \"Deselect row\").attr(\"aria-checked\", true);\n            });\n          },\n          _toggleHeaderCheckState: function (checked) {\n            var that = this;\n\n            if (checked) {\n              that.thead.add(that.lockedHeader).find(\"tr \" + CHECKBOXINPUT).prop(\"checked\", true).attr(\"aria-checked\", true).attr(\"aria-label\", \"Deselect all rows\");\n            } else {\n              that.thead.add(that.lockedHeader).find(\"tr \" + CHECKBOXINPUT).prop(\"checked\", false).attr(\"aria-checked\", false).attr(\"aria-label\", \"Select all rows\");\n            }\n          },\n          _dataSource: function (dataSource) {\n            var that = this;\n            var ds = this.dataSource;\n            var pageable = that.options.pageable;\n\n            if (ds) {\n              ds.unbind(CHANGE, this._refreshHandler);\n              ds.unbind(ERROR, this._errorHandler);\n              ds.unbind(SORT, this._sortHandler);\n              ds.unbind(PROGRESS, this._progressHandler);\n            }\n\n            this._refreshHandler = this.refresh.bind(this);\n            this._errorHandler = this._error.bind(this);\n            this._sortHandler = this._clearSortClasses.bind(this);\n            this._progressHandler = this._progress.bind(this);\n\n            if (isPlainObject(dataSource)) {\n              extend(dataSource, {\n                table: that.table,\n                fields: that.columns\n              });\n\n              if (isPlainObject(pageable) && pageable.pageSize !== undefined) {\n                dataSource.pageSize = pageable.pageSize;\n              }\n            }\n\n            ds = this.dataSource = TreeListDataSource.create(dataSource);\n\n            if (pageable) {\n              ds._collapsedTotal = undefined;\n            }\n\n            ds.bind(CHANGE, this._refreshHandler);\n            ds.bind(ERROR, this._errorHandler);\n            ds.bind(SORT, this._sortHandler);\n            ds.bind(PROGRESS, this._progressHandler);\n\n            this._dataSourceFetchProxy = function () {\n              this.dataSource.fetch();\n            }.bind(this);\n          },\n          setDataSource: function (dataSource) {\n            this._dataSource(dataSource);\n\n            this._sortable();\n\n            this._filterable();\n\n            this._filterRow();\n\n            this._columnMenu();\n\n            this._pageable();\n\n            this._contentTree.render([]);\n\n            if (this.options.autoBind) {\n              this.dataSource.fetch();\n            }\n          },\n          dataItem: function (element) {\n            if (element instanceof TreeListModel) {\n              return element;\n            }\n\n            var row = $(element).closest(\"tr\");\n            var uid = row.attr(kendo.attr(\"uid\"));\n            var model = isUndefined(uid) ? null : this.dataSource.getByUid(uid);\n            return model;\n          },\n          editRow: function (row) {\n            var that = this;\n            var model;\n\n            if (this._isIncellEditable() || !this.options.editable) {\n              return;\n            }\n\n            if (typeof row === STRING) {\n              row = this.tbody.find(row);\n            }\n\n            if (that._isPageable() && that._isPopupEditable() && row instanceof TreeListModel) {\n              // popup editor can be created without a rendered row\n              model = row;\n            } else {\n              model = this.dataItem(row);\n            }\n\n            if (!model) {\n              return;\n            }\n\n            if (that.editor) {\n              model._edit = true;\n\n              this._render();\n\n              this._cancelEditor();\n            } else {\n              that._preventPageSizeRestore = false;\n            }\n\n            if (this._editMode() != \"popup\") {\n              model._edit = true;\n            }\n\n            if (this.trigger(BEFORE_EDIT, {\n              model: model\n            })) {\n              that.dataSource._restorePageSizeAfterAddChild();\n\n              return;\n            }\n\n            this._render();\n\n            this._createEditor(model);\n\n            this.trigger(EDIT, {\n              container: this.editor.wrapper,\n              model: model\n            });\n          },\n          _cancelEdit: function (e) {\n            if (!this.editor) {\n              return;\n            }\n\n            var currentIndex;\n            e = extend(e, {\n              container: this.editor.wrapper,\n              model: this.editor.model\n            });\n\n            if (this.trigger(CANCEL, e)) {\n              return;\n            }\n\n            if (this.options.navigatable) {\n              currentIndex = this.items().index($(this.current()).parent());\n            }\n\n            this.cancelRow();\n\n            if (this.options.navigatable) {\n              this.current(this.items().eq(currentIndex).children().filter(NAVCELL).first());\n              focusTable(this.table, true);\n            }\n          },\n          cancelRow: function () {\n            if (this._isIncellEditable()) {\n              return;\n            }\n\n            this._cancelEditor();\n\n            this._render();\n          },\n          saveRow: function () {\n            var editor = this.editor;\n            var args;\n\n            if (this._isIncellEditable()) {\n              return;\n            }\n\n            if (!editor) {\n              return;\n            }\n\n            args = {\n              model: editor.model,\n              container: editor.wrapper\n            };\n\n            if (editor.end() && !this.trigger(SAVE, args)) {\n              this.dataSource.sync();\n            }\n          },\n          addRow: function (parent) {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            var pageable = that._isPageable();\n\n            var incellEditing = that._isIncellEditable();\n\n            var inlineEditing = that._isInlineEditable();\n\n            var editor = this.editor;\n            var index = 0;\n            var model = {};\n\n            if (editor && !editor.end() || !this.options.editable) {\n              return;\n            }\n\n            if (parent) {\n              if (!(parent instanceof TreeListModel)) {\n                parent = this.dataItem(parent);\n              }\n\n              model[parent.parentIdField] = parent.id;\n              index = this.dataSource.indexOf(parent) + 1;\n              this.expand(parent).then(function () {\n                var showNewModelInView = pageable && dataSource._isLastItemInView(parent) && (incellEditing || inlineEditing);\n\n                that._insertAt(model, index, showNewModelInView);\n              });\n              return;\n            }\n\n            this._insertAt(model, index);\n          },\n          _insertAt: function (model, index, showNewModelInView) {\n            var that = this;\n            var dataSource = that.dataSource;\n            model = that.dataSource.insert(index, model);\n\n            if (showNewModelInView) {\n              dataSource._setAddChildPageSize();\n            }\n\n            var row = this._itemFor(model);\n\n            var cell;\n\n            if (that._isIncellEditable()) {\n              cell = row.children(\"td\").eq(that._firstEditableColumnIndex(row));\n              that.editCell(cell);\n            } else if (row && row[0]) {\n              that.editRow(row);\n            } else if ((that._isPageable() || that.dataSource.filter()) && (that._isPopupEditable() || that._isInlineEditable())) {\n              that.editRow(model);\n            }\n          },\n          _firstEditableColumnIndex: function (container) {\n            var that = this;\n            var model = that.dataItem(container);\n            var columns = leafColumns(that.columns);\n            var length = columns.length;\n            var column;\n            var idx;\n\n            for (idx = 0; idx < length; idx++) {\n              column = columns[idx];\n\n              if (model && (!model.editable || model.editable(column.field)) && !column.command && column.field && column.hidden !== true) {\n                return idx;\n              }\n            }\n\n            return -1;\n          },\n          removeRow: function (row) {\n            var model = this.dataItem(row);\n            var args = {\n              model: model,\n              row: row\n            };\n\n            if (this.options.editable && model && !this.trigger(REMOVE, args)) {\n              if (document.activeElement === $(row).find(\".k-grid-delete\")[0]) {\n                $(row).find(\".k-grid-delete\").trigger(\"blur\");\n              }\n\n              this.dataSource.remove(model);\n\n              if (!this._isIncellEditable()) {\n                this.dataSource.sync();\n              }\n            }\n          },\n          _cancelEditor: function () {\n            var that = this;\n            var model;\n            var editor = that.editor;\n\n            if (editor) {\n              model = editor.model;\n\n              that._destroyEditor();\n\n              if (!that._isIncellEditable()) {\n                that.dataSource.cancelChanges(model);\n              } else if (that._shouldRestorePageSize()) {\n                that.dataSource._restorePageSizeAfterAddChild();\n              }\n\n              model._edit = false;\n            }\n\n            that._preventPageSizeRestore = false;\n          },\n          _shouldRestorePageSize: function () {\n            var that = this;\n            return that._isPageable() && that._isIncellEditable() && !that._preventPageSizeRestore;\n          },\n          _destroyEditor: function () {\n            if (!this.editor) {\n              return;\n            }\n\n            this.editor.close();\n            this.editor = null;\n          },\n          _createEditor: function (model) {\n            var row = this.itemFor(model);\n            var columns = leafColumns(this.columns);\n            var leafCols = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              leafCols.push(extend({}, columns[idx]));\n              delete leafCols[idx].parentColumn;\n            }\n\n            row = row.add(this._relatedRow(row));\n\n            var mode = this._editMode();\n\n            var options = {\n              columns: leafCols,\n              model: model,\n              target: this,\n              clearContainer: false,\n              template: this.options.editable.template\n            };\n\n            if (mode == \"inline\") {\n              this.editor = new Editor(row, options);\n            } else {\n              extend(options, {\n                window: this.options.editable.window,\n                commandRenderer: function () {\n                  return this._buildCommands([\"update\", \"canceledit\"]);\n                }.bind(this),\n                fieldRenderer: this._cellContent.bind(this),\n                save: this.saveRow.bind(this),\n                cancel: this._cancelEdit.bind(this),\n                appendTo: this.wrapper\n              });\n              this.editor = new PopupEditor(row, options);\n            }\n          },\n          _createIncellEditor: function (cell, options) {\n            var that = this;\n            var column = extend({}, options.columns[0]);\n            delete column.parentColumn;\n            return new IncellEditor(cell, extend({}, {\n              fieldRenderer: that._cellContent.bind(that),\n              appendTo: that.wrapper,\n              clearContainer: false,\n              target: that,\n              columns: [column],\n              model: options.model,\n              change: options.change\n            }));\n          },\n          editCell: function (cell) {\n            var that = this;\n            cell = $(cell);\n            var column = leafColumns(that.columns)[that.cellIndex(cell)];\n            var model = that.dataItem(cell);\n\n            if (that._isIncellEditable() && model && isColumnEditable(column, model)) {\n              that._editCell(cell, column, model);\n            }\n          },\n          _editCell: function (cell, column, model) {\n            var that = this;\n            var editedCell;\n\n            if (that.trigger(BEFORE_EDIT, {\n              model: model\n            })) {\n              that.dataSource._restorePageSizeAfterAddChild();\n\n              return;\n            }\n\n            that.closeCell();\n            model._edit = true;\n\n            that._cancelEditor();\n\n            that._render({\n              editedColumn: column,\n              editedColumnIndex: cell.index()\n            });\n\n            editedCell = that.table.add(that.lockedTable).find(DOT + classNames.editCell).first();\n            that.editor = that._createIncellEditor(editedCell, {\n              columns: [column],\n              model: model,\n              change: function (e) {\n                if (that.trigger(SAVE, {\n                  values: e.values,\n                  container: cell,\n                  model: model\n                })) {\n                  e.preventDefault();\n                }\n              }\n            }); // refresh the current element as the DOM element reference can be changed after render()\n\n            that._current = editedCell;\n            that.trigger(EDIT, {\n              container: cell,\n              model: model\n            });\n          },\n          closeCell: function (isCancel) {\n            var that = this;\n            var cell = (that.editor || {}).element;\n            var tr;\n            var model;\n\n            if (!cell || !cell[0] || !that._isIncellEditable()) {\n              return;\n            }\n\n            model = that.dataItem(cell);\n\n            if (isCancel && that.trigger(CANCEL, {\n              container: cell,\n              model: model\n            })) {\n              return;\n            }\n\n            that.trigger(CELL_CLOSE, {\n              type: isCancel ? CANCEL : SAVE,\n              model: model,\n              container: cell\n            });\n\n            that._cancelEditor();\n\n            cell.removeClass(classNames.editCell);\n            tr = cell.parent().removeClass(classNames.editRow);\n\n            if (that.lockedContent) {\n              that._relatedRow(tr).removeClass(classNames.editRow);\n            }\n\n            that._render();\n\n            that.trigger(ITEM_CHANGE, {\n              item: tr,\n              data: model,\n              ns: ui\n            });\n\n            if (that.lockedContent) {\n              adjustRowHeight(tr.css(\"height\", \"\")[0], that._relatedRow(tr).css(\"height\", \"\")[0]);\n            }\n          },\n          cancelChanges: function () {\n            this.dataSource.cancelChanges();\n          },\n          saveChanges: function () {\n            var that = this;\n            var editable = (that.editor || {}).editable;\n            var valid = editable && editable.end();\n\n            if ((valid || !editable) && !that.trigger(SAVE_CHANGES)) {\n              that.dataSource.sync();\n            }\n          },\n          _editMode: function () {\n            var mode = \"inline\",\n                editable = this.options.editable;\n\n            if (editable !== true) {\n              if (typeof editable == \"string\") {\n                mode = editable;\n              } else {\n                mode = editable.mode || mode;\n              }\n            }\n\n            return mode.toLowerCase();\n          },\n          _isIncellEditable: function () {\n            return this._editMode() === INCELL;\n          },\n          _isInlineEditable: function () {\n            return this._editMode() === INLINE;\n          },\n          _isPopupEditable: function () {\n            return this._editMode() === POPUP;\n          },\n          hideColumn: function (column) {\n            this._toggleColumnVisibility(column, true);\n          },\n          showColumn: function (column) {\n            this._toggleColumnVisibility(column, false);\n          },\n          _toggleColumnVisibility: function (column, hidden) {\n            column = this._findColumn(column);\n\n            if (!column || column.hidden === hidden) {\n              return;\n            }\n\n            column.hidden = hidden;\n\n            this._setParentsVisibility(column, !hidden);\n\n            this._ensureExpandableColumn();\n\n            this._clearColsCache();\n\n            this._renderCols();\n\n            this._renderHeader();\n\n            this._render();\n\n            this._adjustTablesWidth();\n\n            this.trigger(hidden ? COLUMNHIDE : COLUMNSHOW, {\n              column: column\n            });\n\n            if (!hidden && !column.width) {\n              this.table.add(this.thead.closest(\"table\")).width(\"\");\n            }\n\n            this._updateFirstColumnClass();\n          },\n          _findColumn: function (column) {\n            if (typeof column == \"number\") {\n              column = this.columns[column];\n            } else if (isPlainObject(column)) {\n              column = grep(leafColumns(this.columns), function (item) {\n                return item === column;\n              })[0];\n            } else {\n              column = grep(leafColumns(this.columns), function (item) {\n                return item.field === column;\n              })[0];\n            }\n\n            return column;\n          },\n          _adjustTablesWidth: function () {\n            var idx, length;\n            var cols = this.thead.prev().children();\n            var colWidth,\n                width = 0;\n\n            for (idx = 0, length = cols.length; idx < length; idx++) {\n              colWidth = cols[idx].style.width;\n\n              if (colWidth && colWidth.indexOf(\"%\") == -1) {\n                width += parseInt(colWidth, 10);\n              } else {\n                width = 0;\n                break;\n              }\n            }\n\n            if (width) {\n              this.table.add(this.thead.closest(\"table\")).width(width);\n            }\n          },\n          _reorderable: function () {\n            if (!this.options.reorderable) {\n              return;\n            }\n\n            var scrollable = this.options.scrollable === true;\n            var selector = (scrollable ? \".k-grid-header:first \" : \"table:first>.k-grid-header \") + HEADERCELLS;\n            var that = this;\n            this._draggableInstance = new ui.Draggable(this.wrapper, {\n              group: kendo.guid(),\n              filter: selector,\n              hint: function (target) {\n                return $('<div class=\"k-reorder-clue k-drag-clue\" />').html(target.attr(kendo.attr(\"title\")) || target.attr(kendo.attr(\"field\")) || target.text()).prepend('<span class=\"k-icon k-drag-status k-i-cancel\" />');\n              }\n            });\n            this.reorderable = new ui.Reorderable(this.wrapper, {\n              draggable: this._draggableInstance,\n              dragOverContainers: this._allowDragOverContainers.bind(this),\n              inSameContainer: function (e) {\n                return $(e.source).parent()[0] === $(e.target).parent()[0] && targetParentContainerIndex(flatColumnsInDomOrder(that.columns), that.columns, e.sourceIndex, e.targetIndex) > -1;\n              },\n              change: function (e) {\n                var columns = flatColumnsInDomOrder(that.columns);\n                var column = columns[e.oldIndex];\n                var newIndex = targetParentContainerIndex(columns, that.columns, e.oldIndex, e.newIndex);\n                that.trigger(COLUMNREORDER, {\n                  newIndex: newIndex,\n                  oldIndex: inArray(column, columns),\n                  column: column\n                });\n                that.reorderColumn(newIndex, column, e.position === \"before\");\n              }\n            });\n          },\n          _allowDragOverContainers: function (sourceIndex, targetIndex) {\n            var columns = flatColumnsInDomOrder(this.columns);\n            return columns[sourceIndex].lockable !== false && targetParentContainerIndex(columns, this.columns, sourceIndex, targetIndex) > -1;\n          },\n          _reorderTrees: function (destSources, destContainer, destDomTree, sources, sourcesContainer, sourcesDomTree, before, depth) {\n            var ths = $();\n            var source = sourcesContainer.find(\"tr\").eq(sources[0].rowIndex);\n            var sourceDOM = sourcesDomTree.children[sources[0].rowIndex];\n            var sourceChildren = source.children();\n            var destDomChildren;\n            var currentIndex;\n            var destColumn = before ? destSources[0] : destSources[destSources.length - 1];\n            var destRow;\n            var sourcesLeafs;\n            var destLeafs;\n            var reorderTaget;\n            var destThs;\n\n            for (var idx = 0; idx < sources.length; idx++) {\n              currentIndex = sources[idx].cellIndex;\n              ths = ths.add(sourceChildren.eq(currentIndex));\n              destDomChildren = destDomTree.children[destColumn.rowIndex].children;\n\n              if (destDomTree === sourcesDomTree && before) {\n                currentIndex += idx;\n              }\n\n              destDomChildren.splice(before ? destColumn.cellIndex + idx : destColumn.cellIndex + 1 + idx, 0, sourceDOM.children[currentIndex]);\n            }\n\n            if (destDomTree === sourcesDomTree && before) {\n              sourceDOM.children.splice(sources[0].cellIndex + sources.length, sources.length);\n            } else {\n              sourceDOM.children.splice(sources[0].cellIndex, sources.length);\n            }\n\n            destRow = destContainer.find(\"tr\").eq(destColumn.rowIndex);\n            destThs = destRow.find(\">th.k-header\").eq(destColumn.cellIndex);\n\n            if (destThs.length && ths[0] !== destThs[0]) {\n              ths[before ? \"insertBefore\" : \"insertAfter\"](destThs);\n            }\n\n            if (depth >= sources[0].rowIndex + 1 && depth != 1) {\n              sourcesLeafs = [];\n\n              for (idx = 0; idx < sources.length; idx++) {\n                if (sources[idx].columns) {\n                  sourcesLeafs = sourcesLeafs.concat(sources[idx].columns);\n                }\n              }\n\n              if (!sourcesLeafs.length) {\n                return;\n              }\n\n              destLeafs = [];\n\n              for (idx = 0; idx < destSources.length; idx++) {\n                if (destSources[idx].columns) {\n                  destLeafs = destLeafs.concat(destSources[idx].columns);\n                }\n              }\n\n              if (!destLeafs.length && (destContainer !== sourcesContainer || destColumn.cellIndex - sources[0].cellIndex > 1 || sources[0].cellIndex - destColumn.cellIndex > 1)) {\n                reorderTaget = findReorderTarget(this.columns, destColumn, sources[0], before, this.columns);\n                destLeafs = [reorderTaget];\n\n                if (!reorderTaget && sourcesLeafs.length && destContainer.find(\"tr\").length > sources[0].rowIndex + 1) {\n                  this._insertTree(sourcesLeafs, sourcesContainer, sourcesDomTree, destContainer, destDomTree);\n\n                  return;\n                }\n              }\n\n              if (!destLeafs.length) {\n                return;\n              }\n\n              this._reorderTrees(destLeafs, destContainer, destDomTree, sourcesLeafs, sourcesContainer, sourcesDomTree, before, depth);\n            }\n          },\n          _insertTree: function (columns, sourcesContainer, sourcesDomTree, destContainer, destDomTree) {\n            var leafs = [];\n            var row;\n            var ths = $();\n            var domTr;\n            row = sourcesContainer.find(\"tr\").eq(columns[0].rowIndex);\n            domTr = sourcesDomTree.children[columns[0].rowIndex];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].columns) {\n                leafs = leafs.concat(columns[idx].columns);\n              }\n\n              destDomTree.children[columns[0].rowIndex].children.splice(idx, 0, domTr.children[columns[idx].rowIndex]);\n              ths = ths.add(row.find(\">th.k-header\").eq(columns[idx].cellIndex));\n            }\n\n            sourcesDomTree.children[columns[0].rowIndex].children.splice(columns[0].cellIndex, columns.length);\n            destContainer.find(\"tr\").eq(columns[0].rowIndex).append(ths);\n\n            if (leafs.length) {\n              this._insertTree(leafs, sourcesContainer, sourcesDomTree, destContainer, destDomTree);\n            }\n          },\n          _reorderHeader: function (destColumn, column, before) {\n            var sourcesDepth = column.columns ? depth([column]) : 1;\n            var targetDepth = destColumn.columns ? depth([destColumn]) : 1;\n            var sourceLocked = isLocked(column);\n            var destLocked = isLocked(destColumn);\n            var destContainer = destLocked ? this.lockedHeader : this.thead;\n            var sourcesContainer = sourceLocked ? this.lockedHeader : this.thead;\n            var destDomTree = destLocked ? this._lockedHeaderTree : this._headerTree;\n            var sourcesDomTree = sourceLocked ? this._lockedHeaderTree : this._headerTree;\n            var rowsToAdd;\n            var destRows = destContainer.find(\"tr:not(.k-filter-row)\");\n            var destTarget;\n\n            if (sourcesDepth === targetDepth || sourcesDepth < destRows.length) {\n              this._reorderTrees([destColumn], destContainer, destDomTree, [column], sourcesContainer, sourcesDomTree, before, sourcesDepth);\n\n              updateRowSpans(destContainer, destDomTree);\n              removeEmptyRows(sourcesContainer, sourcesDomTree);\n            } else {\n              if (destContainer !== sourcesContainer) {\n                rowsToAdd = sourcesDepth - destRows.length;\n                destRows.each(function (idx) {\n                  var cells = this.cells;\n\n                  for (var i = 0; i < cells.length; i++) {\n                    if (cells[i].colSpan <= 1 && cells[i].attributes.rowspan) {\n                      destDomTree.children[idx].children[i].attr.rowSpan += rowsToAdd;\n                      cells[i].rowSpan += rowsToAdd;\n                    }\n                  }\n                });\n\n                for (var j = 0; j < rowsToAdd; j++) {\n                  destDomTree.children.push(kendoDomElement(\"tr\", {\n                    \"role\": \"row\"\n                  }));\n\n                  if (destContainer.is(\"thead\")) {\n                    destTarget = destContainer;\n                  } else {\n                    destTarget = destContainer.find(\"thead\");\n                  }\n\n                  if (this._hasFilterRow()) {\n                    $(\"<tr role='row'></tr>\").insertBefore(destTarget.find('tr.k-filter-row'));\n                  } else {\n                    destTarget.append(\"<tr role='row'></tr>\");\n                  }\n                }\n              }\n\n              this._reorderTrees([destColumn], destContainer, destDomTree, [column], sourcesContainer, sourcesDomTree, before, sourcesDepth);\n\n              removeEmptyRows(sourcesContainer, sourcesDomTree);\n            }\n          },\n          reorderColumn: function (destIndex, column, before) {\n            var lockChanged;\n            var parent = column.parentColumn;\n            var columns = parent ? parent.columns : this.columns;\n            var sourceIndex = inArray(column, columns);\n            var destColumn = columns[destIndex];\n            var isLocked = !!destColumn.locked;\n            var hasMultiColumnHeaders = grep(this.columns, function (item) {\n              return item.columns !== undefined;\n            }).length > 0;\n            var nonLockedColumnsLength = nonLockedColumns(columns).length;\n\n            if (sourceIndex === destIndex) {\n              return;\n            }\n\n            if (isLocked && !column.locked && nonLockedColumnsLength == 1) {\n              return;\n            }\n\n            if (!isLocked && column.locked && columns.length - nonLockedColumnsLength == 1) {\n              return;\n            }\n\n            if (before === undefined) {\n              before = destIndex < sourceIndex;\n            }\n\n            if (hasMultiColumnHeaders) {\n              this._reorderHeader(destColumn, column, before);\n            }\n\n            lockChanged = !!column.locked;\n            lockChanged = lockChanged != isLocked;\n            column.locked = isLocked;\n            columns.splice(before ? destIndex : destIndex + 1, 0, column);\n            columns.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\n            this._setColumnDataIndexes(leafColumns(this.columns));\n\n            this._clearColsCache();\n\n            this._renderCols(); //reorder column header manually\n\n\n            if (!hasMultiColumnHeaders) {\n              var ths = $(this.lockedHeader).add(this.thead).find(\"tr:not(.k-filter-row) th\");\n              ths.eq(sourceIndex)[before ? \"insertBefore\" : \"insertAfter\"](ths.eq(destIndex));\n              var dom = this._headerTree.children[0].children;\n\n              if (this._hasLockedColumns) {\n                dom = this._lockedHeaderTree.children[0].children.concat(dom);\n              }\n\n              dom.splice(before ? destIndex : destIndex + 1, 0, dom[sourceIndex]);\n              dom.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\n              if (this._hasLockedColumns) {\n                this._lockedHeaderTree.children[0].children = dom.splice(0, lockedColumns(columns).length);\n                this._headerTree.children[0].children = dom;\n              }\n            } else {\n              if (this.lockedHeader) {\n                columns = nonLockedColumns(this.columns);\n\n                this._prepareColumns([{\n                  rowSpan: 1,\n                  cells: [],\n                  index: 0\n                }], columns);\n\n                columns = lockedColumns(this.columns);\n\n                this._prepareColumns([{\n                  rowSpan: 1,\n                  cells: [],\n                  index: 0\n                }], columns);\n              } else {\n                this._prepareColumns([{\n                  rowSpan: 1,\n                  cells: [],\n                  index: 0\n                }], this.columns);\n              }\n            }\n\n            this._updateColumnCellIndex();\n\n            this._applyLockedContainersWidth();\n\n            this._syncLockedHeaderHeight();\n\n            this._updateFirstColumnClass();\n\n            if (this._hasFilterRow()) {\n              this._updateFilterThs(before, column, destColumn);\n            }\n\n            this.refresh();\n\n            if (!lockChanged) {\n              return;\n            }\n\n            if (isLocked) {\n              this.trigger(COLUMNLOCK, {\n                column: column\n              });\n            } else {\n              this.trigger(COLUMNUNLOCK, {\n                column: column\n              });\n            }\n          },\n          lockColumn: function (column) {\n            var columns = this.columns;\n\n            if (typeof column == \"number\") {\n              column = columns[column];\n            } else {\n              column = grep(columns, function (item) {\n                return item.field === column;\n              })[0];\n            }\n\n            if (!column || column.hidden) {\n              return;\n            }\n\n            var index = lockedColumns(columns).length - 1;\n            this.reorderColumn(index, column, false);\n          },\n          unlockColumn: function (column) {\n            var columns = this.columns;\n\n            if (typeof column == \"number\") {\n              column = columns[column];\n            } else {\n              column = grep(columns, function (item) {\n                return item.field === column;\n              })[0];\n            }\n\n            if (!column || column.hidden) {\n              return;\n            }\n\n            var index = lockedColumns(columns).length;\n            this.reorderColumn(index, column, true);\n          },\n          _columnMenu: function () {\n            var ths = $(this.lockedHeader).add(this.thead).find(\"th\");\n            var columns = this.columns;\n            var options = this.options;\n            var columnMenu = options.columnMenu;\n            var column, menu, menuOptions, sortable, filterable;\n\n            var initHandler = this._columnMenuInit.bind(this);\n\n            var openHandler = this._columnMenuOpen.bind(this);\n\n            var hasLockableColumns = grep(this.columns, function (item) {\n              return item.lockable !== false;\n            }).length > 0;\n            var hasMultiColumnHeaders = grep(this.columns, function (item) {\n              return item.columns !== undefined;\n            }).length > 0;\n\n            if (hasMultiColumnHeaders) {\n              columns = leafColumns(columns);\n\n              if (this.lockedHeader) {\n                ths = sortCells(leafDataCells(this.lockedHeader.find(\">table>thead\")).add(leafDataCells(this.thead)));\n              } else {\n                ths = leafDataCells(this.thead);\n              }\n            } else {\n              ths = $(this.lockedHeader).add(this.thead).find(\"tr:not(.k-filter-row) th\");\n            }\n\n            if (!columnMenu) {\n              return;\n            }\n\n            if (typeof columnMenu == \"boolean\") {\n              columnMenu = {};\n            }\n\n            for (var i = 0; i < ths.length; i++) {\n              column = columns[i];\n\n              if (!column.field) {\n                continue;\n              }\n\n              menu = ths.eq(i).data(\"kendoColumnMenu\");\n\n              if (menu) {\n                menu.destroy();\n              }\n\n              sortable = false;\n\n              if (column.sortable !== false && columnMenu.sortable !== false && options.sortable !== false) {\n                sortable = extend({}, options.sortable, {\n                  compare: (column.sortable || {}).compare\n                });\n              }\n\n              filterable = false;\n\n              if (options.filterable && column.filterable !== false && columnMenu.filterable !== false) {\n                filterable = extend({\n                  pane: this.pane\n                }, column.filterable, options.filterable);\n              }\n\n              menuOptions = {\n                dataSource: this.dataSource,\n                values: column.values,\n                columns: columnMenu.columns,\n                sortable: sortable,\n                filterable: filterable,\n                messages: columnMenu.messages,\n                owner: this,\n                closeCallback: $.noop,\n                init: initHandler,\n                open: openHandler,\n                pane: this.pane,\n                hasLockableColumns: lockedColumns(columns).length > 0 && hasLockableColumns && !hasMultiColumnHeaders,\n                appendTo: DOT + classNames.headerCellInner\n              };\n\n              if (options.$angular) {\n                menuOptions.$angular = options.$angular;\n              }\n\n              ths.eq(i).kendoColumnMenu(menuOptions);\n            }\n          },\n          _columnMenuInit: function (e) {\n            this.trigger(COLUMNMENUINIT, {\n              field: e.field,\n              container: e.container\n            });\n          },\n          _columnMenuOpen: function (e) {\n            this.trigger(COLUMNMENUOPEN, {\n              field: e.field,\n              container: e.container\n            });\n          },\n          _pageable: function () {\n            var that = this,\n                wrapper,\n                pageable = that.options.pageable;\n\n            if (pageable) {\n              wrapper = that.wrapper.children(\"div.k-grid-pager\");\n\n              if (!wrapper.length) {\n                wrapper = $('<div class=\"k-pager-wrap k-grid-pager\"/>').appendTo(that.wrapper);\n              }\n\n              that._destroyPager();\n\n              if (typeof pageable === \"object\" && pageable instanceof kendo.ui.TreeListPager) {\n                that.pager = pageable;\n              } else if (that.dataSource && !that.dataSource.options.serverPaging) {\n                that._createPager(wrapper);\n              }\n\n              if (that.pager) {\n                that.pager.bind(PAGE_CHANGE, function (e) {\n                  if (that.trigger(PAGE, {\n                    page: e.index\n                  })) {\n                    e.preventDefault();\n                  }\n                });\n              }\n            }\n          },\n          _createPager: function (element, options) {\n            var that = this;\n            that.pager = new TreeListPager(element, extend({}, that.options.pageable, {\n              dataSource: that.dataSource,\n              navigatable: that.options.navigatable\n            }, options));\n          },\n          _destroyPager: function () {\n            if (this.pager) {\n              this.pager.destroy();\n              this.pager = null;\n            }\n          },\n          _isPageable: function () {\n            var that = this;\n            return that.options.pageable && (!that.dataSource || that.dataSource && that.dataSource._isPageable());\n          },\n          _togglePagerVisibility: function () {\n            var that = this;\n            var pageable = that.options.pageable;\n\n            if (pageable && (isPlainObject(pageable) || pageable instanceof TreeListPager) && pageable.alwaysVisible === false) {\n              that.wrapper.find(\".k-grid-pager\").toggle((that.dataSource.collapsedTotal() || 0) >= that.dataSource.pageSize());\n            }\n          }\n        });\n\n        function isInputElement(element) {\n          return $(element).is(\":button,a,:input,a>.k-icon,textarea,span.k-select,span.k-icon,span.k-link,.k-input,.k-multiselect-wrap,.k-tool-icon\");\n        }\n\n        function isLocked(column) {\n          if (!column.parentColumn) {\n            return !!column.locked;\n          }\n\n          return !!isLocked(column.parentColumn);\n        }\n\n        function findParentColumnWithChildren(columns, index, source, rtl) {\n          var target;\n          var locked = !!source.locked;\n          var targetLocked;\n\n          do {\n            target = columns[index];\n            index += rtl ? 1 : -1;\n            targetLocked = !!target.locked;\n          } while (target && index > -1 && index < columns.length && target != source && !target.columns && targetLocked === locked);\n\n          return target;\n        }\n\n        function findReorderTarget(columns, target, source, before, masterColumns) {\n          if (target.columns) {\n            target = target.columns;\n            return target[before ? 0 : target.length - 1];\n          } else {\n            var parent = columnParent(target, columns);\n            var parentColumns;\n\n            if (parent) {\n              parentColumns = parent.columns;\n            } else {\n              parentColumns = columns;\n            }\n\n            var index = inArray(target, parentColumns);\n\n            if (index === 0 && before && parentColumns.length !== 1) {\n              index++;\n            } else if (index == parentColumns.length - 1 && !before && index !== 0) {\n              index--;\n            } else if (index > 0 || index === 0 && !before && index !== 0) {\n              index += before ? -1 : 1;\n            }\n\n            var sourceIndex = inArray(source, parentColumns);\n            target = findParentColumnWithChildren(parentColumns, index, source, sourceIndex > index);\n            var targetIndex = inArray(target, masterColumns);\n\n            if (target.columns && (!targetIndex || targetIndex === parentColumns.length - 1)) {\n              return null;\n            }\n\n            if (target && target != source && target.columns) {\n              return findReorderTarget(columns, target, source, before, masterColumns);\n            }\n          }\n\n          return null;\n        }\n\n        function leafColumns(columns) {\n          var result = [];\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            if (!columns[idx].columns) {\n              result.push(columns[idx]);\n              continue;\n            }\n\n            result = result.concat(leafColumns(columns[idx].columns));\n          }\n\n          return result;\n        }\n\n        function getColumnsFields(columns) {\n          var result = [];\n          columns = leafColumns(columns);\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            if (typeof columns[idx] === \"string\") {\n              result.push(columns[idx]);\n            } else if (columns[idx].field) {\n              result.push(columns[idx].field);\n            }\n          }\n\n          return result;\n        }\n\n        function visibleChildColumns(columns) {\n          return grep(columns, function (column) {\n            return !column.hidden;\n          });\n        }\n\n        function isVisible(column) {\n          return visibleColumns([column]).length > 0;\n        }\n\n        function visibleColumns(columns) {\n          return grep(columns, function (column) {\n            var result = !column.hidden;\n\n            if (result && column.columns) {\n              result = visibleColumns(column.columns).length > 0;\n            }\n\n            return result;\n          });\n        }\n\n        function normalizeColumns(columns, hide, parentIds) {\n          return map(columns, function (column) {\n            var hidden;\n            column.parentIds = parentIds;\n\n            if (!isVisible(column) || hide) {\n              hidden = true;\n            }\n\n            var uid = kendo.guid();\n            column.headerAttributes = extend({\n              headers: parentIds\n            }, column.headerAttributes);\n\n            if (!column.headerAttributes || !column.headerAttributes.id) {\n              column.headerAttributes = extend({\n                id: uid\n              }, column.headerAttributes);\n            } else {\n              uid = column.headerAttributes.id;\n            }\n\n            if (column.columns) {\n              column.columns = normalizeColumns(column.columns, hidden, parentIds ? parentIds + \" \" + uid : uid);\n            }\n\n            return extend({\n              hidden: hidden\n            }, column);\n          });\n        }\n\n        function flatColumnsInDomOrder(columns) {\n          var result = flatColumns(lockedColumns(columns));\n          return result.concat(flatColumns(nonLockedColumns(columns)));\n        }\n\n        function targetParentContainerIndex(flatColumns, columns, sourceIndex, targetIndex) {\n          var column = flatColumns[sourceIndex];\n          var target = flatColumns[targetIndex];\n          var parent = columnParent(column, columns);\n          columns = parent ? parent.columns : columns;\n          return inArray(target, columns);\n        }\n\n        function parentColumnsCells(cell) {\n          var container = cell.closest(\"table\");\n          var result = $().add(cell);\n          var row = cell.closest(\"tr\");\n          var headerRows = container.find(\"tr\");\n          var level = headerRows.index(row);\n\n          if (level > 0) {\n            var parent = headerRows.eq(level - 1);\n            var parentCellsWithChildren = parent.find(\"th\").filter(function () {\n              return !$(this).attr(\"rowspan\");\n            });\n            var offset = 0;\n            var index = row.find(\"th\").index(cell);\n            var prevCells = cell.prevAll().filter(function () {\n              return this.colSpan > 1;\n            });\n\n            for (var idx = 0; idx < prevCells.length; idx++) {\n              offset += prevCells[idx].colSpan || 1;\n            }\n\n            index += Math.max(offset - 1, 0);\n            offset = 0;\n\n            for (idx = 0; idx < parentCellsWithChildren.length; idx++) {\n              var parentCell = parentCellsWithChildren.eq(idx);\n\n              if (parentCell.attr(\"data-colspan\")) {\n                offset += parentCell[0].getAttribute(\"data-colspan\");\n              } else {\n                offset += 1;\n              }\n\n              if (index >= idx && index < offset) {\n                result = parentColumnsCells(parentCell).add(result);\n                break;\n              }\n            }\n          }\n\n          return result;\n        }\n\n        function childColumnsCells(cell) {\n          var container = cell.closest(\"thead\");\n          var result = $().add(cell);\n          var row = cell.closest(\"tr\");\n          var headerRows = container.find(\"tr\");\n          var level = headerRows.index(row) + cell[0].rowSpan;\n          var colSpanAttr = kendo.attr(\"colspan\");\n\n          if (level <= headerRows.length - 1) {\n            var child = row.next();\n            var prevCells = cell.prevAll();\n            var idx;\n            prevCells = prevCells.filter(function () {\n              return !this.rowSpan || this.rowSpan === 1;\n            });\n            var offset = 0;\n\n            for (idx = 0; idx < prevCells.length; idx++) {\n              offset += parseInt(prevCells.eq(idx).attr(colSpanAttr), 10) || 1;\n            }\n\n            var cells = child.find(\"th\");\n            var colSpan = parseInt(cell.attr(colSpanAttr), 10) || 1;\n            idx = 0;\n\n            while (idx < colSpan) {\n              child = cells.eq(idx + offset);\n              result = result.add(childColumnsCells(child));\n              var value = parseInt(child.attr(colSpanAttr), 10);\n\n              if (value > 1) {\n                colSpan -= value - 1;\n              }\n\n              idx++;\n            }\n          }\n\n          return result;\n        }\n\n        function columnParent(column, columns) {\n          var parents = [];\n          columnParents(column, columns, parents);\n          return parents[parents.length - 1];\n        }\n\n        function columnParents(column, columns, parents) {\n          parents = parents || [];\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            if (column === columns[idx]) {\n              return true;\n            } else if (columns[idx].columns) {\n              var inserted = parents.length;\n              parents.push(columns[idx]);\n\n              if (!columnParents(column, columns[idx].columns, parents)) {\n                parents.splice(inserted, parents.length - inserted);\n              } else {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        }\n\n        function flatColumns(columns) {\n          var result = [];\n          var children = [];\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            result.push(columns[idx]);\n\n            if (columns[idx].columns) {\n              children = children.concat(columns[idx].columns);\n            }\n          }\n\n          if (children.length) {\n            result = result.concat(flatColumns(children));\n          }\n\n          return result;\n        }\n\n        function columnPosition(column, columns, row, cellCounts) {\n          var result;\n          var idx;\n          row = row || 0;\n          cellCounts = cellCounts || {};\n          cellCounts[row] = cellCounts[row] || 0;\n\n          for (idx = 0; idx < columns.length; idx++) {\n            if (columns[idx] == column) {\n              result = {\n                cell: cellCounts[row],\n                row: row\n              };\n              break;\n            } else if (columns[idx].columns) {\n              result = columnPosition(column, columns[idx].columns, row + 1, cellCounts);\n\n              if (result) {\n                break;\n              }\n            }\n\n            cellCounts[row]++;\n          }\n\n          return result;\n        }\n\n        function updateCellIndex(thead, columns, offset) {\n          offset = offset || 0;\n          var position;\n          var cell;\n          var allColumns = columns;\n          columns = leafColumns(columns);\n          var cells = {};\n          var rows = thead.find(\">tr:not(.k-filter-row)\");\n\n          var filter = function () {\n            var el = $(this);\n            return !el.hasClass(\"k-group-cell\") && !el.hasClass(\"k-hierarchy-cell\");\n          };\n\n          for (var idx = 0, length = columns.length; idx < length; idx++) {\n            position = columnPosition(columns[idx], allColumns);\n\n            if (!cells[position.row]) {\n              cells[position.row] = rows.eq(position.row).find(\".k-header\").filter(filter);\n            }\n\n            cell = cells[position.row].eq(position.cell);\n            cell.attr(kendo.attr(\"index\"), offset + idx);\n          }\n\n          return columns.length;\n        }\n\n        function depth(columns) {\n          var result = 1;\n          var max = 0;\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            if (columns[idx].columns) {\n              var temp = depth(columns[idx].columns);\n\n              if (temp > max) {\n                max = temp;\n              }\n            }\n          }\n\n          return result + max;\n        }\n\n        function lockedColumns(columns) {\n          return grep(columns, is(\"locked\"));\n        }\n\n        function nonLockedColumns(columns) {\n          return grep(columns, not(is(\"locked\")));\n        }\n\n        function updateRowSpans(container, containerDOMtree) {\n          var rows = container.find(\"tr:not(.k-filter-row)\");\n          var length = rows.length;\n          rows.each(function (idx) {\n            var cells = this.cells;\n\n            for (var i = 0; i < cells.length; i++) {\n              if (cells[i].colSpan <= 1 && cells[i].attributes.rowspan) {\n                containerDOMtree.children[idx].children[i].attr.rowSpan = length - idx;\n                cells[i].rowSpan = length - idx;\n              }\n            }\n          });\n        }\n\n        function removeEmptyRows(container, containerDOMtree) {\n          var rows = container.find(\"tr\");\n          var emptyRows = [];\n          rows.filter(function (idx) {\n            var shouldRemove = !$(this).children().length;\n\n            if (shouldRemove) {\n              emptyRows.push(idx);\n            }\n\n            return shouldRemove;\n          }).remove();\n\n          for (var i = emptyRows.length - 1; i >= 0; i--) {\n            containerDOMtree.children.splice(emptyRows[i], 1);\n          }\n\n          updateRowSpans(container, containerDOMtree);\n        }\n\n        function focusTable(table, direct) {\n          if (direct === true) {\n            table = $(table);\n            var scrollTop, scrollLeft;\n            scrollTop = table.parent().scrollTop();\n            scrollLeft = kendo.scrollLeft(table.parent());\n            kendo.focusElement(table);\n            kendo.scrollLeft(table.parent().scrollTop(scrollTop), scrollLeft);\n          } else {\n            $(table).one(\"focusin\", function (e) {\n              e.preventDefault();\n            }).trigger(\"focus\");\n          }\n        }\n\n        function adjustRowHeight(row1, row2) {\n          var height;\n          var offsetHeight1 = row1.offsetHeight;\n          var offsetHeight2 = row2.offsetHeight;\n\n          if (offsetHeight1 > offsetHeight2) {\n            height = offsetHeight1 + \"px\";\n          } else if (offsetHeight1 < offsetHeight2) {\n            height = offsetHeight2 + \"px\";\n          }\n\n          if (height) {\n            row1.style.height = row2.style.height = height;\n          }\n        }\n\n        function isColumnEditable(column, model) {\n          if (!column || !model || !column.field || column.selectable || column.command || column.editable && !column.editable(model)) {\n            return false;\n          }\n\n          return column.field && model.editable && model.editable(column.field);\n        }\n\n        function isDirtyColumn(column, model) {\n          var field = (column || {}).field || \"\";\n          return model.dirty && model.dirtyFields && model.dirtyFields[field] && isColumnEditable(column, model);\n        }\n\n        function isUndefined(value) {\n          return typeof value === \"undefined\";\n        }\n\n        function isNumber(value) {\n          return typeof value === \"number\" && !isNaN(value);\n        }\n\n        if (kendo.ExcelMixin) {\n          kendo.ExcelMixin.extend(TreeList.prototype);\n        }\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(TreeList.prototype);\n\n          TreeList.prototype._drawPDF = function (progress) {\n            var treeList = this;\n\n            if (treeList.options.pdf.paperSize && treeList.options.pdf.paperSize != \"auto\") {\n              return treeList._drawPDF_autoPageBreak(progress);\n            }\n\n            var result = new $.Deferred();\n            var dataSource = treeList.dataSource;\n            var allPages = treeList.options.pdf.allPages;\n\n            this._initPDFProgress(progress); // This group will be our document containing all pages\n\n\n            var doc = new kendo.drawing.Group();\n            var startingPage = dataSource.page();\n\n            function resolve() {\n              if (allPages && startingPage !== undefined) {\n                dataSource.unbind(\"change\", exportPage);\n                dataSource.one(\"change\", function () {\n                  result.resolve(doc);\n                });\n                dataSource.page(startingPage);\n              } else {\n                result.resolve(doc);\n              }\n            }\n\n            function exportPage() {\n              treeList._drawPDFShadow({\n                width: treeList.wrapper.width()\n              }, {\n                avoidLinks: treeList.options.pdf.avoidLinks\n              }).done(function (group) {\n                var pageNum = dataSource.page();\n                var totalPages = allPages ? dataSource.totalPages() : 1;\n                var args = {\n                  page: group,\n                  pageNumber: pageNum,\n                  progress: pageNum / totalPages,\n                  totalPages: totalPages\n                };\n                progress.notify(args);\n                doc.append(args.page);\n\n                if (pageNum < totalPages) {\n                  dataSource.page(pageNum + 1);\n                } else {\n                  resolve();\n                }\n              }).fail(function (err) {\n                result.reject(err);\n              });\n            }\n\n            if (allPages) {\n              dataSource.bind(\"change\", exportPage);\n              dataSource.page(1);\n            } else {\n              exportPage();\n            }\n\n            return result.promise();\n          };\n\n          TreeList.prototype._initPDFProgress = function (deferred) {\n            var loading = $(\"<div class='k-loading-pdf-mask'><div class='k-loading-color'></div></div>\");\n            loading.prepend(this.wrapper.clone().css({\n              position: \"absolute\",\n              top: 0,\n              left: 0\n            }));\n            this.wrapper.append(loading);\n            var progressBar = $(\"<div class='k-loading-pdf-progress'>\").appendTo(loading).kendoProgressBar({\n              type: \"chunk\",\n              chunkCount: 10,\n              min: 0,\n              max: 1,\n              value: 0\n            }).data(\"kendoProgressBar\");\n            deferred.progress(function (e) {\n              progressBar.value(e.progress);\n            }).always(function () {\n              kendo.destroy(loading);\n              loading.remove();\n            });\n          };\n\n          TreeList.prototype._drawPDF_autoPageBreak = function (progress) {\n            var treeList = this;\n            var result = new $.Deferred();\n            var dataSource = treeList.dataSource;\n            var allPages = treeList.options.pdf.allPages;\n            var origBody = treeList.wrapper.find('table[role=\"treeList\"] > tbody');\n            var cont = $(\"<div>\").css({\n              position: \"absolute\",\n              left: -10000,\n              top: -10000\n            });\n            var clone = treeList.wrapper.clone().css({\n              height: \"auto\",\n              width: \"auto\"\n            }).appendTo(cont);\n            clone.find(\".k-grid-content\").css({\n              height: \"auto\",\n              width: \"auto\",\n              overflow: \"visible\"\n            });\n            clone.find('table[role=\"treeList\"], .k-grid-footer table').css({\n              height: \"auto\",\n              width: \"100%\",\n              overflow: \"visible\"\n            });\n            clone.find(\".k-grid-pager, .k-grid-toolbar, .k-grouping-header\").remove();\n            clone.find(\".k-grid-header, .k-grid-footer\").css({\n              paddingRight: 0\n            });\n\n            this._initPDFProgress(progress);\n\n            var body = clone.find('table[role=\"treeList\"] > tbody').empty();\n            var startingPage = dataSource.page();\n\n            function resolve() {\n              if (allPages && startingPage !== undefined) {\n                dataSource.one(\"change\", draw);\n                dataSource.page(startingPage);\n              } else {\n                treeList.refresh();\n                draw();\n              }\n            }\n\n            function draw() {\n              cont.appendTo(document.body);\n              var options = $.extend({}, treeList.options.pdf, {\n                _destructive: true,\n                progress: function (p) {\n                  progress.notify({\n                    page: p.page,\n                    pageNumber: p.pageNum,\n                    progress: 0.5 + p.pageNum / p.totalPages / 2,\n                    totalPages: p.totalPages\n                  });\n                }\n              });\n              kendo.drawing.drawDOM(clone, options).always(function () {\n                cont.remove();\n              }).then(function (group) {\n                result.resolve(group);\n              }).fail(function (err) {\n                result.reject(err);\n              });\n            }\n\n            function renderPage() {\n              var pageNum = dataSource.page();\n              var totalPages = allPages ? dataSource.totalPages() : 1;\n              body.append(origBody.find(\"tr\"));\n\n              if (pageNum < totalPages) {\n                dataSource.page(pageNum + 1);\n              } else {\n                dataSource.unbind(\"change\", renderPage);\n                resolve();\n              }\n            }\n\n            if (allPages) {\n              dataSource.bind(\"change\", renderPage);\n              dataSource.page(1);\n            } else {\n              renderPage();\n            }\n\n            return result.promise();\n          };\n        }\n\n        extend(true, kendo.data, {\n          TreeListDataSource: TreeListDataSource,\n          TreeListModel: TreeListModel\n        });\n        ui.plugin(TreeList);\n        ui.plugin(TreeListPager);\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}