{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CENTER, LEFT } from '../../common/constants';\nimport { autoTextColor, deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\n\nclass FunnelChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.points = [];\n    this.labels = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  }\n\n  render() {\n    const {\n      options,\n      plotArea: {\n        options: {\n          seriesColors = []\n        }\n      }\n    } = this;\n    const series = options.series[0];\n    const data = series.data;\n\n    if (!data) {\n      return;\n    }\n\n    const {\n      total,\n      points\n    } = bindSegments(series);\n\n    for (let i = 0; i < points.length; i++) {\n      const pointData = points[i];\n\n      if (!pointData) {\n        continue;\n      }\n\n      let fields = pointData.fields;\n\n      if (!isFunction(series.color)) {\n        series.color = fields.color || seriesColors[i % seriesColors.length];\n      }\n\n      fields = deepExtend({\n        index: i,\n        owner: this,\n        series: series,\n        dataItem: data[i],\n        percentage: pointData.value / total\n      }, fields, {\n        visible: pointData.visible\n      });\n      const value = pointData.valueFields.value;\n      const segment = this.createSegment(value, fields);\n      const label = this.createLabel(value, fields);\n\n      if (segment && label) {\n        segment.append(label);\n      }\n    }\n  }\n\n  evalSegmentOptions(options, value, fields) {\n    const series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      index: fields.index\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"toggle\", \"visual\"]\n    });\n  }\n\n  createSegment(value, fields) {\n    const seriesOptions = deepExtend({}, fields.series);\n    this.evalSegmentOptions(seriesOptions, value, fields);\n    this.createLegendItem(value, seriesOptions, fields);\n\n    if (fields.visible !== false) {\n      const segment = new FunnelSegment(value, seriesOptions, fields);\n      Object.assign(segment, fields);\n      this.append(segment);\n      this.points.push(segment);\n      return segment;\n    }\n  }\n\n  createLabel(value, fields) {\n    const {\n      series,\n      dataItem\n    } = fields;\n    const labels = deepExtend({}, this.options.labels, series.labels);\n    let text = value;\n\n    if (labels.visible) {\n      const labelTemplate = getTemplate(labels);\n      const data = {\n        dataItem: dataItem,\n        value: value,\n        percentage: fields.percentage,\n        category: fields.category,\n        series: series\n      };\n\n      if (labelTemplate) {\n        text = labelTemplate(data);\n      } else if (labels.format) {\n        text = this.plotArea.chartService.format.auto(labels.format, text);\n      }\n\n      if (!labels.color) {\n        labels.color = autoTextColor(series.color);\n\n        if (!labels.background) {\n          labels.background = series.color;\n        }\n      }\n\n      this.evalSegmentOptions(labels, value, fields);\n      const textBox = new TextBox(text, deepExtend({\n        vAlign: labels.position\n      }, labels), data);\n      this.labels.push(textBox);\n      return textBox;\n    }\n  }\n\n  labelPadding() {\n    const labels = this.labels;\n    const padding = {\n      left: 0,\n      right: 0\n    };\n\n    for (let i = 0; i < labels.length; i++) {\n      const label = labels[i];\n      const align = label.options.align;\n\n      if (align !== CENTER) {\n        const width = labels[i].box.width();\n\n        if (align === LEFT) {\n          padding.left = Math.max(padding.left, width);\n        } else {\n          padding.right = Math.max(padding.right, width);\n        }\n      }\n    }\n\n    return padding;\n  }\n\n  dynamicSlopeReflow(box, width, totalHeight) {\n    const {\n      options,\n      points: segments\n    } = this;\n    const count = segments.length;\n    const firstSegment = segments[0];\n    let maxSegment = firstSegment;\n\n    for (let idx = 0; idx < segments.length; idx++) {\n      if (segments[idx].percentage > maxSegment.percentage) {\n        maxSegment = segments[idx];\n      }\n    }\n\n    let lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;\n    let previousOffset = (width - lastUpperSide) / 2;\n    let previousHeight = 0;\n\n    for (let idx = 0; idx < count; idx++) {\n      const percentage = segments[idx].percentage;\n      const nextSegment = segments[idx + 1];\n      const nextPercentage = nextSegment ? nextSegment.percentage : percentage;\n      const points = segments[idx].points = [];\n      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      let offset;\n\n      if (!percentage) {\n        offset = nextPercentage ? 0 : width / 2;\n      } else {\n        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n      }\n\n      offset = limitValue(offset, 0, width);\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n      previousOffset = offset;\n      previousHeight += height + options.segmentSpacing;\n      lastUpperSide = limitValue(width - 2 * offset, 0, width);\n    }\n  }\n\n  constantSlopeReflow(box, width, totalHeight) {\n    const {\n      options,\n      points: segments\n    } = this;\n    const count = segments.length;\n    const decreasingWidth = options.neckRatio <= 1;\n    const neckRatio = decreasingWidth ? options.neckRatio * width : width;\n    let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n    const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n    const finalNarrow = (topMostWidth - neckRatio) / 2;\n    let previousHeight = 0;\n\n    for (let idx = 0; idx < count; idx++) {\n      const points = segments[idx].points = [];\n      const percentage = segments[idx].percentage;\n      const offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;\n      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));\n      previousOffset += offset;\n      previousHeight += height + options.segmentSpacing;\n    }\n  }\n\n  reflow(chartBox) {\n    const points = this.points;\n    const count = points.length;\n\n    if (!count) {\n      return;\n    }\n\n    const options = this.options;\n    const box = chartBox.clone().unpad(this.labelPadding());\n    const totalHeight = box.height() - options.segmentSpacing * (count - 1);\n    const width = box.width();\n\n    if (options.dynamicSlope) {\n      this.dynamicSlopeReflow(box, width, totalHeight);\n    } else {\n      this.constantSlopeReflow(box, width, totalHeight);\n    }\n\n    for (let idx = 0; idx < count; idx++) {\n      points[idx].reflow(chartBox);\n    }\n  }\n\n}\n\nsetDefaultOptions(FunnelChart, {\n  neckRatio: 0.3,\n  width: 300,\n  dynamicSlope: false,\n  dynamicHeight: true,\n  segmentSpacing: 0,\n  labels: {\n    visible: false,\n    align: CENTER,\n    position: CENTER,\n    zIndex: 1\n  }\n});\ndeepExtend(FunnelChart.prototype, PieChartMixin);\nexport default FunnelChart;","map":null,"metadata":{},"sourceType":"module"}