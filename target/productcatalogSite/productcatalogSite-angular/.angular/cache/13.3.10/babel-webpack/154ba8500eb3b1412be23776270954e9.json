{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Component, HostBinding, Input, EventEmitter, Injectable, Optional, Inject, Directive, SkipSelf, QueryList, isDevMode, ContentChildren, ContentChild, forwardRef, Host, Output, SecurityContext, ChangeDetectionStrategy, ViewChild, HostListener, ViewChildren, Self, TemplateRef, Pipe, ViewEncapsulation, NgModule } from '@angular/core';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, Keys, anyChanged, isChanged as isChanged$1, KendoInput, guid, hasObservers, ResizeSensorComponent, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { merge, of, Subject, from, Subscription, interval, fromEvent, zip as zip$1, BehaviorSubject, Observable } from 'rxjs';\nimport { switchMap, take, map, filter, takeUntil, switchMapTo, delay, auditTime, distinctUntilChanged, tap, throttleTime, debounceTime, bufferCount } from 'rxjs/operators';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport * as i4 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i4$2 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, FormControl, FormGroup, ReactiveFormsModule, FormsModule } from '@angular/forms';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { orderBy, isCompositeFilterDescriptor, process, filterBy } from '@progress/kendo-data-query';\nimport * as i1$2 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport * as i1$3 from '@angular/platform-browser';\nimport * as i4$1 from '@progress/kendo-angular-inputs';\nimport { NumericTextBoxComponent, InputsModule, NumericTextBoxModule } from '@progress/kendo-angular-inputs';\nimport * as i1$4 from '@progress/kendo-angular-dropdowns';\nimport { DropDownListComponent, DropDownListModule, AutoCompleteModule, DropDownsModule } from '@progress/kendo-angular-dropdowns';\nimport * as i5 from '@progress/kendo-angular-label';\nimport { LabelModule } from '@progress/kendo-angular-label';\nimport * as i4$3 from '@progress/kendo-angular-dateinputs';\nimport { DatePickerModule } from '@progress/kendo-angular-dateinputs';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { getter } from '@progress/kendo-common';\nimport * as i1$5 from '@progress/kendo-angular-intl';\nimport { Button } from '@progress/kendo-angular-buttons';\nimport { PDFExportMarginComponent, PDFExportTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';\nimport { saveAs } from '@progress/kendo-file-saver';\nimport { workbookOptions, toDataURL, ColumnBase as ColumnBase$1, ExcelExportModule } from '@progress/kendo-angular-excel-export';\n\nfunction ToolbarComponent_0_ng_template_0_Template(rf, ctx) {}\n\nfunction ToolbarComponent_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.toolbarTemplateRef)(\"ngTemplateOutletContext\", ctx_r0.context);\n  }\n}\n\nconst _c0 = function (a2) {\n  return {\n    \"k-link\": true,\n    \"k-pager-nav\": true,\n    \"k-state-disabled\": a2,\n    \"k-pager-first\": true\n  };\n};\n\nconst _c1 = function () {\n  return {\n    \"k-icon\": true,\n    \"k-i-seek-w\": true\n  };\n};\n\nconst _c2 = function (a2) {\n  return {\n    \"k-link\": true,\n    \"k-pager-nav\": true,\n    \"k-state-disabled\": a2,\n    \"\": true\n  };\n};\n\nconst _c3 = function () {\n  return {\n    \"k-icon\": true,\n    \"k-i-arrow-w\": true\n  };\n};\n\nfunction PagerNumericButtonsComponent_option_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 7);\n    i0.ɵɵtext(1, \"... \");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"selected\", false);\n    i0.ɵɵattribute(\"aria-label\", ctx_r0.pageLabel(ctx_r0.start - 1));\n  }\n}\n\nconst _c4 = function (a1) {\n  return {\n    \"k-link\": true,\n    \"k-state-selected\": a1\n  };\n};\n\nfunction PagerNumericButtonsComponent_option_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const num_r6 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", num_r6.toString())(\"selected\", num_r6 === ctx_r1.currentPage)(\"ngClass\", i0.ɵɵpureFunction1(6, _c4, ctx_r1.currentPage === num_r6));\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.pageLabel(num_r6))(\"aria-current\", ctx_r1.currentPage === num_r6 ? \"page\" : undefined);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", num_r6, \" \");\n  }\n}\n\nfunction PagerNumericButtonsComponent_option_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 9);\n    i0.ɵɵtext(1, \"... \");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"selected\", false);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.pageLabel(ctx_r2.end + 1));\n  }\n}\n\nfunction PagerNumericButtonsComponent_li_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\")(1, \"span\", 10);\n    i0.ɵɵlistener(\"click\", function PagerNumericButtonsComponent_li_5_Template_span_click_1_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.changePage(ctx_r7.start - 2);\n    })(\"keydown.enter\", function PagerNumericButtonsComponent_li_5_Template_span_keydown_enter_1_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.changePage(ctx_r9.start - 2);\n    });\n    i0.ɵɵtext(2, \"...\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-label\", ctx_r3.pageLabel(ctx_r3.start - 1));\n  }\n}\n\nconst _c5 = function (a1) {\n  return {\n    \"k-link\": true,\n    \"k-state-selected\": a1,\n    \"k-pager-nav\": true\n  };\n};\n\nfunction PagerNumericButtonsComponent_li_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\")(1, \"span\", 11);\n    i0.ɵɵlistener(\"click\", function PagerNumericButtonsComponent_li_6_Template_span_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const num_r10 = restoredCtx.$implicit;\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.changePage(num_r10 - 1);\n    })(\"keydown.enter\", function PagerNumericButtonsComponent_li_6_Template_span_keydown_enter_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const num_r10 = restoredCtx.$implicit;\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.changePage(num_r10 - 1);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const num_r10 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c5, ctx_r4.currentPage === num_r10));\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.pageLabel(num_r10));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", num_r10, \" \");\n  }\n}\n\nfunction PagerNumericButtonsComponent_li_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\")(1, \"span\", 10);\n    i0.ɵɵlistener(\"click\", function PagerNumericButtonsComponent_li_7_Template_span_click_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.changePage(ctx_r14.end);\n    })(\"keydown.enter\", function PagerNumericButtonsComponent_li_7_Template_span_keydown_enter_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.changePage(ctx_r16.end);\n    });\n    i0.ɵɵtext(2, \"...\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.pageLabel(ctx_r5.end + 1));\n  }\n}\n\nconst _c6 = function () {\n  return {\n    \"k-pager-numbers\": true,\n    \"k-reset\": true\n  };\n};\n\nconst _c7 = function () {\n  return {\n    \"k-pager-input\": true,\n    \"k-label\": true\n  };\n};\n\nconst _c8 = function (a0, a1) {\n  return {\n    keydown: a0,\n    focusout: a1\n  };\n};\n\nconst _c9 = function () {\n  return {\n    \"k-icon\": true,\n    \"k-i-arrow-e\": true\n  };\n};\n\nconst _c10 = function (a2) {\n  return {\n    \"k-link\": true,\n    \"k-pager-nav\": true,\n    \"k-state-disabled\": a2,\n    \"k-pager-last\": true\n  };\n};\n\nconst _c11 = function () {\n  return {\n    \"k-icon\": true,\n    \"k-i-seek-e\": true\n  };\n};\n\nfunction PagerComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵlistener(\"focusin\", function PagerComponent_div_0_Template_div_focusin_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.onInnerFocusIn($event, \"start\");\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r0.focusTrapTabIndex);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\n\nfunction PagerComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template.templateRef)(\"ngTemplateOutletContext\", ctx_r1.templateContext);\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_prev_buttons_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-prev-buttons\");\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_numeric_buttons_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-numeric-buttons\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"buttonCount\", ctx_r8.settings.buttonCount);\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_input_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-input\");\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_next_buttons_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-next-buttons\");\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_info_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-info\");\n  }\n}\n\nfunction PagerComponent_ng_container_2_kendo_pager_page_sizes_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-pager-page-sizes\", 9, 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"pageSizes\", ctx_r12.settings.pageSizes);\n  }\n}\n\nfunction PagerComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, PagerComponent_ng_container_2_kendo_pager_prev_buttons_1_Template, 1, 0, \"kendo-pager-prev-buttons\", 2);\n    i0.ɵɵtemplate(2, PagerComponent_ng_container_2_kendo_pager_numeric_buttons_2_Template, 1, 1, \"kendo-pager-numeric-buttons\", 6);\n    i0.ɵɵtemplate(3, PagerComponent_ng_container_2_kendo_pager_input_3_Template, 1, 0, \"kendo-pager-input\", 2);\n    i0.ɵɵtemplate(4, PagerComponent_ng_container_2_kendo_pager_next_buttons_4_Template, 1, 0, \"kendo-pager-next-buttons\", 2);\n    i0.ɵɵtemplate(5, PagerComponent_ng_container_2_kendo_pager_info_5_Template, 1, 0, \"kendo-pager-info\", 2);\n    i0.ɵɵtemplate(6, PagerComponent_ng_container_2_kendo_pager_page_sizes_6_Template, 2, 1, \"kendo-pager-page-sizes\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.previousNext);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.type === \"numeric\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.type === \"input\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.previousNext);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.info);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.settings.pageSizes);\n  }\n}\n\nfunction PagerComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵlistener(\"focusin\", function PagerComponent_div_3_Template_div_focusin_0_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.onInnerFocusIn($event, \"end\");\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r3.focusTrapTabIndex);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\n\nfunction PagerComponent_kendo_resize_sensor_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 11);\n    i0.ɵɵlistener(\"resize\", function PagerComponent_kendo_resize_sensor_4_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.resizeHandler();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c12 = [\"kendoGroupIndicator\", \"\"];\n\nconst _c13 = function () {\n  return {\n    lastTarget: true\n  };\n};\n\nfunction GroupPanelComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"context\", i0.ɵɵpureFunction0(2, _c13));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.text, \" \");\n  }\n}\n\nconst _c14 = function (a0) {\n  return {\n    field: a0\n  };\n};\n\nconst _c15 = function (a0, a2) {\n  return {\n    field: a0,\n    type: \"groupIndicator\",\n    hint: a2\n  };\n};\n\nfunction GroupPanelComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 3)(1, \"div\", 4);\n    i0.ɵɵlistener(\"directionChange\", function GroupPanelComponent_div_1_Template_div_directionChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.directionChange($event);\n    })(\"remove\", function GroupPanelComponent_div_1_Template_div_remove_1_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.remove($event);\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const group_r3 = ctx.$implicit;\n    const index_r4 = ctx.index;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"context\", i0.ɵɵpureFunction1(5, _c14, group_r3.field));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"enableDrag\", true)(\"context\", i0.ɵɵpureFunction2(7, _c15, group_r3.field, ctx_r1.groupTitles[index_r4]))(\"group\", group_r3)(\"groupTitle\", ctx_r1.groupTitles[index_r4]);\n  }\n}\n\nfunction GroupPanelComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1, \"\\xA0\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"context\", i0.ɵɵpureFunction0(1, _c13));\n  }\n}\n\nconst _c16 = [\"kendoGridColGroup\", \"\"];\n\nfunction ColGroupComponent_col_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-group-col\", true);\n  }\n}\n\nfunction ColGroupComponent_col_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-hierarchy-col\", true);\n  }\n}\n\nfunction ColGroupComponent_col_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    i0.ɵɵstyleProp(\"width\", column_r4.width, \"px\");\n  }\n}\n\nconst _c17 = [\"*\"];\n\nfunction StringFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function StringFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.logicChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\n\nfunction StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-string-filter-menu-input\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"menuTabbingService\", ctx_r1.menuTabbingService);\n  }\n}\n\nfunction NumericFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function NumericFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.logicChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\n\nfunction NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-numeric-filter-menu-input\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"format\", ctx_r1.format)(\"decimals\", ctx_r1.decimals)(\"spinners\", ctx_r1.spinners)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"step\", ctx_r1.step)(\"menuTabbingService\", ctx_r1.menuTabbingService);\n  }\n}\n\nfunction DateFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 3);\n    i0.ɵɵlistener(\"valueChange\", function DateFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.logicChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx_r0.filterMenuDropDownLabel)(\"data\", ctx_r0.logicOperators)(\"valuePrimitive\", true)(\"value\", ctx_r0.filter == null ? null : ctx_r0.filter.logic);\n  }\n}\n\nfunction DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-date-filter-menu-input\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"operators\", ctx_r1.operators)(\"currentFilter\", ctx_r1.secondFilter)(\"filterService\", ctx_r1.filterService)(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter)(\"activeView\", ctx_r1.activeView)(\"bottomView\", ctx_r1.bottomView)(\"topView\", ctx_r1.topView)(\"format\", ctx_r1.format)(\"formatPlaceholder\", ctx_r1.formatPlaceholder)(\"placeholder\", ctx_r1.placeholder)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"weekNumber\", ctx_r1.weekNumber)(\"menuTabbingService\", ctx_r1.menuTabbingService);\n  }\n}\n\nfunction BooleanFilterMenuComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\")(1, \"input\", 2, 3);\n    i0.ɵɵlistener(\"change\", function BooleanFilterMenuComponent_li_1_Template_input_change_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const item_r1 = restoredCtx.$implicit;\n\n      const _r2 = i0.ɵɵreference(2);\n\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.onChange(item_r1.value, _r2);\n    })(\"keydown.shift.tab\", function BooleanFilterMenuComponent_li_1_Template_input_keydown_shift_tab_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.onShiftTab($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"label\", 4);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columnLabel\", ctx_r0.columnLabel)(\"name\", ctx_r0.idPrefix)(\"checked\", ctx_r0.isSelected(item_r1.value));\n    i0.ɵɵattribute(\"id\", ctx_r0.radioId(item_r1.value));\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"for\", ctx_r0.radioId(item_r1.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(item_r1.text);\n  }\n}\n\nconst _c18 = [\"resetButton\"];\nconst _c19 = [\"filterButton\"];\n\nfunction FilterMenuContainerComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 9);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"filterService\", ctx_r0.childService)(\"column\", ctx_r0.column)(\"filter\", ctx_r0.childFilter)(\"menuTabbingService\", ctx_r0.menuTabbingService);\n  }\n}\n\nfunction FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) {}\n\nfunction FilterMenuContainerComponent_ng_container_4_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template, 0, 0, \"ng-template\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.column.filterMenuTemplateRef)(\"ngTemplateOutletContext\", ctx_r4.templateContext);\n  }\n}\n\nfunction FilterMenuContainerComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, FilterMenuContainerComponent_ng_container_4_1_Template, 1, 2, null, 10);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.column.filterMenuTemplateRef);\n  }\n}\n\nconst _c20 = [\"anchor\"];\nconst _c21 = [\"template\"];\n\nfunction FilterMenuComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-container\", 4);\n    i0.ɵɵlistener(\"close\", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.close();\n    })(\"keydown.escape\", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.close();\n    })(\"keydown.enter\", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"column\", ctx_r2.column)(\"filter\", ctx_r2.filter);\n  }\n}\n\nconst _c22 = function (a1) {\n  return {\n    \"k-grid-filter\": true,\n    \"k-state-active\": a1\n  };\n};\n\nfunction ColumnMenuItemComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.iconClass);\n  }\n}\n\nfunction ColumnMenuItemComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵelementContainer(1, 5);\n    i0.ɵɵelement(2, \"div\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@state\", ctx_r1.contentState);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.contentTemplate.templateRef);\n  }\n}\n\nfunction ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-lock\", 3);\n    i0.ɵɵlistener(\"keydown.tab\", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext(2);\n      return ctx_r3.onTab($event, !ctx_r3.showStick);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r1.service);\n  }\n}\n\nfunction ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-stick\", 3);\n    i0.ɵɵlistener(\"keydown.tab\", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.onTab($event, true);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"service\", ctx_r2.service);\n  }\n}\n\nfunction ColumnMenuPositionComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template, 1, 1, \"kendo-grid-columnmenu-lock\", 2);\n    i0.ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template, 1, 1, \"kendo-grid-columnmenu-stick\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showLock);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showStick);\n  }\n}\n\nconst _c23 = [\"applyButton\"];\n\nfunction ColumnListComponent_label_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"label\", 3);\n    i0.ɵɵelement(1, \"input\", 4);\n    i0.ɵɵelementStart(2, \"span\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const column_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checked\", !column_r2.hidden)(\"disabled\", ctx_r0.isDisabled(column_r2));\n    i0.ɵɵattribute(\"data-index\", index_r3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r2.displayTitle);\n  }\n}\n\nfunction ColumnListComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 6)(1, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function ColumnListComponent_div_2_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.cancelChanges();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 8, 9);\n    i0.ɵɵlistener(\"keydown.tab\", function ColumnListComponent_div_2_Template_button_keydown_tab_3_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.onTab($event);\n    })(\"click\", function ColumnListComponent_div_2_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.applyChanges();\n    });\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.actionsClass);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.resetText);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r1.applyText);\n  }\n}\n\nfunction ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-columnlist\", 2);\n    i0.ɵɵlistener(\"apply\", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_grid_columnlist_apply_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.onApply($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"applyText\", ctx_r0.localization.get(\"columnsApply\"))(\"resetText\", ctx_r0.localization.get(\"columnsReset\"))(\"columns\", ctx_r0.columns)(\"autoSync\", false)(\"allowHideAll\", false)(\"actionsClass\", ctx_r0.actionsClass)(\"isLast\", ctx_r0.isLast)(\"isExpanded\", ctx_r0.expanded)(\"service\", ctx_r0.service);\n  }\n}\n\nfunction ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-container\", 2);\n    i0.ɵɵlistener(\"keydown.shift.tab\", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    })(\"close\", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.close();\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"column\", ctx_r0.service.column)(\"menuTabbingService\", ctx_r0.service.menuTabbingService)(\"filter\", ctx_r0.service.filter)(\"actionsClass\", ctx_r0.actionsClass)(\"isLast\", ctx_r0.isLast)(\"isExpanded\", ctx_r0.expanded);\n  }\n}\n\nconst _c24 = function (a0, a1) {\n  return {\n    service: a0,\n    column: a1\n  };\n};\n\nfunction ColumnMenuComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r3 = i0.ɵɵreference(6);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.column.columnMenuTemplateRef || ctx_r2.columnMenuTemplate || _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c24, ctx_r2.service, ctx_r2.column));\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-sort\", 10, 11);\n  }\n\n  if (rf & 2) {\n    const _r11 = i0.ɵɵreference(1);\n\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r11)(\"service\", ctx_r5.service);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-lock\", 10, 12);\n  }\n\n  if (rf & 2) {\n    const _r12 = i0.ɵɵreference(1);\n\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r12)(\"service\", ctx_r6.service);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-stick\", 10, 13);\n  }\n\n  if (rf & 2) {\n    const _r13 = i0.ɵɵreference(1);\n\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r13)(\"service\", ctx_r7.service);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-position\", 14, 15);\n  }\n\n  if (rf & 2) {\n    const _r14 = i0.ɵɵreference(1);\n\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"showLock\", ctx_r8.hasLock)(\"showStick\", ctx_r8.hasStick)(\"kendoGridColumnMenuItem\", _r14)(\"service\", ctx_r8.service)(\"expanded\", ctx_r8.expandedPosition);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-chooser\", 16, 17);\n  }\n\n  if (rf & 2) {\n    const _r15 = i0.ɵɵreference(1);\n\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r15)(\"service\", ctx_r9.service)(\"expanded\", ctx_r9.expandedColumns);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-columnmenu-filter\", 16, 18);\n  }\n\n  if (rf & 2) {\n    const _r16 = i0.ɵɵreference(1);\n\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoGridColumnMenuItem\", _r16)(\"service\", ctx_r10.service)(\"expanded\", ctx_r10.expandedFilter);\n  }\n}\n\nfunction ColumnMenuComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-container\", 6);\n    i0.ɵɵlistener(\"keydown.escape\", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.close();\n    })(\"keydown.enter\", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵtemplate(1, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template, 2, 2, \"kendo-grid-columnmenu-sort\", 7);\n    i0.ɵɵtemplate(2, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template, 2, 2, \"kendo-grid-columnmenu-lock\", 7);\n    i0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template, 2, 2, \"kendo-grid-columnmenu-stick\", 7);\n    i0.ɵɵtemplate(4, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template, 2, 5, \"kendo-grid-columnmenu-position\", 8);\n    i0.ɵɵtemplate(5, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_5_Template, 2, 3, \"kendo-grid-columnmenu-chooser\", 9);\n    i0.ɵɵtemplate(6, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_6_Template, 2, 3, \"kendo-grid-columnmenu-filter\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasSort);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasLock && !ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasStick && !ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasPosition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasColumnChooser);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.hasFilter);\n  }\n}\n\nconst _c25 = function (a0) {\n  return {\n    \"k-state-active\": a0\n  };\n};\n\nconst _c26 = [\"dropdown\"];\n\nconst _c27 = function () {\n  return {\n    width: \"auto\"\n  };\n};\n\nfunction FilterCellOperatorsComponent_kendo_dropdownlist_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 2, 3);\n    i0.ɵɵlistener(\"valueChange\", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.onChange($event);\n    })(\"keydown\", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.dropdownKeydown($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r0.operators)(\"value\", ctx_r0.value)(\"valuePrimitive\", true)(\"popupSettings\", i0.ɵɵpureFunction0(4, _c27));\n  }\n}\n\nfunction FilterCellOperatorsComponent_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 4);\n    i0.ɵɵlistener(\"click\", function FilterCellOperatorsComponent_button_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.clearClick();\n    })(\"keydown\", function FilterCellOperatorsComponent_button_1_Template_button_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.clearKeydown($event);\n    });\n    i0.ɵɵelement(1, \"span\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r1.clearText);\n  }\n}\n\nconst _c28 = [\"kendoGridFilterCell\", \"\"];\n\nfunction FilterCellComponent_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"column\", ctx_r1.column)(\"filter\", ctx_r1.filter);\n  }\n}\n\nfunction FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template(rf, ctx) {}\n\nfunction FilterCellComponent_ng_container_0_ng_container_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.column.filterCellTemplateRef)(\"ngTemplateOutletContext\", ctx_r3.templateContext);\n  }\n}\n\nfunction FilterCellComponent_ng_container_0_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, FilterCellComponent_ng_container_0_ng_container_3_1_Template, 1, 2, null, 0);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.column.filterCellTemplateRef);\n  }\n}\n\nfunction FilterCellComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0)(1, 1);\n    i0.ɵɵtemplate(2, FilterCellComponent_ng_container_0_ng_container_2_Template, 2, 2, \"ng-container\", 2);\n    i0.ɵɵtemplate(3, FilterCellComponent_ng_container_0_ng_container_3_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵelementContainerEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r0.hasTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n  }\n}\n\nconst _c29 = [\"kendoGridFilterRow\", \"\"];\n\nfunction FilterRowComponent_td_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 3);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-group-cell\", true);\n  }\n}\n\nfunction FilterRowComponent_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 3);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-hierarchy-cell\", true);\n  }\n}\n\nfunction FilterRowComponent_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 4);\n  }\n\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const columnIndex_r5 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-header-sticky\", column_r4.sticky);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.addStickyStyles(column_r4))(\"ngClass\", column_r4.filterClass)(\"column\", column_r4)(\"filter\", ctx_r2.filter)(\"logicalRowIndex\", ctx_r2.logicalRowIndex)(\"logicalColIndex\", ctx_r2.lockedColumnsCount + columnIndex_r5);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.filterLabel(column_r4));\n  }\n}\n\nconst _c30 = [\"kendoGridHeader\", \"\"];\n\nfunction HeaderComponent_tr_1_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"th\", 6);\n  }\n}\n\nfunction HeaderComponent_tr_1_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"th\", 7);\n  }\n\n  if (rf & 2) {\n    const levelIndex_r3 = i0.ɵɵnextContext().index;\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalColIndex\", 0);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-filter-menu\", 16);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r18.getColumnComponent(column_r9))(\"filter\", ctx_r18.filter)(\"tabIndex\", ctx_r18.tabIndex);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 17);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r19.columnMenuSettings)(\"column\", column_r9)(\"columnMenuTemplate\", ctx_r19.columnMenuTemplate)(\"sort\", ctx_r19.sort)(\"filter\", ctx_r19.filter)(\"sortable\", ctx_r19.sortable)(\"tabIndex\", ctx_r19.tabIndex);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template(rf, ctx) {}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(column_r9.displayTitle);\n  }\n}\n\nconst _c31 = function (a0, a1, a2, a3) {\n  return {\n    templateRef: a0,\n    columnIndex: a1,\n    column: a2,\n    $implicit: a3\n  };\n};\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_1_Template, 1, 3, \"kendo-grid-filter-menu\", 13);\n    i0.ɵɵtemplate(2, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_2_Template, 1, 8, \"kendo-grid-column-menu\", 14);\n    i0.ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(4, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template, 2, 1, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.showFilterMenu && ctx_r14.isFilterable(ctx_r14.getColumnComponent(column_r9)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.showColumnMenu(column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(4, _c31, column_r9.headerTemplateRef, column_r9.leafIndex, column_r9, column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r9.headerTemplateRef);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template(rf, ctx) {}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 24);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(column_r9.displayTitle);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 25);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r29.sortOrder(ctx_r29.getColumnComponent(column_r9).field));\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-filter-menu\", 16);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r30 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r30.getColumnComponent(column_r9))(\"filter\", ctx_r30.filter)(\"tabIndex\", ctx_r30.tabIndex);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 17);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r31.columnMenuSettings)(\"column\", column_r9)(\"columnMenuTemplate\", ctx_r31.columnMenuTemplate)(\"sort\", ctx_r31.sort)(\"filter\", ctx_r31.filter)(\"sortable\", ctx_r31.sortable)(\"tabIndex\", ctx_r31.tabIndex);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r38 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 18)(2, \"span\", 19, 20);\n    i0.ɵɵlistener(\"click\", function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r38);\n\n      const _r26 = i0.ɵɵreference(3);\n\n      const column_r9 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r36 = i0.ɵɵnextContext(2);\n      return ctx_r36.onSortClick(ctx_r36.getColumnComponent(column_r9), $event, _r26);\n    });\n    i0.ɵɵtemplate(4, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(5, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template, 3, 1, \"ng-container\", 11);\n    i0.ɵɵelement(6, \"span\", 21);\n    i0.ɵɵtemplate(7, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_span_7_Template, 2, 1, \"span\", 22);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(8, \"span\", 23);\n    i0.ɵɵtemplate(9, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template, 1, 3, \"kendo-grid-filter-menu\", 13);\n    i0.ɵɵtemplate(10, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template, 1, 8, \"kendo-grid-column-menu\", 14);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(8, _c31, column_r9.headerTemplateRef, column_r9.leafIndex, column_r9, column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r9.headerTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r15.sortIcon(ctx_r15.getColumnComponent(column_r9).field));\n    i0.ɵɵattribute(\"aria-label\", ctx_r15.sortableLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.showSortNumbering(ctx_r15.getColumnComponent(column_r9)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"innerHtml\", ctx_r15.sortStatus(ctx_r15.getColumnComponent(column_r9)), i0.ɵɵsanitizeHtml);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.showFilterMenu && ctx_r15.isFilterable(ctx_r15.getColumnComponent(column_r9)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.showColumnMenu(column_r9));\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"input\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"id\", ctx_r16.selectAllCheckboxId())(\"aria-label\", ctx_r16.selectAllCheckboxLabel);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 27);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", column_r9)(\"columns\", ctx_r17.columns);\n  }\n}\n\nconst _c32 = function (a0, a2, a3, a4) {\n  return {\n    field: a0,\n    type: \"column\",\n    column: a2,\n    hint: a3,\n    lastColumn: a4\n  };\n};\n\nfunction HeaderComponent_tr_1_ng_container_3_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r43 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"th\", 10);\n    i0.ɵɵlistener(\"keydown\", function HeaderComponent_tr_1_ng_container_3_th_1_Template_th_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r43);\n      const column_r9 = i0.ɵɵnextContext().$implicit;\n      const ctx_r41 = i0.ɵɵnextContext(2);\n      return ctx_r41.onHeaderKeydown(ctx_r41.getColumnComponent(column_r9), $event);\n    });\n    i0.ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_Template, 5, 9, \"ng-container\", 11);\n    i0.ɵɵtemplate(2, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template, 11, 13, \"ng-container\", 11);\n    i0.ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_3_Template, 2, 2, \"ng-container\", 11);\n    i0.ɵɵtemplate(4, HeaderComponent_tr_1_ng_container_3_th_1_span_4_Template, 1, 2, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r44 = i0.ɵɵnextContext();\n    const column_r9 = ctx_r44.$implicit;\n    const columnIndex_r10 = ctx_r44.index;\n    const last_r11 = ctx_r44.last;\n    const levelIndex_r3 = i0.ɵɵnextContext().index;\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-filterable\", ctx_r12.showFilterMenu && ctx_r12.isFilterable(ctx_r12.getColumnComponent(column_r9)) || ctx_r12.showColumnMenu(column_r9))(\"k-first\", ctx_r12.isFirstOnRow(ctx_r12.getColumnComponent(column_r9), columnIndex_r10))(\"k-grid-header-sticky\", column_r9.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalColIndex\", ctx_r12.logicalColumnIndex(column_r9))(\"headerLabelText\", column_r9.title || ctx_r12.getColumnComponent(column_r9).field)(\"colSpan\", column_r9.colspan)(\"rowSpan\", column_r9.rowspan(ctx_r12.totalColumnLevels))(\"enableDrag\", ctx_r12.shouldActivate(column_r9))(\"context\", i0.ɵɵpureFunction4(22, _c32, ctx_r12.getColumnComponent(column_r9).field, column_r9, column_r9.title || ctx_r12.getColumnComponent(column_r9).field, last_r11 && columnIndex_r10 === 0))(\"ngClass\", column_r9.headerClass)(\"ngStyle\", column_r9.sticky ? ctx_r12.addStickyStyles(column_r9) : column_r9.headerStyle);\n    i0.ɵɵattribute(\"aria-sort\", ctx_r12.sortState(ctx_r12.getColumnComponent(column_r9)))(\"rowspan\", column_r9.rowspan(ctx_r12.totalColumnLevels))(\"colspan\", column_r9.colspan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.isSortable(ctx_r12.getColumnComponent(column_r9)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.isSortable(ctx_r12.getColumnComponent(column_r9)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.isCheckboxColumn(column_r9) && !column_r9.headerTemplateRef && column_r9.showSelectAll);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.resizable);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_2_kendo_grid_column_menu_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-column-menu\", 30);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r46 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"standalone\", false)(\"settings\", ctx_r46.columnMenuSettings)(\"column\", column_r9)(\"columnMenuTemplate\", ctx_r46.columnMenuTemplate);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_2_ng_template_2_Template(rf, ctx) {}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(column_r9.displayTitle);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_th_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 27);\n  }\n\n  if (rf & 2) {\n    const column_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", column_r9)(\"columns\", ctx_r49.columns);\n  }\n}\n\nconst _c33 = function (a1, a2, a3) {\n  return {\n    type: \"columnGroup\",\n    column: a1,\n    hint: a2,\n    lastColumn: a3\n  };\n};\n\nfunction HeaderComponent_tr_1_ng_container_3_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 28);\n    i0.ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_2_kendo_grid_column_menu_1_Template, 1, 4, \"kendo-grid-column-menu\", 29);\n    i0.ɵɵtemplate(2, HeaderComponent_tr_1_ng_container_3_th_2_ng_template_2_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_th_2_ng_container_3_Template, 2, 1, \"ng-container\", 11);\n    i0.ɵɵtemplate(4, HeaderComponent_tr_1_ng_container_3_th_2_span_4_Template, 1, 2, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r53 = i0.ɵɵnextContext();\n    const column_r9 = ctx_r53.$implicit;\n    const columnIndex_r10 = ctx_r53.index;\n    const last_r11 = ctx_r53.last;\n    const levelIndex_r3 = i0.ɵɵnextContext().index;\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-first\", ctx_r13.isFirstOnRow(ctx_r13.getColumnComponent(column_r9), columnIndex_r10))(\"k-filterable\", ctx_r13.showColumnMenu(column_r9))(\"k-grid-content-sticky\", column_r9.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalColIndex\", ctx_r13.logicalColumnIndex(column_r9))(\"rowSpan\", column_r9.rowspan(ctx_r13.totalColumnLevels))(\"colSpan\", column_r9.colspan)(\"headerLabelText\", column_r9.title || ctx_r13.getColumnComponent(column_r9).field)(\"enableDrag\", ctx_r13.shouldActivate(column_r9))(\"context\", i0.ɵɵpureFunction3(21, _c33, column_r9, column_r9.title, last_r11 && columnIndex_r10 === 0))(\"ngClass\", column_r9.headerClass)(\"ngStyle\", column_r9.headerStyle);\n    i0.ɵɵattribute(\"rowspan\", column_r9.rowspan(ctx_r13.totalColumnLevels))(\"colspan\", column_r9.colspan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.showColumnMenu(column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(25, _c31, column_r9.headerTemplateRef, ctx_r13.lockedColumnsCount + columnIndex_r10, column_r9, column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r9.headerTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.resizable);\n  }\n}\n\nfunction HeaderComponent_tr_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_1_Template, 5, 27, \"th\", 8);\n    i0.ɵɵtemplate(2, HeaderComponent_tr_1_ng_container_3_th_2_Template, 5, 30, \"th\", 9);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r9 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.isColumnGroupComponent(column_r9));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.isColumnGroupComponent(column_r9));\n  }\n}\n\nfunction HeaderComponent_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 2);\n    i0.ɵɵtemplate(1, HeaderComponent_tr_1_th_1_Template, 1, 0, \"th\", 3);\n    i0.ɵɵtemplate(2, HeaderComponent_tr_1_th_2_Template, 1, 2, \"th\", 4);\n    i0.ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_Template, 3, 2, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const levelIndex_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", levelIndex_r3)(\"logicalSlaveRow\", ctx_r0.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r0.columns.length)(\"logicalSlaveCellsCount\", ctx_r0.unlockedColumnsCount);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.groups);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.columnsForLevel(levelIndex_r3))(\"ngForTrackBy\", ctx_r0.trackByIndex);\n  }\n}\n\nfunction HeaderComponent_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tr\", 31);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"columns\", ctx_r1.leafColumns)(\"filter\", ctx_r1.filter)(\"groups\", ctx_r1.groups)(\"detailTemplate\", ctx_r1.detailTemplate)(\"lockedColumnsCount\", ctx_r1.lockedColumnsCount)(\"logicalRowIndex\", ctx_r1.totalColumnLevels + 1)(\"logicalSlaveRow\", ctx_r1.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r1.columns.length)(\"logicalSlaveCellsCount\", ctx_r1.unlockedColumnsCount);\n  }\n}\n\nconst _c34 = [\"kendoGridCell\", \"\"];\n\nfunction CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template(rf, ctx) {}\n\nfunction CellComponent_ng_container_1_ng_container_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.column.templateRef)(\"ngTemplateOutletContext\", ctx_r5.templateContext);\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const childColumn_r11 = ctx.$implicit;\n    const ctx_r10 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(2, 1, ctx_r10.dataItem, childColumn_r11.field, childColumn_r11.format), \" \");\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_container_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template, 3, 5, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6.childColumns);\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_container_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind3(2, 1, ctx_r7.dataItem, ctx_r7.column.field, ctx_r7.column.format));\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"input\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridSelectionCheckbox\", ctx_r8.rowIndex);\n    i0.ɵɵattribute(\"id\", ctx_r8.selectionCheckboxId)(\"aria-label\", ctx_r8.selectionCheckboxLabel);\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_1_Template, 1, 2, null, 4);\n    i0.ɵɵtemplate(2, CellComponent_ng_container_1_ng_container_1_ng_container_2_Template, 2, 1, \"ng-container\", 4);\n    i0.ɵɵtemplate(3, CellComponent_ng_container_1_ng_container_1_ng_container_3_Template, 3, 5, \"ng-container\", 4);\n    i0.ɵɵtemplate(4, CellComponent_ng_container_1_ng_container_1_ng_container_4_Template, 2, 3, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.column.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isSpanColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isBoundColumn);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isCheckboxColumn && !ctx_r2.isNew);\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template(rf, ctx) {}\n\nconst _c35 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction CellComponent_ng_container_1_ng_template_2_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r12.loadingTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c35, ctx_r12.column));\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_template_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 9);\n  }\n}\n\nfunction CellComponent_ng_container_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_Template, 1, 4, null, 4);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_template_2_div_1_Template, 1, 0, \"div\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.loadingTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.loadingTemplate);\n  }\n}\n\nfunction CellComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_Template, 5, 4, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, CellComponent_ng_container_1_ng_template_2_Template, 2, 2, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const _r3 = i0.ɵɵreference(3);\n\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.showLoading)(\"ngIfElse\", _r3);\n  }\n}\n\nfunction CellComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) {}\n\nfunction CellComponent_ng_container_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CellComponent_ng_container_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r15.column.editTemplateRef)(\"ngTemplateOutletContext\", ctx_r15.editTemplateContext);\n  }\n}\n\nfunction CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-numerictextbox\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"format\", ctx_r18.format)(\"formControl\", ctx_r18.formGroup.get(ctx_r18.column.field));\n  }\n}\n\nfunction CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-datepicker\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"format\", ctx_r19.format)(\"formControl\", ctx_r19.formGroup.get(ctx_r19.column.field));\n  }\n}\n\nfunction CellComponent_ng_container_2_ng_container_2_input_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"input\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"formControl\", ctx_r20.formGroup.get(ctx_r20.column.field));\n  }\n}\n\nfunction CellComponent_ng_container_2_ng_container_2_input_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"input\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"formControl\", ctx_r21.formGroup.get(ctx_r21.column.field));\n  }\n}\n\nfunction CellComponent_ng_container_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0, 0);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, \"kendo-numerictextbox\", 11);\n    i0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, \"kendo-datepicker\", 11);\n    i0.ɵɵtemplate(3, CellComponent_ng_container_2_ng_container_2_input_3_Template, 1, 1, \"input\", 12);\n    i0.ɵɵtemplate(4, CellComponent_ng_container_2_ng_container_2_input_4_Template, 1, 1, \"input\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r16.column.editor);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"numeric\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"boolean\");\n  }\n}\n\nfunction CellComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CellComponent_ng_container_2_1_Template, 1, 2, null, 4);\n    i0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_Template, 5, 4, \"ng-container\", 10);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.column.editTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.column.editTemplateRef);\n  }\n}\n\nconst _c36 = [\"kendoGridGroupHeader\", \"\"];\n\nfunction GroupHeaderComponent_ng_container_0_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 3);\n  }\n}\n\nfunction GroupHeaderComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, GroupHeaderComponent_ng_container_0_td_1_Template, 1, 0, \"td\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.prefixGroupCell(ctx_r0.item));\n  }\n}\n\nfunction GroupHeaderComponent_td_1_ng_container_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"valueOf\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate2(\" \", ctx_r6.groupTitle(ctx_r6.item), \": \", i0.ɵɵpipeBind3(2, 2, ctx_r6.item.data, \"value\", ctx_r6.formatForGroup(ctx_r6.item)), \" \");\n  }\n}\n\nfunction GroupHeaderComponent_td_1_ng_container_2_ng_template_3_Template(rf, ctx) {}\n\nconst _c37 = function (a0, a1) {\n  return {\n    \"k-i-collapse\": a0,\n    \"k-i-expand\": a1\n  };\n};\n\nconst _c38 = function (a0, a1, a2, a3, a4, a5, a6, a7) {\n  return {\n    templateRef: a0,\n    group: a1,\n    aggregates: a2,\n    value: a3,\n    field: a4,\n    index: a5,\n    expanded: a6,\n    $implicit: a7\n  };\n};\n\nfunction GroupHeaderComponent_td_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"a\", 6);\n    i0.ɵɵlistener(\"click\", function GroupHeaderComponent_td_1_ng_container_2_Template_a_click_1_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return ctx_r8.toggleGroup(ctx_r8.item);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_container_2_ng_container_2_Template, 3, 6, \"ng-container\", 0);\n    i0.ɵɵtemplate(3, GroupHeaderComponent_td_1_ng_container_2_ng_template_3_Template, 0, 0, \"ng-template\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(5, _c37, ctx_r5.isExpanded, !ctx_r5.isExpanded));\n    i0.ɵɵattribute(\"title\", ctx_r5.groupButtonTitle)(\"aria-label\", ctx_r5.groupButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.groupHeaderTemplate(ctx_r5.item));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction8(8, _c38, ctx_r5.groupHeaderTemplate(ctx_r5.item), ctx_r5.item.data, ctx_r5.item.data == null ? null : ctx_r5.item.data.aggregates, ctx_r5.item.data == null ? null : ctx_r5.item.data.value, ctx_r5.item.data == null ? null : ctx_r5.item.data.field, ctx_r5.item.index, ctx_r5.isExpanded, ctx_r5.item.data));\n  }\n}\n\nfunction GroupHeaderComponent_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 4)(1, \"p\", 5);\n    i0.ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_container_2_Template, 4, 17, \"ng-container\", 0);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r1.logicalRowIndex)(\"logicalColIndex\", 0)(\"logicalSlaveCell\", ctx_r1.skipGroupDecoration)(\"groupItem\", ctx_r1.item)(\"colSpan\", ctx_r1.logicalColSpan());\n    i0.ɵɵattribute(\"colspan\", ctx_r1.groupSpan(ctx_r1.item))(\"role\", ctx_r1.ariaRole())(\"aria-expanded\", ctx_r1.isExpanded);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.skipGroupDecoration);\n  }\n}\n\nfunction GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c39 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    group: a0,\n    aggregates: a1,\n    value: a2,\n    field: a3,\n    index: a4,\n    $implicit: a5\n  };\n};\n\nfunction GroupHeaderComponent_ng_container_2_td_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const column_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", column_r11.groupHeaderColumnTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction6(2, _c39, ctx_r13.item.data, ctx_r13.item.data == null ? null : ctx_r13.item.data.aggregates, ctx_r13.item.data == null ? null : ctx_r13.item.data.value, ctx_r13.item.data == null ? null : ctx_r13.item.data.field, ctx_r13.item.index, ctx_r13.item.data));\n  }\n}\n\nfunction GroupHeaderComponent_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 9);\n    i0.ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_1_Template, 1, 9, null, 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r11 = ctx.$implicit;\n    const index_r12 = ctx.index;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r10.logicalRowIndex)(\"logicalColIndex\", index_r12 + 1)(\"logicalSlaveCell\", false)(\"groupItem\", ctx_r10.item)(\"colSpan\", 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r11.groupHeaderColumnTemplateRef);\n  }\n}\n\nfunction GroupHeaderComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_Template, 2, 6, \"td\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.groupHeaderColumns);\n  }\n}\n\nconst _c40 = [\"kendoGridTableBody\", \"\"];\n\nfunction TableBodyComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 8);\n  }\n}\n\nfunction TableBodyComponent_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, \"td\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.groups);\n  }\n}\n\nfunction TableBodyComponent_ng_container_0_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r5.addRowLogicalIndex())(\"logicalColIndex\", 0);\n  }\n}\n\nfunction TableBodyComponent_ng_container_0_td_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 10);\n  }\n\n  if (rf & 2) {\n    const column_r9 = ctx.$implicit;\n    const columnIndex_r10 = ctx.index;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"left\", column_r9.sticky ? \"0\" : undefined);\n    i0.ɵɵclassProp(\"k-grid-content-sticky\", column_r9.sticky);\n    i0.ɵɵproperty(\"rowIndex\", -1)(\"columnIndex\", ctx_r6.lockedColumnsCount + columnIndex_r10)(\"isNew\", true)(\"column\", column_r9)(\"dataItem\", ctx_r6.newDataItem)(\"ngClass\", column_r9.cssClass)(\"ngStyle\", column_r9.sticky ? ctx_r6.addStickyColumnStyles(column_r9) : column_r9.style)(\"logicalRowIndex\", ctx_r6.addRowLogicalIndex())(\"logicalColIndex\", ctx_r6.logicalColIndex(column_r9))(\"colSpan\", column_r9.colspan);\n    i0.ɵɵattribute(\"colspan\", column_r9.colspan);\n  }\n}\n\nfunction TableBodyComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"tr\", 4);\n    i0.ɵɵtemplate(2, TableBodyComponent_ng_container_0_ng_container_2_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(3, TableBodyComponent_ng_container_0_td_3_Template, 1, 2, \"td\", 5);\n    i0.ɵɵtemplate(4, TableBodyComponent_ng_container_0_td_4_Template, 1, 15, \"td\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r0.addRowLogicalIndex())(\"logicalSlaveRow\", ctx_r0.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r0.columns.length)(\"logicalSlaveCellsCount\", ctx_r0.unlockedColumnsCount);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.columns)(\"ngForTrackBy\", ctx_r0.trackByColumns);\n  }\n}\n\nfunction TableBodyComponent_tr_1_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c41 = function (a0) {\n  return {\n    templateRef: a0\n  };\n};\n\nfunction TableBodyComponent_tr_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TableBodyComponent_tr_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c41, ctx_r11.noRecordsTemplate == null ? null : ctx_r11.noRecordsTemplate.templateRef));\n  }\n}\n\nfunction TableBodyComponent_tr_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r12.noRecordsText, \" \");\n  }\n}\n\nfunction TableBodyComponent_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 11)(1, \"td\");\n    i0.ɵɵtemplate(2, TableBodyComponent_tr_1_2_Template, 1, 3, null, 0);\n    i0.ɵɵtemplate(3, TableBodyComponent_tr_1_ng_container_3_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"colspan\", ctx_r1.colSpan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r1.noRecordsTemplate == null ? null : ctx_r1.noRecordsTemplate.templateRef));\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tr\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r20.$implicit;\n    const rowIndex_r15 = ctx_r20.index;\n    const ctx_r16 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"columns\", ctx_r16.columns)(\"groups\", ctx_r16.groups)(\"item\", item_r14)(\"hasDetails\", !!(ctx_r16.detailTemplate == null ? null : ctx_r16.detailTemplate.templateRef))(\"skipGroupDecoration\", ctx_r16.skipGroupDecoration)(\"hasGroupHeaderColumn\", ctx_r16.hasGroupHeaderColumn)(\"groupHeaderColumns\", ctx_r16.groupHeaderColumns)(\"rowIndex\", rowIndex_r15 + 1)(\"totalColumnsCount\", ctx_r16.totalColumnsCount)(\"logicalRowIndex\", ctx_r16.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r16.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r16.columns.length)(\"logicalSlaveCellsCount\", ctx_r16.groupHeaderSlaveCellsCount);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 8);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template, 1, 0, \"td\", 7);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r21.groups);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"a\", 23);\n    i0.ɵɵlistener(\"click\", function TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const item_r14 = i0.ɵɵnextContext(3).$implicit;\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.toggleRow(item_r14.index, item_r14.data);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r14 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r26 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r26.detailButtonStyles(item_r14));\n    i0.ɵɵattribute(\"title\", ctx_r26.detailButtonTitle(item_r14))(\"aria-label\", ctx_r26.detailButtonTitle(item_r14));\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_2_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 21);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template, 1, 3, \"a\", 22);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    const rowIndex_r15 = ctx_r31.index;\n    const item_r14 = ctx_r31.$implicit;\n    const ctx_r22 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r22.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", 0)(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"detailExpandCell\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.detailTemplate.showIf(item_r14.data, item_r14.index));\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_2_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 24);\n  }\n\n  if (rf & 2) {\n    const column_r32 = ctx.$implicit;\n    const columnIndex_r33 = ctx.index;\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    const item_r14 = ctx_r34.$implicit;\n    const rowIndex_r15 = ctx_r34.index;\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-content-sticky\", column_r32.sticky)(\"k-touch-action-none\", ctx_r23.isSelectable() && ctx_r23.selectable.drag)(\"k-touch-action-auto\", !(ctx_r23.isSelectable() && ctx_r23.selectable.drag))(\"k-grid-edit-cell\", ctx_r23.isEditingCell(item_r14.index, column_r32))(\"k-state-selected\", ctx_r23.isSelectable && ctx_r23.cellSelectionService.isCellSelected(item_r14, column_r32));\n    i0.ɵɵproperty(\"rowIndex\", item_r14.index)(\"columnIndex\", ctx_r23.lockedColumnsCount + columnIndex_r33)(\"column\", column_r32)(\"dataItem\", item_r14.data)(\"isLoading\", ctx_r23.isLoading)(\"isVirtual\", ctx_r23.isVirtual)(\"loadingTemplate\", ctx_r23.cellLoadingTemplate)(\"logicalRowIndex\", ctx_r23.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", ctx_r23.logicalColIndex(column_r32))(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"colIndex\", columnIndex_r33)(\"colSpan\", column_r32.colspan)(\"ngClass\", column_r32.cssClass)(\"ngStyle\", column_r32.sticky ? ctx_r23.addStickyColumnStyles(column_r32) : column_r32.style);\n    i0.ɵɵattribute(\"data-kendo-grid-column-index\", ctx_r23.lockedColumnsCount + columnIndex_r33)(\"aria-selected\", ctx_r23.isSelectable() ? ctx_r23.isAriaSelected(item_r14, column_r32) : undefined)(\"colspan\", column_r32.colspan);\n  }\n}\n\nconst _c42 = function (a0, a1) {\n  return {\n    dataItem: a0,\n    index: a1\n  };\n};\n\nfunction TableBodyComponent_ng_container_2_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 18);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(2, TableBodyComponent_ng_container_2_tr_2_td_2_Template, 2, 6, \"td\", 19);\n    i0.ɵɵtemplate(3, TableBodyComponent_ng_container_2_tr_2_td_3_Template, 1, 28, \"td\", 20);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r35 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r35.$implicit;\n    const rowIndex_r15 = ctx_r35.index;\n    const ctx_r17 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-row-sticky\", ctx_r17.rowSticky ? ctx_r17.rowSticky(i0.ɵɵpureFunction2(22, _c42, item_r14.data, item_r14.index)) : false)(\"k-alt\", ctx_r17.isOdd(item_r14))(\"k-master-row\", ctx_r17.detailTemplate == null ? null : ctx_r17.detailTemplate.templateRef)(\"k-grid-edit-row\", ctx_r17.isEditingRow(item_r14.index))(\"k-state-selected\", ctx_r17.isSelectable() && ctx_r17.isRowSelected(item_r14));\n    i0.ɵɵproperty(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"logicalRowIndex\", ctx_r17.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r17.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r17.columns.length)(\"logicalSlaveCellsCount\", ctx_r17.unlockedColumnsCount)(\"ngClass\", ctx_r17.rowClass(i0.ɵɵpureFunction2(25, _c42, item_r14.data, item_r14.index)));\n    i0.ɵɵattribute(\"data-kendo-grid-item-index\", item_r14.index);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r17.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r17.detailTemplate == null ? null : ctx_r17.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r17.columns)(\"ngForTrackBy\", ctx_r17.trackByColumns);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_3_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 30);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template(rf, ctx) {}\n\nconst _c43 = function (a0, a1, a2) {\n  return {\n    dataItem: a0,\n    rowIndex: a1,\n    $implicit: a2\n  };\n};\n\nfunction TableBodyComponent_ng_container_2_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 25);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_3_td_1_Template, 1, 0, \"td\", 26);\n    i0.ɵɵelement(2, \"td\", 27);\n    i0.ɵɵelementStart(3, \"td\", 28);\n    i0.ɵɵtemplate(4, TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template, 0, 0, \"ng-template\", 29);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r39 = i0.ɵɵnextContext();\n    const item_r14 = ctx_r39.$implicit;\n    const rowIndex_r15 = ctx_r39.index;\n    const ctx_r18 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-alt\", ctx_r18.isOdd(item_r14));\n    i0.ɵɵproperty(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"logicalRowIndex\", ctx_r18.logicalRowIndex(rowIndex_r15) + 1)(\"logicalSlaveRow\", false)(\"logicalCellsCount\", 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r18.groups);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r18.logicalRowIndex(rowIndex_r15) + 1)(\"logicalColIndex\", 0)(\"dataRowIndex\", item_r14.index)(\"dataItem\", item_r14.data)(\"colIndex\", 0)(\"colSpan\", ctx_r18.allColumnsSpan + 1);\n    i0.ɵɵattribute(\"colspan\", ctx_r18.columnsSpan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.detailTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(17, _c43, item_r14.data, item_r14.index, item_r14.data));\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 30);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template, 1, 0, \"td\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r40 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r40.groups);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_4_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 9);\n  }\n\n  if (rf & 2) {\n    const rowIndex_r15 = i0.ɵɵnextContext(2).index;\n    const ctx_r41 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r41.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", 0);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template(rf, ctx) {}\n\nconst _c44 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    templateRef: a0,\n    group: a1,\n    field: a2,\n    column: a3,\n    aggregates: a4,\n    $implicit: a5\n  };\n};\n\nfunction TableBodyComponent_ng_container_2_tr_4_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 33);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template, 0, 0, \"ng-template\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r46 = ctx.$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    const rowIndex_r15 = ctx_r49.index;\n    const item_r14 = ctx_r49.$implicit;\n    const ctx_r42 = i0.ɵɵnextContext();\n    let tmp_3_0;\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r42.logicalRowIndex(rowIndex_r15))(\"logicalColIndex\", ctx_r42.logicalColIndex(column_r46));\n    i0.ɵɵattribute(\"data-skip\", ctx_r42.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction6(4, _c44, column_r46.groupFooterTemplateRef, item_r14.data, column_r46.field, column_r46, (tmp_3_0 = item_r14.data) == null ? null : tmp_3_0.aggregates, (tmp_3_0 = item_r14.data) == null ? null : tmp_3_0.aggregates));\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_tr_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 31);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵtemplate(2, TableBodyComponent_ng_container_2_tr_4_td_2_Template, 1, 2, \"td\", 5);\n    i0.ɵɵtemplate(3, TableBodyComponent_ng_container_2_tr_4_td_3_Template, 2, 11, \"td\", 32);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const rowIndex_r15 = i0.ɵɵnextContext().index;\n    const ctx_r19 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r19.logicalRowIndex(rowIndex_r15))(\"logicalSlaveRow\", ctx_r19.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx_r19.columns.length)(\"logicalSlaveCellsCount\", ctx_r19.unlockedColumnsCount);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r19.skipGroupDecoration);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r19.detailTemplate == null ? null : ctx_r19.detailTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r19.footerColumns)(\"ngForTrackBy\", ctx_r19.trackByColumns);\n  }\n}\n\nfunction TableBodyComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_1_Template, 1, 13, \"tr\", 13);\n    i0.ɵɵtemplate(2, TableBodyComponent_ng_container_2_tr_2_Template, 4, 28, \"tr\", 14);\n    i0.ɵɵtemplate(3, TableBodyComponent_ng_container_2_tr_3_Template, 5, 21, \"tr\", 15);\n    i0.ɵɵtemplate(4, TableBodyComponent_ng_container_2_tr_4_Template, 4, 8, \"tr\", 16);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r14 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isGroup(item_r14) && ctx_r2.isParentGroupExpanded(item_r14) && ctx_r2.showGroupHeader(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isDataItem(item_r14) && (!item_r14.group || ctx_r2.isDataItemInExpandedGroup(item_r14)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isDataItem(item_r14) && (!item_r14.group || ctx_r2.isDataItemInExpandedGroup(item_r14)) && (ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef) && ctx_r2.detailTemplate.showIf(item_r14.data, item_r14.index) && ctx_r2.isExpanded(item_r14));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isFooter(item_r14) && item_r14.group && (ctx_r2.isFooterItemInExpandedGroup(item_r14) || ctx_r2.showGroupFooters && ctx_r2.isParentGroupExpanded(item_r14.group)) && !item_r14.data.hideFooter);\n  }\n}\n\nfunction TableBodyComponent_kendo_resize_sensor_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r52 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 34);\n    i0.ɵɵlistener(\"resize\", function TableBodyComponent_kendo_resize_sensor_3_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r52);\n      const ctx_r51 = i0.ɵɵnextContext();\n      return ctx_r51.resizeHandler();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c45 = [\"container\"];\nconst _c46 = [\"lockedContainer\"];\nconst _c47 = [\"lockedTable\"];\nconst _c48 = [\"table\"];\n\nconst _c49 = function (a0, a1, a2, a3) {\n  return {\n    keydown: a0,\n    scroll: a1,\n    mousewheel: a2,\n    DOMMouseScroll: a3\n  };\n};\n\nfunction ListComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11, 12)(2, \"div\", 3)(3, \"table\", 13, 14);\n    i0.ɵɵelement(5, \"colgroup\", 6)(6, \"tbody\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(7, \"kendo-resize-sensor\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"div\", 9);\n    i0.ɵɵelement(9, \"div\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction4(28, _c49, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))(\"scope\", ctx_r0);\n    i0.ɵɵadvance(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r0.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"groups\", ctx_r0.groups)(\"columns\", ctx_r0.lockedLeafColumns)(\"detailTemplate\", ctx_r0.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"groups\", ctx_r0.groups)(\"isLocked\", true)(\"data\", ctx_r0.data)(\"noRecordsText\", \"\")(\"columns\", ctx_r0.lockedLeafColumns)(\"totalColumnsCount\", ctx_r0.leafColumns.length)(\"detailTemplate\", ctx_r0.detailTemplate)(\"showGroupFooters\", ctx_r0.showFooter)(\"skip\", ctx_r0.skip)(\"selectable\", ctx_r0.selectable)(\"trackBy\", ctx_r0.trackBy)(\"filterable\", ctx_r0.filterable)(\"rowClass\", ctx_r0.rowClass)(\"isLoading\", ctx_r0.loading)(\"isVirtual\", ctx_r0.isVirtual)(\"cellLoadingTemplate\", ctx_r0.cellLoadingTemplate);\n    i0.ɵɵadvance(3);\n    i0.ɵɵstyleProp(\"height\", ctx_r0.totalHeight, \"px\");\n  }\n}\n\nfunction ListComponent_kendo_resize_sensor_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\");\n  }\n}\n\nfunction ListComponent_kendo_resize_sensor_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\");\n  }\n}\n\nfunction ListComponent_div_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r5.totalWidth, \"px\");\n  }\n}\n\nconst _c50 = function () {\n  return [];\n};\n\nconst _c51 = [\"kendoGridFooter\", \"\"];\n\nfunction FooterComponent_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 4);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-group-cell\", true);\n  }\n}\n\nfunction FooterComponent_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"td\", 4);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵclassProp(\"k-hierarchy-cell\", true);\n  }\n}\n\nfunction FooterComponent_td_4_ng_template_1_Template(rf, ctx) {}\n\nfunction FooterComponent_td_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 5);\n    i0.ɵɵtemplate(1, FooterComponent_td_4_ng_template_1_Template, 0, 0, \"ng-template\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const columnIndex_r5 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-grid-footer-sticky\", column_r4.sticky);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r2.logicalRowIndex)(\"logicalColIndex\", ctx_r2.logicalColumnIndex(column_r4))(\"ngClass\", column_r4.footerClass)(\"ngStyle\", column_r4.sticky ? ctx_r2.addStickyStyles(column_r4) : column_r4.footerStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(7, _c31, column_r4.footerTemplateRef, ctx_r2.lockedColumnsCount + columnIndex_r5, column_r4, column_r4));\n  }\n}\n\nconst _c52 = [\"kendoGridLoading\", \"\"];\n\nfunction LoadingComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 1);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(3, \"div\", 2)(4, \"div\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.loadingText);\n  }\n}\n\nfunction LoadingComponent_1_ng_template_0_Template(rf, ctx) {}\n\nfunction LoadingComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, LoadingComponent_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.loadingTemplate == null ? null : ctx_r1.loadingTemplate.templateRef);\n  }\n}\n\nconst _c53 = [\"lockedHeader\"];\nconst _c54 = [\"header\"];\nconst _c55 = [\"ariaRoot\"];\nconst _c56 = [\"footer\"];\n\nfunction GridComponent_kendo_grid_toolbar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-toolbar\", 11);\n  }\n}\n\nfunction GridComponent_kendo_pager_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-pager\", 12);\n    i0.ɵɵlistener(\"pageChange\", function GridComponent_kendo_pager_3_Template_kendo_pager_pageChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.notifyPageChange(\"pager\", $event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.navigation.pagerEnabled ? \"0\" : \"-1\")(\"template\", ctx_r1.pagerTemplate)(\"pageSize\", ctx_r1.pageSize)(\"total\", ctx_r1.view.total)(\"skip\", ctx_r1.skip)(\"options\", ctx_r1.pageable);\n    i0.ɵɵattribute(\"role\", ctx_r1.navigation.pagerEnabled ? \"application\" : undefined);\n  }\n}\n\nfunction GridComponent_kendo_grid_group_panel_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-grid-group-panel\", 13);\n    i0.ɵɵlistener(\"change\", function GridComponent_kendo_grid_group_panel_4_Template_kendo_grid_group_panel_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.groupChange.emit($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"text\", ctx_r2.groupableEmptyText)(\"groups\", ctx_r2.group);\n  }\n}\n\nfunction GridComponent_ng_container_7_div_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25, 26)(2, \"table\", 27);\n    i0.ɵɵelement(3, \"colgroup\", 22)(4, \"thead\", 28);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r15.lockedWidth, \"px\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r15.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r15.lockedLeafColumns)(\"groups\", ctx_r15.group)(\"detailTemplate\", ctx_r15.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"resizable\", ctx_r15.resizable)(\"scrollable\", true)(\"columns\", ctx_r15.lockedColumns)(\"totalColumnLevels\", ctx_r15.totalColumnLevels)(\"sort\", ctx_r15.sort)(\"groups\", ctx_r15.group)(\"filter\", ctx_r15.filter)(\"filterable\", ctx_r15.filterable)(\"groupable\", ctx_r15.showGroupPanel)(\"reorderable\", ctx_r15.reorderable)(\"sortable\", ctx_r15.sortable)(\"columnMenu\", ctx_r15.columnMenuOptions)(\"columnMenuTemplate\", ctx_r15.columnMenuTemplate)(\"totalColumnsCount\", ctx_r15.leafColumns.length)(\"detailTemplate\", ctx_r15.detailTemplate)(\"tabIndex\", ctx_r15.navigation.tableEnabled ? \"-1\" : \"0\");\n  }\n}\n\nfunction GridComponent_ng_container_7_div_1_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 29);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r17.columnsContainer.unlockedWidth, \"px\");\n  }\n}\n\nfunction GridComponent_ng_container_7_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵtemplate(1, GridComponent_ng_container_7_div_1_div_1_Template, 5, 24, \"div\", 18);\n    i0.ɵɵelementStart(2, \"div\", 19, 20)(4, \"table\", 21);\n    i0.ɵɵelement(5, \"colgroup\", 22)(6, \"thead\", 23);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, GridComponent_ng_container_7_div_1_div_7_Template, 2, 2, \"div\", 24);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding\", ctx_r13.headerPadding);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.isLocked);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx_r13.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx_r13.lockedWidth + ctx_r13.scrollbarWidth + 2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r13.nonLockedWidth, \"px\");\n    i0.ɵɵproperty(\"virtualColumns\", ctx_r13.virtualColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r13.headerLeafColumns)(\"groups\", ctx_r13.isLocked ? i0.ɵɵpureFunction0(29, _c50) : ctx_r13.group)(\"detailTemplate\", ctx_r13.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"resizable\", ctx_r13.resizable)(\"scrollable\", true)(\"columns\", ctx_r13.headerColumns)(\"totalColumnLevels\", ctx_r13.totalColumnLevels)(\"sort\", ctx_r13.sort)(\"filter\", ctx_r13.filter)(\"filterable\", ctx_r13.filterable)(\"groupable\", ctx_r13.showGroupPanel)(\"reorderable\", ctx_r13.reorderable)(\"groups\", ctx_r13.isLocked ? i0.ɵɵpureFunction0(30, _c50) : ctx_r13.group)(\"sortable\", ctx_r13.sortable)(\"columnMenu\", ctx_r13.columnMenuOptions)(\"columnMenuTemplate\", ctx_r13.columnMenuTemplate)(\"lockedColumnsCount\", ctx_r13.lockedLeafColumns.length)(\"totalColumnsCount\", ctx_r13.leafColumns.length)(\"detailTemplate\", ctx_r13.detailTemplate)(\"tabIndex\", ctx_r13.navigation.tableEnabled ? \"-1\" : \"0\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.virtualColumns);\n  }\n}\n\nfunction GridComponent_ng_container_7_div_3_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 37)(1, \"table\", 27);\n    i0.ɵɵelement(2, \"colgroup\", 35)(3, \"tfoot\", 38);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"width\", ctx_r19.lockedWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r19.lockedWidth, \"px\");\n    i0.ɵɵproperty(\"locked\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r19.lockedLeafColumns)(\"groups\", ctx_r19.group)(\"detailTemplate\", ctx_r19.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"scrollable\", true)(\"groups\", ctx_r19.group)(\"columns\", ctx_r19.lockedLeafColumns)(\"detailTemplate\", ctx_r19.detailTemplate)(\"logicalRowIndex\", ctx_r19.ariaRowCount);\n  }\n}\n\nfunction GridComponent_ng_container_7_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 30);\n    i0.ɵɵtemplate(1, GridComponent_ng_container_7_div_3_div_1_Template, 4, 13, \"div\", 31);\n    i0.ɵɵelementStart(2, \"div\", 32, 33)(4, \"table\", 34);\n    i0.ɵɵelement(5, \"colgroup\", 35)(6, \"tfoot\", 36);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding\", ctx_r14.headerPadding);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r14.lockedLeafColumns.length);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx_r14.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx_r14.lockedWidth + ctx_r14.scrollbarWidth + 3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r14.nonLockedWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r14.nonLockedLeafColumns)(\"groups\", ctx_r14.isLocked ? i0.ɵɵpureFunction0(16, _c50) : ctx_r14.group)(\"detailTemplate\", ctx_r14.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"logicalRowIndex\", ctx_r14.ariaRowCount)(\"scrollable\", true)(\"groups\", ctx_r14.isLocked ? i0.ɵɵpureFunction0(17, _c50) : ctx_r14.group)(\"columns\", ctx_r14.nonLockedLeafColumns)(\"lockedColumnsCount\", ctx_r14.lockedLeafColumns.length)(\"detailTemplate\", ctx_r14.detailTemplate);\n  }\n}\n\nfunction GridComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, GridComponent_ng_container_7_div_1_Template, 8, 31, \"div\", 14);\n    i0.ɵɵelementStart(2, \"kendo-grid-list\", 15);\n    i0.ɵɵlistener(\"pageChange\", function GridComponent_ng_container_7_Template_kendo_grid_list_pageChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return ctx_r21.notifyPageChange(\"list\", $event);\n    })(\"scrollBottom\", function GridComponent_ng_container_7_Template_kendo_grid_list_scrollBottom_2_listener() {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return ctx_r23.notifyScrollBottom();\n    })(\"contentScroll\", function GridComponent_ng_container_7_Template_kendo_grid_list_contentScroll_2_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return ctx_r24.contentScroll.emit($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, GridComponent_ng_container_7_div_3_Template, 7, 18, \"div\", 16);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.hideHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", ctx_r4.view)(\"rowHeight\", ctx_r4.rowHeight)(\"detailRowHeight\", ctx_r4.detailRowHeight)(\"total\", ctx_r4.totalCount)(\"take\", ctx_r4.pageSize)(\"groups\", ctx_r4.group)(\"groupable\", ctx_r4.groupable)(\"skip\", ctx_r4.skip)(\"trackBy\", ctx_r4.trackBy)(\"columns\", ctx_r4.columnsContainer)(\"selectable\", ctx_r4.selectable)(\"filterable\", ctx_r4.filterable)(\"detailTemplate\", ctx_r4.detailTemplate)(\"noRecordsTemplate\", ctx_r4.noRecordsTemplate)(\"rowClass\", ctx_r4.rowClass)(\"rowSticky\", ctx_r4.rowSticky)(\"loading\", ctx_r4.loading)(\"isVirtual\", ctx_r4.isVirtual)(\"cellLoadingTemplate\", ctx_r4.cellLoadingTemplate == null ? null : ctx_r4.cellLoadingTemplate.templateRef)(\"loadingTemplate\", ctx_r4.loadingTemplate == null ? null : ctx_r4.loadingTemplate.templateRef)(\"virtualColumns\", ctx_r4.virtualColumns)(\"enableDrag\", ctx_r4.marqueeSelection);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.showFooter);\n  }\n}\n\nfunction GridComponent_ng_container_8_thead_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"thead\", 42);\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"resizable\", ctx_r25.resizable)(\"scrollable\", false)(\"columns\", ctx_r25.visibleColumns)(\"totalColumnLevels\", ctx_r25.totalColumnLevels)(\"groups\", ctx_r25.group)(\"groupable\", ctx_r25.showGroupPanel)(\"reorderable\", ctx_r25.reorderable)(\"sort\", ctx_r25.sort)(\"sortable\", ctx_r25.sortable)(\"filter\", ctx_r25.filter)(\"filterable\", ctx_r25.filterable)(\"columnMenu\", ctx_r25.columnMenuOptions)(\"columnMenuTemplate\", ctx_r25.columnMenuTemplate)(\"detailTemplate\", ctx_r25.detailTemplate)(\"tabIndex\", ctx_r25.navigation.tableEnabled ? \"-1\" : \"0\");\n  }\n}\n\nfunction GridComponent_ng_container_8_tfoot_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"tfoot\", 43);\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", false)(\"logicalRowIndex\", ctx_r26.ariaRowCount)(\"groups\", ctx_r26.group)(\"columns\", ctx_r26.leafColumns)(\"detailTemplate\", ctx_r26.detailTemplate);\n  }\n}\n\nfunction GridComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"table\");\n    i0.ɵɵelement(2, \"colgroup\", 35);\n    i0.ɵɵtemplate(3, GridComponent_ng_container_8_thead_3_Template, 1, 15, \"thead\", 39);\n    i0.ɵɵelement(4, \"tbody\", 40);\n    i0.ɵɵtemplate(5, GridComponent_ng_container_8_tfoot_5_Template, 1, 5, \"tfoot\", 41);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"table-layout\", ctx_r5.resizable ? \"fixed\" : null);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r5.leafColumns)(\"groups\", ctx_r5.group)(\"detailTemplate\", ctx_r5.detailTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.hideHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"isLoading\", ctx_r5.loading)(\"groups\", ctx_r5.group)(\"data\", ctx_r5.view)(\"skip\", ctx_r5.skip)(\"columns\", ctx_r5.leafColumns)(\"selectable\", ctx_r5.selectable)(\"filterable\", ctx_r5.filterable)(\"noRecordsTemplate\", ctx_r5.noRecordsTemplate)(\"detailTemplate\", ctx_r5.detailTemplate)(\"showGroupFooters\", ctx_r5.showGroupFooters)(\"trackBy\", ctx_r5.trackBy)(\"rowClass\", ctx_r5.rowClass)(\"enableDrag\", ctx_r5.marqueeSelection);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.showFooter);\n  }\n}\n\nfunction GridComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 44);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"loadingTemplate\", ctx_r6.loadingTemplate);\n  }\n}\n\nfunction GridComponent_kendo_pager_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-pager\", 45);\n    i0.ɵɵlistener(\"pageChange\", function GridComponent_kendo_pager_10_Template_kendo_pager_pageChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.notifyPageChange(\"pager\", $event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r7.navigation.pagerEnabled ? \"0\" : \"-1\")(\"template\", ctx_r7.pagerTemplate)(\"pageSize\", ctx_r7.pageSize)(\"total\", ctx_r7.view.total)(\"skip\", ctx_r7.skip)(\"options\", ctx_r7.pageable);\n    i0.ɵɵattribute(\"role\", ctx_r7.navigation.pagerEnabled ? \"application\" : undefined);\n  }\n}\n\nfunction GridComponent_kendo_grid_toolbar_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-grid-toolbar\", 46);\n  }\n}\n\nfunction ColumnChooserComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"kendo-grid-columnlist\", 5);\n    i0.ɵɵlistener(\"apply\", function ColumnChooserComponent_ng_template_3_Template_kendo_grid_columnlist_apply_2_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.onApply($event);\n    })(\"columnChange\", function ColumnChooserComponent_ng_template_3_Template_kendo_grid_columnlist_columnChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.onChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.localization.get(\"columns\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"columns\", ctx_r2.columns)(\"applyText\", ctx_r2.localization.get(\"columnsApply\"))(\"resetText\", ctx_r2.localization.get(\"columnsReset\"))(\"autoSync\", ctx_r2.autoSync)(\"allowHideAll\", ctx_r2.allowHideAll);\n  }\n}\n\nconst EMPTY_REGEX = /^\\s*$/;\n/**\n * @hidden\n */\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isBlank = value => value === null || value === undefined;\n/**\n * @hidden\n */\n\n\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\n\n\nconst isTruthy = value => !!value;\n/**\n * @hidden\n */\n\n\nconst isNullOrEmptyString = value => isBlank(value) || EMPTY_REGEX.test(value);\n/**\n * @hidden\n */\n\n\nconst observe = list => merge(of(list), list.changes);\n/**\n * @hidden\n */\n\n\nconst isUniversal = () => typeof document === 'undefined';\n/**\n * @hidden\n */\n\n\nconst isString = value => typeof value === 'string';\n/**\n * @hidden\n */\n\n\nconst isNumber = value => typeof value === \"number\" && !isNaN(value);\n/**\n * @hidden\n */\n\n\nconst extractFormat = format => {\n  if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {\n    return format.slice(3, format.length - 1);\n  }\n\n  return format;\n};\n/**\n * @hidden\n */\n\n\nconst not = fn => (...args) => !fn.apply(null, args);\n/**\n * @hidden\n */\n\n\nconst or = (...conditions) => value => conditions.reduce((acc, x) => acc || x(value), false);\n/**\n * @hidden\n */\n\n\nconst and = (...conditions) => value => conditions.reduce((acc, x) => acc && x(value), true);\n/**\n * @hidden\n */\n\n\nconst Skip = new InjectionToken(\"Skip\");\n/**\n * @hidden\n */\n\nconst createPromise = () => {\n  let resolveFn, rejectFn;\n  const promise = new Promise((resolve, reject) => {\n    resolveFn = data => {\n      resolve(data);\n      return promise;\n    };\n\n    rejectFn = data => {\n      reject(data);\n      return promise;\n    };\n  });\n  promise.resolve = resolveFn;\n  promise.reject = rejectFn;\n  return promise;\n};\n/** @hidden */\n\n\nconst iterator = getIterator$1(); // TODO: Move to kendo-common\n\nfunction getIterator$1() {\n  if (typeof Symbol === 'function' && Symbol.iterator) {\n    return Symbol.iterator;\n  }\n\n  const keys = Object.getOwnPropertyNames(Map.prototype);\n  const proto = Map.prototype;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {\n      return key;\n    }\n  }\n}\n\nconst FRAME_DURATION = 1000 / 60;\nconst wnd = typeof window !== 'undefined' ? window : {};\n/** @hidden */\n\nconst requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));\n/** @hidden */\n\n\nconst cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;\n/**\n * @hidden\n */\n\nconst detectIE = () => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf('MSIE ');\n  const trident = ua.indexOf('Trident/');\n  return msie > 0 || trident > 0;\n};\n/**\n * @hidden\n */\n\n\nconst nodesToArray = nodes => [].slice.call(nodes);\n/**\n * @hidden\n */\n\n\nconst replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\\{\\\\s*${name}\\\\s*\\}`, 'g'), value);\n/**\n * Represents the Kendo UI GridSpacer component for Angular.\n * Used to give additional white space between the Pager inner elements,\n * and provides a way for customizing the spacer width.\n * It can also be used in any flex container within the Grid.\n */\n\n\nlet GridSpacerComponent = /*#__PURE__*/(() => {\n  class GridSpacerComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n    get sizedClass() {\n      return isPresent(this.width);\n    }\n\n    get flexBasisStyle() {\n      return this.width;\n    }\n\n  }\n\n  GridSpacerComponent.ɵfac = function GridSpacerComponent_Factory(t) {\n    return new (t || GridSpacerComponent)();\n  };\n\n  GridSpacerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GridSpacerComponent,\n    selectors: [[\"kendo-grid-spacer\"], [\"kendo-pager-spacer\"]],\n    hostVars: 6,\n    hostBindings: function GridSpacerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"flex-basis\", ctx.flexBasisStyle);\n        i0.ɵɵclassProp(\"k-spacer\", ctx.hostClass)(\"k-spacer-sized\", ctx.sizedClass);\n      }\n    },\n    inputs: {\n      width: \"width\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function GridSpacerComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return GridSpacerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DomEventsService = /*#__PURE__*/(() => {\n  class DomEventsService {\n    constructor() {\n      this.cellClick = new EventEmitter();\n      this.cellMousedown = new EventEmitter();\n      this.cellMouseup = new EventEmitter();\n      this.click = new EventEmitter();\n      this.keydown = new EventEmitter();\n      this.focus = new EventEmitter();\n      this.focusIn = new EventEmitter();\n      this.focusOut = new EventEmitter();\n      this.windowBlur = new EventEmitter();\n    }\n\n  }\n\n  DomEventsService.ɵfac = function DomEventsService_Factory(t) {\n    return new (t || DomEventsService)();\n  };\n\n  DomEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DomEventsService,\n    factory: DomEventsService.ɵfac\n  });\n  return DomEventsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalDataChangesService = /*#__PURE__*/(() => {\n  class LocalDataChangesService {\n    constructor() {\n      this.changes = new EventEmitter();\n    }\n\n  }\n\n  LocalDataChangesService.ɵfac = function LocalDataChangesService_Factory(t) {\n    return new (t || LocalDataChangesService)();\n  };\n\n  LocalDataChangesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LocalDataChangesService,\n    factory: LocalDataChangesService.ɵfac\n  });\n  return LocalDataChangesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass GridFocusableElement {\n  constructor(navigationService) {\n    this.navigationService = navigationService;\n  }\n\n  focus() {\n    this.navigationService.focusCell();\n  }\n\n  toggle(active) {\n    this.navigationService.toggle(active);\n  }\n\n  canFocus() {\n    return true;\n  }\n\n  hasFocus() {\n    return this.navigationService.hasFocus();\n  }\n\n  isNavigable() {\n    return false;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass NavigationCursor {\n  constructor(model) {\n    this.model = model;\n    this.changes = new Subject();\n    this.activeRow = 0;\n    this.activeCol = 0;\n    this.virtualCol = 0;\n    this.virtualRow = 0;\n  }\n\n  get row() {\n    return this.model.findRow(this.activeRow);\n  }\n\n  get cell() {\n    const row = this.row;\n\n    if (row) {\n      return this.model.findCell(this.activeCol, row);\n    }\n  }\n\n  get dataRowIndex() {\n    const row = this.row;\n\n    if (row) {\n      return row.dataRowIndex;\n    }\n\n    return -1;\n  }\n  /**\n   * Assumes and announces a new cursor position.\n   */\n\n\n  reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {\n    if (this.activate(rowIndex, colIndex, force)) {\n      this.virtualRow = rowIndex;\n      this.virtualCol = colIndex;\n    }\n  }\n\n  activate(rowIndex, colIndex, force) {\n    if (!force && this.isActiveRange(rowIndex, colIndex)) {\n      return false;\n    }\n\n    const prevColIndex = this.activeCol;\n    const prevRowIndex = this.activeRow;\n    this.activeCol = colIndex;\n    this.activeRow = rowIndex;\n    this.changes.next({\n      colIndex,\n      prevColIndex,\n      prevRowIndex,\n      rowIndex\n    });\n    return true;\n  }\n\n  isActiveRange(rowIndex, colIndex) {\n    if (this.activeRow !== rowIndex) {\n      return false;\n    }\n\n    const cell = this.cell;\n    const {\n      start,\n      end\n    } = this.model.cellRange(cell);\n    return !Boolean(cell) || start <= colIndex && colIndex <= end;\n  }\n  /**\n   * Assumes a new cursor position without announcing it.\n   */\n\n\n  assume(rowIndex = this.activeRow, colIndex = this.activeCol) {\n    this.virtualRow = rowIndex;\n    this.virtualCol = colIndex;\n    this.activeCol = colIndex;\n    this.activeRow = rowIndex;\n  }\n  /**\n   * Announces a current cursor position to subscribers.\n   */\n\n\n  announce() {\n    this.changes.next({\n      colIndex: this.activeCol,\n      prevColIndex: this.activeCol,\n      prevRowIndex: this.activeRow,\n      rowIndex: this.activeRow\n    });\n  }\n\n  activateVirtualCell(cell) {\n    const rowRange = this.model.rowRange(cell);\n    const cellRange = this.model.cellRange(cell);\n    const activeCol = this.activeCol;\n    const activeRow = this.activeRow;\n\n    if (rowRange.start <= activeRow && activeRow <= rowRange.end && cellRange.start <= activeCol && activeCol <= cellRange.end) {\n      this.activeRow = cell.rowIndex;\n      this.activeCol = cell.colIndex;\n      return true;\n    }\n  }\n\n  isActive(rowIndex, colIndex) {\n    return this.activeCol === colIndex && this.activeRow === rowIndex;\n  }\n\n  moveUp(offset = 1) {\n    return this.offsetRow(-offset);\n  }\n\n  moveDown(offset = 1) {\n    return this.offsetRow(offset);\n  }\n\n  moveLeft(offset = 1) {\n    return this.offsetCol(-offset);\n  }\n\n  moveRight(offset = 1) {\n    return this.offsetCol(offset);\n  }\n\n  lastCellIndex(row) {\n    return this.metadata.columns.leafColumnsToRender.length - 1 + (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);\n  }\n\n  offsetCol(offset) {\n    const prevRow = this.model.findRow(this.virtualRow);\n    const lastIndex = this.lastCellIndex(prevRow);\n    const virtualCol = this.virtualCol;\n    this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));\n    let nextColIndex = this.virtualCol;\n    let nextRowIndex = this.virtualRow;\n    let cell = this.model.findCell(this.virtualCol, prevRow);\n\n    if (!cell && this.metadata.virtualColumns) {\n      return this.activate(nextRowIndex, nextColIndex);\n    }\n\n    if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {\n      nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);\n      const nextCell = this.model.findCell(nextColIndex, prevRow);\n\n      if (cell !== nextCell) {\n        cell = nextCell;\n        this.virtualCol = cell.colIndex;\n      } else {\n        this.virtualCol = virtualCol;\n      }\n    }\n\n    return this.activate(cell.rowIndex, cell.colIndex);\n  }\n\n  offsetRow(offset) {\n    let nextColIndex = this.virtualCol;\n\n    if (this.metadata && this.metadata.isVirtual) {\n      const maxIndex = this.metadata.maxLogicalRowIndex;\n      let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));\n\n      if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {\n        nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;\n        nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));\n      }\n\n      if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {\n        if (this.model.lastRow.index !== maxIndex) {\n          // Don't attempt to navigate past the last collapsed row.\n          nextIndex--;\n        }\n      }\n\n      const nextRow = this.model.findRow(nextIndex);\n\n      if (nextRow) {\n        // remove duplication\n        let cell = this.model.findCell(this.virtualCol, nextRow);\n\n        if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {\n          cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));\n        }\n\n        nextIndex = cell.rowIndex;\n        nextColIndex = cell.colIndex;\n      }\n\n      this.virtualRow = nextIndex;\n      return this.activate(nextIndex, nextColIndex);\n    }\n\n    const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);\n\n    if (!nextRow) {\n      return false;\n    }\n\n    let cell = this.model.findCell(this.virtualCol, nextRow);\n\n    if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {\n      // spanned cell go to next\n      const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;\n      cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));\n    }\n\n    if (!cell && this.metadata.virtualColumns) {\n      return this.activate(this.virtualRow + offset, this.virtualCol);\n    }\n\n    this.virtualRow = cell.rowIndex;\n    return this.activate(this.virtualRow, cell.colIndex);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ItemMap {\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  get first() {\n    if (this.count > 0) {\n      let result;\n      this.forEach(item => {\n        result = item;\n        return true;\n      });\n      return result;\n    }\n  }\n\n  get last() {\n    if (this.count > 0) {\n      const keys = Object.keys(this.items);\n      return this.items[keys[keys.length - 1]];\n    }\n  }\n\n  removeItem(key) {\n    if (this.items[key]) {\n      delete this.items[key];\n      this.count--;\n    }\n  }\n\n  setItem(key, item) {\n    if (!this.items[key]) {\n      this.count++;\n    }\n\n    this.items[key] = item;\n  }\n\n  getItem(key) {\n    return this.items[key];\n  }\n\n  toArray() {\n    const result = [];\n    this.forEach(item => {\n      result.push(item);\n    });\n    return result;\n  }\n\n  forEach(callback) {\n    for (let key in this.items) {\n      if (this.items.hasOwnProperty(key) && callback(this.items[key])) {\n        return this.items[key];\n      }\n    }\n  }\n\n  find(callback) {\n    return this.forEach(callback);\n  }\n\n}\n/**\n * @hidden\n *\n * Contains information for the currently rendered rows and cells.\n */\n\n\nclass NavigationModel {\n  constructor() {\n    this.rows = new ItemMap();\n  }\n\n  get firstRow() {\n    return this.rows.first;\n  }\n\n  get lastRow() {\n    return this.rows.last;\n  }\n\n  registerCell(cell) {\n    const row = this.rows.getItem(cell.logicalRowIndex);\n\n    if (!row) {\n      return;\n    }\n\n    const colIndex = cell.logicalColIndex;\n    const modelCell = {\n      uid: cell.uid,\n      colIndex,\n      rowIndex: row.index,\n      colSpan: cell.colSpan,\n      rowSpan: cell.rowSpan,\n      detailExpandCell: cell.detailExpandCell,\n      dataItem: row.dataItem,\n      dataRowIndex: row.dataRowIndex,\n      focusGroup: cell.focusGroup\n    };\n    row.cells.setItem(colIndex, modelCell);\n\n    if (cell.groupItem) {\n      row.groupItem = cell.groupItem;\n    }\n\n    return modelCell;\n  }\n\n  unregisterCell(index, rowIndex, cell) {\n    const row = this.rows.getItem(rowIndex);\n\n    if (row) {\n      const match = row.cells.getItem(index);\n\n      if (match && match.uid === cell.uid) {\n        row.cells.removeItem(index);\n      }\n    }\n  }\n\n  registerRow(row) {\n    const modelRow = {\n      uid: row.uid,\n      index: row.logicalRowIndex,\n      dataItem: row.dataItem,\n      dataRowIndex: row.dataRowIndex,\n      cells: new ItemMap()\n    };\n    this.rows.setItem(row.logicalRowIndex, modelRow);\n  }\n\n  updateRow(row) {\n    const current = this.rows.getItem(row.logicalRowIndex);\n\n    if (current) {\n      Object.assign(current, {\n        dataItem: row.dataItem,\n        dataRowIndex: row.dataRowIndex\n      });\n    }\n  }\n\n  unregisterRow(index, row) {\n    const match = this.rows.getItem(index);\n\n    if (match && match.uid === row.uid) {\n      this.rows.removeItem(index);\n    }\n  }\n\n  cellRange(cell) {\n    if (cell) {\n      const start = cell.colIndex;\n      const end = cell.colIndex + (cell.colSpan || 1) - 1;\n      return {\n        start,\n        end\n      };\n    }\n\n    return {};\n  }\n\n  rowRange(cell) {\n    if (cell) {\n      const start = cell.rowIndex;\n      const end = cell.rowIndex + (cell.rowSpan || 1) - 1;\n      return {\n        start,\n        end\n      };\n    }\n\n    return {};\n  }\n\n  nextRow(rowIndex, offset) {\n    const rows = this.rows.toArray();\n    const row = this.rows.getItem(rowIndex);\n    const position = rows.indexOf(row);\n    const next = rows[position + offset];\n    return next;\n  }\n\n  findRow(index) {\n    return this.rows.getItem(index);\n  }\n\n  findCell(index, row) {\n    if (!row) {\n      return;\n    }\n\n    const rowIndex = row.index;\n    let cell = row.cells.getItem(index);\n    let currentIndex = rowIndex;\n\n    while (!cell && row) {\n      row = this.rows.getItem(currentIndex);\n      cell = this.rowCell(index, row);\n      currentIndex--;\n    }\n\n    if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {\n      return cell;\n    }\n  }\n\n  rowCell(index, row) {\n    if (!row || !row.cells.count) {\n      return;\n    }\n\n    const firstCell = row.cells.first;\n    let cell,\n        currentIndex = index;\n\n    while (!cell && currentIndex >= firstCell.colIndex) {\n      cell = row.cells.getItem(currentIndex);\n      currentIndex--;\n    }\n\n    if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {\n      return cell;\n    }\n  }\n\n}\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\nconst NODE_NAME_PREDICATES = {};\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\n\n\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\n\n\nconst matchesClasses = classNames => element => hasClasses(element, classNames);\n/**\n * @hidden\n */\n\n\nconst matchesNodeName = nodeName => {\n  if (!NODE_NAME_PREDICATES[nodeName]) {\n    NODE_NAME_PREDICATES[nodeName] = element => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n  }\n\n  return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst contains$2 = (parent, node, matchSelf = false) => {\n  const outside = !closest(node, child => child === parent);\n\n  if (outside) {\n    return false;\n  }\n\n  const el = closest(node, child => child === node);\n  return el && (matchSelf || el !== parent);\n};\n/**\n * @hidden\n */\n\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0; // Elements can have zero size due to styling, but they will still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = element => {\n  if (!element.tagName) {\n    return false;\n  }\n\n  const tagName = element.tagName.toLowerCase();\n  const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n  const focusable = !element.disabled && focusableRegex.test(tagName);\n  return focusable || hasTabIndex;\n};\n/**\n * @hidden\n */\n\n\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n  if (!isFocusable(element)) {\n    return false;\n  }\n\n  const visible = !checkVisibility || isVisible(element);\n  const ariaHidden = element.getAttribute('aria-hidden') === 'true';\n  const tabIndex = element.getAttribute('tabIndex');\n  return visible && !ariaHidden && tabIndex !== '-1';\n};\n/**\n * @hidden\n */\n\n\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n\n  node = node.firstChild;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n\n      if (element) {\n        return element;\n      }\n    }\n\n    node = node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst findLastElement = (node, predicate, matchSelf = true) => {\n  let last = null;\n  findElement(node, node => {\n    if (predicate(node)) {\n      last = node;\n    }\n\n    return false;\n  }, matchSelf);\n  return last;\n};\n/**\n * @hidden\n */\n\n\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility));\n};\n/**\n * @hidden\n */\n\n\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\n\n\nconst findLastFocusableChild = (element, checkVisibility = true) => {\n  return findLastElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\n\n\nfunction rtlScrollPosition(position, element, initial) {\n  let result = position;\n\n  if (initial < 0) {\n    result = -position;\n  } else if (initial > 0) {\n    result = element.scrollWidth - element.offsetWidth - position;\n  }\n\n  return result;\n}\n/**\n * @hidden\n */\n\n\nclass PagerContextService {\n  constructor() {\n    this.changes = new Subject();\n    this.pageChange = new Subject();\n  }\n\n  get currentPage() {\n    return this.skip / this.pageSize;\n  }\n\n  notifyChanges(changes) {\n    this.total = changes.total;\n    this.pageSize = changes.pageSize;\n    this.skip = changes.skip;\n    this.changes.next(changes);\n  }\n\n  changePage(page) {\n    this.pageChange.next({\n      skip: page * this.pageSize,\n      take: this.pageSize\n    });\n  }\n\n  changePageSize(value) {\n    this.pageChange.next({\n      skip: 0,\n      take: value\n    });\n  }\n\n  nextPage() {\n    const nextPage = this.currentPage + 1;\n\n    if (nextPage * this.pageSize < this.total) {\n      this.changePage(nextPage);\n    }\n  }\n\n  prevPage() {\n    const prevPage = this.currentPage - 1;\n\n    if (prevPage * this.pageSize >= 0) {\n      this.changePage(prevPage);\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet ScrollRequestService = /*#__PURE__*/(() => {\n  class ScrollRequestService {\n    constructor() {\n      this.requests = new Subject();\n    }\n\n    scrollTo(request) {\n      this.requests.next(request);\n    }\n\n  }\n\n  ScrollRequestService.ɵfac = function ScrollRequestService_Factory(t) {\n    return new (t || ScrollRequestService)();\n  };\n\n  ScrollRequestService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollRequestService,\n    factory: ScrollRequestService.ɵfac\n  });\n  return ScrollRequestService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst getGroupRowArgs = groupItem => {\n  if (!isPresent(groupItem)) {\n    return null;\n  }\n\n  return {\n    group: groupItem.data,\n    groupIndex: groupItem.index,\n    parentGroup: getGroupRowArgs(groupItem.parentGroup)\n  };\n};\n\nconst isChildIndex = (targetIndex, parentIndex) => parentIndex !== targetIndex && targetIndex.startsWith(parentIndex);\n/**\n * @hidden\n */\n\n\nlet GroupsService = /*#__PURE__*/(() => {\n  class GroupsService {\n    constructor() {\n      this.changes = new Subject();\n      this.rowState = new Set();\n    }\n\n    reset() {\n      this.rowState.clear();\n    }\n\n    ngOnDestroy() {\n      this.reset();\n    }\n\n    isExpanded(groupArgs) {\n      if (this.userCallback) {\n        return this.userCallback(groupArgs);\n      }\n\n      return !this.rowState.has(groupArgs.groupIndex);\n    }\n\n    isInExpandedGroup(groupItem) {\n      let expanded = true;\n\n      while (groupItem && expanded) {\n        expanded = this.isExpanded({\n          group: groupItem.data,\n          groupIndex: groupItem.index,\n          parentGroup: getGroupRowArgs(groupItem.parentGroup)\n        });\n        groupItem = groupItem.parentGroup;\n      }\n\n      return expanded;\n    }\n\n    toggleRow(groupItem) {\n      const parentGroup = getGroupRowArgs(groupItem.parentGroup);\n      const expand = !this.isExpanded({\n        group: groupItem.data,\n        groupIndex: groupItem.index,\n        parentGroup\n      });\n      this.changes.next({\n        group: groupItem.data,\n        expand,\n        groupIndex: groupItem.index,\n        parentGroup\n      }); // if usercallback is given, the rowState should be ignored\n\n      if (this.userCallback) {\n        return;\n      }\n\n      if (expand) {\n        this.rowState.delete(groupItem.index);\n      } else {\n        this.rowState.add(groupItem.index);\n      }\n    }\n\n    expandChildren(parentIndex) {\n      this.rowState.forEach(index => isChildIndex(index, parentIndex) && this.rowState.delete(index));\n    }\n\n  }\n\n  GroupsService.ɵfac = function GroupsService_Factory(t) {\n    return new (t || GroupsService)();\n  };\n\n  GroupsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GroupsService,\n    factory: GroupsService.ɵfac\n  });\n  return GroupsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Arguments for the `detailCollapse` event.\n */\n\n\nclass DetailCollapseEvent extends PreventableEvent {\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * Arguments for the `detailExpand` event.\n */\n\n\nclass DetailExpandEvent extends PreventableEvent {\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet DetailsService = /*#__PURE__*/(() => {\n  class DetailsService {\n    constructor() {\n      this.changes = new Subject();\n      this.rowState = new Set();\n    }\n\n    ngOnDestroy() {\n      this.rowState.clear();\n    }\n\n    isExpanded(index, dataItem) {\n      if (this.userCallback) {\n        return this.userCallback({\n          index,\n          dataItem\n        });\n      }\n\n      return this.rowState.has(index);\n    }\n\n    toggleRow(index, dataItem) {\n      if (this.isExpanded(index, dataItem)) {\n        this.collapseRow(index, dataItem);\n      } else {\n        this.expandRow(index, dataItem);\n      }\n    }\n\n    expandRow(index, dataItem) {\n      const prevented = this.emitEvent({\n        dataItem,\n        index,\n        expand: true\n      });\n\n      if (!prevented && !this.userCallback) {\n        this.rowState.add(index);\n      }\n    }\n\n    collapseRow(index, dataItem) {\n      const prevented = this.emitEvent({\n        dataItem,\n        index,\n        expand: false\n      });\n\n      if (!prevented && !this.userCallback) {\n        this.rowState.delete(index);\n      }\n    }\n\n    emitEvent(args) {\n      const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);\n      this.changes.next(eventArg);\n      return eventArg.isDefaultPrevented();\n    }\n\n  }\n\n  DetailsService.ɵfac = function DetailsService_Factory(t) {\n    return new (t || DetailsService)();\n  };\n\n  DetailsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DetailsService,\n    factory: DetailsService.ɵfac\n  });\n  return DetailsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst FOCUS_ROOT_ACTIVE = new InjectionToken('focus-root-initial-active-state');\n/**\n * @hidden\n */\n\nlet FocusRoot = /*#__PURE__*/(() => {\n  class FocusRoot {\n    constructor(active = false) {\n      this.active = active;\n      this.groups = new Set();\n    }\n\n    registerGroup(group) {\n      if (this.active) {\n        this.groups.add(group);\n      }\n    }\n\n    unregisterGroup(group) {\n      if (this.active) {\n        this.groups.delete(group);\n      }\n    }\n\n    activate() {\n      if (this.active) {\n        this.groups.forEach(f => f.activate());\n      }\n    }\n\n    deactivate() {\n      if (this.active) {\n        this.groups.forEach(f => f.deactivate());\n      }\n    }\n\n  }\n\n  FocusRoot.ɵfac = function FocusRoot_Factory(t) {\n    return new (t || FocusRoot)(i0.ɵɵinject(FOCUS_ROOT_ACTIVE, 8));\n  };\n\n  FocusRoot.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusRoot,\n    factory: FocusRoot.ɵfac\n  });\n  return FocusRoot;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `cellClose` event.\n */\n\n\nclass CellCloseEvent extends PreventableEvent {\n  constructor(options) {\n    super();\n    /**\n     * @hidden\n     */\n\n    this.action = 'cellClose';\n    Object.assign(this, options);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst isEqual = index => item => item.index === index;\n/**\n * @hidden\n */\n\n\nconst isNotEqual = index => item => item.index !== index;\n/**\n * @hidden\n */\n\n\nconst isNewRow = index => index === -1 || index === undefined;\n/**\n * @hidden\n */\n\n\nlet EditService = /*#__PURE__*/(() => {\n  class EditService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.changes = new EventEmitter();\n      this.editedIndices = [];\n      this.keepEditCell = false;\n      this.closingCell = false;\n      this.changedSource = new Subject();\n      this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));\n    }\n\n    editRow(index, group = undefined) {\n      this.editedIndices.push({\n        index,\n        group\n      });\n      this.onChanged();\n    }\n\n    addRow(group) {\n      this.newItemGroup = {\n        group\n      };\n      this.onChanged();\n    }\n\n    editCell(rowIndex, column, group) {\n      if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {\n        return;\n      }\n\n      this.preventCellClose();\n\n      if (!this.closeCell()) {\n        this.editRow(rowIndex, group);\n        this.column = column;\n        this.onChanged();\n      }\n    }\n\n    isEditing() {\n      return this.editedIndices.length > 0;\n    }\n\n    isEditingCell() {\n      return this.isEditing() && this.column !== undefined;\n    }\n\n    get hasNewItem() {\n      return isPresent(this.newItemGroup);\n    }\n\n    get newDataItem() {\n      if (this.hasNewItem) {\n        return this.newItemGroup.group.value;\n      }\n\n      return {};\n    }\n\n    close(index) {\n      if (isNewRow(index)) {\n        this.newItemGroup = undefined;\n        return;\n      }\n\n      this.editedIndices = this.editedIndices.filter(isNotEqual(index));\n      delete this.column;\n      this.onChanged();\n    }\n\n    closeCell(originalEvent) {\n      if (this.column && !this.closingCell) {\n        return this.ngZone.run(() => {\n          const {\n            index,\n            group\n          } = this.editedIndices[0];\n          const args = new CellCloseEvent({\n            column: this.column,\n            formGroup: group,\n            originalEvent: originalEvent,\n            rowIndex: index\n          });\n          this.closingCell = true;\n          this.changes.emit(args);\n          this.closingCell = false;\n\n          if (!args.isDefaultPrevented()) {\n            this.cancelCell();\n          }\n\n          return args.isDefaultPrevented();\n        });\n      }\n    }\n\n    cancelCell() {\n      if (this.column) {\n        this.editedIndices = [];\n        delete this.column;\n        this.onChanged();\n      }\n    }\n\n    shouldCloseCell() {\n      return this.column && !this.keepEditCell;\n    }\n\n    preventCellClose() {\n      this.ngZone.runOutsideAngular(() => {\n        window.clearTimeout(this.keepCellTimeout);\n        this.keepEditCell = true;\n        this.keepCellTimeout = window.setTimeout(() => {\n          this.keepEditCell = false;\n        }, 0);\n      });\n    }\n\n    context(index) {\n      if (isNewRow(index)) {\n        return this.newItemGroup;\n      }\n\n      return this.findByIndex(index);\n    }\n\n    columnContext(index, column) {\n      if (isNewRow(index)) {\n        return this.newItemGroup;\n      }\n\n      if (!this.column || column === this.column) {\n        return this.findByIndex(index);\n      }\n    }\n\n    isEdited(index) {\n      if (isNewRow(index) && isPresent(this.newItemGroup)) {\n        return true;\n      }\n\n      return !this.column && isPresent(this.findByIndex(index));\n    }\n\n    hasEdited(index) {\n      return isPresent(this.context(index));\n    }\n\n    isEditedColumn(index, column) {\n      if (this.column && this.column === column) {\n        return isPresent(this.findByIndex(index));\n      }\n\n      return false;\n    }\n\n    beginEdit(rowIndex) {\n      this.changes.emit({\n        action: 'edit',\n        rowIndex\n      });\n    }\n\n    beginAdd() {\n      this.changes.emit({\n        action: 'add'\n      });\n    }\n\n    endEdit(rowIndex) {\n      const {\n        group: formGroup\n      } = this.context(rowIndex);\n      this.changes.emit({\n        action: 'cancel',\n        rowIndex,\n        formGroup,\n        isNew: isNewRow(rowIndex)\n      });\n    }\n\n    save(rowIndex) {\n      const {\n        group: formGroup\n      } = this.context(rowIndex);\n      this.changes.emit({\n        action: 'save',\n        rowIndex,\n        formGroup,\n        isNew: isNewRow(rowIndex)\n      });\n    }\n\n    remove(rowIndex) {\n      this.changes.emit({\n        action: 'remove',\n        rowIndex\n      });\n    }\n\n    findByIndex(index) {\n      return this.editedIndices.find(isEqual(index));\n    }\n\n    onChanged() {\n      this.ngZone.runOutsideAngular(() => {\n        this.changedSource.next();\n      });\n    }\n\n  }\n\n  EditService.ɵfac = function EditService_Factory(t) {\n    return new (t || EditService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  EditService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: EditService,\n    factory: EditService.ɵfac\n  });\n  return EditService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isButton = matchesNodeName('button');\nconst isInputTag = matchesNodeName('input');\nconst navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;\n\nconst isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);\n\nconst isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element));\n/**\n * @hidden\n */\n\n\nclass DefaultFocusableElement {\n  constructor(host, renderer) {\n    this.renderer = renderer;\n    this.element = host.nativeElement;\n    this.focusable = findFocusable(this.element, false) || this.element;\n  }\n\n  get enabled() {\n    return this.focusable && !this.focusable.disabled;\n  }\n\n  get visible() {\n    return this.focusable && isVisible(this.focusable);\n  }\n\n  isNavigable() {\n    return this.canFocus() && isNavigable(this.element);\n  }\n\n  toggle(active) {\n    this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');\n  }\n\n  focus() {\n    if (this.focusable) {\n      this.focusable.focus();\n    }\n  }\n\n  canFocus() {\n    return this.visible && this.enabled;\n  }\n\n  hasFocus() {\n    return document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst CELL_CONTEXT = new InjectionToken('grid-cell-context');\n/**\n * @hidden\n */\n\nconst EMPTY_CELL_CONTEXT = {};\n/**\n * A directive that controls the way focusable elements receive\n * [focus in a navigable Grid]({% slug keyboard_navigation_grid %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *      <input type=\"text\" placeholder=\"Tab stop #0\" style=\"margin-bottom: 8px;\" />\n *      <kendo-grid [data]=\"data\" [navigable]=\"true\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"100\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\" [width]=\"150\">\n *          </kendo-grid-column>\n *          <kendo-grid-column>\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <!-- The first focusable element will be focused when pressing Enter on the cell -->\n *                  <input type=\"text\" kendoGridFocusable [value]=\"dataItem.ProductName\" style=\"margin-right: 8px;\" />\n *                  <button kendoGridFocusable>Update</button>\n *              </ng-template>\n *          </kendo-grid-column>\n *          <kendo-grid-column [width]=\"100\">\n *              <ng-template kendoGridCellTemplate>\n *                  <!-- A single focusable element will be focused during navigation -->\n *                  <button kendoGridFocusable>Delete</button>\n *              </ng-template>\n *          </kendo-grid-column>\n *      </kendo-grid>\n *      <input type=\"text\" placeholder=\"Tab stop #2\" style=\"margin-top: 8px;\" />\n *    `\n * })\n *\n * class AppComponent {\n *     public readonly data: any = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": true\n *     }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": false\n *     }];\n * }\n * ```\n */\n\nlet FocusableDirective = /*#__PURE__*/(() => {\n  class FocusableDirective {\n    constructor(cellContext, hostElement, renderer) {\n      this.cellContext = cellContext;\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.active = true;\n      this._enabled = true;\n\n      if (this.cellContext) {\n        this.group = this.cellContext.focusGroup;\n      }\n\n      if (this.group) {\n        this.group.registerElement(this);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set enabled(value) {\n      if (value === '') {\n        value = true;\n      } else {\n        value = Boolean(value);\n      }\n\n      if (value !== this.enabled) {\n        this._enabled = value;\n\n        if (this.element) {\n          this.element.toggle(this.active && value);\n        }\n      }\n    }\n\n    get enabled() {\n      return this._enabled;\n    }\n\n    ngAfterViewInit() {\n      if (!this.element) {\n        this.element = new DefaultFocusableElement(this.hostElement, this.renderer);\n      }\n\n      if (this.group && this.element) {\n        this.toggle(this.group.isActive);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.group) {\n        this.group.unregisterElement(this);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggle(active) {\n      if (this.element && active !== this.active) {\n        this.element.toggle(this.enabled && active);\n        this.active = active;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return this.enabled && this.element && this.element.canFocus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    isNavigable() {\n      return this.enabled && this.element && this.element.isNavigable();\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus() {\n      if (this.enabled && this.element) {\n        this.element.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    hasFocus() {\n      return this.enabled && this.element && this.element.hasFocus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerElement(element) {\n      this.element = element;\n    }\n\n  }\n\n  FocusableDirective.ɵfac = function FocusableDirective_Factory(t) {\n    return new (t || FocusableDirective)(i0.ɵɵdirectiveInject(CELL_CONTEXT, 12), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  FocusableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusableDirective,\n    selectors: [[\"\", \"kendoGridFocusable\", \"\"], [\"\", \"kendoGridEditCommand\", \"\"], [\"\", \"kendoGridRemoveCommand\", \"\"], [\"\", \"kendoGridSaveCommand\", \"\"], [\"\", \"kendoGridCancelCommand\", \"\"], [\"\", \"kendoGridSelectionCheckbox\", \"\"]],\n    inputs: {\n      enabled: [\"kendoGridFocusable\", \"enabled\"]\n    }\n  });\n  return FocusableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;\n\nconst matchHeaderCell = matchesNodeName('th');\nconst matchDataCell = matchesNodeName('td');\nconst matchFooterCell = matchesNodeName('.k-grid-footer td');\n\nconst matchCell = element => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);\n\nconst gridCell = (element, gridElement) => {\n  let target = closest(element, matchCell);\n\n  while (target && !isInSameGrid(target, gridElement)) {\n    target = closest(target.parentElement, matchCell);\n  }\n\n  return target;\n};\n\nconst targetCell = (target, gridElement) => {\n  const cell = gridCell(target, gridElement);\n  const row = closest(cell, matchesNodeName('tr'));\n\n  if (cell && row) {\n    let rowIndex = row.getAttribute('aria-rowindex');\n    rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;\n    let colIndex = cell.getAttribute('aria-colindex');\n    colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;\n\n    if (rowIndex !== null && colIndex !== null) {\n      return {\n        colIndex,\n        rowIndex,\n        element: cell\n      };\n    }\n  }\n};\n\nconst isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight || keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;\n\nconst isNavigationKey = keyCode => isArrowKey(keyCode) || keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;\n\nconst isInput = matchesNodeName('input');\n\nconst isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';\n\nconst isPrintableCharacter = str => str.length === 1 && str.match(/\\S/);\n/**\n * @hidden\n */\n\n\nclass NavigationViewport {\n  constructor(firstItemIndex, lastItemIndex) {\n    this.firstItemIndex = firstItemIndex;\n    this.lastItemIndex = lastItemIndex;\n  }\n\n  containsRow(dataRowIndex) {\n    const headerRow = dataRowIndex < 0;\n    return headerRow || dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex;\n  }\n\n  intersects(start, end) {\n    return start <= this.firstItemIndex && this.lastItemIndex <= end || this.firstItemIndex <= start && start <= this.lastItemIndex || this.firstItemIndex <= end && end <= this.lastItemIndex;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, localization, focusableParent) {\n      this.zone = zone;\n      this.domEvents = domEvents;\n      this.pagerContextService = pagerContextService;\n      this.scrollRequestService = scrollRequestService;\n      this.groupsService = groupsService;\n      this.detailsService = detailsService;\n      this.focusRoot = focusRoot;\n      this.editService = editService;\n      this.cd = cd;\n      this.localization = localization;\n      this.focusableParent = focusableParent;\n      this.cellKeydown = new EventEmitter();\n      this.activeRowIndex = 0;\n      this.alive = false;\n      this.active = true;\n      this.mode = 0\n      /* Standby */\n      ;\n      this.model = new NavigationModel();\n      this.cursor = new NavigationCursor(this.model);\n      this.pagerIsNavigable = false;\n      this.tableIsNavigable = false;\n      this.changes = this.cursor.changes;\n    }\n\n    set metadata(value) {\n      this.meta = value;\n      this.cursor.metadata = value;\n    }\n\n    get metadata() {\n      return this.meta;\n    }\n\n    get enabled() {\n      return this.alive;\n    }\n\n    get pagerEnabled() {\n      return this.alive && this.pagerIsNavigable;\n    }\n\n    get tableEnabled() {\n      return this.alive && this.tableIsNavigable;\n    }\n\n    get activeCell() {\n      if (this.mode !== 0\n      /* Standby */\n      ) {\n        return this.cursor.cell;\n      }\n    }\n\n    get activeRow() {\n      if (this.mode !== 0\n      /* Standby */\n      ) {\n        return Object.assign({}, this.cursor.row, {\n          cells: this.cursor.row.cells.toArray()\n        });\n      }\n    }\n\n    get activeDataRow() {\n      return Math.max(0, this.activeRowIndex - this.meta.headerRows);\n    }\n\n    init(meta, navigableOptions) {\n      this.setActiveSections(navigableOptions);\n      this.alive = true;\n      this.focusRoot.active = true;\n      this.metadata = meta;\n\n      const onStableSubscriber = (...operators) => args => this.zone.isStable ? from([true]).pipe(map(() => args)) : this.zone.onStable.pipe(take(1), map(() => args), ...operators);\n\n      const onStable = onStableSubscriber();\n      this.subs = new Subscription();\n      this.subs.add(this.cursor.changes.subscribe(args => this.onCursorChanges(args)));\n      this.subs.add(this.domEvents.focus.pipe(switchMap(onStable)).subscribe(args => this.navigateTo(args.target)));\n      this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0\n      /* Standby */\n      ), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus)))).subscribe(args => this.onFocusOut(args)));\n      this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0\n      /* Standby */\n      )).subscribe(() => this.onWindowBlur()));\n      this.subs.add( // Closing the editor will not always trigger focusout in Firefox.\n      // To get around this, we ensure that the cell is closed after editing.\n      this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2\n      /* Content */\n      ), filter(e => e.action === 'cellClose' && !e.prevented), switchMap(onStable)).subscribe(() => this.leaveCell()));\n      this.subs.add(this.pagerContextService.pageChange.subscribe(() => this.cursor.reset(0, 0)));\n      this.subs.add(this.domEvents.keydown.subscribe(args => this.onKeydown(args)));\n      this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2\n      /* Content */\n      ), switchMapTo(this.domEvents.focusOut.pipe(takeUntil( // Timeout if focusOut doesn't fire very soon\n      interval(0).pipe(take(1)))))).subscribe(() => this.onTabout()));\n\n      if (this.focusableParent) {\n        const element = new GridFocusableElement(this);\n        this.focusableParent.registerElement(element);\n      }\n\n      this.deactivateElements();\n    }\n\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n\n      this.alive = false;\n    }\n\n    registerCell(cell) {\n      if (cell.logicalRowIndex !== this.pendingRowIndex) {\n        const modelCell = this.model.registerCell(cell);\n\n        if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {\n          this.virtualCell = false;\n        }\n      }\n    }\n\n    registerCellOnCurrentRow(cell) {\n      if (cell.logicalRowIndex === this.pendingRowIndex) {\n        this.model.registerCell(cell);\n      }\n    }\n\n    unregisterCell(index, rowIndex, cell) {\n      this.model.unregisterCell(index, rowIndex, cell);\n    }\n\n    registerRow(row) {\n      this.model.registerRow(row);\n      this.pendingRowIndex = row.logicalRowIndex;\n    }\n\n    updateRow(row) {\n      this.model.updateRow(row);\n    }\n\n    unregisterRow(index, row) {\n      this.model.unregisterRow(index, row);\n      const lastRow = this.model.lastRow;\n\n      if (lastRow && this.mode === 0\n      /* Standby */\n      ) {\n        const maxIndex = this.needsViewport() && this.viewport ? this.viewport.lastItemIndex : lastRow.index;\n\n        if (this.activeRowIndex > maxIndex) {\n          this.cursor.reset(0, 0);\n        }\n      }\n    }\n\n    isCellFocusable(cell) {\n      return this.alive && this.active && this.mode !== 2\n      /* Content */\n      && this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);\n    }\n\n    isCellFocused(cell) {\n      return this.mode === 1\n      /* Cursor */\n      && this.isCellFocusable(cell);\n    }\n\n    navigateTo(el) {\n      if (!this.alive) {\n        return;\n      }\n\n      const cell = targetCell(el, this.meta.gridElement.nativeElement);\n\n      if (!cell) {\n        return;\n      }\n\n      const oldMode = this.mode;\n      const focusInCell = contains$2(cell.element, document.activeElement);\n      const focusInActiveRowContent = this.mode === 2\n      /* Content */\n      && this.activeRowIndex === cell.rowIndex && el !== cell.element;\n\n      if (focusInCell) {\n        this.mode = 2\n        /* Content */\n        ;\n        this.cursor.reset(cell.rowIndex, cell.colIndex);\n        this.activateRow();\n      } else if (!focusInActiveRowContent) {\n        this.mode = 1\n        /* Cursor */\n        ;\n        this.deactivateElements();\n        const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);\n        const isCursor = oldMode === 1\n        /* Cursor */\n        && alreadyActive;\n\n        if (!isCursor) {\n          this.cursor.reset(cell.rowIndex, cell.colIndex);\n        }\n      }\n    }\n\n    tryFocus(el) {\n      this.activateElements();\n      const focusable = findFocusableChild(el);\n\n      if (focusable) {\n        const cell = targetCell(focusable, this.meta.gridElement.nativeElement);\n\n        if (cell) {\n          this.cursor.reset(cell.rowIndex, cell.colIndex);\n          this.deactivateElements();\n          this.enterCell();\n        }\n\n        focusable.focus();\n      } else {\n        this.deactivateElements();\n      }\n\n      return !!focusable;\n    }\n\n    needsViewport() {\n      return this.meta && this.meta.isVirtual;\n    }\n\n    setViewport(firstItemIndex, lastItemIndex) {\n      this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n\n      if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {\n        const dataRowIndex = this.activeDataRow;\n        const ahead = firstItemIndex - dataRowIndex;\n        const behind = dataRowIndex - lastItemIndex;\n\n        if (ahead > 0) {\n          this.cursor.reset(firstItemIndex + this.meta.headerRows);\n        } else if (behind > 0) {\n          this.cursor.reset(lastItemIndex - this.meta.headerRows);\n        }\n      }\n    }\n\n    setColumnViewport(firstItemIndex, lastItemIndex) {\n      this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);\n    }\n\n    focusCell(rowIndex = undefined, colIndex = undefined) {\n      this.mode = 1\n      /* Cursor */\n      ;\n      this.cursor.reset(rowIndex, colIndex);\n      return this.activeCell;\n    }\n\n    focusCellByElement(el) {\n      const cell = targetCell(el, this.meta.gridElement.nativeElement);\n\n      if (cell) {\n        return this.focusCell(cell.rowIndex, cell.colIndex);\n      }\n    }\n\n    focusNextCell(wrap = true) {\n      return this.focusAdjacentCell(true, wrap);\n    }\n\n    focusPrevCell(wrap = true) {\n      return this.focusAdjacentCell(false, wrap);\n    }\n\n    toggle(active) {\n      this.active = active;\n      this.cursor.announce();\n    }\n\n    hasFocus() {\n      return this.mode === 1\n      /* Cursor */\n      || this.mode === 2\n      /* Content */\n      ;\n    }\n\n    autoFocusCell(start, end) {\n      return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);\n    }\n\n    setActiveSections(navigableOptions) {\n      this.pagerIsNavigable = navigableOptions.includes('pager');\n      this.tableIsNavigable = navigableOptions.includes('table');\n    }\n\n    focusAdjacentCell(fwd, wrap) {\n      this.focusCell();\n      let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();\n\n      if (wrap && !success) {\n        success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);\n\n        if (success) {\n          const row = this.cursor.row;\n          const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row);\n          this.cursor.reset(row.index, colIdx);\n        }\n      }\n\n      if (success) {\n        return this.activeCell;\n      } else {\n        this.mode = 0\n        /* Standby */\n        ;\n        this.cursor.announce();\n      }\n\n      return null;\n    }\n\n    enterCell() {\n      const cell = this.cursor.cell;\n\n      if (!cell) {\n        return;\n      }\n\n      const group = cell.focusGroup;\n      const focusable = group && group.canFocus();\n      this.mode = focusable ? 2\n      /* Content */\n      : 1\n      /* Cursor */\n      ;\n      this.cursor.announce();\n\n      if (focusable) {\n        this.activateRow();\n        group.focus();\n      }\n    }\n\n    leaveCell() {\n      const cell = this.cursor.cell;\n\n      if (!cell) {\n        return;\n      }\n\n      const group = cell.focusGroup;\n      const focusable = group && group.canFocus();\n\n      if (!focusable) {\n        this.deactivateElements();\n      }\n\n      this.mode = 1\n      /* Cursor */\n      ;\n      this.cursor.announce();\n    }\n\n    activateElements() {\n      this.focusRoot.activate();\n    }\n\n    deactivateElements() {\n      this.focusRoot.deactivate();\n    }\n\n    activateRow() {\n      this.cursor.row.cells.forEach(cell => cell.focusGroup && cell.focusGroup.activate());\n    }\n\n    moveCursorFwd() {\n      return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();\n    }\n\n    moveCursorBwd() {\n      return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();\n    }\n\n    onCursorKeydown(args) {\n      let preventDefault = false;\n      const modifier = args.ctrlKey || args.metaKey;\n      const step = modifier ? 5 : 1;\n\n      if (!this.onCellKeydown(args)) {\n        return;\n      }\n\n      const row = this.cursor.row;\n\n      switch (args.keyCode) {\n        case Keys.ArrowDown:\n          preventDefault = this.cursor.moveDown(step);\n          break;\n\n        case Keys.ArrowUp:\n          preventDefault = this.cursor.moveUp(step);\n          break;\n\n        case Keys.ArrowRight:\n          preventDefault = this.moveCursorFwd();\n          break;\n\n        case Keys.ArrowLeft:\n          preventDefault = this.moveCursorBwd();\n          break;\n\n        case Keys.PageDown:\n          if (this.metadata.isVirtual && this.viewport) {\n            let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;\n\n            if (this.metadata.hasDetailTemplate) {\n              nextItemIndex++;\n            }\n\n            nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);\n            this.cursor.reset(nextItemIndex);\n            preventDefault = true;\n          } else if (this.metadata.hasPager) {\n            this.zone.run(() => this.pagerContextService.nextPage());\n            preventDefault = true;\n          }\n\n          break;\n\n        case Keys.PageUp:\n          if (this.metadata.isVirtual && this.viewport) {\n            let viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;\n            let firstItemIndex = this.viewport.firstItemIndex;\n            let nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);\n            this.cursor.reset(nextItemIndex);\n            preventDefault = true;\n          } else if (this.metadata.hasPager) {\n            this.zone.run(() => this.pagerContextService.prevPage());\n            preventDefault = true;\n          }\n\n          break;\n\n        case Keys.Home:\n          if (modifier) {\n            if (this.meta.isVirtual) {\n              this.cursor.reset(this.meta.headerRows, 0, false);\n            } else {\n              this.cursor.reset(this.model.firstRow.index, 0, false);\n            }\n          } else {\n            this.cursor.reset(row.index, 0, false);\n          }\n\n          preventDefault = true;\n          break;\n\n        case Keys.End:\n          if (modifier) {\n            if (this.meta.isVirtual) {\n              let lastRowIndex = this.meta.maxLogicalRowIndex;\n\n              if (this.meta.hasDetailTemplate) {\n                lastRowIndex--;\n              }\n\n              this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);\n            } else {\n              this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);\n            }\n          } else {\n            const lastIndex = this.cursor.lastCellIndex(row);\n            const cell = this.model.findCell(lastIndex, row);\n\n            if (cell) {\n              this.cursor.reset(cell.rowIndex, cell.colIndex);\n            } else {\n              this.cursor.reset(row.index, lastIndex);\n            }\n          }\n\n          preventDefault = true;\n          break;\n\n        case Keys.Enter:\n        case Keys.F2:\n          const groupItem = row.groupItem;\n\n          if (groupItem) {\n            this.zone.run(() => this.groupsService.toggleRow(groupItem));\n          } else if (this.cursor.cell.detailExpandCell) {\n            this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));\n          } else {\n            this.enterCell();\n\n            if (!this.cursor.cell.focusGroup.isNavigable()) {\n              preventDefault = true;\n            }\n          }\n\n          break;\n\n        default:\n          if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {\n            this.enterCell();\n          }\n\n      }\n\n      if (preventDefault) {\n        args.preventDefault();\n      }\n    }\n\n    onContentKeydown(args) {\n      if (!this.onCellKeydown(args)) {\n        return;\n      }\n\n      const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);\n\n      if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {\n        this.leaveCell();\n        this.cursor.reset();\n        args.stopPropagation();\n      } else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {\n        this.onCursorKeydown(args);\n\n        if (args.defaultPrevented) {\n          this.leaveCell();\n        }\n      }\n    }\n\n    onCellKeydown(args) {\n      if (this.editService.isEditingCell()) {\n        const confirm = args.keyCode === Keys.Enter;\n        const cancel = args.keyCode === Keys.Escape;\n        const navigate = isNavigationKey(args.keyCode);\n\n        if (confirm) {\n          this.editService.closeCell(args);\n        } else if (cancel) {\n          this.editService.closeCell(args);\n          this.cd.detectChanges();\n        } else if (navigate) {\n          return false;\n        }\n      }\n\n      this.cellKeydown.emit(args);\n      return true;\n    }\n\n    onCursorChanges(args) {\n      this.activeRowIndex = args.rowIndex;\n      const dataRowIndex = this.activeDataRow;\n\n      if (this.meta && this.meta.isVirtual && args.rowIndex >= this.meta.headerRows && this.viewport && !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1) {\n        this.scrollRequestService.scrollTo({\n          row: dataRowIndex\n        });\n      }\n\n      if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {\n        const cell = this.activeCell;\n        const {\n          start,\n          end\n        } = this.model.cellRange(cell);\n\n        if (!cell) {\n          this.virtualCell = true;\n        }\n\n        if (!cell && this.mode !== 0\n        /* Standby */\n        || cell && !this.columnViewport.intersects(start, end)) {\n          this.scrollRequestService.scrollTo({\n            column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0)\n          });\n        }\n      }\n    }\n\n    onFocusOut(args) {\n      if (isVisible(args.target)) {\n        this.mode = 0\n        /* Standby */\n        ;\n      } else {\n        // Focused target is no longer visible,\n        // reset to cursor mode and recapture focus.\n        this.mode = 1\n        /* Cursor */\n        ;\n      }\n\n      this.deactivateElements();\n      this.cursor.announce();\n    }\n\n    onWindowBlur() {\n      this.mode = 0\n      /* Standby */\n      ;\n      this.deactivateElements();\n      this.cursor.announce();\n    }\n\n    onKeydown(args) {\n      if (this.mode === 1\n      /* Cursor */\n      ) {\n        this.onCursorKeydown(args);\n      } else if (this.mode === 2\n      /* Content */\n      ) {\n        this.onContentKeydown(args);\n      }\n    }\n\n    onTabout() {\n      // Tabbed out of the last focusable content element\n      // reset to cursor mode and recapture focus.\n      if (this.cursor.cell.focusGroup.isNavigable()) {\n        // Unless the cell has a single focusable element,\n        // otherwise we'd return to Content mode and enter an endless loop\n        return;\n      }\n\n      this.leaveCell();\n      this.cursor.reset();\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DomEventsService), i0.ɵɵinject(PagerContextService), i0.ɵɵinject(ScrollRequestService), i0.ɵɵinject(GroupsService), i0.ɵɵinject(DetailsService), i0.ɵɵinject(FocusRoot), i0.ɵɵinject(EditService), i0.ɵɵinject(i0.ChangeDetectorRef), i0.ɵɵinject(i1.LocalizationService), i0.ɵɵinject(FocusableDirective, 8));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SelectionService = /*#__PURE__*/(() => {\n  class SelectionService {\n    constructor(domEvents, localDataChangesService, navigationService) {\n      this.domEvents = domEvents;\n      this.localDataChangesService = localDataChangesService;\n      this.navigationService = navigationService;\n      this.changes = new EventEmitter();\n      this.lastSelectionStartIndex = 0;\n      this.currentSelection = [];\n      this.selectAllChecked = false;\n      this.active = false;\n      this.dragging = false;\n      this.addSubscriptions();\n    }\n\n    get enableMarquee() {\n      const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;\n\n      if (!this.settings || checkboxOnly) {\n        return false;\n      }\n\n      const selectableSettings = this.settings.selectable;\n      const dragAndMultiple = typeof selectableSettings === 'object' && isPresent(selectableSettings) && selectableSettings.mode === 'multiple' && selectableSettings.enabled !== false && !selectableSettings.checkboxOnly && selectableSettings.drag;\n      return this.active && dragAndMultiple;\n    }\n\n    init(settings) {\n      this.settings = settings;\n      this.currentSelection = [];\n\n      if (settings.selectable && settings.selectable.enabled !== false) {\n        const iterator = this.getIterator();\n        this._selectAllState = true;\n        let item = iterator.next();\n\n        while (!item.done) {\n          if (item.value && item.value.type === \"data\") {\n            const rowArgs = {\n              dataItem: item.value.data,\n              index: item.value.index\n            };\n\n            if (settings.rowSelected(rowArgs)) {\n              this.currentSelection[item.value.index] = rowArgs;\n            } else {\n              this._selectAllState = undefined;\n            }\n          }\n\n          item = iterator.next();\n        }\n\n        if (this.currentSelection.length === 0) {\n          this._selectAllState = false;\n        }\n      }\n    }\n\n    isSelected(index) {\n      if (this.settings && this.active) {\n        return this.options.enabled && isPresent(this.currentSelection[index]);\n      }\n    }\n\n    handleClick(item, event) {\n      if (this.dragging) {\n        this.dragging = false;\n        return;\n      }\n\n      let ev;\n      const ctrlKey = event.ctrlKey || event.metaKey;\n\n      if (this.options.mode === \"single\" && ctrlKey && this.isSelected(item.index)) {\n        ev = this.toggle(item);\n      } else if (this.options.mode === \"multiple\") {\n        if (ctrlKey && !event.shiftKey) {\n          ev = this.toggle(item);\n        } else if (event.shiftKey) {\n          ev = this.addAllTo(item, ctrlKey);\n        }\n      }\n\n      if (!isPresent(ev)) {\n        ev = this.select(item);\n        this.currentSelection[item.index] = {\n          dataItem: item.data,\n          index: item.index\n        };\n      }\n\n      if (!ev.selectedRows.length && !ev.deselectedRows.length) {\n        return;\n      }\n\n      ev.ctrlKey = ctrlKey;\n      ev.shiftKey = event.shiftKey;\n      this.changes.emit(ev);\n    }\n\n    toggle(item) {\n      let selectedRows = [];\n      let deselectedRows = [];\n      this.lastSelectionStartIndex = item.index;\n      const rowArgs = {\n        dataItem: item.data,\n        index: item.index\n      };\n\n      if (this.isSelected(item.index)) {\n        deselectedRows.push(rowArgs);\n      } else {\n        selectedRows.push(rowArgs);\n      }\n\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n\n    toggleByIndex(index) {\n      const iterator = this.getIterator();\n\n      if (this.selectAllChecked && this.isSelected(index)) {\n        this.selectAllChecked = false;\n      }\n\n      let item = iterator.next();\n\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.index === index) {\n          const itemToToggle = {\n            data: item.value.data,\n            index: item.value.index\n          };\n\n          if (this.isSelected(index) || this.options.mode === \"multiple\") {\n            return this.toggle(itemToToggle);\n          } else {\n            return this.select(itemToToggle);\n          }\n        }\n\n        item = iterator.next();\n      }\n    }\n\n    select(item) {\n      let deselectedRows = [];\n      let selectedRows = [];\n      this.lastSelectionStartIndex = item.index;\n\n      if (!this.isSelected(item.index)) {\n        selectedRows.push({\n          dataItem: item.data,\n          index: item.index\n        });\n      }\n\n      this.currentSelection.forEach(row => {\n        if (row.index !== item.index) {\n          deselectedRows.push(row);\n        }\n      });\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    } //Used to manually deselect removed items\n\n\n    deselect(removedItem) {\n      const iterator = this.getIterator();\n      let item = iterator.next();\n\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.data === removedItem) {\n          const rowArgs = {\n            dataItem: item.value.data,\n            index: item.value.index\n          };\n\n          if (this.isSelected(rowArgs.index)) {\n            let ev = {\n              ctrlKey: false,\n              deselectedRows: [rowArgs],\n              selectedRows: []\n            };\n            this.changes.emit(ev);\n          }\n        }\n\n        item = iterator.next();\n      }\n    }\n\n    addAllTo(item, ctrlKey) {\n      let selectedRows = [];\n      let deselectedRows = [];\n      const start = Math.min(this.lastSelectionStartIndex, item.index);\n      const end = Math.max(this.lastSelectionStartIndex, item.index);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n\n          if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey) {\n            deselectedRows.push(rowArgs);\n          }\n\n          if (idx >= start && idx <= end && !this.isSelected(idx)) {\n            selectedRows.push(rowArgs);\n          }\n        }\n\n        next = iterator.next();\n      }\n\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n\n    updateAll(selectAllChecked) {\n      this.selectAllChecked = selectAllChecked;\n      let selectedRows = [];\n      let deselectedRows = [];\n      const iterator = this.getIterator();\n      let next = iterator.next();\n\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n\n          if (this.isSelected(idx) && !selectAllChecked) {\n            deselectedRows.push(rowArgs);\n          }\n\n          if (!this.isSelected(idx) && selectAllChecked) {\n            selectedRows.push(rowArgs);\n          }\n        }\n\n        next = iterator.next();\n      }\n\n      if (!selectedRows.length && !deselectedRows.length) {\n        return;\n      }\n\n      let ev = {\n        ctrlKey: true,\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows,\n        shiftKey: true\n      };\n      this.changes.emit(ev);\n    }\n\n    selectRange(startIndex, endIndex) {\n      let selectedRows = [];\n      let deselectedRows = [];\n      const start = Math.min(startIndex, endIndex);\n      const end = Math.max(startIndex, endIndex);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const rowArgs = {\n            dataItem: next.value.data,\n            index: idx\n          };\n\n          if ((idx < start || idx > end) && this.isSelected(idx)) {\n            deselectedRows.push(rowArgs);\n          }\n\n          if (idx >= start && idx <= end && !this.isSelected(idx)) {\n            selectedRows.push(rowArgs);\n          }\n        }\n\n        next = iterator.next();\n      }\n\n      return {\n        deselectedRows: deselectedRows,\n        selectedRows: selectedRows\n      };\n    }\n\n    get selectAllState() {\n      return this._selectAllState;\n    }\n\n    get selected() {\n      return this.currentSelection.map(item => {\n        return item.index;\n      }).filter(n => typeof n === \"number\");\n    }\n\n    get options() {\n      const defaultOptions = {\n        checkboxOnly: false,\n        enabled: true,\n        mode: \"multiple\"\n      };\n\n      if (!isPresent(this.settings)) {\n        return defaultOptions;\n      }\n\n      if (typeof this.settings.selectable === 'boolean') {\n        return {\n          checkboxOnly: false,\n          enabled: this.settings.selectable,\n          mode: \"multiple\"\n        };\n      } else {\n        return Object.assign(defaultOptions, this.settings.selectable);\n      }\n    }\n\n    ngOnDestroy() {\n      this.removeSubscriptions();\n    }\n\n    targetArgs() {\n      return {\n        index: this.mouseDownEventArgs.rowIndex,\n        dataItem: this.mouseDownEventArgs.dataItem\n      };\n    }\n\n    addSubscriptions() {\n      if (!this.cellClickSubscription) {\n        this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n          if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {\n            if (this.active) {\n              this.handleClick({\n                index: args.rowIndex,\n                data: args.dataItem\n              }, args.originalEvent);\n            }\n          }\n        });\n      }\n\n      if (!this.mousedownSubscription) {\n        this.mousedownSubscription = this.domEvents.cellMousedown.subscribe(args => {\n          this.mouseDownEventArgs = args;\n\n          if (this.options.enabled && (!this.options.mode || this.options.mode === \"multiple\") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {\n            if (this.active) {\n              args.originalEvent.preventDefault();\n              this.navigationService.focusCellByElement(args.originalEvent.target);\n            }\n          }\n        });\n      }\n\n      if (this.localDataChangesService && !this.dataChangedSubscription) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(args => {\n          if (this.active) {\n            if (isPresent(args.action) && args.action === 'remove') {\n              this.deselect(args.item);\n            }\n          }\n        });\n      }\n    }\n\n    getIterator() {\n      const accessor = this.settings.view.accessor();\n\n      if (!accessor) {\n        return;\n      }\n\n      return accessor[iterator]();\n    }\n\n    removeSubscriptions() {\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n        this.cellClickSubscription = null;\n      }\n\n      if (this.mousedownSubscription) {\n        this.mousedownSubscription.unsubscribe();\n        this.mousedownSubscription = null;\n      }\n\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n        this.dataChangedSubscription = null;\n      }\n    }\n\n  }\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)(i0.ɵɵinject(DomEventsService), i0.ɵɵinject(LocalDataChangesService), i0.ɵɵinject(NavigationService));\n  };\n\n  SelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: SelectionService.ɵfac\n  });\n  return SelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet CellSelectionService = /*#__PURE__*/(() => {\n  class CellSelectionService {\n    constructor(domEvents, localDataChangesService, navigationService) {\n      this.domEvents = domEvents;\n      this.localDataChangesService = localDataChangesService;\n      this.navigationService = navigationService;\n      this.changes = new EventEmitter();\n      this.mouseUpEvent = new EventEmitter();\n      this.currentSelection = [];\n      this.active = false;\n      this.dragging = false;\n      this.dragSelectDeselect = false;\n      this.lastSelectionItem = {\n        itemKey: 0,\n        columnKey: 0\n      };\n      this.lastSelectionItemRowIndex = 0;\n      this.lastSelectionItemColIndex = 0;\n      this.addSubscriptions();\n    }\n\n    get enableMarquee() {\n      const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;\n\n      if (!this.settings || checkboxOnly) {\n        return false;\n      }\n\n      const selectableSettings = this.settings.selectable;\n      const dragAndMultiple = typeof selectableSettings === 'object' && isPresent(selectableSettings) && selectableSettings.mode === 'multiple' && selectableSettings.cell && selectableSettings.enabled !== false && selectableSettings.drag;\n      return this.active && dragAndMultiple;\n    }\n\n    init(settings) {\n      this.settings = settings;\n      this.currentSelection = [];\n\n      if (settings.selectable && settings.selectable.enabled !== false) {\n        const iterator = this.getIterator();\n        let item = iterator.next();\n\n        while (!item.done) {\n          if (item.value && item.value.type === \"data\") {\n            const rowArgs = {\n              dataItem: item.value.data,\n              index: item.value.index\n            };\n            settings.columns.forEach(col => {\n              const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);\n\n              if (selectedCellArgs.selected) {\n                this.currentSelection.push(selectedCellArgs.item);\n              }\n            });\n          }\n\n          item = iterator.next();\n        }\n      }\n    }\n\n    isCellSelected(item, col) {\n      if (this.settings && this.active) {\n        const selectedCellArgs = this.settings.cellSelected({\n          dataItem: item.data,\n          index: item.index\n        }, col, col.leafIndex);\n        return this.options.enabled && selectedCellArgs.selected;\n      }\n\n      return false;\n    }\n\n    handleClick(item, event) {\n      if (this.dragging) {\n        this.dragging = false;\n        return;\n      }\n\n      let ev;\n      const ctrlKey = event.ctrlKey || event.metaKey;\n\n      if (this.options.mode === \"single\" && ctrlKey && this.isCellSelected(item, item.column)) {\n        ev = this.toggle(item);\n      } else if (this.options.mode === \"multiple\") {\n        if (ctrlKey && !event.shiftKey) {\n          ev = this.toggle(item);\n        } else if (event.shiftKey) {\n          const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);\n          const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);\n          const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);\n          const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);\n          ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);\n        }\n      }\n\n      if (!isPresent(ev)) {\n        ev = this.select(item);\n        this.currentSelection = [this.lastSelectionItem];\n      }\n\n      if (!ev.selectedCells.length && !ev.deselectedCells.length) {\n        return;\n      }\n\n      ev.ctrlKey = ctrlKey;\n      ev.shiftKey = event.shiftKey;\n      this.changes.emit(ev);\n    }\n\n    toggle(item) {\n      let selectedCells = [];\n      let deselectedCells = [];\n      this.lastSelectionItem = this.settings.cellSelected({\n        dataItem: item.data,\n        index: item.index\n      }, item.column, item.column.leafIndex).item;\n      this.lastSelectionItemRowIndex = item.index;\n      this.lastSelectionItemColIndex = item.column.leafIndex;\n\n      if (this.isCellSelected(item, item.column)) {\n        deselectedCells.push(this.lastSelectionItem);\n      } else {\n        selectedCells.push(this.lastSelectionItem);\n      }\n\n      return {\n        deselectedCells,\n        selectedCells\n      };\n    }\n\n    select(item) {\n      const selectedCells = [];\n      const deselectedCells = [];\n      this.lastSelectionItem = this.settings.cellSelected({\n        dataItem: item.data,\n        index: item.index\n      }, item.column, item.column.leafIndex).item;\n      this.lastSelectionItemRowIndex = item.index;\n      this.lastSelectionItemColIndex = item.column.leafIndex;\n\n      if (!this.isCellSelected(item, item.column)) {\n        selectedCells.push(this.lastSelectionItem);\n      }\n\n      this.currentSelection.forEach(selectedItem => {\n        if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {\n          deselectedCells.push(selectedItem);\n        }\n      });\n      return {\n        deselectedCells,\n        selectedCells\n      };\n    } //Used to manually deselect removed items\n\n\n    deselect(removedItem) {\n      const iterator = this.getIterator();\n      let item = iterator.next();\n      let rowArgs;\n\n      while (!item.done) {\n        if (item.value && item.value.type === \"data\" && item.value.data === removedItem) {\n          rowArgs = {\n            dataItem: item.value.data,\n            index: item.value.index\n          };\n          break;\n        }\n\n        item = iterator.next();\n      }\n\n      if (rowArgs) {\n        const cellsToRemove = this.currentSelection.filter(selectedItem => {\n          const contender = this.settings.cellSelected(rowArgs, null, null).item;\n          return selectedItem.itemKey === contender.itemKey;\n        });\n\n        if (cellsToRemove.length) {\n          let ev = {\n            ctrlKey: false,\n            deselectedCells: cellsToRemove,\n            selectedCells: []\n          };\n          this.changes.emit(ev);\n        }\n      }\n    }\n\n    selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex) {\n      const selectedCells = [];\n      const deselectedCells = [];\n      const selectionStartRow = Math.min(startRowIndex, endRowIndex);\n      const selectionStartCol = Math.min(startColIndex, endColIndex);\n      const selectionEndRow = Math.max(startRowIndex, endRowIndex);\n      const selectionEndCol = Math.max(startColIndex, endColIndex);\n      const iterator = this.getIterator();\n      let next = iterator.next();\n\n      while (!next.done) {\n        if (next.value && next.value.type === \"data\") {\n          const idx = next.value.index;\n          const data = next.value.data;\n          const rowArgs = {\n            dataItem: data,\n            index: idx\n          };\n          this.settings.columns.forEach(col => {\n            const {\n              item\n            } = this.settings.cellSelected(rowArgs, col, col.leafIndex);\n            const selected = this.isCellSelected(next.value, col);\n            const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;\n            const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;\n            const isInSelectionRect = isInRowRange && isInColRange;\n\n            if (!isInSelectionRect && selected) {\n              deselectedCells.push(item);\n            }\n\n            if (isInSelectionRect && !selected) {\n              selectedCells.push(item);\n            }\n          });\n        }\n\n        next = iterator.next();\n      }\n\n      return {\n        deselectedCells,\n        selectedCells\n      };\n    }\n\n    get options() {\n      const defaultOptions = {\n        checkboxOnly: false,\n        enabled: true,\n        mode: \"multiple\"\n      };\n\n      if (!isPresent(this.settings)) {\n        return defaultOptions;\n      }\n\n      if (typeof this.settings.selectable === 'boolean') {\n        return {\n          checkboxOnly: false,\n          enabled: this.settings.selectable,\n          mode: \"multiple\"\n        };\n      } else {\n        return Object.assign(defaultOptions, this.settings.selectable);\n      }\n    }\n\n    ngOnDestroy() {\n      this.removeSubscriptions();\n    }\n\n    addSubscriptions() {\n      if (!this.cellClickSubscription) {\n        this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n          if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {\n            if (this.active) {\n              this.handleClick({\n                index: args.rowIndex,\n                data: args.dataItem,\n                column: args.column\n              }, args.originalEvent);\n            }\n          }\n        });\n      }\n\n      if (!this.mousedownSubscription) {\n        this.mousedownSubscription = this.domEvents.cellMousedown.subscribe(args => {\n          this.mouseDownEventArgs = args;\n\n          if (this.options.enabled && (!this.options.mode || this.options.mode === \"multiple\") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {\n            if (this.active) {\n              args.originalEvent.preventDefault();\n              this.navigationService.focusCellByElement(args.originalEvent.target);\n            }\n          }\n        });\n      }\n\n      if (this.localDataChangesService && !this.dataChangedSubscription) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(args => {\n          if (this.active) {\n            if (isPresent(args.action) && args.action === 'remove') {\n              this.deselect(args.item);\n            }\n          }\n        });\n      }\n    }\n\n    getIterator() {\n      const accessor = this.settings.view.accessor();\n\n      if (!accessor) {\n        return;\n      }\n\n      return accessor[iterator]();\n    }\n\n    removeSubscriptions() {\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n        this.cellClickSubscription = null;\n      }\n\n      if (this.mousedownSubscription) {\n        this.mousedownSubscription.unsubscribe();\n        this.mousedownSubscription = null;\n      }\n\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n        this.dataChangedSubscription = null;\n      }\n    }\n\n  }\n\n  CellSelectionService.ɵfac = function CellSelectionService_Factory(t) {\n    return new (t || CellSelectionService)(i0.ɵɵinject(DomEventsService), i0.ɵɵinject(LocalDataChangesService), i0.ɵɵinject(NavigationService));\n  };\n\n  CellSelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CellSelectionService,\n    factory: CellSelectionService.ɵfac\n  });\n  return CellSelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst createElement$1 = () => {\n  const marquee = document.createElement(\"div\");\n  marquee.className = \"k-marquee\";\n  const marqueeColor = document.createElement(\"div\");\n  marqueeColor.className = \"k-marquee-color\";\n  marquee.appendChild(marqueeColor);\n  return marquee;\n};\n\nconst POINTER_OFFSET = 2;\nconst MINIMAL_DRAG_DISTANCE = 5;\nconst offsets = {\n  topLeft: {\n    x: POINTER_OFFSET,\n    y: POINTER_OFFSET\n  },\n  topRight: {\n    x: -POINTER_OFFSET,\n    y: POINTER_OFFSET\n  },\n  bottomLeft: {\n    x: POINTER_OFFSET,\n    y: -POINTER_OFFSET\n  },\n  bottomRight: {\n    x: -POINTER_OFFSET,\n    y: -POINTER_OFFSET\n  }\n};\n/**\n * @hidden\n */\n\nlet GridMarqueeDirective = /*#__PURE__*/(() => {\n  class GridMarqueeDirective {\n    constructor(draggable, selection, cellSelection, domEvents) {\n      this.draggable = draggable;\n      this.selection = selection;\n      this.cellSelection = cellSelection;\n      this.domEvents = domEvents;\n      this.selectionStarted = false;\n    }\n\n    get webkitUserSelection() {\n      return this.cellSelection.enableMarquee || this.selection.enableMarquee ? 'none' : null;\n    }\n\n    get userSelection() {\n      return this.cellSelection.enableMarquee || this.selection.enableMarquee;\n    }\n\n    ngOnInit() {\n      this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));\n      this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.clean();\n    }\n\n    start(args) {\n      if (args.originalEvent.target.classList.contains('k-checkbox')) {\n        this.pressArgs = null;\n        return;\n      }\n\n      this.pressArgs = args;\n      this.pressTarget = null;\n    }\n\n    moveMarquee(args) {\n      if (!this.pressTarget) {\n        this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;\n      }\n\n      const press = this.pressArgs;\n\n      if (!press) {\n        return;\n      }\n\n      if (!this.selectionStarted) {\n        const distance = Math.sqrt(Math.pow(args.pageX - press.pageX, 2) + Math.pow(args.pageY - press.pageY, 2));\n\n        if (distance > MINIMAL_DRAG_DISTANCE) {\n          this.selectionStarted = true;\n          this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1))).subscribe(this.endSelection.bind(this));\n        } else {\n          return;\n        }\n      }\n\n      this.initMarquee();\n      const element = this.marqueeElement;\n      const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);\n      let left = Math.min(args.pageX, press.pageX);\n      let top = Math.min(args.pageY, press.pageY);\n      const width = Math.abs(args.pageX - press.pageX);\n      const height = Math.abs(args.pageY - press.pageY);\n\n      if (marqueeQuadrant) {\n        left += offsets[marqueeQuadrant].x;\n        top += offsets[marqueeQuadrant].y;\n      }\n\n      element.style.left = `${left}px`;\n      element.style.top = `${top}px`;\n      element.style.width = `${width}px`;\n      element.style.height = `${height}px`;\n    }\n\n    endSelection(args) {\n      if (args.type === 'mouseup' || args.type === 'touchend') {\n        if (this.cellSelection.active) {\n          this.cellSelection.dragging = true;\n          this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex));\n        } else if (this.selection.active) {\n          this.selection.dragging = true;\n          this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex));\n        }\n      }\n\n      this.clean();\n    }\n\n    clean() {\n      if (this.marqueeElement) {\n        document.body.removeChild(this.marqueeElement);\n        this.marqueeElement = null;\n      }\n\n      if (this.dragEndSubscription) {\n        this.dragEndSubscription.unsubscribe();\n      }\n\n      this.dragEndSubscription = null;\n      this.pressTarget = null;\n      this.pressArgs = null;\n      this.selectionStarted = false; // eslint-disable-next-line no-unused-expressions\n\n      this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;\n    }\n\n    initMarquee() {\n      if (!this.marqueeElement) {\n        this.marqueeElement = createElement$1();\n        document.body.appendChild(this.marqueeElement);\n      }\n    }\n\n    getMarqueeQuadrant(pointerX, pointerY, startX, startY) {\n      const leftHalf = pointerX < startX;\n      const rightHalf = pointerX > startX;\n      const topHalf = pointerY < startY;\n      const bottomHalf = pointerY > startY;\n\n      if (leftHalf && topHalf) {\n        return 'topLeft';\n      }\n\n      if (leftHalf && bottomHalf) {\n        return 'bottomLeft';\n      }\n\n      if (rightHalf && topHalf) {\n        return 'topRight';\n      }\n\n      if (rightHalf && bottomHalf) {\n        return 'bottomRight';\n      }\n\n      return null;\n    }\n\n  }\n\n  GridMarqueeDirective.ɵfac = function GridMarqueeDirective_Factory(t) {\n    return new (t || GridMarqueeDirective)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(DomEventsService));\n  };\n\n  GridMarqueeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GridMarqueeDirective,\n    selectors: [[\"\", \"kendoGridSelectionMarquee\", \"\"]],\n    hostVars: 4,\n    hostBindings: function GridMarqueeDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"-webkit-user-select\", ctx.webkitUserSelection);\n        i0.ɵɵclassProp(\"user-select-none\", ctx.userSelection);\n      }\n    }\n  });\n  return GridMarqueeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass ZoneAwareEventEmitter extends EventEmitter {\n  constructor(ngZone, isAsync = false) {\n    super(isAsync);\n    this.ngZone = ngZone;\n  }\n\n  subscribe(generatorOrNext, error, complete) {\n    let schedulerFn;\n\n    let errorFn = _ => null;\n\n    let completeFn = () => null;\n\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = value => {\n        this.ngZone.run(() => generatorOrNext.next(value));\n      };\n\n      if (generatorOrNext.error) {\n        errorFn = err => {\n          this.ngZone.run(() => generatorOrNext.error(err));\n        };\n      }\n\n      if (generatorOrNext.complete) {\n        completeFn = () => {\n          this.ngZone.run(() => generatorOrNext.complete());\n        };\n      }\n    } else {\n      schedulerFn = value => {\n        this.ngZone.run(() => generatorOrNext(value));\n      };\n\n      if (error) {\n        errorFn = err => {\n          this.ngZone.run(() => error(err));\n        };\n      }\n\n      if (complete) {\n        completeFn = () => {\n          this.ngZone.run(() => complete());\n        };\n      }\n    }\n\n    return super.subscribe(schedulerFn, errorFn, completeFn);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-grid',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654697320,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Represents the column cell template of the Grid ([more information and example]({% slug templates_columns_grid %}#toc-cell-template)).\n * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag\n * with the `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex=\"columnIndex\"` syntax.\n * - `rowIndex`&mdash;The current data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.\n * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridCellTemplate let-dataItem let-rowIndex=\"rowIndex\">\n *                     Data Row #: {{rowIndex}} /\n *                     <strong>{{dataItem.ProductName}}</strong>\n *                     ({{dataItem.Discontinued ? \"discontinued\" : \"active\"}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\n\nlet CellTemplateDirective = /*#__PURE__*/(() => {\n  class CellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) {\n    return new (t || CellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  CellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CellTemplateDirective,\n    selectors: [[\"\", \"kendoGridCellTemplate\", \"\"]]\n  });\n  return CellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the group-header cell template of the Grid which helps to customize the content of the group header item.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderTemplate`\n * directive inside `<kendo-grid-column>`.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n * - `index`&mdash;The index of the current group.\n * - `expanded`&mdash;A boolean value indicating if the group is currently expanded.\n * ([see example]({% slug groupable_grid_with_aggregates %})).\n *\n * @example\n * ```ts\n * import { process } from '@progress/kendo-data-query';\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridGroupHeaderTemplate let-group let-field=\"field\" let-value=\"value\">\n *                    <strong>{{field}}</strong>: {{value}}\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public groups = [{ field: \"ProductName\" }];\n *\n *     public gridData = process([{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ], {\n *      group: this.groups\n *     });\n * }\n *\n * ```\n */\n\n\nlet GroupHeaderTemplateDirective = /*#__PURE__*/(() => {\n  class GroupHeaderTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) {\n    return new (t || GroupHeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  GroupHeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupHeaderTemplateDirective,\n    selectors: [[\"\", \"kendoGridGroupHeaderTemplate\", \"\"]]\n  });\n  return GroupHeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the group-header column template of the Grid which helps to customize the content of the group headers.\n * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`\n * directive inside `<kendo-grid-column>`. ([See example]({% slug groupable_grid_with_aggregates %})).\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `group`&mdash;The current group item.\n * - `field`&mdash;The name of the field by which data is grouped.\n * - `value`&mdash;The current group value.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * ```ts\n * <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *     <ng-template kendoGridGroupHeaderColumnTemplate let-group=\"group\" let-aggregates=\"aggregates\">\n *         <span title=\"Group Header Column Template for ProductName\">\n *             Count: {{ aggregates.Discontinued.count }}\n *         </span>\n *     </ng-template>\n * </kendo-grid-column>\n * ```\n */\n\n\nlet GroupHeaderColumnTemplateDirective = /*#__PURE__*/(() => {\n  class GroupHeaderColumnTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) {\n    return new (t || GroupHeaderColumnTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  GroupHeaderColumnTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupHeaderColumnTemplateDirective,\n    selectors: [[\"\", \"kendoGridGroupHeaderColumnTemplate\", \"\"]]\n  });\n  return GroupHeaderColumnTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the column edit-cell template of the Grid ([see example]({% slug editing_template_forms_grid %})).\n * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`\n * tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag.\n *\n * The template context is set to the current form group and the following additional fields are passed:\n * - `formGroup`&mdash;The current [FormGroup]({{ site.data.urls.angular['formgroupapi'] }}).\n * Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-formGroup`.\n * If you use the Grid inside [Template-Driven Forms]({{ site.data.urls.angular['forms'] }}), it will be `undefined`.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex` is `-1`. Use it as an alias for a template variable by utilizing the `let-rowIndex=\"rowIndex\"` syntax.\n * - `dataItem`&mdash;The current data item. Use it as an alias for a template variable by utilizing the `let-dataItem=\"dataItem\"` syntax.\n * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column=\"column\"` syntax.\n * - `isNew`&mdash;The state of the current item. Use it as an alias for a template variable by utilizing the `let-isNew=\"isNew\"` syntax.\n */\n\n\nlet EditTemplateDirective = /*#__PURE__*/(() => {\n  class EditTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  EditTemplateDirective.ɵfac = function EditTemplateDirective_Factory(t) {\n    return new (t || EditTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  EditTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: EditTemplateDirective,\n    selectors: [[\"\", \"kendoGridEditTemplate\", \"\"]]\n  });\n  return EditTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the column group footer cell template of the Grid which helps to customize the group footer cell for the column.\n * To define the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive\n * inside `<kendo-grid-column>`.\n *\n * The template context is set to the current aggregates and the following additional fields are passed:\n * - `column`&mdash;Defines an instance of the `ColumnComponent` option.\n * - `field`&mdash;The current column field name.\n * - `group`&mdash;The current group data item.\n * - `aggregates`&mdash;All aggregate values for the current group.\n *\n * @example\n * ```ts-preview\n * import { process } from '@progress/kendo-data-query';\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" [group]=\"groups\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridGroupFooterTemplate let-aggregates let-field=\"field\">\n *                    Count: {{aggregates[field].count}}\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public groups = [{ field: \"ProductName\", aggregates: [{ field: \"ProductName\", aggregate: \"count\" }] }];\n *\n *     public gridData = process([{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ], {\n *      group: this.groups\n *     });\n * }\n * ```\n */\n\n\nlet GroupFooterTemplateDirective = /*#__PURE__*/(() => {\n  class GroupFooterTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) {\n    return new (t || GroupFooterTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  GroupFooterTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupFooterTemplateDirective,\n    selectors: [[\"\", \"kendoGridGroupFooterTemplate\", \"\"]]\n  });\n  return GroupFooterTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the column header cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).\n * Helps to customize the table header cell for the column.\n * To define a header template, nest an `<ng-template>` tag with the\n * [kendoGridHeaderTemplate]({% slug api_grid_headertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.\n *\n *  The template context is set to the current column and then the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *                 <ng-template kendoGridHeaderTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\n\n\nlet HeaderTemplateDirective = /*#__PURE__*/(() => {\n  class HeaderTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) {\n    return new (t || HeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  HeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HeaderTemplateDirective,\n    selectors: [[\"\", \"kendoGridHeaderTemplate\", \"\"]]\n  });\n  return HeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the column footer cell template of the Grid\n * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).\n * Helps to customize the table footer cell for the column.\n * To define a footer template, nest an `<ng-template>` tag with the\n * [kendoGridFooterTemplate]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.\n *\n * The template context is set to the current column and the following additional fields are passed:\n * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.\n * * `columnIndex`&mdash;Defines the current column index.\n *\n * For more information on how to display aggregates in the footer of the Grid,\n * refer to the article on [aggregates]({% slug groupable_grid_with_aggregates %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\" scrollable=\"none\">\n *             <kendo-grid-column field=\"ProductName\">\n *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *                 <ng-template kendoGridFooterTemplate let-column let-columnIndex=\"columnIndex\">\n *                   {{column.field}}({{columnIndex}})\n *                 </ng-template>\n *             </kendo-grid-column>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\n\n\nlet FooterTemplateDirective = /*#__PURE__*/(() => {\n  class FooterTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) {\n    return new (t || FooterTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  FooterTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FooterTemplateDirective,\n    selectors: [[\"\", \"kendoGridFooterTemplate\", \"\"]]\n  });\n  return FooterTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template for the column menu in the Grid. Provides an option for\n * customizing the content of the column menu for all or for specific columns.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuTemplate` directive inside the `kendo-grid` or the `<kendo-grid-column>` component.\n *\n * The template context is passes through the following fields:\n * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}).\n * - `column`&mdash;Represents the Grid column.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\">\n *              <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *                  <kendo-grid-columnmenu-lock [service]=\"service\">\n *                  </kendo-grid-columnmenu-lock>\n *                  <kendo-grid-columnmenu-sort [service]=\"service\">\n *                  </kendo-grid-columnmenu-sort>\n *              </ng-template>\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuTemplateDirective = /*#__PURE__*/(() => {\n  class ColumnMenuTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ColumnMenuTemplateDirective.ɵfac = function ColumnMenuTemplateDirective_Factory(t) {\n    return new (t || ColumnMenuTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ColumnMenuTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnMenuTemplateDirective,\n    selectors: [[\"\", \"kendoGridColumnMenuTemplate\", \"\"]]\n  });\n  return ColumnMenuTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Incremented each time the service is instantiated.\n\n\nlet sequence = 0;\n/**\n * @hidden\n */\n\nlet IdService = /*#__PURE__*/(() => {\n  class IdService {\n    constructor() {\n      this.prefix = `k-grid${sequence++}`;\n    }\n\n    gridId() {\n      return this.prefix;\n    }\n\n    cellId(rowIndex, colIndex) {\n      return `${this.prefix}-r${rowIndex}c${colIndex}`;\n    }\n\n    selectionCheckboxId(itemIndex) {\n      return `${this.prefix}-checkbox${itemIndex}`;\n    }\n\n    selectAllCheckboxId() {\n      return `${this.prefix}-select-all`;\n    }\n\n  }\n\n  IdService.ɵfac = function IdService_Factory(t) {\n    return new (t || IdService)();\n  };\n\n  IdService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IdService,\n    factory: IdService.ɵfac\n  });\n  return IdService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst isSpanColumn = column => column.isSpanColumn;\n/**\n * @hidden\n */\n\n\nconst isCheckboxColumn = column => column.isCheckboxColumn;\n\nconst isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);\n/**\n * The base class for the column components of the Grid.\n */\n\n\nlet ColumnBase = /*#__PURE__*/(() => {\n  class ColumnBase {\n    /**\n     * @hidden\n     */\n    constructor(parent, idService) {\n      this.parent = parent;\n      /**\n       * @hidden\n       */\n\n      this.matchesMedia = true;\n      /**\n       * The column index after reordering.\n       *\n       * > `orderIndex` is a read-only property. Setting this field does not affect column order.\n       */\n\n      this.orderIndex = 0;\n      /**\n       * @hidden\n       */\n\n      this.isColumnGroup = false;\n      /**\n       * @hidden\n       */\n\n      this.isSpanColumn = false;\n      /**\n       * Indicates whether the column is resizable.\n       * @default true\n       */\n\n      this.resizable = true;\n      /**\n       * Indicates whether the column is reorderable.\n       * @default true\n       */\n\n      this.reorderable = true;\n      /**\n       * The width (in pixels) below which the user is not able to resize the column by using the UI.\n       */\n\n      this.minResizableWidth = 10;\n      this._locked = false;\n      /**\n       * Determines whether the column will be always visible when scrolling the Grid horizontally.\n       *\n       * @default false\n       */\n\n      this.sticky = false;\n      /**\n       * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.\n       */\n\n      this.lockable = true;\n      /**\n       * Specifies if the column can be stuck or unstuck from the column menu.\n       */\n\n      this.stickable = true;\n      /**\n       * Specifies if the column menu will be shown for the column.\n       */\n\n      this.columnMenu = true;\n      /**\n       * Specifies if the column will be included in the column-chooser list.\n       */\n\n      this.includeInChooser = true;\n      /**\n       * @hidden\n       */\n\n      this.headerTemplates = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.columnMenuTemplates = new QueryList();\n      this.idService = idService;\n\n      if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {\n        throw new Error('Columns can be nested only inside ColumnGroupComponent');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set leafIndex(value) {\n      this._leafIndex = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get leafIndex() {\n      return this._leafIndex;\n    }\n    /**\n     * The width of the column (in pixels).\n     */\n\n\n    set width(value) {\n      if (typeof value === 'string') {\n        const parsedValue = this._width = parseInt(value, 10);\n\n        if (isDevMode()) {\n          console.warn(`Expected numeric value for column width, but got a string \"${value}\". Treating as ${parsedValue}px.`);\n        }\n      } else {\n        this._width = value;\n      }\n    }\n\n    get width() {\n      return this._width;\n    }\n    /**\n     * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).\n     *\n     * @default false\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid [data]=\"gridData\" [scrollable]=\"scrollable\" style=\"height: 200px\">\n     *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\" [locked]=\"true\">\n     *          </kendo-grid-column>\n     *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\" [width]=\"200\">\n     *          </kendo-grid-column>\n     *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" [width]=\"230\">\n     *          </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     *\n     * class AppComponent {\n     *    public gridData: any[];\n     *\n     *    constructor() {\n     *        this.gridData = products;\n     *    }\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     *\n     * ```\n     */\n\n\n    set locked(value) {\n      this._locked = value;\n    }\n\n    get locked() {\n      return this._locked;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get level() {\n      if (this.parent && isSpanColumn(this.parent)) {\n        return this.parent.level;\n      }\n\n      return this.parent ? this.parent.level + 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isLocked() {\n      return this.parent ? this.parent.isLocked : this.locked;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colspan() {\n      return 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    rowspan(totalColumnLevels) {\n      return this.level < totalColumnLevels ? totalColumnLevels - this.level + 1 : 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get headerTemplateRef() {\n      const template = this.headerTemplates.first;\n      return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get footerTemplateRef() {\n      return this.footerTemplate ? this.footerTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnMenuTemplateRef() {\n      const template = this.columnMenuTemplates.first;\n      return template ? template.templateRef : null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get displayTitle() {\n      return this.title;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isVisible() {\n      return !this.hidden && this.matchesMedia;\n    }\n\n  }\n\n  ColumnBase.ɵfac = function ColumnBase_Factory(t) {\n    return new (t || ColumnBase)(i0.ɵɵdirectiveInject(ColumnBase), i0.ɵɵdirectiveInject(IdService));\n  };\n\n  ColumnBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnBase,\n    selectors: [[\"kendo-grid-column-base\"]],\n    contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);\n      }\n    },\n    inputs: {\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      minResizableWidth: \"minResizableWidth\",\n      title: \"title\",\n      width: \"width\",\n      autoSize: \"autoSize\",\n      locked: \"locked\",\n      sticky: \"sticky\",\n      hidden: \"hidden\",\n      media: \"media\",\n      lockable: \"lockable\",\n      stickable: \"stickable\",\n      columnMenu: \"columnMenu\",\n      includeInChooser: \"includeInChooser\",\n      style: \"style\",\n      headerStyle: \"headerStyle\",\n      filterStyle: \"filterStyle\",\n      footerStyle: \"footerStyle\",\n      cssClass: [\"class\", \"cssClass\"],\n      headerClass: \"headerClass\",\n      filterClass: \"filterClass\",\n      footerClass: \"footerClass\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ColumnBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ColumnBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the filter-cell template ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-rows)).\n */\n\n\nlet FilterCellTemplateDirective = /*#__PURE__*/(() => {\n  class FilterCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  FilterCellTemplateDirective.ɵfac = function FilterCellTemplateDirective_Factory(t) {\n    return new (t || FilterCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  FilterCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterCellTemplateDirective,\n    selectors: [[\"\", \"kendoGridFilterCellTemplate\", \"\"]]\n  });\n  return FilterCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the filter-menu template\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-customizing-filter-menus)).\n */\n\n\nlet FilterMenuTemplateDirective = /*#__PURE__*/(() => {\n  class FilterMenuTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  FilterMenuTemplateDirective.ɵfac = function FilterMenuTemplateDirective_Factory(t) {\n    return new (t || FilterMenuTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  FilterMenuTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterMenuTemplateDirective,\n    selectors: [[\"\", \"kendoGridFilterMenuTemplate\", \"\"]]\n  });\n  return FilterMenuTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction isColumnComponent(column) {\n  return isPresent(column.field);\n}\n/**\n * Represents the columns of the [Angular Data Grid]({% slug overview_grid %}).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" [width]=\"230\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"Discontinued\" [width]=\"120\">\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *              </ng-template>\n *          </kendo-grid-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\n\n\nlet ColumnComponent = /*#__PURE__*/(() => {\n  class ColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      /**\n       * Allows the column headers to be clicked and the `sortChange` event emitted.\n       * You have to handle the `sortChange` event yourself and sort the data.\n       */\n\n      this.sortable = true;\n      /**\n       * Determines if the column can be dragged to the group panel. The default value is `true`.\n       * If set to `false`, you can group the columns by the column field by using the API of the Grid.\n       */\n\n      this.groupable = true;\n      /**\n       * Defines the editor type ([see example]({% slug editing_reactive_forms_grid %}#toc-setup)).\n       * Used when the column enters the edit mode. The default value is `text`.\n       *\n       * @example\n       * ```html-no-run\n       * <kendo-grid>\n       *    <kendo-grid-column field=\"UnitPrice\" editor=\"numeric\">\n       *    </kendo-grid-column>\n       * </kendo-grid>\n       * ```\n       */\n\n      this.editor = 'text';\n      /**\n       * Defines the filter type that is displayed inside the filter row. The default value is `text`.\n       *\n       * @example\n       * ```html-no-run\n       * <kendo-grid>\n       *    <kendo-grid-column field=\"UnitPrice\" filter=\"numeric\">\n       *    </kendo-grid-column>\n       * </kendo-grid>\n       * ```\n       */\n\n      this.filter = 'text';\n      /**\n       * Defines if a filter UI will be displayed for this column. The default value is `true`.\n       *\n       * @example\n       * ```html-no-run\n       * <kendo-grid>\n       *    <kendo-grid-column field=\"UnitPrice\" [filterable]=\"false\">\n       *    </kendo-grid-column>\n       * </kendo-grid>\n       * ```\n       */\n\n      this.filterable = true;\n      /**\n       * Defines whether the column is editable. The default value is `true`.\n       *\n       * @example\n       * ```html-no-run\n       * <kendo-grid>\n       *    <kendo-grid-column field=\"UnitPrice\" [editable]=\"false\">\n       *    </kendo-grid-column>\n       * </kendo-grid>\n       * ```\n       */\n\n      this.editable = true;\n    }\n\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n\n    get groupHeaderTemplateRef() {\n      return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;\n    }\n\n    get groupHeaderColumnTemplateRef() {\n      return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;\n    }\n\n    get groupFooterTemplateRef() {\n      return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;\n    }\n\n    get editTemplateRef() {\n      return this.editTemplate ? this.editTemplate.templateRef : undefined;\n    }\n\n    get filterCellTemplateRef() {\n      return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;\n    }\n\n    get filterMenuTemplateRef() {\n      return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;\n    }\n\n    get displayTitle() {\n      return this.title === undefined ? this.field : this.title;\n    }\n\n  }\n\n  ColumnComponent.ɵfac = function ColumnComponent_Factory(t) {\n    return new (t || ColumnComponent)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  };\n\n  ColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnComponent,\n    selectors: [[\"kendo-grid-column\"]],\n    contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);\n      }\n    },\n    inputs: {\n      field: \"field\",\n      format: \"format\",\n      sortable: \"sortable\",\n      groupable: \"groupable\",\n      editor: \"editor\",\n      filter: \"filter\",\n      filterable: \"filterable\",\n      editable: \"editable\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => ColumnComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function ColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction isSpanColumnComponent(column) {\n  return column.isSpanColumn;\n}\n/**\n * Represents a column which can be spanned over multiple data cells while the individual\n * header and footer cells are retained ([see example]({% slug spanned_columns_grid %})).\n * Enables you to achieve more flexible layout while keeping the built-in UI element for\n * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and\n * [grouping]({% slug groupingbasics_grid %}). Wrap the columns that will be\n * merged inside the `<kendo-grid-span-column>` tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid\n *              [sortable]=\"true\"\n *              [filterable]=\"true\"\n *              [kendoGridBinding]=\"products\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-span-column>\n *              <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *              </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" filter=\"numeric\" [width]=\"180\" format=\"{0:c}\">\n *              </kendo-grid-column>\n *          </kendo-grid-span-column>\n *          <kendo-grid-column field=\"Discontinued\" [width]=\"120\" filter=\"boolean\">\n *              <ng-template kendoGridCellTemplate let-dataItem>\n *                  <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *              </ng-template>\n *          </kendo-grid-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *   public products = [{\n *      \"ProductID\": 1,\n *      \"ProductName\": \"Chai\",\n *      \"UnitPrice\": 18.0000,\n *      \"Discontinued\": true\n *    }, {\n *      \"ProductID\": 2,\n *      \"ProductName\": \"Chang\",\n *      \"UnitPrice\": 19.0000,\n *      \"Discontinued\": false\n *    }\n *   ];\n * }\n *\n * ```\n *\n * By default, the data cell displays the data for the specified fields. To further customize\n * the span-column functionality, use a [cell template]({% slug api_grid_celltemplatedirective %}).\n *\n * ```html-no-run\n * <kendo-grid-span-column>\n *  <kendo-grid-column field=\"field1\" title=\"Field 1\"></kendo-grid-column>\n *  <kendo-grid-column field=\"field2\" title=\"Field 2\"></kendo-grid-column>\n *    <ng-template kendoGridCellTemplate let-dataItem>\n *        <h5>{{ dataItem.field1 }}</h5>\n *        <p>{{ dataItem.field2 }}</p>\n *    </ng-template>\n *  </kendo-grid-span-column>\n * ```\n */\n\n\nlet SpanColumnComponent = /*#__PURE__*/(() => {\n  class SpanColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      /*\n       * @hidden\n       */\n\n      this.isSpanColumn = true;\n      this.template = new QueryList();\n      this.editTemplate = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.childColumns = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.includeInChooser = false;\n      this._editable = true;\n\n      if (parent && parent.isSpanColumn) {\n        throw new Error('SpanColumn cannot be nested inside another SpanColumn');\n      }\n    }\n    /**\n     * Defines whether the edit template of the column will be rendered. The default value is `false`.\n     *\n     * > To enable the editing functionality for a spanned column, set an edit template for it.\n     *\n     * @example\n     * ```html-no-run\n     * <kendo-grid>\n     *    <kendo-grid-span-column [editable]=\"false\">\n     *      <kendo-grid-column field=\"UnitPrice\">\n     *      </kendo-grid-column>\n     *      <kendo-grid-column field=\"ProductName\">\n     *      </kendo-grid-column>\n     *      <ng-template kendoGridEditTemplate>\n     *         .....\n     *      </ng-template>\n     *    </kendo-grid-span-column>\n     * </kendo-grid>\n     * ```\n     */\n\n\n    set editable(value) {\n      this._editable = value;\n    }\n\n    get editable() {\n      return isPresent(this.editTemplateRef) && this._editable;\n    }\n    /**\n     * @hidden\n     * added for backwards compitability\n     */\n\n\n    set width(_value) {}\n\n    get width() {\n      return this.childColumns.reduce((total, column) => total + column.width, 0);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get leafIndex() {\n      return this.childColumns.first.leafIndex;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get templateRef() {\n      const template = this.template.first;\n      return template ? template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get editTemplateRef() {\n      const editTemplate = this.editTemplate.first;\n      return editTemplate ? editTemplate.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colspan() {\n      return this.childColumns.filter(c => c.isVisible).length;\n    }\n    /**\n     * Toggles the locked (frozen) state of the columns. Locked columns are visible\n     * at all times during the horizontal scrolling of the Grid.\n     *\n     * For the option to work properly, make sure that:\n     * - Scrolling is enabled.\n     * - The `height` option of the Grid is set.\n     * - The widths of all Grid columns are explicitly set in pixels. In this way,\n     * the Grid adjusts the layout of the locked and unlocked columns.\n     *\n     * @default false\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid [data]=\"gridData\" [scrollable]=\"scrollable\" style=\"height: 200px\">\n     *          <kendo-grid-span-column [locked]=\"true\">\n     *             <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n     *             </kendo-grid-column>\n     *             <kendo-grid-column field=\"ProductName\" title=\"Product Name\" [width]=\"200\">\n     *             </kendo-grid-column>\n     *          </kendo-grid-span-column>\n     *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" [width]=\"230\">\n     *          </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     *\n     * class AppComponent {\n     *    public gridData: any[];\n     *\n     *    constructor() {\n     *        this.gridData = products;\n     *    }\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     *\n     * ```\n     */\n\n\n    set locked(value) {\n      this._locked = value;\n    }\n\n    get locked() {\n      return this._locked || this.childColumns.some(c => c.locked);\n    }\n\n    get childrenArray() {\n      return this.childColumns.toArray();\n    }\n\n    get hasChildren() {\n      return this.childColumns.length > 0;\n    }\n\n  }\n\n  SpanColumnComponent.ɵfac = function SpanColumnComponent_Factory(t) {\n    return new (t || SpanColumnComponent)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  };\n\n  SpanColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SpanColumnComponent,\n    selectors: [[\"kendo-grid-span-column\"]],\n    contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childColumns = _t);\n      }\n    },\n    inputs: {\n      editable: \"editable\",\n      locked: \"locked\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => SpanColumnComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function SpanColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SpanColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst expandColumns = columns => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []);\n/**\n * @hidden\n */\n\n\nconst expandColumnsWithSpan = columns => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? [column].concat(column.childrenArray) : [column]), []);\n/**\n * @hidden\n */\n\n\nconst columnsToRender = columns => expandColumns(columns).filter(x => x.isVisible);\n\nconst sumProp = prop => array => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);\n/**\n * @hidden\n */\n\n\nconst sumColumnWidths = sumProp('width');\n/**\n * @hidden\n */\n\nconst columnsSpan = sumProp('colspan');\nconst validField = new RegExp(`^[$A-Z\\_a-z][$A-Z\\_a-z0-9\\\\.]*$`);\n/**\n * @hidden\n */\n\nconst isValidFieldName = fieldName => !isNullOrEmptyString(fieldName) && validField.test(fieldName) && fieldName[0] !== \".\" && fieldName[fieldName.length - 1] !== \".\";\n/**\n * @hidden\n */\n\n\nconst children = column => column.children.filter(child => child !== column);\n/**\n * @hidden\n */\n\n\nconst leafColumns = columns => {\n  return columns.reduce((acc, column) => {\n    if (column.isColumnGroup) {\n      acc = acc.concat(leafColumns(children(column)));\n    } else if (column.isSpanColumn) {\n      acc = acc.concat(column.childrenArray);\n    } else {\n      acc.push(column);\n    }\n\n    return acc;\n  }, []).filter(x => x.isVisible);\n};\n/**\n * @hidden\n */\n\n\nconst someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);\n/**\n * @hidden\n */\n\n\nconst resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);\n/**\n * @hidden\n */\n\n\nconst sortColumns = columns => orderBy(columns, [{\n  field: 'orderIndex',\n  dir: 'asc'\n}]);\n/**\n * @hidden\n */\n\n\nconst isInSpanColumn$1 = column => isTruthy(column.parent) && isSpanColumnComponent(column.parent);\n/**\n * @hidden\n */\n\n\nfunction isColumnGroupComponent(column) {\n  return column.isColumnGroup;\n}\n/**\n * Represents the column group header of the Grid\n * ([more information and examples]({% slug multicolumnheaders_columns_grid %})).\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *     <kendo-grid [data]=\"gridData\">\n *       <kendo-grid-column-group title=\"Product Info\">\n *         <ng-template kendoGridHeaderTemplate let-columnIndex=\"columnIndex\" let-column=\"column\">\n *               Column index: {{columnIndex}} / column title: {{column.title}}\n *         </ng-template>\n *         <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *         </kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *         </kendo-grid-column>\n *       </kendo-grid-column-group>\n *       <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" [width]=\"230\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"Discontinued\" [width]=\"120\">\n *           <ng-template kendoGridCellTemplate let-dataItem>\n *               <input type=\"checkbox\" [checked]=\"dataItem.Discontinued\" disabled/>\n *           </ng-template>\n *       </kendo-grid-column>\n *     </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\n\n\nlet ColumnGroupComponent = /*#__PURE__*/(() => {\n  class ColumnGroupComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      this.parent = parent;\n      /**\n       * @hidden\n       */\n\n      this.includeInChooser = false;\n      /**\n       * @hidden\n       */\n\n      this.isColumnGroup = true;\n      /**\n       * @hidden\n       */\n\n      this.minResizableWidth = 10;\n\n      if (parent && parent.isSpanColumn) {\n        throw new Error('ColumnGroupComponent cannot be nested inside SpanColumnComponent');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    rowspan() {\n      return 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colspan() {\n      if (!this.children || this.children.length === 1) {\n        return 1;\n      }\n\n      return columnsSpan(this.children.filter(child => child !== this && child.isVisible));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get leafIndex() {\n      return this.children ? (this.firstChild || {}).leafIndex : -1;\n    }\n\n    get childrenArray() {\n      return this.children.filter(c => c !== this);\n    }\n\n    get hasChildren() {\n      return Boolean(this.firstChild);\n    }\n\n    get firstChild() {\n      return this.children.find(column => column !== this);\n    }\n\n  }\n\n  ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) {\n    return new (t || ColumnGroupComponent)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  };\n\n  ColumnGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnGroupComponent,\n    selectors: [[\"kendo-grid-column-group\"]],\n    contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => ColumnGroupComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function ColumnGroupComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ColumnGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).\n * To define the detail template, nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-grid\n *         [data]=\"data\"\n *         selectable=\"true\"\n *         style=\"height: 160px\"\n *         >\n *         <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *         <kendo-grid-column field=\"UnitPrice\"></kendo-grid-column>\n *         <ng-template kendoGridDetailTemplate let-dataItem>\n *           <div *ngIf=\"dataItem.Category\">\n *             <header>{{dataItem.Category?.CategoryName}}</header>\n *             <span>{{dataItem.Category?.Description}}</span>\n *           </div>\n *         </ng-template>\n *       </kendo-grid>\n *   `\n * })\n *\n * class AppComponent {\n *     public data = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 1,\n *             \"CategoryName\": \"Beverages\",\n *             \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *         }\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 1,\n *             \"CategoryName\": \"Beverages\",\n *             \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *         }\n *       }, {\n *         \"ProductID\": 3,\n *         \"ProductName\": \"Aniseed Syrup\",\n *         \"UnitPrice\": 10.0000,\n *         \"Discontinued\": false,\n *         \"Category\": {\n *             \"CategoryID\": 2,\n *             \"CategoryName\": \"Condiments\",\n *             \"Description\": \"Sweet and savory sauces, relishes, spreads, and seasonings\"\n *         }\n *     }];\n *\n * }\n *\n * ```\n *\n */\n\n\nlet DetailTemplateDirective = /*#__PURE__*/(() => {\n  class DetailTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n\n      this._condition = () => true;\n    }\n    /**\n     * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.\n     */\n\n\n    set showIf(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`showIf must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this._condition = fn;\n    }\n\n    get showIf() {\n      return this._condition;\n    }\n\n  }\n\n  DetailTemplateDirective.ɵfac = function DetailTemplateDirective_Factory(t) {\n    return new (t || DetailTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DetailTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DetailTemplateDirective,\n    selectors: [[\"\", \"kendoGridDetailTemplate\", \"\"]],\n    inputs: {\n      showIf: [\"kendoGridDetailTemplateShowIf\", \"showIf\"]\n    }\n  });\n  return DetailTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst canCreateElement = () => isDocumentAvailable() && document.createElement;\n\nlet cachedScrollbarWidth = null;\nlet cachedPixelRatio;\nlet cachedRtlScrollLeft = null;\n\nfunction scrollbarWidth() {\n  if (cachedScrollbarWidth === null && canCreateElement()) {\n    cachedPixelRatio = window.devicePixelRatio || 1;\n    const div = document.createElement(\"div\");\n    div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n    div.innerHTML = \"&nbsp;\";\n    document.body.appendChild(div);\n    cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;\n    document.body.removeChild(div);\n  }\n\n  return cachedScrollbarWidth;\n}\n\nfunction rtlScrollLeft() {\n  if (cachedRtlScrollLeft === null && canCreateElement()) {\n    const div = document.createElement(\"div\");\n    div.style.cssText = \"overflow:scroll;zoom:1;clear:both;display:block;width:100px;visibility:hidden;position:absolute;left:-10000px;direction:rtl;\";\n    div.innerHTML = \"<div style='width:200px;height:1px;'</div>\";\n    document.body.appendChild(div);\n    const initial = div.scrollLeft;\n    div.scrollLeft = -1;\n    cachedRtlScrollLeft = div.scrollLeft < 0 ? div.scrollLeft : initial;\n    document.body.removeChild(div);\n  }\n\n  return cachedRtlScrollLeft;\n}\n/**\n * @hidden\n * move to kendo-common\n */\n\n\nlet BrowserSupportService = /*#__PURE__*/(() => {\n  class BrowserSupportService {\n    constructor(zone, changeDetector) {\n      this.zone = zone;\n      this.changeDetector = changeDetector;\n      this.changes = new EventEmitter();\n\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.subscriptions = fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {\n          if (cachedPixelRatio !== window.devicePixelRatio) {\n            zone.run(() => {\n              cachedScrollbarWidth = null;\n              this.changes.emit();\n              this.changeDetector.markForCheck();\n            });\n          }\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n        this.subscriptions = null;\n      }\n    }\n\n    get scrollbarWidth() {\n      return scrollbarWidth();\n    }\n\n    get rtlScrollLeft() {\n      return rtlScrollLeft();\n    }\n\n  }\n\n  BrowserSupportService.ɵfac = function BrowserSupportService_Factory(t) {\n    return new (t || BrowserSupportService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ChangeDetectorRef));\n  };\n\n  BrowserSupportService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BrowserSupportService,\n    factory: BrowserSupportService.ɵfac\n  });\n  return BrowserSupportService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isGroupItem = source => {\n  return source.items !== undefined && source.field !== undefined;\n};\n\nconst isVirtualGroupItem = source => {\n  return source.offset !== undefined && source.skipHeader !== undefined;\n};\n\nconst flattenGroups = groups => groups.reduce((acc, curr) => {\n  if (isGroupItem(curr)) {\n    return acc.concat(flattenGroups(curr.items));\n  }\n\n  return acc.concat([curr]);\n}, []);\n/**\n * @hidden\n */\n\n\nconst itemAt = (data, index) => {\n  const first = data[0];\n\n  if (isPresent(first) && isGroupItem(first)) {\n    return flattenGroups(data)[index];\n  }\n\n  return data[index];\n};\n/**\n * @hidden\n */\n\n\nconst getIterator = (data, {\n  footers,\n  level,\n  dataIndex,\n  parentGroupIndex,\n  groupIndex,\n  parentGroup\n}) => {\n  const first = data[0];\n\n  if (isPresent(first) && isGroupItem(first)) {\n    if (isVirtualGroupItem(first)) {\n      groupIndex = isPresent(first.offset) ? first.offset : groupIndex;\n    }\n\n    return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);\n  }\n\n  return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);\n};\n\nclass ArrayIterator {\n  constructor(arr, idx = 0) {\n    this.arr = arr;\n    this.idx = idx;\n    this.arr = arr || [];\n  }\n\n  [iterator]() {\n    return this;\n  }\n\n  next() {\n    return this.idx < this.arr.length ? {\n      done: false,\n      value: this.arr[this.idx++]\n    } : {\n      done: true,\n      value: undefined\n    };\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass Iterator {\n  constructor(arr, dataIndex = 0, resultMap = x => x) {\n    this.dataIndex = dataIndex;\n    this.resultMap = resultMap;\n    const iter = arr[iterator];\n    this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);\n  }\n\n  [iterator]() {\n    return this;\n  }\n\n  next() {\n    return this.resultMap(this._innerIterator.next(), this.dataIndex++);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ItemIterator extends Iterator {\n  constructor(arr, dataIndex, groupIndex, group) {\n    super(arr, dataIndex, (x, idx) => ({\n      done: x.done,\n      value: {\n        data: x.value,\n        groupIndex: groupIndex,\n        index: idx,\n        type: 'data',\n        group\n      }\n    }));\n  }\n  /**\n   * The index of the next record.\n   * @readonly\n   * @type {number}\n   */\n\n\n  get index() {\n    return this.dataIndex;\n  }\n\n}\n\nconst prefix = (s, n) => {\n  const p = s ? s + \"_\" : s;\n  return `${p}${n}`;\n};\n/**\n * @hidden\n */\n\n\nclass GroupIterator {\n  constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = \"\", groupIndex = 0, parentGroup = undefined) {\n    this.arr = arr;\n    this.outputFooters = outputFooters;\n    this.level = level;\n    this.dataIndex = dataIndex;\n    this.parentIndex = parentIndex;\n    this.groupIndex = groupIndex;\n    this.parentGroup = parentGroup;\n    this.currentGroupIndex = \"\";\n    this.arr = arr || [];\n    this._iterator = new Iterator(this.arr, this.dataIndex);\n  }\n\n  [iterator]() {\n    return this;\n  }\n\n  nextGroupItem() {\n    this.current = this._iterator.next().value;\n    this._innerIterator = null;\n\n    if (this.current) {\n      this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);\n      return {\n        done: false,\n        value: {\n          data: this.current,\n          index: this.currentGroupIndex,\n          level: this.level,\n          type: 'group',\n          parentGroup: this.parentGroup\n        }\n      };\n    } else {\n      this.current = null;\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  }\n\n  footerItem() {\n    if (this.current) {\n      const group = this.current;\n      this.current = null;\n      return {\n        done: false,\n        value: {\n          data: group,\n          groupIndex: this.currentGroupIndex,\n          level: this.level,\n          type: 'footer',\n          group: {\n            data: group,\n            index: this.currentGroupIndex,\n            level: this.level,\n            type: 'group',\n            parentGroup: this.parentGroup\n          }\n        }\n      };\n    } else {\n      this.current = null;\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  }\n\n  innerIterator(group) {\n    if (!this._innerIterator) {\n      this._innerIterator = getIterator(group.items, {\n        dataIndex: this.dataIndex,\n        footers: this.outputFooters,\n        level: this.level + 1,\n        parentGroupIndex: this.currentGroupIndex,\n        parentGroup: {\n          data: this.current,\n          index: this.currentGroupIndex,\n          level: this.level,\n          type: 'group',\n          parentGroup: this.parentGroup\n        }\n      });\n    }\n\n    return this._innerIterator;\n  }\n\n  nextDataItem(group) {\n    const iterator = this.innerIterator(group);\n    const result = iterator.next();\n\n    if (isPresent(result.value) && !result.done && result.value.type === \"data\") {\n      this.dataIndex = result.value.index + 1;\n    }\n\n    return !result.done ? result : undefined;\n  }\n\n  next() {\n    if (!isPresent(this.current)) {\n      return this.nextGroupItem();\n    }\n\n    const item = this.nextDataItem(this.current);\n    return item ? item : this.outputFooters ? this.footerItem() : this.nextGroupItem();\n  }\n  /**\n   * The index of the last iterated data record.\n   * @readonly\n   * @type {number}\n   */\n\n\n  get index() {\n    return this.dataIndex + 1;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass DataResultIterator {\n  constructor(source, skip = 0, groupFooters = false) {\n    this.source = source;\n    this.skip = skip;\n    this.groupFooters = groupFooters;\n    this.source = this.source ? this.source : [];\n    this.isObject = this.isGridDataResult(this.source);\n  }\n\n  isGridDataResult(source) {\n    return source.total !== undefined && source.data !== undefined;\n  }\n\n  get total() {\n    return this.isObject ? this.source.total : this.source.length;\n  }\n\n  get data() {\n    return this.isObject ? this.source.data : this.source;\n  }\n\n  map(fn) {\n    return this.data.map(fn);\n  }\n\n  filter(fn) {\n    return this.data.filter(fn);\n  }\n\n  reduce(fn, init) {\n    return this.data.reduce(fn, init);\n  }\n\n  forEach(fn) {\n    this.data.forEach(fn);\n  }\n\n  some(fn) {\n    return this.data.some(fn);\n  }\n\n  [iterator]() {\n    return getIterator(this.data, {\n      dataIndex: this.skip,\n      footers: this.groupFooters,\n      groupIndex: this.skip\n    });\n  }\n\n  toString() {\n    return this.data.toString();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass DataCollection {\n  constructor(accessor) {\n    this.accessor = accessor;\n  }\n\n  get total() {\n    return this.accessor().total;\n  }\n\n  get length() {\n    return this.accessor().data.length;\n  }\n\n  get first() {\n    return this.accessor().data[0];\n  }\n\n  get last() {\n    return this.accessor().data[this.length - 1];\n  }\n\n  at(index) {\n    return itemAt(this.accessor().data, index);\n  }\n\n  map(fn) {\n    return this.accessor().map(fn);\n  }\n\n  filter(fn) {\n    return this.accessor().filter(fn);\n  }\n\n  reduce(fn, init) {\n    return this.accessor().reduce(fn, init);\n  }\n\n  forEach(fn) {\n    this.accessor().forEach(fn);\n  }\n\n  some(fn) {\n    return this.accessor().some(fn);\n  }\n\n  [iterator]() {\n    return this.accessor()[iterator]();\n  }\n\n  toString() {\n    return this.accessor().toString();\n  }\n\n}\n/**\n * @hidden\n *\n * Quick look-up structure for combinations of keys.\n * Similar to the native JS Set, however, working with a couple of keys instead of with a single key.\n * Supports both primitive keys and object keys (compared by reference).\n */\n\n\nclass PairSet {\n  constructor(items, keyXField, keyYField) {\n    /**\n     * Holds a set of Y keys for each defined X key.\n     * Each X key creates a map which holds a set of Y keys.\n     *\n     * Map { 1 => Set { 1, 2, 3 } } // pairs: [1, 1], [1, 2], [1, 3]\n     */\n    this.keysX = new Map();\n    /**\n     * Count the each added or deleted key manually to avoid iterating over all items when calling `this.size`.\n     */\n\n    this.totalKeysCount = 0;\n\n    if (items && keyXField && keyYField) {\n      items.forEach(item => this.add(item[keyXField], item[keyYField]));\n    }\n  }\n  /**\n   * Gets the total number of X/Y key pairs.\n   */\n\n\n  get size() {\n    return this.totalKeysCount;\n  }\n  /**\n   * Adds a couple of items identified as a combination.\n   */\n\n\n  add(keyX, keyY) {\n    if (!this.keysX.has(keyX)) {\n      this.keysX.set(keyX, new Set());\n    }\n\n    if (!this.has(keyX, keyY)) {\n      this.keysX.get(keyX).add(keyY);\n      this.totalKeysCount += 1;\n    }\n  }\n  /**\n   * Adds a combination of a couple of items identified together.\n   */\n\n\n  delete(keyX, keyY) {\n    if (this.has(keyX, keyY)) {\n      this.keysX.get(keyX).delete(keyY);\n      this.totalKeysCount -= 1;\n    }\n  }\n  /**\n   * Checks whether the defined combination is stored.\n   */\n\n\n  has(keyX, keyY) {\n    return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);\n  }\n  /**\n   * Clears all key combinations.\n   */\n\n\n  clear() {\n    this.keysX.clear();\n    this.totalKeysCount = 0;\n  }\n  /**\n   * Converts the persisted data structure to an array of objects,\n   * using the provided field names for the object props.\n   */\n\n\n  toArray(keyXField, keyYField) {\n    return Array.from(this.keysX).reduce((pairs, pair) => {\n      // Array.from(mapInstance) returns an array of arrays [[itemKey1, columnKeysSet1], [itemKey2, columnKeysSet2]]\n      const [keyX, keysY] = pair;\n      Array.from(keysY).forEach(keyY => pairs.push({\n        [keyXField]: keyX,\n        [keyYField]: keyY\n      }));\n      return pairs;\n    }, []);\n  }\n\n}\n/**\n * @hidden\n *\n * The Context service is used to provide common\n * services and DI tokens for a Grid instance.\n *\n * This keeps the constructor parameters stable\n * and a avoids dependency cycles between components.\n */\n\n\nlet ContextService = /*#__PURE__*/(() => {\n  class ContextService {}\n\n  ContextService.ɵfac = function ContextService_Factory(t) {\n    return new (t || ContextService)();\n  };\n\n  ContextService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContextService,\n    factory: ContextService.ɵfac\n  });\n  return ContextService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet Selection = /*#__PURE__*/(() => {\n  class Selection {\n    constructor(ctx, cd) {\n      this.ctx = ctx;\n      this.cd = cd;\n      /**\n       * Defines the collection that will store the selected item keys.\n       */\n\n      this.selectedKeys = [];\n      /**\n       * Fires when the `selectedKeys` collection has been updated.\n       */\n\n      this.selectedKeysChange = new EventEmitter();\n      this.rowSelectionState = new Set();\n      this.cellSelectionState = new PairSet();\n      this.init();\n    }\n\n    get isCellSelectionMode() {\n      return isPresent(this.ctx.grid.selectable) && this.ctx.grid.selectable['cell'];\n    }\n\n    ngOnChanges(changes) {\n      // skip reinitialization if the user data is the same as the last state change\n      if (isPresent(changes.selectedKeys) && this.lastSelectionState !== this.selectedKeys) {\n        this.setState(this.selectedKeys);\n      }\n    }\n\n    init() {\n      if (!isPresent(this.ctx.grid.rowSelected)) {\n        this.ctx.grid.rowSelected = row => this.rowSelectionState.has(this.getItemKey(row));\n      }\n\n      if (!isPresent(this.ctx.grid.cellSelected)) {\n        this.ctx.grid.cellSelected = (row, column, colIndex) => {\n          const contender = this.getSelectionItem(row, column, colIndex);\n          return {\n            selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),\n            item: contender\n          };\n        };\n      }\n\n      this.selectionChangeSubscription = this.ctx.grid.selectionChange.subscribe(this.onSelectionChange.bind(this));\n    }\n    /**\n     * @hidden\n     */\n\n\n    destroy() {\n      this.selectionChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    reset() {\n      this.rowSelectionState.clear();\n      this.cellSelectionState.clear();\n    }\n\n    getItemKey(row) {\n      if (this.selectionKey) {\n        if (typeof this.selectionKey === \"string\") {\n          return row.dataItem[this.selectionKey];\n        }\n\n        if (typeof this.selectionKey === \"function\") {\n          return this.selectionKey(row);\n        }\n      }\n\n      return row.index;\n    }\n\n    getSelectionItem(row, col, colIndex) {\n      const itemIdentifiers = {};\n      itemIdentifiers.itemKey = this.getItemKey(row);\n\n      if (!isPresent(col) && !isPresent(colIndex)) {\n        return itemIdentifiers;\n      }\n\n      if (this.columnKey) {\n        if (typeof this.columnKey === \"string\") {\n          itemIdentifiers.columnKey = row.dataItem[this.columnKey];\n        }\n\n        if (typeof this.columnKey === \"function\") {\n          itemIdentifiers.columnKey = this.columnKey(col, colIndex);\n        }\n      }\n\n      return {\n        itemKey: itemIdentifiers.itemKey,\n        columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex\n      };\n    }\n\n    onSelectionChange(selection) {\n      if (selection.selectedRows) {\n        selection.deselectedRows.forEach(item => {\n          const itemKey = this.getItemKey(item);\n          this.rowSelectionState.delete(itemKey);\n        });\n\n        if (this.ctx.grid.selectableSettings.mode === \"single\" && this.rowSelectionState.size > 0) {\n          this.reset();\n        }\n\n        selection.selectedRows.forEach(item => {\n          const itemKey = this.getItemKey(item);\n          this.rowSelectionState.add(itemKey);\n        });\n      } else {\n        selection.deselectedCells.forEach(({\n          itemKey,\n          columnKey\n        }) => {\n          this.cellSelectionState.delete(itemKey, columnKey);\n        });\n\n        if (this.ctx.grid.selectableSettings.mode === \"single\" && this.cellSelectionState.size > 0) {\n          this.reset();\n        }\n\n        selection.selectedCells.forEach(({\n          itemKey,\n          columnKey\n        }) => {\n          this.cellSelectionState.add(itemKey, columnKey);\n        });\n      }\n\n      this.cd.markForCheck();\n      this.notifyChange();\n    }\n\n    notifyChange() {\n      this.lastSelectionState = this.stateToArray();\n      this.selectedKeysChange.emit(this.lastSelectionState);\n    }\n\n    setState(selectedKeys) {\n      this.reset();\n\n      if (this.isCellSelectionMode) {\n        this.cellSelectionState = new PairSet(selectedKeys, 'itemKey', 'columnKey');\n      } else {\n        this.rowSelectionState = new Set(selectedKeys);\n      }\n    }\n\n    stateToArray() {\n      return this.isCellSelectionMode ? this.cellSelectionState.toArray('itemKey', 'columnKey') : Array.from(this.rowSelectionState);\n    }\n\n  }\n\n  Selection.ɵfac = function Selection_Factory(t) {\n    return new (t || Selection)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  Selection.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Selection,\n    selectors: [[\"kendo-grid-selection-base\"]],\n    inputs: {\n      selectedKeys: \"selectedKeys\",\n      selectionKey: [\"kendoGridSelectBy\", \"selectionKey\"],\n      columnKey: \"columnKey\"\n    },\n    outputs: {\n      selectedKeysChange: \"selectedKeysChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return Selection;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst reset = (...lists) => {\n  let diff = false;\n\n  for (let idx = 0; idx < lists.length; idx++) {\n    const [list, columns] = lists[idx];\n    diff = diff || list.length !== columns.length;\n    list.reset(columns);\n  }\n\n  return diff;\n};\n/**\n * @hidden\n */\n\n\nclass ColumnsContainer {\n  constructor(columns) {\n    this.columns = columns;\n    this.allColumns = new QueryList();\n    this.leafColumns = new QueryList();\n    this.lockedColumns = new QueryList();\n    this.nonLockedColumns = new QueryList();\n    this.lockedLeafColumns = new QueryList();\n    this.nonLockedLeafColumns = new QueryList();\n    this.totalLevels = 0;\n    this.changes = new EventEmitter();\n    this.leafColumnsToRender = [];\n    this.lockedColumnsToRender = [];\n    this.nonLockedColumnsToRender = [];\n    this.hasGroupHeaderColumn = false;\n    this.hasGroupFooter = false;\n    this.hasFooter = false;\n    this.unlockedWidth = 0;\n  }\n\n  refresh() {\n    const currentLevels = this.totalLevels;\n    const leafColumns = new Array();\n    const lockedLeafColumns = new Array();\n    const nonLockedLeafColumns = new Array();\n    const lockedColumns = new Array();\n    const nonLockedColumns = new Array();\n    const allColumns = new Array();\n    const leafColumnsToRender = new Array();\n    const lockedColumnsToRender = new Array();\n    const nonLockedColumnsToRender = new Array();\n    let hasGroupHeaderColumn = false;\n    let hasGroupFooter = false;\n    let hasFooter = false;\n    let unlockedWidth = 0;\n    let leafIndex = 0;\n    this.totalLevels = 0;\n    this.columns().forEach(column => {\n      const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;\n      const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;\n      const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;\n\n      if (!isColumnGroupComponent(column)) {\n        containerLeafColumns.push(column);\n        leafColumns.push(column);\n        leafColumnsToRender.push.apply(leafColumnsToRender, columnsToRender([column]));\n        toRenderContainer.push.apply(toRenderContainer, columnsToRender([column]));\n        hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);\n        hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);\n        hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);\n\n        if (!column.isLocked) {\n          unlockedWidth += column.width || 0;\n        }\n\n        if (column.isSpanColumn) {\n          column.childColumns.forEach(c => {\n            c.leafIndex = leafIndex++;\n          });\n        } else {\n          column.leafIndex = leafIndex++;\n        }\n      }\n\n      containerColumns.push(column);\n      allColumns.push(column);\n      this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;\n    });\n    this.hasGroupHeaderColumn = hasGroupHeaderColumn;\n    this.hasGroupFooter = hasGroupFooter;\n    this.hasFooter = hasFooter;\n    this.leafColumnsToRender = leafColumnsToRender;\n    this.lockedColumnsToRender = lockedColumnsToRender;\n    this.nonLockedColumnsToRender = nonLockedColumnsToRender;\n    this.unlockedWidth = unlockedWidth;\n    const changes = reset([this.leafColumns, leafColumns], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;\n\n    if (changes) {\n      this.changes.emit();\n    }\n\n    return changes;\n  }\n\n}\n\nconst forEachColumn = (list, callback) => {\n  list.forEach(column => {\n    callback(column);\n\n    if (column.isColumnGroup && column.hasChildren) {\n      forEachColumn(column.childrenArray, callback);\n    }\n  });\n};\n\nconst forEachLevel = (list, callback) => {\n  sortColumns(list).forEach(column => {\n    callback(column);\n\n    if (column.isColumnGroup && column.hasChildren) {\n      forEachLevel(column.childrenArray, callback);\n    }\n  });\n};\n\nconst filterHierarchy = (list, predicate) => {\n  const result = [];\n  sortColumns(list).forEach(column => {\n    if (predicate(column)) {\n      if (column.isColumnGroup) {\n        const children = filterHierarchy(column.childrenArray, predicate);\n\n        if (children.length) {\n          result.push(column, ...children);\n        }\n      } else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {\n        result.push(column);\n      }\n    }\n  });\n  return result;\n};\n/**\n * @hidden\n */\n\n\nclass ColumnList {\n  constructor(columns) {\n    this.columns = columns;\n  }\n\n  static empty() {\n    return new ColumnList(new QueryList());\n  }\n\n  forEach(callback) {\n    forEachColumn(this.columns, callback);\n  }\n\n  filter(callback) {\n    const result = [];\n    forEachColumn(this.columns, column => {\n      if (callback(column)) {\n        result.push(column);\n      }\n    });\n    return result;\n  }\n\n  filterHierarchy(predicate) {\n    return filterHierarchy(this.columns.toArray(), predicate);\n  }\n\n  filterSort(callback) {\n    const result = [];\n    forEachLevel(this.columns.toArray(), column => {\n      if (callback(column)) {\n        result.push(column);\n      }\n    });\n    return result;\n  }\n\n  toArray() {\n    const result = [];\n    forEachColumn(this.columns, column => {\n      result.push(column);\n    });\n    return result;\n  }\n\n  rootColumns() {\n    return this.columns.toArray();\n  }\n\n  totalColumnLevels() {\n    let totalLevels = 0;\n    this.forEach(column => {\n      totalLevels = Math.max(column.level, totalLevels);\n    });\n    return totalLevels;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass GroupInfoService {\n  constructor() {\n    this._columnList = ColumnList.empty;\n  }\n\n  get columns() {\n    return expandColumns(this._columnList().toArray()).filter(isColumnComponent);\n  }\n\n  registerColumnsContainer(columns) {\n    this._columnList = columns;\n  }\n\n  formatForGroup(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.format : \"\";\n  }\n\n  isGroupable(groupField) {\n    const [column] = this.columns.filter(x => x.field === groupField);\n    return column ? column.groupable : true;\n  }\n\n  groupTitle(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.title || column.field : this.groupField(item);\n  }\n\n  groupHeaderTemplate(item) {\n    const column = this.columnForGroup(item);\n    return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;\n  }\n\n  groupField(group) {\n    return group.data ? group.data.field : group.field;\n  }\n\n  columnForGroup(group) {\n    const field = this.groupField(group);\n    const [column] = this.columns.filter(x => x.field === field);\n    return column;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet ChangeNotificationService = /*#__PURE__*/(() => {\n  class ChangeNotificationService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.changes = new EventEmitter();\n    }\n\n    notify() {\n      if (!this.subscription || this.subscription.closed) {\n        this.subscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this.changes.emit());\n      }\n    }\n\n  }\n\n  ChangeNotificationService.ɵfac = function ChangeNotificationService_Factory(t) {\n    return new (t || ChangeNotificationService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  ChangeNotificationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ChangeNotificationService,\n    factory: ChangeNotificationService.ɵfac\n  });\n  return ChangeNotificationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the no-records template of the Grid. Provides an option to customize the\n * appearance of the item that is displayed when no data is present. To define the no-records template,\n * nest an `<ng-template>` tag with the `kendoGridNoRecordsTemplate` directive inside `<kendo-grid>`.\n *\n * > When the locked columns of the Grid are in use, the template is displayed in the non-locked part of the content.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-grid [data]=\"data\">\n *         <kendo-grid-column field=\"ProductID\"></kendo-grid-column>\n *         <kendo-grid-column field=\"ProductName\"></kendo-grid-column>\n *         <kendo-grid-column field=\"UnitPrice\"></kendo-grid-column>\n *         <ng-template kendoGridNoRecordsTemplate>\n *            There are not products. <a href=\"#\" (click)=\"refresh()\">Click here to refresh</a>.\n *         </ng-template>\n *       </kendo-grid>\n *   `\n * })\n *\n * class AppComponent {\n *     public data = [];\n *     public refresh() {\n *       this.data = [{\n *            \"ProductID\": 1,\n *            \"ProductName\": \"Chai\",\n *            \"UnitPrice\": 18.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 1,\n *                \"CategoryName\": \"Beverages\",\n *                \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *            }\n *          }, {\n *            \"ProductID\": 2,\n *            \"ProductName\": \"Chang\",\n *            \"UnitPrice\": 19.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 1,\n *                \"CategoryName\": \"Beverages\",\n *                \"Description\": \"Soft drinks, coffees, teas, beers, and ales\"\n *            }\n *          }, {\n *            \"ProductID\": 3,\n *            \"ProductName\": \"Aniseed Syrup\",\n *            \"UnitPrice\": 10.0000,\n *            \"Discontinued\": false,\n *            \"Category\": {\n *                \"CategoryID\": 2,\n *                \"CategoryName\": \"Condiments\",\n *                \"Description\": \"Sweet and savory sauces, relishes, spreads, and seasonings\"\n *            }\n *        }];\n *\n *     }\n * }\n *\n * ```\n */\n\n\nlet NoRecordsTemplateDirective = /*#__PURE__*/(() => {\n  class NoRecordsTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  NoRecordsTemplateDirective.ɵfac = function NoRecordsTemplateDirective_Factory(t) {\n    return new (t || NoRecordsTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  NoRecordsTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NoRecordsTemplateDirective,\n    selectors: [[\"\", \"kendoGridNoRecordsTemplate\", \"\"]]\n  });\n  return NoRecordsTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst set = value => pair => pair.forEach(x => x.style.height = value);\n\nconst clearHeight = pairs => pairs.filter(([left, right]) => left.style.height || right.style.height).forEach(set(\"\"));\n\nconst zip = (arr1, arr2) => {\n  const result = [];\n\n  for (let idx = 0, len = arr1.length; idx < len; idx++) {\n    if (!arr2[idx]) {\n      break;\n    }\n\n    result.push([arr1[idx], arr2[idx]]);\n  }\n\n  return result;\n};\n\nconst setHeight$1 = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);\n\nconst getHeights = rows => rows.map(([left, right]) => {\n  const height = left.offsetHeight;\n  const offsetHeight2 = right.offsetHeight;\n\n  if (height < offsetHeight2) {\n    return offsetHeight2;\n  }\n\n  return height;\n});\n/**\n * @hidden\n */\n\n\nconst syncRowsHeight = (table1, table2) => {\n  const activeElement = document.activeElement;\n  const rows = zip(table1.rows, table2.rows);\n  clearHeight(rows);\n  const heights = getHeights(rows);\n  [table1, table2].forEach(x => x.style.display = 'none');\n  rows.forEach(setHeight$1(heights));\n  [table1, table2].forEach(x => x.style.display = '');\n\n  if (document.activeElement !== activeElement && (table1.contains(activeElement) || table2.contains(activeElement))) {\n    activeElement.focus();\n  }\n};\n/**\n * @hidden\n */\n\n\nlet MenuTabbingService = /*#__PURE__*/(() => {\n  class MenuTabbingService {\n    constructor() {\n      this.isColumnMenu = false;\n      this.isPopupOpen = false;\n    }\n\n  }\n\n  MenuTabbingService.ɵfac = function MenuTabbingService_Factory(t) {\n    return new (t || MenuTabbingService)();\n  };\n\n  MenuTabbingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MenuTabbingService,\n    factory: MenuTabbingService.ɵfac\n  });\n  return MenuTabbingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a service to set the filter descriptor\n * ([see example]({% slug reusablecustomfilters_grid %})).\n */\n\n\nlet FilterService = /*#__PURE__*/(() => {\n  class FilterService {\n    /**\n     * @hidden\n     */\n    constructor(menuTabbingService) {\n      /**\n       * Fires when the filter descriptors is set.\n       */\n      this.changes = new Subject();\n      this.menuTabbingService = menuTabbingService;\n    }\n    /**\n     * Sets the filter descriptor.\n     *\n     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.\n     */\n\n\n    filter(value) {\n      this.changes.next(value);\n    }\n\n  }\n\n  FilterService.ɵfac = function FilterService_Factory(t) {\n    return new (t || FilterService)(i0.ɵɵinject(MenuTabbingService, 8));\n  };\n\n  FilterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FilterService,\n    factory: FilterService.ɵfac\n  });\n  return FilterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the pager template which helps to customize the pager appearance in the Grid. To define a pager\n * template, nest an `<ng-template>` tag with the `kendoPagerTemplate` directive inside `<kendo-grid>`.\n *\n * The template context provides the following fields:\n * * `currentPage`&mdash;The index of the displayed page.\n * * `pageSize`&mdash;The value of the current `pageSize`.\n * * `skip`&mdash;The current skip value.\n * * `total`&mdash;The total number of records.\n * * `totalPages`&mdash;The total number of available pages.\n * *  Needs to be provided as an input to inner pager components used within the template when the Grid is navigable.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-grid\n *        [kendoGridBinding]=\"gridData\"\n *        [pageSize]=\"1\"\n *        [pageable]=\"true\"\n *      >\n *       <kendo-grid-column field=\"ProductID\" title=\"ID\" [width]=\"40\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"ProductName\" title=\"Name\" [width]=\"250\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"UnitPrice\" title=\"Price\" [width]=\"80\" format=\"{0:c}\">\n *       </kendo-grid-column>\n *\n *       <ng-template kendoPagerTemplate let-totalPages=\"totalPages\" let-currentPage=\"currentPage\">\n *          <kendo-pager-prev-buttons></kendo-pager-prev-buttons>\n *          <kendo-pager-numeric-buttons [buttonCount]=\"10\"></kendo-pager-numeric-buttons>\n *          <kendo-pager-next-buttons></kendo-pager-next-buttons>\n *          <kendo-pager-info></kendo-pager-info>\n *          Current page: {{currentPage}}\n *       </ng-template>\n *\n *    </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\n\n\nlet PagerTemplateDirective = /*#__PURE__*/(() => {\n  class PagerTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PagerTemplateDirective.ɵfac = function PagerTemplateDirective_Factory(t) {\n    return new (t || PagerTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PagerTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PagerTemplateDirective,\n    selectors: [[\"\", \"kendoPagerTemplate\", \"\"]]\n  });\n  return PagerTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PDFService = /*#__PURE__*/(() => {\n  class PDFService {\n    constructor() {\n      this.savePDF = new EventEmitter();\n      this.drawPDF = new EventEmitter();\n      this.exportClick = new EventEmitter();\n      this.dataChanged = new EventEmitter();\n    }\n\n    save(component) {\n      this.emitEvent(this.savePDF, component);\n    }\n\n    draw(component, promise) {\n      this.emitEvent(this.drawPDF, {\n        component,\n        promise\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitEvent(emitter, args) {\n      if (emitter.observers.length === 0) {\n        if (isDevMode()) {\n          throw new Error('Creating PDF requires including the PDFModule and adding the <kendo-grid-pdf> component.');\n        }\n      } else {\n        emitter.emit(args);\n      }\n    }\n\n  }\n\n  PDFService.ɵfac = function PDFService_Factory(t) {\n    return new (t || PDFService)();\n  };\n\n  PDFService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PDFService,\n    factory: PDFService.ɵfac\n  });\n  return PDFService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `pdfExport` event.\n */\n\n\nclass PDFExportEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor() {\n    super();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet SuspendService = /*#__PURE__*/(() => {\n  class SuspendService {\n    constructor() {\n      this.scroll = false;\n    }\n\n  }\n\n  SuspendService.ɵfac = function SuspendService_Factory(t) {\n    return new (t || SuspendService)();\n  };\n\n  SuspendService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SuspendService,\n    factory: SuspendService.ɵfac\n  });\n  return SuspendService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst bootstrapToMedia = media => ({\n  \"xs\": \"(max-width: 576px)\",\n  \"sm\": \"(min-width: 576px)\",\n  \"md\": \"(min-width: 768px)\",\n  \"lg\": \"(min-width: 992px)\",\n  \"xl\": \"(min-width: 1200px)\"\n})[media] || media;\n\nconst browserMatchMedia = media => window.matchMedia(media).matches;\n/**\n * @hidden\n */\n\n\nlet ResponsiveService = /*#__PURE__*/(() => {\n  class ResponsiveService {\n    constructor() {\n      /**\n       * @hidden\n       */\n      this.matchMedia = browserMatchMedia;\n    }\n    /**\n     * @hidden\n     */\n\n\n    matchesMedia(media) {\n      return !media || this.matchMedia(bootstrapToMedia(media));\n    }\n\n  }\n\n  ResponsiveService.ɵfac = function ResponsiveService_Factory(t) {\n    return new (t || ResponsiveService)();\n  };\n\n  ResponsiveService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResponsiveService,\n    factory: ResponsiveService.ɵfac\n  });\n  return ResponsiveService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ExcelService = /*#__PURE__*/(() => {\n  class ExcelService {\n    constructor() {\n      this.saveToExcel = new EventEmitter();\n      this.exportClick = new EventEmitter();\n    }\n\n    save(component) {\n      if (this.saveToExcel.observers.length === 0) {\n        if (isDevMode()) {\n          throw new Error('Saving excel requires including the ExcelModule and adding the <kendo-grid-excel> component.');\n        }\n      } else {\n        this.saveToExcel.emit(component);\n      }\n    }\n\n  }\n\n  ExcelService.ɵfac = function ExcelService_Factory(t) {\n    return new (t || ExcelService)();\n  };\n\n  ExcelService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExcelService,\n    factory: ExcelService.ɵfac\n  });\n  return ExcelService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the toolbar template of the Grid.\n *\n * The template context has the following field:\n * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are \"top\" and \"bottom\".\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <div class=\"example-config\">\n *         <input type=\"radio\" id=\"top\" name=\"position\" value=\"top\" checked (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"top\">Top</label><br/>\n *         <input type=\"radio\" id=\"bottom\" name=\"position\" value=\"bottom\" (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"bottom\">Bottom</label><br/>\n *         <input type=\"radio\" id=\"both\" name=\"position\" value=\"both\" (click)=\"positionChange($event)\"/>\n *         <label class=\"k-radio-label\" for=\"both\">Both</label><br/>\n *       </div>\n *       <kendo-grid [data]=\"gridData\" style=\"height: 200px\">\n *            <ng-template kendoGridToolbarTemplate [position]=\"position\" let-position=\"position\">\n *                <button (click)=\"onClick()\">Custom action</button>\n *            </ng-template>\n *            <kendo-grid-column field=\"ProductName\">\n *            </kendo-grid-column>\n *            <kendo-grid-column field=\"UnitPrice\">\n *            </kendo-grid-column>\n *        </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public position: 'top' | 'bottom' | 'both' = 'top';\n *\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n *\n *     public onClick(): void {\n *         console.log(\"button was clicked\");\n *     }\n *\n *     public positionChange({ target }): void {\n *        this.position = target.value;\n *     }\n * }\n *\n * ```\n */\n\n\nlet ToolbarTemplateDirective = /*#__PURE__*/(() => {\n  class ToolbarTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n      this._position = \"top\";\n    }\n    /**\n     * The position of the toolbar ([see example]({% slug toolbartemplate_grid %})).\n     *\n     * The possible values are:\n     * - `top`&mdash;Positions the toolbar above the group panel or header.\n     * - `bottom`&mdash;Positions the toolbar below the pager.\n     * - `both`&mdash;Displays two toolbar instances. Positions the first one above\n     * the group panel or header and the second one below the pager.\n     */\n\n\n    set position(position) {\n      this._position = position;\n    }\n\n    get position() {\n      return this._position;\n    }\n\n  }\n\n  ToolbarTemplateDirective.ɵfac = function ToolbarTemplateDirective_Factory(t) {\n    return new (t || ToolbarTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ToolbarTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ToolbarTemplateDirective,\n    selectors: [[\"\", \"kendoGridToolbarTemplate\", \"\"]],\n    inputs: {\n      position: \"position\"\n    }\n  });\n  return ToolbarTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ScrollSyncService = /*#__PURE__*/(() => {\n  class ScrollSyncService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.changes = new Subject();\n      this.elements = [];\n      this.subscriptions = new Subscription();\n      this.headerSubscription = new Subscription();\n      this.bodySubscription = new Subscription();\n      this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));\n    }\n\n    registerEmitter(el, sourceType) {\n      this.unregister(sourceType);\n      this.elements.push({\n        element: el,\n        sourceType\n      });\n\n      if (sourceType === \"body\" || sourceType === \"header\") {\n        this.ngZone.runOutsideAngular(() => {\n          const obs = fromEvent(el, \"scroll\").pipe(map(({\n            target: {\n              scrollLeft\n            }\n          }) => ({\n            scrollLeft,\n            sourceType\n          })));\n          const subscription = obs.pipe(distinctUntilChanged((x, y) => x.scrollLeft === y.scrollLeft), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType)).subscribe(x => this.changes.next(x));\n          subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType)).subscribe(() => this.source = undefined));\n\n          if (sourceType === \"body\") {\n            this.bodySubscription.add(subscription);\n          } else {\n            this.headerSubscription.add(subscription);\n          }\n        });\n      }\n    }\n    /**\n     * destroy\n     */\n\n\n    destroy() {\n      this.subscriptions.unsubscribe();\n      this.headerSubscription.unsubscribe();\n      this.bodySubscription.unsubscribe();\n    }\n\n    scrollLeft({\n      scrollLeft,\n      sourceType\n    }) {\n      this.ngZone.runOutsideAngular(() => {\n        this.elements.filter(x => sourceType !== x.sourceType).forEach(({\n          element\n        }) => element.scrollLeft = scrollLeft);\n      });\n    }\n\n    unregister(sourceType) {\n      const index = this.elements.findIndex(x => x.sourceType === sourceType);\n\n      if (index > -1) {\n        if (sourceType === \"header\") {\n          this.headerSubscription.unsubscribe();\n          this.headerSubscription = new Subscription();\n        } else if (sourceType === \"body\") {\n          this.bodySubscription.unsubscribe();\n          this.bodySubscription = new Subscription();\n        }\n\n        this.elements.splice(index, 1);\n      }\n    }\n\n  }\n\n  ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) {\n    return new (t || ScrollSyncService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  ScrollSyncService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollSyncService,\n    factory: ScrollSyncService.ɵfac\n  });\n  return ScrollSyncService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ResizeService = /*#__PURE__*/(() => {\n  class ResizeService {\n    constructor() {\n      this.resizeSubscription = new Subscription(() => {});\n      this.dispatcher = new Subject();\n      this.changes = this.dispatcher.asObservable().pipe(throttleTime(100));\n    }\n\n    connect(resizes) {\n      this.resizeSubscription.add(resizes.subscribe(this.dispatcher));\n    }\n\n    destroy() {\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  ResizeService.ɵfac = function ResizeService_Factory(t) {\n    return new (t || ResizeService)();\n  };\n\n  ResizeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResizeService,\n    factory: ResizeService.ɵfac\n  });\n  return ResizeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;\n/**\n * @hidden\n */\n\n\nconst resizeArgs = (column, extra) => Object.assign({\n  columns: leafColumns([column]),\n  locked: isLocked(column)\n}, extra);\n/**\n * @hidden\n */\n\n\nlet ColumnResizingService = /*#__PURE__*/(() => {\n  class ColumnResizingService {\n    constructor() {\n      this.changes = new EventEmitter();\n      this.tables = [];\n      this.batch = null;\n    }\n\n    start(column) {\n      this.trackColumns(column);\n      const columns = (this.column.isColumnGroup ? [column] : []).concat(leafColumns([column]));\n      this.changes.emit({\n        columns: columns,\n        locked: isLocked(this.column),\n        type: 'start'\n      });\n    }\n\n    resizeColumns(deltaPercent) {\n      const action = resizeArgs(this.column, {\n        deltaPercent,\n        type: 'resizeColumn'\n      });\n      this.changes.emit(action);\n    }\n\n    resizeTable(column, delta) {\n      const action = resizeArgs(column, {\n        delta,\n        type: 'resizeTable'\n      });\n      this.changes.emit(action);\n    }\n\n    resizedColumn(state) {\n      this.resizedColumns.push(state);\n    }\n\n    end() {\n      this.changes.emit({\n        columns: [],\n        resizedColumns: this.resizedColumns,\n        type: 'end'\n      });\n    }\n\n    registerTable(tableMetadata) {\n      this.tables.push(tableMetadata);\n\n      const unregisterTable = () => {\n        this.tables.splice(this.tables.indexOf(tableMetadata), 1);\n      };\n\n      return unregisterTable;\n    }\n\n    measureColumns(info) {\n      if (this.batch !== null) {\n        this.batch.push(...info);\n      } else {\n        this.autoFitBatch(info, () => this.end());\n      }\n    }\n\n    autoFit(...columns) {\n      const nonLockedColumns = columns.filter(column => !column.isLocked);\n      this.autoFitStart(nonLockedColumns);\n      this.autoFitBatch(this.batch, () => {\n        if (nonLockedColumns.length < columns.length) {\n          const lockedColumns = columns.filter(column => column.isLocked);\n          this.autoFitStart(lockedColumns);\n          this.autoFitBatch(this.batch, () => this.end());\n        } else {\n          this.end();\n        }\n      });\n    }\n\n    trackColumns(column) {\n      this.resizedColumns = [];\n      this.column = column;\n    }\n\n    autoFitStart(columns) {\n      this.batch = [];\n      this.resizedColumns = [];\n\n      if (columns.length === 0) {\n        return;\n      }\n\n      const locked = columns[0].isLocked;\n      this.changes.emit({\n        type: 'start',\n        columns,\n        locked\n      });\n      this.changes.emit({\n        type: 'triggerAutoFit',\n        columns,\n        locked\n      });\n    }\n\n    autoFitBatch(info, onComplete) {\n      const locked = info.length > 0 ? info[0].column.isLocked : false;\n      const observables = this.tables.filter(table => table.locked === locked).map(table => table.autoFit(info));\n      zip$1(...observables).pipe(take(1)).subscribe(widths => {\n        this.changes.emit({\n          columns: info.map(i => i.column),\n          type: 'autoFitComplete',\n          widths,\n          locked\n        });\n\n        if (onComplete) {\n          onComplete();\n        }\n      });\n      this.batch = null;\n    }\n\n  }\n\n  ColumnResizingService.ɵfac = function ColumnResizingService_Factory(t) {\n    return new (t || ColumnResizingService)();\n  };\n\n  ColumnResizingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColumnResizingService,\n    factory: ColumnResizingService.ɵfac\n  });\n  return ColumnResizingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst isFilterable = settings => settings !== false;\n/**\n * @hidden\n */\n\n\nconst hasFilterMenu = settings => typeof settings === 'string' && settings.indexOf('menu') > -1;\n/**\n * @hidden\n */\n\n\nconst hasFilterRow = settings => settings === true || typeof settings === 'string' && settings.indexOf('row') > -1;\n\nconst contains$1 = (node, predicate) => {\n  while (node) {\n    if (predicate(node)) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n};\n/**\n * Arguments for the `close` event of the filter and column-menu popup.\n */\n\n\nclass PopupCloseEvent extends PreventableEvent {\n  constructor(e) {\n    super();\n    this.originalEvent = e;\n  }\n\n}\n\nconst DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';\n/**\n * The service that is used for the popups of the filter and column menus\n * ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-menu-with-popup)).\n */\n\nlet SinglePopupService = /*#__PURE__*/(() => {\n  class SinglePopupService {\n    constructor(popupService, renderer, ngZone, scrollSyncService, localization) {\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.localization = localization;\n      /**\n       * Fires when the filter or column menus are about to close because the user clicked outside their popups.\n       * Used to prevent the popup from closing.\n       */\n\n      this.onClose = new Subject();\n      this.scrollSubscription = scrollSyncService.changes.subscribe(() => this.destroy());\n    }\n    /**\n     * @hidden\n     */\n\n\n    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {\n      const toggle = isPresent(popupRef) && this.popupRef === popupRef;\n      this.destroy();\n\n      if (!toggle) {\n        const direction = this.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          },\n          anchor: anchor,\n          popupClass: popupClass,\n          content: template,\n          positionMode: \"absolute\"\n        });\n        this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');\n        this.attachClose(anchor);\n      }\n\n      return this.popupRef;\n    }\n    /**\n     * @hidden\n     */\n\n\n    destroy() {\n      if (this.popupRef) {\n        this.detachClose();\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy();\n      this.scrollSubscription.unsubscribe();\n    }\n\n    detachClose() {\n      if (this.removeClick) {\n        this.removeClick();\n      }\n    }\n\n    attachClose(skipElement) {\n      this.detachClose();\n      this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen(\"document\", \"click\", e => {\n        if (!contains$1(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {\n          const args = new PopupCloseEvent(e);\n          this.onClose.next(args);\n\n          if (!args.isDefaultPrevented()) {\n            this.destroy();\n          }\n        }\n      }));\n    }\n\n  }\n\n  SinglePopupService.ɵfac = function SinglePopupService_Factory(t) {\n    return new (t || SinglePopupService)(i0.ɵɵinject(i1$2.PopupService), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(ScrollSyncService), i0.ɵɵinject(i1.LocalizationService));\n  };\n\n  SinglePopupService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SinglePopupService,\n    factory: SinglePopupService.ɵfac\n  });\n  return SinglePopupService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable  no-bitwise */\n\n/**\n * @hidden\n */\n\n\nconst append = element => {\n  let appended = false;\n  return () => {\n    if (!appended) {\n      document.body.appendChild(element);\n      appended = true;\n    }\n\n    return element;\n  };\n};\n/**\n * @hidden\n */\n\n\nconst getDocument = element => element.ownerDocument.documentElement;\n/**\n * @hidden\n */\n\n\nconst getWindow = element => element.ownerDocument.defaultView;\n/**\n * @hidden\n */\n\n\nconst offset = element => {\n  const {\n    clientTop,\n    clientLeft\n  } = getDocument(element);\n  const {\n    pageYOffset,\n    pageXOffset\n  } = getWindow(element);\n  const {\n    top,\n    left\n  } = element.getBoundingClientRect();\n  return {\n    top: top + pageYOffset - clientTop,\n    left: left + pageXOffset - clientLeft\n  };\n};\n/**\n * @hidden\n * If the target is before the draggable element, returns `true`.\n *\n * DOCUMENT_POSITION_FOLLOWING = 4\n */\n\n\nconst isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;\n/**\n * @hidden\n * If the container and the element are the same\n * or if the container holds (contains) the element, returns `true`.\n *\n * DOCUMENT_POSITION_CONTAINED_BY = 16\n */\n\n\nconst contains = (element, container) => element === container || (container.compareDocumentPosition(element) & 16) !== 0;\n/**\n * @hidden\n */\n\n\nconst position = (target, before) => {\n  const targetRect = offset(target);\n  const {\n    offsetWidth,\n    offsetHeight\n  } = target;\n  const left = targetRect.left + (before ? 0 : offsetWidth);\n  const top = targetRect.top;\n  const height = offsetHeight;\n  return {\n    left,\n    top,\n    height\n  };\n};\n/**\n * @hidden\n */\n\n\nlet DragAndDropService = /*#__PURE__*/(() => {\n  class DragAndDropService {\n    constructor() {\n      this.changes = new EventEmitter();\n      this.register = [];\n      this.lastTarget = null;\n    }\n\n    add(target) {\n      this.register.push(target);\n    }\n\n    remove(target) {\n      this.register = this.register.filter(current => current !== target);\n    }\n\n    notifyDrag(draggable, element, mouseEvent) {\n      const target = this.targetFor(element);\n\n      if (this.lastTarget === target) {\n        return;\n      }\n\n      this.changes.next({\n        draggable,\n        mouseEvent,\n        target: this.lastTarget,\n        type: 'leave'\n      });\n\n      if (target) {\n        this.changes.next({\n          draggable,\n          mouseEvent,\n          target,\n          type: 'enter'\n        });\n      }\n\n      this.lastTarget = target;\n    }\n\n    notifyDrop(draggable, mouseEvent) {\n      this.changes.next({\n        draggable,\n        mouseEvent,\n        target: this.lastTarget,\n        type: 'drop'\n      });\n      this.lastTarget = null;\n    }\n\n    targetFor(element) {\n      const comparer = contains.bind(null, element);\n      return this.register.find(({\n        element: {\n          nativeElement\n        }\n      }) => comparer(nativeElement));\n    }\n\n  }\n\n  DragAndDropService.ɵfac = function DragAndDropService_Factory(t) {\n    return new (t || DragAndDropService)();\n  };\n\n  DragAndDropService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DragAndDropService,\n    factory: DragAndDropService.ɵfac\n  });\n  return DragAndDropService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst updateClass = (element, valid) => {\n  const icon = element.querySelector('.k-icon');\n  icon.className = icon.className.replace(/(plus|cancel)/, valid ? 'plus' : 'cancel');\n};\n\nconst updateLock = (element, locked = null) => {\n  const icon = element.querySelectorAll('.k-icon')[1];\n  const value = locked === null ? '' : locked ? 'k-i-lock' : 'k-i-unlock';\n  icon.className = icon.className.replace(/(k-i-unlock|k-i-lock)/, '') + ` ${value}`;\n};\n\nconst decorate = element => {\n  element.className = 'k-header k-drag-clue';\n  element.style.position = 'absolute';\n  element.style.zIndex = '20000';\n};\n/**\n * @hidden\n */\n\n\nlet DragHintService = /*#__PURE__*/(() => {\n  class DragHintService {\n    constructor(santizer) {\n      this.santizer = santizer;\n    }\n\n    create(title) {\n      this.dom = document.createElement(\"div\");\n      decorate(this.dom);\n      const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);\n      this.dom.innerHTML = `\n            <span class=\"k-icon k-drag-status k-i-cancel k-icon-with-modifier\">\n                <span class=\"k-icon k-icon-modifier\"></span>\n            </span>\n            ${safeTitle}\n        `;\n    }\n\n    attach() {\n      return append(this.dom);\n    }\n\n    remove() {\n      if (this.dom && this.dom.parentNode) {\n        (function (el) {\n          setTimeout(() => document.body.removeChild(el));\n        })(this.dom); // hack for IE + pointer events!\n\n\n        this.dom = null;\n      }\n    }\n\n    show() {\n      this.dom.style.display = \"\";\n    }\n\n    hide() {\n      this.dom.style.display = \"none\";\n    }\n\n    enable() {\n      updateClass(this.dom, true);\n    }\n\n    disable() {\n      updateClass(this.dom, false);\n    }\n\n    removeLock() {\n      updateLock(this.dom);\n    }\n\n    toggleLock(locked) {\n      updateLock(this.dom, locked);\n    }\n\n    move(move) {\n      this.dom.style.top = move.pageY + 'px';\n      this.dom.style.left = move.pageX + 'px';\n    }\n\n  }\n\n  DragHintService.ɵfac = function DragHintService_Factory(t) {\n    return new (t || DragHintService)(i0.ɵɵinject(i1$3.DomSanitizer));\n  };\n\n  DragHintService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DragHintService,\n    factory: DragHintService.ɵfac\n  });\n  return DragHintService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DropCueService = /*#__PURE__*/(() => {\n  class DropCueService {\n    create() {\n      this.dom = document.createElement(\"div\");\n      this.dom.className = 'k-grouping-dropclue';\n      this.hide();\n    }\n\n    attach() {\n      return append(this.dom);\n    }\n\n    remove() {\n      if (this.dom && this.dom.parentElement) {\n        document.body.removeChild(this.dom);\n        this.dom = null;\n      }\n    }\n\n    hide() {\n      this.dom.style.display = \"none\";\n    }\n\n    position({\n      left,\n      top,\n      height\n    }) {\n      this.dom.style.display = 'block';\n      this.dom.style.height = height + 'px';\n      this.dom.style.top = top + 'px';\n      const width = this.dom.offsetWidth / 2;\n      this.dom.style.left = left - width + 'px';\n    }\n\n  }\n\n  DropCueService.ɵfac = function DropCueService_Factory(t) {\n    return new (t || DropCueService)();\n  };\n\n  DropCueService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DropCueService,\n    factory: DropCueService.ɵfac\n  });\n  return DropCueService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColumnReorderService = /*#__PURE__*/(() => {\n  class ColumnReorderService {\n    constructor() {\n      this.changes = new EventEmitter();\n    }\n\n    reorder(e) {\n      this.changes.emit(e);\n    }\n\n  }\n\n  ColumnReorderService.ɵfac = function ColumnReorderService_Factory(t) {\n    return new (t || ColumnReorderService)();\n  };\n\n  ColumnReorderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColumnReorderService,\n    factory: ColumnReorderService.ɵfac\n  });\n  return ColumnReorderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `columnReorder` event.\n */\n\n\nclass ColumnReorderEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor({\n    column,\n    newIndex,\n    oldIndex\n  }) {\n    super();\n    this.column = column;\n    this.newIndex = newIndex;\n    this.oldIndex = oldIndex;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass NavigationMetadata {\n  constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {\n    this.dataRows = dataRows;\n    this.headerRows = headerRows;\n    this.isVirtual = isVirtual;\n    this.hasPager = hasPager;\n    this.hasDetailTemplate = hasDetailTemplate;\n    this.gridElement = gridElement;\n    this.virtualColumns = virtualColumns;\n    this.columns = columns;\n  }\n\n  get maxLogicalRowIndex() {\n    const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;\n    return this.headerRows + dataRows - 1;\n  }\n\n}\n\nconst NO_STICKY = {\n  left: '0px',\n  right: '0px'\n};\n/**\n * @hidden\n */\n\nlet ColumnInfoService = /*#__PURE__*/(() => {\n  class ColumnInfoService {\n    constructor() {\n      this.visibilityChange = new EventEmitter();\n      this.lockedChange = new EventEmitter();\n      this.stickyChange = new EventEmitter();\n      this.columnRangeChange = new EventEmitter();\n      this.columnsContainer = new ColumnsContainer(() => []);\n    }\n\n    get lockedLeafColumns() {\n      return this.columnsContainer.lockedLeafColumns;\n    }\n\n    get nonLockedLeafColumns() {\n      return this.columnsContainer.nonLockedLeafColumns;\n    }\n\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n\n    get totalLevels() {\n      return this.columnsContainer.totalLevels;\n    }\n\n    get hiddenColumns() {\n      if (!this.list) {\n        return [];\n      }\n\n      return this.list().filter(column => !column.isVisible);\n    }\n\n    get leafNamedColumns() {\n      const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup)).filter(column => column.matchesMedia && column.displayTitle);\n      return orderBy(columns, [{\n        field: 'locked',\n        dir: 'desc'\n      }]);\n    }\n\n    get unlockedRootCount() {\n      return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;\n    }\n\n    stickyColumnsStyles(column) {\n      if (!this.stickyColumns) {\n        this.stickyColumns = this.list().rootColumns().filter(column => column.sticky && !column.locked && column.isVisible);\n      }\n\n      if (this.stickyColumns.length === 0) {\n        return NO_STICKY;\n      }\n\n      const result = this.stickyColumns.reduce((acc, curr) => {\n        if (curr.leafIndex < column.leafIndex) {\n          acc.left += curr.width;\n        } else if (curr.leafIndex > column.leafIndex) {\n          acc.right += curr.width;\n        }\n\n        return acc;\n      }, {\n        left: 0,\n        right: 0\n      });\n      return {\n        left: `${result.left}px`,\n        right: `${result.right}px`\n      };\n    }\n\n    init(columns, list) {\n      this.columnsContainer = columns;\n      this.list = list;\n      this.stickyColumns = null;\n    }\n\n    changeVisibility(columns) {\n      this.stickyColumns = null;\n      this.visibilityChange.emit(columns);\n    }\n\n    changeLocked(columns) {\n      this.stickyColumns = null;\n      this.lockedChange.emit(columns);\n    }\n\n    changeStuck(columns) {\n      this.stickyColumns = null;\n      this.stickyChange.emit(columns);\n    }\n\n  }\n\n  ColumnInfoService.ɵfac = function ColumnInfoService_Factory(t) {\n    return new (t || ColumnInfoService)();\n  };\n\n  ColumnInfoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColumnInfoService,\n    factory: ColumnInfoService.ɵfac\n  });\n  return ColumnInfoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass SortService {\n  constructor() {\n    this.changes = new Subject();\n  }\n\n  sort(value) {\n    this.changes.next(value);\n  }\n\n}\n/**\n * Arguments for the `columnVisibilityChange` event.\n */\n\n\nclass ColumnVisibilityChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    this.columns = columns;\n  }\n\n}\n/**\n * Arguments for the `columnLockedChange` event.\n */\n\n\nclass ColumnLockedChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    this.columns = columns;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!\n\n/**\n * @hidden\n */\n\nconst RESPONSIVE_BREAKPOINT_MEDIUM = 600;\n/**\n * @hidden\n */\n\nconst RESPONSIVE_BREAKPOINT_LARGE = 768;\n/**\n * @hidden\n */\n\nfunction defaultTrackBy(index, item) {\n  if (item.type === 'data' && item.isEditing) {\n    return item.data;\n  }\n\n  return index;\n}\n/**\n * Arguments for the `columnStickyChange` event.\n */\n\n\nclass ColumnStickyChangeEvent {\n  /**\n   * @hidden\n   */\n  constructor(columns) {\n    this.columns = columns;\n  }\n\n}\n/**\n * Represents the virtual scrolling cell template of the Grid while loading new data. Provides an option to customize the\n * appearance of the indicator that is displayed while new data is loading. To define the loading cell template,\n * nest an `<ng-template>` tag with the `kendoGridCellLoadingTemplate` directive inside `<kendo-grid>` ([see example]({% slug virtualscrolling_grid %}#toc-custom-loading-skeleton)).\n *\n * The template context is set to the current column, and utilizes the `let-x` syntax&mdash;for example, `let-column`.\n *\n * @example\n * ```ts-no-run\n *       <kendo-grid [data]=\"data\" scrollable=\"virtual\" [rowHeight]=\"36\">\n *         <ng-template kendoGridCellLoadingTemplate let-column>\n *             ...\n *         </ng-template>\n *       </kendo-grid>\n * ```\n */\n\n\nlet CellLoadingTemplateDirective = /*#__PURE__*/(() => {\n  class CellLoadingTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  CellLoadingTemplateDirective.ɵfac = function CellLoadingTemplateDirective_Factory(t) {\n    return new (t || CellLoadingTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  CellLoadingTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CellLoadingTemplateDirective,\n    selectors: [[\"\", \"kendoGridCellLoadingTemplate\", \"\"]]\n  });\n  return CellLoadingTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Creates a loading template that overrides the default loading indicator of the Grid Component.\n * To define a loading template, nest an `<ng-template>` tag with the `kendoGridLoadingTemplate` directive inside the `<kendo-grid>` tag\n * [see example]({% slug databinding_grid %}#toc-loading-template).\n */\n\n\nlet LoadingTemplateDirective = /*#__PURE__*/(() => {\n  class LoadingTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  LoadingTemplateDirective.ɵfac = function LoadingTemplateDirective_Factory(t) {\n    return new (t || LoadingTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  LoadingTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LoadingTemplateDirective,\n    selectors: [[\"\", \"kendoGridLoadingTemplate\", \"\"]]\n  });\n  return LoadingTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ToolbarComponent = /*#__PURE__*/(() => {\n  class ToolbarComponent {\n    constructor(ctx) {\n      this.ctx = ctx;\n      this.context = {};\n    }\n\n    set position(value) {\n      this.context.position = value;\n    }\n\n    get toolbarTemplateRef() {\n      return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : undefined;\n    }\n\n  }\n\n  ToolbarComponent.ɵfac = function ToolbarComponent_Factory(t) {\n    return new (t || ToolbarComponent)(i0.ɵɵdirectiveInject(ContextService));\n  };\n\n  ToolbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolbarComponent,\n    selectors: [[\"kendo-grid-toolbar\"]],\n    inputs: {\n      position: \"position\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function ToolbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, null, 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.toolbarTemplateRef);\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return ToolbarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst normalizeSettings = ({\n  buttonCount = 10,\n  info = true,\n  type = 'numeric',\n  pageSizes = false,\n  previousNext = true,\n  responsive = true,\n  position = 'bottom'\n}) => ({\n  buttonCount,\n  info,\n  pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,\n  previousNext,\n  type,\n  responsive,\n  position\n});\n/**\n * @hidden\n */\n\n\nconst normalize$1 = settings => normalizeSettings(settings === true ? {} : settings);\n/**\n * @hidden\n */\n\n\nlet FocusGroup = /*#__PURE__*/(() => {\n  class FocusGroup {\n    constructor(root) {\n      this.root = root;\n      this.active = true;\n      this.children = [];\n      this.root.registerGroup(this);\n    }\n\n    get focusableChildren() {\n      return this.children.filter(el => el.canFocus());\n    }\n\n    get isActive() {\n      return this.active;\n    }\n\n    ngOnDestroy() {\n      this.root.unregisterGroup(this);\n    }\n\n    registerElement(element) {\n      this.unregisterElement(element);\n      this.children.push(element);\n    }\n\n    unregisterElement(element) {\n      this.children = this.children.filter(f => f !== element);\n    }\n    /**\n     * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.\n     * Requires a single \"simple\" focusable element such as a button or a checkbox.\n     */\n\n\n    isNavigable() {\n      const focusable = this.focusableChildren;\n      return focusable.length === 1 && focusable[0].isNavigable();\n    }\n\n    canFocus() {\n      return this.focusableChildren.length > 0;\n    }\n\n    focus() {\n      if (this.canFocus() && !this.hasFocus()) {\n        this.focusableChildren[0].focus();\n      }\n    }\n\n    activate() {\n      this.toggleState(true);\n    }\n\n    deactivate() {\n      this.toggleState(false);\n    }\n\n    hasFocus() {\n      return this.children.reduce((focused, element) => focused || element.hasFocus(), false);\n    }\n\n    toggleState(active) {\n      if (this.active !== active) {\n        this.active = active;\n        this.children.forEach(f => f.toggle(active));\n      }\n    }\n\n  }\n\n  FocusGroup.ɵfac = function FocusGroup_Factory(t) {\n    return new (t || FocusGroup)(i0.ɵɵinject(FocusRoot));\n  };\n\n  FocusGroup.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusGroup,\n    factory: FocusGroup.ɵfac\n  });\n  return FocusGroup;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PagerElementComponent = /*#__PURE__*/(() => {\n  class PagerElementComponent {\n    constructor(localization, pagerContext, cd) {\n      this.localization = localization;\n      this.pagerContext = pagerContext;\n      this.cd = cd;\n      this.total = this.pagerContext.total;\n      this.skip = this.pagerContext.skip;\n      this.pageSize = this.pagerContext.pageSize;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerElementComponent\n     */\n\n\n    get currentPage() {\n      return Math.floor((this.skip || 0) / this.pageSize) + 1;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerElementComponent\n     */\n\n\n    get totalPages() {\n      return Math.ceil((this.total || 0) / this.pageSize);\n    }\n    /**\n     * @hidden\n     *\n     * @param {string} key\n     * @returns {string}\n     *\n     * @memberOf PagerElementComponent\n     */\n\n\n    textFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     *\n     * @param {number} page\n     *\n     * @memberOf PagerElementComponent\n     */\n\n\n    changePage(page) {\n      this.pagerContext.changePage(page);\n      return false;\n    }\n    /**\n     * @hidden\n     *\n     * @memberOf PagerElementComponent\n     */\n\n\n    ngOnInit() {\n      this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));\n      this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n  }\n\n  PagerElementComponent.ɵfac = function PagerElementComponent_Factory(t) {\n    return new (t || PagerElementComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  PagerElementComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PagerElementComponent\n  });\n  return PagerElementComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays buttons for navigating to the first and to the previous page ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\n\n\nlet PagerPrevButtonsComponent = /*#__PURE__*/(() => {\n  class PagerPrevButtonsComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, cd, navigationService) {\n      super(localization, pagerContext, cd);\n      this.navigationService = navigationService;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerPrevButtonsComponent\n     */\n\n\n    get disabled() {\n      return this.currentPage === 1 || !this.total;\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = pageSize;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerPrevButtonsComponent.ɵfac = function PagerPrevButtonsComponent_Factory(t) {\n    return new (t || PagerPrevButtonsComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  PagerPrevButtonsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerPrevButtonsComponent,\n    selectors: [[\"kendo-pager-prev-buttons\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 16,\n    consts: [[\"role\", \"button\", 3, \"kendoGridFocusable\", \"title\", \"ngClass\", \"click\", \"keydown.enter\"], [\"role\", \"note\", 3, \"ngClass\"]],\n    template: function PagerPrevButtonsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵlistener(\"click\", function PagerPrevButtonsComponent_Template_span_click_0_listener() {\n          return ctx.currentPage !== 1 ? ctx.changePage(0) : false;\n        })(\"keydown.enter\", function PagerPrevButtonsComponent_Template_span_keydown_enter_0_listener() {\n          return ctx.currentPage !== 1 ? ctx.changePage(0) : false;\n        });\n        i0.ɵɵelement(1, \"span\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"span\", 0);\n        i0.ɵɵlistener(\"click\", function PagerPrevButtonsComponent_Template_span_click_2_listener() {\n          return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false;\n        })(\"keydown.enter\", function PagerPrevButtonsComponent_Template_span_keydown_enter_2_listener() {\n          return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false;\n        });\n        i0.ɵɵelement(3, \"span\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"kendoGridFocusable\", !ctx.disabled)(\"title\", ctx.textFor(\"pagerFirstPage\"))(\"ngClass\", i0.ɵɵpureFunction1(10, _c0, ctx.disabled));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(12, _c1));\n        i0.ɵɵattribute(\"aria-label\", ctx.textFor(\"pagerFirstPage\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoGridFocusable\", !ctx.disabled)(\"title\", ctx.textFor(\"pagerPreviousPage\"))(\"ngClass\", i0.ɵɵpureFunction1(13, _c2, ctx.disabled));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(15, _c3));\n        i0.ɵɵattribute(\"aria-label\", ctx.textFor(\"pagerPreviousPage\"));\n      }\n    },\n    directives: [FocusableDirective, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PagerPrevButtonsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays numeric buttons to enable navigation between the pages.\n */\n\n\nlet PagerNumericButtonsComponent = /*#__PURE__*/(() => {\n  class PagerNumericButtonsComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext) {\n      super(localization, pagerContext, cd);\n      this.pagerContext = pagerContext;\n      this.numbersWrapClass = true;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number[]}\n     * @memberOf PagerNumericButtonsComponent\n     */\n\n\n    get buttons() {\n      let result = [];\n\n      for (let idx = this.start; idx <= this.end; idx++) {\n        result.push(idx);\n      }\n\n      return result;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get end() {\n      return Math.min(this.start + this.buttonCount - 1, this.totalPages);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get start() {\n      const page = this.currentPage;\n      const buttonCount = this.buttonCount;\n\n      if (page > buttonCount) {\n        const reminder = page % buttonCount;\n        return reminder === 0 ? page - buttonCount + 1 : page - reminder + 1;\n      }\n\n      return 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageLabel(num) {\n      const pageText = this.textFor('pagerPage');\n\n      if (pageText) {\n        return pageText + ' ' + num;\n      }\n\n      return num.toString();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onSelectChange(e) {\n      const target = e.target;\n      const valueAsNumber = Number(target.value);\n\n      if (!Number.isNaN(valueAsNumber)) {\n        this.changePage(valueAsNumber - 1);\n      } else {\n        if (target.value === 'previousButtons') {\n          this.changePage(this.start - 2);\n        } else {\n          this.changePage(this.end);\n        }\n      }\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = pageSize;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerNumericButtonsComponent.ɵfac = function PagerNumericButtonsComponent_Factory(t) {\n    return new (t || PagerNumericButtonsComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PagerContextService));\n  };\n\n  PagerNumericButtonsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerNumericButtonsComponent,\n    selectors: [[\"kendo-pager-numeric-buttons\"]],\n    hostVars: 2,\n    hostBindings: function PagerNumericButtonsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-pager-numbers-wrap\", ctx.numbersWrapClass);\n      }\n    },\n    inputs: {\n      buttonCount: \"buttonCount\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 8,\n    vars: 8,\n    consts: [[\"kendoGridFocusable\", \"\", \"tabindex\", \"0\", 1, \"k-dropdownlist\", \"k-pager-nav\", 3, \"change\"], [\"class\", \"k-link\", \"value\", \"previousButtons\", 3, \"selected\", 4, \"ngIf\"], [3, \"value\", \"selected\", \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [\"value\", \"nextButtons\", \"class\", \"k-link\", 3, \"selected\", 4, \"ngIf\"], [3, \"ngClass\"], [4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"value\", \"previousButtons\", 1, \"k-link\", 3, \"selected\"], [3, \"value\", \"selected\", \"ngClass\"], [\"value\", \"nextButtons\", 1, \"k-link\", 3, \"selected\"], [\"kendoGridFocusable\", \"\", \"tabindex\", \"0\", \"role\", \"button\", 1, \"k-link\", \"k-pager-nav\", 3, \"click\", \"keydown.enter\"], [\"kendoGridFocusable\", \"\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"ngClass\", \"click\", \"keydown.enter\"]],\n    template: function PagerNumericButtonsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"select\", 0);\n        i0.ɵɵlistener(\"change\", function PagerNumericButtonsComponent_Template_select_change_0_listener($event) {\n          return ctx.onSelectChange($event);\n        });\n        i0.ɵɵtemplate(1, PagerNumericButtonsComponent_option_1_Template, 2, 2, \"option\", 1);\n        i0.ɵɵtemplate(2, PagerNumericButtonsComponent_option_2_Template, 2, 8, \"option\", 2);\n        i0.ɵɵtemplate(3, PagerNumericButtonsComponent_option_3_Template, 2, 2, \"option\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"ul\", 4);\n        i0.ɵɵtemplate(5, PagerNumericButtonsComponent_li_5_Template, 3, 1, \"li\", 5);\n        i0.ɵɵtemplate(6, PagerNumericButtonsComponent_li_6_Template, 3, 5, \"li\", 6);\n        i0.ɵɵtemplate(7, PagerNumericButtonsComponent_li_7_Template, 3, 1, \"li\", 5);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.start > 1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.buttons);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.end < ctx.totalPages);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(7, _c6));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.start > 1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.buttons);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.end < ctx.totalPages);\n      }\n    },\n    directives: [FocusableDirective, i4.NgIf, i4.NgForOf, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PagerNumericButtonsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PagerInputDirective = /*#__PURE__*/(() => {\n  class PagerInputDirective {\n    constructor(host, renderer) {\n      this.host = host;\n      this.renderer = renderer;\n    }\n\n    ngAfterViewInit() {\n      const inputElement = this.host.numericInput.nativeElement;\n      this.renderer.addClass(inputElement, 'k-pager-nav');\n    }\n\n  }\n\n  PagerInputDirective.ɵfac = function PagerInputDirective_Factory(t) {\n    return new (t || PagerInputDirective)(i0.ɵɵdirectiveInject(i4$1.NumericTextBoxComponent), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  PagerInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PagerInputDirective,\n    selectors: [[\"\", \"kendoGridPagerInput\", \"\"]]\n  });\n  return PagerInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays an input element which allows the typing and rendering of page numbers.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-grid\n *        [kendoGridBinding]=\"gridData\"\n *        [pageSize]=\"1\"\n *        [pageable]=\"true\"\n *      >\n *       <kendo-grid-column field=\"ProductID\" title=\"ID\" [width]=\"40\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"ProductName\" title=\"Name\" [width]=\"250\">\n *       </kendo-grid-column>\n *       <kendo-grid-column field=\"UnitPrice\" title=\"Price\" [width]=\"80\" format=\"{0:c}\">\n *       </kendo-grid-column>\n *\n *       <ng-template kendoPagerTemplate let-totalPages=\"totalPages\" let-currentPage=\"currentPage\">\n *          <kendo-pager-prev-buttons></kendo-pager-prev-buttons>\n *          <kendo-pager-numeric-buttons [buttonCount]=\"10\"></kendo-pager-numeric-buttons>\n *          <kendo-pager-next-buttons></kendo-pager-next-buttons>\n *          <kendo-pager-input></kendo-pager-input>\n *          <kendo-pager-info></kendo-pager-info>\n *       </ng-template>\n *\n *    </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000,\n *         \"Discontinued\": false\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000,\n *         \"Discontinued\": true\n *       }\n *     ];\n * }\n *\n * ```\n */\n\n\nlet PagerInputComponent = /*#__PURE__*/(() => {\n  class PagerInputComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, zone, navigationService, cd) {\n      super(localization, pagerContext, cd);\n      this.pagerContext = pagerContext;\n      this.zone = zone;\n      this.navigationService = navigationService;\n      /**\n       * @hidden\n       *\n       * @param {string} value\n       *\n       * @memberOf PagerInputComponent\n       */\n\n      this.handleKeyDown = event => {\n        let incomingValue = this.numericInput.value || this.current;\n\n        if (event.keyCode === Keys.Enter) {\n          event.preventDefault();\n\n          if (incomingValue !== this.current) {\n            this.zone.run(() => {\n              this.changePage(incomingValue - 1);\n            });\n          }\n        }\n      };\n      /**\n       * @hidden\n       *\n       * @param {string} value\n       *\n       * @memberOf PagerInputComponent\n       */\n\n\n      this.handleBlur = () => {\n        const inputValue = this.numericInput.value;\n\n        if (!inputValue) {\n          this.numericInput.writeValue(this.current);\n          return;\n        }\n\n        if (inputValue !== this.current) {\n          this.zone.run(() => {\n            this.changePage(inputValue - 1);\n          });\n        }\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get current() {\n      return this.hasPages ? this.currentPage : 0;\n    }\n\n    get hasPages() {\n      return this.totalPages !== 0;\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = pageSize;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerInputComponent.ɵfac = function PagerInputComponent_Factory(t) {\n    return new (t || PagerInputComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  PagerInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerInputComponent,\n    selectors: [[\"kendo-pager-input\"]],\n    viewQuery: function PagerInputComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NumericTextBoxComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 19,\n    consts: [[3, \"ngClass\"], [\"kendoGridPagerInput\", \"\", \"format\", \"n0\", 3, \"kendoGridFocusable\", \"tabindex\", \"spinners\", \"decimals\", \"disabled\", \"value\", \"min\", \"max\", \"autoCorrect\", \"title\", \"kendoEventsOutsideAngular\"]],\n    template: function PagerInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelement(2, \"kendo-numerictextbox\", 1);\n        i0.ɵɵtext(3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(15, _c7));\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.textFor(\"pagerPage\"), \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoGridFocusable\", ctx.hasPages)(\"tabindex\", 0)(\"spinners\", false)(\"decimals\", 0)(\"disabled\", !ctx.hasPages)(\"value\", ctx.current)(\"min\", ctx.hasPages ? 1 : 0)(\"max\", ctx.totalPages)(\"autoCorrect\", true)(\"title\", ctx.textFor(\"pagerPageNumberInputTitle\"))(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(16, _c8, ctx.handleKeyDown, ctx.handleBlur));\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate2(\" \", ctx.textFor(\"pagerOf\"), \" \", ctx.totalPages, \" \");\n      }\n    },\n    directives: [i4$1.NumericTextBoxComponent, i4.NgClass, PagerInputDirective, FocusableDirective, i1$1.EventsOutsideAngularDirective],\n    encapsulation: 2\n  });\n  return PagerInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays buttons for navigating to the next and to the last page ([see example]({% slug paging_grid %}#toc-pager-template)).\n */\n\n\nlet PagerNextButtonsComponent = /*#__PURE__*/(() => {\n  class PagerNextButtonsComponent extends PagerElementComponent {\n    constructor(localization, pagerContext, cd, navigationService) {\n      super(localization, pagerContext, cd);\n      this.navigationService = navigationService;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerNextButtonsComponent\n     */\n\n\n    get disabled() {\n      return this.currentPage === this.totalPages || !this.total;\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = pageSize;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerNextButtonsComponent.ɵfac = function PagerNextButtonsComponent_Factory(t) {\n    return new (t || PagerNextButtonsComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  PagerNextButtonsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerNextButtonsComponent,\n    selectors: [[\"kendo-pager-next-buttons\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 16,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", 3, \"kendoGridFocusable\", \"title\", \"ngClass\", \"click\", \"keydown.enter\"], [\"role\", \"note\", 3, \"ngClass\"]],\n    template: function PagerNextButtonsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵlistener(\"click\", function PagerNextButtonsComponent_Template_span_click_0_listener() {\n          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false;\n        })(\"keydown.enter\", function PagerNextButtonsComponent_Template_span_keydown_enter_0_listener() {\n          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false;\n        });\n        i0.ɵɵelement(1, \"span\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"span\", 0);\n        i0.ɵɵlistener(\"click\", function PagerNextButtonsComponent_Template_span_click_2_listener() {\n          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false;\n        })(\"keydown.enter\", function PagerNextButtonsComponent_Template_span_keydown_enter_2_listener() {\n          return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false;\n        });\n        i0.ɵɵelement(3, \"span\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"kendoGridFocusable\", !ctx.disabled)(\"title\", ctx.textFor(\"pagerNextPage\"))(\"ngClass\", i0.ɵɵpureFunction1(10, _c2, ctx.disabled));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(12, _c9));\n        i0.ɵɵattribute(\"aria-label\", ctx.textFor(\"pagerNextPage\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoGridFocusable\", !ctx.disabled)(\"title\", ctx.textFor(\"pagerLastPage\"))(\"ngClass\", i0.ɵɵpureFunction1(13, _c10, ctx.disabled));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction0(15, _c11));\n        i0.ɵɵattribute(\"aria-label\", ctx.textFor(\"pagerLastPage\"));\n      }\n    },\n    directives: [FocusableDirective, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PagerNextButtonsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n/**\n * Displays information about the current page and the total number of records ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\n\n\nlet PagerInfoComponent = /*#__PURE__*/(() => {\n  class PagerInfoComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext) {\n      super(localization, pagerContext, cd);\n      this.pagerContext = pagerContext;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerInfoComponent\n     */\n\n\n    get maxItems() {\n      return Math.min(this.currentPage * this.pageSize, this.total);\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {number}\n     * @memberOf PagerInfoComponent\n     */\n\n\n    get currentPageText() {\n      return this.total ? (this.currentPage - 1) * this.pageSize + 1 : 0;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberOf PagerInfoComponent\n     */\n\n\n    get classes() {\n      return true;\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = pageSize;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerInfoComponent.ɵfac = function PagerInfoComponent_Factory(t) {\n    return new (t || PagerInfoComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PagerContextService));\n  };\n\n  PagerInfoComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerInfoComponent,\n    selectors: [[\"kendo-pager-info\"]],\n    hostVars: 4,\n    hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-pager-info\", ctx.classes)(\"k-label\", ctx.classes);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 5,\n    template: function PagerInfoComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtext(0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵtextInterpolate5(\"\", ctx.currentPageText, \" - \", ctx.maxItems, \" \", ctx.textFor(\"pagerOf\"), \" \", ctx.total, \" \", ctx.textFor(\"pagerItems\"), \"\");\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PagerInfoComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PagerDropDownListDirective = /*#__PURE__*/(() => {\n  class PagerDropDownListDirective {\n    constructor(host) {\n      this.host = host;\n\n      this.keydownHandler = e => {\n        if (e.keyCode === Keys.Escape && this.host.isOpen) {\n          e.stopPropagation();\n          this.host.toggle(false);\n        }\n      };\n    }\n\n    ngAfterViewInit() {\n      const wrapperElement = this.host.wrapper.nativeElement;\n      wrapperElement.addEventListener('keydown', this.keydownHandler, true);\n    }\n\n    ngOnDestroy() {\n      this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);\n    }\n\n  }\n\n  PagerDropDownListDirective.ɵfac = function PagerDropDownListDirective_Factory(t) {\n    return new (t || PagerDropDownListDirective)(i0.ɵɵdirectiveInject(i1$4.DropDownListComponent));\n  };\n\n  PagerDropDownListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PagerDropDownListDirective,\n    selectors: [[\"\", \"kendoGridPagerDropDown\", \"\"]]\n  });\n  return PagerDropDownListDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays a drop-down list for the page size selection ([see example]({% slug paging_grid %}#toc-pager-templates)).\n */\n\n\nlet PagerPageSizesComponent = /*#__PURE__*/(() => {\n  class PagerPageSizesComponent extends PagerElementComponent {\n    constructor(localization, cd, pagerContext, navigationService) {\n      super(localization, pagerContext, cd);\n      this.pagerContext = pagerContext;\n      this.navigationService = navigationService;\n      this._pageSizes = [];\n    }\n    /**\n     * The page sizes collection. Can be an Array of numbers and/or PageSizeItem objects.\n     *\n     * @example\n     * ```ts-preview\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid [kendoGridBinding]=\"gridData\" [height]=\"200\"\n     *           [pageable]=\"true\"\n     *            [pageSize]=\"pageSize\">\n     *            <ng-template kendoPagerTemplate let-totalPages=\"totalPages\" let-currentPage=\"currentPage\">\n     *                <kendo-pager-page-sizes [pageSizes]=\"pagesizes\"></kendo-pager-page-sizes>\n     *            </ng-template>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     *    public pageSize = 2;\n     *    public pagesizes = [{text: 'One', value: 1}, {text: 'Two', value: 2}, {text: 'All', value : 'all'}];\n     * }\n     *\n     * const products = [{\n     *   'ProductID' : 1,\n     *   'ProductName' : \"Chai\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 1,\n     *   'QuantityPerUnit' : \"10 boxes x 20 bags\",\n     *   'UnitPrice' : 18.0000,\n     *   'UnitsInStock' : 39,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 10,\n     *   'Discontinued' : false\n     *\n     * }, {\n     *   'ProductID' : 2,\n     *   'ProductName' : \"Chang\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 1,\n     *   'QuantityPerUnit' : \"24 - 12 oz bottles\",\n     *   'UnitPrice' : 19.0000,\n     *   'UnitsInStock' : 17,\n     *   'UnitsOnOrder' : 40,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 3,\n     *   'ProductName' : \"Aniseed Syrup\",\n     *   'SupplierID' : 1,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"12 - 550 ml bottles\",\n     *   'UnitPrice' : 10.0000,\n     *   'UnitsInStock' : 13,\n     *   'UnitsOnOrder' : 70,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 4,\n     *   'ProductName' : \"Chef Anton\\'s Cajun Seasoning\",\n     *   'SupplierID' : 2,\n     *  'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"48 - 6 oz jars\",\n     *   'UnitPrice' : 22.0000,\n     *   'UnitsInStock' : 53,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 0,\n     *   'Discontinued' : false\n     * }, {\n     *   'ProductID' : 5,\n     *   'ProductName' : \"Chef Anton\\'s Gumbo Mix\",\n     *   'SupplierID' : 2,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"36 boxes\",\n     *   'UnitPrice' : 21.3500,\n     *   'UnitsInStock' : 0,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 0,\n     *   'Discontinued' : true\n     * }, {\n     *   'ProductID' : 6,\n     *   'ProductName' : \"Grandma\\'s Boysenberry Spread\",\n     *   'SupplierID' : 3,\n     *   'CategoryID' : 2,\n     *   'QuantityPerUnit' : \"12 - 8 oz jars\",\n     *   'UnitPrice' : 25.0000,\n     *   'UnitsInStock' : 120,\n     *   'UnitsOnOrder' : 0,\n     *   'ReorderLevel' : 25,\n     *   'Discontinued' : false\n     * }];\n     * ```\n     */\n\n\n    set pageSizes(pageSizes) {\n      let normalizedItems = [];\n      pageSizes.forEach(item => {\n        if (typeof item === 'number') {\n          normalizedItems.push({\n            text: item.toString(),\n            value: item\n          });\n        } else {\n          normalizedItems.push(item);\n        }\n      });\n\n      if (this.pageSize && !normalizedItems.some(item => item.value === this.pageSize)) {\n        normalizedItems = [{\n          text: this.pageSize.toString(),\n          value: this.pageSize\n        }, ...normalizedItems];\n      }\n\n      this._pageSizes = normalizedItems;\n    }\n\n    get pageSizes() {\n      return this._pageSizes;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     */\n\n\n    get classes() {\n      return true;\n    }\n    /**\n     * @hidden\n     *\n     * @readonly\n     */\n\n\n    get showInitialPageSize() {\n      return this.pageSizes.filter(item => {\n        if (typeof item.value === 'number') {\n          return item.value === Number(this.pageSize);\n        }\n\n        return this.total === Number(this.pageSize);\n      }).length === 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageSizeChange(value) {\n      this.pageSize = typeof value === 'number' ? value : this.total;\n      this.pagerContext.changePageSize(this.pageSize);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getValue(page) {\n      return typeof page.value === 'number' ? page.value : this.total;\n    }\n\n    onChanges({\n      total,\n      skip,\n      pageSize\n    }) {\n      this.total = total;\n      this.skip = skip;\n      this.pageSize = typeof pageSize === 'number' ? pageSize : this.total;\n      this.cd.markForCheck();\n    }\n\n  }\n\n  PagerPageSizesComponent.ɵfac = function PagerPageSizesComponent_Factory(t) {\n    return new (t || PagerPageSizesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  PagerPageSizesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerPageSizesComponent,\n    selectors: [[\"kendo-pager-page-sizes\"]],\n    hostVars: 4,\n    hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-pager-sizes\", ctx.classes)(\"k-label\", ctx.classes);\n      }\n    },\n    inputs: {\n      pageSizes: \"pageSizes\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 6,\n    consts: [[\"kendoGridPagerDropDown\", \"\", \"kendoGridFocusable\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"tabindex\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [\"dropdownlist\", \"\"], [3, \"for\", \"text\"]],\n    template: function PagerPageSizesComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 0, 1);\n        i0.ɵɵlistener(\"valueChange\", function PagerPageSizesComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n          return ctx.pageSizeChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(2, \"kendo-label\", 2);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵproperty(\"tabindex\", 0)(\"data\", ctx.pageSizes)(\"valuePrimitive\", true)(\"value\", ctx.pageSize);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"for\", _r0)(\"text\", ctx.textFor(\"pagerItemsPerPage\"));\n      }\n    },\n    directives: [i1$4.DropDownListComponent, i5.LabelComponent, PagerDropDownListDirective, FocusableDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PagerPageSizesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PagerComponent = /*#__PURE__*/(() => {\n  class PagerComponent {\n    constructor(pagerContext, navigationService, element, renderer, zone, localizationService, cellContext, focusRoot, focusGroup) {\n      this.pagerContext = pagerContext;\n      this.navigationService = navigationService;\n      this.element = element;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.localizationService = localizationService;\n      this.cellContext = cellContext;\n      this.focusRoot = focusRoot;\n      this.focusGroup = focusGroup;\n      this.total = 0;\n      this.skip = 1;\n      this.pageChange = new EventEmitter();\n      this.pagerWrapClass = true;\n      this.gridPagerClass = true;\n      this.settings = normalize$1({});\n      this.subscriptions = new Subscription();\n      this._templateContext = {};\n      this._isFocused = false;\n\n      this.resizeHandler = () => {\n        const element = this.element.nativeElement;\n\n        if (this.template || !element) {\n          return;\n        }\n\n        const width = element.offsetWidth;\n\n        if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {\n          this.renderer.removeClass(element, 'k-pager-md');\n          this.renderer.addClass(element, 'k-pager-sm');\n        } else if (width >= RESPONSIVE_BREAKPOINT_MEDIUM && width < RESPONSIVE_BREAKPOINT_LARGE) {\n          this.renderer.addClass(element, 'k-pager-md');\n          this.renderer.removeClass(element, 'k-pager-sm');\n        } else {\n          this.clearResponsiveClasses();\n        }\n      };\n    }\n\n    set options(value) {\n      this.settings = normalize$1(value);\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    get pagerAriaLabel() {\n      return this.navigationService.pagerEnabled ? this.pagerLabel : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pagerLabel() {\n      const localizationMsg = this.localizationService.get('pagerLabel') || '';\n      return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, 'currentPage', this.currentPage.toString()), 'totalPages', this.totalPages.toString());\n    }\n\n    get focusTrapTabIndex() {\n      return this.focusGroup.isActive ? '0' : '-1';\n    }\n\n    onFocusIn(event) {\n      if (this.navigationService.pagerEnabled) {\n        const shouldFocusPager = event.target === this.element.nativeElement;\n\n        if (shouldFocusPager) {\n          this._isFocused = true;\n          this.focusRoot.deactivate();\n        } else {\n          this.focusRoot.activate();\n        }\n      }\n    }\n\n    onFocusOut() {\n      if (this.navigationService.pagerEnabled) {\n        this._isFocused = false;\n      }\n    }\n\n    onEscape() {\n      if (this.navigationService.pagerEnabled) {\n        this.focusRoot.deactivate();\n        this.element.nativeElement.focus();\n      }\n    }\n\n    onEnter(event) {\n      if (this.navigationService.pagerEnabled && event.target === this.element.nativeElement) {\n        this.focusRoot.activate();\n        this.focusFirstElement();\n      }\n    }\n\n    navigateToPreviousPage(e) {\n      if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {\n        this.pagerContext.prevPage();\n      }\n    }\n\n    navigateToNextPage(e) {\n      if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {\n        this.pagerContext.nextPage();\n      }\n    }\n\n    navigateToFirstPage(e) {\n      if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {\n        this.pagerContext.changePage(0);\n      }\n    }\n\n    navigateToLastPage(e) {\n      if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {\n        this.pagerContext.changePage(this.totalPages - 1);\n      }\n    }\n\n    get totalPages() {\n      return Math.ceil((this.total || 0) / this.pageSize);\n    }\n\n    get currentPage() {\n      return Math.floor((this.skip || 0) / this.pageSize) + 1;\n    }\n\n    get templateContext() {\n      const context = this._templateContext;\n      context.totalPages = this.totalPages;\n      context.total = this.total;\n      context.skip = this.skip;\n      context.pageSize = this.pageSize;\n      context.currentPage = this.currentPage;\n      return context;\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));\n\n      if (this.navigationService.pagerEnabled) {\n        this.focusRoot.deactivate();\n      }\n    }\n\n    ngDoCheck() {\n      this.updateCellContext();\n    }\n\n    ngOnChanges(changes) {\n      if (anyChanged(['pageSize', 'skip', 'total'], changes, false)) {\n        this.pagerContext.notifyChanges({\n          pageSize: this.pageSize,\n          skip: this.skip,\n          total: this.total\n        });\n      }\n\n      if (changes.template) {\n        // eslint-disable-next-line no-unused-expressions\n        changes.template.currentValue ? this.clearResponsiveClasses() : this.resizeHandler();\n      }\n\n      if (changes.options) {\n        // eslint-disable-next-line no-unused-expressions\n        this.settings.responsive ? this.resizeHandler() : this.clearResponsiveClasses();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    changePage(event) {\n      this.pageChange.emit(event);\n    }\n\n    onInnerFocusIn(event, position) {\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        if (position === 'start') {\n          if (event.relatedTarget === this.element.nativeElement) {\n            this.focusFirstElement();\n          } else {\n            this.focusLastElement();\n          }\n        } else {\n          this.focusFirstElement();\n        }\n      });\n    }\n\n    clearResponsiveClasses() {\n      const element = this.element.nativeElement;\n      this.renderer.removeClass(element, 'k-pager-sm');\n      this.renderer.removeClass(element, 'k-pager-md');\n    }\n\n    shouldTriggerPageChange(target, condition) {\n      return this.navigationService.pagerEnabled && target === this.element.nativeElement && condition;\n    }\n\n    focusFirstElement() {\n      const first = findFocusableChild(this.element.nativeElement, true);\n\n      if (first) {\n        first.focus();\n      }\n    }\n\n    focusLastElement() {\n      const last = findLastFocusableChild(this.element.nativeElement, true);\n\n      if (last) {\n        last.focus();\n      }\n    }\n\n    updateCellContext() {\n      if (this.cellContext) {\n        this.cellContext.focusGroup = this.focusGroup;\n      }\n    }\n\n  }\n\n  PagerComponent.ɵfac = function PagerComponent_Factory(t) {\n    return new (t || PagerComponent)(i0.ɵɵdirectiveInject(PagerContextService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(CELL_CONTEXT, 8), i0.ɵɵdirectiveInject(FocusRoot), i0.ɵɵdirectiveInject(FocusGroup));\n  };\n\n  PagerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PagerComponent,\n    selectors: [[\"kendo-pager\"]],\n    hostVars: 7,\n    hostBindings: function PagerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusin\", function PagerComponent_focusin_HostBindingHandler($event) {\n          return ctx.onFocusIn($event);\n        })(\"focusout\", function PagerComponent_focusout_HostBindingHandler() {\n          return ctx.onFocusOut();\n        })(\"keydown.escape\", function PagerComponent_keydown_escape_HostBindingHandler() {\n          return ctx.onEscape();\n        })(\"keydown.enter\", function PagerComponent_keydown_enter_HostBindingHandler($event) {\n          return ctx.onEnter($event);\n        })(\"keydown.arrowleft\", function PagerComponent_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.navigateToPreviousPage($event);\n        })(\"keydown.pageup\", function PagerComponent_keydown_pageup_HostBindingHandler($event) {\n          return ctx.navigateToPreviousPage($event);\n        })(\"keydown.arrowright\", function PagerComponent_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.navigateToNextPage($event);\n        })(\"keydown.pagedown\", function PagerComponent_keydown_pagedown_HostBindingHandler($event) {\n          return ctx.navigateToNextPage($event);\n        })(\"keydown.home\", function PagerComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.navigateToFirstPage($event);\n        })(\"keydown.end\", function PagerComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.navigateToLastPage($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.pagerAriaLabel);\n        i0.ɵɵclassProp(\"k-pager-wrap\", ctx.pagerWrapClass)(\"k-grid-pager\", ctx.gridPagerClass)(\"k-state-focused\", ctx.isFocused);\n      }\n    },\n    inputs: {\n      total: \"total\",\n      skip: \"skip\",\n      pageSize: \"pageSize\",\n      options: \"options\",\n      template: \"template\"\n    },\n    outputs: {\n      pageChange: \"pageChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FOCUS_ROOT_ACTIVE,\n      useValue: true\n    }, {\n      provide: FocusRoot,\n      deps: [FOCUS_ROOT_ACTIVE],\n      useClass: FocusRoot\n    }, {\n      provide: FocusGroup,\n      deps: [FocusRoot],\n      useClass: FocusGroup\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[\"class\", \"k-sr-only\", 3, \"tabindex\", \"focusin\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"resize\", 4, \"ngIf\"], [1, \"k-sr-only\", 3, \"tabindex\", \"focusin\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"buttonCount\", 4, \"ngIf\"], [3, \"pageSizes\", 4, \"ngIf\"], [3, \"buttonCount\"], [3, \"pageSizes\"], [\"pageSizes\", \"\"], [3, \"resize\"]],\n    template: function PagerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, PagerComponent_div_0_Template, 1, 2, \"div\", 0);\n        i0.ɵɵtemplate(1, PagerComponent_ng_container_1_Template, 1, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, PagerComponent_ng_container_2_Template, 7, 6, \"ng-container\", 2);\n        i0.ɵɵtemplate(3, PagerComponent_div_3_Template, 1, 2, \"div\", 0);\n        i0.ɵɵtemplate(4, PagerComponent_kendo_resize_sensor_4_Template, 1, 0, \"kendo-resize-sensor\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.navigationService.pagerEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template == null ? null : ctx.template.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !(ctx.template == null ? null : ctx.template.templateRef));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.navigationService.pagerEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.settings.responsive);\n      }\n    },\n    directives: [PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerInfoComponent, PagerPageSizesComponent, i1$1.ResizeSensorComponent, i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return PagerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DropTargetDirective = /*#__PURE__*/(() => {\n  class DropTargetDirective {\n    constructor(element, service) {\n      this.element = element;\n      this.service = service;\n      this.context = {};\n      this.enter = new EventEmitter();\n      this.leave = new EventEmitter();\n      this.drop = new EventEmitter();\n      this.subscriptions = new Subscription();\n    }\n\n    ngOnInit() {\n      this.service.add(this);\n      const changes = this.service.changes.pipe(filter(({\n        target\n      }) => target === this));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'leave')).subscribe(e => {\n        this.leave.next(this.eventArgs(e));\n      }));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'enter')).subscribe(e => {\n        this.enter.next(this.eventArgs(e));\n      }));\n      this.subscriptions.add(changes.pipe(filter(({\n        type\n      }) => type === 'drop')).subscribe(e => {\n        this.drop.next(this.eventArgs(e));\n      }));\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    eventArgs(e) {\n      return {\n        target: this,\n        mouseEvent: e.mouseEvent,\n        draggable: e.draggable\n      };\n    }\n\n  }\n\n  DropTargetDirective.ɵfac = function DropTargetDirective_Factory(t) {\n    return new (t || DropTargetDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DragAndDropService));\n  };\n\n  DropTargetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropTargetDirective,\n    selectors: [[\"\", \"kendoDropTarget\", \"\"]],\n    inputs: {\n      context: \"context\"\n    },\n    outputs: {\n      enter: \"enter\",\n      leave: \"leave\",\n      drop: \"drop\"\n    }\n  });\n  return DropTargetDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet GroupIndicatorComponent = /*#__PURE__*/(() => {\n  class GroupIndicatorComponent {\n    constructor() {\n      this.directionChange = new EventEmitter();\n      this.remove = new EventEmitter();\n    }\n\n    get groupIndicatorClass() {\n      return true;\n    }\n\n    get dir() {\n      return this.group.dir ? this.group.dir : \"asc\";\n    }\n\n    toggleDirection() {\n      this.directionChange.emit({\n        dir: this.dir === \"asc\" ? \"desc\" : \"asc\",\n        field: this.group.field\n      });\n      return false;\n    }\n\n    removeDescriptor() {\n      this.remove.emit({\n        dir: this.group.dir,\n        field: this.group.field\n      });\n      return false;\n    }\n\n  }\n\n  GroupIndicatorComponent.ɵfac = function GroupIndicatorComponent_Factory(t) {\n    return new (t || GroupIndicatorComponent)();\n  };\n\n  GroupIndicatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GroupIndicatorComponent,\n    selectors: [[\"\", \"kendoGroupIndicator\", \"\"]],\n    hostVars: 2,\n    hostBindings: function GroupIndicatorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-group-indicator\", ctx.groupIndicatorClass);\n      }\n    },\n    inputs: {\n      group: \"group\",\n      groupTitle: \"groupTitle\"\n    },\n    outputs: {\n      directionChange: \"directionChange\",\n      remove: \"remove\"\n    },\n    attrs: _c12,\n    decls: 5,\n    vars: 5,\n    consts: [[\"href\", \"#\", \"tabindex\", \"-1\", 1, \"k-link\", 3, \"click\"], [1, \"k-icon\"], [\"tabindex\", \"-1\", 1, \"k-button\", \"k-button-flat-base\", \"k-button-flat\", \"k-icon-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", \"k-icon-button\", 3, \"click\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-group-delete\"]],\n    template: function GroupIndicatorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"a\", 0);\n        i0.ɵɵlistener(\"click\", function GroupIndicatorComponent_Template_a_click_0_listener() {\n          return ctx.toggleDirection();\n        });\n        i0.ɵɵelement(1, \"span\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"a\", 2);\n        i0.ɵɵlistener(\"click\", function GroupIndicatorComponent_Template_a_click_3_listener() {\n          return ctx.removeDescriptor();\n        });\n        i0.ɵɵelement(4, \"span\", 3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-i-sort-asc-sm\", ctx.dir === \"asc\")(\"k-i-sort-desc-sm\", ctx.dir === \"desc\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.groupTitle, \"\");\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return GroupIndicatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n\nconst hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);\n\nconst isDeleteButton = or(hasClass('k-i-group-delete'), hasClass('k-icon-button'));\nconst isSortIcon = or(hasClass('k-i-sort-asc-sm'), hasClass('k-i-sort-desc-sm'));\nconst skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName('label')));\n\nconst elementUnderCursor = ({\n  clientX,\n  clientY\n}) => document.elementFromPoint(clientX, clientY);\n\nconst hideThenShow = (element, cont) => {\n  element.style.display = 'none';\n  const result = cont();\n  element.style.display = 'block';\n  return result;\n};\n/**\n * @hidden\n */\n\n\nlet DraggableColumnDirective = /*#__PURE__*/(() => {\n  class DraggableColumnDirective {\n    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {\n      this.draggable = draggable;\n      this.element = element;\n      this.zone = zone;\n      this.service = service;\n      this.hint = hint;\n      this.cue = cue;\n      this.nav = nav;\n      this.renderer = renderer;\n      this.context = {};\n      this.drag = new EventEmitter();\n      this.subscriptions = new Subscription();\n    }\n\n    set enableDrag(enabled) {\n      this.enabled = enabled;\n      this.updateTouchAction();\n    }\n\n    get hostClass() {\n      return this.enabled;\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(_ => this.enabled), filter(({\n        originalEvent: {\n          target\n        }\n      }) => target === this.element.nativeElement || skipButtons(target)), tap(e => {\n        const originalEvent = e.originalEvent;\n\n        if (!e.isTouch) {\n          originalEvent.preventDefault();\n        }\n\n        this.nav.navigateTo(originalEvent.target);\n      }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(_ => {\n        this.hint.create(this.context.hint);\n        this.cue.create();\n      }), switchMap(down => this.draggable.kendoDrag.pipe(tap(e => {\n        if (e.isTouch) {\n          e.originalEvent.preventDefault();\n        }\n      }), tap(this.hint.attach()), tap(this.cue.attach()), // eslint-disable-next-line rxjs/no-unsafe-takeuntil\n      takeUntil(this.draggable.kendoRelease), map(move => ({\n        move,\n        down\n      })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    drop(upEvent) {\n      this.hint.remove();\n      this.cue.remove();\n      this.service.notifyDrop(this, upEvent);\n    }\n\n    performDrag({\n      move\n    }) {\n      this.hint.move(move);\n      const cursorElement = this.elementUnderCursor(move);\n\n      if (cursorElement) {\n        this.service.notifyDrag(this, cursorElement, move);\n      }\n\n      this.drag.emit({\n        draggable: this,\n        mouseEvent: move\n      });\n    }\n\n    elementUnderCursor(mouseEvent) {\n      this.hint.hide();\n      let target = elementUnderCursor(mouseEvent);\n\n      if (target && /k-grouping-dropclue/.test(target.className)) {\n        target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));\n      }\n\n      this.hint.show();\n      return target;\n    }\n\n    updateTouchAction() {\n      if (!this.element) {\n        return;\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      this.enabled ? this.renderer.addClass(this.element.nativeElement, 'k-touch-action-none') : this.renderer.removeClass(this.element.nativeElement, 'k-touch-action-none');\n    }\n\n  }\n\n  DraggableColumnDirective.ɵfac = function DraggableColumnDirective_Factory(t) {\n    return new (t || DraggableColumnDirective)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DragAndDropService), i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  DraggableColumnDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DraggableColumnDirective,\n    selectors: [[\"\", \"kendoDraggableColumn\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DraggableColumnDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-draggable-header\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      context: \"context\",\n      enableDrag: \"enableDrag\"\n    },\n    outputs: {\n      drag: \"drag\"\n    }\n  });\n  return DraggableColumnDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst withoutField = ({\n  field\n}) => isNullOrEmptyString(field);\n\nconst alreadyGrouped = ({\n  groups,\n  field\n}) => groups.some(group => group.field === field);\n\nconst overSameTarget = ({\n  target,\n  field\n}) => target.field === field;\n\nconst overLastTarget = ({\n  target\n}) => target.lastTarget;\n\nconst isLastGroup = ({\n  groups,\n  field\n}) => groups.map(group => group.field).indexOf(field) === groups.length - 1;\n\nconst isNotGroupable = groupsService => ({\n  field\n}) => !groupsService.isGroupable(field);\n\nconst columnRules = groupService => or(withoutField, alreadyGrouped, isNotGroupable(groupService));\n\nconst indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));\n/**\n * @hidden\n */\n\nlet GroupPanelComponent = /*#__PURE__*/(() => {\n  class GroupPanelComponent {\n    constructor(hint, cue, groupInfoService, localization, cd) {\n      this.hint = hint;\n      this.cue = cue;\n      this.groupInfoService = groupInfoService;\n      this.localization = localization;\n      this.cd = cd;\n      this.change = new EventEmitter();\n      this.groups = [];\n      this.dropTargets = new QueryList();\n      this.groupTitles = [];\n      this.subscription = new Subscription();\n    }\n\n    get groupHeaderClass() {\n      return true;\n    }\n\n    set text(value) {\n      this.emptyText = value;\n    }\n\n    get text() {\n      return this.emptyText ? this.emptyText : this.localization.get('groupPanelEmpty');\n    }\n\n    ngAfterViewInit() {\n      this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));\n    }\n\n    ngOnInit() {\n      this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n\n    ngDoCheck() {\n      const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));\n\n      if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {\n        this.groupTitles = currentTitles;\n        this.cd.markForCheck();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n    }\n\n    directionChange(group) {\n      const index = this.groups.findIndex(x => x.field === group.field);\n      const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];\n      this.change.emit(groups);\n    }\n\n    insert(field, index) {\n      const groups = this.groups.filter(x => x.field !== field);\n\n      if (groups.length || this.groups.length === 0) {\n        this.change.emit([...groups.slice(0, index), {\n          field: field\n        }, ...groups.slice(index)]);\n      }\n    }\n\n    remove(group) {\n      this.change.emit(this.groups.filter(x => x.field !== group.field));\n    }\n\n    canDrop(draggable, target) {\n      const isIndicator = draggable.type === 'groupIndicator';\n      const rules = isIndicator ? indicatorRules : columnRules(this.groupInfoService);\n      return !rules({\n        field: draggable.field,\n        groups: this.groups,\n        target\n      });\n    }\n\n    attachTargets() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n\n      this.targetSubscription = new Subscription();\n      const enterStream = this.dropTargets.reduce((acc, target) => merge(acc, target.enter), from([]));\n      const leaveStream = this.dropTargets.reduce((acc, target) => merge(acc, target.leave), from([]));\n      const dropStream = this.dropTargets.reduce((acc, target) => merge(acc, target.drop), from([]));\n      this.targetSubscription.add(enterStream.pipe(tap(_ => this.hint.removeLock()), filter(({\n        draggable,\n        target\n      }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));\n    }\n\n    enter({\n      draggable,\n      target\n    }) {\n      this.hint.enable();\n      let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);\n\n      if (this.localization.rtl) {\n        before = !before;\n      }\n\n      this.cue.position(position(target.element.nativeElement, before));\n    }\n\n    leave() {\n      this.hint.disable();\n      this.cue.hide();\n    }\n\n    drop({\n      target,\n      draggable\n    }) {\n      const field = draggable.context.field;\n      const index = this.dropTargets.toArray().indexOf(target);\n      this.insert(field, index);\n    }\n\n  }\n\n  GroupPanelComponent.ɵfac = function GroupPanelComponent_Factory(t) {\n    return new (t || GroupPanelComponent)(i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  GroupPanelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GroupPanelComponent,\n    selectors: [[\"kendo-grid-group-panel\"]],\n    viewQuery: function GroupPanelComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DropTargetDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropTargets = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function GroupPanelComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grouping-header\", ctx.groupHeaderClass)(\"k-grouping-header-flex\", ctx.groupHeaderClass);\n      }\n    },\n    inputs: {\n      text: \"text\",\n      groups: \"groups\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-indicator-container\", \"kendoDropTarget\", \"\", 3, \"context\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-indicator-container\", \"kendoDropTarget\", \"\", 3, \"context\", 4, \"ngIf\"], [\"kendoDropTarget\", \"\", 1, \"k-indicator-container\", 3, \"context\"], [\"kendoDraggableColumn\", \"\", \"kendoGroupIndicator\", \"\", \"kendoDraggable\", \"\", 3, \"enableDrag\", \"context\", \"group\", \"groupTitle\", \"directionChange\", \"remove\"]],\n    template: function GroupPanelComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, GroupPanelComponent_ng_container_0_Template, 3, 3, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, GroupPanelComponent_div_1_Template, 2, 10, \"div\", 1);\n        i0.ɵɵtemplate(2, GroupPanelComponent_div_2_Template, 2, 2, \"div\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.groups.length === 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.groups.length !== 0);\n      }\n    },\n    directives: [GroupIndicatorComponent, i4.NgIf, DropTargetDirective, i4.NgForOf, DraggableColumnDirective, i1$1.DraggableDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return GroupPanelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColGroupComponent = /*#__PURE__*/(() => {\n  class ColGroupComponent {\n    constructor() {\n      this.columns = [];\n      this.groups = [];\n    }\n\n    get columnsToRender() {\n      return columnsToRender(this.columns);\n    }\n\n    trackBy(index, _item) {\n      return index;\n    }\n\n  }\n\n  ColGroupComponent.ɵfac = function ColGroupComponent_Factory(t) {\n    return new (t || ColGroupComponent)();\n  };\n\n  ColGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColGroupComponent,\n    selectors: [[\"\", \"kendoGridColGroup\", \"\"]],\n    inputs: {\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\"\n    },\n    attrs: _c16,\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"k-group-col\", 4, \"ngFor\", \"ngForOf\"], [3, \"k-hierarchy-col\", 4, \"ngIf\"], [3, \"width\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"]],\n    template: function ColGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵtemplate(1, ColGroupComponent_col_1_Template, 1, 2, \"col\", 0);\n        i0.ɵɵtemplate(2, ColGroupComponent_col_2_Template, 1, 2, \"col\", 1);\n        i0.ɵɵtemplate(3, ColGroupComponent_col_3_Template, 1, 2, \"col\", 2);\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnsToRender)(\"ngForTrackBy\", ctx.trackBy);\n      }\n    },\n    directives: [i4.NgForOf, i4.NgIf],\n    encapsulation: 2\n  });\n  return ColGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst DEFAULTS = {\n  allowUnsort: true,\n  mode: 'single',\n  showIndexes: true,\n  initialDirection: 'asc',\n  multiSortKey: 'none'\n};\n/**\n * @hidden\n */\n\nconst normalize = (...settings) => Object.assign({}, DEFAULTS, ...settings);\n/**\n * @hidden\n */\n\n\nconst hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;\n/**\n * @hidden\n */\n\n\nconst hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;\n/**\n * @hidden\n */\n\n\nconst hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\n\n\nconst hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\n\n\nconst hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);\n/**\n * @hidden\n */\n\n\nconst hasColumnChooser = settings => settings.columnChooser !== false;\n/**\n * @hidden\n */\n\n\nconst hasItems = (settings, column) => hasColumnChooser(settings) || hasLock(settings, column) || hasSort(settings, column) || hasFilter(settings, column);\n\nconst localizeOperators$1 = operators => localization => Object.keys(operators).reduce((acc, key) => {\n  acc[operators[key]] = localization.get(key);\n  return acc;\n}, {});\n\nconst operatorTexts = localizeOperators$1({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterGteOperator\": \"gte\",\n  \"filterGtOperator\": \"gt\",\n  \"filterLteOperator\": \"lte\",\n  \"filterLtOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\",\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterAfterOrEqualOperator\": \"after-eq\",\n  \"filterAfterOperator\": \"after\",\n  \"filterBeforeOrEqualOperator\": \"before-eq\",\n  \"filterBeforeOperator\": \"before\"\n});\n/**\n * @hidden\n */\n\nconst toJSON = xs => xs.map(x => x.toJSON());\n/**\n * @hidden\n */\n\n\nlet FilterOperatorBase = /*#__PURE__*/(() => {\n  class FilterOperatorBase {\n    constructor(operator, localization) {\n      this.operator = operator;\n      this.localization = localization;\n      this.messages = operatorTexts(this.localization);\n      this._text = this.messages[this.operator];\n      this.localization.changes.subscribe(this.refreshText.bind(this));\n    }\n    /**\n     * The text that will be displayed in the drop-down list.\n     * @readonly\n     * @type {string}\n     * @memberOf FilterOperatorBase\n     */\n\n\n    get text() {\n      return this._text;\n    }\n\n    set text(value) {\n      this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toJSON() {\n      return {\n        text: this.text,\n        value: this.operator\n      };\n    }\n\n    refreshText() {\n      const update = this._text === this.messages[this.operator];\n      this.messages = operatorTexts(this.localization);\n\n      if (update) {\n        this._text = this.messages[this.operator];\n      }\n    }\n\n  }\n\n  FilterOperatorBase.ɵfac = function FilterOperatorBase_Factory(t) {\n    return new (t || FilterOperatorBase)(i0.ɵɵdirectiveInject('filterOperator'), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  FilterOperatorBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterOperatorBase,\n    selectors: [[\"kendo-grid-filter-operator-base\"]],\n    inputs: {\n      text: \"text\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function FilterOperatorBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return FilterOperatorBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst insertDefaultFilter = (index, rootFilter, filter) => {\n  rootFilter = rootFilter || {\n    filters: [],\n    logic: \"and\"\n  };\n  rootFilter.filters[index] = filter;\n  return filter;\n};\n/**\n * @hidden\n */\n\n\nconst setFilter = (index, filter, field, defaultOperator) => {\n  if (isPresent(filter) && isPresent(filter.filters) && filter.filters.length > index) {\n    return filter.filters[index];\n  } else {\n    return insertDefaultFilter(index, filter, {\n      field,\n      operator: defaultOperator\n    });\n  }\n};\n/**\n * @hidden\n */\n\n\nconst logicOperators = localization => [{\n  text: localization.get(\"filterAndLogic\"),\n  value: \"and\"\n}, {\n  text: localization.get(\"filterOrLogic\"),\n  value: \"or\"\n}];\n/**\n * @hidden\n */\n\n\nconst flatten = filter => {\n  if (isPresent(filter.filters)) {\n    return filter.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);\n  }\n\n  return [];\n};\n\nconst trimFilterByField = (filter, field) => {\n  if (isPresent(filter) && isPresent(filter.filters)) {\n    filter.filters = filter.filters.filter(x => {\n      if (isCompositeFilterDescriptor(x)) {\n        trimFilterByField(x, field);\n        return x.filters.length;\n      } else {\n        return x.field !== field;\n      }\n    });\n  }\n};\n/**\n * @hidden\n */\n\n\nconst filtersByField = (filter, field) => flatten(filter || {}).filter(x => x.field === field);\n/**\n * @hidden\n */\n\n\nconst filterByField = (filter, field) => {\n  let [currentFilter] = filtersByField(filter, field);\n  return currentFilter;\n};\n/**\n * @hidden\n */\n\n\nconst removeFilter = (filter, field) => {\n  trimFilterByField(filter, field);\n  return filter;\n};\n/**\n * @hidden\n */\n\n\nconst localizeOperators = operators => localization => Object.keys(operators).map(key => ({\n  text: localization.get(key),\n  value: operators[key]\n}));\n/**\n * An abstract base class for the filter-cell component ([see example]({% slug reusablecustomfilters_grid %}#toc-filter-row)).\n */\n\n\nlet BaseFilterCellComponent = /*#__PURE__*/(() => {\n  class BaseFilterCellComponent {\n    constructor(filterService) {\n      this.filterService = filterService;\n      this.operatorList = new QueryList();\n    }\n\n    get hostClasses() {\n      return true;\n    }\n\n    get operators() {\n      var _a;\n\n      return ((_a = this._operators) === null || _a === void 0 ? void 0 : _a.length) ? this._operators : this.defaultOperators;\n    }\n\n    set operators(values) {\n      this._operators = values;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      this.operationListSubscription = observe(this.operatorList).pipe(map(q => q.toArray()), map(toJSON)).subscribe(x => {\n        this.operators = x;\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.operationListSubscription) {\n        this.operationListSubscription.unsubscribe();\n      }\n    }\n\n    filterByField(field) {\n      return filterByField(this.filter, field);\n    }\n\n    filtersByField(field) {\n      return filtersByField(this.filter, field);\n    }\n\n    removeFilter(field) {\n      return removeFilter(this.filter, field);\n    }\n\n    updateFilter(filter) {\n      const root = this.filter || {\n        filters: [],\n        logic: \"and\"\n      };\n      let [currentFilter] = flatten(root).filter(x => x.field === filter.field);\n\n      if (!isPresent(currentFilter)) {\n        root.filters.push(filter);\n      } else {\n        Object.assign(currentFilter, filter);\n      }\n\n      return root;\n    }\n\n    applyFilter(filter) {\n      this.filterService.filter(filter);\n    }\n\n  }\n\n  BaseFilterCellComponent.ɵfac = function BaseFilterCellComponent_Factory(t) {\n    return new (t || BaseFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService));\n  };\n\n  BaseFilterCellComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseFilterCellComponent,\n    contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.operatorList = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      operators: \"operators\"\n    }\n  });\n  return BaseFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;\n\nconst isChanged = (a, b) => {\n  if (a.length !== b.length) {\n    return true;\n  }\n\n  for (let idx = 0, len = a.length; idx < len; idx++) {\n    const prev = a[idx];\n    const curr = b[idx];\n\n    if (isCompositeFilterDescriptor(prev)) {\n      if (diffFilters(prev, curr[idx])) {\n        return true;\n      }\n    } else if (areDifferent(prev, curr)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst copyObject = obj => {\n  const result = {};\n  Object.assign(result, obj);\n\n  if (obj.constructor !== Object) {\n    const proto = obj.constructor.prototype;\n    Object.getOwnPropertyNames(proto).forEach(property => {\n      if (property !== 'constructor' && proto.hasOwnProperty(property)) {\n        result[property] = obj[property];\n      }\n    });\n  }\n\n  return result;\n};\n\nconst cloneFilter = filter => copyObject(filter);\n/**\n * @hidden\n */\n\n\nconst cloneFilters = filter => {\n  if (!filter) {\n    return;\n  }\n\n  if (isCompositeFilterDescriptor(filter)) {\n    return {\n      filters: cloneFilters(filter.filters),\n      logic: filter.logic\n    };\n  } else if (Array.isArray(filter)) {\n    return filter.map(cloneFilters);\n  }\n\n  return cloneFilter(filter);\n};\n/**\n * @hidden\n */\n\n\nconst diffFilters = (a, b) => {\n  if (isPresent(a) && !isPresent(b)) {\n    return true;\n  }\n\n  if (!isPresent(a) && isPresent(b)) {\n    return true;\n  }\n\n  return isPresent(a) && isPresent(b) && isChanged(a.filters, b.filters);\n};\n/**\n * @hidden\n */\n\n\nlet FilterHostDirective = /*#__PURE__*/(() => {\n  class FilterHostDirective {\n    constructor(host, resolver) {\n      this.host = host;\n      this.resolver = resolver;\n    }\n\n    ngOnInit() {\n      this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));\n      this.initComponent({\n        column: this.column,\n        filter: this.filter\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.component) {\n        this.component.destroy();\n        this.component = null;\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (anyChanged([\"column\", \"filter\"], changes)) {\n        this.initComponent({\n          column: this.column,\n          filter: this.filter\n        });\n      }\n    }\n\n    initComponent({\n      column,\n      filter\n    }) {\n      const instance = this.component.instance;\n      instance.column = column;\n      instance.filter = filter;\n    }\n\n  }\n\n  FilterHostDirective.ɵfac = function FilterHostDirective_Factory(t) {\n    return new (t || FilterHostDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  };\n\n  FilterHostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterHostDirective,\n    selectors: [[\"\", \"kendoGridFilterHostBase\", \"\"]],\n    inputs: {\n      column: \"column\",\n      filter: \"filter\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FilterHostDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n\nconst stringOperators$1 = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * Represents a base string filter component.\n */\n\nlet StringFilterComponent = /*#__PURE__*/(() => {\n  class StringFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n      super(filterService);\n      this.localization = localization;\n      /**\n       * The default filter operator. Defaults to `contains`.\n       * @type {string}\n       */\n\n      this.operator = \"contains\";\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    get currentFilter() {\n      return this.filterByField((this.column || {}).field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n\n\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n\n    ngOnInit() {\n      this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      super.ngOnDestroy();\n    }\n\n    localizationChange() {\n      this.defaultOperators = stringOperators$1(this.localization);\n\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n\n  }\n\n  StringFilterComponent.ɵfac = function StringFilterComponent_Factory(t) {\n    return new (t || StringFilterComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StringFilterComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StringFilterComponent,\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return StringFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterInputDirective = /*#__PURE__*/(() => {\n  class FilterInputDirective {\n    constructor(valueAccessors, ngZone, element, renderer) {\n      this.element = element;\n      this.renderer = renderer;\n      this.change = new EventEmitter();\n      this.composing = false;\n      this.filterDelay = 500;\n      this.changeRequests = new Subject();\n      this.accessor = valueAccessors[0];\n      ngZone.runOutsideAngular(() => {\n        const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);\n        const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);\n\n        this.unsubscribeEvents = () => {\n          unsubscribeStart();\n          unsubscribeEnd();\n        };\n      });\n    }\n\n    set value(value) {\n      this.accessor.writeValue(value);\n    }\n\n    set disabled(value) {\n      this.accessor.setDisabledState(value);\n    }\n\n    ngAfterViewInit() {\n      this.addAriaAttributes();\n      this.accessor.registerOnChange(x => this.filterDelay > 0 ? this.changeRequests.next(x) : this.change.emit(x));\n      this.subscribeChanges();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged$1('filterDelay', changes)) {\n        this.unsubscribeChanges();\n        this.subscribeChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribeChanges();\n      this.unsubscribeEvents();\n    }\n\n    subscribeChanges() {\n      this.changeRequestsSubscription = this.changeRequests.pipe(debounceTime(this.filterDelay), filter(() => !this.composing)).subscribe(x => this.change.emit(x));\n    }\n\n    unsubscribeChanges() {\n      if (this.changeRequestsSubscription) {\n        this.changeRequestsSubscription.unsubscribe();\n      }\n    }\n\n    addAriaAttributes() {\n      const ariaValue = this.columnLabel;\n\n      if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {\n        const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) || this.element.nativeElement;\n        this.renderer.setAttribute(focusableElement, 'aria-label', ariaValue);\n      } else {\n        this.renderer.setAttribute(this.element.nativeElement, 'aria-label', ariaValue);\n      }\n    }\n\n  }\n\n  FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) {\n    return new (t || FilterInputDirective)(i0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  FilterInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterInputDirective,\n    selectors: [[\"\", \"kendoFilterInput\", \"\"]],\n    contentQueries: function FilterInputDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KendoInput, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);\n      }\n    },\n    inputs: {\n      filterDelay: \"filterDelay\",\n      columnLabel: \"columnLabel\",\n      value: \"value\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FilterInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);\n\nconst isEmptyValueOperator = operator => EMPTY_VALUE_OPERATORS.has(operator);\n/**\n * @hidden\n */\n\n\nlet FilterInputWrapperComponent = /*#__PURE__*/(() => {\n  class FilterInputWrapperComponent extends BaseFilterCellComponent {\n    constructor(filterService) {\n      super(filterService);\n    }\n\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n\n    get currentOperator() {\n      const filter = this.currentFilter;\n\n      if (!this._operator) {\n        this._operator = filter ? filter.operator : this.defaultOperator;\n      }\n\n      return this._operator;\n    }\n\n    set currentOperator(value) {\n      this._operator = value;\n      const emptyValueOperator = isEmptyValueOperator(value);\n      this.filterInputDisabled = emptyValueOperator;\n\n      if (emptyValueOperator) {\n        this.applyNoValueFilter(value);\n      } else if (!isBlank(value) && isPresent(this.currentFilter)) {\n        this.onChange(this.currentFilter.value);\n      }\n    }\n\n    get defaultOperator() {\n      if (!isNullOrEmptyString(this._defaultOperator)) {\n        return this._defaultOperator;\n      } else if (this.operators && this.operators.length) {\n        return this.operators[0].value;\n      }\n\n      return \"eq\";\n    }\n\n    set defaultOperator(value) {\n      this._defaultOperator = value;\n    }\n\n    set filterInputDisabled(disabled) {\n      if (!this.input) {\n        return;\n      }\n\n      this.input.disabled = disabled;\n    }\n\n    ngAfterContentInit() {\n      if (isPresent(this.input)) {\n        this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));\n        this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n      }\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this.changeSubscription) {\n        this.changeSubscription.unsubscribe();\n      }\n    }\n\n    onChange(value) {\n      if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {\n        this.filterChange(isNullOrEmptyString(value) ? this.removeFilter(this.column.field) : this.updateFilter({\n          field: this.column.field,\n          operator: this.currentOperator,\n          value: value\n        }));\n      }\n    }\n\n    onClear() {\n      this.onChange(null);\n      this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);\n    }\n\n    applyNoValueFilter(operator) {\n      this.filterChange(this.updateFilter({\n        field: this.column.field,\n        operator: operator,\n        value: null\n      }));\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged$1(\"filter\", changes, false)) {\n        this._operator = null;\n        this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);\n      }\n    }\n\n  }\n\n  FilterInputWrapperComponent.ɵfac = function FilterInputWrapperComponent_Factory(t) {\n    return new (t || FilterInputWrapperComponent)(i0.ɵɵdirectiveInject(FilterService));\n  };\n\n  FilterInputWrapperComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterInputWrapperComponent,\n    contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      defaultOperator: \"defaultOperator\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return FilterInputWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterMenuDropDownListDirective = /*#__PURE__*/(() => {\n  class FilterMenuDropDownListDirective {\n    constructor(host) {\n      this.host = host;\n\n      this.keydownHandler = e => {\n        if (e.keyCode === Keys.Escape && this.host.isOpen) {\n          e.stopPropagation();\n          this.host.toggle(false);\n        }\n      };\n    }\n\n    ngAfterViewInit() {\n      const wrapperElement = this.host.wrapper.nativeElement;\n      wrapperElement.setAttribute('aria-label', this.filterMenuDropDownLabel);\n      wrapperElement.addEventListener('keydown', this.keydownHandler, true);\n    }\n\n    ngOnDestroy() {\n      this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);\n    }\n\n  }\n\n  FilterMenuDropDownListDirective.ɵfac = function FilterMenuDropDownListDirective_Factory(t) {\n    return new (t || FilterMenuDropDownListDirective)(i0.ɵɵdirectiveInject(i1$4.DropDownListComponent));\n  };\n\n  FilterMenuDropDownListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterMenuDropDownListDirective,\n    selectors: [[\"\", \"kendoFilterMenuDropDown\", \"\"]],\n    inputs: {\n      filterMenuDropDownLabel: \"filterMenuDropDownLabel\"\n    }\n  });\n  return FilterMenuDropDownListDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterMenuInputWrapperComponent = /*#__PURE__*/(() => {\n  class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {\n    constructor(localizationService) {\n      super(null);\n      this.localizationService = localizationService;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return false;\n    }\n\n    ngAfterViewInit() {\n      if (this.isFirstDropDown && this.filterService && this.filterService.menuTabbingService) {\n        this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;\n        this.firstOperatorDropDown.focus();\n      }\n    }\n\n    operatorChange(dataItem) {\n      this.currentOperator = dataItem;\n    }\n\n    filterChange(filter) {\n      this.applyFilter(filter);\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    get currentFilter() {\n      return this._currentFilter;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    set currentFilter(value) {\n      this._currentFilter = value;\n    }\n\n    updateFilter(filter) {\n      Object.assign(this.currentFilter, filter);\n      return this.filter;\n    }\n\n    onChange(value) {\n      this.filterChange(this.updateFilter({\n        field: this.column.field,\n        operator: this.currentOperator,\n        value: value\n      }));\n    }\n\n    onShiftTab(e) {\n      e.stopImmediatePropagation();\n\n      if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {\n        e.preventDefault();\n        this.filterService.menuTabbingService.lastFocusable.focus();\n      }\n    }\n\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.localizationService.get('filterMenuOperatorsDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  FilterMenuInputWrapperComponent.ɵfac = function FilterMenuInputWrapperComponent_Factory(t) {\n    return new (t || FilterMenuInputWrapperComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  FilterMenuInputWrapperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterMenuInputWrapperComponent,\n    selectors: [[\"kendo-grid-filter-menu-input-wrapper\"]],\n    viewQuery: function FilterMenuInputWrapperComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DropDownListComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);\n      }\n    },\n    inputs: {\n      filterService: \"filterService\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\",\n      currentFilter: \"currentFilter\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c17,\n    decls: 2,\n    vars: 4,\n    consts: [[\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"value\", \"valuePrimitive\", \"valueChange\", \"keydown.shift.tab\"]],\n    template: function FilterMenuInputWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"kendo-dropdownlist\", 0);\n        i0.ɵɵlistener(\"valueChange\", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {\n          return ctx.operatorChange($event);\n        })(\"keydown.shift.tab\", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) {\n          return ctx.onShiftTab($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"filterMenuDropDownLabel\", ctx.filterMenuDropDownLabel)(\"data\", ctx.operators)(\"value\", ctx.currentOperator)(\"valuePrimitive\", true);\n      }\n    },\n    directives: [i1$4.DropDownListComponent, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  });\n  return FilterMenuInputWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet StringFilterMenuInputComponent = /*#__PURE__*/(() => {\n  class StringFilterMenuInputComponent {\n    constructor(localizationService) {\n      this.localizationService = localizationService;\n      this.operators = [];\n    }\n\n    get columnLabel() {\n      const localizationMsg = this.localizationService.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  StringFilterMenuInputComponent.ɵfac = function StringFilterMenuInputComponent_Factory(t) {\n    return new (t || StringFilterMenuInputComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StringFilterMenuInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StringFilterMenuInputComponent,\n    selectors: [[\"kendo-grid-string-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    decls: 2,\n    vars: 11,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoTextBox\", \"\", \"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"ngModel\"]],\n    template: function StringFilterMenuInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0);\n        i0.ɵɵelement(1, \"input\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", 0)(\"ngModel\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    directives: [FilterMenuInputWrapperComponent, i4$1.TextBoxDirective, i4$2.DefaultValueAccessor, FilterInputDirective, i4$2.NgControlStatus, i4$2.NgModel],\n    encapsulation: 2\n  });\n  return StringFilterMenuInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a string-filter menu component.\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).\n */\n\n\nlet StringFilterMenuComponent = /*#__PURE__*/(() => {\n  class StringFilterMenuComponent extends StringFilterComponent {\n    constructor(localization) {\n      super(null, localization);\n      this.logicOperators = logicOperators(this.localization);\n      /**\n       * The current menu filter.\n       * @type {CompositeFilterDescriptor}\n       */\n\n      this.filter = {\n        filters: [],\n        logic: \"and\"\n      };\n      /**\n       * Determines if the inputs of second criteria will displayed.\n       */\n\n      this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return false;\n    }\n\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n    localizationChange() {\n      this.logicOperators = logicOperators(this.localization);\n      super.localizationChange();\n    }\n\n  }\n\n  StringFilterMenuComponent.ɵfac = function StringFilterMenuComponent_Factory(t) {\n    return new (t || StringFilterMenuComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StringFilterMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StringFilterMenuComponent,\n    selectors: [[\"kendo-grid-string-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 9,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"menuTabbingService\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"menuTabbingService\"]],\n    template: function StringFilterMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-string-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, StringFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template, 1, 6, \"kendo-grid-string-filter-menu-input\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"isFirstDropDown\", true)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    directives: [StringFilterMenuInputComponent, i1$4.DropDownListComponent, i4.NgIf, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  });\n  return StringFilterMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n\nconst numericOperators = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterGteOperator\": \"gte\",\n  \"filterGtOperator\": \"gt\",\n  \"filterLteOperator\": \"lte\",\n  \"filterLtOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * Represents a base numeric filter component.\n */\n\nlet NumericFilterComponent = /*#__PURE__*/(() => {\n  class NumericFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n      super(filterService);\n      this.localization = localization;\n      /**\n       * The default filter operator. Defaults to `eq`.\n       * @type {string}\n       */\n\n      this.operator = \"eq\";\n      /**\n       * Specifies the value that is used to increment or decrement the component value.\n       * @type {numeric}\n       */\n\n      this.step = 1;\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n       * @type {boolean}\n       */\n\n      this.spinners = true;\n      this.defaultOperators = numericOperators(this.localization);\n    }\n    /**\n     * Specifies the number format used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n\n\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * @readonly\n     * @type {string}\n     */\n\n\n    get format() {\n      return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n\n\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n\n    get columnFormat() {\n      return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : \"n2\";\n    }\n\n    ngOnInit() {\n      this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      super.ngOnDestroy();\n    }\n\n    localizationChange() {\n      this.defaultOperators = numericOperators(this.localization);\n\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n\n  }\n\n  NumericFilterComponent.ɵfac = function NumericFilterComponent_Factory(t) {\n    return new (t || NumericFilterComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NumericFilterComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NumericFilterComponent,\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      step: \"step\",\n      min: \"min\",\n      max: \"max\",\n      spinners: \"spinners\",\n      decimals: \"decimals\",\n      format: \"format\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return NumericFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet NumericFilterMenuInputComponent = /*#__PURE__*/(() => {\n  class NumericFilterMenuInputComponent {\n    constructor(localization) {\n      this.localization = localization;\n      this.operators = [];\n      /**\n       * Specifies the value which is used to increment or decrement the component value.\n       * @type {numeric}\n       */\n\n      this.step = 1;\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n       * @type {boolean}\n       */\n\n      this.spinners = true;\n    }\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  NumericFilterMenuInputComponent.ɵfac = function NumericFilterMenuInputComponent_Factory(t) {\n    return new (t || NumericFilterMenuInputComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NumericFilterMenuInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NumericFilterMenuInputComponent,\n    selectors: [[\"kendo-grid-numeric-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      isFirstDropDown: \"isFirstDropDown\",\n      menuTabbingService: \"menuTabbingService\",\n      step: \"step\",\n      min: \"min\",\n      max: \"max\",\n      spinners: \"spinners\",\n      decimals: \"decimals\",\n      format: \"format\"\n    },\n    decls: 3,\n    vars: 20,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"autoCorrect\", \"value\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\"], [3, \"increment\", \"decrement\"]],\n    template: function NumericFilterMenuInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0)(1, \"kendo-numerictextbox\", 1);\n        i0.ɵɵelement(2, \"kendo-numerictextbox-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", 0)(\"autoCorrect\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"increment\", ctx.messageFor(\"filterNumericIncrement\"))(\"decrement\", ctx.messageFor(\"filterNumericDecrement\"));\n      }\n    },\n    directives: [FilterMenuInputWrapperComponent, i4$1.NumericTextBoxComponent, i4$1.NumericTextBoxCustomMessagesComponent, FilterInputDirective],\n    encapsulation: 2\n  });\n  return NumericFilterMenuInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a numeric-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *          <kendo-grid-numeric-filter-menu\n *              [column]=\"column\"\n *              [filter]=\"filter\"\n *              [filterService]=\"filterService\"\n *              >\n *          </kendo-grid-numeric-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet NumericFilterMenuComponent = /*#__PURE__*/(() => {\n  class NumericFilterMenuComponent extends NumericFilterComponent {\n    constructor(localization) {\n      super(null, localization);\n      this.logicOperators = logicOperators(this.localization);\n      /**\n       * The current menu filter.\n       * @type {CompositeFilterDescriptor}\n       */\n\n      this.filter = {\n        filters: [],\n        logic: \"and\"\n      };\n      /**\n       * Determines if the inputs of second criteria will displayed.\n       */\n\n      this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return false;\n    }\n\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n    localizationChange() {\n      this.logicOperators = logicOperators(this.localization);\n      super.localizationChange();\n    }\n\n  }\n\n  NumericFilterMenuComponent.ɵfac = function NumericFilterMenuComponent_Factory(t) {\n    return new (t || NumericFilterMenuComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NumericFilterMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NumericFilterMenuComponent,\n    selectors: [[\"kendo-grid-numeric-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 15,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\", \"isFirstDropDown\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\", \"menuTabbingService\"]],\n    template: function NumericFilterMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-numeric-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, NumericFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template, 1, 12, \"kendo-grid-numeric-filter-menu-input\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step)(\"menuTabbingService\", ctx.menuTabbingService)(\"isFirstDropDown\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    directives: [NumericFilterMenuInputComponent, i1$4.DropDownListComponent, i4.NgIf, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  });\n  return NumericFilterMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n\nconst dateOperators = localizeOperators({\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterAfterOrEqualOperator\": \"gte\",\n  \"filterAfterOperator\": \"gt\",\n  \"filterBeforeOrEqualOperator\": \"lte\",\n  \"filterBeforeOperator\": \"lt\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\"\n});\n/**\n * @hidden\n */\n\nlet DateFilterComponent = /*#__PURE__*/(() => {\n  class DateFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n      super(filterService);\n      this.localization = localization;\n      /**\n       * The default filter operator. Defaults to `contains`.\n       * @type {string}\n       */\n\n      this.operator = \"gte\";\n      /**\n       * Defines the active view that the calendar initially renders.\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = \"month\";\n      /**\n       * Defines the bottommost calendar view, to which the user can navigate.\n       */\n\n      this.bottomView = \"month\";\n      /**\n       * Defines the topmost calendar view, to which the user can navigate.\n       */\n\n      this.topView = \"century\";\n      /**\n       * Determines whether to display a week number column in the `month` view of the Calendar.\n       */\n\n      this.weekNumber = false;\n      this.defaultOperators = dateOperators(this.localization);\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     */\n\n\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * Specifies the date format that is used when the component is not focused.\n     * By default, the `column.format` value is used (if set).\n     *\n     * @readonly\n     * @type {string}\n     */\n\n\n    get format() {\n      return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;\n    }\n\n    get columnFormat() {\n      return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : \"d\";\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n\n\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n\n    ngOnInit() {\n      this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      super.ngOnDestroy();\n    }\n\n    localizationChange() {\n      this.defaultOperators = dateOperators(this.localization);\n\n      if (this.operatorList.length) {\n        this.operators = toJSON(this.operatorList.toArray());\n      }\n    }\n\n  }\n\n  DateFilterComponent.ɵfac = function DateFilterComponent_Factory(t) {\n    return new (t || DateFilterComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DateFilterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateFilterComponent,\n    selectors: [[\"kendo-grid-date-filter-base\"]],\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      format: \"format\",\n      min: \"min\",\n      max: \"max\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      weekNumber: \"weekNumber\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DateFilterComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DateFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DateFilterMenuInputComponent = /*#__PURE__*/(() => {\n  class DateFilterMenuInputComponent {\n    constructor(popupService, localizationService) {\n      this.popupService = popupService;\n      this.localizationService = localizationService;\n      this.operators = [];\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n\n    open(picker) {\n      this.subscription = this.popupService.onClose.pipe(filter(() => picker.isActive)).subscribe(e => e.preventDefault());\n    }\n\n    messageFor(key) {\n      return this.localizationService.get(key);\n    }\n\n    get columnLabel() {\n      const localizationMsg = this.localizationService.get('filterInputLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  DateFilterMenuInputComponent.ɵfac = function DateFilterMenuInputComponent_Factory(t) {\n    return new (t || DateFilterMenuInputComponent)(i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DateFilterMenuInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateFilterMenuInputComponent,\n    selectors: [[\"kendo-grid-date-filter-menu-input\"]],\n    inputs: {\n      operators: \"operators\",\n      column: \"column\",\n      filter: \"filter\",\n      operator: \"operator\",\n      currentFilter: \"currentFilter\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\",\n      format: \"format\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      min: \"min\",\n      max: \"max\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      weekNumber: \"weekNumber\",\n      isFirstDropDown: \"isFirstDropDown\"\n    },\n    decls: 4,\n    vars: 22,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"currentFilter\", \"filterService\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"value\", \"placeholder\", \"formatPlaceholder\", \"format\", \"min\", \"max\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"open\"], [\"picker\", \"\"], [3, \"toggle\", \"today\"]],\n    template: function DateFilterMenuInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r1 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-menu-input-wrapper\", 0)(1, \"kendo-datepicker\", 1, 2);\n        i0.ɵɵlistener(\"open\", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() {\n          i0.ɵɵrestoreView(_r1);\n\n          const _r0 = i0.ɵɵreference(2);\n\n          return ctx.open(_r0);\n        });\n        i0.ɵɵelement(3, \"kendo-datepicker-messages\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"currentFilter\", ctx.currentFilter)(\"filterService\", ctx.filterService)(\"isFirstDropDown\", ctx.isFirstDropDown)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", 0)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"placeholder\", ctx.placeholder)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"format\", ctx.format)(\"min\", ctx.min)(\"max\", ctx.max)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"weekNumber\", ctx.weekNumber);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"toggle\", ctx.messageFor(\"filterDateToggle\"))(\"today\", ctx.messageFor(\"filterDateToday\"));\n      }\n    },\n    directives: [FilterMenuInputWrapperComponent, i4$3.DatePickerComponent, i4$3.DatePickerCustomMessagesComponent, FilterInputDirective],\n    encapsulation: 2\n  });\n  return DateFilterMenuInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a date-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"OrderDate\" title=\"Order Date\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *            <kendo-grid-date-filter-menu\n *                [column]=\"column\"\n *                [filter]=\"filter\"\n *                [filterService]=\"filterService\"\n *                >\n *            </kendo-grid-date-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet DateFilterMenuComponent = /*#__PURE__*/(() => {\n  class DateFilterMenuComponent extends DateFilterComponent {\n    constructor(localization) {\n      super(null, localization);\n      this.logicOperators = logicOperators(this.localization);\n      /**\n       * The current menu filter.\n       * @type {CompositeFilterDescriptor}\n       */\n\n      this.filter = {\n        filters: [],\n        logic: \"and\"\n      };\n      /**\n       * Determines if the inputs of second criteria will be displayed.\n       */\n\n      this.extra = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return false;\n    }\n\n    get firstFilter() {\n      return setFilter(0, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    get secondFilter() {\n      return setFilter(1, this.filter, (this.column || {}).field, this.operator);\n    }\n\n    logicChange(value) {\n      this.filter.logic = value;\n    }\n\n    get filterMenuDropDownLabel() {\n      const localizationMsg = this.localization.get('filterMenuLogicDropDownLabel') || '';\n      const columnName = this.column ? this.column.title || this.column.field : '';\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n    localizationChange() {\n      this.logicOperators = logicOperators(this.localization);\n      super.localizationChange();\n    }\n\n  }\n\n  DateFilterMenuComponent.ɵfac = function DateFilterMenuComponent_Factory(t) {\n    return new (t || DateFilterMenuComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DateFilterMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateFilterMenuComponent,\n    selectors: [[\"kendo-grid-date-filter-menu\"]],\n    hostVars: 2,\n    hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      extra: \"extra\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 18,\n    consts: [[3, \"currentFilter\", \"operators\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"isFirstDropDown\", \"menuTabbingService\"], [\"kendoFilterMenuDropDown\", \"\", \"class\", \"k-filter-and\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"menuTabbingService\", 4, \"ngIf\"], [\"kendoFilterMenuDropDown\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-filter-and\", 3, \"filterMenuDropDownLabel\", \"data\", \"valuePrimitive\", \"value\", \"valueChange\"], [3, \"operators\", \"currentFilter\", \"filterService\", \"column\", \"filter\", \"activeView\", \"bottomView\", \"topView\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"weekNumber\", \"menuTabbingService\"]],\n    template: function DateFilterMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"kendo-grid-date-filter-menu-input\", 0);\n        i0.ɵɵtemplate(1, DateFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, \"kendo-dropdownlist\", 1);\n        i0.ɵɵtemplate(2, DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template, 1, 15, \"kendo-grid-date-filter-menu-input\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentFilter\", ctx.firstFilter)(\"operators\", ctx.operators)(\"filterService\", ctx.filterService)(\"column\", ctx.column)(\"filter\", ctx.filter)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"format\", ctx.format)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.min)(\"max\", ctx.max)(\"weekNumber\", ctx.weekNumber)(\"isFirstDropDown\", true)(\"menuTabbingService\", ctx.menuTabbingService);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.extra);\n      }\n    },\n    directives: [DateFilterMenuInputComponent, i1$4.DropDownListComponent, i4.NgIf, FilterMenuDropDownListDirective],\n    encapsulation: 2\n  });\n  return DateFilterMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n/**\n * @hidden\n */\n\n\nlet BooleanFilterComponent = /*#__PURE__*/(() => {\n  class BooleanFilterComponent extends BaseFilterCellComponent {\n    constructor(filterService, localization) {\n      super(filterService);\n      this.localization = localization;\n      /**\n       * @hidden\n       */\n\n      this.operator = \"eq\";\n      /**\n       * @hidden\n       */\n\n      this.items = [{\n        text: this.localization.get(\"filterIsTrue\"),\n        value: true\n      }, {\n        text: this.localization.get(\"filterIsFalse\"),\n        value: false\n      }];\n      /**\n       * @hidden\n       */\n\n      this.defaultItem = {\n        text: this.localization.get(\"filterBooleanAll\"),\n        value: null\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return true;\n    }\n    /**\n     * The current filter for the associated column field.\n     * @readonly\n     * @type {FilterDescriptor}\n     */\n\n\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n    /**\n     * The current filter operator for the associated column field.\n     * @readonly\n     * @type {string}\n     */\n\n\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : this.operator;\n    }\n\n    ngOnInit() {\n      this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      super.ngOnDestroy();\n    }\n\n    localizationChange() {\n      this.items = [{\n        text: this.localization.get(\"filterIsTrue\"),\n        value: true\n      }, {\n        text: this.localization.get(\"filterIsFalse\"),\n        value: false\n      }];\n      this.defaultItem = {\n        text: this.localization.get(\"filterBooleanAll\"),\n        value: null\n      };\n    }\n\n  }\n\n  BooleanFilterComponent.ɵfac = function BooleanFilterComponent_Factory(t) {\n    return new (t || BooleanFilterComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  BooleanFilterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BooleanFilterComponent,\n    selectors: [[\"kendo-grid-boolean-filter-base\"]],\n    hostVars: 2,\n    hostBindings: function BooleanFilterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell-boolean\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function BooleanFilterComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return BooleanFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet BooleanFilterRadioButtonDirective = /*#__PURE__*/(() => {\n  class BooleanFilterRadioButtonDirective {\n    constructor(hostElement, renderer) {\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n    }\n\n    ngAfterViewInit() {\n      this.radioButtonEl = this.hostElement.nativeElement;\n      this.renderer.setAttribute(this.hostElement.nativeElement, 'aria-label', this.columnLabel);\n    }\n\n  }\n\n  BooleanFilterRadioButtonDirective.ɵfac = function BooleanFilterRadioButtonDirective_Factory(t) {\n    return new (t || BooleanFilterRadioButtonDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  BooleanFilterRadioButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BooleanFilterRadioButtonDirective,\n    selectors: [[\"\", \"kendoFilterMenuRadioButton\", \"\"]],\n    inputs: {\n      columnLabel: \"columnLabel\"\n    }\n  });\n  return BooleanFilterRadioButtonDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a Boolean-filter menu component.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"Discontinued\" title=\"Discontinued\">\n *          <ng-template kendoGridFilterMenuTemplate let-filter let-column=\"column\" let-filterService=\"filterService\">\n *            <kendo-grid-boolean-filter-menu\n *                [column]=\"column\"\n *                [filter]=\"filter\"\n *                [filterService]=\"filterService\"\n *                >\n *            </kendo-grid-boolean-filter-menu>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet BooleanFilterMenuComponent = /*#__PURE__*/(() => {\n  class BooleanFilterMenuComponent extends BooleanFilterComponent {\n    constructor(localization) {\n      super(null, localization);\n      /**\n       * The current menu filter.\n       * @type {CompositeFilterDescriptor}\n       */\n\n      this.filter = {\n        filters: [],\n        logic: \"and\"\n      };\n      this.idPrefix = guid();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return false;\n    }\n\n    ngAfterViewInit() {\n      this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;\n      this.radioButtons.first.radioButtonEl.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    radioId(value) {\n      return `${this.idPrefix}_${value}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onChange(value, input) {\n      this.applyFilter(this.updateFilter({\n        field: this.column.field,\n        operator: \"eq\",\n        value: value\n      }));\n      this.filterService.menuTabbingService.firstFocusable = input;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isSelected(radioValue) {\n      return this.filtersByField(this.column.field).some(({\n        value\n      }) => value === radioValue);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onShiftTab(e) {\n      if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.filterService.menuTabbingService.lastFocusable) {\n        e.preventDefault();\n        this.filterService.menuTabbingService.lastFocusable.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  BooleanFilterMenuComponent.ɵfac = function BooleanFilterMenuComponent_Factory(t) {\n    return new (t || BooleanFilterMenuComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  BooleanFilterMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BooleanFilterMenuComponent,\n    selectors: [[\"kendo-grid-boolean-filter-menu\"]],\n    viewQuery: function BooleanFilterMenuComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.radioButtons = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      filter: \"filter\",\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"k-radio-list\", \"k-reset\"], [4, \"ngFor\", \"ngForOf\"], [\"type\", \"radio\", \"kendoFilterMenuRadioButton\", \"\", \"kendoRadioButton\", \"\", 3, \"columnLabel\", \"name\", \"checked\", \"change\", \"keydown.shift.tab\"], [\"input\", \"\"], [1, \"k-radio-label\"]],\n    template: function BooleanFilterMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, BooleanFilterMenuComponent_li_1_Template, 5, 6, \"li\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    directives: [i4.NgForOf, i4$1.RadioButtonDirective, BooleanFilterRadioButtonDirective],\n    encapsulation: 2\n  });\n  return BooleanFilterMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * > List the following components as `entryComponents` in the GridModule.\n */\n\n\nconst filterMenuComponentFactory = type => ({\n  \"boolean\": BooleanFilterMenuComponent,\n  \"date\": DateFilterMenuComponent,\n  \"numeric\": NumericFilterMenuComponent,\n  \"text\": StringFilterMenuComponent\n})[type];\n/**\n * @hidden\n */\n\n\nlet FilterMenuHostDirective = /*#__PURE__*/(() => {\n  class FilterMenuHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n      super(host, resolver);\n    }\n\n    componentType() {\n      if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {\n        return filterMenuComponentFactory(this.column.filter);\n      }\n\n      return StringFilterMenuComponent;\n    }\n\n    initComponent(ctx) {\n      super.initComponent(ctx);\n      this.component.instance.filterService = this.filterService;\n      this.component.instance.menuTabbingService = this.menuTabbingService;\n    }\n\n  }\n\n  FilterMenuHostDirective.ɵfac = function FilterMenuHostDirective_Factory(t) {\n    return new (t || FilterMenuHostDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  };\n\n  FilterMenuHostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterMenuHostDirective,\n    selectors: [[\"\", \"kendoFilterMenuHost\", \"\"]],\n    inputs: {\n      filterService: \"filterService\",\n      menuTabbingService: \"menuTabbingService\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return FilterMenuHostDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isNoValueOperator = operator => operator === \"isnull\" || operator === \"isnotnull\" || operator === \"isempty\" || operator === \"isnotempty\";\n\nconst validFilters = ({\n  value,\n  operator\n}) => !isNullOrEmptyString(value) || isNoValueOperator(operator);\n\nconst trimFilters = filter => {\n  filter.filters = filter.filters.filter(validFilters);\n  return filter;\n};\n\nconst findParent = (filters, field, parent) => {\n  return filters.reduce((acc, filter) => {\n    if (acc) {\n      return acc;\n    }\n\n    if (filter.filters) {\n      return findParent(filter.filters, field, filter);\n    } else if (filter.field === field) {\n      return parent;\n    }\n\n    return acc;\n  }, undefined);\n};\n\nconst parentLogicOfDefault = (filter, field, def = \"and\") => {\n  const parent = findParent((filter || {}).filters || [], field);\n  return isPresent(parent) ? parent.logic : def;\n};\n/**\n * @hidden\n */\n\n\nlet FilterMenuContainerComponent = /*#__PURE__*/(() => {\n  class FilterMenuContainerComponent {\n    constructor(parentService, childService, localization, cd, menuTabbingService) {\n      this.parentService = parentService;\n      this.childService = childService;\n      this.localization = localization;\n      this.cd = cd;\n      this.close = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.actionsClass = 'k-action-buttons k-button-group';\n      this._templateContext = {};\n      this.menuTabbingService = menuTabbingService;\n    }\n\n    get filter() {\n      return this._filter;\n    }\n    /**\n     * The current root filter.\n     * @type {CompositeFilterDescriptor}\n     */\n\n\n    set filter(value) {\n      this._filter = cloneFilters(value);\n    }\n\n    get childFilter() {\n      if (!isPresent(this._childFilter)) {\n        this._childFilter = {\n          filters: filtersByField(this.filter, (this.column || {}).field),\n          logic: parentLogicOfDefault(this.filter, (this.column || {}).field)\n        };\n      }\n\n      return this._childFilter;\n    }\n\n    ngOnInit() {\n      this.subscription = this.childService.changes.subscribe(filter => this._childFilter = filter);\n      this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n\n    ngAfterViewChecked() {\n      if (!this.menuTabbingService.isColumnMenu || this.isLast && this.isExpanded) {\n        this.menuTabbingService.lastFocusable = this.disabled ? this.resetButton.nativeElement : this.filterButton.nativeElement;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      this.menuTabbingService.lastFocusable = undefined;\n    }\n\n    get disabled() {\n      return !this.childFilter.filters.some(validFilters);\n    }\n\n    get templateContext() {\n      this._templateContext.column = this.column;\n      this._templateContext.filter = this.childFilter;\n      this._templateContext.filterService = this.childService;\n      this._templateContext[\"$implicit\"] = this.childFilter;\n      return this._templateContext;\n    }\n\n    get hasTemplate() {\n      return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);\n    }\n\n    submit() {\n      const filter = trimFilters(this.childFilter);\n\n      if (filter.filters.length) {\n        const root = this.filter || {\n          filters: [],\n          logic: \"and\"\n        };\n        removeFilter(root, this.column.field);\n        root.filters.push(filter);\n        this.parentService.filter(root);\n      }\n\n      this.close.emit();\n      return false;\n    }\n\n    reset() {\n      const root = this.filter || {\n        filters: [],\n        logic: \"and\"\n      };\n      removeFilter(root, this.column.field);\n      this.parentService.filter(root);\n      this.close.emit();\n    }\n\n    onTab(e, buttonType) {\n      if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {\n        e.preventDefault();\n\n        if (buttonType === 'reset') {\n          // eslint-disable-next-line no-unused-expressions\n          this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.filterButton.nativeElement.focus();\n        } else {\n          this.menuTabbingService.firstFocusable.focus();\n        }\n      }\n    }\n\n    get clearText() {\n      return this.localization.get(\"filterClearButton\");\n    }\n\n    get filterText() {\n      return this.localization.get(\"filterFilterButton\");\n    }\n\n  }\n\n  FilterMenuContainerComponent.ɵfac = function FilterMenuContainerComponent_Factory(t) {\n    return new (t || FilterMenuContainerComponent)(i0.ɵɵdirectiveInject(FilterService, 4), i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MenuTabbingService));\n  };\n\n  FilterMenuContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterMenuContainerComponent,\n    selectors: [[\"kendo-grid-filter-menu-container\"]],\n    viewQuery: function FilterMenuContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c18, 5);\n        i0.ɵɵviewQuery(_c19, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resetButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterButton = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      isLast: \"isLast\",\n      isExpanded: \"isExpanded\",\n      menuTabbingService: \"menuTabbingService\",\n      filter: \"filter\",\n      actionsClass: \"actionsClass\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    features: [i0.ɵɵProvidersFeature([FilterService, MenuTabbingService])],\n    decls: 12,\n    vars: 7,\n    consts: [[1, \"k-filter-menu\", \"k-group\", \"k-reset\", \"k-state-border-up\", 3, \"submit\", \"reset\"], [1, \"k-filter-menu-container\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [3, \"ngClass\"], [\"type\", \"reset\", 1, \"k-button\", \"k-button-solid-base\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"keydown.tab\"], [\"resetButton\", \"\"], [\"type\", \"submit\", 1, \"k-button\", \"k-button-solid-primary\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"disabled\", \"keydown.tab\"], [\"filterButton\", \"\"], [\"kendoFilterMenuHost\", \"\", 3, \"filterService\", \"column\", \"filter\", \"menuTabbingService\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function FilterMenuContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"form\", 0);\n        i0.ɵɵlistener(\"submit\", function FilterMenuContainerComponent_Template_form_submit_0_listener() {\n          return ctx.submit();\n        })(\"reset\", function FilterMenuContainerComponent_Template_form_reset_0_listener() {\n          return ctx.reset();\n        });\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵtemplate(3, FilterMenuContainerComponent_ng_container_3_Template, 2, 4, \"ng-container\", 3);\n        i0.ɵɵtemplate(4, FilterMenuContainerComponent_ng_container_4_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(5, \"div\", 4)(6, \"button\", 5, 6);\n        i0.ɵɵlistener(\"keydown.tab\", function FilterMenuContainerComponent_Template_button_keydown_tab_6_listener($event) {\n          return ctx.onTab($event, \"reset\");\n        });\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"button\", 7, 8);\n        i0.ɵɵlistener(\"keydown.tab\", function FilterMenuContainerComponent_Template_button_keydown_tab_9_listener($event) {\n          return ctx.onTab($event, \"filter\");\n        });\n        i0.ɵɵtext(11);\n        i0.ɵɵelementEnd()()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitch\", ctx.hasTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.actionsClass);\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate(ctx.clearText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"disabled\", ctx.disabled);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.filterText);\n      }\n    },\n    directives: [i4$2.ɵNgNoValidate, i4$2.NgControlStatusGroup, i4$2.NgForm, i4.NgSwitch, i4.NgSwitchCase, FilterMenuHostDirective, i4.NgIf, i4.NgTemplateOutlet, i4.NgClass],\n    encapsulation: 2\n  });\n  return FilterMenuContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterMenuComponent = /*#__PURE__*/(() => {\n  class FilterMenuComponent {\n    constructor(filterService, popupService, localization, navigationService) {\n      this.filterService = filterService;\n      this.popupService = popupService;\n      this.localization = localization;\n      this.navigationService = navigationService;\n      this.tabIndex = '-1';\n    }\n\n    get hasFilters() {\n      return filtersByField(this.filter, (this.column || {}).field).length > 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get filterLabel() {\n      const localizationMsg = this.localization.get('filterMenuTitle') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n    toggle(anchor, template) {\n      this.popupRef = this.popupService.open(anchor, template, this.popupRef);\n\n      if (!this.popupRef) {\n        if (this.navigationService.tableEnabled) {\n          this.navigationService.focusCell(0, this.column.leafIndex);\n        } else {\n          this.anchor.nativeElement.focus();\n        }\n      }\n\n      return false;\n    }\n\n    close() {\n      this.popupService.destroy();\n\n      if (this.navigationService.tableEnabled) {\n        this.navigationService.focusCell(0, this.column.leafIndex);\n      } else {\n        this.anchor.nativeElement.focus();\n      }\n    }\n\n  }\n\n  FilterMenuComponent.ɵfac = function FilterMenuComponent_Factory(t) {\n    return new (t || FilterMenuComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  FilterMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterMenuComponent,\n    selectors: [[\"kendo-grid-filter-menu\"]],\n    viewQuery: function FilterMenuComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c20, 7);\n        i0.ɵɵviewQuery(_c21, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.anchor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      filter: \"filter\",\n      tabIndex: \"tabIndex\"\n    },\n    decls: 5,\n    vars: 5,\n    consts: [[\"href\", \"#\", 3, \"ngClass\", \"tabindex\", \"click\", \"keydown.enter\"], [\"anchor\", \"\"], [1, \"k-icon\", \"k-i-filter\"], [\"template\", \"\"], [3, \"column\", \"filter\", \"close\", \"keydown.escape\", \"keydown.enter\"]],\n    template: function FilterMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r7 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"click\", function FilterMenuComponent_Template_a_click_0_listener() {\n          i0.ɵɵrestoreView(_r7);\n\n          const _r0 = i0.ɵɵreference(1);\n\n          const _r1 = i0.ɵɵreference(4);\n\n          return ctx.toggle(_r0, _r1);\n        })(\"keydown.enter\", function FilterMenuComponent_Template_a_keydown_enter_0_listener($event) {\n          return $event.stopImmediatePropagation();\n        });\n        i0.ɵɵelement(2, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c22, ctx.hasFilters))(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵattribute(\"title\", ctx.filterLabel);\n      }\n    },\n    directives: [FilterMenuContainerComponent, i4.NgClass],\n    encapsulation: 2\n  });\n  return FilterMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the service that is passed to the\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <span class=\"k-icon k-i-close\" (click)=\"service.close()\"\n *                  style=\"position: absolute; right: 5px; top: 5px;cursor: pointer;\"></span>\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuService = /*#__PURE__*/(() => {\n  class ColumnMenuService {\n    /**\n     * @hidden\n     */\n    constructor(menuTabbingService) {\n      /**\n       * @hidden\n       */\n      this.closeMenu = new EventEmitter();\n      this.menuTabbingService = menuTabbingService;\n    }\n    /**\n     * Closes the column menu.\n     */\n\n\n    close() {\n      this.closeMenu.emit();\n    }\n\n  }\n\n  ColumnMenuService.ɵfac = function ColumnMenuService_Factory(t) {\n    return new (t || ColumnMenuService)(i0.ɵɵinject(MenuTabbingService));\n  };\n\n  ColumnMenuService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColumnMenuService,\n    factory: ColumnMenuService.ɵfac\n  });\n  return ColumnMenuService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColumnMenuItemBase = /*#__PURE__*/(() => {\n  class ColumnMenuItemBase {\n    constructor() {\n      this.hostClass = true;\n    }\n\n    ngOnInit() {\n      if (isDevMode() && !this.service) {\n        throw new Error('The service input of the predefined column menu components is mandatory.');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    close() {\n      this.service.close();\n    }\n\n  }\n\n  ColumnMenuItemBase.ɵfac = function ColumnMenuItemBase_Factory(t) {\n    return new (t || ColumnMenuItemBase)();\n  };\n\n  ColumnMenuItemBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuItemBase,\n    selectors: [[\"kendo-grid-column-menu-item-base\"]],\n    hostVars: 2,\n    hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-columnmenu-item-wrapper\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      service: \"service\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ColumnMenuItemBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ColumnMenuItemBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the content template of the\n * [kendo-grid-columnmenu-item]({% slug api_grid_columnmenuitemcomponent %}) component.\n * Provides an option for specifying the content of a column item.\n * To define the content template, nest an `<ng-template>` tag with the\n * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate>\n *              <kendo-grid-columnmenu-item text=\"Item Text\" [expanded]=\"true\">\n *                  <ng-template kendoGridColumnMenuItemContentTemplate>\n *                      Item Content\n *                  </ng-template>\n *              </kendo-grid-columnmenu-item>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuItemContentTemplateDirective = /*#__PURE__*/(() => {\n  class ColumnMenuItemContentTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ColumnMenuItemContentTemplateDirective.ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(t) {\n    return new (t || ColumnMenuItemContentTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ColumnMenuItemContentTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnMenuItemContentTemplateDirective,\n    selectors: [[\"\", \"kendoGridColumnMenuItemContentTemplate\", \"\"]]\n  });\n  return ColumnMenuItemContentTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents an item that can be placed inside a\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\" [resizable]=\"true\" #grid>\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\" let-column=\"column\">\n *              <kendo-grid-columnmenu-item icon=\"arrows-resizing\" text=\"Fit column\"\n *                  (itemClick)=\"grid.autoFitColumn(column); service.close()\">\n *              </kendo-grid-columnmenu-item>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuItemComponent = /*#__PURE__*/(() => {\n  class ColumnMenuItemComponent {\n    constructor() {\n      /**\n       * Fires when the item is clicked.\n       */\n      this.itemClick = new EventEmitter();\n      /**\n       * Fires when the content is expanded.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the content is collapsed.\n       */\n\n      this.collapse = new EventEmitter();\n      this.contentState = 'collapsed';\n    }\n\n    get iconClass() {\n      return `k-i-${this.icon}`;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.expanded) {\n        this.updateContentState();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      this.itemClick.emit(e);\n\n      if (this.contentTemplate) {\n        this.expanded = !this.expanded;\n        this.updateContentState();\n\n        if (this.expanded) {\n          this.expand.emit();\n        } else {\n          this.collapse.emit();\n        }\n      }\n    }\n\n    updateContentState() {\n      this.contentState = this.expanded ? 'expanded' : 'collapsed';\n    }\n\n  }\n\n  ColumnMenuItemComponent.ɵfac = function ColumnMenuItemComponent_Factory(t) {\n    return new (t || ColumnMenuItemComponent)();\n  };\n\n  ColumnMenuItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuItemComponent,\n    selectors: [[\"kendo-grid-columnmenu-item\"]],\n    contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      text: \"text\",\n      selected: \"selected\",\n      disabled: \"disabled\",\n      expanded: \"expanded\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 8,\n    consts: [[\"role\", \"button\", 1, \"k-columnmenu-item\", 3, \"click\", \"keydown.enter\"], [\"class\", \"k-icon\", 3, \"ngClass\", 4, \"ngIf\"], [\"style\", \"overflow:hidden;\", \"class\", \"k-columnmenu-item-content\", 4, \"ngIf\"], [1, \"k-icon\", 3, \"ngClass\"], [1, \"k-columnmenu-item-content\", 2, \"overflow\", \"hidden\"], [3, \"ngTemplateOutlet\"]],\n    template: function ColumnMenuItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"click\", function ColumnMenuItemComponent_Template_div_click_0_listener($event) {\n          return ctx.onClick($event);\n        })(\"keydown.enter\", function ColumnMenuItemComponent_Template_div_keydown_enter_0_listener($event) {\n          return ctx.onClick($event);\n        });\n        i0.ɵɵtemplate(1, ColumnMenuItemComponent_span_1_Template, 1, 1, \"span\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, ColumnMenuItemComponent_div_3_Template, 3, 2, \"div\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-state-selected\", ctx.selected)(\"k-state-disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-expanded\", ctx.expanded);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.text, \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.contentTemplate);\n      }\n    },\n    directives: [i4.NgIf, i4.NgClass, i4.NgTemplateOutlet],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('state', [state('collapsed', style({\n        display: 'none'\n      })), state('expanded', style({\n        display: 'block'\n      })), transition('collapsed => expanded', [style({\n        height: '0px',\n        display: 'block'\n      }), animate('100ms ease-in', style({\n        height: '*'\n      }))]), transition('expanded => collapsed', [style({\n        height: '*'\n      }), animate('100ms ease-in', style({\n        height: '0px'\n      }))])])]\n    }\n  });\n  return ColumnMenuItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a column-menu item that can be placed inside a\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * Allows the user to lock or unlock the columns.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-lock` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-lock [service]=\"service\">\n *              </kendo-grid-columnmenu-lock>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuLockComponent = /*#__PURE__*/(() => {\n  class ColumnMenuLockComponent extends ColumnMenuItemBase {\n    constructor(localization, columnInfoService, changeDetector) {\n      super();\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n    }\n\n    get text() {\n      return this.localization.get(this.locked ? 'unlock' : 'lock');\n    }\n\n    get icon() {\n      return this.locked ? 'unlock' : 'lock';\n    }\n\n    get disabled() {\n      return !this.locked && this.columnInfoService.unlockedRootCount < 2;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleColumn() {\n      this.toggleHierarchy(!this.locked);\n      this.close();\n      this.changeDetector.markForCheck();\n    }\n\n    toggleHierarchy(locked) {\n      let root = this.service.column;\n\n      while (root.parent) {\n        root = root.parent;\n      }\n\n      const columns = [root];\n      const allChanged = [];\n\n      while (columns.length) {\n        const column = columns.shift();\n        column.locked = locked;\n        allChanged.push(column);\n\n        if (column.hasChildren) {\n          columns.push(...column.childrenArray);\n        }\n      }\n\n      this.columnInfoService.changeLocked(allChanged);\n    }\n\n    get locked() {\n      return this.service.column.locked;\n    }\n\n  }\n\n  ColumnMenuLockComponent.ɵfac = function ColumnMenuLockComponent_Factory(t) {\n    return new (t || ColumnMenuLockComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  ColumnMenuLockComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuLockComponent,\n    selectors: [[\"kendo-grid-columnmenu-lock\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 3,\n    consts: [[3, \"text\", \"icon\", \"disabled\", \"itemClick\"]],\n    template: function ColumnMenuLockComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function ColumnMenuLockComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleColumn();\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.text)(\"icon\", ctx.icon)(\"disabled\", ctx.disabled);\n      }\n    },\n    directives: [ColumnMenuItemComponent],\n    encapsulation: 2\n  });\n  return ColumnMenuLockComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a column-menu item that can be placed inside a\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * Allows the user to stick or unstick the columns.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-stick` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-stick [service]=\"service\">\n *              </kendo-grid-columnmenu-stick>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuStickComponent = /*#__PURE__*/(() => {\n  class ColumnMenuStickComponent extends ColumnMenuItemBase {\n    constructor(localization, columnInfoService, changeDetector) {\n      super();\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n    }\n\n    get text() {\n      return this.localization.get(this.sticky ? 'unstick' : 'stick');\n    }\n\n    get icon() {\n      return this.sticky ? 'unstick' : 'stick';\n    }\n\n    get disabled() {\n      return !this.sticky && this.columnInfoService.unlockedRootCount < 2;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleColumn() {\n      this.toggleHierarchy(!this.sticky);\n      this.close();\n      this.changeDetector.markForCheck();\n    }\n\n    toggleHierarchy(sticky) {\n      let root = this.service.column;\n\n      while (root.parent) {\n        root = root.parent;\n      }\n\n      const columns = [root];\n      const allChanged = [];\n\n      while (columns.length) {\n        const column = columns.shift();\n        column.sticky = sticky;\n        allChanged.push(column);\n\n        if (column.hasChildren) {\n          columns.push(...column.childrenArray);\n        }\n      }\n\n      this.columnInfoService.changeStuck(allChanged);\n    }\n\n    get sticky() {\n      return this.service.column.sticky;\n    }\n\n  }\n\n  ColumnMenuStickComponent.ɵfac = function ColumnMenuStickComponent_Factory(t) {\n    return new (t || ColumnMenuStickComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  ColumnMenuStickComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuStickComponent,\n    selectors: [[\"kendo-grid-columnmenu-stick\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 3,\n    consts: [[3, \"text\", \"icon\", \"disabled\", \"itemClick\"]],\n    template: function ColumnMenuStickComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function ColumnMenuStickComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleColumn();\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.text)(\"icon\", ctx.icon)(\"disabled\", ctx.disabled);\n      }\n    },\n    directives: [ColumnMenuItemComponent],\n    encapsulation: 2\n  });\n  return ColumnMenuStickComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the component for editing column filters in the Grid that can be placed\n * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-filter` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-filter [service]=\"service\">\n *              </kendo-grid-columnmenu-filter>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuPositionComponent = /*#__PURE__*/(() => {\n  class ColumnMenuPositionComponent extends ColumnMenuItemBase {\n    constructor(localization, hostElement) {\n      super();\n      this.localization = localization;\n      this.hostElement = hostElement;\n      /**\n       * Fires when the content is expanded.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the content is collapsed.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Specifies if the content is expanded.\n       */\n\n      this.expanded = false;\n      /**\n       * @hidden\n       */\n\n      this.actionsClass = 'k-columnmenu-actions';\n      this._isLast = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isLast(value) {\n      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      this._isLast = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isLast() {\n      return this._isLast;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onTab(e, isLastItem) {\n      if (this.isLast && isLastItem) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        if (this.service) {\n          this.service.menuTabbingService.firstFocusable.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onCollapse() {\n      this.expanded = false;\n\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      }\n\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onExpand() {\n      this.expanded = true;\n\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();\n      }\n\n      this.expand.emit();\n    }\n\n    getLastFocusableItem() {\n      const menuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');\n      const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;\n      return menuItems[lastFocusableIndex];\n    }\n\n  }\n\n  ColumnMenuPositionComponent.ɵfac = function ColumnMenuPositionComponent_Factory(t) {\n    return new (t || ColumnMenuPositionComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ColumnMenuPositionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuPositionComponent,\n    selectors: [[\"kendo-grid-columnmenu-position\"]],\n    inputs: {\n      expanded: \"expanded\",\n      showLock: \"showLock\",\n      showStick: \"showStick\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"icon\", \"set-column-position\", 3, \"text\", \"expanded\", \"keydown.tab\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"service\", \"keydown.tab\", 4, \"ngIf\"], [3, \"service\", \"keydown.tab\"]],\n    template: function ColumnMenuPositionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"keydown.tab\", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) {\n          return ctx.onTab($event, !ctx.expanded);\n        })(\"collapse\", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_Template, 2, 2, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.localization.get(\"setColumnPosition\"))(\"expanded\", ctx.expanded);\n      }\n    },\n    directives: [ColumnMenuItemComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuItemContentTemplateDirective, i4.NgIf],\n    encapsulation: 2\n  });\n  return ColumnMenuPositionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColumnListComponent = /*#__PURE__*/(() => {\n  class ColumnListComponent {\n    constructor(element, ngZone, renderer) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.reset = new EventEmitter();\n      this.apply = new EventEmitter();\n      this.columnChange = new EventEmitter();\n      this.autoSync = true;\n      this.allowHideAll = false;\n      this.actionsClass = 'k-action-buttons';\n      this.unlockedCount = 0;\n    }\n\n    get className() {\n      return true;\n    }\n\n    set columns(value) {\n      this._columns = value.filter(column => column.includeInChooser !== false);\n      this.allColumns = value;\n      this.updateColumnState();\n    }\n\n    get columns() {\n      return this._columns;\n    }\n\n    isDisabled(column) {\n      return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) || this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden;\n    }\n\n    ngOnInit() {\n      if (!this.element) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubscriptions = this.renderer.listen(this.element.nativeElement, 'click', e => {\n          if (hasClasses(e.target, 'k-checkbox')) {\n            if (this.autoSync) {\n              const index = parseInt(e.target.getAttribute('data-index'), 10);\n              const column = this.columns[index];\n              const hidden = !e.target.checked;\n\n              if (Boolean(column.hidden) !== hidden) {\n                this.ngZone.run(() => {\n                  column.hidden = hidden;\n                  this.columnChange.emit([column]);\n                });\n              }\n            } else {\n              this.updateDisabled();\n            }\n          }\n        });\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (!this.service) {\n        return;\n      }\n\n      if (changes.isLast && this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;\n      }\n\n      if (changes.isExpanded && this.isExpanded && this.isLast && this.applyButton) {\n        this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.domSubscriptions) {\n        this.domSubscriptions();\n      }\n    }\n\n    cancelChanges() {\n      this.forEachCheckBox((element, index) => {\n        element.checked = !this.columns[index].hidden;\n      });\n      this.updateDisabled();\n      this.reset.emit();\n    }\n\n    applyChanges() {\n      const changed = [];\n      this.forEachCheckBox((element, index) => {\n        const column = this.columns[index];\n        const hidden = !element.checked;\n\n        if (Boolean(column.hidden) !== hidden) {\n          column.hidden = hidden;\n          changed.push(column);\n        }\n      });\n      this.updateDisabled();\n      this.apply.emit(changed);\n    }\n\n    onTab(e) {\n      if (this.isLast) {\n        e.preventDefault();\n\n        if (this.service) {\n          this.service.menuTabbingService.firstFocusable.focus();\n        }\n      }\n    }\n\n    forEachCheckBox(callback) {\n      const checkboxes = this.element.nativeElement.getElementsByClassName('k-checkbox');\n      const length = checkboxes.length;\n\n      for (let idx = 0; idx < length; idx++) {\n        callback(checkboxes[idx], idx);\n      }\n    }\n\n    updateDisabled() {\n      if (this.allowHideAll && !this.hasLocked) {\n        return;\n      }\n\n      const checkedItems = [];\n      this.forEachCheckBox((checkbox, index) => {\n        if (checkbox.checked) {\n          checkedItems.push({\n            checkbox,\n            index\n          });\n        }\n\n        checkbox.disabled = false;\n      });\n\n      if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {\n        checkedItems[0].checkbox.disabled = true;\n      } else if (this.hasLocked && !this.hasUnlockedFiltered) {\n        const columns = this.columns;\n        const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);\n\n        if (checkedUnlocked.length === 1) {\n          checkedUnlocked[0].checkbox.disabled = true;\n        }\n      }\n    }\n\n    updateColumnState() {\n      this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;\n      this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;\n      this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;\n      const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);\n\n      if (filteredColumns.length) {\n        this.hasFiltered = filteredColumns.length > 0;\n        this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;\n      } else {\n        this.hasFiltered = false;\n        this.hasUnlockedFiltered = false;\n      }\n    }\n\n  }\n\n  ColumnListComponent.ɵfac = function ColumnListComponent_Factory(t) {\n    return new (t || ColumnListComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ColumnListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnListComponent,\n    selectors: [[\"kendo-grid-columnlist\"]],\n    viewQuery: function ColumnListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c23, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.applyButton = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ColumnListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-column-list-wrapper\", ctx.className);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      autoSync: \"autoSync\",\n      allowHideAll: \"allowHideAll\",\n      applyText: \"applyText\",\n      resetText: \"resetText\",\n      actionsClass: \"actionsClass\",\n      isLast: \"isLast\",\n      isExpanded: \"isExpanded\",\n      service: \"service\"\n    },\n    outputs: {\n      reset: \"reset\",\n      apply: \"apply\",\n      columnChange: \"columnChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"k-column-list\"], [\"class\", \"k-column-list-item\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\", 4, \"ngIf\"], [1, \"k-column-list-item\"], [\"type\", \"checkbox\", 1, \"k-checkbox\", \"k-checkbox-md\", \"k-rounded-md\", 3, \"checked\", \"disabled\"], [1, \"k-checkbox-label\"], [3, \"ngClass\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-solid-base\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"click\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-solid-primary\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", 3, \"keydown.tab\", \"click\"], [\"applyButton\", \"\"]],\n    template: function ColumnListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, ColumnListComponent_label_1_Template, 4, 4, \"label\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, ColumnListComponent_div_2_Template, 6, 3, \"div\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columns);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.autoSync);\n      }\n    },\n    directives: [i4.NgForOf, i4.NgIf, i4.NgClass],\n    encapsulation: 2\n  });\n  return ColumnListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the component for selecting columns in the Grid that can be placed\n * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-chooser` component.\n *\n * @example\n * {% meta height:300 %}\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-chooser [service]=\"service\">\n *              </kendo-grid-columnmenu-chooser>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [hidden]=\"true\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n * {% endmeta %}\n */\n\n\nlet ColumnMenuChooserComponent = /*#__PURE__*/(() => {\n  class ColumnMenuChooserComponent extends ColumnMenuItemBase {\n    constructor(localization, columnInfoService, changeDetector, hostElement) {\n      super();\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      /**\n       * Fires when the content is expanded.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the content is collapsed.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Specifies if the content is expanded.\n       */\n\n      this.expanded = false;\n      /**\n       * @hidden\n       */\n\n      this.isLast = false;\n      /**\n       * @hidden\n       */\n\n      this.actionsClass = 'k-columnmenu-actions';\n    }\n\n    get columns() {\n      return this.columnInfoService.leafNamedColumns;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onApply(changed) {\n      this.close();\n\n      if (changed.length) {\n        this.changeDetector.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onCollapse() {\n      this.expanded = false;\n\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');\n      }\n\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onExpand() {\n      this.expanded = true;\n      this.expand.emit();\n    }\n\n  }\n\n  ColumnMenuChooserComponent.ɵfac = function ColumnMenuChooserComponent_Factory(t) {\n    return new (t || ColumnMenuChooserComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ColumnMenuChooserComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuChooserComponent,\n    selectors: [[\"kendo-grid-columnmenu-chooser\"]],\n    inputs: {\n      expanded: \"expanded\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"icon\", \"columns\", 3, \"text\", \"expanded\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"applyText\", \"resetText\", \"columns\", \"autoSync\", \"allowHideAll\", \"actionsClass\", \"isLast\", \"isExpanded\", \"service\", \"apply\"]],\n    template: function ColumnMenuChooserComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"collapse\", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 9, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.localization.get(\"columns\"))(\"expanded\", ctx.expanded);\n      }\n    },\n    directives: [ColumnMenuItemComponent, ColumnListComponent, ColumnMenuItemContentTemplateDirective],\n    encapsulation: 2\n  });\n  return ColumnMenuChooserComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the component for editing column filters in the Grid that can be placed\n * inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-filter` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-filter [service]=\"service\">\n *              </kendo-grid-columnmenu-filter>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuFilterComponent = /*#__PURE__*/(() => {\n  class ColumnMenuFilterComponent extends ColumnMenuItemBase {\n    constructor(localization, hostElement) {\n      super();\n      this.localization = localization;\n      this.hostElement = hostElement;\n      /**\n       * Fires when the content is expanded.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the content is collapsed.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Specifies if the content is expanded.\n       */\n\n      this.expanded = false;\n      /**\n       * @hidden\n       */\n\n      this.isLast = false;\n      /**\n       * @hidden\n       */\n\n      this.actionsClass = 'k-columnmenu-actions';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onCollapse() {\n      this.expanded = false;\n\n      if (this.isLast) {\n        this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');\n      }\n\n      this.collapse.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onExpand() {\n      this.expanded = true;\n      this.expand.emit();\n    }\n\n  }\n\n  ColumnMenuFilterComponent.ɵfac = function ColumnMenuFilterComponent_Factory(t) {\n    return new (t || ColumnMenuFilterComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ColumnMenuFilterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuFilterComponent,\n    selectors: [[\"kendo-grid-columnmenu-filter\"]],\n    inputs: {\n      expanded: \"expanded\",\n      isLast: \"isLast\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"icon\", \"filter\", 3, \"text\", \"expanded\", \"collapse\", \"expand\"], [\"kendoGridColumnMenuItemContentTemplate\", \"\"], [3, \"column\", \"menuTabbingService\", \"filter\", \"actionsClass\", \"isLast\", \"isExpanded\", \"keydown.shift.tab\", \"close\"]],\n    template: function ColumnMenuFilterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"collapse\", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {\n          return ctx.onCollapse();\n        })(\"expand\", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {\n          return ctx.onExpand();\n        });\n        i0.ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 6, \"ng-template\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.localization.get(\"filter\"))(\"expanded\", ctx.expanded);\n      }\n    },\n    directives: [ColumnMenuItemComponent, FilterMenuContainerComponent, ColumnMenuItemContentTemplateDirective],\n    encapsulation: 2\n  });\n  return ColumnMenuFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColumnMenuItemDirective = /*#__PURE__*/(() => {\n  class ColumnMenuItemDirective {\n    constructor(hostElement, renderer, ngZone) {\n      this.hostElement = hostElement;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this._isFirst = false;\n      this._isLast = false;\n      this.subs = new Subscription();\n\n      this.onTab = e => {\n        if (e.keyCode !== Keys.Tab) {\n          return;\n        }\n\n        if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {\n          e.preventDefault();\n          this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();\n        }\n\n        if (this.isLast && !e.shiftKey) {\n          const lastColumnMenuItem = this.getLastColumnMenuItem();\n          const isExpanded = this.menuItemComponent.expanded;\n\n          if (lastColumnMenuItem === e.target && !isExpanded) {\n            e.preventDefault();\n            this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();\n          }\n        }\n      };\n    }\n\n    set isFirst(value) {\n      if (value) {\n        const focusableElement = this.columnMenuItems[0];\n        this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;\n        this.ngZone.runOutsideAngular(() => {\n          const firstItemKeydownSub = this.renderer.listen(focusableElement, 'keydown', this.onTab);\n          this.subs.add(firstItemKeydownSub);\n        });\n      }\n\n      this._isFirst = value;\n    }\n\n    get isFirst() {\n      return this._isFirst;\n    }\n\n    set isLast(value) {\n      if (!this.columnMenuItems) {\n        return;\n      }\n\n      if (value) {\n        const lastFocusableElement = this.getLastColumnMenuItem();\n        this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;\n        this.ngZone.runOutsideAngular(() => {\n          const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, 'keydown', this.onTab);\n          this.subs.add(lastItemKeydownSub);\n        });\n\n        if (this.isExpandableItem()) {\n          this.menuItemComponent.isLast = true;\n        }\n      }\n\n      this._isLast = value;\n    }\n\n    get isLast() {\n      return this._isLast;\n    }\n\n    ngAfterViewInit() {\n      this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');\n      [].slice.apply(this.columnMenuItems).forEach(el => this.renderer.setAttribute(el, 'tabindex', '0'));\n\n      if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {\n        this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n\n    getLastColumnMenuItem() {\n      return this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1];\n    }\n\n    isExpandableItem() {\n      return this.menuItemComponent instanceof ColumnMenuFilterComponent || this.menuItemComponent instanceof ColumnMenuChooserComponent || this.menuItemComponent instanceof ColumnMenuPositionComponent;\n    }\n\n  }\n\n  ColumnMenuItemDirective.ɵfac = function ColumnMenuItemDirective_Factory(t) {\n    return new (t || ColumnMenuItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ColumnMenuItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnMenuItemDirective,\n    selectors: [[\"\", \"kendoGridColumnMenuItem\", \"\"]],\n    inputs: {\n      menuItemComponent: [\"kendoGridColumnMenuItem\", \"menuItemComponent\"]\n    }\n  });\n  return ColumnMenuItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColumnMenuContainerComponent = /*#__PURE__*/(() => {\n  class ColumnMenuContainerComponent {\n    constructor(service, ngZone) {\n      this.service = service;\n      this.ngZone = ngZone;\n    }\n\n    ngAfterContentInit() {\n      if (!this.columnMenuItems.length) {\n        return;\n      }\n\n      this.columnMenuItems.first.isFirst = true;\n      this.columnMenuItems.last.isLast = true;\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable.focus());\n    }\n\n  }\n\n  ColumnMenuContainerComponent.ɵfac = function ColumnMenuContainerComponent_Factory(t) {\n    return new (t || ColumnMenuContainerComponent)(i0.ɵɵdirectiveInject(ColumnMenuService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ColumnMenuContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuContainerComponent,\n    selectors: [[\"kendo-grid-columnmenu-container\"]],\n    contentQueries: function ColumnMenuContainerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuItems = _t);\n      }\n    },\n    ngContentSelectors: _c17,\n    decls: 1,\n    vars: 0,\n    template: function ColumnMenuContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ColumnMenuContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a column-menu item for sorting Grid columns that can be placed inside a\n * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.\n * Allows the user to sort the column.\n *\n * > You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by\n * > the template to the service input of the `kendo-grid-columnmenu-sort` component.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [kendoGridBinding]=\"data\" [sortable]=\"true\" [columnMenu]=\"true\">\n *          <ng-template kendoGridColumnMenuTemplate let-service=\"service\">\n *              <kendo-grid-columnmenu-sort [service]=\"service\">\n *              </kendo-grid-columnmenu-sort>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\" [width]=\"100\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [width]=\"100\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }, { Field1: 'Foo1', Field2: 'Bar1' }];\n * }\n *\n * ```\n */\n\n\nlet ColumnMenuSortComponent = /*#__PURE__*/(() => {\n  class ColumnMenuSortComponent extends ColumnMenuItemBase {\n    constructor(localization, sortService, renderer) {\n      super();\n      this.localization = localization;\n      this.sortService = sortService;\n      this.renderer = renderer;\n    }\n\n    get sortedAsc() {\n      const descriptor = this.descriptor;\n      return descriptor && (!descriptor.dir || descriptor.dir === 'asc');\n    }\n\n    get sortedDesc() {\n      const descriptor = this.descriptor;\n      return descriptor && descriptor.dir === 'desc';\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleSort(dir) {\n      const field = this.service.column.field;\n      const {\n        mode,\n        allowUnsort\n      } = normalize(this.service.sortable);\n      const descriptor = this.descriptor;\n      const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];\n\n      if (descriptor && descriptor.dir === dir) {\n        if (!allowUnsort) {\n          return;\n        }\n      } else {\n        sort.push({\n          field,\n          dir\n        });\n      }\n\n      this.sortService.sort(sort);\n      this.close();\n    }\n\n    get descriptor() {\n      return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);\n    }\n\n  }\n\n  ColumnMenuSortComponent.ɵfac = function ColumnMenuSortComponent_Factory(t) {\n    return new (t || ColumnMenuSortComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ColumnMenuSortComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuSortComponent,\n    selectors: [[\"kendo-grid-columnmenu-sort\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 4,\n    consts: [[\"icon\", \"sort-asc-sm\", 3, \"text\", \"selected\", \"itemClick\"], [\"icon\", \"sort-desc-sm\", 3, \"text\", \"selected\", \"itemClick\"]],\n    template: function ColumnMenuSortComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-columnmenu-item\", 0);\n        i0.ɵɵlistener(\"itemClick\", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {\n          return ctx.toggleSort(\"asc\");\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(1, \"kendo-grid-columnmenu-item\", 1);\n        i0.ɵɵlistener(\"itemClick\", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_1_listener() {\n          return ctx.toggleSort(\"desc\");\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"text\", ctx.localization.get(\"sortAscending\"))(\"selected\", ctx.sortedAsc);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"text\", ctx.localization.get(\"sortDescending\"))(\"selected\", ctx.sortedDesc);\n      }\n    },\n    directives: [ColumnMenuItemComponent],\n    encapsulation: 2\n  });\n  return ColumnMenuSortComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst POPUP_CLASS = 'k-grid-columnmenu-popup';\n/**\n * Represents the [column menu]({% slug columnmenu_grid %}) component.\n */\n\nlet ColumnMenuComponent = /*#__PURE__*/(() => {\n  class ColumnMenuComponent {\n    constructor(popupService, localization, service, navigationService) {\n      this.popupService = popupService;\n      this.localization = localization;\n      this.service = service;\n      this.navigationService = navigationService;\n      /**\n       * @hidden\n       */\n\n      this.standalone = true;\n      /**\n       * The settings for the Column Menu.\n       */\n\n      this.settings = {};\n      /**\n       * @hidden\n       */\n\n      this.sortable = true;\n      /**\n       * @hidden\n       */\n\n      this.tabIndex = '-1';\n      /**\n       * @hidden\n       */\n\n      this.expandedFilter = false;\n      /**\n       * @hidden\n       */\n\n      this.expandedColumns = false;\n      /**\n       * @hidden\n       */\n\n      this.expandedPosition = false;\n      this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isActive() {\n      return this.hasFilter && filtersByField(this.filter, this.column.field).length > 0 || !this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasFilter() {\n      return hasFilter(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasSort() {\n      return hasSort(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasColumnChooser() {\n      return hasColumnChooser(this.settings);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasLock() {\n      return hasLock(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasStick() {\n      return hasStick(this.settings, this.column);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasPosition() {\n      return hasPosition(this.settings, this.column);\n    }\n\n    ngOnChanges() {\n      this.service.column = this.column;\n      this.service.sort = this.sort;\n      this.service.filter = this.filter;\n      this.service.sortable = this.sortable;\n    }\n\n    ngOnDestroy() {\n      this.close();\n      this.closeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggle(e, anchor, template) {\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n\n      this.expandedFilter = this.getExpandedState(this.settings.filter);\n      this.expandedColumns = this.getExpandedState(this.settings.columnChooser);\n      this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);\n      this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASS);\n\n      if (!this.popupRef) {\n        if (this.navigationService.tableEnabled) {\n          this.navigationService.focusCell(0, this.column.leafIndex);\n        } else {\n          this.anchor.nativeElement.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    close() {\n      this.popupService.destroy();\n      this.popupRef = null;\n\n      if (this.navigationService.tableEnabled) {\n        this.navigationService.focusCell(0, this.column.leafIndex);\n      } else {\n        this.anchor.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnMenuTitle() {\n      const localizationMsg = this.localization.get('columnMenu') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n    getExpandedState(menuItemSettings) {\n      return typeof menuItemSettings === 'object' ? menuItemSettings.expanded : false;\n    }\n\n  }\n\n  ColumnMenuComponent.ɵfac = function ColumnMenuComponent_Factory(t) {\n    return new (t || ColumnMenuComponent)(i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnMenuService), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  ColumnMenuComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnMenuComponent,\n    selectors: [[\"kendo-grid-column-menu\"]],\n    viewQuery: function ColumnMenuComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c20, 7);\n        i0.ɵɵviewQuery(_c21, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.anchor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-column-menu-standalone\", ctx.standalone);\n      }\n    },\n    inputs: {\n      standalone: \"standalone\",\n      column: \"column\",\n      settings: \"settings\",\n      sort: \"sort\",\n      filter: \"filter\",\n      sortable: \"sortable\",\n      columnMenuTemplate: \"columnMenuTemplate\",\n      tabIndex: \"tabIndex\"\n    },\n    features: [i0.ɵɵProvidersFeature([ColumnMenuService, MenuTabbingService]), i0.ɵɵNgOnChangesFeature],\n    decls: 7,\n    vars: 5,\n    consts: [[\"href\", \"#\", 1, \"k-grid-column-menu\", \"k-grid-filter\", 3, \"ngClass\", \"tabindex\", \"click\", \"keydown.enter\"], [\"anchor\", \"\"], [1, \"k-icon\", \"k-i-more-vertical\"], [\"template\", \"\"], [\"defaultTemplate\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"keydown.escape\", \"keydown.enter\"], [3, \"kendoGridColumnMenuItem\", \"service\", 4, \"ngIf\"], [3, \"showLock\", \"showStick\", \"kendoGridColumnMenuItem\", \"service\", \"expanded\", 4, \"ngIf\"], [3, \"kendoGridColumnMenuItem\", \"service\", \"expanded\", 4, \"ngIf\"], [3, \"kendoGridColumnMenuItem\", \"service\"], [\"sortItem\", \"\"], [\"lockItem\", \"\"], [\"stickItem\", \"\"], [3, \"showLock\", \"showStick\", \"kendoGridColumnMenuItem\", \"service\", \"expanded\"], [\"positionItem\", \"\"], [3, \"kendoGridColumnMenuItem\", \"service\", \"expanded\"], [\"chooserItem\", \"\"], [\"filterItem\", \"\"]],\n    template: function ColumnMenuComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r20 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"click\", function ColumnMenuComponent_Template_a_click_0_listener($event) {\n          i0.ɵɵrestoreView(_r20);\n\n          const _r0 = i0.ɵɵreference(1);\n\n          const _r1 = i0.ɵɵreference(4);\n\n          return ctx.toggle($event, _r0, _r1);\n        })(\"keydown.enter\", function ColumnMenuComponent_Template_a_keydown_enter_0_listener($event) {\n          return $event.stopImmediatePropagation();\n        });\n        i0.ɵɵelement(2, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 1, 5, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, ColumnMenuComponent_ng_template_5_Template, 7, 6, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c25, ctx.isActive))(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵattribute(\"title\", ctx.columnMenuTitle);\n      }\n    },\n    directives: [ColumnMenuContainerComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, i4.NgClass, i4.NgTemplateOutlet, i4.NgIf, ColumnMenuItemDirective],\n    encapsulation: 2\n  });\n  return ColumnMenuComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a component which accommodates the filter operators.\n */\n\n\nlet FilterCellOperatorsComponent = /*#__PURE__*/(() => {\n  class FilterCellOperatorsComponent {\n    constructor(localization) {\n      this.localization = localization;\n      this.clearText = 'Clear';\n      /**\n       * The filter operators that will be displayed.\n       */\n\n      this.operators = [];\n      /**\n       * Determines if the list of operators will be displayed.\n       * @type {boolean}\n       */\n\n      this.showOperators = true;\n      /**\n       * Fires when the operator is selected.\n       * @type {EventEmitter<string>}\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires when the **Clear** button is clicked.\n       * @type {EventEmitter<{}>}\n       */\n\n      this.clear = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostClasses() {\n      return true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onChange(dataItem) {\n      this.valueChange.emit(dataItem);\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearClick() {\n      this.clear.emit();\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearKeydown(args) {\n      if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {\n        this.clear.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    dropdownKeydown(args) {\n      if (args.defaultPrevented) {\n        return;\n      }\n\n      if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {\n        this.dropdown.toggle(true);\n        args.preventDefault();\n      }\n    }\n\n    ngOnInit() {\n      this.localization.changes.subscribe(() => this.clearText = this.localization.get(\"filterClearButton\"));\n    }\n\n  }\n\n  FilterCellOperatorsComponent.ɵfac = function FilterCellOperatorsComponent_Factory(t) {\n    return new (t || FilterCellOperatorsComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  FilterCellOperatorsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterCellOperatorsComponent,\n    selectors: [[\"kendo-grid-filter-cell-operators\"]],\n    viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c26, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell-operator\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      operators: \"operators\",\n      showButton: \"showButton\",\n      showOperators: \"showOperators\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      clear: \"clear\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"kendoGridFocusable\", \"\", \"class\", \"k-dropdown-operator\", \"iconClass\", \"k-i-filter\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"data\", \"value\", \"valuePrimitive\", \"popupSettings\", \"valueChange\", \"keydown\", 4, \"ngIf\"], [\"type\", \"button\", \"kendoGridFocusable\", \"\", \"class\", \"k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle k-icon-button\", 3, \"title\", \"click\", \"keydown\", 4, \"ngIf\"], [\"kendoGridFocusable\", \"\", \"iconClass\", \"k-i-filter\", \"textField\", \"text\", \"valueField\", \"value\", 1, \"k-dropdown-operator\", 3, \"data\", \"value\", \"valuePrimitive\", \"popupSettings\", \"valueChange\", \"keydown\"], [\"dropdown\", \"\"], [\"type\", \"button\", \"kendoGridFocusable\", \"\", 1, \"k-button\", \"k-button-solid-base\", \"k-button-solid\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", \"k-icon-button\", 3, \"title\", \"click\", \"keydown\"], [1, \"k-icon\", \"k-button-icon\", \"k-i-filter-clear\"]],\n    template: function FilterCellOperatorsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, FilterCellOperatorsComponent_kendo_dropdownlist_0_Template, 2, 5, \"kendo-dropdownlist\", 0);\n        i0.ɵɵtemplate(1, FilterCellOperatorsComponent_button_1_Template, 2, 1, \"button\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButton);\n      }\n    },\n    directives: [i1$4.DropDownListComponent, i4.NgIf, FocusableDirective],\n    encapsulation: 2\n  });\n  return FilterCellOperatorsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];\n/**\n * @hidden\n */\n\nlet FilterCellWrapperComponent = /*#__PURE__*/(() => {\n  class FilterCellWrapperComponent extends FilterInputWrapperComponent {\n    constructor(filterService) {\n      super(filterService);\n      this.showOperators = true;\n    }\n\n    get hostClasses() {\n      return true;\n    }\n\n    get overrideBaseClasses() {\n      return false;\n    }\n\n    get showButton() {\n      const filter = this.currentFilter;\n      return isPresent(filter) && (!isNullOrEmptyString(filter.value) || EMPTY_FILTER_OPERATORS.indexOf(String(filter.operator)) >= 0);\n    }\n\n    filterChange(filter) {\n      this.applyFilter(filter);\n    }\n\n  }\n\n  FilterCellWrapperComponent.ɵfac = function FilterCellWrapperComponent_Factory(t) {\n    return new (t || FilterCellWrapperComponent)(i0.ɵɵdirectiveInject(FilterService));\n  };\n\n  FilterCellWrapperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterCellWrapperComponent,\n    selectors: [[\"kendo-grid-filter-wrapper-cell\"]],\n    hostVars: 4,\n    hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filtercell-wrapper\", ctx.hostClasses)(\"k-filtercell\", ctx.overrideBaseClasses);\n      }\n    },\n    inputs: {\n      showOperators: \"showOperators\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c17,\n    decls: 2,\n    vars: 4,\n    consts: [[3, \"showOperators\", \"operators\", \"showButton\", \"value\", \"clear\", \"valueChange\"]],\n    template: function FilterCellWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"kendo-grid-filter-cell-operators\", 0);\n        i0.ɵɵlistener(\"clear\", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_clear_1_listener() {\n          return ctx.onClear();\n        })(\"valueChange\", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) {\n          return ctx.currentOperator = $event;\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"showOperators\", ctx.showOperators)(\"operators\", ctx.operators)(\"showButton\", ctx.showButton)(\"value\", ctx.currentOperator);\n      }\n    },\n    directives: [FilterCellOperatorsComponent],\n    encapsulation: 2\n  });\n  return FilterCellWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a string-filter cell component\n * ([see example]({% slug builtinfiltertemplate_grid %}#toc-configuration-components-for-filter-templates)).\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-string-filter-cell\n *              [showOperators]=\"false\"\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-string-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet StringFilterCellComponent = /*#__PURE__*/(() => {\n  class StringFilterCellComponent extends StringFilterComponent {\n    constructor(filterService, localization) {\n      super(filterService, localization);\n      /**\n       * Determines the delay time (in milliseconds) before the filter value is submitted.\n       * A value of `0` indicates no delay. The default value is `500`.\n       * @type {boolean}\n       */\n\n      this.filterDelay = 500;\n      /**\n       * Determines if the drop-down filter operators will be displayed.\n       * The default value is `true`.\n       * @type {boolean}\n       */\n\n      this.showOperators = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  StringFilterCellComponent.ɵfac = function StringFilterCellComponent_Factory(t) {\n    return new (t || StringFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StringFilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StringFilterCellComponent,\n    selectors: [[\"kendo-grid-string-filter-cell\"]],\n    inputs: {\n      filterDelay: \"filterDelay\",\n      showOperators: \"showOperators\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 8,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoTextBox\", \"\", \"kendoGridFocusable\", \"\", \"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"ngModel\"]],\n    template: function StringFilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"input\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", ctx.filterDelay)(\"ngModel\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    directives: [FilterCellWrapperComponent, i4$1.TextBoxDirective, i4$2.DefaultValueAccessor, FocusableDirective, FilterInputDirective, i4$2.NgControlStatus, i4$2.NgModel],\n    encapsulation: 2\n  });\n  return StringFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a numeric filter cell.\n *\n * @example\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-numeric-filter-cell\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-numeric-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet NumericFilterCellComponent = /*#__PURE__*/(() => {\n  class NumericFilterCellComponent extends NumericFilterComponent {\n    constructor(filterService, localization) {\n      super(filterService, localization);\n      this.localization = localization;\n      /**\n       * Determines the delay time (in milliseconds) before the filter value is submitted.\n       * A value of `0` indicates no delay. The default value is `500`.\n       * @type {boolean}\n       */\n\n      this.filterDelay = 500;\n      /**\n       * Determines if the drop-down filter operators will be displayed.\n       * The default value is `true`.\n       * @type {boolean}\n       */\n\n      this.showOperators = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  NumericFilterCellComponent.ɵfac = function NumericFilterCellComponent_Factory(t) {\n    return new (t || NumericFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NumericFilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NumericFilterCellComponent,\n    selectors: [[\"kendo-grid-numeric-filter-cell\"]],\n    inputs: {\n      filterDelay: \"filterDelay\",\n      showOperators: \"showOperators\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 17,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoGridFocusable\", \"\", \"kendoFilterInput\", \"\", 3, \"columnLabel\", \"filterDelay\", \"autoCorrect\", \"value\", \"format\", \"decimals\", \"spinners\", \"min\", \"max\", \"step\"], [3, \"increment\", \"decrement\"]],\n    template: function NumericFilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0)(1, \"kendo-numerictextbox\", 1);\n        i0.ɵɵelement(2, \"kendo-numerictextbox-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"filterDelay\", ctx.filterDelay)(\"autoCorrect\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"decimals\", ctx.decimals)(\"spinners\", ctx.spinners)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"increment\", ctx.messageFor(\"filterNumericIncrement\"))(\"decrement\", ctx.messageFor(\"filterNumericDecrement\"));\n      }\n    },\n    directives: [FilterCellWrapperComponent, i4$1.NumericTextBoxComponent, i4$1.NumericTextBoxCustomMessagesComponent, FocusableDirective, FilterInputDirective],\n    encapsulation: 2\n  });\n  return NumericFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a Boolean filter-cell component.\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-boolean-filter-cell\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-boolean-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet BooleanFilterCellComponent = /*#__PURE__*/(() => {\n  class BooleanFilterCellComponent extends BooleanFilterComponent {\n    constructor(filterService, localization, cd) {\n      super(filterService, localization);\n      this.cd = cd;\n    }\n\n    localizationChange() {\n      super.localizationChange();\n      this.cd.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  BooleanFilterCellComponent.ɵfac = function BooleanFilterCellComponent_Factory(t) {\n    return new (t || BooleanFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  BooleanFilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BooleanFilterCellComponent,\n    selectors: [[\"kendo-grid-boolean-filter-cell\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 11,\n    consts: [[3, \"column\", \"filter\", \"showOperators\", \"defaultOperator\"], [\"kendoFilterInput\", \"\", \"kendoGridFocusable\", \"\", \"textField\", \"text\", \"valueField\", \"value\", 3, \"columnLabel\", \"defaultItem\", \"data\", \"popupSettings\", \"valuePrimitive\", \"value\"]],\n    template: function BooleanFilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"kendo-dropdownlist\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"showOperators\", false)(\"defaultOperator\", ctx.operator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"defaultItem\", ctx.defaultItem)(\"data\", ctx.items)(\"popupSettings\", i0.ɵɵpureFunction0(10, _c27))(\"valuePrimitive\", true)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    directives: [FilterCellWrapperComponent, i1$4.DropDownListComponent, FilterInputDirective, FocusableDirective],\n    encapsulation: 2\n  });\n  return BooleanFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a date-filter cell component.\n *\n * @example\n *\n *  ```html-no-run\n *      <kendo-grid-column field=\"OrderDate\" title=\"Order Date\">\n *          <ng-template kendoGridFilterCellTemplate let-filter let-column=\"column\">\n *          <kendo-grid-date-filter-cell\n *              [showOperators]=\"false\"\n *              [column]=\"column\"\n *              [filter]=\"filter\">\n *          </kendo-grid-date-filter-cell>\n *          </ng-template>\n *      </kendo-grid-column>\n *   ```\n */\n\n\nlet DateFilterCellComponent = /*#__PURE__*/(() => {\n  class DateFilterCellComponent extends DateFilterComponent {\n    constructor(filterService, localization) {\n      super(filterService, localization);\n      this.localization = localization;\n      /**\n       * Determines if the drop-down filter operators will be displayed. The default value is `true`.\n       * @type {boolean}\n       */\n\n      this.showOperators = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columnLabel() {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = this.column.title || this.column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  DateFilterCellComponent.ɵfac = function DateFilterCellComponent_Factory(t) {\n    return new (t || DateFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DateFilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateFilterCellComponent,\n    selectors: [[\"kendo-grid-date-filter-cell\"]],\n    inputs: {\n      showOperators: \"showOperators\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 18,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"defaultOperator\", \"showOperators\"], [\"kendoFilterInput\", \"\", \"kendoGridFocusable\", \"\", 3, \"columnLabel\", \"value\", \"format\", \"formatPlaceholder\", \"placeholder\", \"activeView\", \"bottomView\", \"topView\", \"min\", \"max\", \"weekNumber\"], [3, \"toggle\", \"today\"]],\n    template: function DateFilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0)(1, \"kendo-datepicker\", 1);\n        i0.ɵɵelement(2, \"kendo-datepicker-messages\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"defaultOperator\", ctx.operator)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"columnLabel\", ctx.columnLabel)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value)(\"format\", ctx.format)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"activeView\", ctx.activeView)(\"bottomView\", ctx.bottomView)(\"topView\", ctx.topView)(\"min\", ctx.min)(\"max\", ctx.max)(\"weekNumber\", ctx.weekNumber);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"toggle\", ctx.messageFor(\"filterDateToggle\"))(\"today\", ctx.messageFor(\"filterDateToday\"));\n      }\n    },\n    directives: [FilterCellWrapperComponent, i4$3.DatePickerComponent, i4$3.DatePickerCustomMessagesComponent, FilterInputDirective, FocusableDirective],\n    encapsulation: 2\n  });\n  return DateFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * > List the following components in the GridModule as `entryComponents`.\n */\n\n\nconst filterComponentFactory = type => ({\n  \"boolean\": BooleanFilterCellComponent,\n  \"date\": DateFilterCellComponent,\n  \"numeric\": NumericFilterCellComponent,\n  \"text\": StringFilterCellComponent\n})[type];\n/**\n * @hidden\n */\n\n\nlet FilterCellHostDirective = /*#__PURE__*/(() => {\n  class FilterCellHostDirective extends FilterHostDirective {\n    constructor(host, resolver) {\n      super(host, resolver);\n    }\n\n    componentType() {\n      if (!isNullOrEmptyString(this.column.filter)) {\n        return filterComponentFactory(this.column.filter);\n      }\n\n      return StringFilterCellComponent;\n    }\n\n  }\n\n  FilterCellHostDirective.ɵfac = function FilterCellHostDirective_Factory(t) {\n    return new (t || FilterCellHostDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  };\n\n  FilterCellHostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterCellHostDirective,\n    selectors: [[\"\", \"kendoFilterCellHost\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return FilterCellHostDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterCellComponent = /*#__PURE__*/(() => {\n  class FilterCellComponent {\n    constructor() {\n      this._templateContext = {};\n    }\n\n    get filter() {\n      return this._filter;\n    }\n\n    set filter(value) {\n      this._filter = cloneFilters(value);\n    }\n\n    get templateContext() {\n      this._templateContext.column = this.column;\n      this._templateContext.filter = this.filter;\n      this._templateContext['$implicit'] = this.filter;\n      return this._templateContext;\n    }\n\n    get hasTemplate() {\n      return isPresent(this.column.filterCellTemplateRef);\n    }\n\n    get isFilterable() {\n      return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;\n    }\n\n  }\n\n  FilterCellComponent.ɵfac = function FilterCellComponent_Factory(t) {\n    return new (t || FilterCellComponent)();\n  };\n\n  FilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterCellComponent,\n    selectors: [[\"\", \"kendoGridFilterCell\", \"\"]],\n    inputs: {\n      column: \"column\",\n      filter: \"filter\"\n    },\n    attrs: _c28,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [\"kendoFilterCellHost\", \"\", 3, \"column\", \"filter\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function FilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, FilterCellComponent_ng_container_0_Template, 4, 3, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isFilterable);\n      }\n    },\n    directives: [i4.NgIf, i4.NgSwitch, i4.NgSwitchCase, FilterCellHostDirective, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return FilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet id$1 = 0;\n\nfunction nextId$1() {\n  return id$1++;\n}\n/**\n * @hidden\n */\n\n\nlet LogicalCellDirective = /*#__PURE__*/(() => {\n  class LogicalCellDirective {\n    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {\n      this.focusGroup = focusGroup;\n      this.element = element;\n      this.columnInfoService = columnInfoService;\n      this.idService = idService;\n      this.navigationService = navigationService;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.cellContext = cellContext;\n      this.logicalSlaveCell = false;\n      this.colSpan = 1;\n      this.rowSpan = 1;\n      this.dataRowIndex = -1;\n      this.detailExpandCell = false;\n      this.uid = nextId$1();\n    }\n\n    get id() {\n      if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {\n        return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);\n      }\n    }\n\n    get ariaColIndex() {\n      if (this.logicalSlaveCell || this.logicalColIndex === -1) {\n        return undefined;\n      }\n\n      return this.logicalColIndex + 1;\n    }\n\n    ngOnInit() {\n      if (!this.navigationService.tableEnabled) {\n        return;\n      }\n\n      this.navigationChange = this.navigationService.changes.subscribe(e => this.onNavigationChange(e));\n    }\n\n    ngDoCheck() {\n      if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {\n        return;\n      }\n\n      if (this.cellContext) {\n        this.cellContext.focusGroup = this.focusGroup;\n      }\n\n      this.registerNoChanges();\n    }\n\n    ngOnChanges(changes) {\n      if (!this.navigationService.tableEnabled) {\n        return;\n      }\n\n      const keys = Object.keys(changes);\n\n      if (keys.length === 1 && keys[0] === 'groupItem' || this.logicalColIndex === -1) {\n        // Ignore groupItem changes as the reference is not stable\n        return;\n      }\n\n      const indexChange = changes.logicalColIndex;\n      const rowIndexChange = changes.logicalRowIndex;\n      const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;\n      const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;\n      this.navigationService.unregisterCell(index, rowIndex, this);\n      this.registerChanges();\n      this.updateElement();\n    }\n\n    ngOnDestroy() {\n      if (this.navigationChange) {\n        this.navigationChange.unsubscribe();\n      }\n\n      this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);\n    }\n\n    onNavigationChange(e) {\n      const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;\n      const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;\n\n      if (active || wasActive) {\n        this.updateElement();\n      }\n    }\n\n    updateElement() {\n      const el = this.element.nativeElement;\n      this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');\n\n      if (this.isFocused()) {\n        if (this.focusGroup.isNavigable()) {\n          this.focusGroup.focus();\n        } else {\n          if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {\n            this.microtask(() => this.isFocused() && el.focus());\n          }\n\n          this.renderer.addClass(el, 'k-state-focused');\n        }\n\n        if (this.headerLabelText) {\n          el.setAttribute('aria-label', '');\n        }\n      } else {\n        this.renderer.removeClass(el, 'k-state-focused');\n\n        if (this.headerLabelText) {\n          el.setAttribute('aria-label', this.headerLabelText);\n        }\n      }\n    }\n\n    microtask(callback) {\n      this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));\n    }\n\n    registerChanges() {\n      if (!this.logicalSlaveCell) {\n        this.navigationService.registerCell(this);\n      }\n    }\n\n    registerNoChanges() {\n      if (!this.logicalSlaveCell) {\n        this.navigationService.registerCellOnCurrentRow(this);\n      }\n    }\n\n    isFocusable() {\n      return this.navigationService.isCellFocusable(this);\n    }\n\n    isFocused() {\n      return this.navigationService.isCellFocused(this);\n    }\n\n  }\n\n  LogicalCellDirective.ɵfac = function LogicalCellDirective_Factory(t) {\n    return new (t || LogicalCellDirective)(i0.ɵɵdirectiveInject(FocusGroup), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(CELL_CONTEXT, 8));\n  };\n\n  LogicalCellDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LogicalCellDirective,\n    selectors: [[\"\", \"kendoGridLogicalCell\", \"\"]],\n    hostVars: 2,\n    hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-colindex\", ctx.ariaColIndex);\n      }\n    },\n    inputs: {\n      logicalColIndex: \"logicalColIndex\",\n      logicalRowIndex: \"logicalRowIndex\",\n      logicalSlaveCell: \"logicalSlaveCell\",\n      colIndex: \"colIndex\",\n      colSpan: \"colSpan\",\n      rowSpan: \"rowSpan\",\n      groupItem: \"groupItem\",\n      dataRowIndex: \"dataRowIndex\",\n      dataItem: \"dataItem\",\n      detailExpandCell: \"detailExpandCell\",\n      headerLabelText: \"headerLabelText\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FocusGroup,\n      deps: [FocusRoot],\n      useClass: FocusGroup\n    }]), i0.ɵɵNgOnChangesFeature]\n  });\n  return LogicalCellDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterRowComponent = /*#__PURE__*/(() => {\n  class FilterRowComponent {\n    constructor(localization, columnInfoService) {\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.columns = [];\n      this.groups = [];\n      this.filterRowClass = true;\n    }\n\n    addStickyStyles(column) {\n      const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;\n      return Object.assign(Object.assign({}, sticky), column.filterStyle);\n    }\n\n    filterLabel(column) {\n      const localizationMsg = this.localization.get('filterInputLabel') || '';\n      const columnName = column.title || column.field;\n      return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);\n    }\n\n  }\n\n  FilterRowComponent.ɵfac = function FilterRowComponent_Factory(t) {\n    return new (t || FilterRowComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService));\n  };\n\n  FilterRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FilterRowComponent,\n    selectors: [[\"\", \"kendoGridFilterRow\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FilterRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-filter-row\", ctx.filterRowClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      filter: \"filter\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      logicalRowIndex: \"logicalRowIndex\",\n      lockedColumnsCount: \"lockedColumnsCount\"\n    },\n    attrs: _c29,\n    decls: 3,\n    vars: 3,\n    consts: [[\"role\", \"presentation\", 3, \"k-group-cell\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 3, \"k-hierarchy-cell\", 4, \"ngIf\"], [\"kendoGridFilterCell\", \"\", \"kendoGridLogicalCell\", \"\", 3, \"k-grid-header-sticky\", \"ngStyle\", \"ngClass\", \"column\", \"filter\", \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\"], [\"kendoGridFilterCell\", \"\", \"kendoGridLogicalCell\", \"\", 3, \"ngStyle\", \"ngClass\", \"column\", \"filter\", \"logicalRowIndex\", \"logicalColIndex\"]],\n    template: function FilterRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, FilterRowComponent_td_0_Template, 1, 2, \"td\", 0);\n        i0.ɵɵtemplate(1, FilterRowComponent_td_1_Template, 1, 2, \"td\", 1);\n        i0.ɵɵtemplate(2, FilterRowComponent_td_2_Template, 1, 9, \"td\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columns);\n      }\n    },\n    directives: [FilterCellComponent, i4.NgForOf, i4.NgIf, LogicalCellDirective, i4.NgStyle, i4.NgClass],\n    encapsulation: 2\n  });\n  return FilterRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet id = 0;\n\nfunction nextId() {\n  return id++;\n}\n/**\n * @hidden\n */\n\n\nlet LogicalRowDirective = /*#__PURE__*/(() => {\n  class LogicalRowDirective {\n    constructor(idService, navigation) {\n      this.idService = idService;\n      this.navigation = navigation;\n      this.logicalSlaveRow = false;\n      this.logicalSlaveCellsCount = 0;\n      this.dataRowIndex = -1;\n      this.uid = nextId();\n    }\n\n    get hostRole() {\n      return this.logicalSlaveRow ? 'presentation' : 'row';\n    }\n\n    get ariaRowIndex() {\n      return this.logicalRowIndex + 1;\n    }\n\n    get ariaOwns() {\n      if (!this.navigation.enabled || this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {\n        return undefined;\n      }\n\n      const ids = [];\n      const total = this.logicalCellsCount + this.logicalSlaveCellsCount;\n\n      for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {\n        ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));\n      }\n\n      return ids.join(' ');\n    }\n\n    ngOnChanges(changes) {\n      if (!this.navigation.enabled || this.logicalSlaveRow) {\n        return;\n      }\n\n      const indexChange = changes.logicalRowIndex;\n      const logicalSlaveRowChange = changes.logicalSlaveRow;\n\n      if (indexChange || logicalSlaveRowChange) {\n        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;\n        this.navigation.unregisterRow(index, this);\n        this.navigation.registerRow(this);\n      } else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {\n        this.navigation.updateRow(this);\n      }\n    }\n\n    ngOnDestroy() {\n      this.navigation.unregisterRow(this.logicalRowIndex, this);\n    }\n\n  }\n\n  LogicalRowDirective.ɵfac = function LogicalRowDirective_Factory(t) {\n    return new (t || LogicalRowDirective)(i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  LogicalRowDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LogicalRowDirective,\n    selectors: [[\"\", \"kendoGridLogicalRow\", \"\"]],\n    hostVars: 3,\n    hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole)(\"aria-rowindex\", ctx.ariaRowIndex)(\"aria-owns\", ctx.ariaOwns);\n      }\n    },\n    inputs: {\n      logicalRowIndex: \"logicalRowIndex\",\n      logicalSlaveRow: \"logicalSlaveRow\",\n      logicalCellsCount: \"logicalCellsCount\",\n      logicalSlaveCellsCount: \"logicalSlaveCellsCount\",\n      dataRowIndex: \"dataRowIndex\",\n      dataItem: \"dataItem\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LogicalRowDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TemplateContextDirective = /*#__PURE__*/(() => {\n  class TemplateContextDirective {\n    constructor(viewContainerRef) {\n      this.viewContainerRef = viewContainerRef;\n    }\n\n    set templateContext(context) {\n      this.removeView();\n\n      if (context.templateRef) {\n        this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n      }\n    }\n\n    ngOnDestroy() {\n      this.removeView();\n    }\n\n    removeView() {\n      if (this.insertedViewRef) {\n        this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n        this.insertedViewRef = undefined;\n      }\n    }\n\n  }\n\n  TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) {\n    return new (t || TemplateContextDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  TemplateContextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateContextDirective,\n    selectors: [[\"\", \"templateContext\", \"\"]],\n    inputs: {\n      templateContext: \"templateContext\"\n    }\n  });\n  return TemplateContextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the select-all checkbox feature of the Grid ([see example]({% slug selection_grid %}#toc-select-all-feature)).\n */\n\n\nlet SelectAllCheckboxDirective = /*#__PURE__*/(() => {\n  class SelectAllCheckboxDirective {\n    constructor(selectionService, el, renderer, ngZone) {\n      this.selectionService = selectionService;\n      this.el = el;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      /**\n       * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox\n       * ([see example]({% slug selection_grid %}#toc-select-all-feature)).\n       */\n\n      this.selectAllChange = new EventEmitter();\n      this.type = 'checkbox';\n      this.stateSet = false;\n      this.ngZone.runOutsideAngular(() => {\n        this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));\n      });\n    }\n\n    ngAfterContentChecked() {\n      this.setState();\n    }\n\n    ngOnChanges() {\n      this.stateSet = true;\n    }\n\n    ngOnDestroy() {\n      if (this.destroyClick) {\n        this.destroyClick();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      // yields consistent cross-browser behavior when clicking an indeterminate checkbox\n      const undefinedCheckedStateInIE = detectIE() && this.selectionService.selectAllState === undefined;\n      const isChecked = undefinedCheckedStateInIE ? true : this.el.nativeElement.checked;\n      const options = this.selectionService.options;\n      const enabledAndMultiple = options.enabled && options.mode === 'multiple';\n      const shouldEmitSelectAll = hasObservers(this.selectAllChange);\n\n      if (enabledAndMultiple || shouldEmitSelectAll) {\n        this.ngZone.run(() => {\n          if (enabledAndMultiple) {\n            this.selectionService.updateAll(isChecked);\n          }\n\n          if (shouldEmitSelectAll) {\n            this.selectAllChange.emit(isChecked ? 'checked' : 'unchecked');\n          }\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    setState() {\n      const state = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;\n      const elem = this.el.nativeElement;\n      this.renderer.setProperty(elem, 'indeterminate', !isPresent(state));\n      this.renderer.setProperty(elem, 'checked', isPresent(state) ? state : false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    stateToBool() {\n      switch (this.state) {\n        case 'checked':\n          return true;\n\n        case 'unchecked':\n          return false;\n\n        default:\n          return undefined;\n      }\n    }\n\n  }\n\n  SelectAllCheckboxDirective.ɵfac = function SelectAllCheckboxDirective_Factory(t) {\n    return new (t || SelectAllCheckboxDirective)(i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  SelectAllCheckboxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectAllCheckboxDirective,\n    selectors: [[\"\", \"kendoGridSelectAllCheckbox\", \"\"]],\n    hostVars: 1,\n    hostBindings: function SelectAllCheckboxDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type);\n      }\n    },\n    inputs: {\n      state: \"state\"\n    },\n    outputs: {\n      selectAllChange: \"selectAllChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return SelectAllCheckboxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst fromPercentage = (value, percent) => {\n  const sign = percent < 0 ? -1 : 1;\n  return Math.ceil(Math.abs(percent) / 100 * value) * sign;\n};\n/**\n * @hidden\n */\n\n\nconst toPercentage = (value, whole) => value / whole * 100;\n/**\n * @hidden\n */\n\n\nconst headerWidth = handle => handle.nativeElement.parentElement.offsetWidth;\n/**\n * @hidden\n */\n\n\nconst allLeafColumns = columns => expandColumns(columns).filter(c => !c.isColumnGroup);\n/**\n * @hidden\n */\n\n\nconst stopPropagation = ({\n  originalEvent: event\n}) => {\n  event.stopPropagation();\n  event.preventDefault();\n};\n/**\n * @hidden\n */\n\n\nconst createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe( // eslint-disable-next-line rxjs/no-unsafe-takeuntil\ntakeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({\n  pageX\n}) => ({\n  originalX: mouseDown.pageX,\n  pageX\n})));\n/**\n * @hidden\n */\n\n\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n/**\n * @hidden\n */\n\n\nconst isInSpanColumn = column => !!(column.parent && column.parent.isSpanColumn);\n/**\n * @hidden\n *\n * Calculates the column index. If the column is stated in `SpanColumn`,\n * the index for all child columns equals the index of the first child.\n */\n\n\nconst indexOf = (target, list) => {\n  let index = 0;\n  let ignore = 0;\n  let skip = 0;\n\n  while (index < list.length) {\n    const current = list[index];\n    const isParentSpanColumn = isInSpanColumn(current);\n\n    if (current === target) {\n      break;\n    }\n\n    if (ignore-- <= 0 && isParentSpanColumn) {\n      ignore = current.parent.childColumns.length - 1;\n      skip += ignore;\n    }\n\n    index++;\n  }\n\n  return index - skip;\n};\n/**\n * @hidden\n */\n\n\nlet ColumnHandleDirective = /*#__PURE__*/(() => {\n  class ColumnHandleDirective {\n    constructor(draggable, element, service, zone, cdr, localization, columnInfoService) {\n      this.draggable = draggable;\n      this.element = element;\n      this.service = service;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.columns = [];\n      this.subscriptions = new Subscription();\n      this.rtl = false;\n    }\n\n    get visible() {\n      return this.column.resizable ? 'block' : 'none';\n    }\n\n    get leftStyle() {\n      return isTruthy(this.rtl) ? 0 : null;\n    }\n\n    get rightStyle() {\n      return isTruthy(this.rtl) ? null : 0;\n    }\n\n    autoFit() {\n      const allLeafs = allLeafColumns(this.columns);\n      const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));\n      const columnInfo = currentLeafs.map(column => {\n        const isParentSpan = isInSpanColumn(column);\n        const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;\n        const index = indexOf(column, allLeafs);\n        return {\n          column,\n          headerIndex: this.columnsForLevel(column.level).indexOf(column),\n          index,\n          isLastInSpan,\n          isParentSpan,\n          level: column.level\n        };\n      });\n      currentLeafs.forEach(column => column.width = 0);\n      this.service.measureColumns(columnInfo);\n    }\n\n    ngOnInit() {\n      if (isBlank(this.column.width)) {\n        this.column.implicitWidth = headerWidth(this.element);\n      }\n\n      const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'start')).subscribe(this.initState.bind(this)));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn')).subscribe(this.resize.bind(this)));\n      this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only\n      ).subscribe(this.initColumnWidth.bind(this)));\n      this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable))).subscribe(({\n        pageX,\n        originalX\n      }) => {\n        const delta = pageX - originalX;\n        const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);\n        this.service.resizeColumns(percent);\n      })));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete')).subscribe(this.sizeToFit.bind(this)));\n      this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit')).subscribe(this.autoFit.bind(this)));\n      this.subscriptions.add(this.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl));\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    shouldUpdate() {\n      return !allLeafColumns(this.columns).map(column => column.width).some(isBlank);\n    }\n\n    initColumnWidth() {\n      this.column.width = headerWidth(this.element);\n    }\n\n    initState() {\n      this.column.resizeStartWidth = headerWidth(this.element);\n      this.service.resizedColumn({\n        column: this.column,\n        oldWidth: this.column.resizeStartWidth\n      });\n    }\n\n    resize({\n      deltaPercent\n    }) {\n      let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);\n\n      if (isTruthy(this.rtl)) {\n        delta *= -1;\n      }\n\n      const newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);\n      const tableDelta = newWidth > this.column.minResizableWidth ? delta : this.column.minResizableWidth - this.column.resizeStartWidth;\n      this.updateWidth(this.column, newWidth);\n      this.service.resizeTable(this.column, tableDelta);\n    }\n\n    sizeToFit({\n      columns,\n      widths\n    }) {\n      const index = columns.indexOf(this.column);\n      const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE\n\n      const tableDelta = width - this.column.resizeStartWidth;\n      this.updateWidth(this.column, width);\n      this.service.resizeTable(this.column, tableDelta);\n    }\n\n    updateWidth(column, width) {\n      column.width = width;\n      this.columnInfoService.hiddenColumns.forEach(col => {\n        if (isBlank(col.width) && isPresent(col.implicitWidth)) {\n          // Resize hidden columns to their implicit width so they\n          // can be displayed with the same width if made visible.\n          col.width = col.implicitWidth;\n        }\n      });\n      this.cdr.markForCheck(); //force CD cycle\n    }\n\n    columnsForLevel(level) {\n      return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);\n    }\n\n  }\n\n  ColumnHandleDirective.ɵfac = function ColumnHandleDirective_Factory(t) {\n    return new (t || ColumnHandleDirective)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService));\n  };\n\n  ColumnHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnHandleDirective,\n    selectors: [[\"\", \"kendoGridColumnHandle\", \"\"]],\n    hostVars: 6,\n    hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function ColumnHandleDirective_dblclick_HostBindingHandler() {\n          return ctx.autoFit();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible)(\"left\", ctx.leftStyle)(\"right\", ctx.rightStyle);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      column: \"column\"\n    }\n  });\n  return ColumnHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));\n\nconst directions = initialDirection => initialDirection === \"asc\" ? [\"asc\", \"desc\"] : [\"desc\", \"asc\"];\n/**\n * @hidden\n */\n\n\nconst isRootLevel = ({\n  parent\n}) => !isTruthy(parent);\n\nconst ofColumnType = ({\n  draggable\n}) => ['column', 'columnGroup'].indexOf(draggable.context.type) >= 0;\n\nconst notSameElement = ({\n  draggable,\n  target\n}) => draggable.element.nativeElement !== target.element.nativeElement;\n\nconst inSameParent = (x, y) => x.parent === y.parent || isInSpanColumn$1(y) && inSameParent(x, y.parent);\n\nconst sameParent = ({\n  draggable,\n  target\n}) => inSameParent(draggable.context.column, target.context.column);\n\nconst lastNonLocked = ({\n  draggable\n}) => !isTruthy(draggable.context.column.locked) && isRootLevel(draggable.context.column) && draggable.context.lastColumn;\n\nconst notInSpanColumn = ({\n  draggable\n}) => !isInSpanColumn$1(draggable.context.column);\n\nconst reorderable = ({\n  draggable\n}) => draggable.context.column.reorderable;\n\nconst lockable = ({\n  draggable,\n  target\n}) => draggable.context.column.lockable !== false || draggable.context.column.isLocked === target.context.column.isLocked;\n\nconst rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);\nconst modifierKeys = ['alt', 'ctrl', 'shift', 'meta'];\n/**\n * @hidden\n */\n\nlet HeaderComponent = /*#__PURE__*/(() => {\n  class HeaderComponent {\n    constructor(popupService, hint, cue, reorderService, idService, sortService, localization, columnInfoService, cd) {\n      this.popupService = popupService;\n      this.hint = hint;\n      this.cue = cue;\n      this.reorderService = reorderService;\n      this.idService = idService;\n      this.sortService = sortService;\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.cd = cd;\n      this.columns = [];\n      this.groups = [];\n      this.sort = new Array();\n      this.sortable = false;\n      this.groupable = false;\n      this.lockedColumnsCount = 0;\n      this.resizable = false;\n      this.reorderable = false;\n      this.columnMenu = false;\n      this.totalColumnsCount = 0;\n      this.sortedFields = {};\n      this.dropTargets = new QueryList();\n      this.subscription = new Subscription();\n    }\n\n    get headerClass() {\n      return !this.scrollable;\n    }\n\n    get sortableLabel() {\n      return this.localization.get('sortable');\n    }\n\n    get columnMenuSettings() {\n      return this.columnMenu;\n    } // Number of unlocked columns in the next table, if any\n\n\n    get unlockedColumnsCount() {\n      return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;\n    }\n\n    sortColumn(descriptor) {\n      this.sortService.sort(descriptor);\n    }\n\n    getColumnComponent(column) {\n      return column;\n    }\n\n    onSortClick(column, event, link) {\n      const target = event.target;\n\n      if (column.headerTemplateRef && target !== link) {\n        const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));\n\n        if (hasFocusableParent) {\n          // Do not sort when clicking focusable template elements.\n          return;\n        }\n      }\n\n      const modifier = this.matchModifier(event);\n      const toggledColumn = this.toggleSort(column, modifier);\n      this.sortColumn(toggledColumn);\n    }\n\n    onHeaderKeydown(column, args) {\n      if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {\n        args.preventDefault();\n        args.stopImmediatePropagation();\n        const filterMenu = this.filterMenus.find(fm => fm.column === column);\n        filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);\n      }\n\n      if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {\n        args.preventDefault();\n        args.stopImmediatePropagation();\n        const columnMenu = this.columnMenus.find(cm => cm.column === column);\n        columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);\n      }\n\n      if (!this.sortable || args.defaultPrevented || column.sortable === false) {\n        return;\n      }\n\n      if (args.keyCode === Keys.Enter && isPresent(column.field)) {\n        const modifier = this.matchModifier(args);\n        this.sortService.sort(this.toggleSort(column, modifier));\n      }\n    }\n\n    showSortNumbering(column) {\n      const {\n        showIndexes\n      } = normalize(this.sortable);\n      return showIndexes && this.sort && this.sort.filter(({\n        dir\n      }) => isPresent(dir)).length > 1 && this.sortOrder(column.field) > 0;\n    }\n\n    sortOrder(field) {\n      return this.sort.filter(({\n        dir\n      }) => isPresent(dir)).findIndex(x => x.field === field) + 1;\n    }\n\n    sortIcon(field) {\n      const state = this.sortDescriptor(field);\n      return {\n        'k-icon': isPresent(state.dir),\n        'k-i-sort-desc-sm': state.dir === \"desc\",\n        'k-i-sort-asc-sm': state.dir === \"asc\"\n      };\n    }\n\n    sortState(column) {\n      if (!this.isSortable(column)) {\n        return;\n      }\n\n      const state = this.sortDescriptor(column.field);\n\n      if (state.dir === 'asc') {\n        return 'ascending';\n      }\n\n      if (state.dir === 'desc') {\n        return 'descending';\n      }\n    }\n\n    sortStatus(column) {\n      if (!this.sortedFields[column.field] || !this.isSortable(column)) {\n        return;\n      }\n\n      let msg = 'sortedDefault';\n      const state = this.sortDescriptor(column.field);\n\n      if (state.dir === 'asc') {\n        msg = 'sortedAscending';\n      } else if (state.dir === 'desc') {\n        msg = 'sortedDescending';\n      }\n\n      return this.localization.get(msg);\n    }\n    /**\n     *\n     * @param column\n     * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.\n     * @returns - SortDescriptor[]\n     */\n\n\n    toggleSort(column, modifier = true) {\n      const {\n        allowUnsort,\n        mode,\n        initialDirection\n      } = normalize(this.sortable, column.sortable);\n      const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);\n\n      if (mode === 'single' || !modifier) {\n        return [descriptor];\n      }\n\n      return [...this.sort.filter(desc => desc.field !== column.field), descriptor];\n    }\n    /**\n     *\n     * Determines whether the modifier key (if any) passed\n     * with a click/keyboard event matches the user-defined multiSortKey.\n     */\n\n\n    matchModifier(event) {\n      const {\n        multiSortKey\n      } = normalize(this.sortable);\n\n      if (multiSortKey === 'none') {\n        return modifierKeys.every(key => !event[`${key}Key`]);\n      }\n\n      return multiSortKey === 'ctrl' ? event.ctrlKey || event.metaKey : event[`${multiSortKey}Key`];\n    }\n\n    ngAfterViewInit() {\n      this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));\n    }\n\n    ngDoCheck() {\n      this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));\n    }\n\n    ngOnChanges(changes) {\n      const sortChange = changes.sort;\n\n      if (sortChange && !sortChange.isFirstChange()) {\n        sortChange.currentValue.forEach(change => {\n          this.sortedFields[change.field] = true;\n        });\n      }\n    }\n\n    ngOnInit() {\n      this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));\n    }\n\n    ngOnDestroy() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n\n      if (this.popupService) {\n        this.popupService.destroy();\n      }\n\n      this.subscription.unsubscribe();\n    }\n\n    selectAllCheckboxId() {\n      return this.idService.selectAllCheckboxId();\n    }\n\n    get selectAllCheckboxLabel() {\n      return this.localization.get('selectAllCheckboxLabel');\n    }\n\n    isFirstOnRow(column, index) {\n      const isTailing = c => c && (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));\n\n      return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);\n    }\n\n    logicalColumnIndex(column) {\n      const index = column.leafIndex;\n\n      if (isPresent(index)) {\n        return index + (isPresent(this.detailTemplate) ? 1 : 0);\n      }\n\n      return -1;\n    }\n\n    get showFilterMenu() {\n      return !this.columnMenu && hasFilterMenu(this.filterable);\n    }\n\n    get showFilterRow() {\n      return hasFilterRow(this.filterable);\n    }\n\n    showColumnMenu(column) {\n      return this.columnMenu && column.columnMenu && (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));\n    }\n\n    isFilterable(column) {\n      return !isNullOrEmptyString(column.field) && column.filterable === true;\n    }\n\n    canDrop(draggable, target) {\n      return this.reorderable && rules({\n        draggable,\n        target\n      });\n    }\n\n    shouldActivate(column) {\n      const canReorder = this.reorderable && column.reorderable;\n\n      if (!canReorder && !isColumnComponent(column)) {\n        return false;\n      }\n\n      const groupable = this.groupable && isColumnComponent(column) && column.groupable !== false;\n      return groupable || canReorder;\n    }\n\n    isSortable(column) {\n      return !isNullOrEmptyString(column.field) && isTruthy(this.sortable) && isTruthy(column.sortable);\n    }\n\n    isCheckboxColumn(column) {\n      return isCheckboxColumn(column) && !column.templateRef;\n    }\n\n    trackByIndex(index, _item) {\n      return index;\n    }\n\n    addStickyStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return Object.assign(Object.assign({}, column.style), stickyStyles);\n    }\n\n    toggleDirection(field, allowUnsort, initialDirection) {\n      const descriptor = this.sortDescriptor(field);\n      const [first, second] = directions(initialDirection);\n      let dir = first;\n\n      if (descriptor.dir === first) {\n        dir = second;\n      } else if (descriptor.dir === second && allowUnsort) {\n        dir = undefined;\n      }\n\n      return {\n        dir,\n        field\n      };\n    }\n\n    columnsForLevel(level) {\n      const columns = this.columns ? this.columns.filter(column => column.level === level) : [];\n      return sortColumns(columnsToRender(columns));\n    }\n\n    isColumnGroupComponent(column) {\n      return isColumnGroupComponent(column);\n    }\n\n    get columnLevels() {\n      return new Array((this.totalColumnLevels || 0) + 1);\n    }\n\n    sortDescriptor(field) {\n      return this.sort.find(item => item.field === field) || {\n        field\n      };\n    }\n\n    get leafColumns() {\n      return this._leafColumns;\n    }\n\n    attachTargets() {\n      if (this.targetSubscription) {\n        this.targetSubscription.unsubscribe();\n      }\n\n      this.targetSubscription = new Subscription();\n      const enterStream = merge(...this.dropTargets.map(target => target.enter));\n      const leaveStream = merge(...this.dropTargets.map(target => target.leave));\n      const dropStream = merge(...this.dropTargets.map(target => target.drop));\n      this.targetSubscription.add(enterStream.pipe(tap(({\n        target,\n        draggable\n      }) => {\n        if (draggable.context.type === 'groupIndicator') {\n          return;\n        }\n\n        const targetLocked = isTruthy(target.context.column.isLocked);\n        const draggableLocked = isTruthy(draggable.context.column.isLocked);\n\n        if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {\n          this.hint.toggleLock(targetLocked);\n        }\n      }), filter(({\n        draggable,\n        target\n      }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map(e => mergeObjects(e, {\n        before: this.calculateBefore(e),\n        changeContainer: e.changeContainer\n      })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap(args => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));\n    }\n\n    normalizeTarget(e) {\n      let target = e.target;\n      const parent = target.context.column.parent;\n\n      if (parent && parent.isSpanColumn) {\n        const arr = this.dropTargets.toArray();\n        const firstSpan = arr.find(t => t.context.column.parent === parent);\n        const index = arr.indexOf(firstSpan);\n        const adjust = e.before ? 0 : parent.childColumns.length - 1;\n        target = arr[index + adjust];\n      }\n\n      return mergeObjects(e, {\n        target\n      });\n    }\n\n    trackMove(leaveStream, dropStream, e) {\n      const column = e.target.context.column;\n      const levelColumns = this.columnsForLevel(column.level);\n      const index = levelColumns.indexOf(column);\n      const isFirst = column.locked ? index === levelColumns.length - 1 : index === 0;\n      const changed = e.draggable.context.column.isLocked !== column.isLocked;\n\n      if (changed && isFirst) {\n        return e.draggable.drag.pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({\n          mouseEvent\n        }) => mergeObjects({\n          changeContainer: true\n        }, e, {\n          mouseEvent\n        })));\n      }\n\n      return of(mergeObjects({\n        changeContainer: changed\n      }, e));\n    }\n\n    calculateBefore({\n      draggable,\n      target,\n      mouseEvent,\n      changeContainer = false\n    }) {\n      const targetElement = target.element.nativeElement;\n      let before = false;\n\n      if (changeContainer) {\n        const {\n          left\n        } = offset(targetElement);\n        const halfWidth = targetElement.offsetWidth / 2;\n        const middle = left + halfWidth;\n        before = middle > mouseEvent.pageX;\n\n        if (this.localization.rtl) {\n          before = !before;\n        }\n      } else {\n        before = isTargetBefore(draggable.element.nativeElement, targetElement);\n      }\n\n      return before;\n    }\n\n    enter({\n      target,\n      before\n    }) {\n      this.hint.enable();\n\n      if (this.localization.rtl) {\n        before = !before;\n      }\n\n      this.cue.position(position(target.element.nativeElement, before));\n    }\n\n    leave() {\n      this.hint.disable();\n      this.cue.hide();\n    }\n\n    drop({\n      draggable,\n      target,\n      before,\n      changeContainer\n    }) {\n      this.reorderService.reorder({\n        before,\n        changeContainer,\n        source: draggable.context.column,\n        target: target.context.column\n      });\n    }\n\n  }\n\n  HeaderComponent.ɵfac = function HeaderComponent_Factory(t) {\n    return new (t || HeaderComponent)(i0.ɵɵdirectiveInject(SinglePopupService), i0.ɵɵdirectiveInject(DragHintService), i0.ɵɵdirectiveInject(DropCueService), i0.ɵɵdirectiveInject(ColumnReorderService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  HeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderComponent,\n    selectors: [[\"\", \"kendoGridHeader\", \"\"]],\n    viewQuery: function HeaderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DropTargetDirective, 5);\n        i0.ɵɵviewQuery(FilterMenuComponent, 5);\n        i0.ɵɵviewQuery(ColumnMenuComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropTargets = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterMenus = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenus = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-header\", ctx.headerClass);\n      }\n    },\n    inputs: {\n      totalColumnLevels: \"totalColumnLevels\",\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      scrollable: \"scrollable\",\n      filterable: \"filterable\",\n      sort: \"sort\",\n      filter: \"filter\",\n      sortable: \"sortable\",\n      groupable: \"groupable\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      columnMenu: \"columnMenu\",\n      columnMenuTemplate: \"columnMenuTemplate\",\n      totalColumnsCount: \"totalColumnsCount\",\n      tabIndex: \"tabIndex\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c30,\n    decls: 3,\n    vars: 2,\n    consts: [[\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngFor\", \"ngForOf\"], [\"kendoGridFilterRow\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"filter\", \"groups\", \"detailTemplate\", \"lockedColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"class\", \"k-group-cell k-header\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-hierarchy-cell k-header\", \"role\", \"presentation\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"role\", \"presentation\", 1, \"k-group-cell\", \"k-header\"], [\"role\", \"presentation\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 1, \"k-hierarchy-cell\", \"k-header\", 3, \"logicalRowIndex\", \"logicalColIndex\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnheader\", \"aria-selected\", \"false\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", \"class\", \"k-header\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"headerLabelText\", \"colSpan\", \"rowSpan\", \"enableDrag\", \"context\", \"k-filterable\", \"k-first\", \"k-grid-header-sticky\", \"ngClass\", \"ngStyle\", \"keydown\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", \"class\", \"k-header\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"rowSpan\", \"colSpan\", \"headerLabelText\", \"enableDrag\", \"context\", \"k-first\", \"k-filterable\", \"k-grid-content-sticky\", \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnheader\", \"aria-selected\", \"false\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", 1, \"k-header\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"headerLabelText\", \"colSpan\", \"rowSpan\", \"enableDrag\", \"context\", \"ngClass\", \"ngStyle\", \"keydown\"], [4, \"ngIf\"], [\"kendoGridColumnHandle\", \"\", \"kendoDraggable\", \"\", \"class\", \"k-column-resizer\", 3, \"column\", \"columns\", 4, \"ngIf\"], [3, \"column\", \"filter\", \"tabIndex\", 4, \"ngIf\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", \"sort\", \"filter\", \"sortable\", \"tabIndex\", 4, \"ngIf\"], [3, \"templateContext\"], [3, \"column\", \"filter\", \"tabIndex\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", \"sort\", \"filter\", \"sortable\", \"tabIndex\"], [1, \"k-cell-inner\"], [1, \"k-link\", 3, \"click\"], [\"link\", \"\"], [\"role\", \"note\", 3, \"ngClass\"], [\"class\", \"k-sort-order\", 4, \"ngIf\"], [\"role\", \"status\", 1, \"k-sort-status\", 2, \"position\", \"absolute\", \"left\", \"-10000px\", 3, \"innerHtml\"], [1, \"k-column-title\"], [1, \"k-sort-order\"], [\"kendoGridSelectAllCheckbox\", \"\", \"kendoGridFocusable\", \"\", 1, \"k-checkbox\", \"k-checkbox-md\", \"k-rounded-md\"], [\"kendoGridColumnHandle\", \"\", \"kendoDraggable\", \"\", 1, \"k-column-resizer\", 3, \"column\", \"columns\"], [\"kendoGridLogicalCell\", \"\", \"kendoDropTarget\", \"\", \"kendoDraggable\", \"\", \"kendoDraggableColumn\", \"\", 1, \"k-header\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"rowSpan\", \"colSpan\", \"headerLabelText\", \"enableDrag\", \"context\", \"ngClass\", \"ngStyle\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\", 4, \"ngIf\"], [3, \"standalone\", \"settings\", \"column\", \"columnMenuTemplate\"], [\"kendoGridFilterRow\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"filter\", \"groups\", \"detailTemplate\", \"lockedColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"]],\n    template: function HeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵtemplate(1, HeaderComponent_tr_1_Template, 4, 8, \"tr\", 0);\n        i0.ɵɵtemplate(2, HeaderComponent_tr_2_Template, 1, 9, \"tr\", 1);\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnLevels);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showFilterRow);\n      }\n    },\n    directives: [FilterMenuComponent, ColumnMenuComponent, FilterRowComponent, i4.NgForOf, LogicalRowDirective, i4.NgIf, LogicalCellDirective, DropTargetDirective, i1$1.DraggableDirective, DraggableColumnDirective, i4.NgClass, i4.NgStyle, TemplateContextDirective, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective],\n    encapsulation: 2\n  });\n  return HeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst update = (arr, idx, value) => [...arr.slice(0, idx + 1), ...arr.slice(idx + 1).map(x => x + value)];\n/**\n * @hidden\n */\n\n\nclass RowHeightService {\n  constructor(total = 0, rowHeight, detailRowHeight) {\n    this.total = total;\n    this.rowHeight = rowHeight;\n    this.detailRowHeight = detailRowHeight;\n    this.offsets = [];\n    this.heights = [];\n    let agg = 0;\n\n    for (let idx = 0; idx < total; idx++) {\n      this.offsets.push(agg);\n      agg += rowHeight;\n      this.heights.push(rowHeight);\n    }\n  }\n\n  height(rowIndex) {\n    return this.heights[rowIndex];\n  }\n\n  expandDetail(rowIndex) {\n    if (this.height(rowIndex) === this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight);\n    }\n  }\n\n  collapseDetail(rowIndex) {\n    if (this.height(rowIndex) > this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n    }\n  }\n\n  isExpanded(rowIndex) {\n    return this.height(rowIndex) > this.rowHeight;\n  }\n\n  index(position) {\n    if (position < 0) {\n      return undefined;\n    }\n\n    const result = this.offsets.reduce((prev, current, idx) => {\n      if (prev !== undefined) {\n        return prev;\n      } else if (current === position) {\n        return idx;\n      } else if (current > position) {\n        return idx - 1;\n      }\n\n      return undefined;\n    }, undefined);\n    return result === undefined ? this.total - 1 : result;\n  }\n\n  offset(rowIndex) {\n    return this.offsets[rowIndex];\n  }\n\n  totalHeight() {\n    return this.heights.reduce((prev, curr) => prev + curr, 0);\n  }\n\n  updateRowHeight(rowIndex, value) {\n    if (this.total > 0) {\n      this.heights[rowIndex] += value;\n      this.offsets = update(this.offsets, rowIndex, value);\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ScrollAction {\n  constructor(offset) {\n    this.offset = offset;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass PageAction {\n  constructor(skip, take) {\n    this.skip = skip;\n    this.take = take;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ScrollBottomAction {}\n\nconst SCROLL_BOTTOM_THRESHOLD = 2;\n/**\n * @hidden\n */\n\nclass ScrollerService {\n  constructor(scrollObservable) {\n    this.scrollObservable = scrollObservable;\n    this.firstLoaded = 0;\n  }\n\n  create(rowHeightService, skip, take, total) {\n    this.rowHeightService = rowHeightService;\n    this.firstLoaded = skip;\n    this.lastLoaded = skip + take;\n    this.take = take;\n    this.total = total;\n    this.lastScrollTop = 0;\n    const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));\n    this.subscription = Observable.create(observer => {\n      this.unsubscribe();\n      this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n    }).subscribe(x => subject.next(x));\n    return subject;\n  }\n\n  destroy() {\n    this.unsubscribe();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  onScroll({\n    scrollTop,\n    offsetHeight,\n    scrollHeight,\n    clientHeight\n  }, observer) {\n    if (this.lastScrollTop === scrollTop) {\n      return;\n    }\n\n    const up = this.lastScrollTop >= scrollTop;\n    this.lastScrollTop = scrollTop;\n    let firstItemIndex = this.rowHeightService.index(scrollTop);\n    let firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n    const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);\n\n    if (!up) {\n      if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n        const overflow = firstItemIndex + this.take - this.total;\n\n        if (overflow > 0) {\n          firstItemIndex = firstItemIndex - overflow;\n          firstItemOffset = this.rowHeightService.offset(firstItemIndex);\n        }\n\n        this.firstLoaded = firstItemIndex;\n        observer.next(new ScrollAction(firstItemOffset));\n        let nextTake = this.firstLoaded + this.take;\n        this.lastLoaded = Math.min(nextTake, this.total);\n        nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;\n        observer.next(new PageAction(this.firstLoaded, this.take));\n      } else {\n        const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;\n\n        if (atBottom) {\n          observer.next(new ScrollBottomAction());\n        }\n      }\n    }\n\n    if (up && firstItemIndex < this.firstLoaded) {\n      const nonVisibleBuffer = Math.floor(this.take * 0.3);\n      this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);\n      observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded, this.take));\n    }\n  }\n\n  unsubscribe() {\n    if (this.scrollSubscription) {\n      this.scrollSubscription.unsubscribe();\n      this.scrollSubscription = undefined;\n    }\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';\n/**\n * @hidden\n */\n\nconst NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';\n/**\n * @hidden\n */\n\nconst IGNORE_TARGET_CLASSSES = 'k-icon';\n/**\n * @hidden\n */\n\nconst IGNORE_CONTAINER_CLASSES = 'k-grid k-grid-ignore-click';\n/**\n * Represents the command columns of the Grid. You have to define the content of the\n * column inside an `<ng-template>` tag. The template context is set to the current\n * data item. For more information and examples on using the passed fields\n * and the command directives, refer to the article on\n * [editing the Grid in Angular Reactive Forms]({% slug editing_reactive_forms_grid %}).\n *\n * The following additional fields are passed:\n * - `columnIndex`&mdash;The current column index.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex`is `-1`.\n * - `dataItem`&mdash;The current data item.\n * - `column`&mdash;The current column instance.\n * - `isNew`&mdash;The state of the current item.\n *\n * Usually, the template contains CRUD command directives such as:\n * - [EditCommandDirective]({% slug api_grid_editcommanddirective %})\n * - [RemoveCommandDirective]({% slug api_grid_removecommanddirective %})\n * - [CancelCommandDirective]({% slug api_grid_cancelcommanddirective %})\n * - [SaveCommandDirective]({% slug api_grid_savecommanddirective %})\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"UnitPrice\" title=\"Unit Price\" [width]=\"230\">\n *          </kendo-grid-column>\n *          <kendo-grid-command-column title=\"command\" [width]=\"220\">\n *               <ng-template kendoGridCellTemplate>\n *                   <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *                   <button kendoGridRemoveCommand>Remove</button>\n *               </ng-template>\n *           </kendo-grid-command-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\n\nlet CommandColumnComponent = /*#__PURE__*/(() => {\n  class CommandColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      this.parent = parent;\n    }\n\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n\n  }\n\n  CommandColumnComponent.ɵfac = function CommandColumnComponent_Factory(t) {\n    return new (t || CommandColumnComponent)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  };\n\n  CommandColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CommandColumnComponent,\n    selectors: [[\"kendo-grid-command-column\"]],\n    contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => CommandColumnComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CommandColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CommandColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the row-selection checkbox of the Grid. The directive expects the\n * index of the current row as an input parameter. Inside the\n * [CheckboxColumnComponent]({% slug api_grid_checkboxcolumncomponent %}), apply the\n * directive to an `input` element. When the user clicks the checkbox that is associated\n * with the directive, a [selectionChange]({% slug api_grid_gridcomponent %}#toc-selectionChange)\n * event is triggered.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\" [selectable]=\"{enabled: true, checkboxOnly: true}\">\n *          <kendo-grid-checkbox-column title=\"Custom checkbox\">\n *            <ng-template kendoGridCellTemplate let-idx=\"rowIndex\">\n *              Select row <input [kendoGridSelectionCheckbox]=\"idx\" />\n *            </ng-template>\n *          </kendo-grid-checkbox-column>\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\n\n\nlet SelectionCheckboxDirective = /*#__PURE__*/(() => {\n  class SelectionCheckboxDirective {\n    constructor(selectionService, el, renderer, ngZone) {\n      this.selectionService = selectionService;\n      this.el = el;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.type = 'checkbox';\n      this.ngZone.runOutsideAngular(() => {\n        this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));\n        this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, 'keydown', this.onKeyDown.bind(this));\n      });\n    }\n\n    ngAfterContentChecked() {\n      this.setCheckedState();\n    }\n\n    ngOnDestroy() {\n      if (this.destroyClick) {\n        this.destroyClick();\n      }\n\n      if (this.destroyKeyDown) {\n        this.destroyKeyDown();\n      }\n    }\n\n    onClick() {\n      if (this.selectionService.options.enabled) {\n        this.ngZone.run(() => {\n          const ev = this.selectionService.toggleByIndex(this.itemIndex);\n          ev.ctrlKey = true;\n          ev.shiftKey = false;\n          this.selectionService.changes.emit(ev);\n        });\n      }\n    }\n\n    onKeyDown(e) {\n      if (e.keyCode === Keys.Enter) {\n        this.onClick();\n      }\n    }\n    /*\n     * @hidden\n     */\n\n\n    setCheckedState() {\n      this.renderer.setProperty(this.el.nativeElement, 'checked', this.selectionService.isSelected(this.itemIndex));\n    }\n\n  }\n\n  SelectionCheckboxDirective.ɵfac = function SelectionCheckboxDirective_Factory(t) {\n    return new (t || SelectionCheckboxDirective)(i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  SelectionCheckboxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectionCheckboxDirective,\n    selectors: [[\"\", \"kendoGridSelectionCheckbox\", \"\"]],\n    hostVars: 1,\n    hostBindings: function SelectionCheckboxDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.type);\n      }\n    },\n    inputs: {\n      itemIndex: [\"kendoGridSelectionCheckbox\", \"itemIndex\"]\n    }\n  });\n  return SelectionCheckboxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FORMAT_REGEX = /\\{\\d+:?/;\n/**\n * @hidden\n */\n\nlet FieldAccessorPipe = /*#__PURE__*/(() => {\n  class FieldAccessorPipe {\n    constructor(intlService) {\n      this.intlService = intlService;\n    }\n\n    transform(dataItem, fieldName, format) {\n      if (!isNullOrEmptyString(fieldName)) {\n        const value = getter(fieldName)(dataItem);\n\n        if (!isNullOrEmptyString(format)) {\n          return this.formatValue(format, value);\n        }\n\n        return value;\n      }\n\n      return dataItem;\n    }\n\n    formatValue(format, value) {\n      const intl = this.intlService;\n\n      if (isString(format) && format.match(FORMAT_REGEX)) {\n        return intl.format(format, value);\n      }\n\n      return intl.toString(value, format);\n    }\n\n  }\n\n  FieldAccessorPipe.ɵfac = function FieldAccessorPipe_Factory(t) {\n    return new (t || FieldAccessorPipe)(i0.ɵɵdirectiveInject(i1$5.IntlService, 16));\n  };\n\n  FieldAccessorPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"valueOf\",\n    type: FieldAccessorPipe,\n    pure: false\n  });\n  return FieldAccessorPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet CellComponent = /*#__PURE__*/(() => {\n  class CellComponent {\n    constructor(editService, idService, localizationService, cellContext) {\n      this.editService = editService;\n      this.idService = idService;\n      this.localizationService = localizationService;\n      this.cellContext = cellContext;\n      this.isNew = false;\n      this.isLoading = false;\n      this.isVirtual = false;\n      this._templateContext = {};\n      this._editTemplateContext = {};\n    }\n\n    get commandCellClass() {\n      return this.isCommand(this.column);\n    }\n\n    set rowIndex(index) {\n      this._rowIndex = index;\n      this.updateCellContext();\n    }\n\n    get rowIndex() {\n      return this._rowIndex;\n    }\n\n    get isEdited() {\n      if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {\n        return false;\n      }\n\n      const editContext = this.editService.columnContext(this.rowIndex, this.column);\n      return this.isFieldEditable(editContext, this.column);\n    }\n\n    get showLoading() {\n      return this.isVirtual && this.isLoading;\n    }\n\n    get formGroup() {\n      return this.editService.context(this.rowIndex).group;\n    }\n\n    get templateContext() {\n      return this._templateContext;\n    }\n\n    get editTemplateContext() {\n      this._editTemplateContext.$implicit = this.formGroup;\n      this._editTemplateContext.isNew = this.isNew;\n      this._editTemplateContext.column = this.column;\n      this._editTemplateContext.dataItem = this.dataItem;\n      this._editTemplateContext.formGroup = this.formGroup;\n      this._editTemplateContext.rowIndex = this.rowIndex;\n      return this._editTemplateContext;\n    }\n\n    get format() {\n      if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {\n        return extractFormat(this.column.format);\n      }\n\n      return undefined;\n    }\n\n    get isBoundColumn() {\n      return this.column.field && !this.column.templateRef;\n    }\n\n    get isCheckboxColumn() {\n      return isCheckboxColumn(this.column) && !this.column.templateRef;\n    }\n\n    get selectionCheckboxId() {\n      return this.idService.selectionCheckboxId(this.rowIndex);\n    }\n\n    get selectionCheckboxLabel() {\n      return this.localizationService.get('selectionCheckboxLabel');\n    }\n\n    get isSpanColumn() {\n      return isSpanColumn(this.column) && !this.column.templateRef;\n    }\n\n    get childColumns() {\n      return columnsToRender([this.column]);\n    }\n\n    get isColumnEditable() {\n      if (!this.column || this.isCommand(this.column)) {\n        return false;\n      }\n\n      return this.column.editable !== false;\n    }\n\n    ngDoCheck() {\n      this.updateCellContext();\n    }\n\n    ngOnChanges(_changes) {\n      this.updateTemplateContext();\n    }\n\n    ngAfterContentChecked() {\n      this.updateTemplateContext();\n    }\n\n    isCommand(column) {\n      return column instanceof CommandColumnComponent;\n    }\n\n    isFieldEditable(editContext, column) {\n      if (!isPresent(editContext)) {\n        return false;\n      }\n\n      if (isPresent(column.editTemplate)) {\n        return true;\n      }\n\n      return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));\n    }\n\n    updateCellContext() {\n      if (this.cellContext) {\n        this.cellContext.rowIndex = this._rowIndex;\n      }\n    }\n\n    updateTemplateContext() {\n      if (!this.column.templateRef) {\n        return;\n      }\n\n      const context = this._templateContext;\n      context.isNew = this.isNew;\n      context.column = this.column;\n      context.dataItem = this.dataItem;\n      context.rowIndex = this.rowIndex;\n      context.columnIndex = this.columnIndex;\n      context.$implicit = this.dataItem;\n    }\n\n  }\n\n  CellComponent.ɵfac = function CellComponent_Factory(t) {\n    return new (t || CellComponent)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(IdService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(CELL_CONTEXT, 8));\n  };\n\n  CellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CellComponent,\n    selectors: [[\"\", \"kendoGridCell\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CellComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-command-cell\", ctx.commandCellClass);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      columnIndex: \"columnIndex\",\n      isNew: \"isNew\",\n      isLoading: \"isLoading\",\n      isVirtual: \"isVirtual\",\n      loadingTemplate: \"loadingTemplate\",\n      rowIndex: \"rowIndex\",\n      dataItem: \"dataItem\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c34,\n    decls: 3,\n    vars: 3,\n    consts: [[3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngIf\", \"ngIfElse\"], [\"loading\", \"\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-checkbox\", \"k-checkbox-md\", \"k-rounded-md\", 3, \"kendoGridSelectionCheckbox\"], [\"class\", \"k-skeleton-text k-skeleton\", 4, \"ngIf\"], [1, \"k-skeleton-text\", \"k-skeleton\"], [3, \"ngSwitch\", 4, \"ngIf\"], [\"kendoGridFocusable\", \"\", 3, \"format\", \"formControl\", 4, \"ngSwitchCase\"], [\"type\", \"checkbox\", \"class\", \"k-checkbox k-checkbox-md k-rounded-md\", \"kendoGridFocusable\", \"\", 3, \"formControl\", 4, \"ngSwitchCase\"], [\"type\", \"text\", \"class\", \"k-textbox k-input k-rounded-md\", \"kendoGridFocusable\", \"\", 3, \"formControl\", 4, \"ngSwitchDefault\"], [\"kendoGridFocusable\", \"\", 3, \"format\", \"formControl\"], [\"type\", \"checkbox\", \"kendoGridFocusable\", \"\", 1, \"k-checkbox\", \"k-checkbox-md\", \"k-rounded-md\", 3, \"formControl\"], [\"type\", \"text\", \"kendoGridFocusable\", \"\", 1, \"k-textbox\", \"k-input\", \"k-rounded-md\", 3, \"formControl\"]],\n    template: function CellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵtemplate(1, CellComponent_ng_container_1_Template, 4, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, CellComponent_ng_container_2_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngSwitch\", ctx.isEdited);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n      }\n    },\n    directives: [i4$1.NumericTextBoxComponent, i4$3.DatePickerComponent, i4.NgSwitch, i4.NgSwitchCase, i4.NgIf, i4.NgTemplateOutlet, i4.NgForOf, FocusableDirective, SelectionCheckboxDirective, i4$2.NgControlStatus, i4$2.FormControlDirective, i4$2.CheckboxControlValueAccessor, i4.NgSwitchDefault, i4$2.DefaultValueAccessor],\n    pipes: [FieldAccessorPipe],\n    encapsulation: 2\n  });\n  return CellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet GroupHeaderComponent = /*#__PURE__*/(() => {\n  class GroupHeaderComponent {\n    constructor(groupsService, groupInfoService, localization) {\n      this.groupsService = groupsService;\n      this.groupInfoService = groupInfoService;\n      this.localization = localization;\n      this.skipGroupDecoration = false;\n      this.hasDetails = false;\n      this.totalColumnsCount = 0;\n      this.groups = [];\n      this.isExpanded = false;\n    }\n\n    get groupItemClass() {\n      return true;\n    }\n\n    ngDoCheck() {\n      const groupArgs = {\n        group: this.item.data,\n        groupIndex: this.item.index,\n        parentGroup: getGroupRowArgs(this.item.parentGroup)\n      };\n      this.isExpanded = this.groupsService.isExpanded(groupArgs);\n    }\n\n    prefixGroupCell(item) {\n      return new Array(item.level);\n    }\n\n    toggleGroup(item) {\n      this.groupsService.toggleRow(item);\n      return false;\n    }\n\n    groupSpan(item) {\n      const groupCount = (this.groups || []).length;\n      const detailOffset = this.hasDetails ? 1 : 0;\n\n      if (this.hasGroupHeaderColumn) {\n        return groupCount + 1 + detailOffset - item.level;\n      }\n\n      let columnCount = columnsSpan(this.columns);\n\n      if (this.skipGroupDecoration) {\n        return columnCount;\n      }\n\n      return groupCount + columnCount + detailOffset - item.level;\n    }\n\n    logicalColSpan() {\n      return this.skipGroupDecoration ? 1 : this.totalColumnsCount;\n    }\n\n    ariaRole() {\n      if (this.skipGroupDecoration) {\n        return 'presentation';\n      }\n\n      return 'gridcell';\n    }\n\n    formatForGroup(item) {\n      return this.groupInfoService.formatForGroup(item);\n    }\n\n    groupTitle(item) {\n      return this.groupInfoService.groupTitle(item);\n    }\n\n    groupHeaderTemplate(item) {\n      return this.groupInfoService.groupHeaderTemplate(item);\n    }\n\n    get groupButtonTitle() {\n      const messageKey = this.isExpanded ? 'groupCollapse' : 'groupExpand';\n      return this.localization.get(messageKey);\n    }\n\n  }\n\n  GroupHeaderComponent.ɵfac = function GroupHeaderComponent_Factory(t) {\n    return new (t || GroupHeaderComponent)(i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  GroupHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GroupHeaderComponent,\n    selectors: [[\"\", \"kendoGridGroupHeader\", \"\"]],\n    hostVars: 2,\n    hostBindings: function GroupHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grouping-row\", ctx.groupItemClass);\n      }\n    },\n    inputs: {\n      rowIndex: \"rowIndex\",\n      logicalRowIndex: \"logicalRowIndex\",\n      item: \"item\",\n      skipGroupDecoration: \"skipGroupDecoration\",\n      hasDetails: \"hasDetails\",\n      totalColumnsCount: \"totalColumnsCount\",\n      hasGroupHeaderColumn: \"hasGroupHeaderColumn\",\n      groupHeaderColumns: \"groupHeaderColumns\",\n      columns: \"columns\",\n      groups: \"groups\"\n    },\n    attrs: _c36,\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\", 4, \"ngIf\"], [\"class\", \"k-group-cell\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-group-cell\"], [\"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\"], [1, \"k-reset\"], [\"href\", \"#\", \"tabindex\", \"-1\", \"role\", \"presentation\", 1, \"k-icon\", 3, \"ngClass\", \"click\"], [3, \"templateContext\"], [\"role\", \"gridcell\", \"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"gridcell\", \"aria-selected\", \"false\", \"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"logicalSlaveCell\", \"groupItem\", \"colSpan\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function GroupHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, GroupHeaderComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, GroupHeaderComponent_td_1_Template, 3, 9, \"td\", 1);\n        i0.ɵɵtemplate(2, GroupHeaderComponent_ng_container_2_Template, 2, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.skipGroupDecoration);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasGroupHeaderColumn);\n      }\n    },\n    directives: [i4.NgIf, i4.NgForOf, LogicalCellDirective, i4.NgClass, TemplateContextDirective, i4.NgTemplateOutlet],\n    pipes: [FieldAccessorPipe],\n    encapsulation: 2\n  });\n  return GroupHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst columnCellIndex = (cell, cells) => {\n  let cellIndex = 0;\n\n  for (let idx = 0; idx < cells.length; idx++) {\n    if (cells[idx] === cell) {\n      return cellIndex;\n    }\n\n    if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {\n      cellIndex++;\n    }\n  }\n};\n/**\n * @hidden\n */\n\n\nlet TableBodyComponent = /*#__PURE__*/(() => {\n  class TableBodyComponent {\n    constructor(detailsService, groupsService, changeNotification, editService, localization, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {\n      this.detailsService = detailsService;\n      this.groupsService = groupsService;\n      this.changeNotification = changeNotification;\n      this.editService = editService;\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.element = element;\n      this.domEvents = domEvents;\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.columnInfoService = columnInfoService;\n      this.navigationService = navigationService;\n      this.columns = [];\n      this.groups = [];\n      this.skip = 0;\n      this.noRecordsText = this.localization.get('noRecords');\n      this.isLocked = false;\n      this.skipGroupDecoration = false;\n      this.showGroupFooters = false;\n      this.lockedColumnsCount = 0;\n      this.totalColumnsCount = 0;\n      this.trackBy = defaultTrackBy;\n\n      this.rowClass = () => null;\n\n      this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe(args => this.cellKeydownHandler(args));\n      this.trackByWrapper = this.trackByWrapper.bind(this);\n      this.trackByColumns = this.trackByColumns.bind(this);\n    }\n\n    get newDataItem() {\n      return this.editService.newDataItem;\n    } // Number of unlocked columns in the next table, if any\n\n\n    get unlockedColumnsCount() {\n      return this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;\n    }\n\n    isAriaSelected(item, column) {\n      return this.cellSelectionService.isCellSelected(item, column) || this.isRowSelected(item) ? 'true' : 'false';\n    }\n\n    toggleRow(index, dataItem) {\n      this.detailsService.toggleRow(index, dataItem);\n      return false;\n    }\n\n    isExpanded(viewItem) {\n      return this.detailsService.isExpanded(viewItem.index, viewItem.data);\n    }\n\n    detailButtonStyles(viewItem) {\n      const expanded = this.isExpanded(viewItem);\n      return expanded ? 'k-i-minus' : 'k-i-plus';\n    }\n\n    detailButtonTitle(viewItem) {\n      const messageKey = this.isExpanded(viewItem) ? 'detailCollapse' : 'detailExpand';\n      return this.localization.get(messageKey);\n    }\n\n    isGroup(item) {\n      return item.type === 'group';\n    }\n\n    isDataItem(item) {\n      return !this.isGroup(item) && !this.isFooter(item);\n    }\n\n    isFooter(item) {\n      return item.type === 'footer';\n    }\n\n    isFooterItemInExpandedGroup(item) {\n      const footerItem = {\n        data: item.data,\n        index: item.groupIndex,\n        parentGroup: item.group.parentGroup\n      };\n      return this.isInExpandedGroup(footerItem);\n    }\n\n    isDataItemInExpandedGroup(item) {\n      const dataItem = {\n        data: item.group.data,\n        index: item.groupIndex,\n        parentGroup: item.group.parentGroup\n      };\n      return this.isInExpandedGroup(dataItem);\n    }\n\n    isInExpandedGroup(item) {\n      return this.groupsService.isInExpandedGroup(item);\n    }\n\n    isParentGroupExpanded(item) {\n      return this.groupsService.isInExpandedGroup(item.parentGroup);\n    }\n\n    isOdd(item) {\n      return item.index % 2 !== 0;\n    }\n\n    isSelectable() {\n      return this.selectable && this.selectable.enabled !== false;\n    }\n\n    isRowSelected(item) {\n      return this.selectionService.isSelected(item.index);\n    }\n\n    trackByWrapper(index, item) {\n      if (item.type === 'data') {\n        item.isEditing = this.editService.hasEdited(item.index);\n      }\n\n      return this.trackBy(index, item);\n    }\n\n    trackByColumns(index, item) {\n      return this.virtualColumns ? index : item;\n    }\n\n    ngDoCheck() {\n      if (this.hasGroupHeaderColumn) {\n        this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));\n      } else {\n        this.groupHeaderColumns = [];\n      }\n\n      if (this.isLocked) {\n        this.groupHeaderSlaveCellsCount = this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;\n      } else {\n        this.groupHeaderSlaveCellsCount = 0;\n      }\n    }\n\n    ngAfterViewChecked() {\n      if (this.rowSticky) {\n        this.applyStickyRowsStyling();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged$1('columns', changes, false)) {\n        this.changeNotification.notify();\n      }\n    }\n\n    logicalRowIndex(rowIndex) {\n      let pos = this.skip + rowIndex;\n\n      if (this.hasDetailTemplate) {\n        pos *= 2;\n      }\n\n      const absoluteRowIndex = 1 + pos;\n      const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n      const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n      const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;\n      return absoluteRowIndex + headerRowCount;\n    }\n\n    addRowLogicalIndex() {\n      return this.columnInfoService.totalLevels + 1 + (hasFilterRow(this.filterable) ? 1 : 0);\n    }\n\n    logicalColIndex(column) {\n      if (!isPresent(column.leafIndex)) {\n        return -1;\n      }\n\n      return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        const clickHandler = this.clickHandler.bind(this);\n        const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);\n        const mouseupSubscription = this.renderer.listen(this.element.nativeElement, 'mouseup', clickHandler);\n        const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);\n        const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);\n        const touchstartSubscription = this.renderer.listen(this.element.nativeElement, 'touchstart', clickHandler);\n        const touchendSubscription = this.renderer.listen(this.element.nativeElement, 'touchend', clickHandler);\n\n        this.clickSubscription = () => {\n          mousedownSubscription();\n          mouseupSubscription();\n          clickSubscription();\n          contextmenuSubscription();\n        };\n\n        this.touchSubscription = () => {\n          touchstartSubscription();\n          touchendSubscription();\n        };\n      });\n      let originalNoRecordText = this.localization.get('noRecords');\n      this.localization.changes.subscribe(() => {\n        if (this.noRecordsText === originalNoRecordText) {\n          this.noRecordsText = this.localization.get('noRecords');\n          originalNoRecordText = this.noRecordsText;\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.clickSubscription) {\n        this.clickSubscription();\n      }\n\n      if (this.touchSubscription) {\n        this.touchSubscription();\n      }\n\n      this.cellKeydownSubscription.unsubscribe();\n      clearTimeout(this.clickTimeout);\n    }\n\n    isEditingCell(index, column) {\n      return this.editService.isEditing() && this.editService.isEditedColumn(index, column);\n    }\n\n    isEditingRow(index) {\n      return this.editService.isEditing() && this.editService.hasEdited(index);\n    }\n\n    get hasGroupHeaderColumn() {\n      return this.columnsContainer.hasGroupHeaderColumn;\n    }\n\n    get columnsContainer() {\n      return this.columnInfoService.columnsContainer;\n    }\n\n    get columnsSpan() {\n      return columnsSpan(this.columns);\n    }\n\n    get allColumnsSpan() {\n      return columnsSpan(this.allColumns || this.columns);\n    }\n\n    get colSpan() {\n      return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);\n    }\n\n    get footerColumns() {\n      return this.isLocked ? this.columnsContainer.lockedColumnsToRender : this.columnsContainer.nonLockedColumnsToRender;\n    }\n\n    showGroupHeader(item) {\n      return !item.data.skipHeader;\n    }\n\n    addStickyColumnStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return Object.assign(Object.assign({}, column.style), stickyStyles);\n    }\n\n    resizeHandler() {\n      this.applyStickyRowsStyling();\n    }\n\n    get hasDetailTemplate() {\n      return isPresent(this.detailTemplate);\n    }\n\n    clickHandler(eventArg) {\n      const element = this.element.nativeElement;\n      const target = this.eventTarget(eventArg);\n      let cell, row, body, gridElement;\n      let currentTarget = target;\n\n      do {\n        cell = closest(currentTarget, matchesNodeName('td'));\n        row = closest(cell, matchesNodeName('tr'));\n        body = closest(row, matchesNodeName('tbody'));\n        currentTarget = body;\n        gridElement = closestInScope(currentTarget, matchesClasses('k-grid'), element);\n      } while (body && body !== element && !gridElement);\n\n      if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) && !hasClasses(row, NON_DATA_ROW_CLASSES) && body === element && !gridElement) {\n        this.editService.preventCellClose();\n        const focusable = target !== cell && isFocusableWithTabKey(target, false);\n\n        if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) && !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {\n          const args = this.cellClickArgs(cell, row, eventArg);\n\n          if (eventArg.type === 'mousedown' || eventArg.type === 'touchstart') {\n            this.domEvents.cellMousedown.emit(args);\n          } else if (eventArg.type === 'mouseup' || eventArg.type === 'touchend') {\n            this.domEvents.cellMouseup.emit(args);\n          } else {\n            if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {\n              if (eventArg.type === 'click') {\n                this.clickTimeout = setTimeout(() => {\n                  this.emitCellClick(args);\n                }, 0);\n              } else {\n                this.emitCellClick(args);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    emitCellClick(args) {\n      this.domEvents.cellClick.emit(Object.assign(args, {\n        isEdited: args.isEditedRow || args.isEditedColumn\n      }));\n    }\n\n    cellKeydownHandler(args) {\n      if (args.keyCode === Keys.Enter) {\n        this.clickHandler(args);\n      }\n    }\n\n    cellClickArgs(cell, row, eventArg) {\n      const index = columnCellIndex(cell, row.cells);\n      const column = this.columns.toArray()[index];\n      const columnIndex = this.lockedColumnsCount + index;\n      let rowIndex = row.getAttribute('data-kendo-grid-item-index');\n      rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;\n      const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);\n      const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);\n      const isEditedRow = this.editService.isEdited(rowIndex);\n      const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;\n      return {\n        column: column,\n        columnIndex: columnIndex,\n        dataItem: dataItem,\n        isEditedColumn: isEditedColumn,\n        isEditedRow: isEditedRow,\n        originalEvent: eventArg,\n        rowIndex: rowIndex,\n        type: type\n      };\n    }\n\n    eventTarget(args) {\n      if (args.type === 'touchend') {\n        const touch = args.changedTouches[0];\n        return document.elementFromPoint(touch.clientX, touch.clientY);\n      }\n\n      return args.target;\n    }\n\n    applyStickyRowsStyling() {\n      const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll('.k-grid-row-sticky'));\n      const length = stickyRows.length;\n\n      if (length) {\n        let accumulatedHeight = 0;\n        const stickyRowsOffsets = [];\n        stickyRows.forEach(row => {\n          const rowHeight = row.getBoundingClientRect().height;\n          stickyRowsOffsets.push({\n            accumulatedHeight,\n            rowHeight\n          });\n          accumulatedHeight += rowHeight;\n        });\n        stickyRows.forEach((row, index) => {\n          this.renderer.setStyle(row, 'top', `${stickyRowsOffsets[index].accumulatedHeight}px`);\n          this.renderer.setStyle(row, 'bottom', `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);\n        });\n      }\n    }\n\n  }\n\n  TableBodyComponent.ɵfac = function TableBodyComponent_Factory(t) {\n    return new (t || TableBodyComponent)(i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DomEventsService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(NavigationService));\n  };\n\n  TableBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TableBodyComponent,\n    selectors: [[\"\", \"kendoGridTableBody\", \"\"]],\n    inputs: {\n      columns: \"columns\",\n      allColumns: \"allColumns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      noRecordsTemplate: \"noRecordsTemplate\",\n      data: \"data\",\n      skip: \"skip\",\n      selectable: \"selectable\",\n      filterable: \"filterable\",\n      noRecordsText: \"noRecordsText\",\n      isLocked: \"isLocked\",\n      isLoading: \"isLoading\",\n      isVirtual: \"isVirtual\",\n      cellLoadingTemplate: \"cellLoadingTemplate\",\n      skipGroupDecoration: \"skipGroupDecoration\",\n      showGroupFooters: \"showGroupFooters\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      totalColumnsCount: \"totalColumnsCount\",\n      virtualColumns: \"virtualColumns\",\n      trackBy: \"trackBy\",\n      rowSticky: \"rowSticky\",\n      rowClass: \"rowClass\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c40,\n    decls: 4,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-grid-norecords\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"resize\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-grid-add-row\", \"k-grid-edit-row\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"class\", \"k-hierarchy-cell\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngIf\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", 3, \"rowIndex\", \"columnIndex\", \"isNew\", \"column\", \"dataItem\", \"k-grid-content-sticky\", \"ngClass\", \"left\", \"ngStyle\", \"logicalRowIndex\", \"logicalColIndex\", \"colSpan\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"k-group-cell\", \"role\", \"presentation\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"k-group-cell\"], [\"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 1, \"k-hierarchy-cell\", 3, \"logicalRowIndex\", \"logicalColIndex\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", 3, \"rowIndex\", \"columnIndex\", \"isNew\", \"column\", \"dataItem\", \"ngClass\", \"ngStyle\", \"logicalRowIndex\", \"logicalColIndex\", \"colSpan\"], [1, \"k-grid-norecords\"], [3, \"templateContext\"], [\"kendoGridGroupHeader\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"groups\", \"item\", \"hasDetails\", \"skipGroupDecoration\", \"hasGroupHeaderColumn\", \"groupHeaderColumns\", \"rowIndex\", \"totalColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngIf\"], [\"kendoGridLogicalRow\", \"\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"k-grid-row-sticky\", \"ngClass\", \"k-alt\", \"k-master-row\", \"k-grid-edit-row\", \"k-state-selected\", 4, \"ngIf\"], [\"class\", \"k-detail-row\", \"kendoGridLogicalRow\", \"\", 3, \"k-alt\", \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", 4, \"ngIf\"], [\"class\", \"k-group-footer\", \"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", 4, \"ngIf\"], [\"kendoGridGroupHeader\", \"\", \"kendoGridLogicalRow\", \"\", 3, \"columns\", \"groups\", \"item\", \"hasDetails\", \"skipGroupDecoration\", \"hasGroupHeaderColumn\", \"groupHeaderColumns\", \"rowIndex\", \"totalColumnsCount\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"kendoGridLogicalRow\", \"\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\", \"ngClass\"], [\"class\", \"k-hierarchy-cell\", \"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"detailExpandCell\", 4, \"ngIf\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", 3, \"rowIndex\", \"columnIndex\", \"column\", \"dataItem\", \"isLoading\", \"isVirtual\", \"loadingTemplate\", \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"colIndex\", \"colSpan\", \"k-grid-content-sticky\", \"k-touch-action-none\", \"k-touch-action-auto\", \"ngClass\", \"k-grid-edit-cell\", \"ngStyle\", \"k-state-selected\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"kendoGridLogicalCell\", \"\", \"aria-selected\", \"false\", 1, \"k-hierarchy-cell\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"detailExpandCell\"], [\"class\", \"k-icon\", \"href\", \"#\", \"tabindex\", \"-1\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"href\", \"#\", \"tabindex\", \"-1\", 1, \"k-icon\", 3, \"ngClass\", \"click\"], [\"kendoGridCell\", \"\", \"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", 3, \"rowIndex\", \"columnIndex\", \"column\", \"dataItem\", \"isLoading\", \"isVirtual\", \"loadingTemplate\", \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"colIndex\", \"colSpan\", \"ngClass\", \"ngStyle\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-detail-row\", 3, \"dataRowIndex\", \"dataItem\", \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\"], [\"class\", \"k-group-cell\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-hierarchy-cell\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"gridcell\", \"aria-selected\", \"false\", 1, \"k-detail-cell\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"dataRowIndex\", \"dataItem\", \"colIndex\", \"colSpan\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-group-cell\"], [\"kendoGridLogicalRow\", \"\", 1, \"k-group-footer\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"kendoGridLogicalCell\", \"\", 3, \"logicalRowIndex\", \"logicalColIndex\"], [3, \"resize\"]],\n    template: function TableBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TableBodyComponent_ng_container_0_Template, 5, 8, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, TableBodyComponent_tr_1_Template, 4, 3, \"tr\", 1);\n        i0.ɵɵtemplate(2, TableBodyComponent_ng_container_2_Template, 5, 4, \"ng-container\", 2);\n        i0.ɵɵtemplate(3, TableBodyComponent_kendo_resize_sensor_3_Template, 1, 0, \"kendo-resize-sensor\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.editService.hasNewItem);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", (ctx.data == null ? null : ctx.data.length) === 0 || ctx.data === null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data)(\"ngForTrackBy\", ctx.trackByWrapper);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowSticky);\n      }\n    },\n    directives: [CellComponent, GroupHeaderComponent, i1$1.ResizeSensorComponent, i4.NgIf, LogicalRowDirective, i4.NgForOf, LogicalCellDirective, i4.NgClass, i4.NgStyle, TemplateContextDirective, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return TableBodyComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst columnsToResize = ({\n  columns\n}) => Math.max(1, resizableColumns(columns).length);\n/**\n * @hidden\n */\n\n\nconst row = selector => element => element.querySelector(selector);\n/**\n * @hidden\n */\n\n\nconst headerRow = index => element => element.querySelectorAll('thead>tr')[index];\n/**\n * @hidden\n */\n\n\nconst cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];\n/**\n * @hidden\n */\n\n\nconst offsetWidth = element => element.offsetWidth;\n/**\n * @hidden\n */\n\n\nconst pipe = (...fns) => data => fns.reduce((state, fn) => state ? fn(state) : 0, data);\n/**\n * @hidden\n */\n\n\nlet TableDirective = /*#__PURE__*/(() => {\n  class TableDirective {\n    constructor(element, renderer, service, zone, cdr) {\n      this.element = element;\n      this.renderer = renderer;\n      this.service = service;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.locked = false;\n      this.firstResize = false;\n    }\n\n    get minWidth() {\n      return this.firstResize ? 0 : null;\n    }\n\n    ngOnInit() {\n      const obs = this.service.changes.pipe(filter(e => this.locked === e.locked));\n      this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap(take => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take)))).subscribe(this.resize.bind(this));\n      this.autoFitSubscription = this.service.registerTable({\n        autoFit: this.autoFitObservable.bind(this),\n        locked: this.locked\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      if (this.autoFitSubscription) {\n        this.autoFitSubscription();\n        this.autoFitSubscription = null;\n      }\n    }\n\n    initState() {\n      this.firstResize = true;\n\n      if (!this.virtualColumns || this.locked) {\n        this.originalWidth = offsetWidth(this.element.nativeElement);\n      }\n    }\n\n    resize(deltas) {\n      if (!this.virtualColumns || this.locked) {\n        const delta = deltas.reduce((sum, item) => sum + item, 0);\n        const width = this.originalWidth + delta;\n        this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');\n      }\n\n      this.cdr.detectChanges();\n    }\n\n    autoFitObservable(columnInfo) {\n      return Observable.create(observer => {\n        this.zone.runOutsideAngular(() => {\n          this.renderer.addClass(this.element.nativeElement, 'k-autofitting');\n          this.cdr.detectChanges();\n          const widths = columnInfo.map(this.measureColumn.bind(this));\n          this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');\n          observer.next(widths);\n        });\n      });\n    }\n\n    measureColumn(info) {\n      const dom = this.element.nativeElement;\n      const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);\n      let data = 0;\n\n      if (!info.isParentSpan || info.isParentSpan && info.isLastInSpan) {\n        data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);\n      }\n\n      const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);\n      return Math.max(header, data, footer);\n    }\n\n  }\n\n  TableDirective.ɵfac = function TableDirective_Factory(t) {\n    return new (t || TableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  TableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TableDirective,\n    selectors: [[\"table\"]],\n    hostVars: 2,\n    hostBindings: function TableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"min-width\", ctx.minWidth);\n      }\n    },\n    inputs: {\n      locked: \"locked\",\n      virtualColumns: \"virtualColumns\"\n    }\n  });\n  return TableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ResizableContainerDirective = /*#__PURE__*/(() => {\n  class ResizableContainerDirective {\n    constructor(el, renderer, resizeService, ctx) {\n      this.el = el;\n      this.renderer = renderer;\n      this.resizeService = resizeService;\n      this.ctx = ctx;\n      this.enabled = false;\n    }\n\n    set lockedWidth(value) {\n      this._lockedWidth = value;\n\n      if (this.enabled) {\n        this.attachResize();\n        this.resize();\n      }\n    }\n\n    set kendoGridResizableContainer(enabled) {\n      const refresh = enabled !== this.enabled;\n      this.enabled = enabled;\n\n      if (refresh) {\n        this.attachResize();\n        this.resize();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n\n    attachResize() {\n      if (this.resizeSubscription && !this.enabled) {\n        this.resizeSubscription.unsubscribe();\n        this.resizeSubscription = null;\n      }\n\n      if (!this.resizeSubscription && this.enabled) {\n        this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));\n      }\n    }\n\n    resize() {\n      if (this.ctx.grid && this.ctx.grid.wrapper) {\n        const containerElement = this.ctx.grid.wrapper.nativeElement;\n        const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);\n\n        if (this.enabled && width > 0) {\n          this.renderer.setStyle(this.el.nativeElement, \"width\", width + \"px\");\n        } else {\n          this.renderer.setStyle(this.el.nativeElement, \"width\", \"\");\n        }\n      }\n    }\n\n  }\n\n  ResizableContainerDirective.ɵfac = function ResizableContainerDirective_Factory(t) {\n    return new (t || ResizableContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ResizeService), i0.ɵɵdirectiveInject(ContextService));\n  };\n\n  ResizableContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ResizableContainerDirective,\n    selectors: [[\"\", \"kendoGridResizableContainer\", \"\"]],\n    inputs: {\n      lockedWidth: \"lockedWidth\",\n      kendoGridResizableContainer: \"kendoGridResizableContainer\"\n    }\n  });\n  return ResizableContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst elementAt = (index, elements, elementOffset) => {\n  for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {\n    const offset = elementOffset(elements[idx]);\n\n    if (elementIdx <= index && index <= elementIdx + offset - 1) {\n      return elements[idx];\n    }\n\n    elementIdx += offset;\n  }\n};\n\nconst rowAt = (index, rows) => elementAt(index, rows, row => row.hasAttribute('data-kendo-grid-item-index') ? 1 : 0);\n\nconst cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);\n\nconst EMPTY_OBJECT = {};\n/**\n * @hidden\n */\n\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');\n/**\n * @hidden\n */\n\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n  return new ScrollerService(observable);\n}\n\nconst wheelDeltaY = e => {\n  const deltaY = e.wheelDeltaY;\n\n  if (e.wheelDelta && (deltaY === undefined || deltaY)) {\n    return e.wheelDelta;\n  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {\n    return -e.detail * 10;\n  }\n\n  return 0;\n};\n\nconst preventLockedScroll = (args, element) => {\n  const delta = wheelDeltaY(args);\n  const scrollTop = element.scrollTop;\n  const allowScroll = scrollTop === 0 && 0 < delta || element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0;\n\n  if (!allowScroll) {\n    event.preventDefault();\n  }\n};\n\nconst translateY = (renderer, value) => el => renderer.setStyle(el, \"transform\", `translateY(${value}px)`);\n\nconst maybeNativeElement = el => el ? el.nativeElement : null;\n\nconst hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;\n\nconst setHeight = renderer => ({\n  el,\n  height\n}) => renderer.setStyle(el, \"height\", `${height}px`);\n\nconst bufferSize = 1;\n/**\n * @hidden\n */\n\nlet ListComponent = /*#__PURE__*/(() => {\n  class ListComponent {\n    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, localization, columnResizingService, changeDetector, pdfService, columnInfo) {\n      this.changeNotification = changeNotification;\n      this.suspendService = suspendService;\n      this.groupsService = groupsService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.scrollSyncService = scrollSyncService;\n      this.resizeService = resizeService;\n      this.editService = editService;\n      this.supportService = supportService;\n      this.navigationService = navigationService;\n      this.localization = localization;\n      this.columnResizingService = columnResizingService;\n      this.changeDetector = changeDetector;\n      this.pdfService = pdfService;\n      this.columnInfo = columnInfo;\n      this.groups = [];\n      this.skip = 0;\n      this.columns = new ColumnsContainer(() => []);\n      this.selectable = false;\n      this.groupable = false;\n      this.trackBy = defaultTrackBy;\n      this.contentScroll = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.scrollBottom = new EventEmitter();\n      this.columnsStartIdx = 0;\n      this.resizeSensors = new QueryList();\n      this.dispatcher = new Subject();\n      this.containerScrollTop = 0;\n      this.scrollLeft = 0;\n      this.rtl = false;\n      this.scroller = scrollerFactory(this.dispatcher);\n      this.subscriptions = detailsService.changes.subscribe(x => this.detailExpand(x));\n      this.subscriptions.add(scrollRequestService.requests.subscribe(x => this.scrollTo(x)));\n    }\n\n    get hostClass() {\n      return true;\n    }\n\n    get hostRole() {\n      return 'presentation';\n    }\n\n    get showFooter() {\n      return this.groupable && this.groupable.showFooter;\n    }\n\n    get totalWidth() {\n      if (this.virtualColumns && this.columns.unlockedWidth) {\n        return this.columns.unlockedWidth;\n      }\n    }\n\n    get lockedLeafColumns() {\n      return this.columns.lockedLeafColumns;\n    }\n\n    get nonLockedLeafColumns() {\n      return this.columns.nonLockedLeafColumns;\n    }\n\n    get nonLockedColumnsToRender() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.viewportColumns;\n      }\n\n      return this.nonLockedLeafColumns;\n    }\n\n    get leafColumns() {\n      return this.columns.leafColumnsToRender;\n    }\n\n    get lockedWidth() {\n      const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;\n      return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n\n    get nonLockedWidth() {\n      if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {\n        return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));\n      }\n\n      return undefined;\n    }\n\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n\n    ngOnInit() {\n      this.init();\n      this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));\n      this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));\n      this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {\n        if (this.virtualColumns) {\n          this.ngZone.run(() => {\n            this.updateViewportColumns();\n            this.changeDetector.markForCheck();\n          });\n        }\n      }));\n      this.subscriptions.add(this.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl));\n    }\n\n    ngOnChanges(changes) {\n      const hasInitialSkip = changes.skip && changes.skip.firstChange && changes.skip.currentValue > 0;\n\n      if (hasInitialSkip) {\n        this.handleInitialScrollToSkip();\n      }\n\n      if (isChanged$1(\"skip\", changes) && !this.rebind) {\n        this.skipScroll = true;\n        this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n      }\n\n      if (anyChanged([\"total\", \"take\"], changes)) {\n        this.init();\n      }\n\n      this.rebind = false;\n    }\n\n    ngDoCheck() {\n      if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {\n        this.updateViewportColumns();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.skip && this.isVirtual) {\n        this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);\n      }\n\n      this.resetNavigationViewport();\n      this.attachContainerScroll();\n      this.initResizeService();\n    }\n\n    ngAfterViewChecked() {\n      const isLocked = this.isLocked;\n\n      if (isLocked && !this.hasLockedContainer) {\n        this.syncRowsHeight();\n      }\n\n      this.hasLockedContainer = isLocked;\n    }\n\n    syncRowsHeight() {\n      if (this.lockedContainer) {\n        syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n\n      if (this.resizeService) {\n        this.resizeService.destroy();\n      }\n\n      this.cleanupScroller();\n    }\n\n    init() {\n      if (this.suspendService.scroll) {\n        return;\n      }\n\n      this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);\n      this.totalHeight = this.rowHeightService.totalHeight();\n\n      if (!isUniversal()) {\n        this.ngZone.runOutsideAngular(this.createScroller.bind(this));\n      }\n    }\n\n    lockedScroll() {\n      if (!this.suspendService.scroll) {\n        const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;\n\n        if (lockedScrollTop !== this.containerScrollTop) {\n          this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;\n        }\n      }\n    }\n\n    lockedMousewheel(args) {\n      if (!args.ctrlKey) {\n        preventLockedScroll(args, this.container.nativeElement);\n        const scrollDelta = wheelDeltaY(args);\n        this.container.nativeElement.scrollTop -= scrollDelta;\n      }\n    }\n\n    lockedKeydown(args) {\n      if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {\n        const dir = args.keyCode === Keys.PageDown ? 1 : -1;\n        const element = this.container.nativeElement;\n        element.scrollTop += element.offsetHeight * dir * 0.8;\n        args.preventDefault();\n      }\n    }\n\n    detailExpand({\n      index,\n      expand\n    }) {\n      if (expand) {\n        this.rowHeightService.expandDetail(index);\n      } else {\n        this.rowHeightService.collapseDetail(index);\n      }\n\n      this.totalHeight = this.rowHeightService.totalHeight();\n      this.resetNavigationViewport();\n    }\n\n    attachContainerScroll() {\n      if (isUniversal()) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map(event => event.target), filter(() => !this.suspendService.scroll), tap(target => {\n          this.onContainerScroll(target);\n          this.resetNavigationViewport();\n\n          if (this.virtualColumns) {\n            this.handleColumnScroll();\n          }\n\n          const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;\n          const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;\n          this.contentScroll.emit({\n            scrollLeft: target.scrollLeft,\n            scrollTop: target.scrollTop,\n            startRow: rowViewport.firstItemIndex,\n            endRow: rowViewport.lastItemIndex,\n            startColumn: columnViewport.firstItemIndex,\n            endColumn: columnViewport.lastItemIndex\n          });\n        })).subscribe(this.dispatcher));\n      });\n      this.scrollSyncService.registerEmitter(this.container.nativeElement, \"body\");\n    }\n\n    createScroller() {\n      this.cleanupScroller();\n      const observable = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total);\n      this.skipScroll = false;\n      this.scrollerSubscription = observable.pipe(filter(x => x instanceof PageAction), filter(() => {\n        const temp = this.skipScroll;\n        this.skipScroll = false;\n        return !temp;\n      }), tap(() => this.rebind = true)).subscribe(x => this.ngZone.run(() => this.pageChange.emit(x)));\n      this.scrollerSubscription.add(observable.pipe(filter(x => x instanceof ScrollAction)).subscribe(this.scroll.bind(this)));\n      this.scrollerSubscription.add(observable.pipe(filter(x => x instanceof ScrollBottomAction)).subscribe(() => this.scrollBottom.emit()));\n    }\n\n    scroll({\n      offset = 0\n    }) {\n      if (this.isVirtual) {\n        [maybeNativeElement(this.table), maybeNativeElement(this.lockedTable)].filter(isPresent).forEach(translateY(this.renderer, offset));\n      }\n\n      this.resetNavigationViewport();\n    }\n\n    onContainerScroll({\n      scrollTop\n    }) {\n      this.containerScrollTop = scrollTop;\n\n      if (this.lockedContainer) {\n        this.lockedContainer.nativeElement.scrollTop = scrollTop;\n      }\n    }\n\n    handleInitialScrollToSkip() {\n      const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;\n\n      const sub = this.changeNotification.changes.pipe(filter(shouldScroll)).subscribe(_ => {\n        this.scrollTo({\n          row: this.skip\n        });\n        sub.unsubscribe();\n      });\n    }\n\n    handleRowSync() {\n      const isLocked = () => isPresent(this.lockedContainer);\n\n      const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));\n\n      return merge(this.changeNotification.changes, this.groupsService.changes.pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes.pipe(filter(change => change.type === 'end')), this.supportService.changes).pipe(tap(() => this.resetNavigationViewport()), filter(isLocked)).subscribe(() => {\n        const scrollTop = this.container.nativeElement.scrollTop;\n        const scrollLeft = this.container.nativeElement.scrollLeft;\n        this.syncRowsHeight();\n        this.syncContainerHeight();\n        this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop; // fixes scroll left position in IE when editing\n\n        this.container.nativeElement.scrollLeft = scrollLeft;\n        this.resizeSensors.forEach(sensor => sensor.acceptSize());\n      });\n    }\n\n    handleRowNavigationLocked() {\n      return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe(args => {\n        if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {\n          const cell = this.navigationService.activeCell;\n\n          if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {\n            this.container.nativeElement.scrollLeft = 0;\n          }\n        }\n      });\n    }\n\n    scrollToVirtualRow(itemIndex) {\n      if (isPresent(this.detailTemplate)) {\n        itemIndex = Math.floor(itemIndex / 2);\n      }\n\n      const offset = this.rowHeightService.offset(itemIndex);\n      this.container.nativeElement.scrollTop = offset;\n      this.resetNavigationViewport();\n    }\n\n    scrollTo({\n      row,\n      column\n    }) {\n      if (isNumber(row)) {\n        if (this.isVirtual) {\n          this.scrollToVirtualRow(row);\n        } else {\n          const element = rowAt(row, this.table.nativeElement.rows);\n\n          if (element) {\n            this.container.nativeElement.scrollTop = element.offsetTop;\n          }\n        }\n      }\n\n      if (isNumber(column)) {\n        column -= this.lockedLeafColumns.length;\n\n        if (this.virtualColumns) {\n          const columns = this.columns.leafColumnsToRender;\n          let offset = 0;\n\n          for (let idx = 0; idx < column; idx++) {\n            offset += columns[idx].width || 0;\n          }\n\n          const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);\n          this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);\n        } else if (column === 0 && this.detailTemplate) {\n          this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);\n        } else {\n          const firstRow = rowAt(0, this.table.nativeElement.rows);\n\n          if (firstRow) {\n            const element = cellAt(column, firstRow.cells);\n\n            if (element) {\n              this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);\n            }\n          }\n        }\n      }\n    }\n\n    resetNavigationViewport() {\n      if (!this.container || !this.navigationService.tableEnabled || !this.navigationService.needsViewport() || this.data.length === 0) {\n        return;\n      }\n\n      const {\n        scrollTop,\n        offsetHeight\n      } = this.container.nativeElement;\n      const scrollBottom = scrollTop + offsetHeight;\n      const firstItemIndex = this.rowHeightService.index(scrollTop);\n      let lastItemIndex = this.rowHeightService.index(scrollBottom);\n      const lastItemOffset = this.rowHeightService.offset(lastItemIndex);\n      const lastItemOverflows = lastItemOffset + this.rowHeight > scrollBottom;\n\n      if (lastItemIndex > 0 && lastItemOverflows) {\n        lastItemIndex--;\n      }\n\n      let viewportStart = firstItemIndex;\n      let viewportEnd = lastItemIndex;\n\n      if (isPresent(this.detailTemplate)) {\n        viewportStart *= 2;\n        viewportEnd *= 2;\n        const firstItemHeight = this.rowHeightService.offset(firstItemIndex);\n\n        if (firstItemHeight + this.rowHeight < scrollTop) {\n          viewportStart++;\n        }\n\n        const lastItemHeight = this.rowHeightService.height(lastItemIndex);\n        const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);\n        const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;\n\n        if (lastItemExpanded && !lastItemDetailOverflows) {\n          viewportEnd++;\n        }\n      }\n\n      this.navigationService.setViewport(viewportStart, viewportEnd);\n    }\n\n    cleanupScroller() {\n      if (this.scrollerSubscription) {\n        this.scrollerSubscription.unsubscribe();\n      }\n\n      if (this.scroller) {\n        this.scroller.destroy();\n      }\n    }\n\n    initResizeService() {\n      this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));\n    }\n\n    syncContainerHeight() {\n      [maybeNativeElement(this.lockedContainer)].filter(isPresent).map(el => {\n        el.style.height = '';\n        let height = this.container.nativeElement.offsetHeight;\n\n        if (hasScrollbar(this.table, this.container)) {\n          height -= this.supportService.scrollbarWidth;\n        }\n\n        return {\n          el,\n          height\n        };\n      }).forEach(setHeight(this.renderer));\n    }\n\n    updateViewportColumns(range) {\n      const columns = this.columns.nonLockedLeafColumns.toArray();\n      let {\n        startIdx,\n        endIdx,\n        offset\n      } = range || this.calculateViewportColumns();\n      const start = Math.max(0, startIdx - bufferSize);\n      const end = Math.min(endIdx + bufferSize, columns.length - 1);\n\n      if (start < startIdx) {\n        for (let idx = startIdx - 1; idx >= start; idx--) {\n          offset -= columns[idx].width;\n        }\n      }\n\n      let currentColumns = columns.slice(start, end + 1);\n      this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);\n\n      if (start > 0) {\n        const offsetColumn = new ColumnBase();\n        offsetColumn.width = offset;\n        currentColumns.unshift(offsetColumn);\n      }\n\n      this.viewportColumns = new QueryList();\n      this.viewportColumns.reset(currentColumns);\n      this.columnsStartIdx = start;\n      this.columnsEndIdx = end;\n      this.columnInfo.columnRangeChange.emit({\n        start,\n        end,\n        offset\n      });\n\n      if (!range) {\n        this.updateColumnViewport(startIdx, endIdx);\n      }\n    }\n\n    handleColumnScroll() {\n      const container = this.container.nativeElement;\n      const scrollLeft = container.scrollLeft;\n\n      if (this.scrollLeft !== scrollLeft) {\n        this.scrollLeft = scrollLeft;\n        const range = this.calculateViewportColumns();\n        this.updateColumnViewport(range.startIdx, range.endIdx);\n\n        if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {\n          cancelAnimationFrame(this.columnUpdateFrame);\n          this.columnUpdateFrame = requestAnimationFrame(() => {\n            this.ngZone.run(() => {\n              this.updateViewportColumns(range);\n              this.changeDetector.markForCheck();\n            });\n          });\n        }\n      }\n    }\n\n    updateColumnViewport(startIdx, endIdx) {\n      const lockedCount = this.lockedLeafColumns.length;\n      const leafColumns = this.nonLockedLeafColumns.toArray();\n      const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);\n      let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);\n\n      for (let idx = 0; idx < leafColumns.length; idx++) {\n        const column = leafColumns[idx];\n\n        if (column.isSpanColumn) {\n          viewportEnd += column.childColumns.length;\n        }\n      }\n\n      this.navigationService.setColumnViewport(viewportStart, viewportEnd);\n    }\n\n    calculateViewportColumns() {\n      const {\n        scrollLeft,\n        clientWidth\n      } = this.container.nativeElement;\n      const columns = this.columns.nonLockedLeafColumns.toArray();\n      const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);\n      const viewportEnd = normalizedScrollLeft + clientWidth;\n      let startIdx;\n      let endIdx = 0;\n      let current = 0;\n      let offset = 0;\n      let idx;\n\n      for (idx = 0; idx < columns.length; idx++) {\n        const column = columns[idx];\n        current += column.width || 0;\n\n        if (startIdx === undefined && current > normalizedScrollLeft) {\n          startIdx = idx;\n          offset = current - (column.width || 0);\n        }\n\n        if (current >= viewportEnd) {\n          endIdx = idx;\n          break;\n        }\n      }\n\n      if (!endIdx && idx > 0) {\n        endIdx = columns.length - 1;\n      }\n\n      return {\n        startIdx,\n        endIdx,\n        offset\n      };\n    }\n\n    viewportWidthChange() {\n      const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);\n      return currentWidth !== this.viewportColumnsWidth;\n    }\n\n    normalizeScrollLeft(position) {\n      return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;\n    }\n\n    elementScrollLeft(element) {\n      if (this.rtl) {\n        return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);\n      }\n\n      return element.offsetLeft;\n    }\n\n  }\n\n  ListComponent.ɵfac = function ListComponent_Factory(t) {\n    return new (t || ListComponent)(i0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(SuspendService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ScrollSyncService), i0.ɵɵdirectiveInject(ResizeService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(BrowserSupportService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(ScrollRequestService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(ColumnInfoService));\n  };\n\n  ListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ListComponent,\n    selectors: [[\"kendo-grid-list\"]],\n    viewQuery: function ListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c45, 7);\n        i0.ɵɵviewQuery(_c46, 5);\n        i0.ɵɵviewQuery(_c47, 5);\n        i0.ɵɵviewQuery(_c48, 7);\n        i0.ɵɵviewQuery(ResizeSensorComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedTable = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.table = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeSensors = _t);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function ListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.hostRole);\n        i0.ɵɵclassProp(\"k-grid-container\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      groups: \"groups\",\n      total: \"total\",\n      rowHeight: \"rowHeight\",\n      stickyRowHeight: \"stickyRowHeight\",\n      detailRowHeight: \"detailRowHeight\",\n      take: \"take\",\n      skip: \"skip\",\n      columns: \"columns\",\n      detailTemplate: \"detailTemplate\",\n      noRecordsTemplate: \"noRecordsTemplate\",\n      selectable: \"selectable\",\n      groupable: \"groupable\",\n      filterable: \"filterable\",\n      rowClass: \"rowClass\",\n      rowSticky: \"rowSticky\",\n      loading: \"loading\",\n      trackBy: \"trackBy\",\n      virtualColumns: \"virtualColumns\",\n      isVirtual: \"isVirtual\",\n      cellLoadingTemplate: \"cellLoadingTemplate\",\n      loadingTemplate: \"loadingTemplate\"\n    },\n    outputs: {\n      contentScroll: \"contentScroll\",\n      pageChange: \"pageChange\",\n      scrollBottom: \"scrollBottom\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SCROLLER_FACTORY_TOKEN,\n      useValue: DEFAULT_SCROLLER_FACTORY\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 13,\n    vars: 35,\n    consts: [[\"class\", \"k-grid-content-locked\", \"role\", \"presentation\", \"tabindex\", \"-1\", 3, \"width\", \"kendoEventsOutsideAngular\", \"scope\", 4, \"ngIf\"], [\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-grid-content\", \"k-virtual-content\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"container\", \"\"], [\"role\", \"presentation\", 1, \"k-grid-table-wrap\"], [\"role\", \"presentation\", 1, \"k-grid-table\", 3, \"virtualColumns\"], [\"table\", \"\"], [\"kendoGridColGroup\", \"\", \"role\", \"presentation\", 3, \"groups\", \"columns\", \"detailTemplate\"], [\"kendoGridTableBody\", \"\", \"role\", \"presentation\", 3, \"skipGroupDecoration\", \"data\", \"groups\", \"showGroupFooters\", \"columns\", \"allColumns\", \"detailTemplate\", \"noRecordsTemplate\", \"lockedColumnsCount\", \"totalColumnsCount\", \"skip\", \"selectable\", \"trackBy\", \"filterable\", \"rowClass\", \"rowSticky\", \"virtualColumns\", \"isLoading\", \"isVirtual\", \"cellLoadingTemplate\"], [4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-height-container\"], [\"class\", \"k-width-container\", \"role\", \"presentation\", 4, \"ngIf\"], [\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-grid-content-locked\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"lockedContainer\", \"\"], [\"role\", \"presentation\", 1, \"k-grid-table\", 3, \"locked\"], [\"lockedTable\", \"\"], [\"kendoGridTableBody\", \"\", \"role\", \"presentation\", 3, \"groups\", \"isLocked\", \"data\", \"noRecordsText\", \"columns\", \"totalColumnsCount\", \"detailTemplate\", \"showGroupFooters\", \"skip\", \"selectable\", \"trackBy\", \"filterable\", \"rowClass\", \"isLoading\", \"isVirtual\", \"cellLoadingTemplate\"], [\"role\", \"presentation\", 1, \"k-width-container\"]],\n    template: function ListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ListComponent_div_0_Template, 10, 33, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"div\", 3)(4, \"table\", 4, 5);\n        i0.ɵɵelement(6, \"colgroup\", 6)(7, \"tbody\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, ListComponent_kendo_resize_sensor_8_Template, 1, 0, \"kendo-resize-sensor\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, ListComponent_kendo_resize_sensor_9_Template, 1, 0, \"kendo-resize-sensor\", 8);\n        i0.ɵɵelementStart(10, \"div\", 9);\n        i0.ɵɵelement(11, \"div\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, ListComponent_div_12_Template, 2, 2, \"div\", 10);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoGridResizableContainer\", ctx.lockedLeafColumns.length > 0)(\"lockedWidth\", ctx.lockedWidth + 1);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"width\", ctx.nonLockedWidth, \"px\");\n        i0.ɵɵproperty(\"virtualColumns\", ctx.virtualColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"groups\", ctx.isLocked ? i0.ɵɵpureFunction0(34, _c50) : ctx.groups)(\"columns\", ctx.nonLockedColumnsToRender)(\"detailTemplate\", ctx.detailTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"skipGroupDecoration\", ctx.isLocked)(\"data\", ctx.data)(\"groups\", ctx.groups)(\"showGroupFooters\", ctx.showFooter)(\"columns\", ctx.nonLockedColumnsToRender)(\"allColumns\", ctx.nonLockedLeafColumns)(\"detailTemplate\", ctx.detailTemplate)(\"noRecordsTemplate\", ctx.noRecordsTemplate)(\"lockedColumnsCount\", ctx.lockedLeafColumns.length)(\"totalColumnsCount\", ctx.leafColumns.length)(\"skip\", ctx.skip)(\"selectable\", ctx.selectable)(\"trackBy\", ctx.trackBy)(\"filterable\", ctx.filterable)(\"rowClass\", ctx.rowClass)(\"rowSticky\", ctx.rowSticky)(\"virtualColumns\", ctx.virtualColumns)(\"isLoading\", ctx.loading)(\"isVirtual\", ctx.isVirtual)(\"cellLoadingTemplate\", ctx.cellLoadingTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isLocked || ctx.virtualColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.virtualColumns);\n      }\n    },\n    directives: [ColGroupComponent, TableBodyComponent, i1$1.ResizeSensorComponent, i4.NgIf, i1$1.EventsOutsideAngularDirective, TableDirective, ResizableContainerDirective],\n    encapsulation: 2\n  });\n  return ListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FooterComponent = /*#__PURE__*/(() => {\n  class FooterComponent {\n    constructor(columnInfoService) {\n      this.columnInfoService = columnInfoService;\n      this.columns = [];\n      this.groups = [];\n      this.lockedColumnsCount = 0;\n      this.logicalRowIndex = 0;\n    }\n\n    get footerClass() {\n      return !this.scrollable;\n    }\n\n    get columnsToRender() {\n      return columnsToRender(this.columns || []);\n    }\n\n    logicalColumnIndex(column) {\n      const index = column.leafIndex;\n\n      if (isPresent(index)) {\n        return index + (isPresent(this.detailTemplate) ? 1 : 0);\n      }\n\n      return -1;\n    }\n\n    addStickyStyles(column) {\n      const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);\n      return Object.assign(Object.assign({}, column.style), stickyStyles);\n    }\n\n  }\n\n  FooterComponent.ɵfac = function FooterComponent_Factory(t) {\n    return new (t || FooterComponent)(i0.ɵɵdirectiveInject(ColumnInfoService));\n  };\n\n  FooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FooterComponent,\n    selectors: [[\"\", \"kendoGridFooter\", \"\"]],\n    hostVars: 2,\n    hostBindings: function FooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-footer\", ctx.footerClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      groups: \"groups\",\n      detailTemplate: \"detailTemplate\",\n      scrollable: \"scrollable\",\n      lockedColumnsCount: \"lockedColumnsCount\",\n      logicalRowIndex: \"logicalRowIndex\"\n    },\n    attrs: _c51,\n    decls: 5,\n    vars: 9,\n    consts: [[\"kendoGridLogicalRow\", \"\", 3, \"logicalRowIndex\", \"logicalSlaveRow\", \"logicalCellsCount\", \"logicalSlaveCellsCount\"], [\"role\", \"presentation\", 3, \"k-group-cell\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 3, \"k-hierarchy-cell\", 4, \"ngIf\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnfooter\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"k-grid-footer-sticky\", \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\"], [\"kendoGridLogicalCell\", \"\", \"role\", \"columnfooter\", \"aria-selected\", \"false\", 3, \"logicalRowIndex\", \"logicalColIndex\", \"ngClass\", \"ngStyle\"], [3, \"templateContext\"]],\n    template: function FooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0);\n        i0.ɵɵelementStart(1, \"tr\", 0);\n        i0.ɵɵtemplate(2, FooterComponent_td_2_Template, 1, 2, \"td\", 1);\n        i0.ɵɵtemplate(3, FooterComponent_td_3_Template, 1, 2, \"td\", 2);\n        i0.ɵɵtemplate(4, FooterComponent_td_4_Template, 2, 12, \"td\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-footer-template\", true);\n        i0.ɵɵproperty(\"logicalRowIndex\", ctx.logicalRowIndex)(\"logicalSlaveRow\", ctx.lockedColumnsCount > 0)(\"logicalCellsCount\", ctx.columns.length)(\"logicalSlaveCellsCount\", ctx.columns.length - ctx.lockedColumnsCount);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.groups);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnsToRender);\n      }\n    },\n    directives: [LogicalRowDirective, i4.NgForOf, i4.NgIf, LogicalCellDirective, i4.NgClass, i4.NgStyle, TemplateContextDirective],\n    encapsulation: 2\n  });\n  return FooterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LoadingComponent = /*#__PURE__*/(() => {\n  class LoadingComponent {\n    constructor(localization) {\n      this.localization = localization;\n      this.hostClass = true;\n    }\n\n    get loadingText() {\n      return this.localization.get('loading');\n    }\n\n  }\n\n  LoadingComponent.ɵfac = function LoadingComponent_Factory(t) {\n    return new (t || LoadingComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LoadingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LoadingComponent,\n    selectors: [[\"\", \"kendoGridLoading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function LoadingComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-loading-mask\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      loadingTemplate: \"loadingTemplate\"\n    },\n    attrs: _c52,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [1, \"k-loading-text\"], [1, \"k-loading-image\"], [1, \"k-loading-color\"], [3, \"ngTemplateOutlet\"]],\n    template: function LoadingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, LoadingComponent_ng_container_0_Template, 5, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, LoadingComponent_1_Template, 1, 1, null, 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.loadingTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loadingTemplate);\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return LoadingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet GridMessages = /*#__PURE__*/(() => {\n  class GridMessages extends ComponentMessages {}\n\n  GridMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵGridMessages_BaseFactory;\n    return function GridMessages_Factory(t) {\n      return (ɵGridMessages_BaseFactory || (ɵGridMessages_BaseFactory = i0.ɵɵgetInheritedFactory(GridMessages)))(t || GridMessages);\n    };\n  }();\n\n  GridMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GridMessages,\n    selectors: [[\"kendo-grid-messages-base\"]],\n    inputs: {\n      groupPanelEmpty: \"groupPanelEmpty\",\n      noRecords: \"noRecords\",\n      pagerLabel: \"pagerLabel\",\n      pagerFirstPage: \"pagerFirstPage\",\n      pagerLastPage: \"pagerLastPage\",\n      pagerPreviousPage: \"pagerPreviousPage\",\n      pagerNextPage: \"pagerNextPage\",\n      pagerPage: \"pagerPage\",\n      pagerItemsPerPage: \"pagerItemsPerPage\",\n      pagerOf: \"pagerOf\",\n      pagerItems: \"pagerItems\",\n      pagerPageNumberInputTitle: \"pagerPageNumberInputTitle\",\n      filter: \"filter\",\n      filterInputLabel: \"filterInputLabel\",\n      filterMenuTitle: \"filterMenuTitle\",\n      filterMenuOperatorsDropDownLabel: \"filterMenuOperatorsDropDownLabel\",\n      filterMenuLogicDropDownLabel: \"filterMenuLogicDropDownLabel\",\n      filterEqOperator: \"filterEqOperator\",\n      filterNotEqOperator: \"filterNotEqOperator\",\n      filterIsNullOperator: \"filterIsNullOperator\",\n      filterIsNotNullOperator: \"filterIsNotNullOperator\",\n      filterIsEmptyOperator: \"filterIsEmptyOperator\",\n      filterIsNotEmptyOperator: \"filterIsNotEmptyOperator\",\n      filterStartsWithOperator: \"filterStartsWithOperator\",\n      filterContainsOperator: \"filterContainsOperator\",\n      filterNotContainsOperator: \"filterNotContainsOperator\",\n      filterEndsWithOperator: \"filterEndsWithOperator\",\n      filterGteOperator: \"filterGteOperator\",\n      filterGtOperator: \"filterGtOperator\",\n      filterLteOperator: \"filterLteOperator\",\n      filterLtOperator: \"filterLtOperator\",\n      filterIsTrue: \"filterIsTrue\",\n      filterIsFalse: \"filterIsFalse\",\n      filterBooleanAll: \"filterBooleanAll\",\n      filterAfterOrEqualOperator: \"filterAfterOrEqualOperator\",\n      filterAfterOperator: \"filterAfterOperator\",\n      filterBeforeOperator: \"filterBeforeOperator\",\n      filterBeforeOrEqualOperator: \"filterBeforeOrEqualOperator\",\n      filterFilterButton: \"filterFilterButton\",\n      filterClearButton: \"filterClearButton\",\n      filterAndLogic: \"filterAndLogic\",\n      filterOrLogic: \"filterOrLogic\",\n      loading: \"loading\",\n      gridLabel: \"gridLabel\",\n      columnMenu: \"columnMenu\",\n      setColumnPosition: \"setColumnPosition\",\n      columns: \"columns\",\n      lock: \"lock\",\n      unlock: \"unlock\",\n      stick: \"stick\",\n      unstick: \"unstick\",\n      sortable: \"sortable\",\n      sortAscending: \"sortAscending\",\n      sortDescending: \"sortDescending\",\n      sortedAscending: \"sortedAscending\",\n      sortedDescending: \"sortedDescending\",\n      sortedDefault: \"sortedDefault\",\n      columnsApply: \"columnsApply\",\n      columnsReset: \"columnsReset\",\n      detailExpand: \"detailExpand\",\n      detailCollapse: \"detailCollapse\",\n      filterDateToday: \"filterDateToday\",\n      filterDateToggle: \"filterDateToggle\",\n      filterNumericDecrement: \"filterNumericDecrement\",\n      filterNumericIncrement: \"filterNumericIncrement\",\n      selectionCheckboxLabel: \"selectionCheckboxLabel\",\n      selectAllCheckboxLabel: \"selectAllCheckboxLabel\",\n      groupCollapse: \"groupCollapse\",\n      groupExpand: \"groupExpand\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return GridMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedMessagesDirective extends GridMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n    return new (t || LocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoGridLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: GridMessages,\n      useExisting: forwardRef(() => LocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst createControl = source => (acc, key) => {\n  acc[key] = new FormControl(source[key]);\n  return acc;\n};\n\nconst validateColumnsField = columns => expandColumns(columns.toArray()).filter(isColumnComponent).filter(({\n  field\n}) => !isValidFieldName(field)).forEach(({\n  field\n}) => console.warn(`\n                Grid column field name '${field}' does not look like a valid JavaScript identifier.\n                Identifiers can contain only alphanumeric characters (including \"$\" or \"_\"), and may not start with a digit.\n                Please use only valid identifier names to ensure error-free operation.\n            `));\n\nconst handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map) => service.changes.pipe(filter(({\n  group\n}) => isPresent(group))).subscribe(x => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x)));\n\nconst handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map) => service.changes.pipe(filter(({\n  dataItem\n}) => isPresent(dataItem))).subscribe(x => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x)));\n\nconst isInEditedCell = (element, gridElement) => closest(element, matchesClasses('k-grid-edit-cell')) && closest(element, matchesNodeName('kendo-grid')) === gridElement;\n/**\n * Represents the Kendo UI Grid component for Angular.\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\">\n *        </kendo-grid>\n *    `\n * })\n * class AppComponent {\n *    public gridData: any[] = products;\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n * ```\n */\n\n\nlet GridComponent = /*#__PURE__*/(() => {\n  class GridComponent {\n    constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx) {\n      this.supportService = supportService;\n      this.selectionService = selectionService;\n      this.cellSelectionService = cellSelectionService;\n      this.wrapper = wrapper;\n      this.groupInfoService = groupInfoService;\n      this.groupsService = groupsService;\n      this.changeNotification = changeNotification;\n      this.detailsService = detailsService;\n      this.editService = editService;\n      this.filterService = filterService;\n      this.pdfService = pdfService;\n      this.responsiveService = responsiveService;\n      this.renderer = renderer;\n      this.excelService = excelService;\n      this.ngZone = ngZone;\n      this.scrollSyncService = scrollSyncService;\n      this.domEvents = domEvents;\n      this.columnResizingService = columnResizingService;\n      this.changeDetectorRef = changeDetectorRef;\n      this.columnReorderService = columnReorderService;\n      this.columnInfoService = columnInfoService;\n      this.navigationService = navigationService;\n      this.sortService = sortService;\n      this.scrollRequestService = scrollRequestService;\n      this.localization = localization;\n      this.ctx = ctx;\n      /**\n       * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count\n       * ([more information and example]({% slug databinding_grid %})).\n       */\n\n      this.data = [];\n      /**\n       * Defines the scroll mode used by the Grid.\n       *\n       * The available options are:\n       *  - `none`&mdash;Renders no scrollbar.\n       *  - `scrollable`&mdash;The default scroll mode. It requires the setting of the `height` option.\n       *  - `virtual`&mdash;Displays no pager and renders a portion of the data (optimized rendering) while the user is scrolling the content.\n       */\n\n      this.scrollable = 'scrollable';\n      /**\n       * Enables the single-row [selection]({% slug selection_grid %}) of the Grid.\n       */\n\n      this.selectable = false;\n      /**\n       * A function that defines how to track changes for the data rows.\n       *\n       * By default, the Grid tracks changes by the index of the data item.\n       * Edited rows are tracked by reference.\n       * In some cases, you might need to override the default behavior,\n       * for example, when you implement editing with immutable data items.\n       *\n       * The following example demonstrates how to track items only by index.\n       *\n       * @example\n       * ```ts\n       * import { Component } from '@angular/core';\n       * import { GridItem } from '@progress/kendo-angular-grid';\n       *\n       * _@Component({\n       *    selector: 'my-app',\n       *    template: `\n       *        <kendo-grid [data]=\"gridData\" [trackBy]=\"trackBy\">\n       *        </kendo-grid>\n       *    `\n       * })\n       * class AppComponent {\n       *    public gridData: any[] = products;\n       *\n       *    public trackBy(index: number, item: GridItem): any {\n       *        console.log(item);\n       *        return index;\n       *    }\n       * }\n       *\n       * const products = [{\n       *    \"ProductID\": 1,\n       *    \"ProductName\": \"Chai\",\n       *    \"UnitPrice\": 18.0000,\n       *    \"Discontinued\": true\n       *  }, {\n       *    \"ProductID\": 2,\n       *    \"ProductName\": \"Chang\",\n       *    \"UnitPrice\": 19.0000,\n       *    \"Discontinued\": false\n       *  }\n       * ];\n       * ```\n       */\n\n      this.trackBy = defaultTrackBy;\n      /**\n       * If set to `true`, the grid will render only the columns in the current viewport.\n       */\n\n      this.virtualColumns = false;\n      /**\n       * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.\n       */\n\n      this.filterable = false;\n      /**\n       * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.\n       */\n\n      this.sortable = false;\n      /**\n       * Configures the pager of the Grid ([see example]({% slug paging_grid %})).\n       *\n       * The available options are:\n       * - `buttonCount: Number`&mdash;Sets the maximum numeric buttons count before the buttons are collapsed. Defaults to `10`.\n       * - `info: Boolean`&mdash;Toggles the information about the current page and the total number of records. Defaults to `true`.\n       * - `type: PagerType`&mdash;Accepts the `numeric` (buttons with numbers) and `input` (input for typing the page number) values. Defaults to `'numeric'`.\n       * - `pageSizes: Boolean` or `Array<number>`&mdash;Shows a menu for selecting the page size. Defaults to `false`.\n       * - `previousNext: Boolean`&mdash;Toggles the **Previous** and **Next** buttons. Defaults to `true`.\n       * - `responsive: Boolean`&mdash;Toggles the built-in responsive behavior of the Pager. Defaults to `true`.\n       */\n\n      this.pageable = false;\n      /**\n       * If set to `true`, the user can group the Grid by dragging the column header cells.\n       * By default, grouping is disabled ([see example]({% slug groupingbasics_grid %})).\n       */\n\n      this.groupable = false;\n      /**\n       * Indicates whether the Grid columns will be resized during initialization so that\n       * they fit their headers and row content. Defaults to `false`.\n       * Columns with `autoSize` set to `false` are excluded.\n       * To dynamically update the column width to match the new content,\n       * refer to [this example]({% slug resizing_columns_grid %}).\n       */\n\n      this.autoSize = false;\n      /**\n       * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells\n       * ([see example]({% slug resizing_columns_grid %})).\n       *\n       * @default false\n       */\n\n      this.resizable = false;\n      /**\n       * If set to `true`, the user can reorder columns by dragging their header cells\n       * ([see example]({% slug reordering_columns_grid %})).\n       *\n       * @default false\n       */\n\n      this.reorderable = false;\n      /**\n       * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug databinding_grid %})).\n       *\n       * @default false\n       */\n\n      this.loading = false;\n      /**\n       * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).\n       *\n       * @default false\n       */\n\n      this.columnMenu = false;\n      /**\n       * Specifies if the header of the grid will be hidden. The header is visible by default.\n       *\n       * > The header includes column headers and the [filter row]({% slug filtering_grid %}#toc-filter-row).\n       */\n\n      this.hideHeader = false;\n      /**\n       * Fires when the Grid filter is modified through the UI.\n       * You have to handle the event yourself and filter the data.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).\n       * You have to handle the event yourself and page the data.\n       */\n\n      this.pageChange = new EventEmitter();\n      /**\n       * Fires when the grouping of the Grid is changed.\n       * You have to handle the event yourself and group the data ([see example]({% slug groupingbasics_grid %})).\n       */\n\n      this.groupChange = new ZoneAwareEventEmitter(this.ngZone);\n      /**\n       * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).\n       * You have to handle the event yourself and sort the data.\n       */\n\n      this.sortChange = new EventEmitter();\n      /**\n       * Fires when the user selects a Grid row.\n       * Emits the [SelectionEvent]({% slug api_grid_selectionevent %}#toc-selectionchange).\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires when the data state of the Grid is changed.\n       */\n\n      this.dataStateChange = new EventEmitter();\n      /**\n       * Fires when the user expands a group header.\n       */\n\n      this.groupExpand = new EventEmitter();\n      /**\n       * Fires when the user collapses a group header.\n       */\n\n      this.groupCollapse = new EventEmitter();\n      /**\n       * Fires when the user expands a master row.\n       */\n\n      this.detailExpand = new EventEmitter();\n      /**\n       * Fires when the user collapses a master row.\n       */\n\n      this.detailCollapse = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Edit** command button to edit a row\n       * ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).\n       */\n\n      this.edit = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Cancel** command button to close a row\n       * ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).\n       */\n\n      this.cancel = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Save** command button to save changes in a row\n       * ([see example]({% slug editing_template_forms_grid %}#toc-saving-records)).\n       */\n\n      this.save = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Remove** command button to remove a row\n       * ([see example]({% slug editing_template_forms_grid %}#toc-removing-records)).\n       */\n\n      this.remove = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Add** command button to add a new row\n       * ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).\n       */\n\n      this.add = new EventEmitter();\n      /**\n       * Fires when the user leaves an edited cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).\n       */\n\n      this.cellClose = new EventEmitter();\n      /**\n       * Fires when the user clicks a cell ([see example]({% slug editing_incell_grid %}#toc-basic-concepts)).\n       */\n\n      this.cellClick = new ZoneAwareEventEmitter(this.ngZone);\n      /**\n       * Fires when the user clicks the **Export to PDF** command button.\n       */\n\n      this.pdfExport = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Export to Excel** command button.\n       */\n\n      this.excelExport = new EventEmitter();\n      /**\n       * Fires when the user completes the resizing of the column.\n       */\n\n      this.columnResize = new ZoneAwareEventEmitter(this.ngZone);\n      /**\n       * Fires when the user completes the reordering of the column.\n       */\n\n      this.columnReorder = new EventEmitter();\n      /**\n       * Fires when the user changes the visibility of the columns from the column menu or column chooser.\n       */\n\n      this.columnVisibilityChange = new EventEmitter();\n      /**\n       * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.\n       */\n\n      this.columnLockedChange = new EventEmitter();\n      /**\n       * Fires when the user changes the sticky state of the columns from the column menu.\n       */\n\n      this.columnStickyChange = new EventEmitter();\n      /**\n       * Fires when the user scrolls to the last record on the page and enables endless scrolling\n       * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).\n       * You have to handle the event yourself and page the data.\n       */\n\n      this.scrollBottom = new EventEmitter();\n      /**\n       * Fires when the grid content is scrolled.\n       * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.\n       */\n\n      this.contentScroll = new EventEmitter();\n      /**\n       * A query list of all declared columns.\n       */\n\n      this.columns = new QueryList();\n      this.footer = new QueryList();\n      this.selectionDirective = false;\n      this.columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {\n        column.matchesMedia = this.matchesMedia(column);\n        return column.isVisible;\n      }));\n      this.view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));\n      this.shouldGenerateColumns = true;\n      this._sort = new Array();\n      this._group = new Array();\n      this._skip = 0;\n      this.cachedWindowWidth = 0;\n      this._rowSelected = null;\n      this._cellSelected = null;\n      this._navigable = [];\n      this.rtl = false;\n\n      this._rowClass = () => null;\n\n      validatePackage(packageMetadata);\n      this.ctx.grid = this;\n      this.localizationSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n      this.groupInfoService.registerColumnsContainer(() => this.columnList);\n      this.columnInfoService.init(this.columnsContainer, () => this.columnList);\n      this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe(changed => {\n        this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));\n      });\n      this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe(changed => {\n        this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));\n      });\n      this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe(changed => {\n        this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));\n      });\n      this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({\n        group,\n        groupIndex,\n        parentGroup\n      }) => ({\n        group,\n        groupIndex,\n        parentGroup\n      }));\n      this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, args => args);\n      this.filterSubscription = this.filterService.changes.subscribe(x => {\n        this.filterChange.emit(x);\n      });\n      this.sortSubscription = this.sortService.changes.subscribe(x => {\n        this.sortChange.emit(x);\n      });\n      this.attachStateChangesEmitter();\n      this.attachEditHandlers();\n      this.attachDomEventHandlers();\n      this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));\n      this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));\n      this.columnsContainerChange();\n      this.handleColumnResize();\n      this.columnList = new ColumnList(this.columns);\n      this.columnReorderSubscription = this.columnReorderService.changes.subscribe(this.reorder.bind(this));\n      this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));\n    }\n    /**\n     * Defines the number of records to be skipped by the pager.\n     * Required by the [paging]({% slug paging_grid %}) functionality.\n     */\n\n\n    get skip() {\n      return this._skip;\n    }\n\n    set skip(value) {\n      if (typeof value === 'number' && value >= 0) {\n        this._skip = value;\n      }\n    }\n    /**\n     * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).\n     */\n\n\n    set sort(value) {\n      if (isArray(value)) {\n        this._sort = value;\n      }\n    }\n\n    get sort() {\n      return this._sort;\n    }\n    /**\n     * The descriptors by which the data will be grouped ([see example]({% slug groupingbasics_grid %})).\n     */\n\n\n    set group(value) {\n      if (isArray(value)) {\n        this._group = value;\n      }\n    }\n    /**\n     */\n\n\n    get group() {\n      return this._group;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showTopToolbar() {\n      return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showBottomToolbar() {\n      return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isLocked() {\n      return this.lockedLeafColumns.length > 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showTopPager() {\n      const position = this.pageable.position;\n      return !this.isVirtual && this.pageable !== false && ['top', 'both'].indexOf(position) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showBottomPager() {\n      const position = this.pageable.position;\n      return !this.isVirtual && this.pageable !== false && position !== 'top';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasPager() {\n      return this.showTopPager || this.showBottomPager;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showGroupPanel() {\n      return this.groupable && this.groupable.enabled !== false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get groupableEmptyText() {\n      return this.groupable.emptyText;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get marqueeSelection() {\n      return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;\n    }\n    /**\n     * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.\n     * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.\n     * To enable navigation through separate Grid sections only, provide a [`GridNavigableSection`]({% slug api_grid_gridnavigablesection %}) array.\n     */\n\n\n    set navigable(value) {\n      if (typeof value === 'boolean') {\n        this._navigable = value ? ['table', 'pager'] : [];\n        return;\n      }\n\n      this._navigable = value;\n    }\n\n    get navigable() {\n      return this._navigable;\n    }\n    /**\n     * @hidden\n     *\n     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.\n     */\n\n\n    set navigatable(value) {\n      this.navigable = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get navigatable() {\n      return this.navigable;\n    }\n    /**\n     * Defines a function that is executed for every data row in the component.\n     *\n     * @example\n     * ```ts\n     * import { Component, ViewEncapsulation } from '@angular/core';\n     * import { RowClassArgs } from '@progress/kendo-angular-grid';\n     *\n     * _@Component({\n     *    selector: 'my-app',\n     *    encapsulation: ViewEncapsulation.None,\n     *    styles: [`\n     *        .k-grid tr.even { background-color: #f45c42; }\n     *        .k-grid tr.odd { background-color: #41f4df; }\n     *    `],\n     *    template: `\n     *        <kendo-grid [data]=\"gridData\" [rowClass]=\"rowCallback\">\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     *\n     *    public rowCallback(context: RowClassArgs) {\n     *        const isEven = context.index % 2 === 0;\n     *        return {\n     *            even: isEven,\n     *            odd: !isEven\n     *        };\n     *    }\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n\n\n    set rowClass(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`rowClass must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this._rowClass = fn;\n    }\n\n    get rowClass() {\n      return this._rowClass;\n    }\n    /**\n     * Defines a function that is executed for every data row in the component,\n     * and determines whether the row will be sticky, i.e. always visible after scrolling.\n     */\n\n\n    set rowSticky(fn) {\n      if (isDevMode && isPresent(fn) && typeof fn !== 'function') {\n        throw new Error(`rowSticky must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      if (isPresent(fn)) {\n        this._rowSticky = fn;\n      }\n    }\n\n    get rowSticky() {\n      return this._rowSticky;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data row in the component\n     * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).\n     * Determines whether the row will be selected.\n     */\n\n\n    set rowSelected(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`rowSelected must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this._rowSelected = fn;\n    }\n\n    get rowSelected() {\n      return this._rowSelected;\n    }\n    /**\n     * Defines a function that determines the selected state of a data cell.\n     * Returns an object with `selected` and `item` properties.\n     * The cell is marked as selected only if the `selected` property equals `true`.\n     *\n     * The function is executed for each data cell and may be called more than once\n     * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))\n     */\n\n\n    set cellSelected(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`cellSelected must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this._cellSelected = fn;\n    }\n\n    get cellSelected() {\n      return this._cellSelected;\n    }\n    /**\n     * Returns the currently focused cell (if any).\n     */\n\n\n    get activeCell() {\n      return this.navigationService.activeCell;\n    }\n    /**\n     * Returns the currently focused row (if any).\n     */\n\n\n    get activeRow() {\n      return this.navigationService.activeRow;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    get hostClasses() {\n      return true;\n    }\n\n    get lockedClasses() {\n      return this.lockedLeafColumns.length > 0;\n    }\n\n    get virtualClasses() {\n      return this.isVirtual;\n    }\n\n    get noScrollbarClass() {\n      return this.scrollbarWidth === 0;\n    }\n\n    get detailTemplate() {\n      if (this._customDetailTemplate) {\n        return this._customDetailTemplate;\n      }\n\n      return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;\n    }\n\n    set detailTemplate(detailTemplate) {\n      this._customDetailTemplate = detailTemplate;\n    }\n\n    get cellLoadingTemplate() {\n      if (this._cellLoadingTemplate) {\n        return this._customDetailTemplate;\n      }\n\n      return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : undefined;\n    }\n\n    set cellLoadingTemplate(cellLoadingTemplate) {\n      this._cellLoadingTemplate = cellLoadingTemplate;\n    }\n\n    get loadingTemplate() {\n      if (this._loadingTemplate) {\n        return this._loadingTemplate;\n      }\n\n      return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : undefined;\n    }\n\n    set loadingTemplate(loadingTemplate) {\n      this._loadingTemplate = loadingTemplate;\n    }\n\n    get noRecordsTemplate() {\n      if (this._customNoRecordsTemplate) {\n        return this._customNoRecordsTemplate;\n      }\n\n      return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;\n    }\n\n    set noRecordsTemplate(customNoRecordsTemplate) {\n      this._customNoRecordsTemplate = customNoRecordsTemplate;\n    }\n\n    get pagerTemplate() {\n      if (this._customPagerTemplate) {\n        return this._customPagerTemplate;\n      }\n\n      return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;\n    }\n\n    set pagerTemplate(customPagerTemplate) {\n      this._customPagerTemplate = customPagerTemplate;\n    }\n\n    get toolbarTemplate() {\n      if (this._customToolbarTemplate) {\n        return this._customToolbarTemplate;\n      }\n\n      return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;\n    }\n\n    set toolbarTemplate(customToolbarTemplate) {\n      this._customToolbarTemplate = customToolbarTemplate;\n    }\n\n    get scrollbarWidth() {\n      return this.supportService.scrollbarWidth;\n    }\n\n    get headerPadding() {\n      if (isUniversal()) {\n        return \"\";\n      }\n\n      const padding = Math.max(0, this.scrollbarWidth) + 'px';\n      const right = this.rtl ? 0 : padding;\n      const left = this.rtl ? padding : 0;\n      return `0 ${right} 0 ${left}`;\n    }\n\n    get hasGroupFooters() {\n      return this.columnsContainer.hasGroupFooter;\n    }\n\n    get showFooter() {\n      return this.columnsContainer.hasFooter;\n    }\n\n    get showGroupFooters() {\n      return this.groupable && this.groupable.showFooter;\n    }\n\n    get ariaRowCount() {\n      return this.totalColumnLevels + 1 + this.view.total;\n    }\n\n    get ariaColCount() {\n      return this.columnsContainer.leafColumnsToRender.length;\n    }\n\n    get navigation() {\n      return this.navigationService;\n    }\n\n    get isVirtual() {\n      return this.scrollable === 'virtual';\n    }\n\n    get isScrollable() {\n      return this.scrollable !== 'none';\n    }\n\n    get visibleColumns() {\n      return this.columnsContainer.allColumns;\n    }\n\n    get lockedColumns() {\n      return this.columnsContainer.lockedColumns;\n    }\n\n    get nonLockedColumns() {\n      return this.columnsContainer.nonLockedColumns;\n    }\n\n    get lockedLeafColumns() {\n      return this.columnsContainer.lockedLeafColumns;\n    }\n\n    get stickyColumns() {\n      return this.columns.filter(column => column.sticky);\n    }\n\n    get nonLockedLeafColumns() {\n      return this.columnsContainer.nonLockedLeafColumns;\n    }\n\n    get leafColumns() {\n      return this.columnsContainer.leafColumns;\n    }\n\n    get totalColumnLevels() {\n      return this.columnsContainer.totalLevels;\n    }\n\n    get headerColumns() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.viewportColumns;\n      }\n\n      return this.nonLockedColumns;\n    }\n\n    get headerLeafColumns() {\n      if (this.virtualColumns && !this.pdfService.exporting) {\n        return this.leafViewportColumns;\n      }\n\n      return this.nonLockedLeafColumns;\n    }\n\n    get lockedWidth() {\n      const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;\n      return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);\n    }\n\n    get nonLockedWidth() {\n      if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {\n        return !this.virtualColumns ? this.columnsContainer.unlockedWidth : this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);\n      }\n\n      return undefined;\n    }\n\n    get selectableSettings() {\n      if (this.selectionService) {\n        return this.selectionService.options;\n      }\n\n      return undefined;\n    }\n\n    get columnMenuTemplate() {\n      const template = this.columnMenuTemplates.first;\n      return template ? template.templateRef : null;\n    }\n\n    get totalCount() {\n      if (this.isVirtual || !isPresent(this.pageSize)) {\n        return this.view.total;\n      }\n\n      return this.pageSize;\n    }\n    /**\n     * Expands the specified master row ([see example]({% slug hierarchy_grid %})).\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded state internally using the data row index.\n     *\n     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})\n     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})\n     * for examples on how to control the expanded state.\n     *\n     * @param index - The data row index of the master row.\n     */\n\n\n    expandRow(index) {\n      this.toggleDetailRowLegacy(index, true);\n    }\n    /**\n     * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded state internally using the data row index.\n     *\n     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})\n     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})\n     * for examples on how to control the expanded state.\n     *\n     * @param index - The data row index of the master row.\n     */\n\n\n    collapseRow(index) {\n      this.toggleDetailRowLegacy(index, false);\n    }\n    /**\n     * Expands a group header item for the given index. For example,\n     * `0_1` expands the second inner group of the first master group.\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded group state internally using the hierarchical group index.\n     *\n     * > * When you use the [kendoGridGroupBinding]({% slug api_grid_groupbindingdirective %}) directive,\n     * > the `expandGroup` method is not supported.\n     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n\n\n    expandGroup(index) {\n      this.toggleGroupRowLegacy(index, true);\n    }\n    /**\n     * Collapses a group header item for the given index. For example,\n     * `0_1` collapses the second inner group of the first master group.\n     *\n     * This method is provided only for backwards-compatibility with legacy versions.\n     * These versions tracked the expanded group state internally using the hierarchical group index.\n     *\n     * > * When you use the [kendoGridGroupBinding]({% slug api_grid_groupbindingdirective %}) directive,\n     * > the `collapseGroup` method is not supported.\n     * > * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).\n     *\n     * @param {string} index - The underscore separated hierarchical index of the group.\n     */\n\n\n    collapseGroup(index) {\n      this.toggleGroupRowLegacy(index, false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    resetGroupsState() {\n      this.groupsService.reset();\n    }\n    /**\n     * @hidden\n     */\n\n\n    expandGroupChildren(groupIndex) {\n      this.groupsService.expandChildren(groupIndex);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDataChange() {\n      this.autoGenerateColumns();\n      this.changeNotification.notify();\n      this.pdfService.dataChanged.emit();\n\n      if (isPresent(this.defaultSelection)) {\n        this.defaultSelection.reset();\n      }\n\n      this.initSelectionService();\n      this.updateNavigationMetadata();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged$1(\"data\", changes)) {\n        this.onDataChange();\n      }\n\n      if (this.lockedLeafColumns.length && anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\"], changes)) {\n        this.changeNotification.notify();\n      }\n\n      if (anyChanged([\"pageSize\", \"scrollable\", 'virtualColumns'], changes)) {\n        this.updateNavigationMetadata();\n      }\n\n      if (isChanged$1(\"virtualColumns\", changes)) {\n        this.viewportColumns = this.leafViewportColumns = null;\n      }\n\n      if (isChanged$1(\"height\", changes, false)) {\n        this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);\n      }\n\n      if (isChanged$1(\"filterable\", changes) && this.lockedColumns.length) {\n        this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));\n      }\n\n      if (anyChanged([\"columnMenu\", \"sortable\", \"filterable\"], changes, false)) {\n        this.columnMenuOptions = this.columnMenu && Object.assign({\n          filter: Boolean(this.filterable),\n          sort: Boolean(this.sortable)\n        }, this.columnMenu);\n      }\n\n      if (isChanged$1(\"scrollable\", changes) && this.isScrollable) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());\n      }\n\n      if (isChanged$1(\"selectable\", changes) && this.shouldResetSelection(changes.selectable)) {\n        if (this.defaultSelection) {\n          this.defaultSelection.reset();\n        } else if (this.selectionDirective) {\n          this.selectionDirective.reset();\n        }\n      }\n\n      if (isChanged$1('groupable', changes, true)) {\n        this.groupable = changes.groupable.currentValue;\n      }\n\n      if (isChanged$1('navigable', changes, true)) {\n        if (this.navigationService.enabled) {\n          this.navigationService.setActiveSections(this.navigable);\n        } else {\n          if (this.navigable.length) {\n            this.navigationService.init(this.navigationMetadata(), this.navigable);\n          }\n        }\n      }\n    }\n\n    ngAfterViewInit() {\n      this.attachScrollSync();\n      this.attachElementEventHandlers();\n      this.updateNavigationMetadata();\n      this.applyAutoSize();\n    }\n\n    ngAfterContentChecked() {\n      this.columnsContainer.refresh();\n      this.verifySettings();\n      this.initSelectionService();\n    }\n\n    ngAfterContentInit() {\n      this.shouldGenerateColumns = !this.columns.length;\n      this.autoGenerateColumns();\n      this.columnList = new ColumnList(this.columns);\n      this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());\n    }\n\n    ngOnInit() {\n      if (this.navigable.length) {\n        this.navigationService.init(this.navigationMetadata(), this.navigable);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.selectionSubscription) {\n        this.selectionSubscription.unsubscribe();\n      }\n\n      if (this.stateChangeSubscription) {\n        this.stateChangeSubscription.unsubscribe();\n      }\n\n      if (this.groupExpandCollapseSubscription) {\n        this.groupExpandCollapseSubscription.unsubscribe();\n      }\n\n      if (this.detailsServiceSubscription) {\n        this.detailsServiceSubscription.unsubscribe();\n      }\n\n      if (this.editServiceSubscription) {\n        this.editServiceSubscription.unsubscribe();\n      }\n\n      if (this.pdfSubscription) {\n        this.pdfSubscription.unsubscribe();\n      }\n\n      if (this.filterSubscription) {\n        this.filterSubscription.unsubscribe();\n      }\n\n      if (this.sortSubscription) {\n        this.sortSubscription.unsubscribe();\n      }\n\n      if (this.columnsChangeSubscription) {\n        this.columnsChangeSubscription.unsubscribe();\n      }\n\n      if (this.excelSubscription) {\n        this.excelSubscription.unsubscribe();\n      }\n\n      if (this.columnsContainerChangeSubscription) {\n        this.columnsContainerChangeSubscription.unsubscribe();\n      }\n\n      if (this.scrollSyncService) {\n        this.scrollSyncService.destroy();\n      }\n\n      if (this.detachElementEventHandlers) {\n        this.detachElementEventHandlers();\n      }\n\n      if (this.defaultSelection) {\n        this.defaultSelection.destroy();\n      }\n\n      if (this.cellClickSubscription) {\n        this.cellClickSubscription.unsubscribe();\n      }\n\n      if (this.footerChangeSubscription) {\n        this.footerChangeSubscription.unsubscribe();\n      }\n\n      this.ngZone = null;\n\n      if (this.columnResizingSubscription) {\n        this.columnResizingSubscription.unsubscribe();\n      }\n\n      if (this.columnReorderSubscription) {\n        this.columnReorderSubscription.unsubscribe();\n      }\n\n      if (this.localizationSubscription) {\n        this.localizationSubscription.unsubscribe();\n      }\n\n      if (this.columnVisibilityChangeSubscription) {\n        this.columnVisibilityChangeSubscription.unsubscribe();\n      }\n\n      if (this.columnLockedChangeSubscription) {\n        this.columnLockedChangeSubscription.unsubscribe();\n      }\n\n      if (this.columnStickyChangeSubscription) {\n        this.columnStickyChangeSubscription.unsubscribe();\n      }\n\n      if (this.focusElementSubscription) {\n        this.focusElementSubscription.unsubscribe();\n      }\n\n      this.columnRangeChangeSubscription.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    attachScrollSync() {\n      if (isUniversal()) {\n        return;\n      }\n\n      if (this.header) {\n        this.scrollSyncService.registerEmitter(this.header.nativeElement, \"header\");\n      }\n\n      if (this.footer) {\n        this.footerChangeSubscription = observe(this.footer).subscribe(footers => footers.map(footer => footer.nativeElement).filter(isPresent).forEach(element => this.scrollSyncService.registerEmitter(element, \"footer\")));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get ariaLabel() {\n      return this.localization.get('gridLabel');\n    }\n    /**\n     * Switches the specified table row in the edit mode ([see example]({% slug editing_template_forms_grid %}#toc-editing-records)).\n     *\n     * @param rowIndex - The data row index that will be switched in the edit mode.\n     * @param group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }})\n     * that describes the edit form.\n     * @param options - Additional options configuring the focus target once the editor opens.\n     */\n\n\n    editRow(rowIndex, group, options) {\n      this.editService.editRow(rowIndex, group);\n\n      if (isPresent(options) && options.skipFocus) {\n        return;\n      }\n\n      const row = `tr[data-kendo-grid-item-index=\"${rowIndex}\"]`;\n      const columnIndex = options && options.columnIndex;\n      const target = isNaN(columnIndex) ? row : `${row} td[data-kendo-grid-column-index=\"${columnIndex}\"]`;\n      this.focusEditElement(target);\n    }\n    /**\n     * Closes the editor for a given row ([see example]({% slug editing_template_forms_grid %}#toc-cancelling-editing)).\n     *\n     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed\n     * that the new item editor will be closed.\n     */\n\n\n    closeRow(index) {\n      this.editService.close(index);\n    }\n    /**\n     * Creates a new row editor ([see example]({% slug editing_template_forms_grid %}#toc-adding-records)).\n     *\n     * @param {FormGroup} group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }}) that describes\n     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.\n     */\n\n\n    addRow(group) {\n      const isFormGroup = group instanceof FormGroup;\n\n      if (!isFormGroup) {\n        const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?\n\n        group = new FormGroup(fields);\n      }\n\n      this.editService.addRow(group);\n      this.focusEditElement('.k-grid-add-row');\n    }\n    /**\n     * Puts the cell that is specified by the table row and column in edit mode.\n     *\n     * @param {number} rowIndex - The data row index that will be switched in the edit mode.\n     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.\n     * @param {FormGroup} group - The [FormGroup]({{ site.data.urls.angular['formgroupapi'] }})\n     * that describes the edit form.\n     */\n\n\n    editCell(rowIndex, column, group) {\n      const instance = this.columnInstance(column);\n      this.editService.editCell(rowIndex, instance, group);\n      this.focusEditElement('.k-grid-edit-cell');\n    }\n    /**\n     * Closes the current cell in edit mode and fires\n     * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.\n     *\n     * @return {boolean} Indicates whether the edited cell was closed.\n     * A `false` value indicates that the\n     * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.\n     */\n\n\n    closeCell() {\n      return !this.editService.closeCell();\n    }\n    /**\n     * Closes the current cell in edit mode.\n     */\n\n\n    cancelCell() {\n      this.editService.cancelCell();\n    }\n    /**\n     * Returns a flag which indicates if a row or a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a row or a cell is currently edited.\n     */\n\n\n    isEditing() {\n      return this.editService.isEditing();\n    }\n    /**\n     * Returns a flag which indicates if a cell is currently edited.\n     *\n     * @return {boolean} A flag which indicates if a cell is currently being edited.\n     */\n\n\n    isEditingCell() {\n      return this.editService.isEditingCell();\n    }\n    /**\n     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).\n     */\n\n\n    saveAsPDF() {\n      this.pdfService.save(this);\n    }\n    /**\n     * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.\n     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).\n     *\n     * @return {Promise} - A promise that will be resolved with the Drawing `Group`.\n     */\n\n\n    drawPDF() {\n      const promise = createPromise();\n      this.pdfService.draw(this, promise);\n      return promise;\n    }\n    /**\n     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).\n     */\n\n\n    saveAsExcel() {\n      this.excelService.save(this);\n    }\n    /**\n     * Applies the minimum possible width for the specified column,\n     * so that the whole text fits without wrapping. This method expects the Grid\n     * to be resizable (set `resizable` to `true`).\n     * Makes sense to execute this method only\n     * after the Grid is already populated with data.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid\n     *            #grid\n     *            [data]=\"gridData\"\n     *            [resizable]=\"true\"\n     *            style=\"height: 300px\">\n     *            <ng-template kendoGridToolbarTemplate>\n     *                 <button kendoButton (click)=\"grid.autoFitColumn(groupColumn)\">\n     *                     Auto-fit the group column\n     *                 </button>\n     *            </ng-template>\n     *            <kendo-grid-column-group #groupColumn title=\"Product Info\">\n     *                <kendo-grid-column\n     *                    field=\"ProductID\"\n     *                    [width]=\"50\"\n     *                    [minResizableWidth]=\"30\"\n     *                    title=\"ID\">\n     *                </kendo-grid-column>\n     *\n     *                <kendo-grid-column\n     *                    field=\"ProductName\"\n     *                    title=\"Product Name\">\n     *                </kendo-grid-column>\n     *            </kendo-grid-column-group>\n     *\n     *            <kendo-grid-column\n     *                field=\"UnitPrice\"\n     *                title=\"Unit Price\"\n     *                [width]=\"180\"\n     *                filter=\"numeric\"\n     *                format=\"{0:c}\">\n     *            </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n\n\n    autoFitColumn(column) {\n      this.columnResizingService.autoFit(column);\n    }\n    /**\n     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.\n     * If no columns are specified, `autoFitColumns` is applied to all columns.\n     *\n     * This method requires the Grid to be resizable (set `resizable` to `true`).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *      <kendo-grid\n     *          #grid\n     *          [data]=\"gridData\"\n     *          [resizable]=\"true\"\n     *          style=\"height: 300px\">\n     *          <ng-template kendoGridToolbarTemplate>\n     *              <button kendoButton (click)=\"grid.autoFitColumns([firstColumn, lastColumn])\">\n     *                  Auto-fit the first and last column\n     *              </button>\n     *              <button kendoButton (click)=\"grid.autoFitColumns()\">\n     *                  Auto-fit all columns\n     *              </button>\n     *          </ng-template>\n     *          <kendo-grid-column-group title=\"Product Info\">\n     *              <kendo-grid-column\n     *                  #firstColumn\n     *                  field=\"ProductID\"\n     *                  [width]=\"50\"\n     *                  [minResizableWidth]=\"30\"\n     *                  title=\"ID\">\n     *              </kendo-grid-column>\n     *\n     *              <kendo-grid-column\n     *                  field=\"ProductName\"\n     *                  title=\"Product Name\"\n     *                  >\n     *              </kendo-grid-column>\n     *          </kendo-grid-column-group>\n     *\n     *          <kendo-grid-column\n     *              #lastColumn\n     *              field=\"UnitPrice\"\n     *              title=\"Unit Price\"\n     *              [width]=\"180\"\n     *              filter=\"numeric\"\n     *              format=\"{0:c}\">\n     *          </kendo-grid-column>\n     *      </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n\n\n    autoFitColumns(columns = this.columns) {\n      let cols;\n\n      if (columns instanceof QueryList) {\n        cols = columns.toArray();\n      } else {\n        cols = columns;\n      }\n\n      this.columnResizingService.autoFit(...cols);\n    }\n    /**\n     * @hidden\n     */\n\n\n    notifyPageChange(source, event) {\n      if (source === \"list\" && !this.isVirtual) {\n        return;\n      }\n\n      this.pageChange.emit(event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    notifyScrollBottom() {\n      if (this.scrollable === 'none') {\n        return;\n      }\n\n      if (hasObservers(this.scrollBottom)) {\n        this.ngZone.run(() => this.scrollBottom.emit({\n          sender: this\n        }));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    focusEditElement(containerSelector) {\n      if (this.focusElementSubscription) {\n        this.focusElementSubscription.unsubscribe();\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          const wrapper = this.wrapper.nativeElement;\n\n          if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {\n            this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));\n          }\n\n          this.focusElementSubscription = null;\n        });\n      });\n    }\n    /**\n     * Focuses the last active or the first cell of the Grid.\n     *\n     * @returns {NavigationCell} The focused cell.\n     */\n\n\n    focus() {\n      this.assertNavigable();\n      return this.navigationService.focusCell();\n    }\n    /**\n     * Focuses the cell with the specified row and column index.\n     *\n     * The row index is based on the logical structure of the Grid and does not correspond to the data item index:\n     * * Header rows are included, starting at index 0.\n     * * Group headers and footers are included.\n     * * The row indexing is absolute and does not change with paging.\n     *\n     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.\n     * If the row is not present on the current page, the method will have no effect.\n     *\n     * @param rowIndex - The logical row index to focus. The top header row has an index 0.\n     * @param colIndex - The column index to focus.\n     * @returns {NavigationCell} The focused cell.\n     *\n     */\n\n\n    focusCell(rowIndex, colIndex) {\n      this.assertNavigable();\n      return this.navigationService.focusCell(rowIndex, colIndex);\n    }\n    /**\n     * Focuses the next cell, optionally wrapping to the next row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.\n     */\n\n\n    focusNextCell(wrap = true) {\n      this.assertNavigable();\n      return this.navigationService.focusNextCell(wrap);\n    }\n    /**\n     * Focuses the previous cell. Optionally wraps to the previous row.\n     *\n     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.\n     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.\n     */\n\n\n    focusPrevCell(wrap = true) {\n      this.assertNavigable();\n      return this.navigationService.focusPrevCell(wrap);\n    }\n    /**\n     * Scrolls to the specified row and column ([see example]({% slug scrollmmodes_grid %}#toc-scrolling-to-a-specific-row-and-column-index)).\n     */\n\n\n    scrollTo(request) {\n      this.scrollRequestService.scrollTo(request);\n    }\n    /**\n     * Changes the position of the specified column.\n     * The reordering of columns operates only on the level\n     * which is inferred by the source column.\n     * For the `reorderColumn` method to work properly,\n     * the `source` column has to be visible.\n     *\n     * @param {ColumnBase} source - The column whose position will be changed.\n     * @param {number} destIndex - The new position of the column.\n     * @param {ColumnReorderConfig} options - Additional options.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-grid\n     *            #grid\n     *            [data]=\"gridData\"\n     *            [reorderable]=\"true\"\n     *            style=\"height: 300px\">\n     *            <ng-template kendoGridToolbarTemplate>\n     *                 <button kendoButton\n     *                     (click)=\"grid.reorderColumn(groupColumn, 2, { before: true })\">\n     *                     Move the group column before the last one.\n     *                 </button>\n     *            </ng-template>\n     *            <kendo-grid-column-group #groupColumn title=\"Product Info\">\n     *                <kendo-grid-column\n     *                    field=\"ProductID\"\n     *                    [width]=\"50\"\n     *                    title=\"ID\">\n     *                </kendo-grid-column>\n     *\n     *                <kendo-grid-column\n     *                    field=\"ProductName\"\n     *                    title=\"Product Name\">\n     *                </kendo-grid-column>\n     *            </kendo-grid-column-group>\n     *\n     *            <kendo-grid-column\n     *                field=\"UnitPrice\"\n     *                title=\"Unit Price\"\n     *                [width]=\"180\"\n     *                format=\"{0:c}\">\n     *            </kendo-grid-column>\n     *\n     *            <kendo-grid-column\n     *                field=\"Discontinued\"\n     *                title=\"Discontinued\"\n     *                [width]=\"100\">\n     *            </kendo-grid-column>\n     *        </kendo-grid>\n     *    `\n     * })\n     * class AppComponent {\n     *    public gridData: any[] = products;\n     * }\n     *\n     * const products = [{\n     *    \"ProductID\": 1,\n     *    \"ProductName\": \"Chai\",\n     *    \"UnitPrice\": 18.0000,\n     *    \"Discontinued\": true\n     *  }, {\n     *    \"ProductID\": 2,\n     *    \"ProductName\": \"Chang\",\n     *    \"UnitPrice\": 19.0000,\n     *    \"Discontinued\": false\n     *  }\n     * ];\n     * ```\n     */\n\n\n    reorderColumn(source, destIndex, options = {\n      before: false\n    }) {\n      const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));\n      let target = columnsForLevel[destIndex];\n\n      if (!target) {\n        return;\n      }\n\n      const lastNonLocked = target.isLocked && !source.isLocked && this.columnsContainer.nonLockedColumns.length === 1;\n\n      if (lastNonLocked) {\n        return;\n      }\n\n      if (isSpanColumnComponent(target) && !options.before) {\n        target = target.childColumns.last;\n      }\n\n      this.reorder({\n        before: options.before,\n        source: source,\n        target: target\n      });\n    }\n    /**\n     * A function which determines if a specific row is expanded.\n     */\n\n\n    set isDetailExpanded(callback) {\n      this.detailsService.userCallback = callback;\n    }\n\n    get isDetailExpanded() {\n      return this.detailsService.userCallback;\n    }\n    /**\n     * A function which determines if a specific group row is expanded.\n     */\n\n\n    set isGroupExpanded(callback) {\n      this.groupsService.userCallback = callback;\n      this.groupable = isPresent(callback);\n    }\n\n    get isGroupExpanded() {\n      return this.groupsService.userCallback;\n    }\n    /**\n     * @hidden\n     */\n\n\n    reorder({\n      target,\n      source,\n      before,\n      changeContainer\n    }) {\n      this.ngZone.run(() => {\n        const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));\n        let newIndex = columnsForLevel.indexOf(target);\n\n        if (target.parent && target.parent.isSpanColumn) {\n          newIndex = columnsForLevel.indexOf(target.parent);\n\n          if (before) {\n            target = target.parent;\n          }\n        }\n\n        let oldIndex = columnsForLevel.indexOf(source);\n\n        if (changeContainer) {\n          if (before && 0 < newIndex && oldIndex < newIndex) {\n            // dropped before the first not locked column\n            newIndex--;\n          } else if (!before && oldIndex > newIndex) {\n            // dropped after the last locked column\n            newIndex++;\n          }\n        }\n\n        const args = new ColumnReorderEvent({\n          column: source,\n          oldIndex: oldIndex,\n          newIndex: newIndex\n        });\n        this.columnReorder.emit(args);\n\n        if (args.isDefaultPrevented()) {\n          return;\n        }\n\n        if (changeContainer) {\n          this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));\n        }\n\n        this.updateColumnIndices({\n          columnsForLevel,\n          source,\n          target,\n          before\n        });\n\n        if (source.locked !== target.locked) {\n          source.locked = target.locked;\n        }\n\n        this.columnsContainer.refresh();\n        this.changeDetectorRef.markForCheck();\n      });\n    }\n\n    updateColumnIndices({\n      columnsForLevel,\n      source,\n      target,\n      before\n    }) {\n      const expandedColumns = expandColumnsWithSpan(columnsForLevel);\n      const sourceColumnIndex = expandedColumns.indexOf(source);\n      let nextSourceIndex = 0;\n      let nextIndex = 0;\n      let toSkip = 1; // Possible only when called from the API.\n\n      if (source.isSpanColumn) {\n        toSkip += source.childColumns.length;\n      }\n\n      let i = 0;\n\n      while (i < expandedColumns.length) {\n        let column = expandedColumns[i];\n\n        if (column === target) {\n          nextSourceIndex = before ? nextIndex : nextIndex + 1;\n          nextIndex = before ? nextIndex + toSkip : nextIndex;\n          column.orderIndex = nextIndex;\n\n          if (nextSourceIndex === nextIndex + 1) {\n            nextIndex += toSkip;\n          }\n        } else if (column === source) {\n          i += toSkip;\n          continue;\n        } else {\n          column.orderIndex = nextIndex;\n        }\n\n        nextIndex++;\n        i++;\n      }\n\n      for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {\n        expandedColumns[i].orderIndex = nextSourceIndex++;\n      }\n\n      this.updateIndicesForLevel(source.level + 1);\n    }\n\n    updateIndicesForLevel(level) {\n      const colsForParentLevel = this.allColumnsForLevel(level - 1);\n      const colsForLevel = [];\n      sortColumns(colsForParentLevel).forEach(c => {\n        if (c.isColumnGroup) {\n          colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));\n        }\n      });\n      expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);\n\n      if (level < this.columnList.totalColumnLevels()) {\n        this.updateIndicesForLevel(level + 1);\n      }\n    }\n\n    allColumnsForLevel(level) {\n      return this.columnList.toArray().filter(column => column.level === level);\n    }\n\n    initSelectionService() {\n      if (!this.selectable) {\n        this.selectionService.ngOnDestroy();\n        this.cellSelectionService.ngOnDestroy();\n        return;\n      }\n\n      if (!this.selectionDirective && !isPresent(this.defaultSelection)) {\n        this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);\n      }\n\n      const cellSelectionMode = this.selectable['cell'];\n      const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;\n      const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;\n\n      if (inactiveService.active) {\n        inactiveService.ngOnDestroy();\n        activeService.addSubscriptions();\n        inactiveService.active = false;\n      }\n\n      activeService.active = true;\n      activeService.init({\n        cellSelected: cellSelectionMode ? this.cellSelected : undefined,\n        rowSelected: cellSelectionMode ? undefined : this.rowSelected,\n        selectable: this.selectable,\n        view: this.view,\n        columns: cellSelectionMode ? this.columnList.toArray() : undefined\n      });\n\n      if (!this.selectionDirective && !this.selectableSettings.enabled) {\n        this.defaultSelection.reset();\n      }\n\n      if (this.selectionSubscription) {\n        this.selectionSubscription.unsubscribe();\n      }\n\n      if (cellSelectionMode) {\n        this.selectionSubscription = this.cellSelectionService.changes.subscribe(event => {\n          this.ngZone.run(() => this.selectionChange.emit(event));\n        });\n      } else {\n        this.selectionSubscription = this.selectionService.changes.subscribe(event => {\n          this.ngZone.run(() => this.selectionChange.emit(event));\n        });\n      }\n    }\n\n    setEditFocus(element) {\n      if (element) {\n        return this.navigationService.tryFocus(element);\n      }\n    }\n\n    columnInstance(column) {\n      let instance;\n\n      if (typeof column === 'number') {\n        instance = this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];\n      } else if (typeof column === 'string') {\n        instance = this.columnList.filter(item => item.field === column)[0];\n      } else {\n        instance = column;\n      }\n\n      if (!instance && isDevMode()) {\n        throw new Error(`Invalid column ${column}`);\n      }\n\n      return instance;\n    }\n\n    verifySettings() {\n      if (isDevMode()) {\n        const locked = this.lockedLeafColumns.length || this.columnMenu && this.columnMenu.lock;\n        const stickyColumns = this.stickyColumns.length || this.columnMenu && this.columnMenu.stick;\n\n        if (locked && this.detailTemplate) {\n          throw new Error('Having both detail template and locked columns is not supported.');\n        }\n\n        if (stickyColumns && this.detailTemplate) {\n          throw new Error('Having both detail template and sticky columns is not supported.');\n        }\n\n        if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {\n          throw new Error('There should be at least one non-locked column');\n        }\n\n        if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {\n          throw new Error((locked ? 'Locked' : 'Virtual') + ' columns feature requires all columns to have set width.');\n        }\n\n        if (locked && !this.isScrollable) {\n          throw new Error('Locked columns are only supported when scrolling is enabled.');\n        }\n\n        if (this.columnList.filter(isColumnGroupComponent).filter(x => !x.hasChildren).length) {\n          throw new Error('ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.');\n        }\n\n        if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {\n          throw new Error('Locked child columns require their parent columns to be locked.');\n        }\n\n        if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {\n          throw new Error('Row height and detail row height settings require virtual scrolling mode to be enabled.');\n        }\n\n        if (stickyColumns && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {\n          throw new Error('Sticky columns feature requires all columns to have set width.');\n        }\n\n        if (stickyColumns && !this.isScrollable) {\n          throw new Error('Sticky columns are only supported when scrolling is enabled.');\n        }\n\n        if (stickyColumns && this.virtualColumns) {\n          throw new Error('Having both sticky columns and column virtualization is not supported.');\n        }\n\n        if (this.rowSticky && this.scrollable === 'virtual') {\n          throw new Error('Having both sticky rows and row virtualization (scrollable=\"virtual\") is not supported.');\n        }\n\n        if (this.rowSticky && this.groupable) {\n          throw new Error('Having both sticky rows and grouping is not supported.');\n        }\n\n        validateColumnsField(this.columnList);\n      }\n    }\n\n    autoGenerateColumns() {\n      if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {\n        this.columns.reset(Object.keys(this.view.at(0)).map(field => {\n          let column = new ColumnComponent();\n          column.field = field;\n          return column;\n        }));\n      }\n    }\n\n    attachStateChangesEmitter() {\n      this.stateChangeSubscription = merge(this.pageChange.pipe(map(x => ({\n        filter: this.filter,\n        group: this.group,\n        skip: x.skip,\n        sort: this.sort,\n        take: x.take\n      }))), this.sortChange.pipe(map(sort => ({\n        filter: this.filter,\n        group: this.group,\n        skip: this.skip,\n        sort: sort,\n        take: this.pageSize\n      }))), this.groupChange.pipe(map(group => ({\n        filter: this.filter,\n        group: group,\n        skip: this.skip,\n        sort: this.sort,\n        take: this.pageSize\n      }))), this.filterChange.pipe(map(filter => ({\n        filter: filter,\n        group: this.group,\n        skip: 0,\n        sort: this.sort,\n        take: this.pageSize\n      })))).subscribe(x => {\n        this.closeCell();\n        this.cancelCell();\n        this.dataStateChange.emit(x);\n      });\n    }\n\n    attachEditHandlers() {\n      if (!this.editService) {\n        return;\n      }\n\n      this.editServiceSubscription = this.editService.changes.subscribe(this.emitCRUDEvent.bind(this));\n    }\n\n    emitCRUDEvent(args) {\n      const {\n        action,\n        rowIndex,\n        formGroup\n      } = args;\n      let dataItem = this.view.at(rowIndex - this.skip);\n\n      if (action !== 'add' && !dataItem) {\n        dataItem = formGroup.value;\n      }\n\n      this.closeCell();\n      Object.assign(args, {\n        dataItem: dataItem,\n        sender: this\n      });\n\n      switch (action) {\n        case 'add':\n          this.add.emit(args);\n          break;\n\n        case 'cancel':\n          this.cancel.emit(args);\n          break;\n\n        case 'edit':\n          this.edit.emit(args);\n          break;\n\n        case 'remove':\n          this.remove.emit(args);\n          break;\n\n        case 'save':\n          this.save.emit(args);\n          break;\n\n        case 'cellClose':\n          this.cellClose.emit(args);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    attachDomEventHandlers() {\n      this.cellClickSubscription = this.domEvents.cellClick.subscribe(args => {\n        this.cellClick.emit(Object.assign({\n          sender: this\n        }, args));\n      });\n    }\n\n    attachElementEventHandlers() {\n      if (isUniversal()) {\n        return;\n      }\n\n      const wrapper = this.wrapper.nativeElement;\n      const ariaRoot = this.ariaRoot.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        const resizeCheck = this.resizeCheck.bind(this);\n        const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);\n        const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);\n        const documentClickSubscription = this.renderer.listen('document', 'click', args => {\n          const activeElement = document.activeElement;\n\n          if (this.editService.shouldCloseCell() && !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) && !(activeElement && (closest(activeElement, matchesClasses('k-animation-container')) || isInEditedCell(activeElement, this.wrapper.nativeElement)))) {\n            this.editService.closeCell(args);\n          }\n        });\n        const windowBlurSubscription = this.renderer.listen('window', 'blur', args => {\n          const activeElement = document.activeElement;\n\n          if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' && isInEditedCell(activeElement, this.wrapper.nativeElement))) {\n            this.editService.closeCell(args);\n          }\n\n          this.domEvents.windowBlur.emit(args);\n        });\n        const clickSubscription = this.renderer.listen(wrapper, 'click', args => {\n          this.domEvents.click.emit(args);\n        });\n        const keydownSubscription = this.renderer.listen(wrapper, 'keydown', args => {\n          this.domEvents.keydown.emit(args);\n        }); // focusIn and focusOut are relative to the element with ARIA role \"grid\"\n\n        let focused = false;\n        const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', args => {\n          this.domEvents.focus.emit(args);\n\n          if (!focused) {\n            this.domEvents.focusIn.emit(args);\n            focused = true;\n          }\n        });\n        const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', args => {\n          const next = args.relatedTarget || document.activeElement;\n          const outside = !closest(next, node => node === ariaRoot);\n\n          if (outside) {\n            this.domEvents.focusOut.emit(args);\n            focused = false;\n          }\n        });\n\n        this.detachElementEventHandlers = () => {\n          resizeSubscription();\n          orientationSubscription();\n          documentClickSubscription();\n          windowBlurSubscription();\n          clickSubscription();\n          keydownSubscription();\n          focusInSubscription();\n          focusOutSubscription();\n        };\n      });\n    }\n\n    matchesMedia(c) {\n      return this.responsiveService.matchesMedia(c.media);\n    }\n\n    resizeCheck() {\n      if (window.innerWidth !== this.cachedWindowWidth) {\n        this.cachedWindowWidth = window.innerWidth;\n        let hasChanges = false;\n        this.columnList.filterHierarchy(column => {\n          const matchesMedia = this.matchesMedia(column);\n\n          if (column.matchesMedia !== matchesMedia) {\n            hasChanges = true;\n            column.matchesMedia = matchesMedia;\n          }\n\n          return column.isVisible;\n        });\n\n        if (hasChanges) {\n          this.ngZone.run(() => {\n            this.changeDetectorRef.markForCheck();\n          });\n        }\n      }\n    }\n\n    emitPDFExportEvent() {\n      const args = new PDFExportEvent();\n      this.pdfExport.emit(args);\n\n      if (!args.isDefaultPrevented()) {\n        this.saveAsPDF();\n      }\n    }\n\n    syncHeaderHeight(observable) {\n      return observable.pipe(filter(() => isPresent(this.lockedHeader))).subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));\n    }\n\n    columnsContainerChange() {\n      this.columnsContainerChangeSubscription = this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));\n    }\n\n    handleColumnResize() {\n      const resizes = this.columnResizingService.changes;\n      this.columnResizingSubscription = resizes.pipe(tap(e => {\n        if (e.type === 'start') {\n          this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n        } else if (e.type === 'end') {\n          this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');\n        }\n      }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe( // eslint-disable-next-line rxjs/no-unsafe-takeuntil\n      takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end')))).subscribe(this.notifyResize.bind(this));\n    }\n\n    notifyResize(e) {\n      const args = e.resizedColumns.filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup).map(item => ({\n        column: item.column,\n        newWidth: item.column.width,\n        oldWidth: item.oldWidth\n      }));\n      this.columnResize.emit(args);\n    }\n\n    assertNavigable() {\n      if (isDevMode() && !this.navigationService.enabled) {\n        throw new Error('The Grid should be configured as navigable to control focus');\n      }\n    }\n\n    navigationMetadata() {\n      const isVirtual = this.isVirtual;\n      const pageSize = this.pageSize;\n      const dataRows = isVirtual ? this.view.total : pageSize;\n      const addRowOffset = this.editService.hasNewItem ? 1 : 0;\n      const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;\n      const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;\n      return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);\n    }\n\n    updateNavigationMetadata() {\n      this.navigationService.metadata = this.navigationMetadata();\n    }\n\n    applyAutoSize() {\n      const cols = this.columns.filter(c => this.autoSize ? c.autoSize !== false : c.autoSize);\n\n      if (cols.length > 0) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(_ => this.autoFitColumns(cols));\n      }\n    }\n\n    onColumnRangeChange(range) {\n      const viewportColumns = this.viewportColumns = [];\n      const leafViewportColumns = this.columnsContainer.nonLockedLeafColumns.toArray().slice(range.start, range.end + 1);\n\n      for (let idx = 0; idx < leafViewportColumns.length; idx++) {\n        let column = leafViewportColumns[idx];\n\n        while (column.parent) {\n          column = column.parent;\n        }\n\n        const toAdd = [column];\n\n        while (toAdd.length) {\n          column = toAdd.shift();\n          viewportColumns.push(column);\n\n          if (column.isColumnGroup) {\n            toAdd.unshift.apply(toAdd, column.childrenArray);\n          }\n        }\n\n        const lastFromGroup = viewportColumns[viewportColumns.length - 1];\n        column = leafViewportColumns[idx];\n\n        while (column !== lastFromGroup && idx < leafViewportColumns.length) {\n          idx++;\n          column = leafViewportColumns[idx];\n        }\n      }\n\n      if (range.start > 0) {\n        const first = leafViewportColumns[0];\n        let offset = range.offset;\n        let current = viewportColumns[0];\n        let index = 0;\n\n        while (current !== first) {\n          offset -= current.isColumnGroup ? 0 : current.width;\n          index++;\n          current = viewportColumns[index];\n        }\n\n        if (offset > 0) {\n          const totalLevels = this.columnsContainer.totalLevels;\n          let previous;\n\n          for (let idx = 0; idx <= totalLevels; idx++) {\n            const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase(previous);\n            previous = offsetColumn;\n            offsetColumn.title = \"\\u00A0\";\n            offsetColumn.width = offset;\n            viewportColumns.unshift(offsetColumn);\n          }\n        }\n      }\n\n      this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);\n    }\n\n    toggleDetailRowLegacy(index, expand) {\n      const hasCallback = typeof this.isDetailExpanded === 'function';\n\n      if (isDevMode() && hasCallback) {\n        throw new Error('The expandRow and collapseRow methods should not be called when using the ' + 'kendoGridDetailsExpandBy directive or the isDetailExpanded callback. ' + 'These methods are provided only for backwards compatibility with legacy versions.');\n      }\n\n      if (!isDevMode() && hasCallback) {\n        return;\n      }\n\n      if (this.detailsService.isExpanded(index, null) !== expand) {\n        this.detailsService.toggleRow(index, null);\n      }\n    }\n\n    toggleGroupRowLegacy(index, expand) {\n      const hasCallback = typeof this.isGroupExpanded === 'function';\n\n      if (isDevMode() && hasCallback) {\n        throw new Error('The expandGroup and collapseGroup methods should not be called when using the ' + 'kendoGridExpandGroupBy directive or the isGroupExpanded callback. ' + 'These methods are provided only for backwards compatibility with legacy versions.');\n      }\n\n      if (!isDevMode() && hasCallback) {\n        return;\n      }\n\n      if (this.groupsService.isExpanded({\n        groupIndex: index\n      }) !== expand) {\n        this.groupsService.toggleRow({\n          index\n        });\n      }\n    }\n\n    shouldResetSelection(selectableChanges) {\n      const previousValue = selectableChanges.previousValue;\n\n      if (!previousValue) {\n        // Selection was disabled, no need to reset.\n        return false;\n      }\n\n      const currentValue = selectableChanges.currentValue;\n\n      if (!currentValue || currentValue.enabled === false) {\n        // Selection disabled, reset.\n        return true;\n      }\n\n      return previousValue.cell !== currentValue.cell;\n    }\n\n  }\n\n  GridComponent.ɵfac = function GridComponent_Factory(t) {\n    return new (t || GridComponent)(i0.ɵɵdirectiveInject(BrowserSupportService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(CellSelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(GroupInfoService), i0.ɵɵdirectiveInject(GroupsService), i0.ɵɵdirectiveInject(ChangeNotificationService), i0.ɵɵdirectiveInject(DetailsService), i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(ResponsiveService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ScrollSyncService), i0.ɵɵdirectiveInject(DomEventsService), i0.ɵɵdirectiveInject(ColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ColumnReorderService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SortService), i0.ɵɵdirectiveInject(ScrollRequestService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ContextService));\n  };\n\n  GridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GridComponent,\n    selectors: [[\"kendo-grid\"]],\n    contentQueries: function GridComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n        i0.ɵɵcontentQuery(dirIndex, DetailTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, CellLoadingTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, LoadingTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);\n      }\n    },\n    viewQuery: function GridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c53, 5);\n        i0.ɵɵviewQuery(_c54, 5);\n        i0.ɵɵviewQuery(_c55, 7);\n        i0.ɵɵviewQuery(_c56, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footer = _t);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function GridComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-grid\", ctx.hostClasses)(\"k-grid-lockedcolumns\", ctx.lockedClasses)(\"k-grid-virtual\", ctx.virtualClasses)(\"k-grid-no-scrollbar\", ctx.noScrollbarClass);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      pageSize: \"pageSize\",\n      height: \"height\",\n      rowHeight: \"rowHeight\",\n      detailRowHeight: \"detailRowHeight\",\n      skip: \"skip\",\n      scrollable: \"scrollable\",\n      selectable: \"selectable\",\n      sort: \"sort\",\n      trackBy: \"trackBy\",\n      filter: \"filter\",\n      group: \"group\",\n      virtualColumns: \"virtualColumns\",\n      filterable: \"filterable\",\n      sortable: \"sortable\",\n      pageable: \"pageable\",\n      groupable: \"groupable\",\n      navigable: \"navigable\",\n      navigatable: \"navigatable\",\n      autoSize: \"autoSize\",\n      rowClass: \"rowClass\",\n      rowSticky: \"rowSticky\",\n      rowSelected: \"rowSelected\",\n      cellSelected: \"cellSelected\",\n      resizable: \"resizable\",\n      reorderable: \"reorderable\",\n      loading: \"loading\",\n      columnMenu: \"columnMenu\",\n      hideHeader: \"hideHeader\",\n      isDetailExpanded: \"isDetailExpanded\",\n      isGroupExpanded: \"isGroupExpanded\"\n    },\n    outputs: {\n      filterChange: \"filterChange\",\n      pageChange: \"pageChange\",\n      groupChange: \"groupChange\",\n      sortChange: \"sortChange\",\n      selectionChange: \"selectionChange\",\n      dataStateChange: \"dataStateChange\",\n      groupExpand: \"groupExpand\",\n      groupCollapse: \"groupCollapse\",\n      detailExpand: \"detailExpand\",\n      detailCollapse: \"detailCollapse\",\n      edit: \"edit\",\n      cancel: \"cancel\",\n      save: \"save\",\n      remove: \"remove\",\n      add: \"add\",\n      cellClose: \"cellClose\",\n      cellClick: \"cellClick\",\n      pdfExport: \"pdfExport\",\n      excelExport: \"excelExport\",\n      columnResize: \"columnResize\",\n      columnReorder: \"columnReorder\",\n      columnVisibilityChange: \"columnVisibilityChange\",\n      columnLockedChange: \"columnLockedChange\",\n      columnStickyChange: \"columnStickyChange\",\n      scrollBottom: \"scrollBottom\",\n      contentScroll: \"contentScroll\"\n    },\n    exportAs: [\"kendoGrid\"],\n    features: [i0.ɵɵProvidersFeature([BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {\n      provide: CELL_CONTEXT,\n      useValue: EMPTY_CELL_CONTEXT\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.grid'\n    }, FilterService, ResponsiveService, PagerContextService, ExcelService, ScrollSyncService, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService, FocusRoot, IdService, ScrollRequestService, SortService, ContextService]), i0.ɵɵNgOnChangesFeature],\n    decls: 12,\n    vars: 17,\n    consts: function () {\n      let i18n_57;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label visible in the Grid group panel when it is empty\n         * @meaning kendo.grid.groupPanelEmpty\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_58 = goog.getMsg(\"Drag a column header and drop it here to group by that column\");\n        i18n_57 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_58;\n      } else {\n        i18n_57 = $localize`:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty:Drag a column header and drop it here to group by that column`;\n      }\n\n      let i18n_59;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label visible in the Grid when there are no records\n         * @meaning kendo.grid.noRecords\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_60 = goog.getMsg(\"No records available.\");\n        i18n_59 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_60;\n      } else {\n        i18n_59 = $localize`:kendo.grid.noRecords|The label visible in the Grid when there are no records:No records available.`;\n      }\n\n      let i18n_61;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the first page button in Grid pager\n         * @meaning kendo.grid.pagerFirstPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_62 = goog.getMsg(\"Go to the first page\");\n        i18n_61 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_62;\n      } else {\n        i18n_61 = $localize`:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager:Go to the first page`;\n      }\n\n      let i18n_63;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the previous page button in Grid pager\n         * @meaning kendo.grid.pagerPreviousPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_64 = goog.getMsg(\"Go to the previous page\");\n        i18n_63 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_64;\n      } else {\n        i18n_63 = $localize`:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager:Go to the previous page`;\n      }\n\n      let i18n_65;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the next page button in Grid pager\n         * @meaning kendo.grid.pagerNextPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_66 = goog.getMsg(\"Go to the next page\");\n        i18n_65 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_66;\n      } else {\n        i18n_65 = $localize`:kendo.grid.pagerNextPage|The label for the next page button in Grid pager:Go to the next page`;\n      }\n\n      let i18n_67;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the last page button in Grid pager\n         * @meaning kendo.grid.pagerLastPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_68 = goog.getMsg(\"Go to the last page\");\n        i18n_67 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_68;\n      } else {\n        i18n_67 = $localize`:kendo.grid.pagerLastPage|The label for the last page button in Grid pager:Go to the last page`;\n      }\n\n      let i18n_69;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label before the current page number in the Grid pager\n         * @meaning kendo.grid.pagerPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_70 = goog.getMsg(\"Page\");\n        i18n_69 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_70;\n      } else {\n        i18n_69 = $localize`:kendo.grid.pagerPage|The label before the current page number in the Grid pager:Page`;\n      }\n\n      let i18n_71;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label before the total pages number in the Grid pager\n         * @meaning kendo.grid.pagerOf\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_72 = goog.getMsg(\"of\");\n        i18n_71 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_72;\n      } else {\n        i18n_71 = $localize`:kendo.grid.pagerOf|The label before the total pages number in the Grid pager:of`;\n      }\n\n      let i18n_73;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label after the total pages number in the Grid pager\n         * @meaning kendo.grid.pagerItems\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_74 = goog.getMsg(\"items\");\n        i18n_73 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_74;\n      } else {\n        i18n_73 = $localize`:kendo.grid.pagerItems|The label after the total pages number in the Grid pager:items`;\n      }\n\n      let i18n_75;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the pager input in the Grid pager\n         * @meaning kendo.grid.pagerPageNumberInputTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_76 = goog.getMsg(\"Page Number\");\n        i18n_75 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_76;\n      } else {\n        i18n_75 = $localize`:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager:Page Number`;\n      }\n\n      let i18n_77;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the page size chooser in the Grid pager\n         * @meaning kendo.grid.pagerItemsPerPage\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_78 = goog.getMsg(\"items per page\");\n        i18n_77 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_78;\n      } else {\n        i18n_77 = $localize`:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager:items per page`;\n      }\n\n      let i18n_79;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter cell or icon\n         * @meaning kendo.grid.filter\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_80 = goog.getMsg(\"Filter\");\n        i18n_79 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_80;\n      } else {\n        i18n_79 = $localize`:kendo.grid.filter|The label of the filter cell or icon:Filter`;\n      }\n\n      let i18n_81;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the equal filter operator\n         * @meaning kendo.grid.filterEqOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_82 = goog.getMsg(\"Is equal to\");\n        i18n_81 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_82;\n      } else {\n        i18n_81 = $localize`:kendo.grid.filterEqOperator|The text of the equal filter operator:Is equal to`;\n      }\n\n      let i18n_83;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the not equal filter operator\n         * @meaning kendo.grid.filterNotEqOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_84 = goog.getMsg(\"Is not equal to\");\n        i18n_83 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_84;\n      } else {\n        i18n_83 = $localize`:kendo.grid.filterNotEqOperator|The text of the not equal filter operator:Is not equal to`;\n      }\n\n      let i18n_85;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is null filter operator\n         * @meaning kendo.grid.filterIsNullOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_86 = goog.getMsg(\"Is null\");\n        i18n_85 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_86;\n      } else {\n        i18n_85 = $localize`:kendo.grid.filterIsNullOperator|The text of the is null filter operator:Is null`;\n      }\n\n      let i18n_87;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is not null filter operator\n         * @meaning kendo.grid.filterIsNotNullOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_88 = goog.getMsg(\"Is not null\");\n        i18n_87 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_88;\n      } else {\n        i18n_87 = $localize`:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator:Is not null`;\n      }\n\n      let i18n_89;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is empty filter operator\n         * @meaning kendo.grid.filterIsEmptyOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_90 = goog.getMsg(\"Is empty\");\n        i18n_89 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_90;\n      } else {\n        i18n_89 = $localize`:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator:Is empty`;\n      }\n\n      let i18n_91;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the is not empty filter operator\n         * @meaning kendo.grid.filterIsNotEmptyOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_92 = goog.getMsg(\"Is not empty\");\n        i18n_91 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_92;\n      } else {\n        i18n_91 = $localize`:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator:Is not empty`;\n      }\n\n      let i18n_93;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the starts with filter operator\n         * @meaning kendo.grid.filterStartsWithOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_94 = goog.getMsg(\"Starts with\");\n        i18n_93 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_94;\n      } else {\n        i18n_93 = $localize`:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator:Starts with`;\n      }\n\n      let i18n_95;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the contains filter operator\n         * @meaning kendo.grid.filterContainsOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_96 = goog.getMsg(\"Contains\");\n        i18n_95 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_96;\n      } else {\n        i18n_95 = $localize`:kendo.grid.filterContainsOperator|The text of the contains filter operator:Contains`;\n      }\n\n      let i18n_97;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the does not contain filter operator\n         * @meaning kendo.grid.filterNotContainsOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_98 = goog.getMsg(\"Does not contain\");\n        i18n_97 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_98;\n      } else {\n        i18n_97 = $localize`:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator:Does not contain`;\n      }\n\n      let i18n_99;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the ends with filter operator\n         * @meaning kendo.grid.filterEndsWithOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_100 = goog.getMsg(\"Ends with\");\n        i18n_99 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_100;\n      } else {\n        i18n_99 = $localize`:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator:Ends with`;\n      }\n\n      let i18n_101;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the greater than or equal filter operator\n         * @meaning kendo.grid.filterGteOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_102 = goog.getMsg(\"Is greater than or equal to\");\n        i18n_101 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_102;\n      } else {\n        i18n_101 = $localize`:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator:Is greater than or equal to`;\n      }\n\n      let i18n_103;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the greater than filter operator\n         * @meaning kendo.grid.filterGtOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_104 = goog.getMsg(\"Is greater than\");\n        i18n_103 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_104;\n      } else {\n        i18n_103 = $localize`:kendo.grid.filterGtOperator|The text of the greater than filter operator:Is greater than`;\n      }\n\n      let i18n_105;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the less than or equal filter operator\n         * @meaning kendo.grid.filterLteOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_106 = goog.getMsg(\"Is less than or equal to\");\n        i18n_105 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_106;\n      } else {\n        i18n_105 = $localize`:kendo.grid.filterLteOperator|The text of the less than or equal filter operator:Is less than or equal to`;\n      }\n\n      let i18n_107;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the less than filter operator\n         * @meaning kendo.grid.filterLtOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_108 = goog.getMsg(\"Is less than\");\n        i18n_107 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_108;\n      } else {\n        i18n_107 = $localize`:kendo.grid.filterLtOperator|The text of the less than filter operator:Is less than`;\n      }\n\n      let i18n_109;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the IsTrue boolean filter option\n         * @meaning kendo.grid.filterIsTrue\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_110 = goog.getMsg(\"Is True\");\n        i18n_109 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_110;\n      } else {\n        i18n_109 = $localize`:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option:Is True`;\n      }\n\n      let i18n_111;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the IsFalse boolean filter option\n         * @meaning kendo.grid.filterIsFalse\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_112 = goog.getMsg(\"Is False\");\n        i18n_111 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_112;\n      } else {\n        i18n_111 = $localize`:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option:Is False`;\n      }\n\n      let i18n_113;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the (All) boolean filter option\n         * @meaning kendo.grid.filterBooleanAll\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_114 = goog.getMsg(\"(All)\");\n        i18n_113 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_114;\n      } else {\n        i18n_113 = $localize`:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option:(All)`;\n      }\n\n      let i18n_115;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the after or equal date filter operator\n         * @meaning kendo.grid.filterAfterOrEqualOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_116 = goog.getMsg(\"Is after or equal to\");\n        i18n_115 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_116;\n      } else {\n        i18n_115 = $localize`:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator:Is after or equal to`;\n      }\n\n      let i18n_117;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the after date filter operator\n         * @meaning kendo.grid.filterAfterOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_118 = goog.getMsg(\"Is after\");\n        i18n_117 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_118;\n      } else {\n        i18n_117 = $localize`:kendo.grid.filterAfterOperator|The text of the after date filter operator:Is after`;\n      }\n\n      let i18n_119;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the before date filter operator\n         * @meaning kendo.grid.filterBeforeOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_120 = goog.getMsg(\"Is before\");\n        i18n_119 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_120;\n      } else {\n        i18n_119 = $localize`:kendo.grid.filterBeforeOperator|The text of the before date filter operator:Is before`;\n      }\n\n      let i18n_121;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the before or equal date filter operator\n         * @meaning kendo.grid.filterBeforeOrEqualOperator\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_122 = goog.getMsg(\"Is before or equal to\");\n        i18n_121 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_122;\n      } else {\n        i18n_121 = $localize`:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator:Is before or equal to`;\n      }\n\n      let i18n_123;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the filter button\n         * @meaning kendo.grid.filterFilterButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_124 = goog.getMsg(\"Filter\");\n        i18n_123 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_124;\n      } else {\n        i18n_123 = $localize`:kendo.grid.filterFilterButton|The text of the filter button:Filter`;\n      }\n\n      let i18n_125;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the clear filter button\n         * @meaning kendo.grid.filterClearButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_126 = goog.getMsg(\"Clear\");\n        i18n_125 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_126;\n      } else {\n        i18n_125 = $localize`:kendo.grid.filterClearButton|The text of the clear filter button:Clear`;\n      }\n\n      let i18n_127;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the And filter logic\n         * @meaning kendo.grid.filterAndLogic\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_128 = goog.getMsg(\"And\");\n        i18n_127 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_128;\n      } else {\n        i18n_127 = $localize`:kendo.grid.filterAndLogic|The text of the And filter logic:And`;\n      }\n\n      let i18n_129;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Or filter logic\n         * @meaning kendo.grid.filterOrLogic\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_130 = goog.getMsg(\"Or\");\n        i18n_129 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_130;\n      } else {\n        i18n_129 = $localize`:kendo.grid.filterOrLogic|The text of the Or filter logic:Or`;\n      }\n\n      let i18n_131;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The loading text\n         * @meaning kendo.grid.loading\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_132 = goog.getMsg(\"Loading\");\n        i18n_131 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_132;\n      } else {\n        i18n_131 = $localize`:kendo.grid.loading|The loading text:Loading`;\n      }\n\n      let i18n_133;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Grid aria-label\n         * @meaning kendo.grid.gridLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_134 = goog.getMsg(\"Data table\");\n        i18n_133 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_134;\n      } else {\n        i18n_133 = $localize`:kendo.grid.gridLabel|The Grid aria-label:Data table`;\n      }\n\n      let i18n_135;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the columns item\n         * @meaning kendo.grid.columns\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_136 = goog.getMsg(\"Columns\");\n        i18n_135 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_136;\n      } else {\n        i18n_135 = $localize`:kendo.grid.columns|The text shown in the column menu for the columns item:Columns`;\n      }\n\n      let i18n_137;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the lock item\n         * @meaning kendo.grid.lock\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_138 = goog.getMsg(\"Lock\");\n        i18n_137 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_138;\n      } else {\n        i18n_137 = $localize`:kendo.grid.lock|The text shown in the column menu for the lock item:Lock`;\n      }\n\n      let i18n_139;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the unlock item\n         * @meaning kendo.grid.unlock\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_140 = goog.getMsg(\"Unlock\");\n        i18n_139 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_140;\n      } else {\n        i18n_139 = $localize`:kendo.grid.unlock|The text shown in the column menu for the unlock item:Unlock`;\n      }\n\n      let i18n_141;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the set column position item\n         * @meaning kendo.grid.setColumnPosition\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_142 = goog.getMsg(\"Set Column Position\");\n        i18n_141 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_142;\n      } else {\n        i18n_141 = $localize`:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item:Set Column Position`;\n      }\n\n      let i18n_143;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the stick item\n         * @meaning kendo.grid.stick\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_144 = goog.getMsg(\"Stick\");\n        i18n_143 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_144;\n      } else {\n        i18n_143 = $localize`:kendo.grid.stick|The text shown in the column menu for the stick item:Stick`;\n      }\n\n      let i18n_145;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the unstick item\n         * @meaning kendo.grid.unstick\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_146 = goog.getMsg(\"Unstick\");\n        i18n_145 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_146;\n      } else {\n        i18n_145 = $localize`:kendo.grid.unstick|The text shown in the column menu for the unstick item:Unstick`;\n      }\n\n      let i18n_147;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the sort icon\n         * @meaning kendo.grid.sortable\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_148 = goog.getMsg(\"Sortable\");\n        i18n_147 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_148;\n      } else {\n        i18n_147 = $localize`:kendo.grid.sortable|The label of the sort icon:Sortable`;\n      }\n\n      let i18n_149;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the sort ascending item\n         * @meaning kendo.grid.sortAscending\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_150 = goog.getMsg(\"Sort Ascending\");\n        i18n_149 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_150;\n      } else {\n        i18n_149 = $localize`:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item:Sort Ascending`;\n      }\n\n      let i18n_151;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu for the sort descending item\n         * @meaning kendo.grid.sortDescending\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_152 = goog.getMsg(\"Sort Descending\");\n        i18n_151 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_152;\n      } else {\n        i18n_151 = $localize`:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item:Sort Descending`;\n      }\n\n      let i18n_153;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The status announcement when a column is sorted ascending\n         * @meaning kendo.grid.sortedAscending\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_154 = goog.getMsg(\"Sorted Ascending\");\n        i18n_153 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_154;\n      } else {\n        i18n_153 = $localize`:kendo.grid.sortedAscending|The status announcement when a column is sorted ascending:Sorted Ascending`;\n      }\n\n      let i18n_155;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The status announcement when a column is sorted descending\n         * @meaning kendo.grid.sortedDescending\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_156 = goog.getMsg(\"Sorted Descending\");\n        i18n_155 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_156;\n      } else {\n        i18n_155 = $localize`:kendo.grid.sortedDescending|The status announcement when a column is sorted descending:Sorted Descending`;\n      }\n\n      let i18n_157;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The status announcement when a column is no longer sorted\n         * @meaning kendo.grid.sortedDefault\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_158 = goog.getMsg(\"Not Sorted\");\n        i18n_157 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_158;\n      } else {\n        i18n_157 = $localize`:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted:Not Sorted`;\n      }\n\n      let i18n_159;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu or column chooser for the columns apply button\n         * @meaning kendo.grid.columnsApply\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_160 = goog.getMsg(\"Apply\");\n        i18n_159 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_160;\n      } else {\n        i18n_159 = $localize`:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button:Apply`;\n      }\n\n      let i18n_161;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text shown in the column menu or column chooser for the columns reset button\n         * @meaning kendo.grid.columnsReset\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_162 = goog.getMsg(\"Reset\");\n        i18n_161 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_162;\n      } else {\n        i18n_161 = $localize`:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button:Reset`;\n      }\n\n      let i18n_163;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the expand icon of detail rows.\n         * @meaning kendo.grid.detailExpand\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_164 = goog.getMsg(\"Expand Details\");\n        i18n_163 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_164;\n      } else {\n        i18n_163 = $localize`:kendo.grid.detailExpand|The title of the expand icon of detail rows.:Expand Details`;\n      }\n\n      let i18n_165;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the collapse icon of detail rows.\n         * @meaning kendo.grid.detailCollapse\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_166 = goog.getMsg(\"Collapse Details\");\n        i18n_165 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_166;\n      } else {\n        i18n_165 = $localize`:kendo.grid.detailCollapse|The title of the collapse icon of detail rows.:Collapse Details`;\n      }\n\n      let i18n_167;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the Today button of the Date filter.\n         * @meaning kendo.grid.filterDateToday\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_168 = goog.getMsg(\"TODAY\");\n        i18n_167 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_168;\n      } else {\n        i18n_167 = $localize`:kendo.grid.filterDateToday|The text of the Today button of the Date filter.:TODAY`;\n      }\n\n      let i18n_169;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Toggle button of the Date filter.\n         * @meaning kendo.grid.filterDateToggle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_170 = goog.getMsg(\"Toggle Calendar\");\n        i18n_169 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_170;\n      } else {\n        i18n_169 = $localize`:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.:Toggle Calendar`;\n      }\n\n      let i18n_171;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Decrement button of the Numeric filter.\n         * @meaning kendo.grid.filterNumericDecrement\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_172 = goog.getMsg(\"Decrement\");\n        i18n_171 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_172;\n      } else {\n        i18n_171 = $localize`:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.:Decrement`;\n      }\n\n      let i18n_173;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the Increment button of the Numeric filter.\n         * @meaning kendo.grid.filterNumericIncrement\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_174 = goog.getMsg(\"Increment\");\n        i18n_173 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_174;\n      } else {\n        i18n_173 = $localize`:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.:Increment`;\n      }\n\n      let i18n_175;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The labels of the checkbox column checkboxes.\n         * @meaning kendo.grid.selectionCheckboxLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_176 = goog.getMsg(\"Select Row\");\n        i18n_175 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_176;\n      } else {\n        i18n_175 = $localize`:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.:Select Row`;\n      }\n\n      let i18n_177;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the checkbox column select all checkbox.\n         * @meaning kendo.grid.selectAllCheckboxLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_178 = goog.getMsg(\"Select All Rows\");\n        i18n_177 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_178;\n      } else {\n        i18n_177 = $localize`:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.:Select All Rows`;\n      }\n\n      let i18n_179;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the title and aria-label attributes applied to the collapse icon of group rows.\n         * @meaning kendo.grid.groupCollapse\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_180 = goog.getMsg(\"Collapse Group\");\n        i18n_179 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_180;\n      } else {\n        i18n_179 = $localize`:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.:Collapse Group`;\n      }\n\n      let i18n_181;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text of the title and aria-label attributes applied to the expand icon of group rows.\n         * @meaning kendo.grid.groupExpand\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_182 = goog.getMsg(\"Expand Group\");\n        i18n_181 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_182;\n      } else {\n        i18n_181 = $localize`:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.:Expand Group`;\n      }\n\n      let i18n_183;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Grid pager\n         * @meaning kendo.grid.pagerLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_184 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_183 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_184;\n      } else {\n        i18n_183 = $localize`:kendo.grid.pagerLabel|The label for the Grid pager:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      let i18n_185;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter row and menu inputs\n         * @meaning kendo.grid.filterInputLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_186 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_185 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_186;\n      } else {\n        i18n_185 = $localize`:kendo.grid.filterInputLabel|The label of the filter row and menu inputs:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      let i18n_187;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the filter menu icon\n         * @meaning kendo.grid.filterMenuTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_188 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_187 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_188;\n      } else {\n        i18n_187 = $localize`:kendo.grid.filterMenuTitle|The title of the filter menu icon:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      let i18n_189;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter menu operators dropdown\n         * @meaning kendo.grid.filterMenuOperatorsDropDownLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_190 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_189 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_190;\n      } else {\n        i18n_189 = $localize`:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      let i18n_191;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label of the filter menu logic dropdown\n         * @meaning kendo.grid.filterMenuLogicDropDownLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_192 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_191 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_192;\n      } else {\n        i18n_191 = $localize`:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      let i18n_193;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the column menu icon\n         * @meaning kendo.grid.columnMenu\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_194 = goog.getMsg(\"{$interpolation}\", {\n          \"interpolation\": \"\\uFFFD0\\uFFFD\"\n        });\n        i18n_193 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2015_KENDO_ANGULAR_GRID_JS_194;\n      } else {\n        i18n_193 = $localize`:kendo.grid.columnMenu|The title of the column menu icon:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n      }\n\n      return [[\"kendoGridLocalizedMessages\", \"\", \"groupPanelEmpty\", i18n_57, \"noRecords\", i18n_59, \"pagerFirstPage\", i18n_61, \"pagerPreviousPage\", i18n_63, \"pagerNextPage\", i18n_65, \"pagerLastPage\", i18n_67, \"pagerPage\", i18n_69, \"pagerOf\", i18n_71, \"pagerItems\", i18n_73, \"pagerPageNumberInputTitle\", i18n_75, \"pagerItemsPerPage\", i18n_77, \"filter\", i18n_79, \"filterEqOperator\", i18n_81, \"filterNotEqOperator\", i18n_83, \"filterIsNullOperator\", i18n_85, \"filterIsNotNullOperator\", i18n_87, \"filterIsEmptyOperator\", i18n_89, \"filterIsNotEmptyOperator\", i18n_91, \"filterStartsWithOperator\", i18n_93, \"filterContainsOperator\", i18n_95, \"filterNotContainsOperator\", i18n_97, \"filterEndsWithOperator\", i18n_99, \"filterGteOperator\", i18n_101, \"filterGtOperator\", i18n_103, \"filterLteOperator\", i18n_105, \"filterLtOperator\", i18n_107, \"filterIsTrue\", i18n_109, \"filterIsFalse\", i18n_111, \"filterBooleanAll\", i18n_113, \"filterAfterOrEqualOperator\", i18n_115, \"filterAfterOperator\", i18n_117, \"filterBeforeOperator\", i18n_119, \"filterBeforeOrEqualOperator\", i18n_121, \"filterFilterButton\", i18n_123, \"filterClearButton\", i18n_125, \"filterAndLogic\", i18n_127, \"filterOrLogic\", i18n_129, \"loading\", i18n_131, \"gridLabel\", i18n_133, \"columns\", i18n_135, \"lock\", i18n_137, \"unlock\", i18n_139, \"setColumnPosition\", i18n_141, \"stick\", i18n_143, \"unstick\", i18n_145, \"sortable\", i18n_147, \"sortAscending\", i18n_149, \"sortDescending\", i18n_151, \"sortedAscending\", i18n_153, \"sortedDescending\", i18n_155, \"sortedDefault\", i18n_157, \"columnsApply\", i18n_159, \"columnsReset\", i18n_161, \"detailExpand\", i18n_163, \"detailCollapse\", i18n_165, \"filterDateToday\", i18n_167, \"filterDateToggle\", i18n_169, \"filterNumericDecrement\", i18n_171, \"filterNumericIncrement\", i18n_173, \"selectionCheckboxLabel\", i18n_175, \"selectAllCheckboxLabel\", i18n_177, \"groupCollapse\", i18n_179, \"groupExpand\", i18n_181, 6, \"pagerLabel\", \"filterInputLabel\", \"filterMenuTitle\", \"filterMenuOperatorsDropDownLabel\", \"filterMenuLogicDropDownLabel\", \"columnMenu\"], [\"pagerLabel\", i18n_183, \"filterInputLabel\", i18n_185, \"filterMenuTitle\", i18n_187, \"filterMenuOperatorsDropDownLabel\", i18n_189, \"filterMenuLogicDropDownLabel\", i18n_191, \"columnMenu\", i18n_193], [\"class\", \"k-toolbar k-grid-toolbar\", \"position\", \"top\", 4, \"ngIf\"], [\"class\", \"k-grid-pager-top\", 3, \"tabindex\", \"template\", \"pageSize\", \"total\", \"skip\", \"options\", \"pageChange\", 4, \"ngIf\"], [3, \"text\", \"groups\", \"change\", 4, \"ngIf\"], [\"role\", \"grid\", 1, \"k-grid-aria-root\"], [\"ariaRoot\", \"\"], [4, \"ngIf\"], [\"kendoGridLoading\", \"\", 3, \"loadingTemplate\", 4, \"ngIf\"], [3, \"tabindex\", \"template\", \"pageSize\", \"total\", \"skip\", \"options\", \"pageChange\", 4, \"ngIf\"], [\"class\", \"k-toolbar k-grid-toolbar k-grid-toolbar-bottom\", \"position\", \"bottom\", 4, \"ngIf\"], [\"position\", \"top\", 1, \"k-toolbar\", \"k-grid-toolbar\"], [1, \"k-grid-pager-top\", 3, \"tabindex\", \"template\", \"pageSize\", \"total\", \"skip\", \"options\", \"pageChange\"], [3, \"text\", \"groups\", \"change\"], [\"class\", \"k-grid-header\", \"role\", \"presentation\", 3, \"padding\", 4, \"ngIf\"], [\"kendoDraggable\", \"\", \"kendoGridSelectionMarquee\", \"\", 3, \"data\", \"rowHeight\", \"detailRowHeight\", \"total\", \"take\", \"groups\", \"groupable\", \"skip\", \"trackBy\", \"columns\", \"selectable\", \"filterable\", \"detailTemplate\", \"noRecordsTemplate\", \"rowClass\", \"rowSticky\", \"loading\", \"isVirtual\", \"cellLoadingTemplate\", \"loadingTemplate\", \"virtualColumns\", \"enableDrag\", \"pageChange\", \"scrollBottom\", \"contentScroll\"], [\"class\", \"k-grid-footer\", 3, \"padding\", 4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-grid-header\"], [\"role\", \"presentation\", \"class\", \"k-grid-header-locked\", 3, \"width\", 4, \"ngIf\"], [\"role\", \"presentation\", \"data-scrollable\", \"\", 1, \"k-grid-header-wrap\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"header\", \"\"], [\"role\", \"presentation\", 3, \"virtualColumns\"], [\"kendoGridColGroup\", \"\", \"role\", \"presentation\", 3, \"columns\", \"groups\", \"detailTemplate\"], [\"kendoGridHeader\", \"\", \"role\", \"presentation\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"sort\", \"filter\", \"filterable\", \"groupable\", \"reorderable\", \"groups\", \"sortable\", \"columnMenu\", \"columnMenuTemplate\", \"lockedColumnsCount\", \"totalColumnsCount\", \"detailTemplate\", \"tabIndex\"], [\"class\", \"k-width-container\", \"role\", \"presentation\", 4, \"ngIf\"], [\"role\", \"presentation\", 1, \"k-grid-header-locked\"], [\"lockedHeader\", \"\"], [\"role\", \"presentation\", 3, \"locked\"], [\"kendoGridHeader\", \"\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"sort\", \"groups\", \"filter\", \"filterable\", \"groupable\", \"reorderable\", \"sortable\", \"columnMenu\", \"columnMenuTemplate\", \"totalColumnsCount\", \"detailTemplate\", \"tabIndex\"], [\"role\", \"presentation\", 1, \"k-width-container\"], [1, \"k-grid-footer\"], [\"class\", \"k-grid-footer-locked\", 3, \"width\", 4, \"ngIf\"], [\"data-scrollable\", \"\", 1, \"k-grid-footer-wrap\", 3, \"kendoGridResizableContainer\", \"lockedWidth\"], [\"footer\", \"\"], [\"role\", \"presentation\"], [\"kendoGridColGroup\", \"\", 3, \"columns\", \"groups\", \"detailTemplate\"], [\"kendoGridFooter\", \"\", 3, \"logicalRowIndex\", \"scrollable\", \"groups\", \"columns\", \"lockedColumnsCount\", \"detailTemplate\"], [1, \"k-grid-footer-locked\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"groups\", \"columns\", \"detailTemplate\", \"logicalRowIndex\"], [\"kendoGridHeader\", \"\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"groups\", \"groupable\", \"reorderable\", \"sort\", \"sortable\", \"filter\", \"filterable\", \"columnMenu\", \"columnMenuTemplate\", \"detailTemplate\", \"tabIndex\", 4, \"ngIf\"], [\"kendoGridTableBody\", \"\", \"kendoDraggable\", \"\", \"kendoGridSelectionMarquee\", \"\", 3, \"isLoading\", \"groups\", \"data\", \"skip\", \"columns\", \"selectable\", \"filterable\", \"noRecordsTemplate\", \"detailTemplate\", \"showGroupFooters\", \"trackBy\", \"rowClass\", \"enableDrag\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"logicalRowIndex\", \"groups\", \"columns\", \"detailTemplate\", 4, \"ngIf\"], [\"kendoGridHeader\", \"\", 3, \"resizable\", \"scrollable\", \"columns\", \"totalColumnLevels\", \"groups\", \"groupable\", \"reorderable\", \"sort\", \"sortable\", \"filter\", \"filterable\", \"columnMenu\", \"columnMenuTemplate\", \"detailTemplate\", \"tabIndex\"], [\"kendoGridFooter\", \"\", 3, \"scrollable\", \"logicalRowIndex\", \"groups\", \"columns\", \"detailTemplate\"], [\"kendoGridLoading\", \"\", 3, \"loadingTemplate\"], [3, \"tabindex\", \"template\", \"pageSize\", \"total\", \"skip\", \"options\", \"pageChange\"], [\"position\", \"bottom\", 1, \"k-toolbar\", \"k-grid-toolbar\", \"k-grid-toolbar-bottom\"]];\n    },\n    template: function GridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵi18nAttributes(1, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(2, GridComponent_kendo_grid_toolbar_2_Template, 1, 0, \"kendo-grid-toolbar\", 2);\n        i0.ɵɵtemplate(3, GridComponent_kendo_pager_3_Template, 1, 7, \"kendo-pager\", 3);\n        i0.ɵɵtemplate(4, GridComponent_kendo_grid_group_panel_4_Template, 1, 2, \"kendo-grid-group-panel\", 4);\n        i0.ɵɵelementStart(5, \"div\", 5, 6);\n        i0.ɵɵtemplate(7, GridComponent_ng_container_7_Template, 4, 24, \"ng-container\", 7);\n        i0.ɵɵtemplate(8, GridComponent_ng_container_8_Template, 6, 20, \"ng-container\", 7);\n        i0.ɵɵtemplate(9, GridComponent_div_9_Template, 1, 1, \"div\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(10, GridComponent_kendo_pager_10_Template, 1, 7, \"kendo-pager\", 9);\n        i0.ɵɵtemplate(11, GridComponent_kendo_grid_toolbar_11_Template, 1, 0, \"kendo-grid-toolbar\", 10);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵi18nExp(\"Page navigation, page {currentPage} of {totalPages}\")(\"{columnName} Filter\")(\"{columnName} Filter Menu\")(\"{columnName} Filter Operators\")(\"{columnName} Filter Logic\")(\"{columnName} Column Menu\");\n        i0.ɵɵi18nApply(1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTopToolbar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTopPager);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showGroupPanel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"aria-rowcount\", ctx.ariaRowCount)(\"aria-colcount\", ctx.ariaColCount);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.isScrollable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isScrollable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showBottomPager);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showBottomToolbar);\n      }\n    },\n    directives: [ToolbarComponent, PagerComponent, GroupPanelComponent, ColGroupComponent, HeaderComponent, ListComponent, FooterComponent, TableBodyComponent, LoadingComponent, LocalizedMessagesDirective, i4.NgIf, TableDirective, ResizableContainerDirective, i1$1.DraggableDirective, GridMarqueeDirective],\n    encapsulation: 2\n  });\n  return GridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the in-memory handling of data operations such as [paging]({% slug paging_grid %}),\n * [sorting]({% slug sorting_grid %}), and [grouping]({% slug groupingbasics_grid %})\n * ([more information and examples]({% slug automaticoperations_grid %})).\n */\n\n\nlet DataBindingDirective = /*#__PURE__*/(() => {\n  class DataBindingDirective {\n    constructor(grid, changeDetector, localDataChangesService) {\n      this.grid = grid;\n      this.changeDetector = changeDetector;\n      this.localDataChangesService = localDataChangesService;\n      this.state = {\n        skip: 0\n      };\n      this.originalData = [];\n\n      if (localDataChangesService) {\n        this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));\n      }\n    }\n    /**\n     * Defines the number of records that will be skipped by the pager.\n     */\n\n\n    set skip(value) {\n      if (!isPresent(value)) {\n        value = 0;\n      }\n\n      this.grid.skip = this.state.skip = value;\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n\n\n    set sort(value) {\n      this.grid.sort = this.state.sort = value;\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n\n\n    set filter(value) {\n      this.grid.filter = this.state.filter = value;\n    }\n    /**\n     * Defines the page size used by the Grid pager.\n     */\n\n\n    set pageSize(value) {\n      this.grid.pageSize = this.state.take = value;\n    }\n    /**\n     * The descriptors by which the data will be grouped.\n     */\n\n\n    set group(value) {\n      this.grid.group = this.state.group = value;\n    }\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n\n\n    set data(value) {\n      this.originalData = value || [];\n\n      if (this.localDataChangesService) {\n        this.localDataChangesService.data = value;\n      }\n\n      this.dataChanged = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.applyState(this.state);\n      this.stateChangeSubscription = this.grid.dataStateChange.subscribe(this.onStateChange.bind(this));\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      if (this.stateChangeSubscription) {\n        this.stateChangeSubscription.unsubscribe();\n      }\n\n      if (this.dataChangedSubscription) {\n        this.dataChangedSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (anyChanged([\"pageSize\", \"skip\", \"sort\", \"group\", \"filter\"], changes)) {\n        this.rebind();\n      }\n    }\n\n    ngDoCheck() {\n      if (this.dataChanged) {\n        this.updateGridData();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onStateChange(state) {\n      this.applyState(state);\n      this.rebind();\n    }\n    /**\n     * @hidden\n     */\n\n\n    rebind() {\n      this.data = this.originalData;\n      this.updateGridData();\n      this.notifyDataChange();\n    }\n    /**\n     * Notifies the Grid that its data has changed.\n     */\n\n\n    notifyDataChange() {\n      this.grid.onDataChange();\n\n      if (this.changeDetector) {\n        this.changeDetector.markForCheck();\n      }\n    }\n\n    process(state) {\n      return process(this.originalData, state);\n    }\n\n    applyState({\n      skip,\n      take,\n      sort,\n      group,\n      filter\n    }) {\n      this.skip = skip;\n      this.pageSize = take;\n      this.sort = sort;\n      this.group = group;\n      this.filter = filter;\n    }\n\n    updateGridData() {\n      this.grid.data = this.process(this.state);\n      this.dataChanged = false;\n    }\n\n  }\n\n  DataBindingDirective.ɵfac = function DataBindingDirective_Factory(t) {\n    return new (t || DataBindingDirective)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  };\n\n  DataBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DataBindingDirective,\n    selectors: [[\"\", \"kendoGridBinding\", \"\"]],\n    inputs: {\n      skip: \"skip\",\n      sort: \"sort\",\n      filter: \"filter\",\n      pageSize: \"pageSize\",\n      group: \"group\",\n      data: [\"kendoGridBinding\", \"data\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DataBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which stores the row selection state of the Grid in memory\n * ([see example]({% slug selection_grid %}#toc-during-data-operations)).\n */\n\n\nlet SelectionDirective = /*#__PURE__*/(() => {\n  class SelectionDirective extends Selection {\n    constructor(ctx, cd) {\n      super(ctx, cd);\n      this.ctx = ctx;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      if (this.ctx.grid.selectable === false) {\n        this.ctx.grid.selectable = true;\n      }\n\n      this.ctx.grid.selectionDirective = this;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      super.destroy();\n    }\n\n  }\n\n  SelectionDirective.ɵfac = function SelectionDirective_Factory(t) {\n    return new (t || SelectionDirective)(i0.ɵɵdirectiveInject(ContextService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  SelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectionDirective,\n    selectors: [[\"\", \"kendoGridSelectBy\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return SelectionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which controls the expanded state of the master detail rows.\n */\n\n\nlet ExpandDetailsDirective = /*#__PURE__*/(() => {\n  class ExpandDetailsDirective {\n    constructor(grid) {\n      this.grid = grid;\n      /**\n       * Fires when the expandedDetailKeys are changed.\n       */\n\n      this.expandedDetailKeysChange = new EventEmitter();\n      /**\n       * Defines the collection that will store the expanded keys.\n       */\n\n      this.expandedDetailKeys = [];\n      /**\n       * Specifies if the items should be initially expanded.\n       * When set to `true` items added to the `expandedDetailKeys` collection will be collapsed, and items that are not present in it will be expanded.\n       *\n       * @default false\n       */\n\n      this.initiallyExpanded = false;\n      this.expandedState = new Set();\n      this.subscriptions = new Subscription();\n      this.grid.isDetailExpanded = this.isExpanded.bind(this);\n      this.subscriptions.add(merge(this.grid.detailExpand.pipe(map(e => Object.assign({\n        expand: true\n      }, e))), this.grid.detailCollapse.pipe(map(e => Object.assign({\n        expand: false\n      }, e)))).subscribe(this.toggleState.bind(this)));\n    }\n    /**\n     * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).\n     */\n\n\n    get expandDetailsKey() {\n      return this._expandBy;\n    }\n\n    set expandDetailsKey(key) {\n      if (isString(key)) {\n        this._expandBy = getter(key);\n      } else {\n        this._expandBy = key;\n      }\n    }\n    /**\n     *\n     * @hidden\n     * A deprecated alias for setting the `expandDetailsKey` property.\n     */\n\n\n    get expandDetailBy() {\n      return this.expandDetailsKey;\n    }\n\n    set expandDetailBy(key) {\n      this.expandDetailsKey = key;\n    }\n\n    ngOnChanges(changes) {\n      // skip reinitialization if the user data is the same as the last state change\n      if (isPresent(changes.expandedDetailKeys) && this.lastExpandedState !== this.expandedDetailKeys) {\n        this.expandedState = new Set(this.expandedDetailKeys);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    get keyGetter() {\n      return this._expandBy || getter(undefined);\n    }\n    /**\n     * @hidden\n     */\n\n\n    isExpanded(args) {\n      const key = this.keyGetter(args.dataItem);\n      const hasKey = this.expandedState.has(key); // when [initiallyExpanded]=\"true\" a present key means the corresponding detail row is collapsed\n\n      return this.initiallyExpanded ? !hasKey : hasKey;\n    }\n\n    toggleState(args) {\n      const key = this.keyGetter(args.dataItem);\n\n      if (Boolean(this.initiallyExpanded) !== args.expand) {\n        this.expandedState.add(key);\n      } else {\n        this.expandedState.delete(key);\n      }\n\n      this.notifyChange();\n    }\n\n    notifyChange() {\n      this.lastExpandedState = Array.from(this.expandedState);\n      this.expandedDetailKeysChange.emit(this.lastExpandedState);\n    }\n\n  }\n\n  ExpandDetailsDirective.ɵfac = function ExpandDetailsDirective_Factory(t) {\n    return new (t || ExpandDetailsDirective)(i0.ɵɵdirectiveInject(GridComponent));\n  };\n\n  ExpandDetailsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExpandDetailsDirective,\n    selectors: [[\"\", \"kendoGridExpandDetailsBy\", \"\"]],\n    inputs: {\n      expandDetailsKey: [\"kendoGridExpandDetailsBy\", \"expandDetailsKey\"],\n      expandDetailBy: \"expandDetailBy\",\n      expandedDetailKeys: \"expandedDetailKeys\",\n      initiallyExpanded: \"initiallyExpanded\"\n    },\n    outputs: {\n      expandedDetailKeysChange: \"expandedDetailKeysChange\"\n    },\n    exportAs: [\"kendoGridExpandDetailsBy\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return ExpandDetailsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst mapParentGroup = parentGroup => {\n  const parentGroupKeys = [];\n\n  while (parentGroup) {\n    parentGroupKeys.push({\n      field: parentGroup.group.field,\n      value: parentGroup.group.value\n    });\n    parentGroup = parentGroup.parentGroup;\n  }\n\n  return parentGroupKeys;\n};\n\nconst DEFAULT_KEY_GETTER = groupRowArgs => ({\n  field: groupRowArgs.group.field,\n  value: groupRowArgs.group.value,\n  parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)\n});\n/**\n * A directive which controls the expanded state of the group rows\n * ([see example]({% slug groups_expanded_state_grid %}#toc-built-in-directive)).\n */\n\n\nlet ExpandGroupDirective = /*#__PURE__*/(() => {\n  class ExpandGroupDirective {\n    constructor(grid) {\n      this.grid = grid;\n      /**\n       * Fires when the expandedGroupKeys are changed.\n       */\n\n      this.expandedGroupKeysChange = new EventEmitter();\n      /**\n       * Specifies if the group items should be initially expanded.\n       * @default false\n       */\n\n      this.groupsInitiallyExpanded = false;\n      this.subscriptions = new Subscription();\n      this.grid.isGroupExpanded = this.isExpanded.bind(this);\n      this.subscriptions.add(merge(this.grid.groupExpand.pipe(map(e => Object.assign({\n        expand: true\n      }, e))), this.grid.groupCollapse.pipe(map(e => Object.assign({\n        expand: false\n      }, e)))).subscribe(this.toggleState.bind(this)));\n    }\n    /**\n     * Defines the item format that will be stored in the `expandedGroupKeys`\n     * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).\n     */\n\n\n    get expandGroupBy() {\n      return this._expandGroupBy;\n    }\n\n    set expandGroupBy(key) {\n      if (typeof key === 'function') {\n        this._expandGroupBy = key;\n      }\n    }\n    /**\n     * Defines the collection that will store the expanded group keys.\n     */\n\n\n    get expandedGroupKeys() {\n      return this._expandedGroupKeys;\n    }\n\n    set expandedGroupKeys(expandedGroups) {\n      this._expandedGroupKeys = (expandedGroups || []).slice();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    get keyGetter() {\n      return this.expandGroupBy || DEFAULT_KEY_GETTER;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isExpanded(groupArgs) {\n      const itemIndex = this.getItemIndex(groupArgs);\n      return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;\n    }\n\n    getItemIndex(groupArgs) {\n      if (this.expandGroupBy) {\n        return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));\n      }\n\n      return this.expandedGroupKeys.findIndex(item => {\n        let index = 0;\n        let parentGroup = groupArgs.parentGroup;\n\n        while (isPresent(parentGroup)) {\n          if (!isPresent(item.parentGroupKeys) || !isPresent(item.parentGroupKeys[index]) || parentGroup.group.value !== item.parentGroupKeys[index].value || parentGroup.group.field !== item.parentGroupKeys[index].field) {\n            return false;\n          }\n\n          parentGroup = parentGroup.parentGroup;\n          index++;\n        }\n\n        return item.value === groupArgs.group.value && item.field === groupArgs.group.field;\n      });\n    }\n\n    toggleState(groupArgs) {\n      const key = this.keyGetter(groupArgs);\n\n      if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {\n        this.expandedGroupKeys.push(key);\n      } else {\n        const index = this.expandedGroupKeys.indexOf(key);\n        this.expandedGroupKeys.splice(index, 1);\n      }\n\n      this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());\n    }\n\n  }\n\n  ExpandGroupDirective.ɵfac = function ExpandGroupDirective_Factory(t) {\n    return new (t || ExpandGroupDirective)(i0.ɵɵdirectiveInject(GridComponent));\n  };\n\n  ExpandGroupDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExpandGroupDirective,\n    selectors: [[\"\", \"kendoGridExpandGroupBy\", \"\"]],\n    inputs: {\n      expandGroupBy: [\"kendoGridExpandGroupBy\", \"expandGroupBy\"],\n      expandedGroupKeys: \"expandedGroupKeys\",\n      groupsInitiallyExpanded: \"groupsInitiallyExpanded\"\n    },\n    outputs: {\n      expandedGroupKeysChange: \"expandedGroupKeysChange\"\n    },\n    exportAs: [\"kendoGridExpandGroupBy\"]\n  });\n  return ExpandGroupDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug globalization_grid %}#toc-localization)).\n */\n\n\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  class CustomMessagesComponent extends GridMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) {\n    return new (t || CustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  CustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CustomMessagesComponent,\n    selectors: [[\"kendo-grid-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: GridMessages,\n      useExisting: forwardRef(() => CustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable no-access-missing-member\n\n\nconst stringOperators = localizeOperators({\n  \"filterContainsOperator\": \"contains\",\n  \"filterNotContainsOperator\": \"doesnotcontain\",\n  \"filterEqOperator\": \"eq\",\n  \"filterNotEqOperator\": \"neq\",\n  \"filterStartsWithOperator\": \"startswith\",\n  \"filterEndsWithOperator\": \"endswith\",\n  \"filterIsNullOperator\": \"isnull\",\n  \"filterIsNotNullOperator\": \"isnotnull\",\n  \"filterIsEmptyOperator\": \"isempty\",\n  \"filterIsNotEmptyOperator\": \"isnotempty\"\n});\n/**\n * @hidden\n */\n\nlet AutoCompleteFilterCellComponent = /*#__PURE__*/(() => {\n  class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {\n    constructor(filterService, column, localization) {\n      super(filterService);\n      this.localization = localization;\n      this.showOperators = true;\n      this.defaultOperators = stringOperators(this.localization);\n      this.column = column;\n    }\n\n    set valueField(value) {\n      this._valueField = value;\n    }\n\n    get valueField() {\n      return this._valueField ? this._valueField : this.column.field;\n    }\n\n    get currentFilter() {\n      return this.filterByField(this.column.field);\n    }\n\n    get currentOperator() {\n      return this.currentFilter ? this.currentFilter.operator : \"contains\";\n    }\n\n  }\n\n  AutoCompleteFilterCellComponent.ɵfac = function AutoCompleteFilterCellComponent_Factory(t) {\n    return new (t || AutoCompleteFilterCellComponent)(i0.ɵɵdirectiveInject(FilterService), i0.ɵɵdirectiveInject(ColumnComponent), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  AutoCompleteFilterCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AutoCompleteFilterCellComponent,\n    selectors: [[\"kendo-grid-autocomplete-filter-cell\"]],\n    inputs: {\n      showOperators: \"showOperators\",\n      column: \"column\",\n      filter: \"filter\",\n      data: \"data\",\n      valueField: \"valueField\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 7,\n    consts: [[3, \"column\", \"filter\", \"operators\", \"showOperators\"], [\"kendoFilterInput\", \"\", 3, \"data\", \"valueField\", \"value\"]],\n    template: function AutoCompleteFilterCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-grid-filter-wrapper-cell\", 0);\n        i0.ɵɵelement(1, \"kendo-autocomplete\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"column\", ctx.column)(\"filter\", ctx.filter)(\"operators\", ctx.operators)(\"showOperators\", ctx.showOperators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"data\", ctx.data)(\"valueField\", ctx.valueField)(\"value\", ctx.currentFilter == null ? null : ctx.currentFilter.value);\n      }\n    },\n    directives: [FilterCellWrapperComponent, i1$4.AutoCompleteComponent, FilterInputDirective],\n    encapsulation: 2\n  });\n  return AutoCompleteFilterCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$5 = [ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {\n    static exports() {\n      return [ColumnComponent, SpanColumnComponent, ColumnGroupComponent, FooterTemplateDirective, DetailTemplateDirective, FocusableDirective];\n    }\n\n  }\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], DraggableModule, EventsModule]\n  });\n  return SharedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `Contains` (**Contains**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet ContainsFilterOperatorComponent = /*#__PURE__*/(() => {\n  class ContainsFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"contains\", localization);\n    }\n\n  }\n\n  ContainsFilterOperatorComponent.ɵfac = function ContainsFilterOperatorComponent_Factory(t) {\n    return new (t || ContainsFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ContainsFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ContainsFilterOperatorComponent,\n    selectors: [[\"kendo-filter-contains-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => ContainsFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function ContainsFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ContainsFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `DoesNotContain` (**Does not contain**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet DoesNotContainFilterOperatorComponent = /*#__PURE__*/(() => {\n  class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"doesnotcontain\", localization);\n    }\n\n  }\n\n  DoesNotContainFilterOperatorComponent.ɵfac = function DoesNotContainFilterOperatorComponent_Factory(t) {\n    return new (t || DoesNotContainFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DoesNotContainFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DoesNotContainFilterOperatorComponent,\n    selectors: [[\"kendo-filter-not-contains-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DoesNotContainFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `EndsWith` (**Ends with**) string filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet EndsWithFilterOperatorComponent = /*#__PURE__*/(() => {\n  class EndsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"endswith\", localization);\n    }\n\n  }\n\n  EndsWithFilterOperatorComponent.ɵfac = function EndsWithFilterOperatorComponent_Factory(t) {\n    return new (t || EndsWithFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  EndsWithFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: EndsWithFilterOperatorComponent,\n    selectors: [[\"kendo-filter-endswith-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => EndsWithFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function EndsWithFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return EndsWithFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `Equal` (**Is equal to**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet EqualFilterOperatorComponent = /*#__PURE__*/(() => {\n  class EqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"eq\", localization);\n    }\n\n  }\n\n  EqualFilterOperatorComponent.ɵfac = function EqualFilterOperatorComponent_Factory(t) {\n    return new (t || EqualFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  EqualFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: EqualFilterOperatorComponent,\n    selectors: [[\"kendo-filter-eq-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => EqualFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function EqualFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return EqualFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `IsEmpty` (**Is empty**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet IsEmptyFilterOperatorComponent = /*#__PURE__*/(() => {\n  class IsEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"isempty\", localization);\n    }\n\n  }\n\n  IsEmptyFilterOperatorComponent.ɵfac = function IsEmptyFilterOperatorComponent_Factory(t) {\n    return new (t || IsEmptyFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  IsEmptyFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IsEmptyFilterOperatorComponent,\n    selectors: [[\"kendo-filter-isempty-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return IsEmptyFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `IsNotEmpty` (**Is not empty**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet IsNotEmptyFilterOperatorComponent = /*#__PURE__*/(() => {\n  class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"isnotempty\", localization);\n    }\n\n  }\n\n  IsNotEmptyFilterOperatorComponent.ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(t) {\n    return new (t || IsNotEmptyFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  IsNotEmptyFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IsNotEmptyFilterOperatorComponent,\n    selectors: [[\"kendo-filter-isnotempty-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return IsNotEmptyFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `IsNotNull` (**Is not null**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet IsNotNullFilterOperatorComponent = /*#__PURE__*/(() => {\n  class IsNotNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"isnotnull\", localization);\n    }\n\n  }\n\n  IsNotNullFilterOperatorComponent.ɵfac = function IsNotNullFilterOperatorComponent_Factory(t) {\n    return new (t || IsNotNullFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  IsNotNullFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IsNotNullFilterOperatorComponent,\n    selectors: [[\"kendo-filter-isnotnull-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return IsNotNullFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `IsNull` (**Is null**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet IsNullFilterOperatorComponent = /*#__PURE__*/(() => {\n  class IsNullFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"isnull\", localization);\n    }\n\n  }\n\n  IsNullFilterOperatorComponent.ɵfac = function IsNullFilterOperatorComponent_Factory(t) {\n    return new (t || IsNullFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  IsNullFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IsNullFilterOperatorComponent,\n    selectors: [[\"kendo-filter-isnull-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => IsNullFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IsNullFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return IsNullFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `NotEqual` (**Is not equal to**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet NotEqualFilterOperatorComponent = /*#__PURE__*/(() => {\n  class NotEqualFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"neq\", localization);\n    }\n\n  }\n\n  NotEqualFilterOperatorComponent.ɵfac = function NotEqualFilterOperatorComponent_Factory(t) {\n    return new (t || NotEqualFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NotEqualFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NotEqualFilterOperatorComponent,\n    selectors: [[\"kendo-filter-neq-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => NotEqualFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function NotEqualFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return NotEqualFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `StartsWith` (**Starts with**) filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet StartsWithFilterOperatorComponent = /*#__PURE__*/(() => {\n  class StartsWithFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"startswith\", localization);\n    }\n\n  }\n\n  StartsWithFilterOperatorComponent.ɵfac = function StartsWithFilterOperatorComponent_Factory(t) {\n    return new (t || StartsWithFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StartsWithFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StartsWithFilterOperatorComponent,\n    selectors: [[\"kendo-filter-startswith-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => StartsWithFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function StartsWithFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return StartsWithFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `Greater` (**Is greater than**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet GreaterFilterOperatorComponent = /*#__PURE__*/(() => {\n  class GreaterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"gt\", localization);\n    }\n\n  }\n\n  GreaterFilterOperatorComponent.ɵfac = function GreaterFilterOperatorComponent_Factory(t) {\n    return new (t || GreaterFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  GreaterFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GreaterFilterOperatorComponent,\n    selectors: [[\"kendo-filter-gt-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => GreaterFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function GreaterFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return GreaterFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet GreaterOrEqualToFilterOperatorComponent = /*#__PURE__*/(() => {\n  class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"gte\", localization);\n    }\n\n  }\n\n  GreaterOrEqualToFilterOperatorComponent.ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(t) {\n    return new (t || GreaterOrEqualToFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  GreaterOrEqualToFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GreaterOrEqualToFilterOperatorComponent,\n    selectors: [[\"kendo-filter-gte-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return GreaterOrEqualToFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `Less` (**Is less than**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet LessFilterOperatorComponent = /*#__PURE__*/(() => {\n  class LessFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"lt\", localization);\n    }\n\n  }\n\n  LessFilterOperatorComponent.ɵfac = function LessFilterOperatorComponent_Factory(t) {\n    return new (t || LessFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LessFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LessFilterOperatorComponent,\n    selectors: [[\"kendo-filter-lt-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => LessFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function LessFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return LessFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet LessOrEqualToFilterOperatorComponent = /*#__PURE__*/(() => {\n  class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"lte\", localization);\n    }\n\n  }\n\n  LessOrEqualToFilterOperatorComponent.ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(t) {\n    return new (t || LessOrEqualToFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LessOrEqualToFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LessOrEqualToFilterOperatorComponent,\n    selectors: [[\"kendo-filter-lte-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return LessOrEqualToFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `Greater` (**Is after**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet AfterFilterOperatorComponent = /*#__PURE__*/(() => {\n  class AfterFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"after\", localization);\n    }\n    /**\n     * @hidden\n     */\n\n\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"gt\"\n      };\n    }\n\n  }\n\n  AfterFilterOperatorComponent.ɵfac = function AfterFilterOperatorComponent_Factory(t) {\n    return new (t || AfterFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  AfterFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AfterFilterOperatorComponent,\n    selectors: [[\"kendo-filter-after-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => AfterFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function AfterFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return AfterFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `GreaterOrEqualTo` (**Is after or equal to**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet AfterEqFilterOperatorComponent = /*#__PURE__*/(() => {\n  class AfterEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"after-eq\", localization);\n    }\n    /**\n     * @hidden\n     */\n\n\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"gte\"\n      };\n    }\n\n  }\n\n  AfterEqFilterOperatorComponent.ɵfac = function AfterEqFilterOperatorComponent_Factory(t) {\n    return new (t || AfterEqFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  AfterEqFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AfterEqFilterOperatorComponent,\n    selectors: [[\"kendo-filter-after-eq-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => AfterEqFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function AfterEqFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return AfterEqFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `LessOrEqualTo` (**Is before or equal to**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet BeforeEqFilterOperatorComponent = /*#__PURE__*/(() => {\n  class BeforeEqFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"before-eq\", localization);\n    }\n    /**\n     * @hidden\n     */\n\n\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"lte\"\n      };\n    }\n\n  }\n\n  BeforeEqFilterOperatorComponent.ɵfac = function BeforeEqFilterOperatorComponent_Factory(t) {\n    return new (t || BeforeEqFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  BeforeEqFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BeforeEqFilterOperatorComponent,\n    selectors: [[\"kendo-filter-before-eq-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return BeforeEqFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents the `Less then` (**Is before**) date filter operator.\n *\n * For more information and examples, refer to:\n * * [Setting the default filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-default-filter-operator)\n * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_grid %}#toc-setting-the-order-of-the-filter-operators)\n */\n\n\nlet BeforeFilterOperatorComponent = /*#__PURE__*/(() => {\n  class BeforeFilterOperatorComponent extends FilterOperatorBase {\n    constructor(localization) {\n      super(\"before\", localization);\n    }\n    /**\n     * @hidden\n     */\n\n\n    toJSON() {\n      return {\n        text: this.text,\n        value: \"lt\"\n      };\n    }\n\n  }\n\n  BeforeFilterOperatorComponent.ɵfac = function BeforeFilterOperatorComponent_Factory(t) {\n    return new (t || BeforeFilterOperatorComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  BeforeFilterOperatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BeforeFilterOperatorComponent,\n    selectors: [[\"kendo-filter-before-operator\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FilterOperatorBase,\n      useExisting: forwardRef(() => BeforeFilterOperatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function BeforeFilterOperatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return BeforeFilterOperatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FILTER_OPERATORS = [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent];\nconst importedModules$4 = [CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule];\nconst COMPONENTS$1 = [FilterInputDirective];\n/**\n * @hidden\n */\n\nlet SharedFilterModule = /*#__PURE__*/(() => {\n  class SharedFilterModule {\n    static exports() {\n      return [...FILTER_OPERATORS];\n    }\n\n  }\n\n  SharedFilterModule.ɵfac = function SharedFilterModule_Factory(t) {\n    return new (t || SharedFilterModule)();\n  };\n\n  SharedFilterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedFilterModule\n  });\n  SharedFilterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[...importedModules$4], CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule]\n  });\n  return SharedFilterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INTERNAL_COMPONENTS$2 = [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent];\nconst ENTRY_COMPONENTS$1 = [StringFilterCellComponent, NumericFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent];\n/**\n * @hidden\n */\n\nlet RowFilterModule = /*#__PURE__*/(() => {\n  class RowFilterModule {\n    static exports() {\n      return [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, FilterCellOperatorsComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent, SharedFilterModule.exports()];\n    }\n\n  }\n\n  RowFilterModule.ɵfac = function RowFilterModule_Factory(t) {\n    return new (t || RowFilterModule)();\n  };\n\n  RowFilterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RowFilterModule\n  });\n  RowFilterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedFilterModule], SharedFilterModule]\n  });\n  return RowFilterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst importedModules$3 = [CommonModule, InputsModule, LabelModule, DropDownsModule, ResizeSensorModule, SharedModule];\nconst INTERNAL_COMPONENTS$1 = [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective];\n/**\n * @hidden\n */\n\nlet PagerModule = /*#__PURE__*/(() => {\n  class PagerModule {\n    static exports() {\n      return [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective];\n    }\n\n  }\n\n  PagerModule.ɵfac = function PagerModule_Factory(t) {\n    return new (t || PagerModule)();\n  };\n\n  PagerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PagerModule\n  });\n  PagerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[...importedModules$3]]\n  });\n  return PagerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exported$1 = [DraggableColumnDirective, DropTargetDirective];\n/**\n * @hidden\n */\n\nlet DragAndDropModule = /*#__PURE__*/(() => {\n  class DragAndDropModule {}\n\n  DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  };\n\n  DragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DragAndDropModule\n  });\n  DragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return DragAndDropModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$4 = [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, GroupIndicatorComponent];\n/**\n * @hidden\n */\n\nlet GroupModule = /*#__PURE__*/(() => {\n  class GroupModule {\n    static exports() {\n      return [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective];\n    }\n\n  }\n\n  GroupModule.ɵfac = function GroupModule_Factory(t) {\n    return new (t || GroupModule)();\n  };\n\n  GroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GroupModule\n  });\n  GroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, SharedModule, DragAndDropModule]]\n  });\n  return GroupModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INTERNAL_COMPONENTS = [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective];\nconst ENTRY_COMPONENTS = [StringFilterMenuComponent, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent];\n/**\n * @hidden\n */\n\nlet FilterMenuModule = /*#__PURE__*/(() => {\n  class FilterMenuModule {\n    static exports() {\n      return [StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, SharedFilterModule.exports()];\n    }\n\n  }\n\n  FilterMenuModule.ɵfac = function FilterMenuModule_Factory(t) {\n    return new (t || FilterMenuModule)();\n  };\n\n  FilterMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FilterMenuModule\n  });\n  FilterMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedFilterModule], SharedFilterModule]\n  });\n  return FilterMenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the component for selecting columns in the Grid. To enable the user to show or hide columns,\n * add the component inside a [ToolbarTemplate]({% slug api_grid_toolbartemplatedirective %}) directive.\n *\n * @example\n * ```ts-preview\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *       <kendo-grid [data]=\"data\">\n *          <ng-template kendoGridToolbarTemplate>\n *             <kendo-grid-column-chooser></kendo-grid-column-chooser>\n *          </ng-template>\n *          <kendo-grid-column field=\"Field1\"></kendo-grid-column>\n *          <kendo-grid-column field=\"Field2\" [hidden]=\"true\"></kendo-grid-column>\n *       </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *   public data: any[] = [{ Field1: 'Foo', Field2: 'Bar' }];\n * }\n * ```\n */\n\n\nlet ColumnChooserComponent = /*#__PURE__*/(() => {\n  class ColumnChooserComponent {\n    constructor(localization, columnInfoService, popupService, ngZone, renderer, changeDetector) {\n      this.localization = localization;\n      this.columnInfoService = columnInfoService;\n      this.popupService = popupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.changeDetector = changeDetector;\n      /**\n       * Specifies if the changes in the visibility of the column will be immediately applied.\n       */\n\n      this.autoSync = false;\n      /**\n       * Specifies if all columns can be hidden.\n       */\n\n      this.allowHideAll = true;\n    }\n\n    get columns() {\n      return this.columnInfoService.leafNamedColumns;\n    }\n\n    ngOnDestroy() {\n      this.close();\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggle(anchor, template) {\n      if (!this.popupRef) {\n        const direction = this.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: anchor,\n          content: template,\n          positionMode: 'absolute',\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          }\n        });\n        this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');\n        this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen(\"document\", \"click\", ({\n          target\n        }) => {\n          if (!closest(target, node => node === this.popupRef.popupElement || node === anchor)) {\n            this.close();\n          }\n        }));\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onApply(changed) {\n      this.close();\n\n      if (changed.length) {\n        this.changeDetector.markForCheck();\n        this.columnInfoService.changeVisibility(changed);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onChange(changed) {\n      this.changeDetector.markForCheck();\n      this.columnInfoService.changeVisibility(changed);\n    }\n\n    close() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n\n      this.detachClose();\n    }\n\n    detachClose() {\n      if (this.closeClick) {\n        this.closeClick();\n        this.closeClick = null;\n      }\n    }\n\n  }\n\n  ColumnChooserComponent.ɵfac = function ColumnChooserComponent_Factory(t) {\n    return new (t || ColumnChooserComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(ColumnInfoService), i0.ɵɵdirectiveInject(i1$2.PopupService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  ColumnChooserComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColumnChooserComponent,\n    selectors: [[\"kendo-grid-column-chooser\"]],\n    inputs: {\n      autoSync: \"autoSync\",\n      allowHideAll: \"allowHideAll\"\n    },\n    decls: 5,\n    vars: 1,\n    consts: [[\"type\", \"button\", 1, \"k-button\", \"k-button-flat-base\", \"k-button-flat\", \"k-icon-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-rectangle\", \"k-icon-button\", 3, \"click\"], [\"anchor\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-columns\"], [\"template\", \"\"], [1, \"k-column-chooser-title\"], [3, \"columns\", \"applyText\", \"resetText\", \"autoSync\", \"allowHideAll\", \"apply\", \"columnChange\"]],\n    template: function ColumnChooserComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r6 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function ColumnChooserComponent_Template_button_click_0_listener() {\n          i0.ɵɵrestoreView(_r6);\n\n          const _r0 = i0.ɵɵreference(1);\n\n          const _r1 = i0.ɵɵreference(4);\n\n          return ctx.toggle(_r0, _r1);\n        });\n        i0.ɵɵelement(2, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, ColumnChooserComponent_ng_template_3_Template, 3, 6, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"title\", ctx.localization.get(\"columns\"));\n      }\n    },\n    directives: [ColumnListComponent],\n    encapsulation: 2\n  });\n  return ColumnChooserComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENTS = [ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent];\n/**\n * @hidden\n */\n\nlet ColumnMenuModule = /*#__PURE__*/(() => {\n  class ColumnMenuModule {\n    static exports() {\n      return [ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent];\n    }\n\n  }\n\n  ColumnMenuModule.ɵfac = function ColumnMenuModule_Factory(t) {\n    return new (t || ColumnMenuModule)();\n  };\n\n  ColumnMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ColumnMenuModule\n  });\n  ColumnMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FilterMenuModule]]\n  });\n  return ColumnMenuModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$3 = [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective];\nconst importedModules$2 = [CommonModule, GroupModule, RowFilterModule, FilterMenuModule, SharedModule, DragAndDropModule, ColumnMenuModule];\n/**\n * @hidden\n */\n\nlet HeaderModule = /*#__PURE__*/(() => {\n  class HeaderModule {\n    static exports() {\n      return [HeaderTemplateDirective, SelectAllCheckboxDirective];\n    }\n\n  }\n\n  HeaderModule.ɵfac = function HeaderModule_Factory(t) {\n    return new (t || HeaderModule)();\n  };\n\n  HeaderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: HeaderModule\n  });\n  HeaderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[...importedModules$2]]\n  });\n  return HeaderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the checkbox for selecting columns in the Grid. If the column is\n * defined as empty, it renders a default checkbox for row selection.\n * You can also define the content of the column inside an `<ng-template>` tag.\n * The input requires you to include the `SelectionCheckbox` option.\n *\n * The template context is set to the current data item and the following additional fields are passed:\n * - `columnIndex`&mdash;The current column index.\n * - `rowIndex`&mdash;The current data row index. If inside a new item row, it will be `-1`.\n * - `dataItem`&mdash;The current data item.\n * - `column`&mdash;The current column instance.\n * - `isNew`&mdash;The state of the current item.\n *\n * For more examples, refer to:\n * - [Selecting or deselecting all items on a page]({% slug selection_grid %}#toc-select-all-feature)\n * - [Persisting the selection]({% slug selection_grid %}#toc-in-combination-with-the-select-all-feature)\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-grid [data]=\"gridData\" [selectable]=\"{enabled: true, checkboxOnly: true}\">\n *          <kendo-grid-column field=\"ProductID\" title=\"Product ID\" [width]=\"120\">\n *          </kendo-grid-column>\n *          <kendo-grid-column field=\"ProductName\" title=\"Product Name\">\n *          </kendo-grid-column>\n *          <kendo-grid-checkbox-column title=\"Default checkbox\">\n *          </kendo-grid-checkbox-column>\n *          <kendo-grid-checkbox-column title=\"Custom checkbox\">\n *            <ng-template kendoGridCellTemplate let-idx=\"rowIndex\">\n *              Select row <input [kendoGridSelectionCheckbox]=\"idx\" />\n *            </ng-template>\n *          </kendo-grid-checkbox-column>\n *        </kendo-grid>\n *    `\n * })\n *\n * class AppComponent {\n *    public gridData: any[];\n *\n *    constructor() {\n *        this.gridData = products;\n *    }\n * }\n *\n * const products = [{\n *    \"ProductID\": 1,\n *    \"ProductName\": \"Chai\",\n *    \"UnitPrice\": 18.0000,\n *    \"Discontinued\": true\n *  }, {\n *    \"ProductID\": 2,\n *    \"ProductName\": \"Chang\",\n *    \"UnitPrice\": 19.0000,\n *    \"Discontinued\": false\n *  }\n * ];\n *\n * ```\n */\n\n\nlet CheckboxColumnComponent = /*#__PURE__*/(() => {\n  class CheckboxColumnComponent extends ColumnBase {\n    constructor(parent, idService) {\n      super(parent, idService);\n      this.parent = parent;\n      /*\n       * @hidden\n       */\n\n      this.isCheckboxColumn = true;\n    }\n\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n\n  }\n\n  CheckboxColumnComponent.ɵfac = function CheckboxColumnComponent_Factory(t) {\n    return new (t || CheckboxColumnComponent)(i0.ɵɵdirectiveInject(ColumnBase, 13), i0.ɵɵdirectiveInject(IdService, 8));\n  };\n\n  CheckboxColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CheckboxColumnComponent,\n    selectors: [[\"kendo-grid-checkbox-column\"]],\n    contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      showSelectAll: \"showSelectAll\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColumnBase,\n      useExisting: forwardRef(() => CheckboxColumnComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CheckboxColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CheckboxColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `edit` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [edit]({% slug api_grid_gridcomponent %}#toc-edit) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is in the edit mode, the button with `kendoGridEditCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridEditCommand class=\"k-primary\">Edit</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n */\n\n\nlet EditCommandDirective = /*#__PURE__*/(() => {\n  class EditCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.editService = editService;\n      this.cellContext = cellContext;\n      /**\n       * @hidden\n       */\n\n      this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get visible() {\n      return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n      this.editService.beginEdit(this.rowIndex);\n    }\n\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n\n  }\n\n  EditCommandDirective.ɵfac = function EditCommandDirective_Factory(t) {\n    return new (t || EditCommandDirective)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  EditCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: EditCommandDirective,\n    selectors: [[\"\", \"kendoGridEditCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function EditCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function EditCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-edit-command\", ctx.commandClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return EditCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `cancel` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [cancel]({% slug api_grid_gridcomponent %}#toc-cancel) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is not in the edit mode, the button with the `kendoGridCancelCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridCancelCommand>Cancel changes</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\n\n\nlet CancelCommandDirective = /*#__PURE__*/(() => {\n  class CancelCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.editService = editService;\n      this.cellContext = cellContext;\n      /**\n       * @hidden\n       */\n\n      this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get visible() {\n      return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n\n      if (this.isEdited) {\n        this.editService.endEdit(this.rowIndex);\n      }\n    }\n\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n\n  }\n\n  CancelCommandDirective.ɵfac = function CancelCommandDirective_Factory(t) {\n    return new (t || CancelCommandDirective)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  CancelCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CancelCommandDirective,\n    selectors: [[\"\", \"kendoGridCancelCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function CancelCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-cancel-command\", ctx.commandClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return CancelCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `save` command of the Grid. You can apply this directive to any `button`\n * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [save]({% slug api_grid_gridcomponent %}#toc-save) event\n * is triggered ([see example]({% slug editing_grid %})).\n *\n * > When the row is not in the edit mode, the button with `kendoGridSaveCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridSaveCommand>Save changes</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n *\n * You can control the content of the button based on the state of the row.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate let-isNew=\"isNew\">\n *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\n\n\nlet SaveCommandDirective = /*#__PURE__*/(() => {\n  class SaveCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.editService = editService;\n      this.cellContext = cellContext;\n      /**\n       * @hidden\n       */\n\n      this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get visible() {\n      return !this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n\n      if (this.isEdited) {\n        this.editService.save(this.rowIndex);\n      }\n    }\n\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n\n  }\n\n  SaveCommandDirective.ɵfac = function SaveCommandDirective_Factory(t) {\n    return new (t || SaveCommandDirective)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  SaveCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SaveCommandDirective,\n    selectors: [[\"\", \"kendoGridSaveCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function SaveCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-save-command\", ctx.commandClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return SaveCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `remove` command of the Grid. You can apply this directive to any `button` element\n * inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [remove event]({% slug api_grid_gridcomponent %}#toc-remove)\n * is triggered ([see example]({% slug editing_reactive_forms_grid %})).\n *\n * > When the row is in the edit mode, the button with the `kendoGridRemoveCommand` is automatically hidden.\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *   <kendo-grid-command-column title=\"command\">\n *     <ng-template kendoGridCellTemplate>\n *       <button kendoGridRemoveCommand>Remove row</button>\n *     </ng-template>\n *   </kendo-grid-command-column>\n * </kendo-grid>\n * ```\n */\n\n\nlet RemoveCommandDirective = /*#__PURE__*/(() => {\n  class RemoveCommandDirective extends Button {\n    constructor(editService, cellContext, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.editService = editService;\n      this.cellContext = cellContext;\n      /**\n       * @hidden\n       */\n\n      this.commandClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get visible() {\n      return this.isEdited ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n      this.editService.remove(this.rowIndex);\n    }\n\n    ngDoCheck() {\n      if (this.cellContext) {\n        this.rowIndex = this.cellContext.rowIndex;\n        this.isEdited = this.editService.isEdited(this.rowIndex);\n      }\n    }\n\n  }\n\n  RemoveCommandDirective.ɵfac = function RemoveCommandDirective_Factory(t) {\n    return new (t || RemoveCommandDirective)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(CELL_CONTEXT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  RemoveCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RemoveCommandDirective,\n    selectors: [[\"\", \"kendoGridRemoveCommand\", \"\"]],\n    hostVars: 4,\n    hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RemoveCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n        i0.ɵɵclassProp(\"k-grid-remove-command\", ctx.commandClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RemoveCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the command for adding a new item to the Grid. You can apply this directive to any\n * `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).\n * When an associated button with the directive is clicked, the\n * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered\n * ([see example]({% slug editing_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *    <ng-template kendoGridToolbarTemplate>\n *       <button kendoGridAddCommand>Add new</button>\n *    </ng-template>\n * </kendo-grid>\n * ```\n */\n\n\nlet AddCommandDirective = /*#__PURE__*/(() => {\n  class AddCommandDirective extends Button {\n    constructor(editService, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.editService = editService;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n      this.editService.beginAdd();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get commandClass() {\n      return true;\n    }\n\n  }\n\n  AddCommandDirective.ɵfac = function AddCommandDirective_Factory(t) {\n    return new (t || AddCommandDirective)(i0.ɵɵdirectiveInject(EditService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  AddCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AddCommandDirective,\n    selectors: [[\"\", \"kendoGridAddCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function AddCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function AddCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-add-command\", ctx.commandClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return AddCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exported = [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective];\nconst importedModules$1 = [CommonModule, ReactiveFormsModule, FormsModule, SharedModule, GroupModule, NumericTextBoxModule, DatePickerModule, ResizeSensorModule];\n/**\n * @hidden\n */\n\nlet BodyModule = /*#__PURE__*/(() => {\n  class BodyModule {\n    static exports() {\n      return [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, NoRecordsTemplateDirective, EditTemplateDirective, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective];\n    }\n\n  }\n\n  BodyModule.ɵfac = function BodyModule_Factory(t) {\n    return new (t || BodyModule)();\n  };\n\n  BodyModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BodyModule\n  });\n  BodyModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[...importedModules$1]]\n  });\n  return BodyModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$2 = [FooterComponent];\nconst importedModules = [CommonModule, SharedModule];\n/**\n * @hidden\n */\n\nlet FooterModule = /*#__PURE__*/(() => {\n  class FooterModule {\n    static exports() {\n      return [];\n    }\n\n  }\n\n  FooterModule.ɵfac = function FooterModule_Factory(t) {\n    return new (t || FooterModule)();\n  };\n\n  FooterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FooterModule\n  });\n  FooterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[...importedModules]]\n  });\n  return FooterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass LocalEditService {\n  constructor(grid, localDataChangesService) {\n    this.grid = grid;\n    this.localDataChangesService = localDataChangesService;\n  }\n\n  create(item) {\n    if (this.hasLocalData && this.grid.skip) {\n      this.localDataChangesService.data.splice(this.grid.skip, 0, item);\n    } else {\n      this.data.unshift(item);\n    }\n\n    this.dataChanged();\n  }\n\n  update(_item) {} // eslint-disable-line no-empty\n\n\n  remove(item) {\n    const data = this.data;\n\n    for (let idx = 0; idx < data.length; idx++) {\n      if (item === data[idx]) {\n        data.splice(idx, 1);\n        this.dataChanged({\n          action: 'remove',\n          item: item\n        });\n        break;\n      }\n    }\n  }\n\n  assignValues(target, source) {\n    Object.assign(target, source);\n  }\n\n  dataChanged(args = {}) {\n    if (this.hasLocalData) {\n      this.localDataChangesService.changes.emit(args);\n    }\n  }\n\n  get hasLocalData() {\n    return Array.isArray(this.localDataChangesService.data);\n  }\n\n  get data() {\n    if (this.hasLocalData) {\n      return this.localDataChangesService.data;\n    }\n\n    const data = this.grid.data;\n\n    if (Array.isArray(data)) {\n      return data;\n    }\n\n    if (isDevMode()) {\n      throw new Error('The default edit service of the editing directives works only when binding to plain array.' + 'Please provide an editService.');\n    }\n\n    return [];\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet EditingDirectiveBase = /*#__PURE__*/(() => {\n  class EditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n      this.defaultEditService = this.createDefaultService();\n    } // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.\n    // The Input should still be kept.\n\n    /**\n     * The edit service that will handle the operations.\n     */\n\n\n    set editService(value) {\n      this.userEditService = value;\n    }\n\n    get editService() {\n      return this.userEditService || this.defaultEditService;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.subscriptions = this.grid.add.subscribe(this.addHandler.bind(this));\n      this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));\n      this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));\n      this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));\n      this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    createDefaultService() {\n      return new LocalEditService(this.grid, this.localDataChangesService);\n    }\n\n    addHandler() {\n      this.grid.addRow(this.createModel({\n        isNew: true\n      }));\n    }\n\n    saveHandler(args) {\n      const item = this.saveModel(args);\n\n      if (item) {\n        if (args.isNew) {\n          this.editService.create(item);\n        } else {\n          this.editService.update(item);\n        }\n      }\n\n      this.grid.closeRow(args.rowIndex);\n    }\n\n    cancelHandler({\n      rowIndex\n    }) {\n      this.closeEditor(rowIndex);\n    }\n\n    removeHandler({\n      dataItem\n    }) {\n      const removeItem = shouldRemove => {\n        if (shouldRemove) {\n          this.editService.remove(dataItem);\n        }\n      };\n\n      if (this.removeConfirmation) {\n        const result = this.removeConfirmation(dataItem);\n\n        if (result instanceof Promise) {\n          result.then(removeItem);\n        } else if (result instanceof Observable) {\n          result.pipe(take(1)).subscribe(removeItem);\n        } else {\n          removeItem(result);\n        }\n      } else {\n        removeItem(true);\n      }\n    }\n\n    onStateChange() {\n      this.closeEditor();\n    }\n\n    closeEditor(rowIndex) {\n      this.grid.closeRow(rowIndex);\n    }\n\n  }\n\n  EditingDirectiveBase.ɵfac = function EditingDirectiveBase_Factory(t) {\n    return new (t || EditingDirectiveBase)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  };\n\n  EditingDirectiveBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: EditingDirectiveBase,\n    selectors: [[\"\", \"kendoGridEditingDirectiveBase\", \"\"]],\n    inputs: {\n      editService: \"editService\",\n      removeConfirmation: \"removeConfirmation\"\n    }\n  });\n  return EditingDirectiveBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass LocalRowEditService extends LocalEditService {\n  update(_item) {\n    this.dataChanged();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet RowEditingDirectiveBase = /*#__PURE__*/(() => {\n  class RowEditingDirectiveBase extends EditingDirectiveBase {\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n      super.ngOnInit();\n      this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));\n    }\n\n    createDefaultService() {\n      return new LocalRowEditService(this.grid, this.localDataChangesService);\n    }\n\n    addHandler() {\n      this.closeEditor();\n      super.addHandler();\n    }\n\n    editHandler(args) {\n      this.closeEditor();\n      this.rowIndex = args.rowIndex;\n      this.grid.editRow(args.rowIndex, this.createModel(args));\n    }\n\n    saveHandler(args) {\n      super.saveHandler(args);\n      this.clean();\n    }\n\n    closeEditor(rowIndex = this.rowIndex) {\n      super.closeEditor(rowIndex);\n      this.clean();\n    }\n\n    clean() {\n      delete this.rowIndex;\n    }\n\n  }\n\n  RowEditingDirectiveBase.ɵfac = /* @__PURE__ */function () {\n    let ɵRowEditingDirectiveBase_BaseFactory;\n    return function RowEditingDirectiveBase_Factory(t) {\n      return (ɵRowEditingDirectiveBase_BaseFactory || (ɵRowEditingDirectiveBase_BaseFactory = i0.ɵɵgetInheritedFactory(RowEditingDirectiveBase)))(t || RowEditingDirectiveBase);\n    };\n  }();\n\n  RowEditingDirectiveBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RowEditingDirectiveBase,\n    selectors: [[\"\", \"kendoGridRowEditingDirectiveBase\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RowEditingDirectiveBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the editing operations of the Grid when using\n * the Template-Driven Angular Forms ([see example]({% slug editing_directives_grid %}#toc-the-template-directive)).\n */\n\n\nlet TemplateEditingDirective = /*#__PURE__*/(() => {\n  class TemplateEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n      super(grid, localDataChangesService);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n    }\n\n    editHandler(args) {\n      super.editHandler(args);\n      this.dataItem = args.dataItem;\n      this.originalValues = {};\n      this.editService.assignValues(this.originalValues, this.dataItem);\n    }\n\n    closeEditor(rowIndex) {\n      if (this.dataItem) {\n        this.editService.assignValues(this.dataItem, this.originalValues);\n      }\n\n      super.closeEditor(rowIndex);\n    }\n\n    createModel(args) {\n      if (args.isNew) {\n        return this.createNewItem();\n      }\n    }\n\n    saveModel(args) {\n      return args.dataItem;\n    }\n\n    clean() {\n      super.clean();\n      delete this.dataItem;\n    }\n\n  }\n\n  TemplateEditingDirective.ɵfac = function TemplateEditingDirective_Factory(t) {\n    return new (t || TemplateEditingDirective)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  };\n\n  TemplateEditingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateEditingDirective,\n    selectors: [[\"\", \"kendoGridTemplateEditing\", \"\"]],\n    inputs: {\n      createNewItem: [\"kendoGridTemplateEditing\", \"createNewItem\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TemplateEditingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst markAllAsTouched = control => {\n  control.markAsTouched();\n\n  if (control.hasOwnProperty('controls')) {\n    let controls = control.controls;\n\n    for (let inner in controls) {\n      if (controls.hasOwnProperty(inner)) {\n        markAllAsTouched(controls[inner]);\n      }\n    }\n  }\n};\n/**\n * A directive which encapsulates the editing operations of the Grid when using the\n * Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-reactive-directive)).\n */\n\n\nlet ReactiveEditingDirective = /*#__PURE__*/(() => {\n  class ReactiveEditingDirective extends RowEditingDirectiveBase {\n    constructor(grid, localDataChangesService) {\n      super(grid, localDataChangesService);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n    }\n\n    createModel(args) {\n      return this.createFormGroup(args);\n    }\n\n    saveModel({\n      dataItem,\n      formGroup,\n      isNew\n    }) {\n      if (!formGroup.dirty && !isNew) {\n        return;\n      }\n\n      if (formGroup.valid) {\n        this.editService.assignValues(dataItem, formGroup.value);\n        return dataItem;\n      }\n\n      markAllAsTouched(formGroup);\n    }\n\n  }\n\n  ReactiveEditingDirective.ɵfac = function ReactiveEditingDirective_Factory(t) {\n    return new (t || ReactiveEditingDirective)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  };\n\n  ReactiveEditingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ReactiveEditingDirective,\n    selectors: [[\"\", \"kendoGridReactiveEditing\", \"\"]],\n    inputs: {\n      createFormGroup: [\"kendoGridReactiveEditing\", \"createFormGroup\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ReactiveEditingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the editing operations of the Grid when using the in-cell\n * editing with Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-the-incell-directive)).\n */\n\n\nlet InCellEditingDirective = /*#__PURE__*/(() => {\n  class InCellEditingDirective extends EditingDirectiveBase {\n    constructor(grid, localDataChangesService, cdr) {\n      super(grid, localDataChangesService);\n      this.grid = grid;\n      this.localDataChangesService = localDataChangesService;\n      this.cdr = cdr;\n    } // Need mixin\n\n\n    createModel(args) {\n      return this.createFormGroup(args);\n    }\n\n    saveModel({\n      dataItem,\n      formGroup,\n      isNew\n    }) {\n      if (!formGroup.dirty && !isNew) {\n        return;\n      }\n\n      if (formGroup.valid) {\n        this.editService.assignValues(dataItem, formGroup.value);\n        return dataItem;\n      }\n\n      markAllAsTouched(formGroup);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));\n      this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));\n    }\n\n    removeHandler(args) {\n      super.removeHandler(args);\n      this.grid.cancelCell();\n    }\n\n    cellClickHandler(args) {\n      if (!args.isEdited && args.type !== 'contextmenu') {\n        this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));\n        this.cdr.markForCheck();\n      }\n    }\n\n    cellCloseHandler(args) {\n      const {\n        formGroup,\n        dataItem\n      } = args;\n\n      if (!formGroup.valid) {\n        args.preventDefault();\n      } else if (formGroup.dirty) {\n        if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {\n          return;\n        }\n\n        this.editService.assignValues(dataItem, formGroup.value);\n        this.editService.update(dataItem);\n      }\n    }\n\n  }\n\n  InCellEditingDirective.ɵfac = function InCellEditingDirective_Factory(t) {\n    return new (t || InCellEditingDirective)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(LocalDataChangesService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  InCellEditingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InCellEditingDirective,\n    selectors: [[\"\", \"kendoGridInCellEditing\", \"\"]],\n    inputs: {\n      createFormGroup: [\"kendoGridInCellEditing\", \"createFormGroup\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return InCellEditingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst hasGroups = items => items && items.length && items[0].field && items[0].items;\n\nconst groupDescriptorsPresent = descriptors => isPresent(descriptors) && descriptors.length > 0;\n\nconst processGroups = (data, state) => process(data, state).data;\n\nconst removeParentDescriptors = (parents, owner) => g => g.field !== owner.field && !parents.some(y => y.field === g.field);\n\nconst findGroup = (groupIndex, groups) => {\n  const parents = [];\n  return {\n    group: groupIndex.split(\"_\").reduce((acc, x) => {\n      const idx = parseInt(x, 10);\n\n      if (acc.items) {\n        parents.push(acc);\n        return acc.items[idx];\n      }\n\n      return isArray(acc) ? acc[idx] : acc;\n    }, groups),\n    parents\n  };\n};\n\nconst findChildren = (data, parents) => {\n  const filters = parents.map(p => ({\n    field: p.field,\n    operator: \"eq\",\n    value: p.value\n  }));\n  return filterBy(data, {\n    filters: filters,\n    logic: \"and\"\n  });\n};\n/**\n * @hidden\n */\n\n\nconst count = (groups, includeFooters = false) => groups.reduce((acc, group) => {\n  if (!group.skipHeader) {\n    acc++;\n  }\n\n  if (group.items) {\n    const children = count(group.items, includeFooters);\n\n    if (includeFooters && children && !group.hideFooter) {\n      acc++;\n    }\n\n    acc += children;\n  }\n\n  return acc;\n}, 0);\n/**\n * @hidden\n */\n\n\nconst slice = (groups, skip, take, includeFooters = false) => {\n  if (!isPresent(take)) {\n    return groups;\n  }\n\n  const result = [];\n\n  for (let idx = 0, length = groups.length; idx < length; idx++) {\n    if (take <= 0) {\n      break;\n    }\n\n    const group = groups[idx];\n    const groupItems = group.items;\n    let itemCount = count(groupItems, includeFooters);\n\n    if (includeFooters && groupItems.length) {\n      itemCount++;\n    }\n\n    const skipHeader = skip > 0;\n\n    if (skip) {\n      skip--;\n\n      if (itemCount && skip >= itemCount) {\n        skip -= itemCount;\n        continue;\n      }\n    }\n\n    if (!skipHeader || itemCount) {\n      const items = [];\n      let hideFooter = true;\n\n      if (!skipHeader) {\n        take--;\n      }\n\n      if (take) {\n        if (hasGroups(groupItems)) {\n          const children = slice(groupItems, skip, take, includeFooters);\n          items.push(...children);\n          take -= count(children, includeFooters);\n        } else {\n          items.push(...groupItems.slice(skip, Math.min(skip + take, groupItems.length)));\n          take -= items.length;\n        }\n\n        if (take && includeFooters) {\n          hideFooter = false;\n          take--;\n        }\n\n        skip = 0;\n      }\n\n      result.push({\n        aggregates: group.aggregates,\n        field: group.field,\n        hideFooter,\n        items,\n        offset: idx,\n        skipHeader,\n        value: group.value\n      });\n    }\n  }\n\n  return result;\n};\n\nconst skippedHeaders = groupItem => {\n  let total = 0;\n\n  while (groupItem) {\n    if (groupItem.skipHeader) {\n      total++;\n    }\n\n    groupItem = groupItem.items && groupItem.items[0] || null;\n  }\n\n  return total;\n};\n/**\n * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.\n */\n\n\nlet GroupBindingDirective = /*#__PURE__*/(() => {\n  class GroupBindingDirective extends DataBindingDirective {\n    constructor(grid, changeDetector, localDataChangesService) {\n      super(grid, changeDetector, localDataChangesService);\n    }\n    /**\n     * The array of data which will be used to populate the Grid.\n     */\n\n\n    set kendoGridGroupBinding(value) {\n      this.groups = null;\n      this.grid.resetGroupsState();\n      this.data = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set data(value) {\n      this.originalData = value || [];\n      this.dataChanged = true;\n    }\n    /**\n     * Defines the descriptors by which the data will be sorted.\n     */\n\n\n    set sort(value) {\n      const clear = this.state.sort !== value;\n      this.grid.sort = this.state.sort = value;\n\n      if (clear) {\n        this.groups = null;\n        this.grid.resetGroupsState();\n      }\n    }\n    /**\n     * Defines the descriptor by which the data will be filtered.\n     */\n\n\n    set filter(value) {\n      const clear = diffFilters(this.state.filter, value);\n\n      if (clear) {\n        this.state.filter = value;\n        this.grid.filter = cloneFilters(value);\n        this.groups = null;\n        this.grid.resetGroupsState();\n      }\n    }\n    /**\n     * Defines the descriptors by which the data will be grouped.\n     */\n\n\n    set group(value) {\n      // don't clear if no groups are present in previous and current value\n      const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value);\n      const clear = this.state.group !== value && groupsPresent;\n      this.grid.group = this.state.group = value;\n\n      if (clear) {\n        this.groups = null;\n        this.grid.resetGroupsState();\n        this.skip = 0;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      this.grid.groupExpand.subscribe(this.groupExpand.bind(this));\n      this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this));\n    }\n\n    ngAfterContentInit() {\n      if (isDevMode() && this.grid.isGroupExpanded) {\n        throw new Error('Using the `kendoGridGroupBinding` directive in combination with the `kendoGridExpandGroupBy` directive ' + 'or the `isGroupExpanded` callback is not supported. To use grouping with the `kendoGridGroupBinding` directive, ' + 'set the Grid `groupable` property to `true`.');\n      }\n    }\n\n    groupExpand({\n      groupIndex\n    }) {\n      this.grid.expandGroupChildren(groupIndex);\n      const {\n        group,\n        parents\n      } = findGroup(groupIndex, this.groups);\n\n      if (!group.items.length) {\n        const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));\n        const children = findChildren(this.originalData, parents.concat(group));\n        group.items = processGroups(children, {\n          filter: this.state.filter,\n          group: descriptors,\n          sort: this.state.sort\n        });\n      }\n\n      this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n\n    groupCollapse({\n      groupIndex\n    }) {\n      const {\n        group\n      } = findGroup(groupIndex, this.groups);\n\n      if (group) {\n        group.items = [];\n      }\n\n      this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    }\n\n    process(state) {\n      if (state.group && state.group.length) {\n        const groups = this.processGroups(state);\n        this.grid.skip -= skippedHeaders(groups.data[0]);\n        return groups;\n      } else {\n        this.groups = null;\n      }\n\n      return super.process(state);\n    }\n\n    processGroups(state) {\n      if (!this.groups || !this.groups.length) {\n        this.groups = processGroups(this.originalData, {\n          filter: state.filter,\n          group: state.group,\n          sort: state.sort\n        });\n      }\n\n      return this.dataResult(state.skip, state.take);\n    }\n\n    dataResult(skip, take) {\n      const includeFooters = this.grid.showGroupFooters;\n      return {\n        data: slice(this.groups, skip, take, includeFooters),\n        total: count(this.groups, includeFooters)\n      };\n    }\n\n    applyState({\n      skip,\n      take,\n      sort,\n      group,\n      filter\n    }) {\n      this.skip = skip;\n      this.state.take = take; // this.pageSize = take; // do need to update take as the process with slice correctly\n\n      this.sort = sort;\n      this.group = group;\n      this.filter = filter;\n    }\n\n  }\n\n  GroupBindingDirective.ɵfac = function GroupBindingDirective_Factory(t) {\n    return new (t || GroupBindingDirective)(i0.ɵɵdirectiveInject(GridComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(LocalDataChangesService));\n  };\n\n  GroupBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupBindingDirective,\n    selectors: [[\"\", \"kendoGridGroupBinding\", \"\"]],\n    inputs: {\n      kendoGridGroupBinding: \"kendoGridGroupBinding\",\n      sort: \"sort\",\n      filter: \"filter\",\n      group: \"group\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return GroupBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$1 = [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, ...GroupModule.exports(), ...SharedModule.exports(), ...BodyModule.exports(), ...HeaderModule.exports(), ...FooterModule.exports(), ...PagerModule.exports(), ...RowFilterModule.exports(), ...FilterMenuModule.exports(), ...ColumnMenuModule.exports()];\nconst declarations$2 = [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Grid component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid module\n * import { GridModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule], // import Grid module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet GridModule = /*#__PURE__*/(() => {\n  class GridModule {}\n\n  GridModule.ɵfac = function GridModule_Factory(t) {\n    return new (t || GridModule)();\n  };\n\n  GridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GridModule\n  });\n  GridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, GroupModule, SharedModule, BodyModule, HeaderModule, FooterModule, PagerModule, RowFilterModule, FilterMenuModule, ResizeSensorModule, ColumnMenuModule]]\n  });\n  return GridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PDFMarginComponent = /*#__PURE__*/(() => {\n  class PDFMarginComponent extends PDFExportMarginComponent {}\n\n  PDFMarginComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵPDFMarginComponent_BaseFactory;\n    return function PDFMarginComponent_Factory(t) {\n      return (ɵPDFMarginComponent_BaseFactory || (ɵPDFMarginComponent_BaseFactory = i0.ɵɵgetInheritedFactory(PDFMarginComponent)))(t || PDFMarginComponent);\n    };\n  }();\n\n  PDFMarginComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PDFMarginComponent,\n    selectors: [[\"kendo-grid-pdf-margin\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function PDFMarginComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return PDFMarginComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the PDF page template of the Grid that helps to customize the PDF pages. To define a page template,\n * nest an `<ng-template>` tag with the `kendoGridPDFTemplate` directive inside `<kendo-grid-pdf>`.\n *\n * The template context provides the following fields:\n * - `pageNumber`&mdash;Defines PDF page number.\n * - `totalPages`&mdash;Defines the total number of PDF pages.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-grid [data]=\"gridData\">\n *             <ng-template kendoGridToolbarTemplate>\n *                 <button kendoGridPDFCommand icon=\"file-pdf\">Export to PDF</button>\n *             </ng-template>\n *             <kendo-grid-column field=\"ProductName\">\n *             </kendo-grid-column>\n *              <kendo-grid-column field=\"UnitPrice\">\n *             </kendo-grid-column>\n *             <kendo-grid-pdf fileName=\"Products.pdf\" paperSize=\"A4\" [margin]=\"{ top: '1cm', left: '1cm', right: '1cm', bottom: '1cm' }\">\n *                 <ng-template kendoGridPDFTemplate let-pageNum=\"pageNum\" let-totalPages=\"totalPages\">\n *                     <div style=\"position: absolute;top: 5px; left: 5px;\">\n *                         Page {{ pageNum }} of {{ totalPages }}\n *                     </div>\n *                 </ng-template>\n *             </kendo-grid-pdf>\n *         </kendo-grid>\n *     `\n * })\n *\n * class AppComponent {\n *     public gridData = [{\n *         \"ProductID\": 1,\n *         \"ProductName\": \"Chai\",\n *         \"UnitPrice\": 18.0000\n *       }, {\n *         \"ProductID\": 2,\n *         \"ProductName\": \"Chang\",\n *         \"UnitPrice\": 19.0000\n *       }\n *     ];\n * }\n *\n * ```\n */\n\n\nlet PDFTemplateDirective = /*#__PURE__*/(() => {\n  class PDFTemplateDirective extends PDFExportTemplateDirective {\n    constructor(templateRef) {\n      super(templateRef);\n    }\n\n  }\n\n  PDFTemplateDirective.ɵfac = function PDFTemplateDirective_Factory(t) {\n    return new (t || PDFTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PDFTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PDFTemplateDirective,\n    selectors: [[\"\", \"kendoGridPDFTemplate\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return PDFTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst HEADER_CLASS = 'k-grid-header';\n/**\n * @hidden\n */\n\nconst FOOTER_CLASS = 'k-grid-footer';\nconst GRID_LIST = 'KENDO-GRID-LIST';\nconst TABLE = 'TABLE';\nconst matchesList = matchesNodeName(GRID_LIST);\nconst matchesTable = matchesNodeName(TABLE);\n\nconst suffix = locked => locked ? 'locked' : 'wrap';\n/**\n * @hidden\n */\n\n\nclass GridQuery {\n  constructor(element) {\n    this.element = element;\n    this.list = findElement(element, matchesList);\n  }\n\n  content(locked) {\n    return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));\n  }\n\n  header(locked) {\n    this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));\n    return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));\n  }\n\n  footer(locked) {\n    this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));\n    return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));\n  }\n\n  table() {\n    return findElement(this.element, matchesTable);\n  }\n\n}\n\nconst FIRST_CLASS = 'k-first';\nconst INPUTS = ['input', 'select', 'textarea', 'option'];\n/** @hidden */\n\nconst cloneNode = node => {\n  const clone = node.cloneNode(false);\n\n  if (node._kendoExportVisual) {\n    clone._kendoExportVisual = node._kendoExportVisual;\n  }\n\n  if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {\n    clone.removeAttribute(\"id\");\n    clone.removeAttribute(\"name\");\n    clone.value = node.value;\n    clone.checked = node.checked;\n    clone.selected = node.selected;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    clone.appendChild(cloneNode(child));\n    child = child.nextSibling;\n  }\n\n  return clone;\n};\n\nconst appendNodes = (element, nodes) => {\n  const length = nodes.length;\n\n  for (let idx = 0; idx < length; idx++) {\n    element.appendChild(cloneNode(nodes[idx]));\n  }\n};\n\nconst wrapTable = table => {\n  const wrapper = document.createElement('div');\n  wrapper.className = 'k-grid';\n  wrapper.appendChild(table);\n  return wrapper;\n};\n\nconst createTableElement = sources => {\n  const sourceCount = sources.length;\n  const element = cloneNode(sources[0]);\n  const rowsCount = element.rows.length;\n\n  if (sourceCount > 1) {\n    for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n      for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {\n        appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);\n      }\n    }\n  }\n\n  return element;\n};\n\nconst setFirstCellClass = (header, headers) => {\n  if (headers.length > 1 && header.rows.length > 1) {\n    for (let idx = 1; idx < header.rows.length; idx++) {\n      const firstCellIndex = headers[0].rows[idx].cells.length;\n      const cell = header.rows[idx].cells[firstCellIndex];\n\n      if (String(cell.className).indexOf(FIRST_CLASS) === -1) {\n        cell.className += ` ${FIRST_CLASS}`;\n      }\n    }\n  }\n};\n\nconst createTable = (colGroups, headers, bodies, footers) => {\n  const table = document.createElement('table');\n  const colGroup = colGroups[0].cloneNode(true);\n\n  for (let idx = 1; idx < colGroups.length; idx++) {\n    appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));\n  }\n\n  const header = createTableElement(headers);\n  const body = createTableElement(bodies);\n  header.className = HEADER_CLASS;\n  setFirstCellClass(header, headers);\n  table.appendChild(colGroup);\n  table.appendChild(header);\n  table.appendChild(body);\n\n  if (footers.length) {\n    const footer = createTableElement(footers);\n    footer.className = FOOTER_CLASS;\n    table.appendChild(footer);\n  }\n\n  return wrapTable(table);\n};\n/**\n * @hidden\n */\n\n\nconst exportElement = wrapper => {\n  const query = new GridQuery(wrapper);\n  const content = query.content();\n  let result;\n\n  if (content) {\n    const colGroups = [content.querySelector('colgroup')];\n    const headers = [query.header().querySelector('thead')];\n    const bodies = [content.querySelector('tbody')];\n    const footer = query.footer();\n    const footers = [];\n\n    if (footer) {\n      footers.push(footer.querySelector('tfoot'));\n    }\n\n    const lockedContent = query.content(true);\n\n    if (lockedContent) {\n      colGroups.unshift(lockedContent.querySelector('colgroup'));\n      headers.unshift(query.header(true).querySelector('thead'));\n      bodies.unshift(lockedContent.querySelector('tbody'));\n\n      if (footer) {\n        footers.unshift(query.footer(true).querySelector('tfoot'));\n      }\n    }\n\n    result = createTable(colGroups, headers, bodies, footers);\n  } else {\n    result = wrapTable(query.table().cloneNode(true));\n  }\n\n  return result;\n};\n\nconst createElement = (tagName, className) => {\n  const element = document.createElement(tagName);\n\n  if (className) {\n    element.className = className;\n  }\n\n  return element;\n};\n\nconst createDiv = className => {\n  return createElement('div', className);\n};\n/**\n * Configures the settings for the export of Grid in PDF ([see example]({% slug pdfexport_grid %})).\n */\n\n\nlet PDFComponent = /*#__PURE__*/(() => {\n  class PDFComponent extends PDFExportComponent {\n    constructor(pdfService, suspendService, ngZone, element) {\n      super(element);\n      this.pdfService = pdfService;\n      this.suspendService = suspendService;\n      this.ngZone = ngZone;\n      /**\n       * The delay in milliseconds before exporting the Grid content.\n       * Useful for scenarios which involve exporting complex components used in the Grid\n       * templates such as charts or data-bound components with asynchronous data retrieval ([see example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).\n       *\n       * @default 0\n       */\n\n      this.delay = 0;\n      this.columns = new QueryList();\n      this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));\n      this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));\n      this.reset = this.reset.bind(this);\n      this.draw = this.draw.bind(this);\n    }\n\n    ngOnDestroy() {\n      this.saveSubscription.unsubscribe();\n      this.drawSubscription.unsubscribe();\n      this.reset();\n    }\n    /**\n     * @hidden\n     */\n\n\n    saveAs(_) {\n      throw new Error('Not supported. Use GridComponent.saveAsPDF');\n    }\n    /**\n     * @hidden\n     */\n\n\n    export() {\n      throw new Error('Not supported. Use GridComponent.drawPDF');\n    }\n\n    savePDF(component) {\n      this.createPDF(component, this.draw);\n    }\n\n    drawPDF({\n      component,\n      promise\n    }) {\n      this.createPDF(component, () => {\n        this.createExportGroup(promise);\n      });\n    }\n\n    createPDF(component, callback) {\n      const pageSize = component.pageSize;\n      const total = component.view.total;\n      const columns = this.columns.toArray();\n\n      if (columns.length) {\n        this.originalColumns = component.columns.toArray();\n      }\n\n      this.component = component;\n      this.suspendService.scroll = true;\n      this.pdfService.exporting = true;\n      this.initProgress();\n      this.renderAllPages = this.allPages && pageSize < total;\n\n      if (this.renderAllPages) {\n        this.skip = component.skip;\n        this.pageSize = pageSize;\n        this.changePage(0, total, callback, columns);\n      } else if (columns.length || component.virtualColumns) {\n        this.changeColumns(columns, callback);\n      } else {\n        callback();\n      }\n    }\n\n    initProgress() {\n      const wrapperElement = this.component.wrapper.nativeElement;\n      const progress = this.progress = createDiv('k-loading-pdf-mask');\n      const overlay = cloneNode(wrapperElement);\n      progress.appendChild(overlay);\n      progress.appendChild(createDiv('k-loading-color'));\n      progress.appendChild(createElement('span', 'k-i-loading k-icon'));\n      this.originalHeight = wrapperElement.style.height;\n      this.originalOverflow = wrapperElement.style.overflow;\n      wrapperElement.style.height = wrapperElement.offsetHeight + 'px';\n      wrapperElement.style.overflow = 'hidden';\n      wrapperElement.appendChild(progress);\n      this.applyScroll(overlay);\n    }\n\n    applyScroll(overlay) {\n      const query = new GridQuery(this.component.wrapper.nativeElement);\n      const content = query.content();\n\n      if (content) {\n        const overlayQuery = new GridQuery(overlay);\n        const overlayContent = overlayQuery.content();\n        overlayContent.scrollTop = content.scrollTop;\n        overlayContent.scrollLeft = content.scrollLeft;\n        overlayQuery.header().scrollLeft = query.header().scrollLeft;\n        const footer = query.footer();\n\n        if (footer) {\n          overlayQuery.footer().scrollLeft = footer.scrollLeft;\n        }\n\n        const lockedContent = query.content(true);\n\n        if (lockedContent) {\n          const overlayLockedContent = overlayQuery.content(true);\n          overlayLockedContent.scrollTop = lockedContent.scrollTop;\n          overlayLockedContent.scrollLeft = lockedContent.scrollLeft;\n        }\n      }\n    }\n\n    draw() {\n      this.createExportElement(element => {\n        this.save(element, this.fileName);\n      });\n    }\n\n    createExportGroup(promise) {\n      this.createExportElement(element => {\n        this.exportElement(element).then(group => promise.resolve(group));\n      });\n    }\n\n    createExportElement(callback) {\n      this.ngZone.runOutsideAngular(() => {\n        const container = this.container = createDiv('k-grid-pdf-export-element');\n        const element = exportElement(this.component.wrapper.nativeElement);\n        container.appendChild(element);\n        document.body.appendChild(container);\n        callback(element);\n      });\n    }\n\n    drawOptions() {\n      const options = super.drawOptions();\n      options._destructive = true;\n      return options;\n    }\n\n    cleanup() {\n      super.cleanup();\n      this.pdfService.exporting = false;\n\n      if (this.component) {\n        const originalColumns = this.originalColumns;\n        delete this.originalColumns;\n\n        if (this.renderAllPages) {\n          this.changePage(this.skip, this.pageSize, this.reset, originalColumns);\n        } else if (originalColumns || this.component.virtualColumns) {\n          this.changeColumns(originalColumns, this.reset);\n        } else {\n          this.reset();\n        }\n      } else {\n        this.reset();\n      }\n\n      this.removeContainer();\n    }\n\n    removeContainer() {\n      if (this.container) {\n        document.body.removeChild(this.container);\n        delete this.container;\n      }\n    }\n\n    changePage(skip, _take, callback, columns) {\n      this.ngZone.run(() => {\n        this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {\n          if (columns && columns.length || this.component.virtualColumns) {\n            this.changeColumns(columns, callback);\n          } else {\n            this.onStable(callback);\n          }\n        });\n        this.component.notifyPageChange('pdf', {\n          skip: skip,\n          take: _take\n        });\n      });\n    }\n\n    changeColumns(columns, callback) {\n      this.ngZone.run(() => {\n        this.onStable(callback);\n\n        if (columns && columns.length) {\n          this.component.columns.reset(columns);\n        }\n      });\n    }\n\n    reset() {\n      this.suspendService.scroll = false;\n      this.renderAllPages = false;\n\n      if (!this.component) {\n        return;\n      }\n\n      const wrapperElement = this.component.wrapper.nativeElement;\n      wrapperElement.removeChild(this.progress);\n      wrapperElement.style.height = this.originalHeight;\n      wrapperElement.style.overflow = this.originalOverflow;\n      delete this.progress;\n      delete this.component;\n    }\n\n    onStable(callback) {\n      // not sure if it is an actual scenario. occurs in the tests.\n      // onStable is triggered in the same pass without the change detection.\n      // thus, the callback is called before the changes are applied without the timeout.\n      setTimeout(() => {\n        let onStable = this.ngZone.onStable.asObservable().pipe(take(1));\n\n        if (this.delay > 0) {\n          onStable = onStable.pipe(delay(this.delay));\n        }\n\n        onStable.subscribe(callback);\n      }, 0);\n    }\n\n  }\n\n  PDFComponent.ɵfac = function PDFComponent_Factory(t) {\n    return new (t || PDFComponent)(i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(SuspendService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  PDFComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PDFComponent,\n    selectors: [[\"kendo-grid-pdf\"]],\n    contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, PDFTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.marginComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    inputs: {\n      allPages: \"allPages\",\n      delay: \"delay\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function PDFComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return PDFComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `export-to-PDF` command of the Grid.\n * You can apply this directive to any `button` element inside a\n * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).\n * When the user clicks a button that is associated with the directive, the\n * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event\n * fires ([see example]({% slug pdfexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridPDFCommand>Export to PDF</button>\n *      </ng-template>\n *      <kendo-grid-pdf fileName=\"Grid.pdf\">\n *      </kendo-grid-pdf>\n * </kendo-grid>\n * ```\n */\n\n\nlet PDFCommandDirective = /*#__PURE__*/(() => {\n  class PDFCommandDirective extends Button {\n    constructor(pdfService, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.pdfService = pdfService;\n      this.ngZone = ngZone;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n      this.pdfService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pdfClass() {\n      return true;\n    }\n\n  }\n\n  PDFCommandDirective.ɵfac = function PDFCommandDirective_Factory(t) {\n    return new (t || PDFCommandDirective)(i0.ɵɵdirectiveInject(PDFService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  PDFCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PDFCommandDirective,\n    selectors: [[\"\", \"kendoGridPDFCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function PDFCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-pdf\", ctx.pdfClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return PDFCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective];\nconst declarations$1 = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Grid PDF component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid and PDF modules\n * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule, PDFModule], // import Grid and PDF modules\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet PDFModule = /*#__PURE__*/(() => {\n  class PDFModule {}\n\n  PDFModule.ɵfac = function PDFModule_Factory(t) {\n    return new (t || PDFModule)();\n  };\n\n  PDFModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PDFModule\n  });\n  PDFModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return PDFModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `excelExport` event.\n */\n\n\nclass ExcelExportEvent extends PreventableEvent {\n  constructor(workbook) {\n    super();\n    this.workbook = workbook;\n  }\n\n}\n\nconst fetchComponentData = component => {\n  return {\n    data: component.view.map(item => item),\n    group: component.group\n  };\n};\n\nconst toExcelColumn = column => {\n  return {\n    title: column.title,\n    field: column.field,\n    locked: Boolean(column.locked),\n    width: column.width,\n    level: column.level,\n    hidden: !column.isVisible,\n    groupHeaderTemplate: column.groupHeaderTemplate,\n    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,\n    groupFooterTemplate: column.groupFooterTemplate,\n    footerTemplate: column.footerTemplate\n  };\n};\n\nconst toExcelColumns = columns => {\n  const result = [];\n  sortColumns(columns).forEach(column => {\n    if (column.isSpanColumn) {\n      result.push(...toExcelColumns(column.childrenArray));\n    } else {\n      const excelColumn = toExcelColumn(column);\n\n      if (column.isColumnGroup) {\n        excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));\n      }\n\n      result.push(excelColumn);\n    }\n  });\n  return result;\n};\n\nconst componentColumns = component => {\n  const columns = toExcelColumns(component.columns.toArray());\n  return orderBy(columns, [{\n    field: 'locked',\n    dir: 'desc'\n  }]);\n};\n/**\n * Configures the settings for the export of Grid in Excel ([see example]({% slug excelexport_grid %})).\n */\n\n\nlet ExcelComponent = /*#__PURE__*/(() => {\n  class ExcelComponent {\n    constructor(excelService, localization, zone) {\n      this.localization = localization;\n      this.zone = zone;\n      /**\n       * Specifies the file name of the exported Excel file.\n       * @default \"Export.xlsx\"\n       */\n\n      this.fileName = 'Export.xlsx';\n      /**\n       * @hidden\n       */\n\n      this.columns = new QueryList();\n      this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));\n    }\n\n    ngOnDestroy() {\n      this.saveSubscription.unsubscribe();\n\n      if (this.dataSubscription) {\n        this.dataSubscription.unsubscribe();\n      }\n    }\n\n    save(component) {\n      const data = (this.fetchData || fetchComponentData)(component);\n\n      const exportData = result => {\n        delete this.dataSubscription;\n        this.exportData(component, result);\n      };\n\n      if (data instanceof Promise) {\n        data.then(exportData);\n      } else if (data instanceof Observable) {\n        this.dataSubscription = data.pipe(take(1)).subscribe(exportData);\n      } else {\n        exportData(data);\n      }\n    }\n\n    exportData(component, result) {\n      const options = workbookOptions({\n        columns: this.columns.length ? this.columns : componentColumns(component),\n        data: result.data,\n        group: result.group,\n        filterable: this.filterable,\n        creator: this.creator,\n        date: this.date,\n        paddingCellOptions: this.paddingCellOptions,\n        headerPaddingCellOptions: this.headerPaddingCellOptions,\n        rtl: this.localization.rtl,\n        collapsible: this.collapsible\n      });\n      const args = new ExcelExportEvent(options);\n      component.excelExport.emit(args);\n\n      if (!args.isDefaultPrevented()) {\n        this.zone.runOutsideAngular(() => this.saveFile(options));\n      }\n    }\n\n    saveFile(options) {\n      toDataURL(options).then(dataURL => {\n        saveAs(dataURL, this.fileName, {\n          forceProxy: this.forceProxy,\n          proxyURL: this.proxyURL\n        });\n      });\n    }\n\n  }\n\n  ExcelComponent.ɵfac = function ExcelComponent_Factory(t) {\n    return new (t || ExcelComponent)(i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ExcelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ExcelComponent,\n    selectors: [[\"kendo-grid-excel\"]],\n    contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnBase$1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    inputs: {\n      fileName: \"fileName\",\n      filterable: \"filterable\",\n      creator: \"creator\",\n      date: \"date\",\n      forceProxy: \"forceProxy\",\n      proxyURL: \"proxyURL\",\n      fetchData: \"fetchData\",\n      paddingCellOptions: \"paddingCellOptions\",\n      headerPaddingCellOptions: \"headerPaddingCellOptions\",\n      collapsible: \"collapsible\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ExcelComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ExcelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the `export-to-Excel` command of the Grid. You can apply this\n * directive to any `button` element inside a\n * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).\n * When the user clicks a button associated with the directive, the\n * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event\n * fires ([see example]({% slug excelexport_grid %})).\n *\n * @example\n * ```html-no-run\n * <kendo-grid>\n *      <ng-template kendoGridToolbarTemplate>\n *          <button kendoGridExcelCommand>Export to PDF</button>\n *      </ng-template>\n *      <kendo-grid-excel fileName=\"Grid.xlsx\">\n *      </kendo-grid-excel>\n * </kendo-grid>\n * ```\n */\n\n\nlet ExcelCommandDirective = /*#__PURE__*/(() => {\n  class ExcelCommandDirective extends Button {\n    constructor(excelService, element, renderer, localization, ngZone) {\n      super(element, renderer, null, localization, ngZone);\n      this.excelService = excelService;\n      this.ngZone = ngZone;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(e) {\n      e.preventDefault();\n      this.excelService.exportClick.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get excelClass() {\n      return true;\n    }\n\n  }\n\n  ExcelCommandDirective.ɵfac = function ExcelCommandDirective_Factory(t) {\n    return new (t || ExcelCommandDirective)(i0.ɵɵdirectiveInject(ExcelService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ExcelCommandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExcelCommandDirective,\n    selectors: [[\"\", \"kendoGridExcelCommand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ExcelCommandDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-grid-excel\", ctx.excelClass);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ExcelCommandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst declarations = [ExcelComponent, ExcelCommandDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Excel component of the Grid.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Grid and Excel modules\n * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, GridModule, ExcelModule], // import Grid and Excel modules\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet ExcelModule = /*#__PURE__*/(() => {\n  class ExcelModule {}\n\n  ExcelModule.ɵfac = function ExcelModule_Factory(t) {\n    return new (t || ExcelModule)();\n  };\n\n  ExcelModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ExcelModule\n  });\n  ExcelModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [ExcelExportModule]\n  });\n  return ExcelModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AddCommandDirective, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, AutoCompleteFilterCellComponent, BaseFilterCellComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, BodyModule, BooleanFilterCellComponent, BooleanFilterComponent, BooleanFilterMenuComponent, BooleanFilterRadioButtonDirective, CancelCommandDirective, CellCloseEvent, CellComponent, CellLoadingTemplateDirective, CellTemplateDirective, CheckboxColumnComponent, ColGroupComponent, ColumnBase, ColumnChooserComponent, ColumnComponent, ColumnGroupComponent, ColumnHandleDirective, ColumnInfoService, ColumnLockedChangeEvent, ColumnMenuChooserComponent, ColumnMenuComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuPositionComponent, ColumnMenuSortComponent, ColumnMenuStickComponent, ColumnMenuTemplateDirective, ColumnReorderEvent, ColumnStickyChangeEvent, ColumnVisibilityChangeEvent, ColumnsContainer, CommandColumnComponent, ContainsFilterOperatorComponent, CustomMessagesComponent, DataBindingDirective, DateFilterCellComponent, DateFilterComponent, DateFilterMenuComponent, DateFilterMenuInputComponent, DetailCollapseEvent, DetailExpandEvent, DetailTemplateDirective, DoesNotContainFilterOperatorComponent, EditCommandDirective, EditTemplateDirective, EditingDirectiveBase, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, ExcelCommandDirective, ExcelComponent, ExcelExportEvent, ExcelModule, ExcelService, ExpandDetailsDirective, ExpandGroupDirective, FieldAccessorPipe, FilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellTemplateDirective, FilterCellWrapperComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuDropDownListDirective, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuModule, FilterMenuTemplateDirective, FilterRowComponent, FilterService, FocusableDirective, FooterComponent, FooterModule, FooterTemplateDirective, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, GridComponent, GridModule, GridSpacerComponent, GroupBindingDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderComponent, GroupHeaderTemplateDirective, GroupIndicatorComponent, GroupModule, GroupPanelComponent, HeaderComponent, HeaderModule, HeaderTemplateDirective, InCellEditingDirective, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, ListComponent, LoadingComponent, LoadingTemplateDirective, LocalDataChangesService, LogicalCellDirective, LogicalRowDirective, MenuTabbingService, NoRecordsTemplateDirective, NotEqualFilterOperatorComponent, NumericFilterCellComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, PDFCommandDirective, PDFComponent, PDFMarginComponent, PDFModule, PDFService, PDFTemplateDirective, PagerComponent, PagerDropDownListDirective, PagerInfoComponent, PagerInputComponent, PagerInputDirective, PagerModule, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PopupCloseEvent, ReactiveEditingDirective, RemoveCommandDirective, ResizableContainerDirective, RowEditingDirectiveBase, RowFilterModule, SaveCommandDirective, SelectAllCheckboxDirective, SelectionCheckboxDirective, SelectionDirective, SharedFilterModule, SharedModule, SinglePopupService, Skip, SpanColumnComponent, StartsWithFilterOperatorComponent, StringFilterCellComponent, StringFilterMenuComponent, StringFilterMenuInputComponent, SuspendService, TableBodyComponent, TableDirective, TemplateContextDirective, TemplateEditingDirective, ToolbarComponent, ToolbarTemplateDirective, count, defaultTrackBy, hasFilterMenu, hasFilterRow, isFilterable, slice };","map":null,"metadata":{},"sourceType":"module"}