{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1029);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1029:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /***********************************************************************\n    * WARNING: this file is auto-generated.  If you change it directly,\n    * your modifications will eventually be lost.  The source code is in\n    * `kendo-ooxml` repository, you should make your changes there and\n    * run `src-modules/sync.sh` in this repository.\n    */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        window.kendo.excel = window.kendo.excel || {};\n        var getter = kendo.getter;\n        var map = $.map;\n        var current = {\n          compile: function (template) {\n            return template;\n          }\n        };\n        var TemplateService = kendo.Class.extend({});\n\n        TemplateService.register = function (userImplementation) {\n          current = userImplementation;\n        };\n\n        TemplateService.compile = function (template) {\n          return current.compile(template);\n        };\n\n        function defaultGroupHeaderTemplate(data) {\n          return data.title + \": \" + data.value;\n        }\n\n        function createArray(length, callback) {\n          var result = [];\n\n          for (var idx = 0; idx < length; idx++) {\n            result.push(callback(idx));\n          }\n\n          return result;\n        }\n\n        function defaultItemId(item) {\n          return item.id;\n        }\n\n        var ExcelExporter = kendo.Class.extend({\n          init: function (options) {\n            options.columns = this._trimColumns(options.columns || []);\n            this.allColumns = map(this._leafColumns(options.columns || []), this._prepareColumn);\n            this.columns = this._visibleColumns(this.allColumns);\n            this.options = options;\n            this.data = options.data || [];\n            this.aggregates = options.aggregates || {};\n            this.groups = [].concat(options.groups || []);\n            this.hasGroups = this.groups.length > 0;\n            this.hierarchy = options.hierarchy;\n            this.hasGroupHeaderColumn = this.columns.some(function (column) {\n              return column.groupHeaderColumnTemplate;\n            });\n            this.collapsible = this.options.collapsible;\n          },\n          workbook: function () {\n            var workbook = {\n              sheets: [{\n                columns: this._columns(),\n                rows: this.hierarchy ? this._hierarchyRows() : this._rows(),\n                freezePane: this._freezePane(),\n                filter: this._filter()\n              }]\n            };\n            return workbook;\n          },\n          _trimColumns: function (columns) {\n            var this$1 = this;\n            return columns.filter(function (column) {\n              var result = Boolean(column.field);\n\n              if (!result && column.columns) {\n                result = this$1._trimColumns(column.columns).length > 0;\n              }\n\n              return result;\n            });\n          },\n          _leafColumns: function (columns) {\n            var this$1 = this;\n            var result = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (!columns[idx].columns) {\n                result.push(columns[idx]);\n              } else {\n                result = result.concat(this$1._leafColumns(columns[idx].columns));\n              }\n            }\n\n            return result;\n          },\n          _prepareColumn: function (column) {\n            if (!column.field) {\n              return null;\n            }\n\n            var value = function (dataItem) {\n              return getter(column.field, true)(dataItem);\n            };\n\n            var values = null;\n\n            if (column.values) {\n              values = {};\n              column.values.forEach(function (item) {\n                values[item.value] = item.text;\n              });\n\n              value = function (dataItem) {\n                return values[getter(column.field, true)(dataItem)];\n              };\n            }\n\n            return $.extend({}, column, {\n              value: value,\n              values: values,\n              groupHeaderTemplate: column.groupHeaderTemplate ? TemplateService.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,\n              groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? TemplateService.compile(column.groupHeaderColumnTemplate) : null,\n              groupFooterTemplate: column.groupFooterTemplate ? TemplateService.compile(column.groupFooterTemplate) : null,\n              footerTemplate: column.footerTemplate ? TemplateService.compile(column.footerTemplate) : null\n            });\n          },\n          _filter: function () {\n            if (!this.options.filterable) {\n              return null;\n            }\n\n            var depth = this._depth();\n\n            return {\n              from: depth,\n              to: depth + this.columns.length - 1\n            };\n          },\n          _createPaddingCells: function (length) {\n            var this$1 = this;\n            return createArray(length, function () {\n              return $.extend({\n                background: \"#dfdfdf\",\n                color: \"#333\"\n              }, this$1.options.paddingCellOptions);\n            });\n          },\n          _dataRow: function (dataItem, level, depth) {\n            var this$1 = this;\n\n            var cells = this._createPaddingCells(level); // grouped\n\n\n            if (this.hasGroups && depth && dataItem.items) {\n              cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));\n\n              var rows = this._dataRows(dataItem.items, level + 1);\n\n              rows.unshift({\n                type: \"group-header\",\n                cells: cells,\n                level: this.collapsible ? level : null\n              });\n              return rows.concat(this._footer(dataItem, level));\n            }\n\n            var dataCells = [];\n\n            for (var cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {\n              dataCells[cellIdx] = this$1._cell(dataItem, this$1.columns[cellIdx]);\n            }\n\n            if (this.hierarchy) {\n              dataCells[0].colSpan = depth - level + 1;\n            }\n\n            return [{\n              type: \"data\",\n              cells: cells.concat(dataCells),\n              level: this.collapsible ? level : null\n            }];\n          },\n          _groupHeaderCells: function (dataItem, level, depth) {\n            var cells = [];\n            var column = this.allColumns.filter(function (column) {\n              return column.field === dataItem.field;\n            })[0] || {};\n            var title = column && column.title ? column.title : dataItem.field;\n            var template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;\n            var group = $.extend({\n              title: title,\n              field: dataItem.field,\n              value: column && column.values ? column.values[dataItem.value] : dataItem.value,\n              aggregates: dataItem.aggregates,\n              items: dataItem.items\n            }, dataItem.aggregates[dataItem.field]);\n            var value = template ? template(group) : title + \": \" + dataItem.value;\n            cells.push($.extend({\n              value: value,\n              background: \"#dfdfdf\",\n              color: \"#333\",\n              colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level\n            }, column.groupHeaderCellOptions));\n\n            if (this.hasGroupHeaderColumn) {\n              this.columns.forEach(function (column, index) {\n                if (index > 0) {\n                  cells.push($.extend({\n                    background: \"#dfdfdf\",\n                    color: \"#333\",\n                    value: column.groupHeaderColumnTemplate ? column.groupHeaderColumnTemplate($.extend({\n                      group: group\n                    }, group, dataItem.aggregates[column.field])) : undefined\n                  }, column.groupHeaderCellOptions));\n                }\n              });\n            }\n\n            return cells;\n          },\n          _dataRows: function (dataItems, level) {\n            var this$1 = this;\n\n            var depth = this._depth();\n\n            var rows = [];\n\n            for (var idx = 0; idx < dataItems.length; idx++) {\n              rows.push.apply(rows, this$1._dataRow(dataItems[idx], level, depth));\n            }\n\n            return rows;\n          },\n          _hierarchyRows: function () {\n            var this$1 = this;\n\n            var depth = this._depth();\n\n            var data = this.data;\n            var itemLevel = this.hierarchy.itemLevel;\n            var itemId = this.hierarchy.itemId || defaultItemId;\n\n            var hasFooter = this._hasFooterTemplate();\n\n            var rows = [];\n            var parents = [];\n            var previousLevel = 0;\n            var previousItemId;\n\n            if (!hasFooter) {\n              this.collapsible = false;\n            }\n\n            for (var idx = 0; idx < data.length; idx++) {\n              var item = data[idx];\n              var level = itemLevel(item, idx);\n\n              if (hasFooter) {\n                if (level > previousLevel) {\n                  parents.push({\n                    id: previousItemId,\n                    level: previousLevel\n                  });\n                } else if (level < previousLevel) {\n                  rows.push.apply(rows, this$1._hierarchyFooterRows(parents, level, depth));\n                }\n\n                previousLevel = level;\n                previousItemId = itemId(item, idx);\n              }\n\n              rows.push.apply(rows, this$1._dataRow(item, level + 1, depth));\n            }\n\n            if (hasFooter) {\n              rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));\n              var rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};\n              rows.push(this._hierarchyFooter(rootAggregate, 0, depth));\n            }\n\n            this._prependHeaderRows(rows);\n\n            return rows;\n          },\n          _hierarchyFooterRows: function (parents, currentLevel, depth) {\n            var this$1 = this;\n            var rows = [];\n\n            while (parents.length && parents[parents.length - 1].level >= currentLevel) {\n              var parent = parents.pop();\n              rows.push(this$1._hierarchyFooter(this$1.aggregates[parent.id], parent.level + 1, depth));\n            }\n\n            return rows;\n          },\n          _hasFooterTemplate: function () {\n            var columns = this.columns;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].footerTemplate) {\n                return true;\n              }\n            }\n          },\n          _hierarchyFooter: function (aggregates, level, depth) {\n            var cells = this.columns.map(function (column, index) {\n              var colSpan = index ? 1 : depth - level + 1;\n\n              if (column.footerTemplate) {\n                var fieldAggregates = (aggregates || {})[column.field];\n                return $.extend({\n                  background: \"#dfdfdf\",\n                  color: \"#333\",\n                  colSpan: colSpan,\n                  value: column.footerTemplate($.extend({\n                    aggregates: aggregates\n                  }, fieldAggregates))\n                }, column.footerCellOptions);\n              }\n\n              return $.extend({\n                background: \"#dfdfdf\",\n                color: \"#333\",\n                colSpan: colSpan\n              }, column.footerCellOptions);\n            });\n            return {\n              type: \"footer\",\n              cells: this._createPaddingCells(level).concat(cells),\n              level: this.collapsible ? level : null\n            };\n          },\n          _footer: function (dataItem, level) {\n            var rows = [];\n            var footer = this.columns.some(function (column) {\n              return column.groupFooterTemplate;\n            });\n            var templateData, group;\n\n            if (footer) {\n              group = {\n                group: {\n                  items: dataItem.items,\n                  field: dataItem.field,\n                  value: dataItem.value\n                }\n              };\n              templateData = {};\n              Object.keys(dataItem.aggregates).forEach(function (key) {\n                templateData[key] = $.extend({}, dataItem.aggregates[key], group);\n              });\n            }\n\n            var cells = this.columns.map(function (column) {\n              if (column.groupFooterTemplate) {\n                var data = $.extend({}, templateData, dataItem.aggregates[column.field], group);\n                return $.extend({\n                  background: \"#dfdfdf\",\n                  color: \"#333\",\n                  value: column.groupFooterTemplate(data)\n                }, column.groupFooterCellOptions);\n              }\n\n              return $.extend({\n                background: \"#dfdfdf\",\n                color: \"#333\"\n              }, column.groupFooterCellOptions);\n            });\n\n            if (footer) {\n              rows.push({\n                type: \"group-footer\",\n                cells: this._createPaddingCells(this.groups.length).concat(cells),\n                level: this.collapsible ? level : null\n              });\n            }\n\n            return rows;\n          },\n          _isColumnVisible: function (column) {\n            return this._visibleColumns([column]).length > 0 && (column.field || column.columns);\n          },\n          _visibleColumns: function (columns) {\n            var this$1 = this;\n            return columns.filter(function (column) {\n              var exportable = column.exportable;\n\n              if (typeof exportable === 'object') {\n                exportable = column.exportable.excel;\n              }\n\n              var visibleInExport = !column.hidden && exportable !== false;\n              var visibleInExportOnly = column.hidden && exportable === true;\n              var visible = visibleInExport || visibleInExportOnly;\n\n              if (visible && column.columns) {\n                visible = this$1._visibleColumns(column.columns).length > 0;\n              }\n\n              return visible;\n            });\n          },\n          _headerRow: function (row, groups) {\n            var this$1 = this;\n            var headers = row.cells.map(function (cell) {\n              return $.extend(cell, {\n                colSpan: cell.colSpan > 1 ? cell.colSpan : 1,\n                rowSpan: row.rowSpan > 1 && !cell.colSpan ? row.rowSpan : 1\n              });\n            });\n\n            if (this.hierarchy && headers[0].firstCell) {\n              headers[0].colSpan += this._depth();\n            }\n\n            return {\n              type: \"header\",\n              cells: createArray(groups.length, function () {\n                return $.extend({\n                  background: \"#7a7a7a\",\n                  color: \"#fff\"\n                }, this$1.options.headerPaddingCellOptions);\n              }).concat(headers)\n            };\n          },\n          _prependHeaderRows: function (rows) {\n            var this$1 = this;\n            var groups = this.groups;\n            var headerRows = [{\n              rowSpan: 1,\n              cells: [],\n              index: 0\n            }];\n\n            this._prepareHeaderRows(headerRows, this.options.columns);\n\n            for (var idx = headerRows.length - 1; idx >= 0; idx--) {\n              rows.unshift(this$1._headerRow(headerRows[idx], groups));\n            }\n          },\n          _prepareHeaderRows: function (rows, columns, parentCell, parentRow) {\n            var this$1 = this;\n            var row = parentRow || rows[rows.length - 1];\n            var childRow = rows[row.index + 1];\n            var totalColSpan = 0;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              var column = columns[idx];\n\n              if (this$1._isColumnVisible(column)) {\n                var cell = $.extend({\n                  background: \"#7a7a7a\",\n                  color: \"#fff\",\n                  value: column.title || column.field,\n                  colSpan: 0,\n                  firstCell: idx === 0 && (!parentCell || parentCell.firstCell)\n                }, column.headerCellOptions);\n                row.cells.push(cell);\n\n                if (column.columns && column.columns.length) {\n                  if (!childRow) {\n                    childRow = {\n                      rowSpan: 0,\n                      cells: [],\n                      index: rows.length\n                    };\n                    rows.push(childRow);\n                  }\n\n                  cell.colSpan = this$1._trimColumns(this$1._visibleColumns(column.columns)).length;\n\n                  this$1._prepareHeaderRows(rows, column.columns, cell, childRow);\n\n                  totalColSpan += cell.colSpan - 1;\n                  row.rowSpan = rows.length - row.index;\n                }\n              }\n            }\n\n            if (parentCell) {\n              parentCell.colSpan += totalColSpan;\n            }\n          },\n          _rows: function () {\n            var this$1 = this;\n\n            var rows = this._dataRows(this.data, 0);\n\n            if (this.columns.length) {\n              this._prependHeaderRows(rows);\n\n              var footer = false;\n              var cells = this.columns.map(function (column) {\n                if (column.footerTemplate) {\n                  footer = true;\n                  return $.extend({\n                    background: \"#dfdfdf\",\n                    color: \"#333\",\n                    value: column.footerTemplate($.extend({}, this$1.aggregates, this$1.aggregates[column.field]))\n                  }, column.footerCellOptions);\n                }\n\n                return $.extend({\n                  background: \"#dfdfdf\",\n                  color: \"#333\"\n                }, column.footerCellOptions);\n              });\n\n              if (footer) {\n                rows.push({\n                  type: \"footer\",\n                  cells: this._createPaddingCells(this.groups.length).concat(cells)\n                });\n              }\n            }\n\n            return rows;\n          },\n          _headerDepth: function (columns) {\n            var this$1 = this;\n            var result = 1;\n            var max = 0;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].columns) {\n                var temp = this$1._headerDepth(columns[idx].columns);\n\n                if (temp > max) {\n                  max = temp;\n                }\n              }\n            }\n\n            return result + max;\n          },\n          _freezePane: function () {\n            var columns = this._visibleColumns(this.options.columns || []);\n\n            var colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function (column) {\n              return column.locked;\n            })))).length;\n\n            return {\n              rowSplit: this._headerDepth(columns),\n              colSplit: colSplit ? colSplit + this.groups.length : 0\n            };\n          },\n          _cell: function (dataItem, column) {\n            return $.extend({\n              value: column.value(dataItem)\n            }, column.cellOptions);\n          },\n          _depth: function () {\n            var depth = 0;\n\n            if (this.hierarchy) {\n              depth = this.hierarchy.depth;\n            } else {\n              depth = this.groups.length;\n            }\n\n            return depth;\n          },\n          _columns: function () {\n            var depth = this._depth();\n\n            var columns = createArray(depth, function () {\n              return {\n                width: 20\n              };\n            });\n            return columns.concat(this.columns.map(function (column) {\n              return {\n                width: parseInt(column.width, 10),\n                autoWidth: column.width ? false : true\n              };\n            }));\n          }\n        });\n        kendo.deepExtend(kendo.excel, {\n          ExcelExporter: ExcelExporter,\n          TemplateService: TemplateService\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}