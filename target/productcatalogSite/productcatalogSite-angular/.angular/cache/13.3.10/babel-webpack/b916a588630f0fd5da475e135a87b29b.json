{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { isDevMode, Directive, Optional, EventEmitter, ElementRef, Component, Input, Output, HostBinding, ViewChild, ContentChild, ViewChildren, forwardRef, Inject, Injectable, HostListener, NgModule, ViewContainerRef, ContentChildren } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';\nimport { Subscription, fromEvent, interval, merge, BehaviorSubject, Subject } from 'rxjs';\nimport { take, filter, concatMap, startWith, takeUntil, skip, debounceTime, throttleTime } from 'rxjs/operators';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX, RTL } from '@progress/kendo-angular-l10n';\nimport * as i3 from '@progress/kendo-angular-common';\nimport { Keys, guid, hasObservers, anyChanged, isDocumentAvailable, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule, PreventableEvent, closest as closest$1 } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1$1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { browser, mobileOS, detectDesktopBrowser, detectMobileOS } from '@progress/kendo-common';\nimport * as i1$2 from '@progress/kendo-angular-intl';\nimport * as i1$3 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport { parseColor as parseColor$1, Color, namedColors } from '@progress/kendo-drawing';\n/**\n * @hidden\n *\n * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.\n */\n\nconst _c0 = [\"wrap\"];\nconst _c1 = [\"track\"];\nconst _c2 = [\"sliderSelection\"];\nconst _c3 = [\"ticks\"];\nconst _c4 = [\"tickElement\"];\nconst _c5 = [\"kendoSliderTicks\", \"\"];\n\nfunction SliderTicksComponent_li_0_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵelementContainer(1, 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const tick_r3 = i0.ɵɵnextContext().$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.labelTemplate || _r1)(\"ngTemplateOutletContext\", tick_r3);\n  }\n}\n\nfunction SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1, \"\\xA0\");\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction SliderTicksComponent_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 2, 3);\n    i0.ɵɵelementContainerStart(2, 4);\n    i0.ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, \"span\", 5);\n    i0.ɵɵtemplate(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, \"ng-container\", 6);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const tick_r3 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵpropertyInterpolate(\"title\", ctx_r0.tickTitle(tick_r3.value));\n    i0.ɵɵproperty(\"ngClass\", tick_r3.classes);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngSwitch\", tick_r3.large);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", false);\n  }\n}\n\nfunction SliderTicksComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const value_r8 = ctx.value;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.tickTitle(value_r8), \" \");\n  }\n}\n\nconst _c6 = [\"draghandle\"];\nconst _c7 = [\"decreaseButton\"];\nconst _c8 = [\"increaseButton\"];\n\nfunction SliderComponent_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 14, 15);\n    i0.ɵɵelement(2, \"span\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r1.decrementMessage);\n    i0.ɵɵattribute(\"tabindex\", -1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-i-arrow-w\", !ctx_r1.vertical)(\"k-i-arrow-s\", ctx_r1.vertical);\n  }\n}\n\nfunction SliderComponent_ul_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 17, 18);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tickTitle\", ctx_r2.title)(\"vertical\", ctx_r2.vertical)(\"step\", ctx_r2.smallStep)(\"largeStep\", ctx_r2.largeStep)(\"min\", ctx_r2.min)(\"max\", ctx_r2.max)(\"labelTemplate\", ctx_r2.labelTemplate == null ? null : ctx_r2.labelTemplate.templateRef);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\n\nfunction SliderComponent_button_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 19, 20);\n    i0.ɵɵlistener(\"click\", function SliderComponent_button_12_Template_button_click_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelement(2, \"span\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r6.incrementMessage);\n    i0.ɵɵattribute(\"tabindex\", -1)(\"aria-label\", ctx_r6.currentValue);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-i-arrow-e\", !ctx_r6.vertical)(\"k-i-arrow-n\", ctx_r6.vertical);\n  }\n}\n\nconst _c15 = function (a0, a1) {\n  return {\n    click: a0,\n    keydown: a1\n  };\n};\n\nconst _c16 = [\"draghandleStart\"];\nconst _c17 = [\"draghandleEnd\"];\n\nfunction RangeSliderComponent_ul_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 13, 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tickTitle\", ctx_r1.title)(\"vertical\", ctx_r1.vertical)(\"step\", ctx_r1.smallStep)(\"largeStep\", ctx_r1.largeStep)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"labelTemplate\", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\n\nconst _c22 = [\"thumb\"];\n\nconst _c27 = function (a0, a1, a2) {\n  return {\n    keydown: a0,\n    focus: a1,\n    blur: a2\n  };\n};\n\nconst _c28 = [\"numericInput\"];\n\nconst _c33 = function (a0, a1) {\n  return {\n    mouseup: a0,\n    mouseleave: a1\n  };\n};\n\nconst _c34 = function (a0) {\n  return {\n    mousedown: a0\n  };\n};\n\nfunction NumericTextBoxComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 4)(1, \"button\", 5);\n    i0.ɵɵelement(2, \"span\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 7);\n    i0.ɵɵelement(4, \"span\", 8);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(13, _c33, ctx_r1.releaseArrow, ctx_r1.releaseArrow));\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-active\", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Up);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(16, _c34, ctx_r1.increasePress))(\"title\", ctx_r1.incrementTitle);\n    i0.ɵɵattribute(\"aria-hidden\", true)(\"aria-label\", ctx_r1.incrementTitle);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-active\", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Down);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(18, _c34, ctx_r1.decreasePress))(\"title\", ctx_r1.decrementTitle);\n    i0.ɵɵattribute(\"aria-hidden\", true)(\"aria-label\", ctx_r1.decrementTitle);\n  }\n}\n\nconst _c35 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    mousedown: a0,\n    dragenter: a1,\n    keydown: a2,\n    input: a3,\n    focus: a4,\n    blur: a5,\n    paste: a6\n  };\n};\n\nconst _c36 = [\"input\"];\n\nconst _c37 = function (a0, a1, a2, a3, a4) {\n  return {\n    focus: a0,\n    blur: a1,\n    click: a2,\n    dragstart: a3,\n    drop: a4\n  };\n};\n\nfunction TextBoxComponent_2_ng_template_0_Template(rf, ctx) {}\n\nfunction TextBoxComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TextBoxComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);\n  }\n}\n\nfunction TextBoxComponent_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵlistener(\"click\", function TextBoxComponent_span_5_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearValue();\n    })(\"mousedown\", function TextBoxComponent_span_5_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    })(\"keydown.enter\", function TextBoxComponent_span_5_Template_span_keydown_enter_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.clearValue($event);\n    })(\"keydown.space\", function TextBoxComponent_span_5_Template_span_keydown_space_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.clearValue($event);\n    });\n    i0.ɵɵelement(1, \"span\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r2.tabIndex)(\"title\", ctx_r2.clearTitle());\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.clearTitle());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.clearButtonClasses);\n  }\n}\n\nfunction TextBoxComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.errorIconClasses);\n  }\n}\n\nfunction TextBoxComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r4.successIconClasses);\n  }\n}\n\nfunction TextBoxComponent_9_ng_template_0_Template(rf, ctx) {}\n\nfunction TextBoxComponent_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TextBoxComponent_9_ng_template_0_Template, 0, 0, \"ng-template\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);\n  }\n}\n\nconst _c40 = function (a0, a1, a2) {\n  return {\n    focus: a0,\n    blur: a1,\n    input: a2\n  };\n};\n\nconst _c41 = [[[\"kendo-textarea-suffix\"]]];\nconst _c42 = [\"kendo-textarea-suffix\"];\nconst _c43 = [\"*\"];\nconst _c44 = [\"clearButton\"];\nconst _c45 = [\"viewButtons\"];\nconst _c46 = [\"kendoFlatColorPickerHeader\", \"\"];\n\nfunction FlatColorPickerHeaderComponent_div_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 7, 8);\n    i0.ɵɵlistener(\"click\", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const view_r4 = restoredCtx.$implicit;\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.onViewButtonClick(view_r4);\n    });\n    i0.ɵɵelement(2, \"span\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const view_r4 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.activeView === view_r4 ? \"k-state-selected\" : \"\");\n    i0.ɵɵattribute(\"title\", ctx_r3.getText(view_r4 === \"gradient\" ? \"gradientView\" : \"paletteView\"))(\"aria-label\", ctx_r3.getText(view_r4 === \"gradient\" ? \"gradientView\" : \"paletteView\"))(\"aria-pressed\", ctx_r3.activeView === view_r4);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.getViewButtonIcon(view_r4));\n  }\n}\n\nfunction FlatColorPickerHeaderComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_button_1_Template, 3, 5, \"button\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.views);\n  }\n}\n\nfunction FlatColorPickerHeaderComponent_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 10, 11);\n    i0.ɵɵlistener(\"click\", function FlatColorPickerHeaderComponent_button_4_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.clearButtonClick.emit();\n    });\n    i0.ɵɵelement(2, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.getText(\"clearButton\"))(\"title\", ctx_r1.getText(\"clearButton\"));\n  }\n}\n\nfunction FlatColorPickerHeaderComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵelement(1, \"span\", 14);\n    i0.ɵɵelementStart(2, \"span\", 15);\n    i0.ɵɵlistener(\"click\", function FlatColorPickerHeaderComponent_div_5_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.valuePaneClick.emit($event);\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"background-color\", ctx_r2.selection);\n    i0.ɵɵattribute(\"title\", ctx_r2.getText(\"previewColor\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"background-color\", ctx_r2.value);\n    i0.ɵɵattribute(\"title\", ctx_r2.getText(\"revertSelection\"));\n  }\n}\n\nconst _c47 = [\"kendoColorContrastSvg\", \"\"];\n\nfunction ColorContrastSvgComponent__svg_path_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 1);\n  }\n\n  if (rf & 2) {\n    const path_r1 = ctx.$implicit;\n    i0.ɵɵattribute(\"d\", path_r1);\n  }\n}\n\nconst _c48 = [\"opacityInput\"];\nconst _c49 = [\"hexInput\"];\nconst _c50 = [\"blueInput\"];\nconst _c51 = [\"toggleFormatButton\"];\n\nfunction ColorInputComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 0)(1, \"input\", 6, 7);\n    i0.ɵɵlistener(\"blur\", function ColorInputComponent_div_4_Template_input_blur_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.handleHexInputBlur();\n    })(\"input\", function ColorInputComponent_div_4_Template_input_input_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n\n      const _r3 = i0.ɵɵreference(2);\n\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleHexValueChange(_r3.value);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"label\", 8);\n    i0.ɵɵtext(4, \"HEX\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r1.focusableId)(\"disabled\", ctx_r1.disabled)(\"readonly\", ctx_r1.readonly)(\"value\", ctx_r1.hex || \"\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", ctx_r1.focusableId);\n  }\n}\n\nfunction ColorInputComponent_ng_container_5_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 0)(1, \"kendo-numerictextbox\", 13, 14);\n    i0.ɵɵlistener(\"valueChange\", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext(2);\n      return ctx_r13.rgba.a = $event;\n    })(\"blur\", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_blur_1_listener() {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.handleRgbaInputBlur();\n    })(\"valueChange\", function ColorInputComponent_ng_container_5_div_16_Template_kendo_numerictextbox_valueChange_1_listener() {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.handleRgbaValueChange();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"label\", 8);\n    i0.ɵɵtext(5, \"A\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const _r12 = i0.ɵɵreference(3);\n\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", ctx_r10.disabled)(\"readonly\", ctx_r10.readonly)(\"min\", 0)(\"max\", 1)(\"value\", ctx_r10.rgba.a)(\"autoCorrect\", true)(\"spinners\", false)(\"step\", 0.01)(\"format\", \"n2\")(\"decimals\", 2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"for\", _r12.focusableId);\n  }\n}\n\nfunction ColorInputComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 0)(2, \"kendo-numerictextbox\", 9, 10);\n    i0.ɵɵlistener(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.rgba.r = $event;\n    })(\"blur\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_2_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.handleRgbaInputBlur();\n    })(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_2_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.handleRgbaValueChange();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"label\", 8);\n    i0.ɵɵtext(5, \"R\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"div\", 0)(7, \"kendo-numerictextbox\", 9, 11);\n    i0.ɵɵlistener(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return ctx_r21.rgba.g = $event;\n    })(\"blur\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_7_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return ctx_r22.handleRgbaInputBlur();\n    })(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_7_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return ctx_r23.handleRgbaValueChange();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"label\", 8);\n    i0.ɵɵtext(10, \"G\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"div\", 0)(12, \"kendo-numerictextbox\", 9, 12);\n    i0.ɵɵlistener(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return ctx_r24.rgba.b = $event;\n    })(\"blur\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_blur_12_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.handleRgbaInputBlur();\n    })(\"valueChange\", function ColorInputComponent_ng_container_5_Template_kendo_numerictextbox_valueChange_12_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r26 = i0.ɵɵnextContext();\n      return ctx_r26.handleRgbaValueChange();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"label\", 8);\n    i0.ɵɵtext(15, \"B\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(16, ColorInputComponent_ng_container_5_div_16_Template, 6, 11, \"div\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const _r7 = i0.ɵɵreference(3);\n\n    const _r8 = i0.ɵɵreference(8);\n\n    const _r9 = i0.ɵɵreference(13);\n\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"disabled\", ctx_r2.disabled)(\"readonly\", ctx_r2.readonly)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.r)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r7.focusableId);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"disabled\", ctx_r2.disabled)(\"readonly\", ctx_r2.readonly)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.g)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r8.focusableId);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"disabled\", ctx_r2.disabled)(\"readonly\", ctx_r2.readonly)(\"min\", 0)(\"max\", 255)(\"value\", ctx_r2.rgba.b)(\"autoCorrect\", true)(\"spinners\", false)(\"format\", \"n\")(\"decimals\", 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"for\", _r9.focusableId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.opacity);\n  }\n}\n\nconst _c52 = [\"kendoContrastValidation\", \"\"];\n\nfunction ContrastValidationComponent_ng_container_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelement(2, \"span\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.passMessage, \" \");\n  }\n}\n\nfunction ContrastValidationComponent_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelement(2, \"span\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.failMessage, \" \");\n  }\n}\n\nfunction ContrastValidationComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ContrastValidationComponent_ng_container_2_span_1_Template, 3, 1, \"span\", 1);\n    i0.ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_span_2_Template, 3, 1, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.pass);\n  }\n}\n\nconst _c53 = [\"kendoContrastTool\", \"\"];\n\nfunction ContrastComponent_ng_container_3_span_1_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 8);\n  }\n}\n\nfunction ContrastComponent_ng_container_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7);\n    i0.ɵɵelement(1, \"span\", 8);\n    i0.ɵɵtemplate(2, ContrastComponent_ng_container_3_span_1_span_2_Template, 1, 0, \"span\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.satisfiesAAACondition);\n  }\n}\n\nfunction ContrastComponent_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction ContrastComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ContrastComponent_ng_container_3_span_1_Template, 3, 1, \"span\", 5);\n    i0.ɵɵtemplate(2, ContrastComponent_ng_container_3_span_2_Template, 2, 0, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.satisfiesAACondition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.satisfiesAACondition);\n  }\n}\n\nconst _c54 = [\"gradientDragHandle\"];\nconst _c55 = [\"inputs\"];\nconst _c56 = [\"alphaSlider\"];\nconst _c57 = [\"gradientWrapper\"];\nconst _c58 = [\"hsvRectangle\"];\n\nfunction ColorGradientComponent__svg_svg_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"svg\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(5);\n\n    i0.ɵɵproperty(\"wrapper\", _r1 ? _r1 : undefined)(\"hsva\", ctx_r3.hsva)(\"backgroundColor\", ctx_r3.contrastTool);\n  }\n}\n\nfunction ColorGradientComponent_span_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 16);\n    i0.ɵɵlistener(\"click\", function ColorGradientComponent_span_10_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.reset();\n    })(\"keydown.enter\", function ColorGradientComponent_span_10_Template_span_keydown_enter_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.reset();\n    })(\"keydown.space\", function ColorGradientComponent_span_10_Template_span_keydown_space_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.reset();\n    });\n    i0.ɵɵelement(1, \"span\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r4.clearButtonTitle)(\"title\", ctx_r4.clearButtonTitle);\n  }\n}\n\nconst _c77 = function (a0) {\n  return {\n    \"k-align-self-end\": a0\n  };\n};\n\nfunction ColorGradientComponent_kendo_slider_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-slider\", 18, 19);\n    i0.ɵɵlistener(\"valueChange\", function ColorGradientComponent_kendo_slider_12_Template_kendo_slider_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.handleAlphaSliderChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(12, _c77, ctx_r5.clearButton))(\"dragHandleTitle\", ctx_r5.opacitySliderTitle)(\"disabled\", ctx_r5.disabled)(\"readonly\", ctx_r5.readonly)(\"showButtons\", false)(\"tickPlacement\", \"none\")(\"vertical\", true)(\"min\", 0)(\"max\", 100)(\"smallStep\", 1)(\"largeStep\", 10)(\"value\", ctx_r5.alphaSliderValue);\n  }\n}\n\nfunction ColorGradientComponent_div_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 20);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r7.value)(\"ratio\", ctx_r7.contrastTool);\n  }\n}\n\nconst _c80 = function (a0, a1, a2, a3) {\n  return {\n    backgroundColor: a0,\n    width: a1,\n    height: a2,\n    minWidth: a3\n  };\n};\n\nfunction ColorPaletteComponent_tr_4_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"td\", 5);\n    i0.ɵɵlistener(\"click\", function ColorPaletteComponent_tr_4_td_1_Template_td_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const color_r4 = restoredCtx.$implicit;\n      const colIndex_r5 = restoredCtx.index;\n      const rowIndex_r2 = i0.ɵɵnextContext().index;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleCellSelection(color_r4, {\n        row: rowIndex_r2,\n        col: colIndex_r5\n      });\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const color_r4 = ctx.$implicit;\n    const colIndex_r5 = ctx.index;\n    const rowIndex_r2 = i0.ɵɵnextContext().index;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-state-selected\", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5)(\"k-state-focus\", ctx_r3.focusInComponent && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.row) === rowIndex_r2 && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.col) === colIndex_r5);\n    i0.ɵɵproperty(\"id\", \"k-\" + rowIndex_r2 + \"-\" + colIndex_r5 + \"-\" + ctx_r3.uniqueId)(\"ngStyle\", i0.ɵɵpureFunction4(9, _c80, color_r4, ctx_r3.tileLayout.width + \"px\", ctx_r3.tileLayout.height + \"px\", ctx_r3.tileLayout.width + \"px\"));\n    i0.ɵɵattribute(\"aria-selected\", (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.row) === rowIndex_r2 && (ctx_r3.selectedCell == null ? null : ctx_r3.selectedCell.col) === colIndex_r5)(\"aria-label\", color_r4)(\"value\", color_r4);\n  }\n}\n\nfunction ColorPaletteComponent_tr_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\");\n    i0.ɵɵtemplate(1, ColorPaletteComponent_tr_4_td_1_Template, 1, 14, \"td\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\n\nconst _c81 = [\"last\"];\nconst _c82 = [\"kendoFlatColorPickerActionButtons\", \"\"];\nconst _c83 = [\"header\"];\nconst _c84 = [\"gradient\"];\nconst _c85 = [\"palette\"];\nconst _c86 = [\"footer\"];\n\nfunction FlatColorPickerComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 6, 7);\n    i0.ɵɵlistener(\"clearButtonClick\", function FlatColorPickerComponent_div_1_Template_div_clearButtonClick_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.onClearButtonClick();\n    })(\"viewChange\", function FlatColorPickerComponent_div_1_Template_div_viewChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.onViewChange($event);\n    })(\"valuePaneClick\", function FlatColorPickerComponent_div_1_Template_div_valuePaneClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.resetSelection($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"clearButton\", ctx_r0.clearButton)(\"activeView\", ctx_r0.activeView)(\"views\", ctx_r0.views)(\"value\", ctx_r0.value)(\"selection\", ctx_r0.selection)(\"preview\", ctx_r0.preview);\n  }\n}\n\nfunction FlatColorPickerComponent_kendo_colorgradient_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-colorgradient\", 8, 9);\n    i0.ɵɵlistener(\"valueChange\", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.handleValueChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", null)(\"value\", ctx_r1.selection)(\"format\", ctx_r1.format)(\"opacity\", ctx_r1.gradientSettings.opacity)(\"delay\", ctx_r1.gradientSettings.delay)(\"contrastTool\", ctx_r1.gradientSettings.contrastTool)(\"readonly\", ctx_r1.readonly);\n  }\n}\n\nfunction FlatColorPickerComponent_kendo_colorpalette_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-colorpalette\", 10, 11);\n    i0.ɵɵlistener(\"valueChange\", function FlatColorPickerComponent_kendo_colorpalette_4_Template_kendo_colorpalette_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.handleValueChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"palette\", ctx_r2.paletteSettings.palette)(\"columns\", ctx_r2.paletteSettings.columns)(\"tileSize\", ctx_r2.paletteSettings.tileSize)(\"format\", ctx_r2.format)(\"value\", ctx_r2.selection);\n  }\n}\n\nfunction FlatColorPickerComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 12, 13);\n    i0.ɵɵlistener(\"actionButtonClick\", function FlatColorPickerComponent_div_5_Template_div_actionButtonClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.onAction($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", \"k-justify-content-\" + ctx_r3.actionsLayout);\n  }\n}\n\nconst _c117 = [\"container\"];\nconst _c118 = [\"activeColor\"];\nconst _c119 = [\"popupTemplate\"];\nconst _c120 = [\"flatColorPicker\"];\n\nfunction ColorPickerComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.iconStyles);\n  }\n}\n\nfunction ColorPickerComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-flatcolorpicker\", 11, 12);\n    i0.ɵɵlistener(\"cancel\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_cancel_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleCancelEvent($event);\n    })(\"focusout\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_focusout_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.handlePopupBlur($event);\n    })(\"valueChange\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.handleValueChange($event);\n    })(\"keydown\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.handlePopupKeyDown($event);\n    })(\"activeViewChange\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_activeViewChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.activeViewChange.emit($event);\n    })(\"actionButtonClick\", function ColorPickerComponent_ng_template_8_Template_kendo_flatcolorpicker_actionButtonClick_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.togglePopup();\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r3.value)(\"format\", ctx_r3.format)(\"views\", ctx_r3.views)(\"activeView\", ctx_r3.activeView)(\"actionsLayout\", ctx_r3.actionsLayout)(\"preview\", ctx_r3.preview)(\"gradientSettings\", ctx_r3.gradientSettings)(\"paletteSettings\", ctx_r3.paletteSettings)(\"clearButton\", ctx_r3.clearButton);\n  }\n}\n\nconst _c153 = function (a0, a1) {\n  return {\n    \"k-icon-color-preview\": a0,\n    \"k-no-color\": a1\n  };\n};\n\nfunction FormFieldComponent_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"hasHints\"]);\n  }\n}\n\nfunction FormFieldComponent_ng_content_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3, [\"*ngIf\", \"hasErrors\"]);\n  }\n}\n\nconst _c154 = [[[\"label\"], [\"kendo-label\"]], \"*\", [[\"kendo-formhint\"]], [[\"kendo-formerror\"]]];\nconst _c155 = [\"label, kendo-label\", \"*\", \"kendo-formhint\", \"kendo-formerror\"];\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst areSame = (value1, value2) => value1 === value2 || value1 === null && value2 === undefined || value1 === undefined && value2 === null;\n/**\n * @hidden\n */\n\n\nconst requiresZoneOnBlur = ngControl => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === 'blur');\n/**\n * @hidden\n *\n * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.\n *\n * @param contender Represents the number you want to fit into specified bounds.\n * @param min The inclusive lower bound number.\n * @param max The inclusive upper bound number.\n */\n\n\nconst fitIntoBounds = (contender, min, max) => {\n  if (!isPresent(contender) || isNaN(contender)) {\n    return min;\n  }\n\n  return contender <= min ? min : contender >= max ? max : contender;\n};\n\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\nconst ROUNDNESS = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\n\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''\n      };\n\n    case 'fillMode':\n      return {\n        toRemove: `k-${componentType}-${previousValue}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${newValue}` : ''\n      };\n\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst MAX_PRECISION = 20;\n/**\n * @hidden\n */\n\nconst limitPrecision = precision => Math.min(precision, MAX_PRECISION);\n/**\n * @hidden\n */\n\n\nconst fractionLength = value => {\n  return (String(value).split('.')[1] || \"\").length;\n};\n\nconst maxFractionLength = (value1, value2) => {\n  return Math.max(fractionLength(value1), fractionLength(value2));\n};\n/**\n * @hidden\n */\n\n\nconst toFixedPrecision = (value, precision) => {\n  const maxPrecision = limitPrecision(precision);\n  return parseFloat(value.toFixed(maxPrecision));\n};\n/**\n * @hidden\n */\n\n\nconst add = (value1, value2) => {\n  const maxPrecision = maxFractionLength(value1, value2);\n  return toFixedPrecision(value1 + value2, maxPrecision);\n};\n/**\n * @hidden\n */\n\n\nconst subtract = (value1, value2) => {\n  return add(value1, -value2);\n};\n/**\n * @hidden\n */\n\n\nconst multiply = (value1, value2) => {\n  const maxPrecision = fractionLength(value1) + fractionLength(value2);\n  return toFixedPrecision(value1 * value2, maxPrecision);\n};\n/**\n * @hidden\n */\n\n\nconst divide = (dividend, divisor) => {\n  if (divisor === 0) {\n    return NaN;\n  }\n\n  const power = maxFractionLength(dividend, divisor);\n  const correctionValue = Math.pow(10, power);\n  return correctionValue * dividend / (correctionValue * divisor);\n};\n/**\n * @hidden\n */\n\n\nconst remainder = (dividend, divisor) => {\n  return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));\n};\n/**\n * @hidden\n */\n\n\nconst calculateFixedTrackSize = ({\n  max,\n  min,\n  smallStep,\n  fixedTickWidth\n}) => (max - min) / smallStep * fixedTickWidth;\n/**\n * @hidden\n */\n\n\nconst calculateTrackSize = (wrapperWidth, offset, showButtons = true) => {\n  const BUTTONS_COUNT = 2;\n  const trackOffset = showButtons ? parseFloat(offset) * BUTTONS_COUNT : 0;\n  const trackWidth = wrapperWidth - trackOffset;\n  return Math.floor(trackWidth);\n};\n/**\n * @hidden\n */\n\n\nconst calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {\n  if (smallStep <= 0) {\n    throw new Error('Invalid argument: smallStep must be a positive number');\n  }\n\n  const adjustedRange = Math.abs(subtract(max, min));\n  const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));\n  const result = add(adjustedRatio, 1);\n  return result;\n};\n/**\n * @hidden\n */\n\n\nconst calculateValueFromTick = (index, {\n  max,\n  min,\n  smallStep,\n  reverse,\n  vertical\n}) => {\n  const value = add(min, multiply(index, smallStep));\n  return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n};\n/**\n * @hidden\n */\n\n\nconst calculateHandlePosition = ({\n  trackWidth,\n  min,\n  max,\n  reverse,\n  value\n}) => {\n  const step = trackWidth / Math.abs(max - min);\n  let pos = isPresent(value) ? step * (value - min) : min;\n\n  if (reverse) {\n    pos = trackWidth - pos;\n  }\n\n  return Math.floor(pos);\n};\n/**\n * @hidden\n */\n\n\nconst decreaseValueToStep = (value, {\n  max,\n  min,\n  smallStep,\n  largeStep\n}, large = false) => {\n  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n  const stepValue = subtract(value, min);\n  let result;\n  const stepRemainder = remainder(stepValue, step);\n\n  if (stepRemainder === 0) {\n    result = subtract(stepValue, step);\n  } else {\n    result = subtract(stepValue, stepRemainder);\n  }\n\n  return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\n\n\nconst increaseValueToStep = (value, {\n  max,\n  min,\n  smallStep,\n  largeStep\n}, large = false) => {\n  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n  const stepValue = subtract(value, min);\n  const stepRemainder = remainder(stepValue, step);\n  const result = add(subtract(stepValue, stepRemainder), step);\n  return limitValue(add(result, min), min, max);\n};\n/**\n * @hidden\n */\n\n\nconst isStartHandle = dragHandle => dragHandle.id.indexOf('k-start-handle') > -1;\n/**\n * @hidden\n */\n\n\nconst snapValue = (value, options) => {\n  const {\n    smallStep,\n    min,\n    max\n  } = options;\n  const limited = limitValue(value, min, max);\n\n  if (value !== limited) {\n    return limited;\n  }\n\n  const left = decreaseValueToStep(value, options);\n  const right = increaseValueToStep(value, options);\n\n  if ((value - min) % smallStep === 0) {\n    return value;\n  }\n\n  if (right - value <= (right - left) / 2) {\n    return right;\n  }\n\n  return left;\n};\n/**\n * @hidden\n */\n\n\nconst trimValue = (max, min, value) => {\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n};\n/**\n * @hidden\n */\n\n\nconst trimValueRange = (max, min, value) => {\n  return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];\n};\n/**\n * @hidden\n */\n\n\nconst identity = value => value;\n/**\n * @hidden\n */\n\n\nconst isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);\n/**\n * @hidden\n */\n\n\nconst elementOffset = element => {\n  const box = element.getBoundingClientRect();\n  const documentElement = document.documentElement;\n  return {\n    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),\n    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)\n  };\n};\n/**\n * @hidden\n */\n\n\nconst limitValue = (value, min, max) => {\n  return Math.max(Math.min(value, max), min);\n};\n/**\n * @hidden\n */\n\n\nconst eventValue = (eventArgs, scaleElement, options) => {\n  const {\n    min,\n    max,\n    vertical,\n    rtl\n  } = options;\n  const trackOffset = elementOffset(scaleElement);\n  const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n  const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n  const offsetValue = offset * scale;\n  let value = rtl || vertical ? max - offsetValue : min + offsetValue;\n  const stepFractionLength = fractionLength(options.smallStep);\n  value = toFixedPrecision(value, stepFractionLength + 1);\n  return snapValue(value, options);\n};\n/**\n * @hidden\n */\n\n\nconst isButton = element => {\n  return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n};\n/**\n * @hidden\n */\n\n\nconst increment = options => {\n  return increaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\n\n\nconst decrement = options => {\n  return decreaseValueToStep(options.value, options);\n};\n/**\n * @hidden\n */\n\n\nconst incrementLarge = options => {\n  return increaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\n\n\nconst decrementLarge = options => {\n  return decreaseValueToStep(options.value, options, true);\n};\n/**\n * @hidden\n */\n\n\nconst validateValue = value => {\n  if (isDevMode && value && value[0] > value[1]) {\n    throw new Error('[RangeSlider] The start value should not be greater than the end value.');\n  }\n};\n/**\n * @hidden\n */\n\n\nvar slidersUtil = {\n  calculateFixedTrackSize,\n  calculateValueFromTick,\n  calculateTrackSize,\n  calculateTicksCount,\n  calculateHandlePosition,\n  decreaseValueToStep,\n  decrement,\n  decrementLarge,\n  eventValue,\n  identity,\n  increment,\n  incrementLarge,\n  isButton,\n  isSameRange,\n  isStartHandle,\n  increaseValueToStep,\n  trimValue,\n  trimValueRange,\n  snapValue,\n  validateValue\n};\n/**\n * @hidden\n */\n\nclass SliderModelBase {\n  constructor(props, wrapper, track, renderer) {\n    this.props = props;\n    this.wrapper = wrapper;\n    this.track = track;\n    this.renderer = renderer;\n    this.props = props;\n    this.wrapper = wrapper;\n    this.track = track;\n    this.tickSizes = this.getTickSizes();\n  }\n\n  resizeTrack() {\n    const orientation = this.props.vertical ? 'height' : 'width';\n    const altOrientation = this.props.vertical ? 'width' : 'height';\n    const trackWidth = this.trackWidth();\n    this.track.parentElement.style[orientation] = `${trackWidth}px`;\n    this.track.parentElement.style[altOrientation] = '';\n  }\n\n  resizeTicks(ticksContainer, ticks) {\n    const dimension = this.props.vertical ? \"height\" : \"width\";\n    [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);\n\n    if (this.props.vertical) {\n      this.adjustPadding(ticksContainer);\n    }\n  }\n\n  resizeWrapper() {\n    const dimension = this.props.vertical ? \"height\" : \"width\";\n    const fixedTrackWidth = calculateFixedTrackSize(this.props);\n    const wrapperParentEl = this.wrapper.parentElement;\n\n    if (fixedTrackWidth) {\n      wrapperParentEl.style[dimension] = \"auto\";\n    }\n  }\n\n  trackWidth() {\n    if (this.props.fixedTickWidth) {\n      return calculateFixedTrackSize(this.props);\n    }\n\n    return this.elementSize(this.track.parentElement);\n  }\n\n  getTickSizes() {\n    const {\n      min,\n      max,\n      smallStep\n    } = this.props;\n    const count = calculateTicksCount(min, max, smallStep);\n    const trackSize = this.trackWidth();\n    const distStep = trackSize / subtract(max, min);\n    const result = [];\n    let usedSpace = 0;\n    let endPoint = 0;\n\n    for (let i = 0; i < count; i++) {\n      if (i === 0 || i === count - 1) {\n        endPoint += smallStep / 2 * distStep;\n      } else {\n        endPoint += smallStep * distStep;\n      } // ensure that the sum of the tick sizes does not exceed the track width\n\n\n      endPoint = +endPoint.toFixed(2) - 0.01;\n      const size = Math.round(endPoint - usedSpace);\n      result.push(size);\n      usedSpace += size;\n    }\n\n    if (usedSpace >= trackSize) {\n      result[result.length - 1] -= 1;\n    }\n\n    return result;\n  }\n\n  adjustPadding(ticksContainer) {\n    const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);\n    const trackWidth = this.trackWidth();\n    const reminder = trackWidth - totalTickSize;\n\n    if (reminder !== 0) {\n      const padding = reminder + this.elementOffset(this.track);\n      ticksContainer.style.paddingTop = `${padding}px`;\n    }\n  }\n\n  elementOffset(element) {\n    const {\n      vertical\n    } = this.props;\n    const style = getComputedStyle(element);\n    return parseInt(vertical ? style.bottom : style.left, 10);\n  }\n\n  elementSize(element) {\n    const {\n      vertical\n    } = this.props;\n    return vertical ? element.clientHeight : element.clientWidth;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass SliderModel extends SliderModelBase {\n  positionHandle(dragHandle) {\n    const {\n      max,\n      min,\n      reverse,\n      vertical\n    } = this.props;\n    const position = vertical ? 'bottom' : 'left';\n    const trackWidth = this.trackWidth();\n    const value = trimValue(max, min, this.props.value);\n    this.handlePosition = calculateHandlePosition({\n      min,\n      max,\n      reverse,\n      value,\n      trackWidth\n    });\n    this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);\n  }\n\n  positionSelection(selection) {\n    const {\n      reverse,\n      vertical\n    } = this.props;\n    const dimension = vertical ? 'height' : 'width';\n    let size = this.handlePosition;\n\n    if (reverse) {\n      size = this.trackWidth() - size;\n    }\n\n    this.renderer.setStyle(selection, dimension, `${size}px`);\n  }\n\n}\n\nconst UNTOUCHED = 'ng-untouched';\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\n\n\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find(name => name === className));\n/**\n * @hidden\n */\n\n\nfunction invokeElementMethod(element, name, ...args) {\n  if (element && element.nativeElement) {\n    return element.nativeElement[name].apply(element.nativeElement, args);\n  }\n}\n/**\n * @hidden\n */\n\n\nconst isUntouched = element => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);\n/**\n * @hidden\n */\n\n\nconst containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-inputs',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1655306203,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Represents the template for the labels of the Slider.\n * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside\n * the `<kendo-slider>` tag. The template context is passed to the `label` value.\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-slider [largeStep]=\"2\">\n *           <ng-template kendoSliderLabelTemplate let-value=\"value\">\n *             <b>{{value}}</b>\n *           </ng-template>\n *         </kendo-slider>\n *     `\n * })\n *\n * class AppComponent {\n * }\n *\n * ```\n */\n\nlet LabelTemplateDirective = /*#__PURE__*/(() => {\n  class LabelTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  LabelTemplateDirective.ɵfac = function LabelTemplateDirective_Factory(t) {\n    return new (t || LabelTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  LabelTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LabelTemplateDirective,\n    selectors: [[\"\", \"kendoSliderLabelTemplate\", \"\"]]\n  });\n  return LabelTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SliderBase = /*#__PURE__*/(() => {\n  class SliderBase {\n    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      /**\n       * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title\n       * for each tick is its Slider value. If you use a callback function, the function accepts an argument\n       * that holds the value of the component and returns a string with the new title.\n       */\n\n      this.title = identity;\n      /**\n       * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).\n       *\n       * The available options are:\n       * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.\n       * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.\n       * * `both`&mdash; (Default) The tick marks are located on both sides of the track.\n       * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.\n       */\n\n      this.tickPlacement = 'both';\n      /**\n       * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical\n       * ([see example]({% slug orientation_slider %})).\n       */\n\n      this.vertical = false;\n      /**\n       * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * The attribute accepts both integers and floating-point numbers.\n       */\n\n      this.min = 0;\n      /**\n       * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * The attribute accepts both integers and floating-point numbers.\n       */\n\n      this.max = 10;\n      /**\n       * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).\n       * Accepts positive values only. Can be an integer or a floating-point number.\n       */\n\n      this.smallStep = 1;\n      /**\n       * Specifies that every n<sup>th</sup> tick will be large and will have a label\n       * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).\n       * Accepts positive integer values only.\n       */\n\n      this.largeStep = null;\n      /**\n       * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires each time the user focuses the component.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the component is blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the user selects a new value.\n       */\n\n      this.valueChange = new EventEmitter();\n      this.sliderClass = true;\n      this.subscriptions = new Subscription();\n      /**\n       * @hidden\n       */\n\n      this.ifEnabled = (callback, event) => {\n        if (!this.isDisabled) {\n          callback.call(this, event);\n        }\n      };\n\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n\n    get horizontalClass() {\n      return !this.vertical;\n    }\n\n    get verticalClass() {\n      return this.vertical;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.sizeComponent();\n      }));\n\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n\n      this.control = this.injector.get(NgControl, null);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n\n    get reverse() {\n      return this.localizationService.rtl && !this.vertical;\n    }\n\n    get keyBinding() {\n      const reverse = this.reverse;\n      return {\n        [Keys.ArrowLeft]: reverse ? increment : decrement,\n        [Keys.ArrowRight]: reverse ? decrement : increment,\n        [Keys.ArrowDown]: decrement,\n        [Keys.ArrowUp]: increment,\n        [Keys.PageUp]: incrementLarge,\n        [Keys.PageDown]: decrementLarge,\n        [Keys.Home]: ({\n          min\n        }) => min,\n        [Keys.End]: ({\n          max\n        }) => max\n      };\n    }\n\n    resetStyles(elements) {\n      elements.forEach(el => {\n        if (el) {\n          if (this.vertical) {\n            this.renderer.removeStyle(el, 'width');\n            this.renderer.removeStyle(el, 'left');\n            this.renderer.removeStyle(el, 'right');\n          } else {\n            this.renderer.removeStyle(el, 'height');\n            this.renderer.removeStyle(el, 'bottom');\n          }\n\n          this.renderer.removeStyle(el, 'padding-top');\n        }\n      });\n    }\n\n  }\n\n  SliderBase.ɵfac = function SliderBase_Factory(t) {\n    return new (t || SliderBase)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  SliderBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SliderBase,\n    selectors: [[\"kendo-slider-base\"]],\n    contentQueries: function SliderBase_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, LabelTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);\n      }\n    },\n    viewQuery: function SliderBase_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n        i0.ɵɵviewQuery(_c3, 5, ElementRef);\n        i0.ɵɵviewQuery(_c3, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ticks = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function SliderBase_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-slider-horizontal\", ctx.horizontalClass)(\"k-slider-vertical\", ctx.verticalClass)(\"k-slider\", ctx.sliderClass)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      tickPlacement: \"tickPlacement\",\n      vertical: \"vertical\",\n      min: \"min\",\n      max: \"max\",\n      smallStep: \"smallStep\",\n      largeStep: \"largeStep\",\n      fixedTickWidth: \"fixedTickWidth\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function SliderBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SliderBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/component-selector */\n\n/**\n * @hidden\n */\n\n\nclass SliderTick {\n  constructor(value) {\n    this.value = value;\n    this.classes = {\n      'k-tick': true\n    };\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet SliderTicksComponent = /*#__PURE__*/(() => {\n  class SliderTicksComponent {\n    constructor() {\n      this.wrapperClasses = 'k-reset k-slider-items';\n      this.ticks = [];\n    }\n\n    ngOnChanges(_) {\n      this.createTicks();\n    }\n\n    createTicks() {\n      const count = calculateTicksCount(this.min, this.max, this.step);\n      const largeStep = this.largeStep;\n      const tickValueProps = {\n        max: this.max,\n        min: this.min,\n        smallStep: this.step\n      };\n      let result = [];\n\n      for (let i = 0; i < count; i++) {\n        result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));\n\n        if (largeStep && i % largeStep === 0) {\n          result[i].large = true;\n          result[i].classes['k-tick-large'] = true;\n        }\n      }\n\n      if (result.length > 0) {\n        Object.assign(result[0].classes, this.endTickClasses(true));\n        Object.assign(result[result.length - 1].classes, this.endTickClasses(false));\n      }\n\n      this.ticks = result;\n    }\n\n    endTickClasses(first) {\n      return {\n        'k-first': first && !this.vertical || !first && this.vertical,\n        'k-last': !first && !this.vertical || first && this.vertical\n      };\n    }\n\n  }\n\n  SliderTicksComponent.ɵfac = function SliderTicksComponent_Factory(t) {\n    return new (t || SliderTicksComponent)();\n  };\n\n  SliderTicksComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SliderTicksComponent,\n    selectors: [[\"\", \"kendoSliderTicks\", \"\"]],\n    viewQuery: function SliderTicksComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c4, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tickElements = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function SliderTicksComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.wrapperClasses);\n      }\n    },\n    inputs: {\n      tickTitle: \"tickTitle\",\n      vertical: \"vertical\",\n      step: \"step\",\n      largeStep: \"largeStep\",\n      min: \"min\",\n      max: \"max\",\n      labelTemplate: \"labelTemplate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c5,\n    decls: 3,\n    vars: 1,\n    consts: [[\"role\", \"presentation\", 3, \"ngClass\", \"title\", 4, \"ngFor\", \"ngForOf\"], [\"defaultLabel\", \"\"], [\"role\", \"presentation\", 3, \"ngClass\", \"title\"], [\"tickElement\", \"\"], [3, \"ngSwitch\"], [\"class\", \"k-label\", 4, \"ngSwitchCase\"], [4, \"ngSwitchCase\"], [1, \"k-label\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function SliderTicksComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, \"li\", 0);\n        i0.ɵɵtemplate(1, SliderTicksComponent_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n      }\n    },\n    directives: [i1$1.NgForOf, i1$1.NgClass, i1$1.NgSwitch, i1$1.NgSwitchCase, i1$1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return SliderTicksComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SliderMessages = /*#__PURE__*/(() => {\n  class SliderMessages extends ComponentMessages {}\n\n  SliderMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵSliderMessages_BaseFactory;\n    return function SliderMessages_Factory(t) {\n      return (ɵSliderMessages_BaseFactory || (ɵSliderMessages_BaseFactory = i0.ɵɵgetInheritedFactory(SliderMessages)))(t || SliderMessages);\n    };\n  }();\n\n  SliderMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SliderMessages,\n    selectors: [[\"kendo-slider-messages-base\"]],\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\",\n      dragHandle: \"dragHandle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return SliderMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedSliderMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedSliderMessagesDirective extends SliderMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedSliderMessagesDirective.ɵfac = function LocalizedSliderMessagesDirective_Factory(t) {\n    return new (t || LocalizedSliderMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedSliderMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedSliderMessagesDirective,\n    selectors: [[\"\", \"kendoSliderLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SliderMessages,\n      useExisting: forwardRef(() => LocalizedSliderMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedSliderMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PRESSED$1 = 'k-pressed';\n/**\n * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).\n */\n\nlet SliderComponent = /*#__PURE__*/(() => {\n  class SliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n      super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n      this.localization = localization;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Determines if the animation will be played on value change.\n       * Regardless of this setting, no animation will be played during the initial rendering.\n       */\n\n      this.animate = true;\n      /**\n       * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).\n       * When `showButtons` is set to `false`, the buttons are not displayed.\n       */\n\n      this.showButtons = true;\n      /**\n       * The current value of the Slider when it is initially displayed.\n       * The component can use either NgModel or the `value` binding but not both of them at the same time.\n       */\n\n      this.value = this.min;\n      this.focusChangedProgrammatically = false;\n      /**\n       * @hidden\n       */\n\n      this.onWrapClick = args => {\n        const target = args.target;\n\n        if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {\n          const value = eventValue(args, this.track.nativeElement, this.getProps());\n          this.changeValue(value);\n        }\n\n        invokeElementMethod(this.draghandle, 'focus');\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.onKeyDown = e => {\n        const options = this.getProps();\n        const {\n          max,\n          min\n        } = options;\n        const handler = this.keyBinding[e.keyCode];\n\n        if (this.isDisabled || !handler) {\n          return;\n        }\n\n        const value = handler(options);\n        this.changeValue(trimValue(max, min, value));\n        e.preventDefault();\n      };\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n\n      this.decreaseValue = () => {\n        this.changeValue(decreaseValueToStep(this.value, this.getProps()));\n      };\n\n      this.increaseValue = () => {\n        this.changeValue(increaseValueToStep(this.value, this.getProps()));\n      };\n\n      this.handleBlur = () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n\n            if (!this.focusChangedProgrammatically) {\n              this.onBlur.emit();\n            }\n          });\n        }\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get currentValue() {\n      return isPresent(this.value) ? this.value.toString() : '';\n    }\n    /**\n     * Focuses the Slider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"slider.focus()\">Focus</button>\n     *  <kendo-slider #slider></kendo-slider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.focusChangedProgrammatically = true;\n        invokeElementMethod(this.draghandle, 'focus');\n        this.focusChangedProgrammatically = false;\n      }\n    }\n    /**\n     * Blurs the Slider.\n     */\n\n\n    blur() {\n      this.focusChangedProgrammatically = true;\n      invokeElementMethod(this.draghandle, 'blur');\n      this.handleBlur();\n      this.focusChangedProgrammatically = false;\n    }\n\n    ngOnChanges(changes) {\n      if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          this.sizeComponent(false);\n        });\n      }\n    }\n\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      if (this.showButtons) {\n        this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());\n        this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());\n      }\n\n      this.sizeComponent(false);\n\n      if (this.ticks) {\n        this.ticks.tickElements.changes.subscribe(() => this.sizeComponent(false));\n      }\n\n      this.attachElementEventHandlers();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get incrementMessage() {\n      return this.incrementTitle || this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get decrementMessage() {\n      return this.decrementTitle || this.localizationService.get('decrement');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get dragHandleMessage() {\n      return this.dragHandleTitle || this.localizationService.get('dragHandle');\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDragPress(args) {\n      if (args.originalEvent) {\n        args.originalEvent.preventDefault();\n      }\n\n      this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleDrag(args) {\n      this.dragging = true;\n      this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleRelease() {\n      this.dragging = false; //needed for animation\n\n      this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n    } //ngModel binding\n\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.changeDetector.markForCheck();\n      this.value = value;\n      this.sizeComponent(this.animate);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    changeValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.sizeComponent(this.animate);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    sizeComponent(animate) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const wrapper = this.wrapper.nativeElement;\n      const track = this.track.nativeElement;\n      const selectionEl = this.sliderSelection.nativeElement;\n      const dragHandleEl = this.draghandle.nativeElement;\n      const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n\n      if (!animate) {\n        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');\n      }\n\n      this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);\n      const props = this.getProps();\n      const model = new SliderModel(props, wrapper, track, this.renderer);\n      model.resizeTrack();\n\n      if (this.ticks) {\n        //for case when tickPlacement: none\n        model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n      }\n\n      model.positionHandle(dragHandleEl);\n      model.positionSelection(selectionEl);\n\n      if (!animate) {\n        this.hostElement.nativeElement.getBoundingClientRect();\n        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');\n      }\n\n      if (this.fixedTickWidth) {\n        model.resizeWrapper();\n      }\n    }\n\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        this.isFocused = value;\n      }\n    }\n\n    set dragging(value) {\n      if (this.isDragged !== value && this.sliderSelection && this.draghandle) {\n        const sliderSelection = this.sliderSelection.nativeElement;\n        const draghandle = this.draghandle.nativeElement;\n\n        if (value) {\n          this.renderer.addClass(sliderSelection, PRESSED$1);\n          this.renderer.addClass(draghandle, PRESSED$1);\n        } else {\n          this.renderer.removeClass(sliderSelection, PRESSED$1);\n          this.renderer.removeClass(draghandle, PRESSED$1);\n        }\n\n        this.isDragged = value;\n      }\n    }\n\n    setValueChangeInterval(element, callback) {\n      this.ngZone.runOutsideAngular(() => {\n        const mousedown = fromEvent(element, 'mousedown');\n        const mouseup = fromEvent(element, 'mouseup');\n        const mouseout = fromEvent(element, 'mouseout');\n        const subscription = mousedown.pipe(filter(e => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {\n          if (!this.isFocused) {\n            invokeElementMethod(this.draghandle, 'focus');\n          }\n\n          callback();\n        });\n        this.subscriptions.add(subscription);\n      });\n    }\n\n    getProps() {\n      return {\n        buttons: this.showButtons,\n        disabled: this.disabled,\n        fixedTickWidth: this.fixedTickWidth,\n        largeStep: this.largeStep,\n        max: this.max,\n        min: this.min,\n        readonly: this.readonly,\n        reverse: this.reverse,\n        rtl: this.localizationService.rtl,\n        smallStep: this.smallStep,\n        value: trimValue(this.max, this.min, this.value),\n        vertical: this.vertical\n      };\n    }\n\n    attachElementEventHandlers() {\n      const hostElement = this.hostElement.nativeElement;\n      let tabbing = false;\n      let cursorInsideWrapper = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              if (!this.focusChangedProgrammatically) {\n                this.onFocus.emit();\n              }\n\n              this.focused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n\n          if (tabbing) {\n            if (args.relatedTarget !== this.draghandle.nativeElement) {\n              this.handleBlur();\n            }\n\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n\n  }\n\n  SliderComponent.ɵfac = function SliderComponent_Factory(t) {\n    return new (t || SliderComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  SliderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SliderComponent,\n    selectors: [[\"kendo-slider\"]],\n    viewQuery: function SliderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 7);\n        i0.ɵɵviewQuery(_c7, 5);\n        i0.ɵɵviewQuery(_c8, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.increaseButton = _t.first);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      dragHandleTitle: \"dragHandleTitle\",\n      incrementTitle: \"incrementTitle\",\n      animate: \"animate\",\n      decrementTitle: \"decrementTitle\",\n      showButtons: \"showButtons\",\n      value: \"value\",\n      tabIndex: \"tabIndex\"\n    },\n    exportAs: [\"kendoSlider\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.slider'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SliderComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => SliderComponent)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 14,\n    vars: 25,\n    consts: function () {\n      let i18n_9;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Increase** button of the Slider.\n         * @meaning kendo.slider.increment\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_10 = goog.getMsg(\"increment\");\n        i18n_9 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_10;\n      } else {\n        i18n_9 = $localize`:kendo.slider.increment|The title of the **Increase** button of the Slider.:increment`;\n      }\n\n      let i18n_11;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Decrease** button of the Slider.\n         * @meaning kendo.slider.decrement\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_12 = goog.getMsg(\"decrement\");\n        i18n_11 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_12;\n      } else {\n        i18n_11 = $localize`:kendo.slider.decrement|The title of the **Decrease** button of the Slider.:decrement`;\n      }\n\n      let i18n_13;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the drag handle of the Slider.\n         * @meaning kendo.slider.dragHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_14 = goog.getMsg(\"Drag\");\n        i18n_13 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_14;\n      } else {\n        i18n_13 = $localize`:kendo.slider.dragHandle|The title of the drag handle of the Slider.:Drag`;\n      }\n\n      return [[\"kendoSliderLocalizedMessages\", \"\", \"increment\", i18n_9, \"decrement\", i18n_11, \"dragHandle\", i18n_13], [1, \"k-slider-wrap\", 3, \"kendoEventsOutsideAngular\"], [\"wrap\", \"\"], [\"type\", \"button\", \"class\", \"k-button-decrease k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button\", \"role\", \"presentation\", 3, \"title\", 4, \"ngIf\"], [1, \"k-slider-track-wrap\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\", 4, \"ngIf\"], [1, \"k-slider-track\"], [\"track\", \"\"], [1, \"k-slider-selection\"], [\"sliderSelection\", \"\"], [\"role\", \"slider\", \"kendoDraggable\", \"\", 1, \"k-draghandle\", 3, \"title\", \"id\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"draghandle\", \"\"], [\"type\", \"button\", \"class\", \"k-button-increase k-button k-button-md k-rounded-full k-button-rectangle k-button-solid k-button-solid-base k-icon-button\", \"role\", \"presentation\", 3, \"title\", \"click\", 4, \"ngIf\"], [3, \"resize\"], [\"type\", \"button\", \"role\", \"presentation\", 1, \"k-button-decrease\", \"k-button\", \"k-button-md\", \"k-rounded-full\", \"k-button-rectangle\", \"k-button-solid\", \"k-button-solid-base\", \"k-icon-button\", 3, \"title\"], [\"decreaseButton\", \"\"], [1, \"k-button-icon\", \"k-icon\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\"], [\"ticks\", \"\"], [\"type\", \"button\", \"role\", \"presentation\", 1, \"k-button-increase\", \"k-button\", \"k-button-md\", \"k-rounded-full\", \"k-button-rectangle\", \"k-button-solid\", \"k-button-solid-base\", \"k-icon-button\", 3, \"title\", \"click\"], [\"increaseButton\", \"\"]];\n    },\n    template: function SliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵtemplate(3, SliderComponent_button_3_Template, 3, 6, \"button\", 3);\n        i0.ɵɵelementStart(4, \"div\", 4);\n        i0.ɵɵtemplate(5, SliderComponent_ul_5_Template, 2, 8, \"ul\", 5);\n        i0.ɵɵelementStart(6, \"div\", 6, 7);\n        i0.ɵɵelement(8, \"div\", 8, 9);\n        i0.ɵɵelementStart(10, \"a\", 10, 11);\n        i0.ɵɵlistener(\"kendoPress\", function SliderComponent_Template_a_kendoPress_10_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function SliderComponent_Template_a_kendoDrag_10_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function SliderComponent_Template_a_kendoRelease_10_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(12, SliderComponent_button_12_Template, 3, 7, \"button\", 12);\n        i0.ɵɵelementStart(13, \"kendo-resize-sensor\", 13);\n        i0.ɵɵlistener(\"resize\", function SliderComponent_Template_kendo_resize_sensor_resize_13_listener() {\n          return ctx.sizeComponent(false);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-slider-buttons\", ctx.showButtons)(\"k-slider-topleft\", ctx.tickPlacement === \"before\")(\"k-slider-bottomright\", ctx.tickPlacement === \"after\");\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(22, _c15, ctx.onWrapClick, ctx.onKeyDown));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButtons);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.tickPlacement !== \"none\");\n        i0.ɵɵadvance(5);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"title\", ctx.dragHandleMessage)(\"id\", ctx.focusableId);\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.currentValue)(\"aria-valuetext\", ctx.currentValue)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\")(\"tabindex\", ctx.disabled ? \"-1\" : ctx.tabIndex);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showButtons);\n      }\n    },\n    directives: [SliderTicksComponent, i3.ResizeSensorComponent, LocalizedSliderMessagesDirective, i3.EventsOutsideAngularDirective, i1$1.NgIf, i3.DraggableDirective],\n    encapsulation: 2\n  });\n  return SliderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass RangeSliderModel extends SliderModelBase {\n  positionHandle(dragHandle) {\n    if (!dragHandle.id) {\n      return;\n    }\n\n    const {\n      max,\n      min,\n      reverse,\n      vertical\n    } = this.props;\n    const position = vertical ? 'bottom' : 'left';\n    const trackWidth = this.trackWidth();\n    const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0] : trimValueRange(max, min, this.props.value)[1];\n\n    if (isStartHandle(dragHandle)) {\n      this.startHandlePosition = calculateHandlePosition({\n        min,\n        max,\n        reverse,\n        value,\n        trackWidth\n      });\n      this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);\n    } else {\n      this.endHandlePosition = calculateHandlePosition({\n        min,\n        max,\n        reverse,\n        value,\n        trackWidth\n      });\n      this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);\n    }\n  }\n\n  positionSelection(dragHandle, selection) {\n    const {\n      reverse,\n      vertical\n    } = this.props;\n    const dimension = vertical ? 'height' : 'width';\n    const position = vertical ? 'bottom' : reverse ? 'right' : 'left';\n    const size = Math.abs(this.endHandlePosition - this.startHandlePosition);\n    const currentSelectionPosition = vertical ? dragHandle.style.bottom : dragHandle.style.left;\n    this.renderer.setStyle(selection, dimension, `${size}px`);\n    this.renderer.setStyle(selection, position, reverse ? this.trackWidth() - parseFloat(currentSelectionPosition) + 'px' : parseFloat(currentSelectionPosition) + 'px');\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet RangeSliderMessages = /*#__PURE__*/(() => {\n  class RangeSliderMessages extends ComponentMessages {}\n\n  RangeSliderMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵRangeSliderMessages_BaseFactory;\n    return function RangeSliderMessages_Factory(t) {\n      return (ɵRangeSliderMessages_BaseFactory || (ɵRangeSliderMessages_BaseFactory = i0.ɵɵgetInheritedFactory(RangeSliderMessages)))(t || RangeSliderMessages);\n    };\n  }();\n\n  RangeSliderMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RangeSliderMessages,\n    selectors: [[\"kendo-rangeslider-messages-base\"]],\n    inputs: {\n      dragHandleStart: \"dragHandleStart\",\n      dragHandleEnd: \"dragHandleEnd\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return RangeSliderMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedRangeSliderMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedRangeSliderMessagesDirective.ɵfac = function LocalizedRangeSliderMessagesDirective_Factory(t) {\n    return new (t || LocalizedRangeSliderMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedRangeSliderMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedRangeSliderMessagesDirective,\n    selectors: [[\"\", \"kendoSliderLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: RangeSliderMessages,\n      useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedRangeSliderMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PRESSED = 'k-pressed';\n/**\n * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).\n */\n\nlet RangeSliderComponent = /*#__PURE__*/(() => {\n  class RangeSliderComponent extends SliderBase {\n    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {\n      super(localization, injector, renderer, ngZone, changeDetector, hostElement);\n      this.localization = localization;\n      this.injector = injector;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      /**\n       * @hidden\n       */\n\n      this.startHandleId = `k-start-handle-${guid()}`;\n      /**\n       * @hidden\n       */\n\n      this.endHandleId = `k-end-handle-${guid()}`;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = this.startHandleId;\n      this.handleZIndex = 0;\n      this.activeHandle = 'startHandle';\n      this.focusChangedProgrammatically = false;\n      /**\n       * @hidden\n       */\n\n      this.onWrapClick = args => {\n        if (!this.isDisabled) {\n          this.value = this.value || [this.min, this.min];\n          const trackValue = eventValue(args, this.track.nativeElement, this.getProps());\n          let newRangeValue;\n          const [startValue, endValue] = newRangeValue = this.value;\n\n          if (trackValue <= startValue) {\n            newRangeValue = [trackValue, endValue];\n            this.activeHandle = 'startHandle';\n          } else if (startValue < trackValue && trackValue < endValue) {\n            if (trackValue < (startValue + endValue) / 2) {\n              newRangeValue = [trackValue, endValue];\n              this.activeHandle = 'startHandle';\n            } else {\n              newRangeValue = [startValue, trackValue];\n              this.activeHandle = 'endHandle';\n            }\n          } else if (trackValue >= endValue) {\n            newRangeValue = [startValue, trackValue];\n            this.activeHandle = 'endHandle';\n          }\n\n          const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n          invokeElementMethod(activeHandle, 'focus');\n          this.changeValue(newRangeValue);\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.onKeyDown = e => {\n        this.value = this.value || [this.min, this.min];\n        const options = this.getProps();\n        const {\n          max,\n          min\n        } = options;\n        const handler = this.keyBinding[e.keyCode];\n\n        if (this.isDisabled || !handler) {\n          return;\n        }\n\n        this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);\n        const startHandleIsActive = isStartHandle(e.target);\n        const value = handler(Object.assign(Object.assign({}, options), {\n          value: startHandleIsActive ? this.value[0] : this.value[1]\n        }));\n\n        if (startHandleIsActive) {\n          if (value > this.value[1]) {\n            this.value[1] = value;\n          }\n        } else {\n          if (value < this.value[0]) {\n            this.value[0] = value;\n          }\n        }\n\n        const trimmedValue = trimValue(max, min, value);\n        const newValue = startHandleIsActive ? [trimmedValue, this.value[1]] : [this.value[0], trimmedValue];\n        this.changeValue(newValue);\n        e.preventDefault();\n      };\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n\n      this.handleBlur = () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n\n            if (!this.focusChangedProgrammatically) {\n              this.onBlur.emit();\n            }\n          });\n        }\n      };\n    }\n    /**\n     * Focuses the RangeSlider.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *     <div>\n     *         <button class=\"k-button\" (click)=\"slider.focus()\">Focus</button>\n     *     </div>\n     *     <kendo-rangeslider #slider></kendo-rangeslider>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      this.focusChangedProgrammatically = true;\n      invokeElementMethod(this.draghandleStart, 'focus');\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the RangeSlider.\n     */\n\n\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;\n      invokeElementMethod(activeHandle, 'blur');\n      this.handleBlur();\n      this.focusChangedProgrammatically = false;\n    }\n\n    ngOnInit() {\n      if (!this.value) {\n        this.value = [this.min, this.max];\n      }\n\n      super.ngOnInit();\n    }\n\n    ngOnChanges(changes) {\n      if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {\n        if (changes.value && changes.value.currentValue) {\n          validateValue(changes.value.currentValue);\n        }\n\n        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          this.sizeComponent();\n        });\n      }\n    }\n\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.sizeComponent();\n\n      if (this.ticks) {\n        this.ticks.tickElements.changes.subscribe(() => this.sizeComponent());\n      }\n\n      this.attachElementEventHandlers();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    textFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get valueText() {\n      return this.value ? `${this.value[0]} - ${this.value[1]}` : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDragPress(args) {\n      if (args.originalEvent) {\n        args.originalEvent.preventDefault();\n      }\n\n      const target = args.originalEvent.target;\n      this.draggedHandle = target;\n      this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleDrag(args) {\n      this.value = this.value || [this.min, this.min];\n      const target = args.originalEvent.target;\n      const lastCoords = this.draggedHandle.getBoundingClientRect();\n      this.lastHandlePosition = {\n        x: lastCoords.left,\n        y: lastCoords.top\n      };\n      this.dragging = {\n        value: true,\n        target\n      };\n      const mousePos = {\n        x: args.pageX - 0.5 - lastCoords.width / 2,\n        y: args.pageY - lastCoords.width / 2\n      };\n      const left = mousePos.x < this.lastHandlePosition.x;\n      const right = mousePos.x > this.lastHandlePosition.x;\n      const up = mousePos.y > this.lastHandlePosition.y;\n\n      const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);\n\n      const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);\n\n      const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);\n\n      const activeStartHandle = isStartHandle(this.draggedHandle);\n      const vertical = this.vertical;\n      const horizontal = !vertical;\n      const forward = vertical && up || (this.reverse ? horizontal && right : horizontal && left);\n      const incorrectValueState = this.value[0] > this.value[1];\n\n      if (this.value[0] === this.value[1] || incorrectValueState) {\n        if (forward) {\n          // eslint-disable-next-line no-unused-expressions\n          activeStartHandle ? moveStartHandle() : moveBothHandles();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          activeStartHandle ? moveBothHandles() : moveEndHandle();\n        }\n      } else {\n        // eslint-disable-next-line no-unused-expressions\n        activeStartHandle ? moveStartHandle() : moveEndHandle();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleRelease(args) {\n      this.dragging = {\n        value: false,\n        target: args.originalEvent.target\n      }; //needed for animation\n\n      this.draggedHandle = undefined;\n    } //ngModel binding\n\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      validateValue(value);\n      this.value = value;\n      this.sizeComponent();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    changeValue(value) {\n      if (!this.value || !isSameRange(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n\n          if (this.value) {\n            this.valueChange.emit(value);\n          }\n\n          this.sizeComponent();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    sizeComponent() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const wrapper = this.wrapper.nativeElement;\n      const track = this.track.nativeElement;\n      const selectionEl = this.sliderSelection.nativeElement;\n      const dragHandleStartEl = this.draghandleStart.nativeElement;\n      const dragHandleEndEl = this.draghandleEnd.nativeElement;\n      const ticks = this.ticks ? this.ticksContainer.nativeElement : null;\n      this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);\n      const props = this.getProps();\n      const model = new RangeSliderModel(props, wrapper, track, this.renderer);\n      model.resizeTrack();\n\n      if (this.ticks) {\n        //for case when tickPlacement: none\n        model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));\n      }\n\n      model.positionHandle(dragHandleStartEl);\n      model.positionHandle(dragHandleEndEl);\n      model.positionSelection(dragHandleStartEl, selectionEl);\n\n      if (this.fixedTickWidth) {\n        model.resizeWrapper();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        this.isFocused = value;\n      }\n    }\n\n    set dragging(data) {\n      if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {\n        const sliderSelection = this.sliderSelection.nativeElement;\n        const draghandle = data.target;\n\n        if (data.value) {\n          this.renderer.addClass(sliderSelection, PRESSED);\n          this.renderer.addClass(draghandle, PRESSED);\n        } else {\n          this.renderer.removeClass(sliderSelection, PRESSED);\n          this.renderer.removeClass(draghandle, PRESSED);\n        }\n\n        this.isDragged = data.value;\n      }\n    }\n\n    getProps() {\n      return {\n        disabled: this.disabled,\n        fixedTickWidth: this.fixedTickWidth,\n        largeStep: this.largeStep,\n        max: this.max,\n        min: this.min,\n        readonly: this.readonly,\n        reverse: this.reverse,\n        rtl: this.localizationService.rtl,\n        smallStep: this.smallStep,\n        value: trimValueRange(this.max, this.min, this.value),\n        vertical: this.vertical,\n        buttons: false\n      };\n    }\n\n    attachElementEventHandlers() {\n      const hostElement = this.hostElement.nativeElement;\n      let tabbing = false;\n      let cursorInsideWrapper = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              if (!this.focusChangedProgrammatically) {\n                this.onFocus.emit();\n              }\n\n              this.focused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n\n          if (tabbing) {\n            if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {\n              this.handleBlur();\n            }\n\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n    }\n\n  }\n\n  RangeSliderComponent.ɵfac = function RangeSliderComponent_Factory(t) {\n    return new (t || RangeSliderComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  RangeSliderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: RangeSliderComponent,\n    selectors: [[\"kendo-rangeslider\"]],\n    viewQuery: function RangeSliderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c16, 7);\n        i0.ɵɵviewQuery(_c17, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);\n      }\n    },\n    inputs: {\n      value: \"value\"\n    },\n    exportAs: [\"kendoRangeSlider\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.rangeslider'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => RangeSliderComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => RangeSliderComponent)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 14,\n    vars: 33,\n    consts: function () {\n      let i18n_18;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **Start** drag handle of the Slider.\n         * @meaning kendo.rangeslider.dragHandleStart\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_19 = goog.getMsg(\"Drag\");\n        i18n_18 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_19;\n      } else {\n        i18n_18 = $localize`:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.:Drag`;\n      }\n\n      let i18n_20;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **End** drag handle of the Slider.\n         * @meaning kendo.rangeslider.dragHandleEnd\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_21 = goog.getMsg(\"Drag\");\n        i18n_20 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_21;\n      } else {\n        i18n_20 = $localize`:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.:Drag`;\n      }\n\n      return [[\"kendoSliderLocalizedMessages\", \"\", \"dragHandleStart\", i18n_18, \"dragHandleEnd\", i18n_20], [1, \"k-slider-wrap\", 3, \"kendoEventsOutsideAngular\"], [\"wrap\", \"\"], [1, \"k-slider-track-wrap\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\", 4, \"ngIf\"], [1, \"k-slider-track\"], [\"track\", \"\"], [1, \"k-slider-selection\"], [\"sliderSelection\", \"\"], [\"role\", \"slider\", \"kendoDraggable\", \"\", 1, \"k-draghandle\", 3, \"id\", \"title\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"draghandleStart\", \"\"], [\"draghandleEnd\", \"\"], [3, \"resize\"], [\"kendoSliderTicks\", \"\", 3, \"tickTitle\", \"vertical\", \"step\", \"largeStep\", \"min\", \"max\", \"labelTemplate\"], [\"ticks\", \"\"]];\n    },\n    template: function RangeSliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"div\", 3);\n        i0.ɵɵtemplate(4, RangeSliderComponent_ul_4_Template, 2, 8, \"ul\", 4);\n        i0.ɵɵelementStart(5, \"div\", 5, 6);\n        i0.ɵɵelement(7, \"div\", 7, 8);\n        i0.ɵɵelementStart(9, \"a\", 9, 10);\n        i0.ɵɵlistener(\"kendoPress\", function RangeSliderComponent_Template_a_kendoPress_9_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function RangeSliderComponent_Template_a_kendoDrag_9_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function RangeSliderComponent_Template_a_kendoRelease_9_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"a\", 9, 11);\n        i0.ɵɵlistener(\"kendoPress\", function RangeSliderComponent_Template_a_kendoPress_11_listener($event) {\n          return ctx.ifEnabled(ctx.handleDragPress, $event);\n        })(\"kendoDrag\", function RangeSliderComponent_Template_a_kendoDrag_11_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleDrag, $event);\n        })(\"kendoRelease\", function RangeSliderComponent_Template_a_kendoRelease_11_listener($event) {\n          return ctx.ifEnabled(ctx.onHandleRelease, $event);\n        });\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(13, \"kendo-resize-sensor\", 12);\n        i0.ɵɵlistener(\"resize\", function RangeSliderComponent_Template_kendo_resize_sensor_resize_13_listener() {\n          return ctx.sizeComponent();\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-slider-topleft\", ctx.tickPlacement === \"before\")(\"k-slider-bottomright\", ctx.tickPlacement === \"after\");\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(30, _c15, ctx.onWrapClick, ctx.onKeyDown));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.tickPlacement !== \"none\");\n        i0.ɵɵadvance(5);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"id\", ctx.startHandleId)(\"title\", ctx.textFor(\"dragHandleStart\"));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value ? ctx.value[0] : null)(\"aria-valuetext\", ctx.valueText)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.isDisabled ? \"\" : \"none\");\n        i0.ɵɵproperty(\"id\", ctx.endHandleId)(\"title\", ctx.textFor(\"dragHandleEnd\"));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value ? ctx.value[1] : null)(\"aria-valuetext\", ctx.valueText)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\");\n      }\n    },\n    directives: [SliderTicksComponent, i3.ResizeSensorComponent, LocalizedRangeSliderMessagesDirective, i3.EventsOutsideAngularDirective, i1$1.NgIf, i3.DraggableDirective],\n    encapsulation: 2\n  });\n  return RangeSliderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n\n  Messages.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = i0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n\n  Messages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages,\n    selectors: [[\"kendo-switch-messages-base\"]],\n    inputs: {\n      on: \"on\",\n      off: \"off\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedSwitchMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedSwitchMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedSwitchMessagesDirective.ɵfac = function LocalizedSwitchMessagesDirective_Factory(t) {\n    return new (t || LocalizedSwitchMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedSwitchMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedSwitchMessagesDirective,\n    selectors: [[\"\", \"kendoSwitchLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => LocalizedSwitchMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedSwitchMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FOCUSED$4 = 'k-focus';\nconst DEFAULT_SIZE$7 = 'medium';\nconst DEFAULT_THUMB_ROUNDED = 'full';\nconst DEFAULT_TRACK_ROUNDED = 'full';\n/**\n * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).\n */\n\nlet SwitchComponent = /*#__PURE__*/(() => {\n  class SwitchComponent {\n    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.changeDetector = changeDetector;\n      this.ngZone = ngZone;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the user selects a new value.\n       */\n\n      this.valueChange = new EventEmitter();\n      this.hostClasses = true;\n      /**\n       * @hidden\n       */\n\n      this.initialized = false;\n      this.hostClickSubscription = new Subscription();\n      this._checked = false;\n      this._size = 'medium';\n      this._trackRounded = 'full';\n      this._thumbRounded = 'full';\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n      /**\n       * @hidden\n       */\n\n\n      this.handleFocus = () => {\n        if (this.isFocused) {\n          return;\n        }\n\n        this.focused = true;\n\n        if (hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleBlur = event => {\n        const relatedTarget = event && event.relatedTarget;\n\n        if (this.hostElement.nativeElement.contains(relatedTarget)) {\n          return;\n        }\n\n        this.changeDetector.markForCheck();\n        this.focused = false;\n\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.onBlur.emit();\n          });\n        }\n      };\n\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n      this.keyDownHandler = this.keyDownHandler.bind(this);\n      this.clickHandler = this.clickHandler.bind(this);\n    }\n    /**\n     * Sets the value of the Switch when it is initially displayed.\n     */\n\n\n    set checked(value) {\n      this.setHostClasses(value);\n      this._checked = value;\n    }\n\n    get checked() {\n      return this._checked;\n    }\n    /**\n     * Specifies the width and height of the Switch.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$7;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Specifies the border radius of the Switch thumb.\n     *\n     * The possible values are:\n     * * `full` (default)\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n\n\n    set thumbRounded(thumbRounded) {\n      const newThumbRounded = thumbRounded ? thumbRounded : DEFAULT_THUMB_ROUNDED;\n      this.handleThumbClasses(newThumbRounded);\n      this._thumbRounded = newThumbRounded;\n    }\n\n    get thumbRounded() {\n      return this._thumbRounded;\n    }\n    /**\n     * Specifies the border radius of the Switch track.\n     *\n     * The possible values are:\n     * * `full` (default)\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `none`\n     */\n\n\n    set trackRounded(trackRounded) {\n      const newTrackRounded = trackRounded ? trackRounded : DEFAULT_TRACK_ROUNDED;\n      this.handleTrackClasses(newTrackRounded);\n      this._trackRounded = newTrackRounded;\n    }\n\n    get trackRounded() {\n      return this._trackRounded;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n\n    get ieClass() {\n      return browser && browser.msie;\n    }\n\n    get ariaDisabled() {\n      return this.disabled ? true : undefined;\n    }\n\n    get ariaReadonly() {\n      return this.readonly;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get onLabelMessage() {\n      return this.onLabel || this.localizationService.get('on');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get offLabelMessage() {\n      return this.offLabel || this.localizationService.get('off');\n    }\n\n    get isEnabled() {\n      return !this.disabled && !this.readonly;\n    }\n\n    ngOnInit() {\n      if (this.hostElement) {\n        const wrapper = this.hostElement.nativeElement;\n        this.renderer.removeAttribute(wrapper, \"tabindex\");\n      }\n\n      this.localizationChangeSubscription = this.localizationService.changes.pipe(skip(1)).subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.control = this.injector.get(NgControl, null);\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);\n    }\n\n    ngAfterViewInit() {\n      const wrapper = this.hostElement.nativeElement;\n      this.attachHostClickHandler();\n\n      if (!this.checked && !wrapper.classList.contains('k-switch-off')) {\n        this.renderer.addClass(wrapper, 'k-switch-off');\n      }\n\n      this.handleClasses(this.size, 'size');\n      this.handleTrackClasses(this.trackRounded);\n      this.handleThumbClasses(this.thumbRounded);\n    }\n\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      if (this.hostClickSubscription) {\n        this.hostClickSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Focuses the Switch.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"switch.focus()\">Focus</button>\n     *  <kendo-switch #switch></kendo-switch>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.track) {\n        return;\n      }\n\n      this.track.nativeElement.focus();\n    }\n    /**\n     * Blurs the Switch.\n     */\n\n\n    blur() {\n      if (!this.track) {\n        return;\n      }\n\n      this.track.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.checked = value === null ? false : value;\n      this.changeDetector.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    keyDownHandler(e) {\n      const keyCode = e.keyCode;\n\n      if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {\n        this.changeValue(!this.checked);\n        e.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    clickHandler() {\n      if (this.isEnabled) {\n        this.changeValue(!this.checked);\n      }\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n\n    changeValue(value) {\n      if (this.checked !== value) {\n        this.ngZone.run(() => {\n          this.checked = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const wrapper = this.hostElement.nativeElement;\n\n        if (value) {\n          this.renderer.addClass(wrapper, FOCUSED$4);\n        } else {\n          this.renderer.removeClass(wrapper, FOCUSED$4);\n        }\n\n        this.isFocused = value;\n      }\n    }\n\n    attachHostClickHandler() {\n      this.ngZone.runOutsideAngular(() => {\n        this.hostClickSubscription.add(this.renderer.listen(this.hostElement.nativeElement, 'click', this.clickHandler));\n      });\n    }\n\n    setHostClasses(value) {\n      const wrapper = this.hostElement.nativeElement;\n\n      if (value) {\n        this.renderer.removeClass(wrapper, 'k-switch-off');\n        this.renderer.addClass(wrapper, 'k-switch-on');\n      } else {\n        this.renderer.removeClass(wrapper, 'k-switch-on');\n        this.renderer.addClass(wrapper, 'k-switch-off');\n      }\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('switch', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n    handleTrackClasses(value) {\n      var _a, _b;\n\n      const elem = (_a = this.hostElement) === null || _a === void 0 ? void 0 : _a.nativeElement;\n      const track = (_b = this.track) === null || _b === void 0 ? void 0 : _b.nativeElement;\n\n      if (!elem || !track) {\n        return;\n      }\n\n      const classes = getStylingClasses('switch', 'rounded', this.trackRounded, value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n        this.renderer.removeClass(track, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n        this.renderer.addClass(track, classes.toAdd);\n      }\n    }\n\n    handleThumbClasses(value) {\n      var _a;\n\n      const thumb = (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.nativeElement;\n\n      if (!thumb) {\n        return;\n      }\n\n      const classes = getStylingClasses('switch', 'rounded', this.thumbRounded, value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(thumb, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(thumb, classes.toAdd);\n      }\n    }\n\n  }\n\n  SwitchComponent.ɵfac = function SwitchComponent_Factory(t) {\n    return new (t || SwitchComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  SwitchComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SwitchComponent,\n    selectors: [[\"kendo-switch\"]],\n    viewQuery: function SwitchComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c22, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function SwitchComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"aria-disabled\", ctx.ariaDisabled)(\"aria-readonly\", ctx.ariaReadonly);\n        i0.ɵɵclassProp(\"k-ie\", ctx.ieClass)(\"k-switch\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      onLabel: \"onLabel\",\n      offLabel: \"offLabel\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      thumbRounded: \"thumbRounded\",\n      trackRounded: \"trackRounded\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoSwitch\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.switch'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SwitchComponent)\n      /* eslint-disable-line*/\n\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => SwitchComponent)\n    }])],\n    decls: 10,\n    vars: 21,\n    consts: function () {\n      let i18n_23;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The **On** label of the Switch.\n         * @meaning kendo.switch.on\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_24 = goog.getMsg(\"ON\");\n        i18n_23 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_24;\n      } else {\n        i18n_23 = $localize`:kendo.switch.on|The **On** label of the Switch.:ON`;\n      }\n\n      let i18n_25;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The **Off** label of the Switch.\n         * @meaning kendo.switch.off\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_26 = goog.getMsg(\"OFF\");\n        i18n_25 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_26;\n      } else {\n        i18n_25 = $localize`:kendo.switch.off|The **Off** label of the Switch.:OFF`;\n      }\n\n      return [[\"kendoSwitchLocalizedMessages\", \"\", \"on\", i18n_23, \"off\", i18n_25], [\"role\", \"switch\", 1, \"k-switch-track\", 3, \"id\", \"kendoEventsOutsideAngular\"], [\"track\", \"\"], [1, \"k-switch-label-on\"], [1, \"k-switch-label-off\"], [\"tabindex\", \"-1\", 1, \"k-switch-thumb-wrap\", 3, \"kendoEventsOutsideAngular\"], [1, \"k-switch-thumb\"], [\"thumb\", \"\"]];\n    },\n    template: function SwitchComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1, 2)(3, \"span\", 3);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 4);\n        i0.ɵɵtext(6);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(7, \"span\", 5);\n        i0.ɵɵelement(8, \"span\", 6, 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"transition-duration\", ctx.initialized ? \"200ms\" : \"0ms\");\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(13, _c27, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));\n        i0.ɵɵattribute(\"aria-checked\", ctx.checked)(\"tabindex\", ctx.disabled ? undefined : ctx.tabIndex);\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.onLabelMessage);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.offLabelMessage);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"transition-duration\", ctx.initialized ? \"200ms\" : \"0ms\");\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(17, _c27, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));\n      }\n    },\n    directives: [LocalizedSwitchMessagesDirective, i3.EventsOutsideAngularDirective],\n    encapsulation: 2\n  });\n  return SwitchComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.\n * Used to style the textbox of any `input` element.\n *\n * @example\n * ```ts-no-run\n * <input kendoTextBox />\n * <input kendoTextBox type=\"email\" />\n * <input kendoTextBox type=\"password\" />\n * ```\n */\n\n\nlet TextBoxDirective = /*#__PURE__*/(() => {\n  class TextBoxDirective {\n    constructor(renderer, inputElement, ngZone) {\n      this.renderer = renderer;\n      this.inputElement = inputElement;\n      this.ngZone = ngZone;\n      this.hostClasses = true;\n      /**\n       * @hidden\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.onValueChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.autoFillStart = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.autoFillEnd = new EventEmitter();\n      this.listeners = [];\n    }\n    /**\n     * @hidden\n     */\n\n\n    set value(text) {\n      if (!this.inputElement) {\n        return;\n      }\n\n      this.inputElement.nativeElement.value = text === undefined || text === null ? '' : text;\n      this.onValueChange.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get value() {\n      return this.inputElement.nativeElement.value;\n    }\n\n    get id() {\n      return this.inputElement.nativeElement.id;\n    }\n\n    set id(id) {\n      this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);\n    }\n\n    ngAfterViewInit() {\n      const input = this.inputElement.nativeElement;\n      this.listeners = [this.renderer.listen(input, 'focus', () => this.onFocus.emit()), this.renderer.listen(input, 'blur', () => this.onBlur.emit())];\n      this.ngZone.runOutsideAngular(() => {\n        this.renderer.listen(input, 'animationstart', e => {\n          if (e.animationName === 'autoFillStart') {\n            this.autoFillStart.emit();\n          } else if (e.animationName === 'autoFillEnd') {\n            this.autoFillEnd.emit();\n          }\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      this.listeners.forEach(listener => listener());\n    }\n\n  }\n\n  TextBoxDirective.ɵfac = function TextBoxDirective_Factory(t) {\n    return new (t || TextBoxDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  TextBoxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextBoxDirective,\n    selectors: [[\"input\", \"kendoTextBox\", \"\"]],\n    hostVars: 10,\n    hostBindings: function TextBoxDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-textbox\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-input-md\", ctx.hostClasses)(\"k-rounded-md\", ctx.hostClasses)(\"k-input-solid\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      value: \"value\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: KendoInput,\n      useExisting: forwardRef(() => TextBoxDirective)\n    }])]\n  });\n  return TextBoxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).\n * Provides floating labels to `textarea` elements.\n *\n * @example\n * ```ts-no-run\n * <textarea kendoTextArea></textarea>\n * ```\n */\n\n\nlet TextAreaDirective = /*#__PURE__*/(() => {\n  class TextAreaDirective {\n    constructor(renderer, element, zone, changeDetector, injector, rtl) {\n      this.renderer = renderer;\n      this.element = element;\n      this.zone = zone;\n      this.changeDetector = changeDetector;\n      this.injector = injector;\n      this.elementClasses = true;\n      this.autofillClass = true;\n      /**\n       * Fires each time the textarea value is changed.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Specifies if the `textarea` element will resize its height automatically\n       * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).\n       *\n       * @default false\n       */\n\n      this.autoSize = false;\n      /**\n       * @hidden\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.onValueChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.autoFillStart = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.autoFillEnd = new EventEmitter();\n      this.listeners = [];\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n\n      this.direction = rtl ? 'rtl' : 'ltr';\n    }\n\n    get id() {\n      return this.element.nativeElement.id;\n    }\n\n    set id(id) {\n      this.renderer.setAttribute(this.element.nativeElement, 'id', id);\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.elementValue = value;\n      this.resize();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.setElementProperty('disabled', isDisabled);\n    }\n\n    ngOnInit() {\n      const element = this.element.nativeElement;\n      this.zone.runOutsideAngular(() => {\n        this.listeners = [this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'animationstart', e => {\n          if (e.animationName === 'autoFillStart') {\n            this.autoFillStart.emit();\n          } else if (e.animationName === 'autoFillEnd') {\n            this.autoFillEnd.emit();\n          }\n        })];\n\n        if (isDocumentAvailable() && this.autoSize) {\n          this.resizeSubscription = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(() => this.resize());\n        }\n\n        this.inputSubscription = fromEvent(element, 'input').subscribe(this.handleInput.bind(this));\n      });\n      this.control = this.injector.get(NgControl, null);\n    }\n\n    ngOnChanges(changes) {\n      const element = this.element.nativeElement;\n\n      if (changes.value) {\n        this.elementValue = this.value;\n      }\n\n      if (changes.autoSize) {\n        if (this.autoSize) {\n          this.initialHeight = element.offsetHeight;\n          this.renderer.setStyle(element, 'resize', 'none');\n        } else {\n          this.renderer.setStyle(element, 'overflow-y', 'auto');\n          this.renderer.setStyle(element, 'resize', 'both');\n          element.style.height = `${this.initialHeight}px`;\n        }\n      }\n\n      this.zone.onStable.pipe(take(1)).subscribe(() => this.resize());\n    }\n\n    ngOnDestroy() {\n      this.listeners.forEach(listener => listener());\n\n      if (this.inputSubscription) {\n        this.inputSubscription.unsubscribe();\n      }\n\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n\n    get elementValue() {\n      if (this.element) {\n        return this.element.nativeElement.value;\n      }\n\n      return '';\n    }\n\n    set elementValue(value) {\n      this.setElementProperty('value', value === undefined || value === null ? '' : value);\n    }\n\n    setElementProperty(name, value) {\n      if (this.element) {\n        this.renderer.setProperty(this.element.nativeElement, name, value);\n      }\n    }\n\n    resize() {\n      if (!this.autoSize) {\n        return;\n      }\n\n      const element = this.element.nativeElement;\n      this.renderer.setStyle(element, 'overflow-y', 'hidden');\n      element.style.height = `${this.initialHeight}px`;\n      const scrollHeight = element.scrollHeight;\n\n      if (scrollHeight > this.initialHeight) {\n        element.style.height = `${scrollHeight}px`;\n      }\n    }\n\n    handleInput() {\n      const value = this.elementValue;\n      this.value = value;\n\n      if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {\n        this.zone.run(() => {\n          this.ngChange(value);\n          this.onValueChange.emit(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n\n      this.resize();\n    }\n\n    handleFocus() {\n      if (hasObservers(this.onFocus)) {\n        this.zone.run(() => {\n          this.onFocus.emit();\n        });\n      }\n    }\n\n    handleBlur() {\n      if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n        this.zone.run(() => {\n          this.ngTouched();\n          this.onBlur.emit();\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n\n  }\n\n  TextAreaDirective.ɵfac = function TextAreaDirective_Factory(t) {\n    return new (t || TextAreaDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(RTL, 8));\n  };\n\n  TextAreaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextAreaDirective,\n    selectors: [[\"textarea\", \"kendoTextArea\", \"\"]],\n    hostVars: 13,\n    hostBindings: function TextAreaDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-textarea\", ctx.elementClasses)(\"k-input\", ctx.elementClasses)(\"k-input-md\", ctx.elementClasses)(\"k-rounded-md\", ctx.elementClasses)(\"k-input-solid\", ctx.elementClasses)(\"k-autofill\", ctx.autofillClass);\n      }\n    },\n    inputs: {\n      autoSize: \"autoSize\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TextAreaDirective),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => TextAreaDirective)\n    }]), i0.ɵɵNgOnChangesFeature]\n  });\n  return TextAreaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst createMaxValidator = maxValue => {\n  return c => {\n    if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {\n      return null;\n    }\n\n    return {\n      maxError: {\n        maxValue: maxValue,\n        value: c.value\n      }\n    };\n  };\n};\n/**\n * @hidden\n */\n\n\nconst createMinValidator = minValue => {\n  return c => {\n    if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {\n      return null;\n    }\n\n    return {\n      minError: {\n        minValue: minValue,\n        value: c.value\n      }\n    };\n  };\n};\n/**\n * @hidden\n */\n\n\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';\n/**\n * @hidden\n */\n\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';\n/**\n * @hidden\n */\n\nconst POINT = \".\";\n/**\n * @hidden\n */\n\nconst INITIAL_SPIN_DELAY = 500;\n/**\n * @hidden\n */\n\nconst SPIN_DELAY = 50;\n/**\n * @hidden\n */\n\nconst EXPONENT_REGEX = /[eE][\\-+]?([0-9]+)/;\n/**\n * @hidden\n */\n\nconst numericRegex = options => {\n  const {\n    autoCorrect,\n    decimals,\n    min\n  } = options;\n  let separator = options.separator;\n\n  if (separator === POINT) {\n    separator = '\\\\' + separator;\n  }\n\n  const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';\n  let numberPattern;\n\n  if (decimals === 0) {\n    numberPattern = '\\\\d*';\n  } else {\n    numberPattern = `(?:(?:\\\\d+(${separator}\\\\d*)?)|(?:${separator}\\\\d*))?`;\n  }\n\n  return new RegExp(`^${signPattern}${numberPattern}$`);\n};\n/**\n * @hidden\n */\n\n\nconst decimalPart = value => {\n  return value >= 0 ? Math.floor(value) : Math.ceil(value);\n};\n/**\n * @hidden\n */\n\n\nconst noop = _ => {}; // eslint-disable-line no-empty\n\n/**\n * @hidden\n */\n\n\nconst defined = value => {\n  return typeof value !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nconst isNumber = value => {\n  return !isNaN(value) && value !== null;\n};\n/**\n * @hidden\n */\n\n\nfunction pad(value, digits) {\n  const count = digits - String(value).length;\n  let result = value;\n\n  if (count > 0) {\n    const padString = new Array(count + 1).join(\"0\");\n    result = parseFloat(value + padString);\n  }\n\n  return result;\n}\n/**\n * @hidden\n */\n\n\nconst getDeltaFromMouseWheel = e => {\n  let delta = 0;\n\n  if (e.wheelDelta) {\n    delta = e.wheelDelta / 120;\n    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n  } else if (e.detail) {\n    delta = Math.round(-e.detail / 3);\n  }\n\n  return delta;\n};\n/**\n * @hidden\n */\n\n\nconst getCaretPosition = element => element.selectionStart;\n/**\n * @hidden\n */\n\n\nconst extractSignificantNumericChars = (formattedString, separator) => {\n  const significantCharacters = `${separator}0123456789-`;\n  return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);\n};\n/**\n * @hidden\n */\n\n\nconst isRightClick = event => {\n  const isRightClickIE = event.button && event.button === 2;\n  const isRightClickOther = event.which && event.which === 3;\n  return isRightClickIE || isRightClickOther;\n};\n/**\n * @hidden\n */\n\n\nvar ArrowDirection = /*#__PURE__*/(() => {\n  (function (ArrowDirection) {\n    ArrowDirection[ArrowDirection[\"Down\"] = -1] = \"Down\";\n    ArrowDirection[ArrowDirection[\"None\"] = 0] = \"None\";\n    ArrowDirection[ArrowDirection[\"Up\"] = 1] = \"Up\";\n  })(ArrowDirection || (ArrowDirection = {}));\n\n  return ArrowDirection;\n})();\n\n/**\n * @hidden\n */\nlet NumericTextBoxMessages = /*#__PURE__*/(() => {\n  class NumericTextBoxMessages extends ComponentMessages {}\n\n  NumericTextBoxMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵNumericTextBoxMessages_BaseFactory;\n    return function NumericTextBoxMessages_Factory(t) {\n      return (ɵNumericTextBoxMessages_BaseFactory || (ɵNumericTextBoxMessages_BaseFactory = i0.ɵɵgetInheritedFactory(NumericTextBoxMessages)))(t || NumericTextBoxMessages);\n    };\n  }();\n\n  NumericTextBoxMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NumericTextBoxMessages,\n    selectors: [[\"kendo-numerictextbox-messages-base\"]],\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return NumericTextBoxMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedNumericTextBoxMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedNumericTextBoxMessagesDirective.ɵfac = function LocalizedNumericTextBoxMessagesDirective_Factory(t) {\n    return new (t || LocalizedNumericTextBoxMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedNumericTextBoxMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedNumericTextBoxMessagesDirective,\n    selectors: [[\"\", \"kendoNumericTextBoxLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NumericTextBoxMessages,\n      useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedNumericTextBoxMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];\nconst PARSABLE_DEFAULTS = {\n  decimals: null,\n  max: null,\n  min: null,\n  step: 1\n};\nconst FOCUSED$3 = 'k-focus';\nconst DEFAULT_SIZE$6 = 'medium';\nconst DEFAULT_ROUNDED$5 = 'medium';\nconst DEFAULT_FILL_MODE$4 = 'solid';\n/**\n * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).\n */\n\nlet NumericTextBoxComponent = /*#__PURE__*/(() => {\n  class NumericTextBoxComponent {\n    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {\n      this.intl = intl;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.injector = injector;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.hostElement = hostElement;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the title of the `input` element of the NumericTextBox.\n       */\n\n      this.title = '';\n      /**\n       * Specifies whether the value will be auto-corrected based on the minimum and maximum values\n       * ([see example]({% slug precision_numerictextbox %})).\n       */\n\n      this.autoCorrect = false;\n      /**\n       * Specifies the number of decimals that the user can enter when the input is focused\n       * ([see example]({% slug precision_numerictextbox %})).\n       */\n\n      this.decimals = null;\n      /**\n       * Specifies the value that is used to increment or decrement the component value\n       * ([see example]({% slug predefinedsteps_numerictextbox %})).\n       */\n\n      this.step = 1;\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered\n       * ([see example]({% slug spinbuttons_numerictextbox %})).\n       */\n\n      this.spinners = true;\n      /**\n       * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.\n       *\n       * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`\n       * to `false`, the built-in Angular validators will be executed.\n       */\n\n      this.rangeValidation = true;\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Determines whether the value of the NumericTextBox will be changed via scrolling. Defaults to `true`.\n       *\n       * @default true\n       */\n\n      this.changeValueOnScroll = true;\n      /**\n       * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.\n       */\n\n      this.selectOnFocus = true;\n      /**\n       * Specifies the value of the NumericTextBox\n       * ([see example]({% slug formats_numerictextbox %})).\n       */\n\n      this.value = null;\n      /**\n       * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.ArrowDirection = ArrowDirection;\n      /**\n       * @hidden\n       */\n\n      this.arrowDirection = ArrowDirection.None;\n      this.hostClasses = true;\n      this.inputValue = '';\n      this.minValidateFn = noop;\n      this.maxValidateFn = noop;\n      this._format = \"n2\";\n      this.isPasted = false;\n      this.mouseDown = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      this.ngChange = noop;\n      this.ngTouched = noop;\n      this.ngValidatorChange = noop;\n      this.domEvents = [];\n      /**\n       * @hidden\n       */\n\n      this.increasePress = e => {\n        this.arrowPress(ArrowDirection.Up, e);\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.decreasePress = e => {\n        this.arrowPress(ArrowDirection.Down, e);\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.releaseArrow = () => {\n        clearTimeout(this.spinTimeout);\n\n        if (this.arrowDirection !== ArrowDirection.None) {\n          this.arrowDirection = ArrowDirection.None;\n          this.changeDetector.detectChanges();\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handlePaste = () => {\n        this.isPasted = true;\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleInput = () => {\n        const input = this.numericInput.nativeElement;\n        let {\n          selectionStart,\n          selectionEnd,\n          value: inputValue\n        } = input;\n\n        if (this.pressedKey === Keys.NumpadDecimal) {\n          inputValue = this.replaceNumpadDotValue();\n        }\n\n        if (this.isPasted) {\n          inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));\n        }\n\n        if (!this.isValid(inputValue)) {\n          input.value = this.inputValue;\n          this.setSelection(selectionStart - 1, selectionEnd - 1);\n          return;\n        }\n\n        const parsedValue = this.intl.parseNumber(inputValue);\n        let value = this.restrictDecimals(parsedValue);\n\n        if (this.autoCorrect) {\n          const limited = this.limitInputValue(value);\n          value = limited.value;\n          selectionStart = limited.selectionStart;\n          selectionEnd = limited.selectionEnd;\n        }\n\n        if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {\n          this.setInputValue(value);\n          this.setSelection(selectionStart, selectionEnd);\n        } else {\n          this.inputValue = inputValue;\n        }\n\n        if (this.isPasted) {\n          input.value = this.inputValue;\n        }\n\n        this.updateValue(value);\n        this.previousSelection = null;\n        this.isPasted = false;\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleDragEnter = () => {\n        if (!this.focused && !this.isDisabled) {\n          this.setInputValue(this.value, true);\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleMouseDown = () => {\n        this.mouseDown = true;\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleFocus = () => {\n        if (!this.focused) {\n          this.focused = true;\n\n          if (!this.isDisabled) {\n            const shouldSelectAll = this.selectOnFocus || !this.mouseDown;\n            this.ngZone.runOutsideAngular(() => {\n              setTimeout(() => {\n                if (shouldSelectAll) {\n                  this.selectAll();\n                } else {\n                  this.selectCaret();\n                }\n              }, 0);\n            });\n          }\n        }\n\n        this.mouseDown = false;\n\n        if (hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleBlur = () => {\n        this.changeDetector.markForCheck();\n        this.focused = false; //blur is thrown before input when dragging the input text in IE\n\n        if (this.inputValue !== this.elementValue) {\n          this.handleInput();\n        }\n\n        this.setInputValue();\n\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.onBlur.emit();\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleKeyDown = e => {\n        if (this.isDisabled) {\n          return;\n        }\n\n        let step;\n\n        if (e.keyCode === Keys.ArrowDown) {\n          step = -1;\n        } else if (e.keyCode === Keys.ArrowUp) {\n          step = 1;\n        }\n\n        if (step && this.step) {\n          e.preventDefault();\n          this.addStep(step);\n        }\n\n        const input = this.numericInput.nativeElement;\n        this.previousSelection = {\n          end: input.selectionEnd,\n          start: input.selectionStart\n        };\n        this.pressedKey = e.keyCode;\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleWheel = e => {\n        if (this.focused && !this.isDisabled && this.changeValueOnScroll) {\n          e.preventDefault();\n          const delta = getDeltaFromMouseWheel(e);\n          this.addStep(delta);\n        }\n      };\n\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Specifies the number format which is used when the NumericTextBox is not focused\n     * ([see example]({% slug formats_numerictextbox %})).\n     * If `format` is set to `null` or `undefined`, the default format will be used.\n     */\n\n\n    get format() {\n      const format = this._format;\n      return format !== null && format !== undefined ? format : 'n2';\n    }\n\n    set format(value) {\n      this._format = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * The size property specifies padding of the NumericTextBox internal input element\n     * ([see example]({% slug appearance_numerictextbox %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$6;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the NumericTextBox\n     * ([see example]({% slug appearance_numerictextbox %}#toc-rounded)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the NumericTextBox\n     * ([see example]({% slug appearance_numerictextbox %}#toc-fillMode)).\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    get disableClass() {\n      return this.disabled;\n    }\n\n    ngOnInit() {\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n\n      this.control = this.injector.get(NgControl, null);\n      this.ngZone.runOutsideAngular(() => {\n        this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'mousewheel', this.handleWheel.bind(this)));\n        this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, 'DOMMouseScroll', this.handleWheel.bind(this)));\n      });\n    }\n\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (anyChanged(PARSABLE_OPTIONS, changes, false)) {\n        this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));\n      }\n\n      this.verifySettings();\n\n      if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {\n        this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;\n        this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;\n        this.ngValidatorChange();\n      }\n\n      if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {\n        delete this.numericRegex;\n      }\n\n      if (anyChanged(['value', 'format'], changes, false)) {\n        this.verifyValue(this.value);\n        this.value = this.restrictModelValue(this.value);\n\n        if (!this.focused || this.intl.parseNumber(this.elementValue) !== this.value) {\n          this.setInputValue();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n\n      clearTimeout(this.spinTimeout);\n      this.domEvents.forEach(unbindHandler => unbindHandler());\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.ngValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.verifyValue(value);\n      let restrictedValue = this.restrictModelValue(value);\n      this.value = restrictedValue;\n      this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * Focuses the NumericTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"numerictextbox.focus()\">Focus NumericTextBox</button>\n     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      invokeElementMethod(this.numericInput, 'focus');\n    }\n    /**\n     * Blurs the NumericTextBox.\n     */\n\n\n    blur() {\n      invokeElementMethod(this.numericInput, 'blur');\n    }\n    /**\n     * Notifies the `NumericTextBoxComponent` that the input value should be changed.\n     * Can be used to update the input after setting the component properties directly.\n     */\n\n\n    notifyValueChange() {\n      this.setInputValue();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get incrementTitle() {\n      return this.localizationService.get('increment');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get decrementTitle() {\n      return this.localizationService.get('decrement');\n    }\n\n    get decimalSeparator() {\n      const numberSymbols = this.intl.numberSymbols();\n      return numberSymbols.decimal;\n    }\n\n    get elementValue() {\n      return this.numericInput.nativeElement.value;\n    }\n\n    set elementValue(value) {\n      this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);\n    }\n\n    get focused() {\n      return this.isFocused;\n    }\n\n    get hasDecimals() {\n      return this.decimals !== null && this.decimals >= 0;\n    }\n\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const wrap = this.hostElement.nativeElement;\n\n        if (value) {\n          this.renderer.addClass(wrap, FOCUSED$3);\n        } else {\n          this.renderer.removeClass(wrap, FOCUSED$3);\n        }\n\n        this.isFocused = value;\n      }\n    }\n\n    get isDisabled() {\n      return this.disabled || this.readonly;\n    }\n\n    arrowPress(direction, e) {\n      e.preventDefault();\n\n      if (this.isDisabled || isRightClick(e)) {\n        return;\n      }\n\n      if (!mobileOS) {\n        this.focused = true;\n        this.focus();\n      }\n\n      if (this.arrowDirection !== direction) {\n        this.arrowDirection = direction;\n        this.changeDetector.detectChanges();\n      }\n\n      if (this.step) {\n        this.spin(direction, INITIAL_SPIN_DELAY);\n      } else {\n        this.setInputValue();\n      }\n    }\n\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n\n    replaceNumpadDotValue() {\n      let value = this.inputValue || \"\";\n\n      if (this.previousSelection) {\n        const input = this.numericInput.nativeElement;\n        const {\n          selectionStart,\n          selectionEnd\n        } = input;\n        const {\n          start,\n          end\n        } = this.previousSelection;\n        input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);\n        this.setSelection(selectionStart, selectionEnd);\n      }\n\n      return value;\n    }\n\n    isValid(value) {\n      if (!this.numericRegex) {\n        this.numericRegex = numericRegex({\n          autoCorrect: this.autoCorrect,\n          decimals: this.decimals,\n          min: this.min,\n          separator: this.decimalSeparator\n        });\n      }\n\n      return this.numericRegex.test(value);\n    }\n\n    spin(step, timeout) {\n      clearTimeout(this.spinTimeout);\n      this.spinTimeout = window.setTimeout(() => {\n        this.spin(step, SPIN_DELAY);\n      }, timeout);\n      this.addStep(step);\n    }\n\n    addStep(step) {\n      let value = add(this.value || 0, this.step * step);\n      value = this.limitValue(value);\n      value = this.restrictDecimals(value);\n      this.setInputValue(value);\n      this.updateValue(value);\n    }\n\n    setSelection(start, end) {\n      if (this.focused) {\n        invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);\n      }\n    }\n\n    limitValue(value) {\n      let result = value;\n\n      if (!this.isInRange(value)) {\n        if (isNumber(this.max) && value > this.max) {\n          result = this.max;\n        }\n\n        if (isNumber(this.min) && value < this.min) {\n          result = this.min;\n        }\n      }\n\n      return result;\n    }\n\n    limitInputValue(value) {\n      let {\n        selectionStart,\n        selectionEnd,\n        value: enteredValue\n      } = this.numericInput.nativeElement;\n      let limitedValue = value;\n      let selectToEnd = false;\n\n      if (!this.isInRange(value)) {\n        const lengthChange = enteredValue.length - String(this.inputValue).length;\n        const {\n          min,\n          max\n        } = this;\n        const hasMax = isNumber(max);\n        const hasMin = isNumber(min);\n        let padLimit, replaceNext;\n        let correctedValue = value;\n\n        if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {\n          return {\n            selectionEnd: selectionEnd,\n            selectionStart: selectionStart,\n            value: null\n          };\n        }\n\n        if (hasMax && value > max) {\n          if (value > 0) {\n            replaceNext = true;\n          } else {\n            padLimit = max;\n          }\n        } else if (hasMin && value < min) {\n          if (value > 0) {\n            padLimit = min;\n          } else {\n            replaceNext = true;\n          }\n        }\n\n        if (padLimit) {\n          const paddedValue = this.tryPadValue(value, padLimit);\n\n          if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {\n            correctedValue = paddedValue;\n            selectToEnd = true;\n          }\n        } else if (replaceNext) {\n          if (this.inputValue && selectionStart !== enteredValue.length) {\n            correctedValue = parseFloat(enteredValue.substr(0, selectionStart) + enteredValue.substr(selectionStart + lengthChange));\n          }\n        }\n\n        limitedValue = this.limitValue(correctedValue);\n        selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection && this.previousSelection.end - this.previousSelection.start + lengthChange > 0;\n      }\n\n      return {\n        selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,\n        selectionStart: selectionStart,\n        value: limitedValue\n      };\n    }\n\n    tryPadValue(value, limit) {\n      const limitLength = String(Math.floor(limit)).length;\n      const zeroPadded = pad(value, limitLength);\n      const zeroPaddedNext = pad(value, limitLength + 1);\n      let result;\n\n      if (this.isInRange(zeroPadded)) {\n        result = zeroPadded;\n      } else if (this.isInRange(zeroPaddedNext)) {\n        result = zeroPaddedNext;\n      }\n\n      return result;\n    }\n\n    isInRange(value) {\n      return !isNumber(value) || (!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max);\n    }\n\n    restrictModelValue(value) {\n      let result = this.restrictDecimals(value, true);\n\n      if (this.autoCorrect && this.limitValue(result) !== result) {\n        result = null;\n      }\n\n      return result;\n    }\n\n    restrictDecimals(value, round) {\n      let result = value;\n\n      if (value && this.hasDecimals) {\n        const decimals = this.decimals;\n        const stringValue = String(value);\n\n        if (round || EXPONENT_REGEX.test(stringValue)) {\n          result = toFixedPrecision(value, decimals);\n        } else {\n          const parts = stringValue.split(POINT);\n          let fraction = parts[1];\n\n          if (fraction && fraction.length > decimals) {\n            fraction = fraction.substr(0, decimals);\n            result = parseFloat(`${parts[0]}${POINT}${fraction}`);\n          }\n        }\n      }\n\n      return result;\n    }\n\n    formatInputValue(value) {\n      let stringValue = Object.is(value, -0) ? '-0' : String(value);\n      const exponentMatch = EXPONENT_REGEX.exec(stringValue);\n\n      if (exponentMatch) {\n        stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));\n      }\n\n      return stringValue.replace(POINT, this.decimalSeparator);\n    }\n\n    formatValue(value, focused) {\n      let formattedValue;\n\n      if (value === null || !defined(value) || value === '') {\n        formattedValue = '';\n      } else if (focused && !this.readonly) {\n        formattedValue = this.formatInputValue(value);\n      } else {\n        formattedValue = this.intl.formatNumber(value, this.format);\n      }\n\n      return formattedValue;\n    }\n\n    setInputValue(value = this.value, focused = this.focused) {\n      const formattedValue = this.formatValue(value, focused);\n      this.elementValue = formattedValue;\n      this.inputValue = formattedValue;\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.min !== null && this.max !== null && this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n      }\n    }\n\n    verifyValue(value) {\n      if (isDevMode() && value && typeof value !== 'number') {\n        throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);\n      }\n    }\n\n    parseOptions(options) {\n      for (let idx = 0; idx < options.length; idx++) {\n        const name = options[idx];\n        const value = this[name];\n\n        if (typeof value === 'string') {\n          const parsed = parseFloat(value);\n          const valid = !isNaN(parsed);\n\n          if (isDevMode() && !valid && value !== '') {\n            throw new Error('The NumericTextBox component requires value of type Number or a String representing ' + `a number for the ${name} property and ${JSON.stringify(value)} was set.`);\n          }\n\n          this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];\n        }\n      }\n    }\n\n    intlChange() {\n      delete this.numericRegex;\n\n      if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {\n        this.setInputValue();\n      }\n    }\n\n    hasTrailingZeros(inputValue) {\n      if (this.hasDecimals && this.focused) {\n        const fraction = inputValue.split(this.decimalSeparator)[1];\n        return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;\n      }\n    }\n\n    selectAll() {\n      this.setInputValue();\n      this.setSelection(0, this.inputValue.length);\n    }\n\n    selectCaret() {\n      const caretPosition = getCaretPosition(this.numericInput.nativeElement);\n      const formattedValue = this.elementValue;\n      const partialValue = formattedValue.substring(0, caretPosition);\n      this.setInputValue();\n\n      if (partialValue.length) {\n        const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);\n        const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);\n        this.setSelection(adjustedSignificantChars, adjustedSignificantChars);\n      } else {\n        this.setSelection(0, 0);\n      }\n    }\n\n    numberOfLeadingZeroes(formattedValue) {\n      const separatorIndex = formattedValue.indexOf(this.decimalSeparator);\n      const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);\n\n      if (matchedLeadingZeroes) {\n        const lengthOfMatch = matchedLeadingZeroes[0].length;\n        const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;\n        return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;\n      }\n\n      return 0;\n    }\n\n    adjustSignificantChars(formattedValue, significantChars) {\n      const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);\n\n      if (leadingZeroes > 0) {\n        return Math.max(0, significantChars - leadingZeroes);\n      }\n\n      return significantChars;\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n  }\n\n  NumericTextBoxComponent.ɵfac = function NumericTextBoxComponent_Factory(t) {\n    return new (t || NumericTextBoxComponent)(i0.ɵɵdirectiveInject(i1$2.IntlService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  NumericTextBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NumericTextBoxComponent,\n    selectors: [[\"kendo-numerictextbox\"]],\n    viewQuery: function NumericTextBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c28, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disableClass)(\"k-input\", ctx.hostClasses)(\"k-numerictextbox\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      title: \"title\",\n      autoCorrect: \"autoCorrect\",\n      format: \"format\",\n      max: \"max\",\n      min: \"min\",\n      decimals: \"decimals\",\n      placeholder: \"placeholder\",\n      step: \"step\",\n      spinners: \"spinners\",\n      rangeValidation: \"rangeValidation\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      changeValueOnScroll: \"changeValueOnScroll\",\n      selectOnFocus: \"selectOnFocus\",\n      value: \"value\",\n      maxlength: \"maxlength\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoNumericTextBox\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.numerictextbox'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => NumericTextBoxComponent),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => NumericTextBoxComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => NumericTextBoxComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 20,\n    consts: function () {\n      let i18n_29;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Increment** button in the NumericTextBox\n         * @meaning kendo.numerictextbox.increment\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_30 = goog.getMsg(\"Increase value\");\n        i18n_29 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_30;\n      } else {\n        i18n_29 = $localize`:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox:Increase value`;\n      }\n\n      let i18n_31;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Decrement** button in the NumericTextBox\n         * @meaning kendo.numerictextbox.decrement\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_32 = goog.getMsg(\"Decrease value\");\n        i18n_31 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_32;\n      } else {\n        i18n_31 = $localize`:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox:Decrease value`;\n      }\n\n      return [[\"kendoNumericTextBoxLocalizedMessages\", \"\", \"increment\", i18n_29, \"decrement\", i18n_31], [\"role\", \"spinbutton\", \"autocomplete\", \"off\", \"autocorrect\", \"off\", 1, \"k-input-inner\", 3, \"id\", \"tabindex\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"numericInput\", \"\"], [\"class\", \"k-input-spinner k-spin-button\", 3, \"kendoEventsOutsideAngular\", 4, \"ngIf\"], [1, \"k-input-spinner\", \"k-spin-button\", 3, \"kendoEventsOutsideAngular\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-spinner-increase\", \"k-button\", \"k-icon-button\", \"k-button-solid\", \"k-button-solid-base\", 3, \"kendoEventsOutsideAngular\", \"title\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrow-n\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-spinner-decrease\", \"k-button\", \"k-icon-button\", \"k-button-solid\", \"k-button-solid-base\", 3, \"kendoEventsOutsideAngular\", \"title\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrow-s\"]];\n    },\n    template: function NumericTextBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelement(1, \"input\", 1, 2);\n        i0.ɵɵtemplate(3, NumericTextBoxComponent_span_3_Template, 5, 20, \"span\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction7(12, _c35, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleFocus, ctx.handleBlur, ctx.handlePaste));\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value)(\"title\", ctx.title)(\"placeholder\", ctx.placeholder)(\"maxLength\", ctx.maxlength);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.spinners);\n      }\n    },\n    directives: [LocalizedNumericTextBoxMessagesDirective, i3.EventsOutsideAngularDirective, i1$1.NgIf],\n    encapsulation: 2\n  });\n  return NumericTextBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet NumericTextBoxCustomMessagesComponent = /*#__PURE__*/(() => {\n  class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  NumericTextBoxCustomMessagesComponent.ɵfac = function NumericTextBoxCustomMessagesComponent_Factory(t) {\n    return new (t || NumericTextBoxCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  NumericTextBoxCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NumericTextBoxCustomMessagesComponent,\n    selectors: [[\"kendo-numerictextbox-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NumericTextBoxMessages,\n      useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return NumericTextBoxCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar ResultType = /*#__PURE__*/(() => {\n  (function (ResultType) {\n    ResultType[ResultType[\"Literal\"] = 0] = \"Literal\";\n    ResultType[ResultType[\"Mask\"] = 1] = \"Mask\"; // eslint-disable-next-line id-denylist\n\n    ResultType[ResultType[\"Undefined\"] = 2] = \"Undefined\";\n  })(ResultType || (ResultType = {}));\n\n  return ResultType;\n})();\n\n/**\n * @hidden\n */\nclass Result {\n  constructor(value, rest, type = ResultType.Undefined) {\n    this.value = value;\n    this.rest = rest;\n    this.type = type;\n  } //map :: Functor f => f a ~> (a -> b) -> f b\n\n\n  map(fn) {\n    return new Result(fn(this.value), this.rest);\n  } //chain :: Chain m => m a ~> (a -> m b) -> m b\n\n\n  chain(fn) {\n    return fn(this.value, this.rest);\n  }\n\n  fold(s, _\n  /*we don't need it*/\n  ) {\n    return s(this.value, this.rest);\n  }\n\n  concat(r) {\n    return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));\n  }\n\n  toString() {\n    return `Result({ value: '${this.value}', rest: ${this.rest} })`;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass Stream {\n  constructor(input = [], control = []) {\n    this.input = input;\n    this.control = control;\n    this.inputCursor = 0;\n    this.controlCursor = 0;\n  }\n\n  eof() {\n    return this.inputCursor >= this.input.length;\n  } // Get the first value from the input.\n\n\n  next() {\n    return {\n      char: this.input[this.inputCursor++],\n      control: this.control[this.controlCursor++]\n    };\n  }\n\n  peek() {\n    return {\n      char: this.input[this.inputCursor],\n      control: this.control[this.controlCursor]\n    };\n  }\n\n  eat_input() {\n    this.inputCursor++;\n  }\n\n  eat_control() {\n    this.controlCursor++;\n  }\n\n  eat() {\n    this.inputCursor++;\n    this.controlCursor++;\n  }\n\n}\n\nconst toArray = value => (value || '').split('');\n\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\n\nclass Parser {\n  constructor(parse) {\n    this.parse = parse;\n  }\n\n  run(input, control = '') {\n    if (input instanceof Stream) {\n      return this.parse(input);\n    } else {\n      return this.parse(new Stream(toArray(input), toArray(control)));\n    }\n  } //map :: Functor f => f a ~> (a -> b) -> f b\n\n\n  map(f) {\n    return new Parser(stream => this.parse(stream).map(f));\n  } //chain :: Chain m => m a ~> (a -> m b) -> m b\n\n\n  chain(f) {\n    return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n  }\n\n  isLiteral(c) {\n    return this.run(c).type === ResultType.Literal;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst mask = ({\n  prompt,\n  promptPlaceholder\n}) => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n\n    if (char === control && control === prompt) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream, ResultType.Mask);\n    }\n\n    if (char === promptPlaceholder) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n\n    stream.eat_input();\n  }\n\n  stream.eat();\n  return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\n\n\nconst literal = _token => new Parser(stream => {\n  //    let {char, control} = stream.peek();\n  let char = stream.peek().char;\n\n  if (char === _token) {\n    stream.eat();\n    return new Result(_token, stream, ResultType.Literal);\n  } //    if (control === _token) {\n  //        while (!stream.eof() && char !== _token) {\n  //            stream.eat_input();\n  //            char = stream.peek().char;\n  //        }\n  //    }\n  //\n  //    if (control !== undefined) {\n  //        stream.eat();\n  //    }\n\n\n  return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\n\n\nconst unmask = prompt => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n\n    if (char === prompt && control === prompt) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n\n    stream.eat_input();\n  }\n\n  stream.eat();\n  return new Result('', stream);\n});\n/**\n * @hidden\n */\n\n\nconst unliteral = _token => new Parser(stream => {\n  if (stream.eof()) {\n    return new Result('', stream);\n  }\n\n  const {\n    char\n  } = stream.peek();\n\n  if (char === _token) {\n    stream.eat();\n  }\n\n  return new Result(_token, stream);\n});\n/**\n * @hidden\n */\n\n\nconst token = (rules, creator) => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n  const rule = rules[char];\n\n  if (char === ESCAPE_CHARACTER) {\n    char = stream.next().char;\n    return new Result(creator.literal(char), stream);\n  }\n\n  if (!rule) {\n    return new Result(creator.literal(char), stream);\n  }\n\n  return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\n\n\nconst rawMask = ({\n  prompt,\n  promptPlaceholder\n}) => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n\n  if (char === prompt) {\n    return new Result(promptPlaceholder, stream);\n  }\n\n  return new Result(char, stream);\n});\n/**\n * @hidden\n */\n\n\nconst rawLiteral = includeLiterals => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n\n  if (includeLiterals) {\n    return new Result(char, stream);\n  }\n\n  return new Result('', stream);\n});\n/**\n * @hidden\n */\n\n\nconst always = value => new Parser(stream => new Result(value, stream));\n/**\n * @hidden\n */\n\n\nconst append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));\n/**\n * @hidden\n */\n\n\nconst sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));\n/**\n * @hidden\n */\n\n\nconst greedy = parser => new Parser(stream => {\n  let result = new Result([], stream);\n\n  while (!stream.eof()) {\n    result = result.concat(parser.run(stream));\n  }\n\n  return result;\n});\n/**\n * @hidden\n */\n\n\nlet MaskingService = /*#__PURE__*/(() => {\n  class MaskingService {\n    constructor() {\n      this.rules = {};\n      this.prompt = \"_\";\n      this.mask = \"\";\n      this.promptPlaceholder = \" \";\n      this.includeLiterals = false;\n      this.maskTokens = [];\n      this.unmaskTokens = [];\n      this.rawTokens = [];\n      this.validationTokens = [];\n    }\n\n    update({\n      mask = '',\n      prompt = '',\n      promptPlaceholder = ' ',\n      rules = {},\n      includeLiterals = false\n    }) {\n      this.mask = mask;\n      this.prompt = prompt;\n      this.promptPlaceholder = promptPlaceholder;\n      this.rules = rules;\n      this.includeLiterals = includeLiterals;\n      this.tokenize();\n    }\n\n    validationValue(maskedValue = '') {\n      let value = maskedValue;\n      sequence(this.validationTokens).run(maskedValue).fold(unmasked => {\n        value = unmasked.join('');\n      });\n      return value;\n    }\n\n    rawValue(maskedValue = '') {\n      let value = maskedValue;\n\n      if (!this.rawTokens.length) {\n        return value;\n      }\n\n      sequence(this.rawTokens).run(maskedValue).fold(unmasked => {\n        value = unmasked.join('');\n      });\n      return value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    maskRaw(rawValue = '') {\n      let value = rawValue;\n\n      if (!this.maskTokens.length) {\n        return value;\n      }\n\n      sequence(this.maskTokens).run(rawValue).fold(masked => {\n        value = masked.join('');\n      });\n      return value;\n    }\n\n    maskInput(input, control, splitPoint) {\n      if (input.length < control.length) {\n        return this.maskRemoved(input, control, splitPoint);\n      }\n\n      return this.maskInserted(input, control, splitPoint);\n    }\n\n    maskInRange(pasted, oldValue, start, end) {\n      let value = '';\n      let selection = end;\n      const beforeChange = oldValue.split('').slice(0, start);\n      const afterChange = oldValue.split('').slice(end);\n      sequence(this.maskTokens.slice(start, end)).run(pasted).fold(masked => {\n        value = beforeChange.concat(masked).concat(afterChange).join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n\n    maskRemoved(input, control, splitPoint) {\n      let value = '';\n      let selection = splitPoint;\n      const unchanged = input.split('').slice(splitPoint);\n      const changed = input.split('').slice(0, splitPoint).join('');\n      const take = this.maskTokens.length - (input.length - splitPoint);\n      sequence(this.maskTokens.slice(0, take)).run(changed, control).fold(masked => {\n        selection = this.adjustPosition(masked, selection);\n        value = masked.concat(unchanged).join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n\n    adjustPosition(input, selection) {\n      const caretChar = input[selection];\n      const isLiteral = this.maskTokens[selection].isLiteral(caretChar);\n\n      if (!isLiteral && caretChar !== this.prompt) {\n        return selection + 1;\n      }\n\n      return selection;\n    }\n\n    maskInserted(input, control, splitPoint) {\n      let value = '';\n      let selection = splitPoint;\n      const changed = input.slice(0, splitPoint);\n      sequence(this.unmaskTokens).run(changed, control).chain(unmasked => {\n        selection = unmasked.join('').length;\n        const unchanged = control.slice(selection);\n        return sequence(this.maskTokens).run(unmasked.join('') + unchanged, control);\n      }).fold(masked => {\n        value = masked.join('');\n      });\n      return {\n        selection,\n        value\n      };\n    }\n\n    get maskTokenCreator() {\n      const {\n        prompt,\n        promptPlaceholder\n      } = this;\n      return {\n        literal: rule => literal(rule),\n        mask: rule => mask({\n          prompt,\n          promptPlaceholder\n        })(rule)\n      };\n    }\n\n    get unmaskTokenCreator() {\n      return {\n        literal: rule => unliteral(rule),\n        mask: rule => unmask(this.prompt)(rule)\n      };\n    }\n\n    get rawTokenCreator() {\n      const {\n        prompt,\n        promptPlaceholder,\n        includeLiterals\n      } = this;\n      return {\n        literal: _ => rawLiteral(includeLiterals),\n        mask: _ => rawMask({\n          prompt,\n          promptPlaceholder\n        })\n      };\n    }\n\n    get validationTokenCreator() {\n      const {\n        prompt\n      } = this;\n      return {\n        literal: _ => rawLiteral(false),\n        mask: _ => rawMask({\n          prompt,\n          promptPlaceholder: ''\n        })\n      };\n    }\n\n    tokenize() {\n      greedy(token(this.rules, this.maskTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.maskTokens = tokens;\n      });\n      greedy(token(this.rules, this.unmaskTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.unmaskTokens = tokens;\n      });\n      greedy(token(this.rules, this.rawTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.rawTokens = tokens;\n      });\n      greedy(token(this.rules, this.validationTokenCreator)).run(this.mask).fold((tokens, _) => {\n        this.validationTokens = tokens;\n      });\n    }\n\n  }\n\n  MaskingService.ɵfac = function MaskingService_Factory(t) {\n    return new (t || MaskingService)();\n  };\n\n  MaskingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MaskingService,\n    factory: MaskingService.ɵfac\n  });\n  return MaskingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst resolvedPromise = Promise.resolve(null);\nconst FOCUSED$2 = 'k-focus';\nconst DEFAULT_SIZE$5 = 'medium';\nconst DEFAULT_ROUNDED$4 = 'medium';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).\n *\n * @example\n * ```ts-no-run\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask\"\n *          [value]=\"value\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value: string = \"9580128055807792\";\n *  public mask: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\n\nlet MaskedTextBoxComponent = /*#__PURE__*/(() => {\n  class MaskedTextBoxComponent {\n    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {\n      this.service = service;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.changeDetector = changeDetector;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).\n       */\n\n      this.readonly = false;\n      /**\n       * Represents a prompt character for the masked value.\n       * @default `_`\n       */\n\n      this.prompt = '_';\n      /**\n       * Indicates a character which represents an empty position in the raw value.\n       * @default ' '\n       */\n\n      this.promptPlaceholder = ' ';\n      /**\n       * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).\n       * @default false\n       */\n\n      this.includeLiterals = false;\n      /**\n       * Specifies if the mask should be shown on focus for empty value.\n       */\n\n      this.maskOnFocus = false;\n      /**\n       * Determines whether the built-in mask validator is enforced when a form is validated\n       * ([see example]({% slug validation_maskedtextbox %})).\n       * @default true\n       */\n\n      this.maskValidation = true;\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires each time the user focuses the `input` element.\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log(\"Component is focused\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the `input` element gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log(\"Component is blurred\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the value changes.\n       */\n\n      this.valueChange = new EventEmitter();\n      this.hostClasses = true;\n      this.focusClick = false;\n      this.defaultRules = {\n        \"#\": /[\\d\\s\\+\\-]/,\n        \"&\": /[\\S]/,\n        \"0\": /[\\d]/,\n        \"9\": /[\\d\\s]/,\n        \"?\": /[a-zA-Z\\s]/,\n        \"A\": /[a-zA-Z0-9]/,\n        \"C\": /./,\n        \"L\": /[a-zA-Z]/,\n        \"a\": /[a-zA-Z0-9\\s]/\n      };\n      this.isPasted = false;\n      this.selection = [0, 0];\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      /**\n       * @hidden\n       */\n\n      this.handleFocus = () => {\n        this.focused = true;\n\n        if (this.maskOnFocus && this.emptyMask) {\n          this.updateInput(this.service.maskRaw(this.value));\n          this.ngZone.runOutsideAngular(() => {\n            setTimeout(() => {\n              this.setSelection(0, 0);\n            }, 0);\n          });\n        }\n\n        if (hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleClick = () => {\n        if (this.focused && !this.focusClick) {\n          this.focusClick = true;\n          const {\n            selectionStart,\n            selectionEnd\n          } = this.input.nativeElement;\n\n          if (selectionStart === selectionEnd) {\n            this.setFocusSelection();\n          }\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleBlur = () => {\n        this.changeDetector.markForCheck();\n        this.focused = false;\n        this.focusClick = false;\n\n        if (this.maskOnFocus && this.emptyMask) {\n          this.updateInput(this.maskedValue);\n        }\n\n        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.onTouched();\n            this.onBlur.emit();\n          });\n        }\n      };\n\n      this.onChange = _ => {};\n\n      this.onTouched = () => {};\n\n      validatePackage(packageMetadata);\n      this.direction = rtl ? 'rtl' : 'ltr';\n      this.updateService();\n    }\n    /**\n     * The size property specifies the padding of the MaskedTextBox internal input element\n     * ([see example]({% slug appearance_maskedtextbox %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$5;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the MaskedTextBox\n     * ([see example]({% slug appearance_maskedtextbox %}#toc-rounded)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the MaskedTexBox\n     * ([see example]({% slug appearance_maskedtextbox %}#toc-fillMode)).\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).\n     */\n\n\n    set rules(value) {\n      this._rules = Object.assign({}, this.defaultRules, value);\n    }\n\n    get rules() {\n      return this._rules || this.defaultRules;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n\n    get hostDisabledClass() {\n      return this.disabled;\n    }\n\n    ngOnInit() {\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n\n      this.control = this.injector.get(NgControl, null);\n    }\n\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the MaskedTextBox is empty.\n     */\n\n\n    isEmpty() {\n      if (this.input) {\n        return !Boolean(this.input.nativeElement.value);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDragDrop() {\n      return false;\n    }\n    /**\n     * Focuses the MaskedTextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.input) {\n        return;\n      }\n\n      this.input.nativeElement.focus();\n      this.setFocusSelection();\n    }\n    /**\n     * Blurs the MaskedTextBox.\n     */\n\n\n    blur() {\n      if (!this.input) {\n        return;\n      }\n\n      this.input.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    pasteHandler(e) {\n      const {\n        selectionStart,\n        selectionEnd\n      } = e.target;\n\n      if (selectionEnd === selectionStart) {\n        return;\n      }\n\n      this.isPasted = true;\n      this.selection = [selectionStart, selectionEnd];\n    }\n    /**\n     * @hidden\n     */\n\n\n    inputHandler(e) {\n      const value = e.target.value;\n      const [start, end] = this.selection;\n\n      if (!this.mask) {\n        this.updateValueWithEvents(value);\n        this.isPasted = false;\n        return;\n      }\n\n      let result;\n\n      if (this.isPasted) {\n        this.isPasted = false;\n        const rightPart = this.maskedValue.length - end;\n        const to = value.length - rightPart;\n        result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n      } else {\n        result = this.service.maskInput(value, this.maskedValue || '', e.target.selectionStart);\n      }\n\n      this.updateInput(result.value, result.selection);\n      this.updateValueWithEvents(result.value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.value) {\n        this.value = this.normalizeValue();\n      }\n\n      if (!this.mask) {\n        this.updateInput(this.value);\n        return;\n      }\n\n      const next = this.extractChanges(changes);\n      this.updateService(next);\n      const maskedValue = this.service.maskRaw(this.value);\n      this.updateInput(maskedValue, null, true);\n\n      if (changes.includeLiterals || isChanged('promptPlaceholder', changes)) {\n        resolvedPromise.then(() => {\n          this.updateValueWithEvents(this.maskedValue);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n\n\n    writeValue(value) {\n      this.value = this.normalizeValue(value);\n      this.updateInput(this.service.maskRaw(this.value));\n\n      if (this.includeLiterals) {\n        this.updateValue(this.maskedValue);\n      }\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(_) {\n      if (this.maskValidation === false || !this.mask) {\n        return null;\n      }\n\n      if (!this.service.validationValue(this.maskedValue)) {\n        return null;\n      }\n\n      if (this.maskedValue.indexOf(this.prompt) !== -1) {\n        return {\n          patternError: {\n            mask: this.mask,\n            maskedValue: this.maskedValue,\n            value: this.value\n          }\n        };\n      }\n\n      return null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    updateValueWithEvents(maskedValue) {\n      this.updateValue(maskedValue);\n\n      if (hasObservers(this.valueChange)) {\n        this.valueChange.emit(this.value);\n      }\n    }\n\n    updateValue(value) {\n      if (this.mask && !this.service.validationValue(value) && !this.includeLiterals) {\n        this.value = '';\n      } else {\n        this.value = this.service.rawValue(value);\n      }\n\n      this.onChange(this.value);\n    }\n\n    updateInput(maskedValue = '', selection, isFromOnChanges) {\n      if (isFromOnChanges && maskedValue === this.maskedValue) {\n        return;\n      }\n\n      this.maskedValue = maskedValue;\n      const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;\n      this.renderer.setProperty(this.input.nativeElement, \"value\", value);\n\n      if (selection !== undefined) {\n        this.setSelection(selection, selection);\n      }\n    }\n\n    extractChanges(changes) {\n      return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {\n        obj[key] = changes[key].currentValue;\n        return obj;\n      }, {});\n    }\n\n    updateService(extra) {\n      const config = Object.assign({\n        includeLiterals: this.includeLiterals,\n        mask: this.mask,\n        prompt: this.prompt,\n        promptPlaceholder: this.promptPlaceholder,\n        rules: this.rules\n      }, extra);\n      this.service.update(config);\n    }\n\n    setSelection(start = this.selection[0], end = this.selection[1]) {\n      if (this.focused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n\n    get emptyMask() {\n      return this.service.maskRaw() === this.maskedValue;\n    }\n\n    setFocusSelection() {\n      const selectionStart = this.input.nativeElement.selectionStart;\n      const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;\n\n      if (index >= 0 && index < selectionStart) {\n        this.selection = [index, index];\n        this.setSelection();\n      }\n    }\n\n    get focused() {\n      return this.isFocused;\n    }\n\n    set focused(value) {\n      if (this.isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n\n        if (value) {\n          this.renderer.addClass(element, FOCUSED$2);\n        } else {\n          this.renderer.removeClass(element, FOCUSED$2);\n        }\n\n        this.isFocused = value;\n      }\n    }\n\n    normalizeValue(value = this.value) {\n      const present = isPresent(value);\n\n      if (present && typeof value !== 'string') {\n        if (isDevMode()) {\n          throw new Error('The MaskedTextBox component supports only string values.');\n        }\n\n        return String(value);\n      }\n\n      return present ? value : '';\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n  }\n\n  MaskedTextBoxComponent.ɵfac = function MaskedTextBoxComponent_Factory(t) {\n    return new (t || MaskedTextBoxComponent)(i0.ɵɵdirectiveInject(MaskingService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(RTL, 8));\n  };\n\n  MaskedTextBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MaskedTextBoxComponent,\n    selectors: [[\"kendo-maskedtextbox\"]],\n    viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c36, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"paste\", function MaskedTextBoxComponent_paste_HostBindingHandler($event) {\n          return ctx.pasteHandler($event);\n        })(\"input\", function MaskedTextBoxComponent_input_HostBindingHandler($event) {\n          return ctx.inputHandler($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-input\", ctx.hostClasses)(\"k-maskedtextbox\", ctx.hostClasses)(\"k-disabled\", ctx.hostDisabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      title: \"title\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      mask: \"mask\",\n      value: \"value\",\n      rules: \"rules\",\n      prompt: \"prompt\",\n      promptPlaceholder: \"promptPlaceholder\",\n      includeLiterals: \"includeLiterals\",\n      maskOnFocus: \"maskOnFocus\",\n      maskValidation: \"maskValidation\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoMaskedTextBox\"],\n    features: [i0.ɵɵProvidersFeature([MaskingService, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MaskedTextBoxComponent)\n      /* eslint-disable-line*/\n\n    }, {\n      multi: true,\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => MaskedTextBoxComponent)\n      /* eslint-disable-line*/\n\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => MaskedTextBoxComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 12,\n    consts: [[\"type\", \"text\", \"autocomplete\", \"off\", \"autocorrect\", \"off\", \"autocapitalize\", \"off\", \"spellcheck\", \"false\", 1, \"k-input-inner\", 3, \"id\", \"tabindex\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"]],\n    template: function MaskedTextBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"input\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"tabindex\", ctx.tabIndex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction5(6, _c37, ctx.handleFocus, ctx.handleBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));\n        i0.ɵɵattribute(\"title\", ctx.title);\n      }\n    },\n    directives: [i3.EventsOutsideAngularDirective],\n    encapsulation: 2\n  });\n  return MaskedTextBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SlidersCommonModule = /*#__PURE__*/(() => {\n  class SlidersCommonModule {}\n\n  SlidersCommonModule.ɵfac = function SlidersCommonModule_Factory(t) {\n    return new (t || SlidersCommonModule)();\n  };\n\n  SlidersCommonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SlidersCommonModule\n  });\n  SlidersCommonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, DraggableModule, EventsModule, ResizeSensorModule], DraggableModule, EventsModule, ResizeSensorModule]\n  });\n  return SlidersCommonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet SliderCustomMessagesComponent = /*#__PURE__*/(() => {\n  class SliderCustomMessagesComponent extends SliderMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  SliderCustomMessagesComponent.ɵfac = function SliderCustomMessagesComponent_Factory(t) {\n    return new (t || SliderCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  SliderCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SliderCustomMessagesComponent,\n    selectors: [[\"kendo-slider-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SliderMessages,\n      useExisting: forwardRef(() => SliderCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function SliderCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SliderCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Slider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { SliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet SliderModule = /*#__PURE__*/(() => {\n  class SliderModule {}\n\n  SliderModule.ɵfac = function SliderModule_Factory(t) {\n    return new (t || SliderModule)();\n  };\n\n  SliderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SliderModule\n  });\n  SliderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, SlidersCommonModule]]\n  });\n  return SliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet RangeSliderCustomMessagesComponent = /*#__PURE__*/(() => {\n  class RangeSliderCustomMessagesComponent extends RangeSliderMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  RangeSliderCustomMessagesComponent.ɵfac = function RangeSliderCustomMessagesComponent_Factory(t) {\n    return new (t || RangeSliderCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  RangeSliderCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: RangeSliderCustomMessagesComponent,\n    selectors: [[\"kendo-rangeslider-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: RangeSliderMessages,\n      useExisting: forwardRef(() => RangeSliderCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return RangeSliderCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RangeSlider component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { RangeSliderModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet RangeSliderModule = /*#__PURE__*/(() => {\n  class RangeSliderModule {}\n\n  RangeSliderModule.ɵfac = function RangeSliderModule_Factory(t) {\n    return new (t || RangeSliderModule)();\n  };\n\n  RangeSliderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RangeSliderModule\n  });\n  RangeSliderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, SlidersCommonModule]]\n  });\n  return RangeSliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet SwitchCustomMessagesComponent = /*#__PURE__*/(() => {\n  class SwitchCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  SwitchCustomMessagesComponent.ɵfac = function SwitchCustomMessagesComponent_Factory(t) {\n    return new (t || SwitchCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  SwitchCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SwitchCustomMessagesComponent,\n    selectors: [[\"kendo-switch-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => SwitchCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function SwitchCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return SwitchCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Switch component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Switch module\n * import { SwitchModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, SwitchModule], // import Switch module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet SwitchModule = /*#__PURE__*/(() => {\n  class SwitchModule {}\n\n  SwitchModule.ɵfac = function SwitchModule_Factory(t) {\n    return new (t || SwitchModule)();\n  };\n\n  SwitchModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SwitchModule\n  });\n  SwitchModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule, ResizeSensorModule]]\n  });\n  return SwitchModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the NumericTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the NumericTextBox module\n * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet NumericTextBoxModule = /*#__PURE__*/(() => {\n  class NumericTextBoxModule {}\n\n  NumericTextBoxModule.ɵfac = function NumericTextBoxModule_Factory(t) {\n    return new (t || NumericTextBoxModule)();\n  };\n\n  NumericTextBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NumericTextBoxModule\n  });\n  NumericTextBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule]]\n  });\n  return NumericTextBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the MaskedTextBox component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MaskedTextBox module\n * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet MaskedTextBoxModule = /*#__PURE__*/(() => {\n  class MaskedTextBoxModule {}\n\n  MaskedTextBoxModule.ɵfac = function MaskedTextBoxModule_Factory(t) {\n    return new (t || MaskedTextBoxModule)();\n  };\n\n  MaskedTextBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MaskedTextBoxModule\n  });\n  MaskedTextBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule]]\n  });\n  return MaskedTextBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * Returns true if the used browser is Safari.\n */\n\n\nconst isSafari = userAgent => {\n  const desktopBrowser = detectDesktopBrowser(userAgent);\n  const mobileOS = detectMobileOS(userAgent);\n  return desktopBrowser && desktopBrowser.safari || mobileOS && mobileOS.browser === 'mobilesafari';\n};\n/**\n * @hidden\n *\n * Checks if input is Japanese IME\n */\n\n\nconst isJapanese = input => {\n  const japaneseRegex = /[\\u3000-\\u303F]|[\\u3040-\\u309F]|[\\u30A0-\\u30FF]|[\\uFF00-\\uFFEF]|[\\u4E00-\\u9FAF]|[\\u2605-\\u2606]|[\\u2190-\\u2195]|\\u203B/g;\n  return japaneseRegex.test(input);\n};\n/**\n * Specifies the adornments in the suffix container ([see examples]({% slug adornments_textbox %}#toc-suffixadornments)).\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\n\n\nlet TextBoxSuffixTemplateDirective = /*#__PURE__*/(() => {\n  class TextBoxSuffixTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  TextBoxSuffixTemplateDirective.ɵfac = function TextBoxSuffixTemplateDirective_Factory(t) {\n    return new (t || TextBoxSuffixTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  TextBoxSuffixTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextBoxSuffixTemplateDirective,\n    selectors: [[\"\", \"kendoTextBoxSuffixTemplate\", \"\"]]\n  });\n  return TextBoxSuffixTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the adornments in the prefix container ([see examples]({% slug adornments_textbox %}#toc-prefixadornments)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxPrefixTemplate>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\n\n\nlet TextBoxPrefixTemplateDirective = /*#__PURE__*/(() => {\n  class TextBoxPrefixTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  TextBoxPrefixTemplateDirective.ɵfac = function TextBoxPrefixTemplateDirective_Factory(t) {\n    return new (t || TextBoxPrefixTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  TextBoxPrefixTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextBoxPrefixTemplateDirective,\n    selectors: [[\"\", \"kendoTextBoxPrefixTemplate\", \"\"]]\n  });\n  return TextBoxPrefixTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TextBoxMessages = /*#__PURE__*/(() => {\n  class TextBoxMessages extends ComponentMessages {}\n\n  TextBoxMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵTextBoxMessages_BaseFactory;\n    return function TextBoxMessages_Factory(t) {\n      return (ɵTextBoxMessages_BaseFactory || (ɵTextBoxMessages_BaseFactory = i0.ɵɵgetInheritedFactory(TextBoxMessages)))(t || TextBoxMessages);\n    };\n  }();\n\n  TextBoxMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TextBoxMessages,\n    selectors: [[\"kendo-textbox-messages-base\"]],\n    inputs: {\n      clear: \"clear\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TextBoxMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedTextBoxMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedTextBoxMessagesDirective extends TextBoxMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedTextBoxMessagesDirective.ɵfac = function LocalizedTextBoxMessagesDirective_Factory(t) {\n    return new (t || LocalizedTextBoxMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedTextBoxMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedTextBoxMessagesDirective,\n    selectors: [[\"\", \"kendoTextBoxLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TextBoxMessages,\n      useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedTextBoxMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FOCUSED$1 = 'k-focus';\nconst DEFAULT_SIZE$4 = 'medium';\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_FILL_MODE$2 = 'solid';\nlet TextBoxComponent = /*#__PURE__*/(() => {\n  class TextBoxComponent {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Sets the `title` attribute of the `input` element of the TextBox.\n       */\n\n      this.title = '';\n      /**\n       * Sets the disabled state of the component.\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       *\n       * @default false\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the `tabindex` of the TextBox.\n       *\n       * @default 0\n       */\n\n      this.tabindex = 0;\n      /**\n       * Provides a value for the TextBox.\n       */\n\n      this.value = null;\n      /**\n       * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.\n       *\n       * @default false\n       */\n\n      this.selectOnFocus = false;\n      /**\n       * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).\n       *\n       * The possible values are:\n       *\n       * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.\n       *\n       * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.\n       *\n       * @default false\n       */\n\n      this.showSuccessIcon = false;\n      /**\n       * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).\n       *\n       * The possible values are:\n       *\n       * * `initial`&mdash;The Error icon will be displayed when the component state is\n       * `invalid` and `touched` or `dirty`.\n       * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.\n       *\n       * @default false\n       */\n\n      this.showErrorIcon = false;\n      /**\n       * Specifies whether a Clear button will be rendered.\n       *\n       * @default false\n       */\n\n      this.clearButton = false;\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example]({% slug overview_textbox %}#toc-events)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user focuses the `input` element.\n       */\n\n      this.inputFocus = new EventEmitter();\n      /**\n       * Fires each time the `input` element gets blurred.\n       */\n\n      this.inputBlur = new EventEmitter();\n      /**\n       * Fires each time the user focuses the TextBox component.\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textbox (focus)=\"handleFocus()\"></kendo-textbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log('Component is isFocused');\n       *   }\n       * }\n       * ```\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the TextBox component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts-no-run\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textbox (blur)=\"handleBlur()\"></kendo-textbox>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log('Component is blurred');\n       *   }\n       * }\n       * ```\n       */\n\n      this.onBlur = new EventEmitter();\n      this.hostClasses = true;\n      this._isFocused = false;\n      this.focusChangedProgrammatically = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      /**\n       * @hidden\n       */\n\n      this.handleInputFocus = () => {\n        if (!this.disabled) {\n          if (this.selectOnFocus && this.value) {\n            this.ngZone.run(() => {\n              setTimeout(() => {\n                this.selectAll();\n              });\n            });\n          }\n\n          if (hasObservers(this.onFocus)) {\n            if (!this.isFocused) {\n              this.ngZone.run(() => {\n                this.onFocus.emit();\n              });\n            }\n          }\n\n          if (hasObservers(this.inputFocus)) {\n            if (!this.focusChangedProgrammatically || this.focusChangedProgrammatically && this.clearButtonClicked) {\n              this.ngZone.run(() => {\n                this.inputFocus.emit();\n              });\n            }\n          }\n\n          this.ngZone.run(() => {\n            this.isFocused = true;\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleInputBlur = () => {\n        this.changeDetector.markForCheck();\n\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.inputBlur.emit();\n          });\n        }\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleInput = ev => {\n        const target = ev.target;\n        const isBrowserSafari = isSafari(navigator.userAgent);\n        const incomingValue = isBrowserSafari && isJapanese(target.value) ? ev.data : target.value;\n        const [caretStart, caretEnd] = [target.selectionStart, target.selectionEnd];\n        this.updateValue(incomingValue);\n\n        if (isBrowserSafari) {\n          target.setSelectionRange(caretStart, caretEnd);\n        }\n      };\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * The size property specifies the padding of the TextBox internal input element\n     * ([see example]({% slug appearance_textbox %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$4;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the TextBox\n     * ([see example]({% slug appearance_textbox %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the TextBox\n     * ([see example]({% slug appearance_textbox %}#toc-fillMode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$2;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n      this.checkClearButton();\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    ngAfterViewInit() {\n      const hostElement = this.hostElement.nativeElement;\n      let cursorInsideWrapper = false;\n      let tabbing = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              this.onFocus.emit();\n              this.isFocused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n\n          if (tabbing) {\n            const closestTextbox = closest(args.relatedTarget, element => element === this.hostElement.nativeElement);\n\n            if (!closestTextbox) {\n              this.handleBlur();\n            }\n\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper && !this.clearButtonClicked) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n      });\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (changes.disabled || changes.readonly || changes.value) {\n        this.checkClearButton();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * Focuses the TextBox.\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"input.focus()\">Focus the input</button>\n     *  <kendo-textbox #input></kendo-textbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.input) {\n        return;\n      }\n\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.input.nativeElement.focus();\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextBox.\n     */\n\n\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearTitle() {\n      return this.localizationService.get('clear');\n    }\n    /**\n     * @hidden\n     */\n\n\n    checkClearButton() {\n      this.showClearButton = !this.disabled && !this.readonly && this.clearButton && !!this.value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearValue(ev) {\n      if (ev) {\n        ev.preventDefault();\n      }\n\n      this.clearButtonClicked = true;\n      this.input.nativeElement.value = '';\n      this.input.nativeElement.focus();\n      this.updateValue('');\n      this.checkClearButton();\n      this.clearButtonClicked = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      this.checkClearButton();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    showErrorsInitial() {\n      if (!this.control) {\n        return false;\n      }\n\n      const {\n        invalid,\n        dirty,\n        touched\n      } = this.control;\n      return invalid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n\n\n    showSuccessInitial() {\n      if (!this.control) {\n        return false;\n      }\n\n      const {\n        valid,\n        dirty,\n        touched\n      } = this.control;\n      return valid && (dirty || touched);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get successIconClasses() {\n      return this.successIcon ? `${this.successIcon}` : `k-input-validation-icon k-icon k-i-check`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get errorIconClasses() {\n      return this.errorIcon ? `${this.errorIcon}` : `k-input-validation-icon k-icon k-i-warning`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get clearButtonClasses() {\n      return this.clearButtonIcon ? this.clearButtonIcon : `k-icon k-i-x`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasErrors() {\n      return this.showErrorIcon === 'initial' ? this.showErrorsInitial() : this.showErrorIcon;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isSuccessful() {\n      return this.showSuccessIcon === 'initial' ? this.showSuccessInitial() : this.showSuccessIcon;\n    }\n\n    setSelection(start, end) {\n      if (this.isFocused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n\n    selectAll() {\n      if (this.value) {\n        this.setSelection(0, this.value.length);\n      }\n    }\n\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.checkClearButton();\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    set isFocused(value) {\n      if (this._isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n\n        if (value && !this.disabled) {\n          this.renderer.addClass(element, FOCUSED$1);\n        } else {\n          this.renderer.removeClass(element, FOCUSED$1);\n        }\n\n        this._isFocused = value;\n      }\n    }\n\n    handleBlur() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.onBlur.emit();\n        }\n\n        this.isFocused = false;\n      });\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n  }\n\n  TextBoxComponent.ɵfac = function TextBoxComponent_Factory(t) {\n    return new (t || TextBoxComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  TextBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TextBoxComponent,\n    selectors: [[\"kendo-textbox\"]],\n    contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);\n      }\n    },\n    viewQuery: function TextBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c36, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function TextBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabledClass)(\"k-textbox\", ctx.hostClasses)(\"k-input\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      title: \"title\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      value: \"value\",\n      selectOnFocus: \"selectOnFocus\",\n      showSuccessIcon: \"showSuccessIcon\",\n      showErrorIcon: \"showErrorIcon\",\n      clearButton: \"clearButton\",\n      successIcon: \"successIcon\",\n      errorIcon: \"errorIcon\",\n      clearButtonIcon: \"clearButtonIcon\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      tabIndex: \"tabIndex\",\n      placeholder: \"placeholder\",\n      maxlength: \"maxlength\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoTextBox\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.textbox'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TextBoxComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => TextBoxComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 18,\n    consts: function () {\n      let i18n_38;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Clear** button in the TextBox.\n         * @meaning kendo.textbox.clear\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_39 = goog.getMsg(\"Clear\");\n        i18n_38 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_39;\n      } else {\n        i18n_38 = $localize`:kendo.textbox.clear|The title for the **Clear** button in the TextBox.:Clear`;\n      }\n\n      return [[\"kendoTextBoxLocalizedMessages\", \"\", \"clear\", i18n_38], [1, \"k-input-prefix\"], [4, \"ngIf\"], [1, \"k-input-inner\", 3, \"id\", \"disabled\", \"readonly\", \"value\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"], [\"role\", \"button\", \"class\", \"k-clear-value\", 3, \"tabindex\", \"title\", \"click\", \"mousedown\", \"keydown.enter\", \"keydown.space\", 4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [1, \"k-input-suffix\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", 1, \"k-clear-value\", 3, \"tabindex\", \"title\", \"click\", \"mousedown\", \"keydown.enter\", \"keydown.space\"], [3, \"ngClass\"]];\n    },\n    template: function TextBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵtemplate(2, TextBoxComponent_2_Template, 1, 1, null, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(3, \"input\", 3, 4);\n        i0.ɵɵtemplate(5, TextBoxComponent_span_5_Template, 2, 4, \"span\", 5);\n        i0.ɵɵtemplate(6, TextBoxComponent_span_6_Template, 1, 1, \"span\", 6);\n        i0.ɵɵtemplate(7, TextBoxComponent_span_7_Template, 1, 1, \"span\", 6);\n        i0.ɵɵelementStart(8, \"span\", 7);\n        i0.ɵɵtemplate(9, TextBoxComponent_9_Template, 1, 1, null, 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.prefixTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"value\", ctx.value)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(14, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));\n        i0.ɵɵattribute(\"tabindex\", ctx.disabled ? undefined : ctx.tabindex)(\"placeholder\", ctx.placeholder)(\"title\", ctx.title)(\"maxlength\", ctx.maxlength);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showClearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasErrors);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isSuccessful);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.suffixTemplate);\n      }\n    },\n    directives: [LocalizedTextBoxMessagesDirective, i1$1.NgIf, i1$1.NgTemplateOutlet, i3.EventsOutsideAngularDirective, i1$1.NgClass],\n    encapsulation: 2\n  });\n  return TextBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet TextBoxCustomMessagesComponent = /*#__PURE__*/(() => {\n  class TextBoxCustomMessagesComponent extends TextBoxMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  TextBoxCustomMessagesComponent.ɵfac = function TextBoxCustomMessagesComponent_Factory(t) {\n    return new (t || TextBoxCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  TextBoxCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TextBoxCustomMessagesComponent,\n    selectors: [[\"kendo-textbox-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TextBoxMessages,\n      useExisting: forwardRef(() => TextBoxCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function TextBoxCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TextBoxCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies a separator in the content of components like the TextArea and the TextBox. ([see examples]({% slug adornments_textbox %}#toc-separator)).\n * @example\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textbox>\n *    <ng-template kendoTextBoxSuffixTemplate>\n *        <kendo-input-separator></kendo-input-separator>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </ng-template>\n *  </kendo-textbox>\n * `\n * })\n * class AppComponent {}\n * ```\n */\n\n\nlet InputSeparatorComponent = /*#__PURE__*/(() => {\n  class InputSeparatorComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  InputSeparatorComponent.ɵfac = function InputSeparatorComponent_Factory(t) {\n    return new (t || InputSeparatorComponent)();\n  };\n\n  InputSeparatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: InputSeparatorComponent,\n    selectors: [[\"kendo-input-separator\"], [\"kendo-textbox-separator\"]],\n    hostVars: 2,\n    hostBindings: function InputSeparatorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input-separator\", ctx.hostClass);\n      }\n    },\n    decls: 0,\n    vars: 0,\n    template: function InputSeparatorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return InputSeparatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst SHARED_DIRECTIVES = [InputSeparatorComponent, TextAreaDirective];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {}\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return SharedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextBox module\n * import { TextBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextBoxModule], // import TextBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet TextBoxModule = /*#__PURE__*/(() => {\n  class TextBoxModule {}\n\n  TextBoxModule.ɵfac = function TextBoxModule_Factory(t) {\n    return new (t || TextBoxModule)();\n  };\n\n  TextBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TextBoxModule\n  });\n  TextBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule, SharedModule], EventsModule]\n  });\n  return TextBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TextFieldsBase = /*#__PURE__*/(() => {\n  class TextFieldsBase {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      /**\n       * Sets the `title` attribute of the internal textarea input element of the component.\n       */\n\n      this.title = '';\n      /**\n       * Sets the disabled state of the TextArea component.\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the TextArea component.\n       *\n       * @default false\n       */\n\n      this.readonly = false;\n      /**\n       * Provides a value for the TextArea component.\n       */\n\n      this.value = null;\n      /**\n       * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.\n       *\n       * @default false\n       */\n\n      this.selectOnFocus = false;\n      /**\n       * Fires each time the user focuses the internal textarea element of the component.\n       * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.\n       */\n\n      this.inputFocus = new EventEmitter();\n      /**\n       * Fires each time the internal textarea element gets blurred.\n       * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.\n       */\n\n      this.inputBlur = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this._isFocused = false;\n      this.focusChangedProgrammatically = false;\n      /**\n       * @hidden\n       */\n\n      this.handleInputBlur = () => {\n        this.changeDetector.markForCheck();\n\n        if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {\n          this.ngZone.run(() => {\n            this.ngTouched();\n            this.inputBlur.emit();\n          });\n        }\n      };\n\n      this.ngChange = _ => {};\n\n      this.ngTouched = () => {};\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.changeDetector.markForCheck();\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  TextFieldsBase.ɵfac = function TextFieldsBase_Factory(t) {\n    return new (t || TextFieldsBase)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  TextFieldsBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TextFieldsBase,\n    selectors: [[\"kendo-textfield-base\"]],\n    viewQuery: function TextFieldsBase_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c36, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function TextFieldsBase_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      value: \"value\",\n      selectOnFocus: \"selectOnFocus\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      inputFocus: \"inputFocus\",\n      inputBlur: \"inputBlur\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function TextFieldsBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TextFieldsBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst resizeClasses = {\n  'vertical': 'k-resize-vertical',\n  'horizontal': 'k-resize-horizontal',\n  'both': 'k-resize-both',\n  'none': 'k-resize-none',\n  'auto': 'k-resize-none'\n};\nconst FOCUSED = 'k-focus';\nconst DEFAULT_SIZE$3 = 'medium';\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_FILL_MODE$1 = 'solid';\n/**\n * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).\n */\n\nlet TextAreaComponent = /*#__PURE__*/(() => {\n  class TextAreaComponent extends TextFieldsBase {\n    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {\n      super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.hostElement = hostElement;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      this.hostClasses = true;\n      /**\n       * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify\n       * their position in relation to the textarea element.\n       *\n       * The possible values are:\n       * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.\n       * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.\n       */\n\n      this.flow = 'vertical';\n      /**\n       * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Configures the resize behavior of the TextArea.\n       *\n       * The possible values are:\n       * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.\n       * * `horizontal`&mdash;The TextArea component can be resized only horizontally.\n       * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.\n       * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.\n       * * `none`&mdash;The TextArea cannot be resized.\n       *\n       */\n\n      this.resizable = 'vertical';\n      /**\n       * Fires each time the user focuses the TextArea component.\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textarea (focus)=\"handleFocus()\"></kendo-textarea>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log('Component is focused');\n       *   }\n       * }\n       * ```\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the TextArea component gets blurred.\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-textarea (blur)=\"handleBlur()\"></kendo-textarea>\n       * `\n       * })\n       * class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log('Component is blurred');\n       *   }\n       * }\n       * ```\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the value is changed or the component is blurred\n       * ([see example]({% slug overview_textarea %}#toc-events)).\n       * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.\n       */\n\n      this.valueChange = new EventEmitter();\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      /**\n       * @hidden\n       */\n\n      this.handleInput = ev => {\n        let incomingValue = ev.target.value;\n        this.updateValue(incomingValue);\n        this.resize();\n      };\n      /**\n       * @hidden\n       */\n\n\n      this.handleInputFocus = () => {\n        if (!this.disabled) {\n          if (this.selectOnFocus && this.value) {\n            this.ngZone.run(() => {\n              setTimeout(() => {\n                this.selectAll();\n              });\n            });\n          }\n\n          if (hasObservers(this.onFocus)) {\n            if (!this.isFocused) {\n              this.ngZone.run(() => {\n                this.onFocus.emit();\n              });\n            }\n          }\n\n          if (hasObservers(this.inputFocus)) {\n            if (!this.focusChangedProgrammatically) {\n              this.ngZone.run(() => {\n                this.inputFocus.emit();\n              });\n            }\n          }\n\n          this.ngZone.run(() => {\n            this.isFocused = true;\n          });\n        }\n      };\n\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n\n    get flowCol() {\n      return this.flow === 'vertical';\n    }\n\n    get flowRow() {\n      return this.flow === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * The size property specifies the padding of the internal textarea element\n     * ([see example]({% slug appearance_textarea %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$3;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the TextArea\n     * ([see example]({% slug appearance_textarea %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$2;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the TextArea\n     * ([see example]({% slug appearance_textarea %}#toc-fillMode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    ngAfterViewInit() {\n      const hostElement = this.hostElement.nativeElement;\n      let cursorInsideWrapper = false;\n      let tabbing = false;\n      this.ngZone.runOutsideAngular(() => {\n        // focusIn and focusOut are relative to the host element\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          if (!this.isFocused) {\n            this.ngZone.run(() => {\n              this.onFocus.emit();\n              this.isFocused = true;\n            });\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', args => {\n          if (!this.isFocused) {\n            return;\n          }\n\n          if (tabbing) {\n            const closestTextbox = closest(args.relatedTarget, element => element === this.hostElement.nativeElement);\n\n            if (!closestTextbox) {\n              this.handleBlur();\n            }\n\n            tabbing = false;\n          } else {\n            if (!cursorInsideWrapper) {\n              this.handleBlur();\n            }\n          }\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {\n          cursorInsideWrapper = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {\n          cursorInsideWrapper = false;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', args => {\n          if (args.keyCode === Keys.Tab) {\n            tabbing = true;\n          } else {\n            tabbing = false;\n          }\n        }));\n        this.handleFlow();\n      });\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n\n    ngOnInit() {\n      this.control = this.injector.get(NgControl, null);\n\n      if (isDocumentAvailable() && this.resizable === 'auto') {\n        this.resizeSubscription = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe(() => this.resize());\n      }\n\n      if (this.hostElement) {\n        this.renderer.removeAttribute(this.hostElement.nativeElement, \"tabindex\");\n      }\n\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    ngOnChanges(changes) {\n      const hostElement = this.hostElement.nativeElement;\n      const element = this.input.nativeElement;\n\n      if (changes.flow) {\n        this.handleFlow();\n      }\n\n      if (changes.resizable) {\n        if (this.resizable === 'auto') {\n          this.renderer.removeClass(element, '\\!k-overflow-y-auto');\n          this.initialHeight = element.offsetHeight;\n        } else {\n          this.renderer.addClass(element, '\\!k-overflow-y-auto');\n          element.style.height = `${this.initialHeight}px`;\n        }\n      }\n\n      if (changes.cols) {\n        if (isPresent(changes.cols.currentValue)) {\n          this.renderer.setStyle(hostElement, 'width', 'auto');\n        } else {\n          this.renderer.removeStyle(hostElement, 'width');\n        }\n      }\n\n      if (changes.value) {\n        this.resize();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      this.resize();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.ngChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.ngTouched = fn;\n    }\n\n    updateValue(value) {\n      if (!areSame(this.value, value)) {\n        this.ngZone.run(() => {\n          this.value = value;\n          this.ngChange(value);\n          this.valueChange.emit(value);\n          this.changeDetector.markForCheck();\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resizableClass() {\n      return resizeClasses[this.resizable];\n    }\n    /**\n     * Focuses the TextArea component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"textarea.focus()\">Focus the textarea</button>\n     *  <kendo-textarea #textarea></kendo-textarea>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.input) {\n        return;\n      }\n\n      this.focusChangedProgrammatically = true;\n      this.isFocused = true;\n      this.input.nativeElement.focus();\n      this.focusChangedProgrammatically = false;\n    }\n    /**\n     * Blurs the TextArea component.\n     */\n\n\n    blur() {\n      this.focusChangedProgrammatically = true;\n      const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');\n\n      if (isFocusedElement) {\n        isFocusedElement.blur();\n      }\n\n      this.isFocused = false;\n      this.focusChangedProgrammatically = false;\n    }\n\n    resize() {\n      if (this.resizable !== 'auto') {\n        return;\n      } // The logic of the resize method, does not depend on Angular and thus moving it outisde of it\n      // We need to ensure that the resizing logic runs after the value is updated thus the setTimout\n\n\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          const hostElement = this.hostElement.nativeElement;\n          const element = this.input.nativeElement;\n          this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);\n          const scrollHeight = element.scrollHeight;\n          this.renderer.setStyle(hostElement, 'min-height', `${scrollHeight}px`);\n\n          if (scrollHeight > this.initialHeight) {\n            this.renderer.setStyle(element, 'height', `${scrollHeight}px`);\n          }\n        }, 0);\n      });\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    set isFocused(value) {\n      if (this._isFocused !== value && this.hostElement) {\n        const element = this.hostElement.nativeElement;\n\n        if (value && !this.disabled) {\n          this.renderer.addClass(element, FOCUSED);\n        } else {\n          this.renderer.removeClass(element, FOCUSED);\n        }\n\n        this._isFocused = value;\n      }\n    }\n\n    handleBlur() {\n      this.ngZone.run(() => {\n        if (!this.focusChangedProgrammatically) {\n          this.onBlur.emit();\n        }\n\n        this.isFocused = false;\n      });\n    }\n\n    setSelection(start, end) {\n      if (this.isFocused) {\n        invokeElementMethod(this.input, 'setSelectionRange', start, end);\n      }\n    }\n\n    selectAll() {\n      if (this.value) {\n        this.setSelection(0, this.value.length);\n      }\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('input', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n    handleFlow() {\n      const isVertical = this.flow === 'vertical';\n      const hostElement = this.hostElement.nativeElement;\n      const element = this.input.nativeElement;\n      const suffix = hostElement.children[1];\n      this.renderer[isVertical ? 'addClass' : 'removeClass'](element, '\\!k-flex-none');\n\n      if (suffix) {\n        this.renderer[isVertical ? 'removeClass' : 'addClass'](suffix, '\\!k-align-items-start');\n      }\n    }\n\n  }\n\n  TextAreaComponent.ɵfac = function TextAreaComponent_Factory(t) {\n    return new (t || TextAreaComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  TextAreaComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TextAreaComponent,\n    selectors: [[\"kendo-textarea\"]],\n    hostVars: 8,\n    hostBindings: function TextAreaComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-textarea\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"!k-flex-col\", ctx.flowCol)(\"!k-flex-row\", ctx.flowRow);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      flow: \"flow\",\n      rows: \"rows\",\n      cols: \"cols\",\n      maxlength: \"maxlength\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      resizable: \"resizable\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoTextArea\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.textarea'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TextAreaComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => TextAreaComponent)\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c42,\n    decls: 4,\n    vars: 19,\n    consts: [[1, \"k-input-inner\", 3, \"ngClass\", \"id\", \"value\", \"disabled\", \"readonly\", \"kendoEventsOutsideAngular\"], [\"input\", \"\"]],\n    template: function TextAreaComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c41);\n        i0.ɵɵelementStart(0, \"textarea\", 0, 1);\n        i0.ɵɵtext(2, \"            \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.resizableClass)(\"id\", ctx.focusableId)(\"value\", ctx.value)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(15, _c40, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));\n        i0.ɵɵattribute(\"aria-multiline\", true)(\"aria-disabled\", ctx.disabled ? true : undefined)(\"aria-readonly\", ctx.readonly ? true : undefined)(\"placeholder\", ctx.placeholder)(\"rows\", ctx.rows)(\"cols\", ctx.cols)(\"tabindex\", ctx.tabIndex)(\"title\", ctx.title)(\"maxlength\", ctx.maxlength);\n      }\n    },\n    directives: [i1$1.NgClass, i3.EventsOutsideAngularDirective],\n    encapsulation: 2\n  });\n  return TextAreaComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the adornments in the suffix container ([see example]({% slug textarea_adornments %})).\n * ```ts-no-run\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-textarea>\n *    <kendo-textarea-suffix>\n *        <button kendoButton look=\"clear\" icon=\"image\"></button>\n *    </kendo-textarea-suffix>\n *  </kendo-textarea>\n * `\n * })\n * class AppComponent {}\n * ```\n */\n\n\nlet TextAreaSuffixComponent = /*#__PURE__*/(() => {\n  class TextAreaSuffixComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  TextAreaSuffixComponent.ɵfac = function TextAreaSuffixComponent_Factory(t) {\n    return new (t || TextAreaSuffixComponent)();\n  };\n\n  TextAreaSuffixComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TextAreaSuffixComponent,\n    selectors: [[\"kendo-textarea-suffix\"]],\n    hostVars: 2,\n    hostBindings: function TextAreaSuffixComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input-suffix\", ctx.hostClass);\n      }\n    },\n    exportAs: [\"kendoTextAreaSuffix\"],\n    ngContentSelectors: _c43,\n    decls: 1,\n    vars: 0,\n    template: function TextAreaSuffixComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TextAreaSuffixComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TextArea component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the TextArea module\n * import { TextAreaModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, TextAreaModule], // import TextArea module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet TextAreaModule = /*#__PURE__*/(() => {\n  class TextAreaModule {}\n\n  TextAreaModule.ɵfac = function TextAreaModule_Factory(t) {\n    return new (t || TextAreaModule)();\n  };\n\n  TextAreaModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TextAreaModule\n  });\n  TextAreaModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule, SharedModule], EventsModule]\n  });\n  return TextAreaModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable max-line-length\n\n/**\n * @hidden\n */\n\n\nconst PALETTEPRESETS = {\n  basic: {\n    colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',\n    columns: 10\n  },\n  office: {\n    colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',\n    columns: 10\n  },\n  apex: {\n    colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',\n    columns: 10\n  },\n  austin: {\n    colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',\n    columns: 10\n  },\n  clarity: {\n    colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',\n    columns: 10\n  },\n  slipstream: {\n    colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',\n    columns: 10\n  },\n  metro: {\n    colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',\n    columns: 10\n  },\n  flow: {\n    colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',\n    columns: 10\n  },\n  hardcover: {\n    colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',\n    columns: 10\n  },\n  trek: {\n    colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',\n    columns: 10\n  },\n  verve: {\n    colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',\n    columns: 10\n  },\n  monochrome: {\n    colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',\n    columns: 12\n  },\n  accessible: {\n    colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',\n    columns: 10\n  }\n};\n;\n/**\n * Arguments for the `cancel` event of the ColorPicker and FlatColorPicker components.\n */\n\nclass ColorPickerCancelEvent extends PreventableEvent {\n  constructor(originalEvent) {\n    super();\n    this.originalEvent = originalEvent;\n  }\n\n}\n/**\n * Arguments for the `close` event of the ColorPicker component.\n */\n\n\nclass ColorPickerCloseEvent extends PreventableEvent {}\n/**\n * Arguments for the `open` event of the ColorPicker component.\n */\n\n\nclass ColorPickerOpenEvent extends PreventableEvent {}\n/**\n * Fires each time the left side of the ColorPicker wrapper is clicked.\n * The event is triggered regardless of whether a ColorPicker icon is set or not.\n *\n * Provides information about the current active color and gives the option to prevent the opening of the popup.\n *\n * @example\n *\n * ```ts-no-run\n * _@Component({\n *   selector: 'my-app',\n *   template: `\n *       <kendo-colorpicker\n *           [icon]=\"'edit-tools'\"\n *           [value]=\"'#900'\"\n *           (activeColorClick)=\"handleActiveColorClick($event)\"\n *       >\n *       </kendo-colorpicker>\n *   `\n * })\n * class AppComponent {\n *     public handleActiveColorClick(event: ActiveColorClickEvent): void {\n *         event.preventOpen();\n *\n *         console.log('Open prevented:', event.isOpenPrevented());\n *         console.log('Current color:', event.color);\n *     }\n *  }\n * ```\n */\n\n\nclass ActiveColorClickEvent {\n  /**\n   * @hidden\n   * @param color Represents the current value of the ColorPicker.\n   */\n  constructor(color) {\n    this.color = color;\n    this.openPrevented = false;\n  }\n  /**\n   * Prevents the opening of the popup.\n   */\n\n\n  preventOpen() {\n    this.openPrevented = true;\n  }\n  /**\n   * Returns `true` if the popup opening is prevented by any of its subscribers.\n   *\n   * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isOpenPrevented() {\n    return this.openPrevented;\n  }\n\n}\n/**\n * @hidden\n *\n * Returns the hex or rgba string representation of the color.\n */\n\n\nconst parseColor = (value, format, opacityEnabled = false, safe = true) => {\n  const allowedFormats = ['hex', 'rgba', 'name'];\n\n  if (allowedFormats.indexOf(format) === -1) {\n    throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);\n  }\n\n  if (!isPresent(value)) {\n    return;\n  }\n\n  if (format === 'name') {\n    return nameFormat(value, safe);\n  }\n\n  const parsedColor = parseColor$1(value.trim(), safe);\n\n  if (!isPresent(parsedColor)) {\n    return;\n  }\n\n  const parsedColorResult = format === 'hex' ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();\n  return parsedColorResult;\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\n\n\nconst getHSV = (value, safe = true) => {\n  const parsed = parseColor$1(value, safe);\n\n  if (!isPresent(parsed)) {\n    return {};\n  }\n\n  return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\n\n\nconst getRGBA = (value, safe = true) => {\n  const parsed = parseColor$1(value, safe);\n\n  if (!isPresent(parsed)) {\n    return {};\n  }\n\n  return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\n\n\nconst getColorFromHSV = (hsva, format = 'rgba', opacityEnabled = false) => {\n  const hue = fitIntoBounds(hsva.h, 0, 359.9);\n  const saturation = fitIntoBounds(hsva.s, 0, 1);\n  const value = fitIntoBounds(hsva.v, 0, 1);\n  const alpha = fitIntoBounds(hsva.a, 0, 1);\n  const color = Color.fromHSV(hue, saturation, value, alpha);\n  return format === 'hex' ? getHexValue(color, opacityEnabled) : color.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the HEX value.\n */\n\n\nconst getHexValue = (color, opacity) => {\n  return opacity && color.a < 1 ? color.toCss({\n    alpha: true\n  }) : color.toCss();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.\n */\n\n\nconst getColorFromHue = hue => {\n  return getColorFromHSV({\n    h: hue,\n    s: 1,\n    v: 1,\n    a: 1\n  });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\n\n\nconst getColorFromRGBA = rgba => {\n  const red = fitIntoBounds(rgba.r, 0, 255);\n  const green = fitIntoBounds(rgba.g, 0, 255);\n  const blue = fitIntoBounds(rgba.b, 0, 255);\n  const alpha = fitIntoBounds(rgba.a, 0, 1);\n  return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n/**\n *\n * @hidden\n */\n\n\nfunction nameFormat(value, safe) {\n  value = value.toLowerCase().trim();\n\n  if (isPresent(namedColors[value])) {\n    return value;\n  }\n\n  if (parseColor$1(value, safe)) {\n    value = parseColor$1(value, safe).toHex();\n  }\n\n  const key = Object.keys(namedColors).find(key => namedColors[key] === value);\n\n  if (!key && !safe) {\n    throw new Error(`The provided color ${value} is not supported for 'format=\"name\"' property.To display ${value} color, the component 'format' property should be set to 'hex' or 'rgba' `);\n  }\n\n  return key;\n}\n/**\n * @hidden\n *\n * Returns the RGB object representation of the color based on the background color.\n */\n\n\nconst getRGBFromRGBA = (foregroundColor, backgroundColor) => {\n  const r1 = fitIntoBounds(foregroundColor.r, 0, 255);\n  const g1 = fitIntoBounds(foregroundColor.g, 0, 255);\n  const b1 = fitIntoBounds(foregroundColor.b, 0, 255);\n  const a1 = fitIntoBounds(foregroundColor.a, 0, 1);\n  const r2 = fitIntoBounds(backgroundColor.r, 0, 255);\n  const g2 = fitIntoBounds(backgroundColor.g, 0, 255);\n  const b2 = fitIntoBounds(backgroundColor.b, 0, 255);\n  return {\n    r: Math.round((1 - a1) * r2 + a1 * r1),\n    g: Math.round((1 - a1) * g2 + a1 * g1),\n    b: Math.round((1 - a1) * b2 + a1 * b1)\n  };\n};\n/**\n * @hidden\n *\n * Returns the relative luminance.\n */\n\n\nconst getLuminance = rgb => {\n  let a = [rgb.r, rgb.g, rgb.b].map(function (v) {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n};\n/**\n * @hidden\n *\n * Returns the color contrast.\n */\n\n\nconst getContrast = (luminance1, luminance2) => {\n  const brightest = Math.max(luminance1, luminance2);\n  const darkest = Math.min(luminance1, luminance2);\n  return (brightest + 0.05) / (darkest + 0.05);\n};\n/**\n * @hidden\n *\n * Returns the color contrast from two RGBA colors.\n */\n\n\nconst getContrastFromTwoRGBAs = (a, b) => {\n  return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  })));\n};\n/**\n * @hidden\n */\n\n\nconst bezierCommand = controlPointCalc => (point, i, a) => {\n  // start control point\n  const [cpsX, cpsY] = controlPointCalc(a[i - 1], a[i - 2], point); // end control point\n\n  const [cpeX, cpeY] = controlPointCalc(point, a[i - 1], a[i + 1], true);\n  return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point[0]},${point[1]}`;\n};\n/**\n * @hidden\n */\n\n\nconst controlPoint = lineCalc => (current, previous, next, reverse) => {\n  // when 'current' is the first or last point of the array\n  // 'previous' and 'next' are undefined\n  // replace with 'current'\n  const p = previous || current;\n  const n = next || current;\n  const smooth = 0.1; // properties of the line between previous and next\n\n  const l = lineCalc(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = l.angle + (reverse ? Math.PI : 0);\n  const length = l.length * smooth; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[1] + Math.sin(angle) * length;\n  return [x, y];\n};\n/**\n * @hidden\n */\n\n\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n */\n\n\nconst d = (points, command) => {\n  if (points.length === 0) {\n    return '';\n  } // build the d attributes by looping over the points\n\n\n  const d = points.reduce((acc, point, i, a) => i === 0 ? // if first point\n  `M ${point[0]},${point[1]}` : // else\n  `${acc} ${command(point, i, a)}`, '');\n  return d;\n};\n/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\n\n\nconst svgPath = (points, command) => {\n  if (points.length === 0) {\n    return '';\n  } // build the d attributes by looping over the points\n\n\n  const d = points.reduce((acc, point, i, a) => i === 0 ? // if first point\n  `M ${point[0]},${point[1]}` : // else\n  `${acc} ${command(point, i, a)}`, '');\n  return d;\n};\n/**\n * @hidden\n */\n\n\nlet ColorPickerLocalizationService = /*#__PURE__*/(() => {\n  class ColorPickerLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl) {\n      super(prefix, messageService, _rtl);\n    }\n\n  }\n\n  ColorPickerLocalizationService.ɵfac = function ColorPickerLocalizationService_Factory(t) {\n    return new (t || ColorPickerLocalizationService)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8));\n  };\n\n  ColorPickerLocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColorPickerLocalizationService,\n    factory: ColorPickerLocalizationService.ɵfac\n  });\n  return ColorPickerLocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst DEFAULT_OUTPUT_FORMAT = 'rgba';\n/**\n * @hidden\n */\n\nconst DEFAULT_GRADIENT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';\n/**\n * @hidden\n */\n\nconst DRAGHANDLE_MOVE_SPEED = 5;\n/**\n * @hidden\n */\n\nconst AAA_RATIO = 7.0;\n/**\n * @hidden\n */\n\nconst AA_RATIO = 4.5;\n/**\n * @hidden\n */\n\nconst DEFAULT_PRESET$1 = 'office';\n/**\n * @hidden\n */\n\nconst DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';\n/**\n * @hidden\n */\n\nconst STEP_COUNT = 16;\n/**\n * @hidden\n */\n\nlet FlatColorPickerLocalizationService = /*#__PURE__*/(() => {\n  class FlatColorPickerLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, colorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      this.colorPickerLocalization = colorPickerLocalization;\n    }\n\n    get(shortKey) {\n      if (this.colorPickerLocalization) {\n        return this.colorPickerLocalization.get(shortKey);\n      }\n\n      return super.get(shortKey);\n    }\n\n  }\n\n  FlatColorPickerLocalizationService.ɵfac = function FlatColorPickerLocalizationService_Factory(t) {\n    return new (t || FlatColorPickerLocalizationService)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(ColorPickerLocalizationService, 8));\n  };\n\n  FlatColorPickerLocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FlatColorPickerLocalizationService,\n    factory: FlatColorPickerLocalizationService.ɵfac\n  });\n  return FlatColorPickerLocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FlatColorPickerService = /*#__PURE__*/(() => {\n  class FlatColorPickerService {\n    getPaletteSettings(settings, format) {\n      const defaultPreset = format !== 'name' ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n      const settingsPalette = settings.palette;\n      const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : undefined;\n      return {\n        palette: settingsPalette || defaultPreset,\n        tileSize: settings.tileSize || 24,\n        columns: settings.columns || presetColumns || 10\n      };\n    }\n\n    paletteTileLayout(tileSize) {\n      if (typeof tileSize === 'number') {\n        return {\n          width: tileSize,\n          height: tileSize\n        };\n      }\n\n      return {\n        width: tileSize.width ? tileSize.width : tileSize.height,\n        height: tileSize.height ? tileSize.height : tileSize.width\n      };\n    }\n\n  }\n\n  FlatColorPickerService.ɵfac = function FlatColorPickerService_Factory(t) {\n    return new (t || FlatColorPickerService)();\n  };\n\n  FlatColorPickerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FlatColorPickerService,\n    factory: FlatColorPickerService.ɵfac\n  });\n  return FlatColorPickerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FlatColorPickerHeaderComponent = /*#__PURE__*/(() => {\n  class FlatColorPickerHeaderComponent {\n    constructor(localizationService) {\n      this.localizationService = localizationService;\n      this.hostClasses = true;\n      this.viewChange = new EventEmitter();\n      this.valuePaneClick = new EventEmitter();\n      this.clearButtonClick = new EventEmitter();\n    }\n\n    onViewButtonClick(view) {\n      this.activeView = view;\n      this.viewChange.emit(view);\n    }\n\n    get viewButtons() {\n      return this.views && this.views.indexOf('gradient') >= 0 && this.views.indexOf('palette') >= 0;\n    }\n\n    getViewButtonIcon(view) {\n      return view === 'gradient' ? 'k-i-color-canvas' : 'k-i-palette';\n    }\n\n    getText(text) {\n      return this.localizationService.get(text);\n    }\n\n  }\n\n  FlatColorPickerHeaderComponent.ɵfac = function FlatColorPickerHeaderComponent_Factory(t) {\n    return new (t || FlatColorPickerHeaderComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  FlatColorPickerHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FlatColorPickerHeaderComponent,\n    selectors: [[\"\", \"kendoFlatColorPickerHeader\", \"\"]],\n    viewQuery: function FlatColorPickerHeaderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c44, 5, ElementRef);\n        i0.ɵɵviewQuery(_c45, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearButtonElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewButtonsCollection = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function FlatColorPickerHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-coloreditor-header\", ctx.hostClasses)(\"k-hstack\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      clearButton: \"clearButton\",\n      activeView: \"activeView\",\n      views: \"views\",\n      preview: \"preview\",\n      value: \"value\",\n      selection: \"selection\"\n    },\n    outputs: {\n      viewChange: \"viewChange\",\n      valuePaneClick: \"valuePaneClick\",\n      clearButtonClick: \"clearButtonClick\"\n    },\n    attrs: _c46,\n    decls: 6,\n    vars: 3,\n    consts: [[1, \"k-coloreditor-header-actions\", \"k-hstack\"], [\"class\", \"k-button-group k-button-group-flat\", 4, \"ngIf\"], [1, \"k-spacer\"], [\"type\", \"button\", \"class\", \"k-button k-button-md k-button-flat k-button-flat-base k-icon-button k-coloreditor-reset\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"k-coloreditor-preview k-vstack\", 4, \"ngIf\"], [1, \"k-button-group\", \"k-button-group-flat\"], [\"type\", \"button\", \"class\", \"k-button k-button-md k-button-flat k-button-flat-base k-icon-button\", 3, \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\", 3, \"ngClass\", \"click\"], [\"viewButtons\", \"\"], [1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\", \"k-coloreditor-reset\", 3, \"click\"], [\"clearButton\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-reset-color\"], [1, \"k-coloreditor-preview\", \"k-vstack\"], [1, \"k-coloreditor-preview-color\", \"k-color-preview\"], [1, \"k-coloreditor-current-color\", \"k-color-preview\", 3, \"click\"]],\n    template: function FlatColorPickerHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_Template, 2, 1, \"div\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 0);\n        i0.ɵɵtemplate(4, FlatColorPickerHeaderComponent_button_4_Template, 3, 2, \"button\", 3);\n        i0.ɵɵtemplate(5, FlatColorPickerHeaderComponent_div_5_Template, 3, 6, \"div\", 4);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.viewButtons);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.preview);\n      }\n    },\n    directives: [i1$1.NgIf, i1$1.NgForOf, i1$1.NgClass],\n    encapsulation: 2\n  });\n  return FlatColorPickerHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorGradientLocalizationService = /*#__PURE__*/(() => {\n  class ColorGradientLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      this.flatColorPickerLocalization = flatColorPickerLocalization;\n    }\n\n    get(shortKey) {\n      if (this.flatColorPickerLocalization) {\n        return this.flatColorPickerLocalization.get(shortKey);\n      }\n\n      return super.get(shortKey);\n    }\n\n  }\n\n  ColorGradientLocalizationService.ɵfac = function ColorGradientLocalizationService_Factory(t) {\n    return new (t || ColorGradientLocalizationService)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(FlatColorPickerLocalizationService, 8));\n  };\n\n  ColorGradientLocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColorGradientLocalizationService,\n    factory: ColorGradientLocalizationService.ɵfac\n  });\n  return ColorGradientLocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorContrastSvgComponent = /*#__PURE__*/(() => {\n  class ColorContrastSvgComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n    ngAfterViewInit() {\n      this.metrics = this.wrapper.getBoundingClientRect();\n      this.oldA = this.hsva.value.a;\n      this.oldH = this.hsva.value.h;\n      this.hsva.subscribe(value => {\n        if (value.h !== this.oldH || value.a !== this.oldA) {\n          this.oldH = value.h;\n          this.oldA = value.a;\n          this.setPaths();\n        }\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.backgroundColor) && this.metrics) {\n        this.setPaths();\n      }\n    }\n\n    setPaths() {\n      const bezierCommandCalc = bezierCommand(controlPoint(line));\n      this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];\n    }\n\n    findValue(contrast, saturation, low, high, comparer) {\n      const mid = (low + high) / 2;\n      const hsva = Object.assign({}, this.hsva.value, {\n        s: saturation / this.metrics.width,\n        v: 1 - mid / this.metrics.height\n      });\n      const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ''));\n\n      if (low + 0.5 > high) {\n        if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {\n          return mid;\n        } else {\n          return null;\n        }\n      }\n\n      if (comparer(currentContrast, contrast)) {\n        return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);\n      }\n\n      return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);\n    }\n\n    getPaths(contrast, stepCount, reversed = false) {\n      const points = [];\n\n      for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {\n        const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? (a, b) => a < b : (a, b) => a > b);\n\n        if (value !== null) {\n          points.push([i, value]);\n        }\n      }\n\n      return points;\n    }\n\n  }\n\n  ColorContrastSvgComponent.ɵfac = function ColorContrastSvgComponent_Factory(t) {\n    return new (t || ColorContrastSvgComponent)();\n  };\n\n  ColorContrastSvgComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorContrastSvgComponent,\n    selectors: [[\"\", \"kendoColorContrastSvg\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ColorContrastSvgComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-color-contrast-svg\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      wrapper: \"wrapper\",\n      hsva: \"hsva\",\n      backgroundColor: \"backgroundColor\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c47,\n    decls: 1,\n    vars: 1,\n    consts: [[\"fill\", \"none\", \"stroke\", \"white\", \"stroke-width\", \"1\", 4, \"ngFor\", \"ngForOf\"], [\"fill\", \"none\", \"stroke\", \"white\", \"stroke-width\", \"1\"]],\n    template: function ColorContrastSvgComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ColorContrastSvgComponent__svg_path_0_Template, 1, 1, \"path\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.paths);\n      }\n    },\n    directives: [i1$1.NgForOf],\n    encapsulation: 2\n  });\n  return ColorContrastSvgComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorInputComponent = /*#__PURE__*/(() => {\n  class ColorInputComponent {\n    constructor(host, renderer, localizationService) {\n      this.host = host;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      /**\n       * The id of the hex input.\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Sets whether the alpha slider will be shown.\n       */\n\n      this.opacity = true;\n      /**\n       * Sets the disabled state of the ColorInput.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the ColorInput.\n       */\n\n      this.readonly = false;\n      /**\n       * Emits a parsed rgba string color.\n       */\n\n      this.valueChange = new EventEmitter();\n      this.colorInputClass = true;\n      /**\n       * The rgba inputs values.\n       */\n\n      this.rgba = {};\n      this.subscriptions = new Subscription();\n    }\n    /**\n     * Indicates whether any of the inputs are focused.\n     */\n\n\n    get isFocused() {\n      if (!(isDocumentAvailable() && isPresent(this.host))) {\n        return false;\n      }\n\n      const activeElement = document.activeElement;\n      return this.host.nativeElement.contains(activeElement);\n    }\n    /**\n     * Indicates whether any of the rgba inputs have value.\n     */\n\n\n    get rgbaInputValid() {\n      return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));\n    }\n\n    ngAfterViewInit() {\n      this.initDomEvents();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.value) && !this.isFocused) {\n        this.hex = parseColor(this.value, 'hex', this.opacity);\n        this.rgba = getRGBA(this.value);\n        this.rgba.a = parseColor(this.value, 'rgba', this.opacity) ? this.rgba.a : 1;\n      }\n    }\n\n    get formatButtonTitle() {\n      return this.localizationService.get('formatButton');\n    }\n\n    handleRgbaValueChange() {\n      const color = getColorFromRGBA(this.rgba);\n\n      if (!this.rgbaInputValid || color === this.value) {\n        return;\n      }\n\n      this.value = color;\n      this.rgba = getRGBA(this.value);\n      this.hex = parseColor(color, 'hex', this.opacity);\n      this.valueChange.emit(color);\n    }\n\n    handleHexValueChange(hex) {\n      this.hex = hex;\n      const color = parseColor(hex, 'rgba', this.opacity);\n\n      if (!isPresent(color) || color === this.value) {\n        return;\n      }\n\n      this.value = color;\n      this.rgba = getRGBA(color);\n      this.valueChange.emit(color);\n    }\n\n    handleRgbaInputBlur() {\n      if (!this.rgbaInputValid) {\n        this.rgba = getRGBA(this.value);\n      }\n    }\n\n    handleHexInputBlur() {\n      this.hex = parseColor(this.value, 'hex', this.opacity);\n    }\n\n    toggleFormatView() {\n      this.formatView = this.formatView === 'hex' ? 'rgba' : 'hex';\n    }\n\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n\n      this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, 'click', () => this.toggleFormatView()));\n    }\n\n  }\n\n  ColorInputComponent.ɵfac = function ColorInputComponent_Factory(t) {\n    return new (t || ColorInputComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ColorInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorInputComponent,\n    selectors: [[\"kendo-colorinput\"]],\n    viewQuery: function ColorInputComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c48, 5);\n        i0.ɵɵviewQuery(_c49, 5, ElementRef);\n        i0.ɵɵviewQuery(_c50, 5, ElementRef);\n        i0.ɵɵviewQuery(_c51, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.opacityInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hexInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.blueInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleFormatButton = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function ColorInputComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-colorgradient-inputs\", ctx.colorInputClass)(\"k-hstack\", ctx.colorInputClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      formatView: \"formatView\",\n      value: \"value\",\n      opacity: \"opacity\",\n      disabled: \"disabled\",\n      readonly: \"readonly\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 6,\n    vars: 4,\n    consts: [[1, \"k-vstack\"], [\"type\", \"button\", 1, \"k-colorgradient-toggle-mode\", \"k-button\", \"k-button-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\"], [\"toggleFormatButton\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrows-kpi\"], [\"class\", \"k-vstack\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-input\", \"k-textbox\", \"k-input-solid\", \"k-input-md\", \"k-rounded-md\", \"k-hex-value\", 3, \"id\", \"disabled\", \"readonly\", \"value\", \"blur\", \"input\"], [\"hexInput\", \"\"], [1, \"k-colorgradient-input-label\", 3, \"for\"], [3, \"disabled\", \"readonly\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"format\", \"decimals\", \"valueChange\", \"blur\"], [\"red\", \"\"], [\"green\", \"\"], [\"blue\", \"\"], [3, \"disabled\", \"readonly\", \"min\", \"max\", \"value\", \"autoCorrect\", \"spinners\", \"step\", \"format\", \"decimals\", \"valueChange\", \"blur\"], [\"opacityInput\", \"\", \"alpha\", \"\"]],\n    template: function ColorInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"button\", 1, 2);\n        i0.ɵɵelement(3, \"span\", 3);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(4, ColorInputComponent_div_4_Template, 5, 5, \"div\", 4);\n        i0.ɵɵtemplate(5, ColorInputComponent_ng_container_5_Template, 17, 31, \"ng-container\", 5);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-label\", ctx.formatButtonTitle)(\"title\", ctx.formatButtonTitle);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.formatView === \"hex\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.formatView === \"rgba\");\n      }\n    },\n    directives: [NumericTextBoxComponent, i1$1.NgIf],\n    encapsulation: 2\n  });\n  return ColorInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ContrastValidationComponent = /*#__PURE__*/(() => {\n  class ContrastValidationComponent {\n    constructor(localization) {\n      this.localization = localization;\n    }\n\n    get passMessage() {\n      return this.localization.get('passContrast');\n    }\n\n    get failMessage() {\n      return this.localization.get('failContrast');\n    }\n\n    get contrastText() {\n      let ratio = this.type === 'AA' ? AA_RATIO : AAA_RATIO;\n      return `${this.type}: ${ratio.toFixed(1)}`;\n    }\n\n  }\n\n  ContrastValidationComponent.ɵfac = function ContrastValidationComponent_Factory(t) {\n    return new (t || ContrastValidationComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ContrastValidationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ContrastValidationComponent,\n    selectors: [[\"\", \"kendoContrastValidation\", \"\"]],\n    inputs: {\n      type: \"type\",\n      pass: \"pass\",\n      value: \"value\"\n    },\n    attrs: _c52,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-success\", 4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-error\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-success\"], [1, \"k-icon\", \"k-i-check\"], [1, \"k-contrast-validation\", \"k-text-error\"], [1, \"k-icon\", \"k-i-close\"]],\n    template: function ContrastValidationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\");\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.contrastText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.value);\n      }\n    },\n    directives: [i1$1.NgIf],\n    encapsulation: 2\n  });\n  return ContrastValidationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ContrastComponent = /*#__PURE__*/(() => {\n  class ContrastComponent {\n    constructor(localization) {\n      this.localization = localization;\n    }\n\n    get formatedRatio() {\n      return this.contrastRatio.toFixed(2);\n    }\n\n    get contrastRatioText() {\n      return `${this.localization.get('contrastRatio')}: ${this.value ? this.formatedRatio : 'n/a'}`;\n    }\n\n    get satisfiesAACondition() {\n      return this.contrastRatio >= AA_RATIO;\n    }\n\n    get satisfiesAAACondition() {\n      return this.contrastRatio >= AAA_RATIO;\n    }\n\n    get contrastRatio() {\n      let contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));\n      return contrast;\n    }\n\n  }\n\n  ContrastComponent.ɵfac = function ContrastComponent_Factory(t) {\n    return new (t || ContrastComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ContrastComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ContrastComponent,\n    selectors: [[\"\", \"kendoContrastTool\", \"\"]],\n    inputs: {\n      value: \"value\",\n      ratio: \"ratio\"\n    },\n    attrs: _c53,\n    decls: 6,\n    vars: 6,\n    consts: [[1, \"k-contrast-ratio\"], [1, \"k-contrast-ratio-text\"], [4, \"ngIf\"], [\"kendoContrastValidation\", \"\", \"type\", \"AA\", 3, \"value\", \"pass\"], [\"kendoContrastValidation\", \"\", \"type\", \"AAA\", 3, \"value\", \"pass\"], [\"class\", \"k-contrast-validation k-text-success\", 4, \"ngIf\"], [\"class\", \"k-contrast-validation k-text-error\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-success\"], [1, \"k-icon\", \"k-i-check\"], [\"class\", \"k-icon k-i-check\", 4, \"ngIf\"], [1, \"k-contrast-validation\", \"k-text-error\"], [1, \"k-icon\", \"k-i-close\"]],\n    template: function ContrastComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"span\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, ContrastComponent_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(4, \"div\", 3)(5, \"div\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.contrastRatioText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.value);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"pass\", ctx.satisfiesAACondition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"pass\", ctx.satisfiesAAACondition);\n      }\n    },\n    directives: [ContrastValidationComponent, i1$1.NgIf],\n    encapsulation: 2\n  });\n  return ContrastComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorPickerMessages = /*#__PURE__*/(() => {\n  class ColorPickerMessages extends ComponentMessages {}\n\n  ColorPickerMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵColorPickerMessages_BaseFactory;\n    return function ColorPickerMessages_Factory(t) {\n      return (ɵColorPickerMessages_BaseFactory || (ɵColorPickerMessages_BaseFactory = i0.ɵɵgetInheritedFactory(ColorPickerMessages)))(t || ColorPickerMessages);\n    };\n  }();\n\n  ColorPickerMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColorPickerMessages,\n    selectors: [[\"kendo-colorpicker-messages-base\"]],\n    inputs: {\n      colorPaletteNoColor: \"colorPaletteNoColor\",\n      colorGradientNoColor: \"colorGradientNoColor\",\n      flatColorPickerNoColor: \"flatColorPickerNoColor\",\n      colorPickerNoColor: \"colorPickerNoColor\",\n      colorGradientHandle: \"colorGradientHandle\",\n      clearButton: \"clearButton\",\n      hueSliderHandle: \"hueSliderHandle\",\n      opacitySliderHandle: \"opacitySliderHandle\",\n      hexInputPlaceholder: \"hexInputPlaceholder\",\n      redInputPlaceholder: \"redInputPlaceholder\",\n      greenInputPlaceholder: \"greenInputPlaceholder\",\n      blueInputPlaceholder: \"blueInputPlaceholder\",\n      alphaInputPlaceholder: \"alphaInputPlaceholder\",\n      passContrast: \"passContrast\",\n      failContrast: \"failContrast\",\n      contrastRatio: \"contrastRatio\",\n      previewColor: \"previewColor\",\n      revertSelection: \"revertSelection\",\n      gradientView: \"gradientView\",\n      paletteView: \"paletteView\",\n      formatButton: \"formatButton\",\n      applyButton: \"applyButton\",\n      cancelButton: \"cancelButton\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ColorPickerMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedColorPickerMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedColorPickerMessagesDirective extends ColorPickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedColorPickerMessagesDirective.ɵfac = function LocalizedColorPickerMessagesDirective_Factory(t) {\n    return new (t || LocalizedColorPickerMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedColorPickerMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedColorPickerMessagesDirective,\n    selectors: [[\"\", \"kendoColorPickerLocalizedMessages\", \"\"], [\"\", \"kendoFlatColorPickerLocalizedMessages\", \"\"], [\"\", \"kendoColorGradientLocalizedMessages\", \"\"], [\"\", \"kendoColorPaletteLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColorPickerMessages,\n      useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedColorPickerMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet serial$3 = 0;\n/**\n * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.\n * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\n\nlet ColorGradientComponent = /*#__PURE__*/(() => {\n  class ColorGradientComponent {\n    constructor(host, ngZone, renderer, cdr, localizationService) {\n      this.host = host;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.localizationService = localizationService;\n      this.hostClasses = true;\n      /**\n       * @hidden\n       */\n\n      this.id = `k-colorgradient-${serial$3++}`;\n      /**\n       * Defines whether the alpha slider will be displayed.\n       *\n       * @default true\n       */\n\n      this.opacity = true;\n      /**\n       * Sets the disabled state of the ColorGradient.\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the ColorGradient.\n       *\n       * @default false\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies whether the ColorGradient should display a 'Clear color' button.\n       *\n       * @default false\n       */\n\n      this.clearButton = false;\n      /**\n       * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.\n       *\n       * @default 0\n       */\n\n      this.delay = 0;\n      /**\n       * Specifies the output format of the ColorGradientComponent.\n       * The input value may be in a different format, but it will be parsed into the output `format`\n       * after the component processes it.\n       *\n       * The supported values are:\n       * * (Default) `rgba`\n       * * `hex`\n       */\n\n      this.format = DEFAULT_OUTPUT_FORMAT;\n      /**\n       * Fires each time the user selects a new color.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;\n      /**\n       * @hidden\n       *\n       * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.\n       * The values are initially set in `ngOnInit` or in `ngOnChanges` and are\n       * updated on moving the drag handle or the sliders.\n       */\n\n      this.hsva = new BehaviorSubject({});\n      this._tabindex = 0;\n      this.listeners = [];\n      this.hueSliderTouched = false;\n      this.alphaSliderTouched = false;\n      this.updateValues = new Subject();\n\n      this.notifyNgChanged = () => {};\n\n      this.notifyNgTouched = () => {};\n\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get readonlyAttribute() {\n      return this.readonly;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get gradientId() {\n      return this.id;\n    }\n\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n\n\n    set value(value) {\n      this._value = parseColor(value, this.format, this.opacity);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Enables the color contrast tool. Accepts the background color that will be compared to the selected value.\n     * The tool will calculate the contrast ratio between the two colors.\n     */\n\n\n    set contrastTool(value) {\n      this._contrastTool = parseColor(value, this.format, this.opacity);\n    }\n\n    get contrastTool() {\n      return this._contrastTool;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n\n\n    set tabindex(value) {\n      if (isPresent(value)) {\n        const tabindex = Number(value);\n        this._tabindex = !isNaN(tabindex) ? tabindex : 0;\n      } else {\n        // Allows removal of the tabindex attribute\n        this._tabindex = value;\n      }\n    }\n\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Indicates whether the ColorGradient or any of its content is focused.\n     */\n\n\n    get isFocused() {\n      if (!(isDocumentAvailable() && isPresent(this.host))) {\n        return false;\n      }\n\n      return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get alphaSliderValue() {\n      // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run\n      if (!(isPresent(this.hsva.value) && isPresent(this.hsva.value.a))) {\n        return;\n      }\n\n      return this.hsva.value.a * 100;\n    }\n\n    get gradientRect() {\n      return this.gradientWrapper.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get contrastToolVisible() {\n      return this.contrastTool && this.contrastTool.length > 0;\n    }\n\n    ngAfterViewInit() {\n      this.updateUI();\n      this.cdr.detectChanges();\n      this.addEventListeners();\n      this.subscribeChanges();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('value', changes) && !this.isFocused) {\n        this.updateUI();\n      }\n\n      if (isChanged('delay', changes)) {\n        this.unsubscribeChanges();\n        this.subscribeChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      this.listeners.forEach(removeListener => removeListener());\n\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n\n      this.unsubscribeChanges();\n    }\n    /**\n     * Focuses the component.\n     */\n\n\n    focus() {\n      if (this.disabled) {\n        return;\n      }\n\n      this.gradientDragHandle.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    reset() {\n      this.handleValueChange(undefined);\n      this.updateUI();\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDragPress(args) {\n      if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {\n        return;\n      }\n\n      this.focus();\n      args.originalEvent.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleDrag(args) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n      this.changePosition(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHandleRelease() {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeyboardAction(args) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      if (args.key && args.key.indexOf('Arrow') !== -1) {\n        args.preventDefault();\n        const dragHandleElement = this.gradientDragHandle.nativeElement;\n        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');\n        let keyboardMoveX = 0;\n        let keyboardMoveY = 0;\n\n        switch (args.key) {\n          case 'ArrowRight':\n            keyboardMoveX = DRAGHANDLE_MOVE_SPEED;\n            break;\n\n          case 'ArrowLeft':\n            keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;\n            break;\n\n          case 'ArrowUp':\n            keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;\n            break;\n\n          case 'ArrowDown':\n            keyboardMoveY = DRAGHANDLE_MOVE_SPEED;\n            break;\n\n          default:\n            break;\n        }\n\n        const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;\n        const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;\n        this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);\n        this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);\n        this.ngZone.run(() => this.moveDragHandle(newX, newY));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    changePosition(position) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.gradientDragHandle.nativeElement.focus();\n      const gradientRect = this.gradientRect;\n      const newX = position.clientX - gradientRect.left;\n      const newY = position.clientY - gradientRect.top;\n      this.ngZone.run(() => this.moveDragHandle(newX, newY));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleHueSliderChange(hue) {\n      const hsva = this.hsva.value;\n      hsva.h = hue;\n      this.hsva.next(hsva);\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.backgroundColor = getColorFromHue(hue);\n      this.setBackgroundColor(this.backgroundColor);\n      this.setAlphaSliderBackground(this.backgroundColor);\n      this.hueSliderTouched = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleAlphaSliderChange(alpha) {\n      const hsva = this.hsva.value;\n      hsva.a = alpha / 100;\n      this.hsva.next(hsva);\n      this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.alphaSliderTouched = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleInputsValueChange(color) {\n      const parsed = parseColor(color, this.format, this.opacity);\n\n      if (this.value !== parsed) {\n        this.handleValueChange(parsed);\n        this.updateUI();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n\n      if (isPresent(this.gradientWrapper)) {\n        this.updateUI();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colorGradientHandleTitle() {\n      return this.localizationService.get('colorGradientHandle');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colorGradientHandleAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.opacity);\n      return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hueSliderTitle() {\n      return this.localizationService.get('hueSliderHandle');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get opacitySliderTitle() {\n      return this.localizationService.get('opacitySliderHandle');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get clearButtonTitle() {\n      return this.localizationService.get('clearButton');\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n\n    moveDragHandle(positionX, positionY) {\n      const gradientRect = this.gradientRect;\n      const gradientRectWidth = gradientRect.width;\n      const gradientRectHeight = gradientRect.height;\n      const top = fitIntoBounds(positionY, 0, gradientRectHeight);\n      const left = fitIntoBounds(positionX, 0, gradientRectWidth);\n      this.setDragHandleElementPosition(top, left);\n      const hsva = this.hsva.value;\n      hsva.s = left / gradientRectWidth;\n      hsva.v = 1 - top / gradientRectHeight;\n      this.hsva.next(hsva);\n      this.updateValues.next(getColorFromHSV(this.hsva.value, this.format, this.opacity));\n      this.setAlphaSliderBackground(getColorFromHSV(Object.assign(Object.assign({}, this.hsva.value), {\n        a: 1\n      }), this.format, this.opacity));\n    }\n\n    handleValueChange(color) {\n      if (this.value === color) {\n        return;\n      }\n\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n\n    setDragHandleElementPosition(top, left) {\n      const dragHandle = this.gradientDragHandle.nativeElement;\n      this.renderer.setStyle(dragHandle, 'top', `${top}px`);\n      this.renderer.setStyle(dragHandle, 'left', `${left}px`);\n    }\n\n    setAlphaSliderBackground(backgroundColor) {\n      if (!isPresent(this.alphaSlider)) {\n        return;\n      }\n\n      const sliderTrack = this.alphaSlider.track.nativeElement;\n      this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);\n    }\n\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.opacity);\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);\n    }\n\n    setBackgroundColor(color) {\n      this.renderer.setStyle(this.hsvRectangle.nativeElement, 'background', color);\n    }\n\n    updateUI() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      if (this.hueSliderTouched || this.alphaSliderTouched) {\n        this.hueSliderTouched = false;\n        this.alphaSliderTouched = false;\n        return;\n      }\n\n      this.hsva.next(this.value ? getHSV(this.value) : {\n        h: 0,\n        s: 0,\n        v: 1,\n        a: 1\n      });\n      const gradientRect = this.gradientRect;\n      const top = (1 - this.hsva.value.v) * gradientRect.height;\n      const left = this.hsva.value.s * gradientRect.width;\n      this.setDragHandleElementPosition(top, left);\n      this.backgroundColor = getColorFromHue(this.hsva.value.h);\n      this.setBackgroundColor(this.backgroundColor);\n      this.setAlphaSliderBackground(this.backgroundColor);\n      this.setHostElementAriaLabel();\n    }\n\n    addEventListeners() {\n      this.ngZone.runOutsideAngular(() => {\n        const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', event => {\n          if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {\n            this.ngZone.run(() => this.notifyNgTouched());\n          }\n        });\n        const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', event => {\n          this.onKeyboardAction(event);\n        });\n        const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {\n          this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');\n\n          if (!this.readonly && !this.disabled) {\n            this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity)));\n          }\n        });\n        const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {\n          this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');\n        });\n        const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {\n          this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');\n        });\n        this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);\n      });\n    }\n\n    subscribeChanges() {\n      this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {\n        this.handleValueChange(value);\n      });\n    }\n\n    unsubscribeChanges() {\n      if (this.changeRequestsSubscription) {\n        this.changeRequestsSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  ColorGradientComponent.ɵfac = function ColorGradientComponent_Factory(t) {\n    return new (t || ColorGradientComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ColorGradientComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorGradientComponent,\n    selectors: [[\"kendo-colorgradient\"]],\n    viewQuery: function ColorGradientComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c54, 5, ElementRef);\n        i0.ɵɵviewQuery(_c55, 5);\n        i0.ɵɵviewQuery(_c56, 5);\n        i0.ɵɵviewQuery(_c57, 5);\n        i0.ɵɵviewQuery(_c58, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientDragHandle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputs = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hsvRectangle = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function ColorGradientComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-readonly\", ctx.readonlyAttribute)(\"id\", ctx.gradientId)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabindex);\n        i0.ɵɵclassProp(\"k-colorgradient\", ctx.hostClasses)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      opacity: \"opacity\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      clearButton: \"clearButton\",\n      delay: \"delay\",\n      value: \"value\",\n      contrastTool: \"contrastTool\",\n      tabindex: \"tabindex\",\n      format: \"format\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendoColorGradient\"],\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ColorGradientComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => ColorGradientComponent)\n    }, ColorGradientLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorGradientLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorgradient'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 16,\n    vars: 28,\n    consts: function () {\n      let i18n_59;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.colorgradient.colorGradientNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_60 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_59 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_60;\n      } else {\n        i18n_59 = $localize`:kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n\n      let i18n_61;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.colorgradient.colorGradientHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_62 = goog.getMsg(\"Choose color\");\n        i18n_61 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_62;\n      } else {\n        i18n_61 = $localize`:kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n\n      let i18n_63;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.colorgradient.clearButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_64 = goog.getMsg(\"Clear value\");\n        i18n_63 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_64;\n      } else {\n        i18n_63 = $localize`:kendo.colorgradient.clearButton|The title for the clear button.:Clear value`;\n      }\n\n      let i18n_65;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.colorgradient.hueSliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_66 = goog.getMsg(\"Set hue\");\n        i18n_65 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_66;\n      } else {\n        i18n_65 = $localize`:kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n\n      let i18n_67;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.colorgradient.opacitySliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_68 = goog.getMsg(\"Set opacity\");\n        i18n_67 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_68;\n      } else {\n        i18n_67 = $localize`:kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n\n      let i18n_69;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The pass message for the contrast tool.\n         * @meaning kendo.colorgradient.passContrast\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_70 = goog.getMsg(\"Pass\");\n        i18n_69 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_70;\n      } else {\n        i18n_69 = $localize`:kendo.colorgradient.passContrast|The pass message for the contrast tool.:Pass`;\n      }\n\n      let i18n_71;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The fail message for the contrast tool.\n         * @meaning kendo.colorgradient.failContrast\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_72 = goog.getMsg(\"Fail\");\n        i18n_71 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_72;\n      } else {\n        i18n_71 = $localize`:kendo.colorgradient.failContrast|The fail message for the contrast tool.:Fail`;\n      }\n\n      let i18n_73;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.colorgradient.contrastRatio\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_74 = goog.getMsg(\"Contrast ratio\");\n        i18n_73 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_74;\n      } else {\n        i18n_73 = $localize`:kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n\n      let i18n_75;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.colorgradient.formatButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_76 = goog.getMsg(\"Change color format\");\n        i18n_75 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_76;\n      } else {\n        i18n_75 = $localize`:kendo.colorgradient.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n\n      return [[\"kendoColorGradientLocalizedMessages\", \"\", \"colorGradientNoColor\", i18n_59, \"colorGradientHandle\", i18n_61, \"clearButton\", i18n_63, \"hueSliderHandle\", i18n_65, \"opacitySliderHandle\", i18n_67, \"passContrast\", i18n_69, \"failContrast\", i18n_71, \"contrastRatio\", i18n_73, \"formatButton\", i18n_75], [1, \"k-colorgradient-canvas\", \"k-hstack\"], [1, \"k-hsv-rectangle\"], [\"hsvRectangle\", \"\"], [\"kendoDraggable\", \"\", 1, \"k-hsv-gradient\", 3, \"click\", \"kendoPress\", \"kendoDrag\", \"kendoRelease\"], [\"gradientWrapper\", \"\"], [\"tabindex\", \"0\", 1, \"k-hsv-draghandle\", \"k-draghandle\"], [\"gradientDragHandle\", \"\"], [\"kendoColorContrastSvg\", \"\", \"class\", \"k-color-contrast-svg\", \"xmlns\", \"http://www.w3.org/2000/svg\", 3, \"wrapper\", \"hsva\", \"backgroundColor\", 4, \"ngIf\"], [\"class\", \"k-clear-color k-button k-button-md k-button-flat k-button-flat-base k-button-icon\", \"tabindex\", \"0\", 3, \"click\", \"keydown.enter\", \"keydown.space\", 4, \"ngIf\"], [1, \"k-hue-slider\", \"k-colorgradient-slider\", 3, \"ngClass\", \"dragHandleTitle\", \"disabled\", \"readonly\", \"showButtons\", \"tickPlacement\", \"vertical\", \"min\", \"max\", \"value\", \"smallStep\", \"largeStep\", \"valueChange\"], [\"class\", \"k-alpha-slider k-colorgradient-slider\", 3, \"ngClass\", \"dragHandleTitle\", \"disabled\", \"readonly\", \"showButtons\", \"tickPlacement\", \"vertical\", \"min\", \"max\", \"smallStep\", \"largeStep\", \"value\", \"valueChange\", 4, \"ngIf\"], [3, \"opacity\", \"formatView\", \"value\", \"disabled\", \"readonly\", \"valueChange\"], [\"inputs\", \"\"], [\"class\", \"k-colorgradient-color-contrast k-vbox\", \"kendoContrastTool\", \"\", 3, \"value\", \"ratio\", 4, \"ngIf\"], [\"kendoColorContrastSvg\", \"\", \"xmlns\", \"http://www.w3.org/2000/svg\", 1, \"k-color-contrast-svg\", 3, \"wrapper\", \"hsva\", \"backgroundColor\"], [\"tabindex\", \"0\", 1, \"k-clear-color\", \"k-button\", \"k-button-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-button-icon\", 3, \"click\", \"keydown.enter\", \"keydown.space\"], [1, \"k-icon\", \"k-i-reset-color\"], [1, \"k-alpha-slider\", \"k-colorgradient-slider\", 3, \"ngClass\", \"dragHandleTitle\", \"disabled\", \"readonly\", \"showButtons\", \"tickPlacement\", \"vertical\", \"min\", \"max\", \"smallStep\", \"largeStep\", \"value\", \"valueChange\"], [\"alphaSlider\", \"\"], [\"kendoContrastTool\", \"\", 1, \"k-colorgradient-color-contrast\", \"k-vbox\", 3, \"value\", \"ratio\"]];\n    },\n    template: function ColorGradientComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2, 3)(4, \"div\", 4, 5);\n        i0.ɵɵlistener(\"click\", function ColorGradientComponent_Template_div_click_4_listener($event) {\n          return ctx.changePosition($event);\n        })(\"kendoPress\", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) {\n          return ctx.handleDragPress($event);\n        })(\"kendoDrag\", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) {\n          return ctx.onHandleDrag($event);\n        })(\"kendoRelease\", function ColorGradientComponent_Template_div_kendoRelease_4_listener() {\n          return ctx.onHandleRelease();\n        });\n        i0.ɵɵelement(6, \"div\", 6, 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, ColorGradientComponent__svg_svg_8_Template, 1, 3, \"svg\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"div\");\n        i0.ɵɵtemplate(10, ColorGradientComponent_span_10_Template, 2, 2, \"span\", 9);\n        i0.ɵɵelementStart(11, \"kendo-slider\", 10);\n        i0.ɵɵlistener(\"valueChange\", function ColorGradientComponent_Template_kendo_slider_valueChange_11_listener($event) {\n          return ctx.handleHueSliderChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, ColorGradientComponent_kendo_slider_12_Template, 2, 14, \"kendo-slider\", 11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(13, \"kendo-colorinput\", 12, 13);\n        i0.ɵɵlistener(\"valueChange\", function ColorGradientComponent_Template_kendo_colorinput_valueChange_13_listener($event) {\n          return ctx.handleInputsValueChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(15, ColorGradientComponent_div_15_Template, 1, 2, \"div\", 14);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(5);\n\n        i0.ɵɵadvance(6);\n        i0.ɵɵattribute(\"title\", ctx.colorGradientHandleTitle)(\"aria-label\", ctx.colorGradientHandleAriaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.contrastToolVisible && _r1);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMapInterpolate1(\"k-hsv-controls k-hstack \", ctx.clearButton ? \"k-sliders-wrap-clearable\" : \"\", \"\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(26, _c77, ctx.clearButton))(\"dragHandleTitle\", ctx.hueSliderTitle)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"showButtons\", false)(\"tickPlacement\", \"none\")(\"vertical\", true)(\"min\", 0)(\"max\", 360)(\"value\", ctx.hsva.value.h)(\"smallStep\", 5)(\"largeStep\", 10);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.opacity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"opacity\", ctx.opacity)(\"formatView\", ctx.format)(\"value\", ctx.value)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.contrastToolVisible);\n      }\n    },\n    directives: [ColorContrastSvgComponent, SliderComponent, ColorInputComponent, ContrastComponent, LocalizedColorPickerMessagesDirective, i3.DraggableDirective, i1$1.NgIf, i1$1.NgClass],\n    styles: [\".k-clear-color[_ngcontent-%COMP%] {\\n            position: absolute;\\n            top: 0;\\n            left: 50%;\\n            transform: translateX(-50%);\\n        }\\n        .k-colorgradient-slider.k-align-self-end[_ngcontent-%COMP%] {\\n            height: 140px;\\n        }\\n\\n        .k-color-contrast-svg[_ngcontent-%COMP%] {\\n            position: absolute;\\n            overflow: visible;\\n            pointer-events: none;\\n            left: 0px;\\n            top: 0px;\\n        }\"]\n  });\n  return ColorGradientComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorPaletteLocalizationService = /*#__PURE__*/(() => {\n  class ColorPaletteLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {\n      super(prefix, messageService, _rtl);\n      this.flatColorPickerLocalization = flatColorPickerLocalization;\n    }\n\n    get(shortKey) {\n      if (this.flatColorPickerLocalization) {\n        return this.flatColorPickerLocalization.get(shortKey);\n      }\n\n      return super.get(shortKey);\n    }\n\n  }\n\n  ColorPaletteLocalizationService.ɵfac = function ColorPaletteLocalizationService_Factory(t) {\n    return new (t || ColorPaletteLocalizationService)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(FlatColorPickerLocalizationService, 8));\n  };\n\n  ColorPaletteLocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColorPaletteLocalizationService,\n    factory: ColorPaletteLocalizationService.ɵfac\n  });\n  return ColorPaletteLocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ColorPaletteService = /*#__PURE__*/(() => {\n  class ColorPaletteService {\n    constructor() {\n      this.colorRows = [];\n    }\n\n    setColorMatrix(palette, columns) {\n      this.colorRows = [];\n\n      if (!(isPresent(palette) && palette.length)) {\n        return;\n      }\n\n      columns = columns || palette.length;\n\n      for (let start = 0; start < palette.length; start += columns) {\n        const row = palette.slice(start, columns + start);\n        this.colorRows.push(row);\n      }\n    }\n\n    getCellCoordsFor(color) {\n      if (!isPresent(color)) {\n        return;\n      }\n\n      for (let row = 0; row < this.colorRows.length; row++) {\n        for (let col = 0; col < this.colorRows[row].length; col++) {\n          if (this.colorRows[row][col] === color) {\n            return {\n              row,\n              col\n            };\n          }\n        }\n      }\n    }\n\n    getColorAt(cellCoords) {\n      if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n        return;\n      }\n\n      return this.colorRows[cellCoords.row][cellCoords.col];\n    }\n\n    getNextCell(current, horizontalStep, verticalStep) {\n      if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n        return {\n          row: 0,\n          col: 0\n        };\n      }\n\n      const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n      const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n      return {\n        row,\n        col\n      };\n    }\n\n    clampIndex(index, max) {\n      const minArrayIndex = 0;\n\n      if (index < minArrayIndex) {\n        return minArrayIndex;\n      }\n\n      if (index > max) {\n        return max;\n      }\n\n      return index;\n    }\n\n  }\n\n  ColorPaletteService.ɵfac = function ColorPaletteService_Factory(t) {\n    return new (t || ColorPaletteService)();\n  };\n\n  ColorPaletteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColorPaletteService,\n    factory: ColorPaletteService.ɵfac\n  });\n  return ColorPaletteService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_TILE_SIZE = 24;\nconst DEFAULT_COLUMNS_COUNT = 10;\nconst DEFAULT_PRESET = 'office';\nconst DEFAULT_ACCESSIBLE_PRESET = 'accessible';\nlet serial$2 = 0;\n/**\n * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.\n * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.\n */\n\nlet ColorPaletteComponent = /*#__PURE__*/(() => {\n  class ColorPaletteComponent {\n    constructor(host, service, cdr, renderer, localizationService, ngZone) {\n      this.host = host;\n      this.service = service;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      /**\n       * @hidden\n       */\n\n      this.id = `k-colorpalette-${serial$2++}`;\n      /**\n       * Specifies the output format of the ColorPaletteComponent.\n       * The input value may be in a different format. However, it will be parsed into the output `format`\n       * after the component processes it.\n       *\n       * The supported values are:\n       * * (Default) `hex`\n       * * `rgba`\n       * * `name`\n       */\n\n      this.format = 'hex';\n      /**\n       * Sets the disabled state of the ColorPalette.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the ColorPalette.\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the size of a color cell.\n       *\n       * The possible values are:\n       * * (Default) `tileSize = 24`\n       * * `{ width: number, height: number }`\n       */\n\n      this.tileSize = {\n        width: DEFAULT_TILE_SIZE,\n        height: DEFAULT_TILE_SIZE\n      };\n      /**\n       * Fires each time the color selection is changed.\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires each time the value is changed.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user selects a cell with the mouse or presses `Enter`.\n       *\n       * @hidden\n       */\n\n      this.cellSelection = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.hostClasses = true;\n      /**\n       * @hidden\n       */\n\n      this.uniqueId = guid();\n      this._tabindex = 0;\n\n      this.notifyNgTouched = () => {};\n\n      this.notifyNgChanged = () => {};\n\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    get paletteId() {\n      return this.id;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n\n\n    set value(value) {\n      this._value = parseColor(value, this.format);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the number of columns that will be displayed.\n     * Defaults to `10`.\n     */\n\n\n    set columns(value) {\n      const minColumnsCount = 1;\n      this._columns = value > minColumnsCount ? value : minColumnsCount;\n    }\n\n    get columns() {\n      return this._columns;\n    }\n    /**\n     * The color palette that will be displayed.\n     *\n     * The supported values are:\n     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).\n     * * A string with comma-separated colors.\n     * * A string array.\n     */\n\n\n    set palette(value) {\n      if (!isPresent(value)) {\n        value = DEFAULT_PRESET;\n      }\n\n      if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {\n        this.columns = this.columns || PALETTEPRESETS[value].columns;\n        value = PALETTEPRESETS[value].colors;\n      }\n\n      const colors = typeof value === 'string' ? value.split(',') : value;\n      this._palette = colors.map(color => parseColor(color, this.format, false, false));\n    }\n\n    get palette() {\n      return this._palette;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tileLayout() {\n      if (typeof this.tileSize !== 'number') {\n        return this.tileSize;\n      }\n\n      return {\n        width: this.tileSize,\n        height: this.tileSize\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get colorRows() {\n      return this.service.colorRows;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get readonlyAttribute() {\n      return this.readonly;\n    }\n\n    ngOnInit() {\n      if (this.colorRows.length === 0) {\n        const defaultPreset = this.format !== 'name' ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;\n        this.palette = this.palette || defaultPreset;\n        this.setRows();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setHostElementAriaLabel();\n\n      if (this.value) {\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          this.selectCell(this.value);\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.palette || changes.columns) {\n        this.setRows();\n      }\n\n      if (changes.palette || changes.value || changes.columns) {\n        this.selectCell(this.value);\n        this.setHostElementAriaLabel();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeydown(event) {\n      const isRTL = this.direction === 'rtl';\n\n      switch (event.keyCode) {\n        case Keys.ArrowDown:\n          this.handleCellNavigation(0, 1);\n          break;\n\n        case Keys.ArrowUp:\n          this.handleCellNavigation(0, -1);\n          break;\n\n        case Keys.ArrowRight:\n          this.handleCellNavigation(isRTL ? -1 : 1, 0);\n          break;\n\n        case Keys.ArrowLeft:\n          this.handleCellNavigation(isRTL ? 1 : -1, 0);\n          break;\n\n        case Keys.Enter:\n          this.handleEnter();\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleHostBlur() {\n      this.notifyNgTouched();\n      this.handleCellFocusOnBlur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCellSelection(value, focusedCell) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.selectedCell = focusedCell;\n      this.focusedCell = this.selectedCell;\n      this.focusInComponent = true;\n      const parsedColor = parseColor(value, this.format, false, false);\n      this.cellSelection.emit(parsedColor);\n      this.handleValueChange(parsedColor);\n\n      if (this.selection !== parsedColor) {\n        this.selection = parsedColor;\n        this.selectionChange.emit(parsedColor);\n      }\n\n      if (focusedCell) {\n        this.activeCellId = `k-${this.selectedCell.row}-${this.selectedCell.col}-${this.uniqueId}`;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      this.selectCell(value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n    /**\n     * Clears the color value of the ColorPalette.\n     */\n\n\n    reset() {\n      this.focusedCell = null;\n\n      if (isPresent(this.value)) {\n        this.handleValueChange(undefined);\n      }\n\n      this.selectedCell = undefined;\n    }\n\n    handleValueChange(color) {\n      if (this.value === color) {\n        return;\n      }\n\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n\n    handleCellFocusOnBlur() {\n      this.focusInComponent = false;\n      this.focusedCell = this.selectedCell;\n    }\n\n    selectCell(value) {\n      this.selectedCell = this.service.getCellCoordsFor(value);\n      this.focusedCell = this.selectedCell;\n    }\n\n    setRows() {\n      if (!isPresent(this.palette)) {\n        return;\n      }\n\n      this.columns = this.columns || DEFAULT_COLUMNS_COUNT;\n      this.service.setColorMatrix(this.palette, this.columns);\n    }\n\n    handleCellNavigation(horizontalStep, verticalStep) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);\n      this.focusInComponent = true;\n    }\n\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format);\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);\n    }\n\n    handleEnter() {\n      if (!isPresent(this.focusedCell)) {\n        return;\n      }\n\n      const selectedColor = this.service.getColorAt(this.focusedCell);\n      this.handleCellSelection(selectedColor, this.focusedCell);\n    }\n\n  }\n\n  ColorPaletteComponent.ɵfac = function ColorPaletteComponent_Factory(t) {\n    return new (t || ColorPaletteComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ColorPaletteService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ColorPaletteComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorPaletteComponent,\n    selectors: [[\"kendo-colorpalette\"]],\n    hostVars: 9,\n    hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function ColorPaletteComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        })(\"blur\", function ColorPaletteComponent_blur_HostBindingHandler() {\n          return ctx.handleHostBlur();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"id\", ctx.paletteId)(\"tabindex\", ctx.hostTabindex)(\"aria-disabled\", ctx.disabledClass)(\"aria-readonly\", ctx.readonlyAttribute);\n        i0.ɵɵclassProp(\"k-colorpalette\", ctx.hostClasses)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      format: \"format\",\n      value: \"value\",\n      columns: \"columns\",\n      palette: \"palette\",\n      tabindex: \"tabindex\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tileSize: \"tileSize\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\",\n      valueChange: \"valueChange\",\n      cellSelection: \"cellSelection\"\n    },\n    exportAs: [\"kendoColorPalette\"],\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ColorPaletteComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => ColorPaletteComponent)\n    }, ColorPaletteService, ColorPaletteLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorPaletteLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorpalette'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 2,\n    consts: function () {\n      let i18n_78;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.colorpalette.colorPaletteNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_79 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_78 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_79;\n      } else {\n        i18n_78 = $localize`:kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n\n      return [[\"kendoColorPaletteLocalizedMessages\", \"\", \"colorPaletteNoColor\", i18n_78], [\"role\", \"listbox\", 1, \"k-colorpalette-table-wrap\"], [1, \"k-colorpalette-table\", \"k-palette\"], [4, \"ngFor\", \"ngForOf\"], [\"role\", \"option\", \"class\", \"k-colorpalette-tile\", 3, \"k-state-selected\", \"k-state-focus\", \"id\", \"ngStyle\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"option\", 1, \"k-colorpalette-tile\", 3, \"id\", \"ngStyle\", \"click\"]];\n    },\n    template: function ColorPaletteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"table\", 2)(3, \"tbody\");\n        i0.ɵɵtemplate(4, ColorPaletteComponent_tr_4_Template, 2, 1, \"tr\", 3);\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeCellId);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.colorRows);\n      }\n    },\n    directives: [LocalizedColorPickerMessagesDirective, i1$1.NgForOf, i1$1.NgStyle],\n    encapsulation: 2\n  });\n  return ColorPaletteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FlatColorPickerActionButtonsComponent = /*#__PURE__*/(() => {\n  class FlatColorPickerActionButtonsComponent {\n    constructor(localizationService) {\n      this.localizationService = localizationService;\n      this.hostClasses = true;\n      this.actionButtonClick = new EventEmitter();\n    }\n\n    getText(text) {\n      return this.localizationService.get(text);\n    }\n\n    onActionButtonClick(type, ev) {\n      let args = {\n        target: type,\n        originalEvent: ev\n      };\n      this.actionButtonClick.emit(args);\n    }\n\n  }\n\n  FlatColorPickerActionButtonsComponent.ɵfac = function FlatColorPickerActionButtonsComponent_Factory(t) {\n    return new (t || FlatColorPickerActionButtonsComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  FlatColorPickerActionButtonsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FlatColorPickerActionButtonsComponent,\n    selectors: [[\"\", \"kendoFlatColorPickerActionButtons\", \"\"]],\n    viewQuery: function FlatColorPickerActionButtonsComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c81, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lastButton = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function FlatColorPickerActionButtonsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-coloreditor-footer\", ctx.hostClasses)(\"k-actions\", ctx.hostClasses)(\"k-hstack\", ctx.hostClasses);\n      }\n    },\n    outputs: {\n      actionButtonClick: \"actionButtonClick\"\n    },\n    attrs: _c82,\n    decls: 5,\n    vars: 4,\n    consts: [[\"type\", \"button\", 1, \"k-coloreditor-cancel\", \"k-button\", \"k-button-md\", \"k-button-solid\", \"k-button-solid-base\", 3, \"click\"], [\"type\", \"button\", 1, \"k-coloreditor-apply\", \"k-button\", \"k-button-md\", \"k-button-solid\", \"k-button-solid-primary\", 3, \"click\"], [\"last\", \"\"]],\n    template: function FlatColorPickerActionButtonsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function FlatColorPickerActionButtonsComponent_Template_button_click_0_listener($event) {\n          return ctx.onActionButtonClick(\"cancel\", $event);\n        });\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"button\", 1, 2);\n        i0.ɵɵlistener(\"click\", function FlatColorPickerActionButtonsComponent_Template_button_click_2_listener($event) {\n          return ctx.onActionButtonClick(\"apply\", $event);\n        });\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"title\", ctx.getText(\"cancelButton\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.getText(\"cancelButton\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"title\", ctx.getText(\"applyButton\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.getText(\"applyButton\"));\n      }\n    },\n    encapsulation: 2\n  });\n  return FlatColorPickerActionButtonsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FocusOnDomReadyDirective = /*#__PURE__*/(() => {\n  class FocusOnDomReadyDirective {\n    constructor(host, ngZone) {\n      this.host = host;\n      this.ngZone = ngZone;\n    }\n\n    ngAfterContentInit() {\n      this.focusOnNextTick();\n    }\n\n    focusOnNextTick() {\n      this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));\n    }\n\n  }\n\n  FocusOnDomReadyDirective.ɵfac = function FocusOnDomReadyDirective_Factory(t) {\n    return new (t || FocusOnDomReadyDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  FocusOnDomReadyDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusOnDomReadyDirective,\n    selectors: [[\"\", \"kendoFocusOnDomReady\", \"\"]]\n  });\n  return FocusOnDomReadyDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI FlatColorPicker component for Angular]({% slug overview_flatcolorpicker %}).\n *\n * The FlatColorPicker is a powerful tool which allows the user to choose colors through palettes with predefined sets of colors and\n * through a gradient that renders an hsv canvas. It supports previewing the selected color, reverting it to its previous state or clearing it completely.\n */\n\n\nlet FlatColorPickerComponent = /*#__PURE__*/(() => {\n  class FlatColorPickerComponent {\n    constructor(host, service, localizationService, cdr, renderer, ngZone) {\n      this.host = host;\n      this.service = service;\n      this.localizationService = localizationService;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.hostClasses = true;\n      /**\n       * Sets the read-only state of the FlatColorPicker.\n       *\n       * @default false\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the disabled state of the FlatColorPicker.\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Specifies the output format of the FlatColorPicker.\n       *\n       * If the input value is in a different format, it will be parsed into the specified output `format`.\n       *\n       * The supported values are:\n       * * `rgba` (default)\n       * * `hex`\n       */\n\n      this.format = 'rgba';\n      /**\n       * Specifies whether the FlatColorPicker should display a 'Clear color' button.\n       *\n       * @default true\n       */\n\n      this.clearButton = true;\n      /**\n       * Displays `Apply` and `Cancel` action buttons and a color preview pane.\n       *\n       * When enabled, the component value will not change immediately upon\n       * color selection, but only after the `Apply` button is clicked.\n       *\n       * The `Cancel` button reverts the current selection to its\n       * initial state i.e. to the current value.\n       *\n       * @default true\n       */\n\n      this.preview = true;\n      /**\n       * Configures the layout of the `Apply` and `Cancel` action buttons.\n       * * `start`\n       * * `center`\n       * * `end` (default)\n       * * `stretch`\n       */\n\n      this.actionsLayout = 'end';\n      /**\n       * Specifies the views that will be rendered. Default value is gradient and palette.\n       */\n\n      this.views = ['gradient', 'palette'];\n      /**\n       * Fires each time the component value is changed.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires when the user cancels the current color selection.\n       *\n       * The event is emitted on preview pane or on 'Cancel' button click.\n       */\n\n      this.cancel = new EventEmitter();\n      /**\n       * Fires each time the view is about to change.\n       * Used to provide a two-way binding for the `activeView` property.\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.actionButtonClick = new EventEmitter();\n      this._tabindex = 0;\n      this._gradientSettings = {\n        opacity: true,\n        delay: 0\n      };\n      this._paletteSettings = {};\n      this.subscriptions = new Subscription();\n\n      this.notifyNgChanged = () => {};\n\n      this.notifyNgTouched = () => {};\n\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get ariaReadonly() {\n      return this.readonly;\n    }\n\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    /**\n     * Specifies the initially selected color.\n     */\n\n\n    set value(value) {\n      this._value = parseColor(value, this.format, this.gradientSettings.opacity);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n\n\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * Configures the gradient view.\n     */\n\n\n    set gradientSettings(value) {\n      Object.assign(this._gradientSettings, value);\n    }\n\n    get gradientSettings() {\n      return this._gradientSettings;\n    }\n    /**\n     * Configures the palette view.\n     */\n\n\n    set paletteSettings(value) {\n      Object.assign(this._paletteSettings, value);\n    }\n\n    get paletteSettings() {\n      return this._paletteSettings;\n    }\n\n    ngOnInit() {\n      this.selection = this.value;\n      this._paletteSettings = this.service.getPaletteSettings(this._paletteSettings, this.format);\n      this.setActiveView();\n    }\n\n    ngAfterViewInit() {\n      this.setHostElementAriaLabel();\n      this.initDomEvents();\n      this.setSizingVariables();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('value', changes)) {\n        this.selection = this.value;\n        this.setHostElementAriaLabel();\n      }\n\n      if (isChanged('paletteSettings', changes)) {\n        this.setSizingVariables();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get headerHasContent() {\n      return this.preview || this.views.length > 1 || this.clearButton;\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n    /**\n     * Focuses the wrapper of the FlatColorPicker.\n     */\n\n\n    focus() {\n      if (this.disabled && this.focused) {\n        return;\n      }\n\n      this.host.nativeElement.focus();\n      this.focused = true;\n    }\n    /**\n     * Blurs the wrapper of the FlatColorPicker.\n     */\n\n\n    blur() {\n      if (!this.focused) {\n        return;\n      }\n\n      this.notifyNgTouched();\n      this.host.nativeElement.blur();\n      this.focused = false;\n    }\n    /**\n     * Clears the value of the FlatColorPicker.\n     */\n\n\n    reset() {\n      if (!isPresent(this.value)) {\n        return;\n      }\n\n      this.value = undefined;\n      this.notifyNgChanged(undefined);\n      this.setHostElementAriaLabel();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onViewChange(view) {\n      if (this.activeView === view) {\n        return;\n      }\n\n      this.activeView = view;\n      this.activeViewChange.emit(view);\n\n      if (this.activeView === 'gradient') {\n        this.ngZone.runOutsideAngular(() => {\n          setTimeout(() => {\n            this.gradient.gradientDragHandle.nativeElement.focus();\n          });\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClearButtonClick() {\n      this.resetInnerComponentValue();\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleValueChange(color) {\n      // eslint-disable-next-line no-unused-expressions\n      this.preview ? this.changeCurrentValue(color) : this.setFlatColorPickerValue(color);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onAction(ev) {\n      // eslint-disable-next-line no-unused-expressions\n      ev.target === 'apply' ? this.setFlatColorPickerValue(this.selection) : this.resetSelection(ev.originalEvent);\n      this.actionButtonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    resetSelection(ev) {\n      const eventArgs = new ColorPickerCancelEvent(ev);\n      this.cancel.emit(eventArgs);\n\n      if (!eventArgs.isDefaultPrevented()) {\n        this.selection = this.value;\n      }\n\n      this.notifyNgTouched();\n    }\n\n    setHostElementAriaLabel() {\n      const parsed = parseColor(this.value, this.format, this.gradientSettings.opacity);\n      const ariaLabelValue = `${this.value ? parsed : this.localizationService.get('flatColorPickerNoColor')}`;\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);\n    }\n\n    setSizingVariables() {\n      const paletteTileSize = this.service.paletteTileLayout(this.paletteSettings.tileSize);\n      const value = `--kendo-color-preview-columns: ${this.paletteSettings.columns};\n            --kendo-color-preview-width: ${paletteTileSize.width}px;\n            --kendo-color-preview-height: ${paletteTileSize.height}px;`;\n      this.host.nativeElement.querySelector('.k-coloreditor-views.k-vstack').setAttribute('style', value);\n    }\n\n    changeCurrentValue(color) {\n      this.selection = color;\n      this.notifyNgTouched();\n    }\n\n    resetInnerComponentValue() {\n      this.selection = null;\n\n      if (this.gradient) {\n        this.gradient.reset();\n        return;\n      }\n\n      this.palette.reset();\n    }\n\n    setFlatColorPickerValue(color) {\n      if (this.value === color) {\n        return;\n      }\n\n      this.value = color;\n      this.valueChange.emit(color);\n      this.notifyNgChanged(color);\n      this.setHostElementAriaLabel();\n    }\n\n    setActiveView() {\n      if (!isPresent(this.activeView)) {\n        this.activeView = this.views[0];\n        return;\n      }\n\n      if (isDevMode() && this.views.indexOf(this.activeView) === -1) {\n        throw new Error(\"Invalid configuration: The current activeView is not present in the views collection\");\n      }\n    }\n\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n\n      let hostElement = this.host.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focus', () => {\n          this.focused = true;\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'blur', () => {\n          this.focused = false;\n          this.notifyNgTouched();\n        }));\n      });\n    }\n\n  }\n\n  FlatColorPickerComponent.ɵfac = function FlatColorPickerComponent_Factory(t) {\n    return new (t || FlatColorPickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FlatColorPickerService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  FlatColorPickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FlatColorPickerComponent,\n    selectors: [[\"kendo-flatcolorpicker\"]],\n    viewQuery: function FlatColorPickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c83, 5);\n        i0.ɵɵviewQuery(_c84, 5);\n        i0.ɵɵviewQuery(_c85, 5);\n        i0.ɵɵviewQuery(_c86, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradient = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.palette = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footer = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function FlatColorPickerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"aria-readonly\", ctx.ariaReadonly)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabindex);\n        i0.ɵɵclassProp(\"k-flatcolorpicker\", ctx.hostClasses)(\"k-coloreditor\", ctx.hostClasses)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      format: \"format\",\n      value: \"value\",\n      tabindex: \"tabindex\",\n      clearButton: \"clearButton\",\n      preview: \"preview\",\n      actionsLayout: \"actionsLayout\",\n      activeView: \"activeView\",\n      views: \"views\",\n      gradientSettings: \"gradientSettings\",\n      paletteSettings: \"paletteSettings\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      cancel: \"cancel\",\n      activeViewChange: \"activeViewChange\",\n      actionButtonClick: \"actionButtonClick\"\n    },\n    exportAs: [\"kendoFlatColorPicker\"],\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => FlatColorPickerComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => FlatColorPickerComponent)\n    }, FlatColorPickerService, FlatColorPickerLocalizationService, {\n      provide: LocalizationService,\n      useExisting: FlatColorPickerLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.flatcolorpicker'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 6,\n    vars: 4,\n    consts: function () {\n      let i18n_87;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.\n         * @meaning kendo.flatcolorpicker.flatColorPickerNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_88 = goog.getMsg(\"Flatcolorpicker no color chosen\");\n        i18n_87 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_88;\n      } else {\n        i18n_87 = $localize`:kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;\n      }\n\n      let i18n_89;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.flatcolorpicker.colorGradientNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_90 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_89 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_90;\n      } else {\n        i18n_89 = $localize`:kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n\n      let i18n_91;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.flatcolorpicker.colorPaletteNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_92 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_91 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_92;\n      } else {\n        i18n_91 = $localize`:kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n\n      let i18n_93;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.flatcolorpicker.colorGradientHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_94 = goog.getMsg(\"Choose color\");\n        i18n_93 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_94;\n      } else {\n        i18n_93 = $localize`:kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n\n      let i18n_95;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.flatcolorpicker.clearButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_96 = goog.getMsg(\"Clear value\");\n        i18n_95 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_96;\n      } else {\n        i18n_95 = $localize`:kendo.flatcolorpicker.clearButton|The title for the clear button.:Clear value`;\n      }\n\n      let i18n_97;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.flatcolorpicker.hueSliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_98 = goog.getMsg(\"Set hue\");\n        i18n_97 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_98;\n      } else {\n        i18n_97 = $localize`:kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n\n      let i18n_99;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.flatcolorpicker.opacitySliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_100 = goog.getMsg(\"Set opacity\");\n        i18n_99 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_100;\n      } else {\n        i18n_99 = $localize`:kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n\n      let i18n_101;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.flatcolorpicker.contrastRatio\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_102 = goog.getMsg(\"Contrast ratio\");\n        i18n_101 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_102;\n      } else {\n        i18n_101 = $localize`:kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n\n      let i18n_103;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the color preview pane.\n         * @meaning kendo.flatcolorpicker.previewColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_104 = goog.getMsg(\"Color preview\");\n        i18n_103 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_104;\n      } else {\n        i18n_103 = $localize`:kendo.flatcolorpicker.previewColor|The message for the color preview pane.:Color preview`;\n      }\n\n      let i18n_105;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the selected color pane.\n         * @meaning kendo.flatcolorpicker.revertSelection\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_106 = goog.getMsg(\"Revert selection\");\n        i18n_105 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_106;\n      } else {\n        i18n_105 = $localize`:kendo.flatcolorpicker.revertSelection|The message for the selected color pane.:Revert selection`;\n      }\n\n      let i18n_107;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the gradient view button.\n         * @meaning kendo.flatcolorpicker.gradientView\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_108 = goog.getMsg(\"Gradient view\");\n        i18n_107 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_108;\n      } else {\n        i18n_107 = $localize`:kendo.flatcolorpicker.gradientView|The message for the gradient view button.:Gradient view`;\n      }\n\n      let i18n_109;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the palette view button.\n         * @meaning kendo.flatcolorpicker.paletteView\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_110 = goog.getMsg(\"Palette view\");\n        i18n_109 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_110;\n      } else {\n        i18n_109 = $localize`:kendo.flatcolorpicker.paletteView|The message for the palette view button.:Palette view`;\n      }\n\n      let i18n_111;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.flatcolorpicker.formatButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_112 = goog.getMsg(\"Change color format\");\n        i18n_111 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_112;\n      } else {\n        i18n_111 = $localize`:kendo.flatcolorpicker.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n\n      let i18n_113;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Apply action button.\n         * @meaning kendo.flatcolorpicker.applyButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_114 = goog.getMsg(\"Apply\");\n        i18n_113 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_114;\n      } else {\n        i18n_113 = $localize`:kendo.flatcolorpicker.applyButton|The message for the Apply action button.:Apply`;\n      }\n\n      let i18n_115;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Cancel action button.\n         * @meaning kendo.flatcolorpicker.cancelButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_116 = goog.getMsg(\"Cancel\");\n        i18n_115 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_116;\n      } else {\n        i18n_115 = $localize`:kendo.flatcolorpicker.cancelButton|The message for the Cancel action button.:Cancel`;\n      }\n\n      return [[\"kendoFlatColorPickerLocalizedMessages\", \"\", \"flatColorPickerNoColor\", i18n_87, \"colorGradientNoColor\", i18n_89, \"colorPaletteNoColor\", i18n_91, \"colorGradientHandle\", i18n_93, \"clearButton\", i18n_95, \"hueSliderHandle\", i18n_97, \"opacitySliderHandle\", i18n_99, \"contrastRatio\", i18n_101, \"previewColor\", i18n_103, \"revertSelection\", i18n_105, \"gradientView\", i18n_107, \"paletteView\", i18n_109, \"formatButton\", i18n_111, \"applyButton\", i18n_113, \"cancelButton\", i18n_115], [\"kendoFlatColorPickerHeader\", \"\", 3, \"clearButton\", \"activeView\", \"views\", \"value\", \"selection\", \"preview\", \"clearButtonClick\", \"viewChange\", \"valuePaneClick\", 4, \"ngIf\"], [1, \"k-coloreditor-views\", \"k-vstack\"], [3, \"tabindex\", \"value\", \"format\", \"opacity\", \"delay\", \"contrastTool\", \"readonly\", \"valueChange\", 4, \"ngIf\"], [\"kendoFocusOnDomReady\", \"\", 3, \"palette\", \"columns\", \"tileSize\", \"format\", \"value\", \"valueChange\", 4, \"ngIf\"], [\"kendoFlatColorPickerActionButtons\", \"\", 3, \"ngClass\", \"actionButtonClick\", 4, \"ngIf\"], [\"kendoFlatColorPickerHeader\", \"\", 3, \"clearButton\", \"activeView\", \"views\", \"value\", \"selection\", \"preview\", \"clearButtonClick\", \"viewChange\", \"valuePaneClick\"], [\"header\", \"\"], [3, \"tabindex\", \"value\", \"format\", \"opacity\", \"delay\", \"contrastTool\", \"readonly\", \"valueChange\"], [\"gradient\", \"\"], [\"kendoFocusOnDomReady\", \"\", 3, \"palette\", \"columns\", \"tileSize\", \"format\", \"value\", \"valueChange\"], [\"palette\", \"\"], [\"kendoFlatColorPickerActionButtons\", \"\", 3, \"ngClass\", \"actionButtonClick\"], [\"footer\", \"\"]];\n    },\n    template: function FlatColorPickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, FlatColorPickerComponent_div_1_Template, 2, 6, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵtemplate(3, FlatColorPickerComponent_kendo_colorgradient_3_Template, 2, 7, \"kendo-colorgradient\", 3);\n        i0.ɵɵtemplate(4, FlatColorPickerComponent_kendo_colorpalette_4_Template, 2, 5, \"kendo-colorpalette\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, FlatColorPickerComponent_div_5_Template, 2, 1, \"div\", 5);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.headerHasContent);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.activeView === \"gradient\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.activeView === \"palette\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.preview);\n      }\n    },\n    directives: [FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, LocalizedColorPickerMessagesDirective, i1$1.NgIf, FocusOnDomReadyDirective, i1$1.NgClass],\n    encapsulation: 2\n  });\n  return FlatColorPickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DOM_FOCUS_EVENTS = ['focus', 'blur'];\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_ROUNDED$1 = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).\n *\n * The ColorPicker is a powerful tool for choosing colors from Gradient and Palette views\n * which are rendered in its popup. It supports previewing the selected color, reverting it to its previous state or clearing it completely.\n */\n\nlet ColorPickerComponent = /*#__PURE__*/(() => {\n  class ColorPickerComponent {\n    constructor(host, popupService, cdr, localizationService, ngZone, renderer) {\n      this.host = host;\n      this.popupService = popupService;\n      this.cdr = cdr;\n      this.localizationService = localizationService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.hostClasses = true;\n      this.role = 'listbox';\n      /**\n       * Specifies the views that will be rendered in the popup.\n       * By default both the gradient and palette views will be rendered.\n       */\n\n      this.views = ['gradient', 'palette'];\n      /**\n       * Sets the read-only state of the ColorPicker.\n       *\n       * @default false\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the disabled state of the ColorPicker.\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Specifies the output format of the ColorPicker.\n       *\n       * If the input value is in a different format, it will be parsed into the specified output `format`.\n       *\n       * The supported values are:\n       * * `rgba` (default)\n       * * `hex`\n       */\n\n      this.format = 'rgba';\n      /**\n       * Specifies whether the ColorPicker should display a 'Clear color' button.\n       *\n       * @default true\n       */\n\n      this.clearButton = true;\n      /**\n       * Displays `Apply` and `Cancel` action buttons and color preview panes.\n       *\n       * When enabled, the component value will not change immediately upon\n       * color selection, but only after the `Apply` button is clicked.\n       *\n       * The `Cancel` button reverts the current selection to its\n       * previous state i.e. to the current value.\n       *\n       * @default false\n       */\n\n      this.preview = false;\n      /**\n       * Configures the layout of the `Apply` and `Cancel` action buttons.\n       *\n       * The possible values are:\n       * * `start`\n       * * `center`\n       * * `end` (default)\n       * * `stretch`\n       */\n\n      this.actionsLayout = 'end';\n      /**\n       * Fires each time the value is changed.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires each time ColorPicker is focused.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the ColorPicker is blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires when the user cancels the current color selection.\n       *\n       * Fires on preview pane or 'Cancel' button click.\n       */\n\n      this.cancel = new EventEmitter();\n      /**\n       * Fires each time the left side of the ColorPicker wrapper is clicked.\n       * The event is triggered regardless of whether a ColorPicker icon is set or not.\n       *\n       * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.\n       */\n\n      this.activeColorClick = new EventEmitter();\n      /**\n       * Fires each time the view is about to change.\n       * Used to provide a two-way binding for the `activeView` property.\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * Indicates whether the ColorPicker wrapper is focused.\n       */\n\n      this.isFocused = false;\n      this._tabindex = 0;\n      this._popupSettings = {\n        animate: true\n      };\n      this._paletteSettings = {};\n      this._gradientSettings = {\n        opacity: true,\n        delay: 0\n      };\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      this.subscriptions = new Subscription();\n\n      this.notifyNgTouched = () => {};\n\n      this.notifyNgChanged = () => {};\n\n      this.domFocusListener = event => event.stopImmediatePropagation();\n\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get focusedClass() {\n      return this.isFocused;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get ariaReadonly() {\n      return this.readonly;\n    }\n\n    get ariaExpanded() {\n      return this.isOpen;\n    }\n\n    get hostTabindex() {\n      return this.tabindex;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set view(view) {\n      this.views = [view];\n    }\n\n    get view() {\n      return this.views && this.views.length > 0 ? this.views[0] : null;\n    }\n    /**\n     * Specifies the value of the initially selected color.\n     */\n\n\n    set value(value) {\n      this._value = parseColor(value, this.format, this.gradientSettings.opacity);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Configures the popup of the ColorPicker.\n     */\n\n\n    set popupSettings(value) {\n      this._popupSettings = Object.assign(this._popupSettings, value);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Configures the palette that is displayed in the ColorPicker popup.\n     */\n\n\n    set paletteSettings(value) {\n      this._paletteSettings = Object.assign(this._paletteSettings, value);\n    }\n\n    get paletteSettings() {\n      return this._paletteSettings;\n    }\n    /**\n     * Configures the gradient that is displayed in the ColorPicker popup.\n     */\n\n\n    set gradientSettings(value) {\n      this._gradientSettings = Object.assign(this._gradientSettings, value);\n    }\n\n    get gradientSettings() {\n      return this._gradientSettings;\n    }\n    /**\n     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     *\n     * @default 0\n     */\n\n\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n\n    get tabindex() {\n      return !this.disabled ? this._tabindex : undefined;\n    }\n    /**\n     * The size property specifies the padding of the ColorPicker internal elements\n     * ([see example]({% slug appearance_colorpicker %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$2;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the ColorPicker\n     * ([see example]({% slug appearance_colorpicker %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * The fillMode property specifies the background and border styles of the ColorPicker\n     * ([see example]({% slug appearance_colorpicker %}#toc-fillMode)).\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this.handleClasses(newFillMode, 'fillMode');\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Indicates whether the ColorPicker popup is open.\n     */\n\n\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconStyles() {\n      if (this.iconClass) {\n        return this.iconClass;\n      }\n\n      if (this.icon) {\n        return `k-icon k-i-${this.icon}`;\n      }\n    }\n\n    ngOnInit() {\n      const defaultPreset = this.format !== 'name' ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;\n      const settingsPalette = this._paletteSettings.palette;\n      const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : undefined;\n      this._paletteSettings = {\n        palette: settingsPalette || defaultPreset,\n        tileSize: this._paletteSettings.tileSize || 24,\n        columns: this._paletteSettings.columns || presetColumns || 10\n      };\n    }\n\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded', 'fillMode'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n      this.setHostElementAriaLabel();\n      this.handleHostId();\n      this.initDomEvents();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.format && changes.format.currentValue === 'name') {\n        this.activeView = 'palette';\n      }\n\n      if (this.activeView === 'gradient' && this.gradientSettings.opacity) {\n        this.format = 'rgba';\n        this.value = parseColor(this.value, this.format, this.gradientSettings.opacity);\n      }\n\n      if (isChanged('value', changes)) {\n        this.setHostElementAriaLabel();\n      }\n    }\n\n    ngOnDestroy() {\n      this.closePopup();\n\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n\n      this.subscriptions.unsubscribe();\n      this.handleDomEvents('remove', DOM_FOCUS_EVENTS);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCancelEvent(ev) {\n      this.cancel.emit(ev);\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup() {\n      this.focus();\n      this.toggleWithEvents(!this.isOpen);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWrapperClick(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      this.focus();\n\n      if (closest$1(event.target, element => element === this.activeColor.nativeElement)) {\n        const event = new ActiveColorClickEvent(this.value);\n        this.activeColorClick.emit(event);\n\n        if (!event.isOpenPrevented() || this.isOpen) {\n          this.toggleWithEvents(!this.isOpen);\n        }\n\n        return;\n      }\n\n      this.toggleWithEvents(!this.isOpen);\n    }\n    /**\n     * Focuses the wrapper of the ColorPicker.\n     */\n\n\n    focus() {\n      this.isFocused = true;\n      this.host.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWrapperFocus() {\n      if (this.isFocused) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.focus();\n        this.onFocus.emit();\n      });\n    }\n    /**\n     * Blurs the ColorPicker.\n     */\n\n\n    blur() {\n      this.isFocused = false;\n      this.host.nativeElement.blur();\n      this.notifyNgTouched();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWrapperBlur() {\n      if (this.isOpen) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.onBlur.emit();\n        this.isFocused = false;\n      });\n    }\n    /**\n     * Clears the value of the ColorPicker.\n     */\n\n\n    reset() {\n      if (!isPresent(this.value)) {\n        return;\n      }\n\n      this._value = undefined;\n      this.setHostElementAriaLabel();\n      this.notifyNgChanged(undefined);\n    }\n    /**\n     * Toggles the popup of the ColorPicker.\n     * Does not trigger the `open` and `close` events of the component.\n     *\n     * @param open An optional parameter. Specifies whether the popup will be opened or closed.\n     */\n\n\n    toggle(open) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.cdr.markForCheck();\n      this.closePopup();\n      open = isPresent(open) ? open : !this.isOpen;\n\n      if (open) {\n        this.openPopup();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleValueChange(color) {\n      const parsedColor = parseColor(color, this.format, this.gradientSettings.opacity);\n      const valueChange = parsedColor !== this.value;\n\n      if (valueChange) {\n        this.value = parsedColor;\n        this.valueChange.emit(parsedColor);\n        this.setHostElementAriaLabel();\n        this.notifyNgChanged(parsedColor);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handlePopupBlur(event) {\n      if (this.popupBlurInvalid(event)) {\n        return;\n      }\n\n      this.isFocused = false;\n      this.onBlur.emit();\n      this.notifyNgTouched();\n      this.toggleWithEvents(false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.notifyNgChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.notifyNgTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.cdr.markForCheck();\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWrapperKeyDown(event) {\n      if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {\n        event.preventDefault();\n        this.ngZone.run(() => {\n          this.toggleWithEvents(true);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handlePopupKeyDown(event) {\n      if (event.keyCode === Keys.Escape) {\n        this.toggleWithEvents(false);\n        this.host.nativeElement.focus();\n      }\n\n      if (event.keyCode === Keys.Tab) {\n        const currentElement = event.shiftKey ? this.firstFocusableElement.nativeElement : this.lastFocusableElement.nativeElement;\n        const nextElement = event.shiftKey ? this.lastFocusableElement.nativeElement : this.firstFocusableElement.nativeElement;\n\n        if (event.target === currentElement) {\n          event.preventDefault();\n          nextElement.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Used by the FloatingLabel to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return false;\n    }\n\n    setHostElementAriaLabel() {\n      const ariaLabelValue = `${this.value ? this.value : this.localizationService.get('colorPickerNoColor')}`;\n      this.renderer.setAttribute(this.host.nativeElement, 'aria-label', ariaLabelValue);\n    }\n\n    handleClasses(value, input) {\n      const elem = this.host.nativeElement;\n      const classes = getStylingClasses('picker', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n    popupBlurInvalid(ev) {\n      const focusInFlatColorPickerElement = this.popupRef.popupElement.contains(ev.relatedTarget);\n      const hostClicked = closest$1(ev.relatedTarget, element => element === this.host.nativeElement);\n      return hostClicked || focusInFlatColorPickerElement;\n    }\n\n    toggleWithEvents(open) {\n      const sameState = this.isOpen === open;\n\n      if (this.disabled || this.readonly || sameState) {\n        return;\n      }\n\n      let eventArgs;\n\n      if (open) {\n        eventArgs = new ColorPickerOpenEvent();\n        this.open.emit(eventArgs);\n      } else {\n        eventArgs = new ColorPickerCloseEvent();\n        this.close.emit(eventArgs);\n      }\n\n      if (!eventArgs.isDefaultPrevented()) {\n        this.toggle(open);\n      }\n\n      if (open) {\n        this.focusFirstElement();\n      }\n    }\n\n    focusFirstElement() {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        if (this.flatColorPicker) {\n          const gradient = this.flatColorPicker.gradient;\n          const elementToFocus = gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;\n          elementToFocus.nativeElement.focus();\n        }\n      });\n    }\n\n    openPopup() {\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.activeColor,\n        animate: this.popupSettings.animate,\n        appendTo: this.popupSettings.appendTo,\n        popupAlign: popupPosition,\n        anchorAlign: anchorPosition,\n        popupClass: 'k-colorpicker-popup',\n        content: this.popupTemplate,\n        positionMode: 'absolute'\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.toggleWithEvents(false);\n\n        if (!this.isOpen) {\n          this.host.nativeElement.focus({\n            preventScroll: true\n          });\n        }\n      });\n    }\n\n    closePopup() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.popupRef.close();\n      this.popupRef = null;\n    }\n\n    get firstFocusableElement() {\n      if (!this.flatColorPicker.header || this.views.length <= 1 && !this.flatColorPicker.clearButton) {\n        const gradient = this.flatColorPicker.gradient;\n        return gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;\n      }\n\n      return this.views.length > 1 ? this.flatColorPicker.header.viewButtonsCollection.toArray()[0] : this.flatColorPicker.header.clearButtonElement;\n    }\n\n    get lastFocusableElement() {\n      if (this.preview) {\n        return this.flatColorPicker.footer.lastButton;\n      }\n\n      if (this.flatColorPicker.palette) {\n        return this.flatColorPicker.palette.host;\n      }\n\n      const gradient = this.flatColorPicker.gradient;\n      const inputs = gradient && gradient.inputs;\n\n      if (gradient && inputs && inputs.formatView === 'hex') {\n        return inputs.hexInput;\n      }\n\n      return this.gradientSettings.opacity ? inputs.opacityInput.numericInput : inputs.blueInput;\n    }\n\n    handleDomEvents(action, events) {\n      const hostElement = this.host.nativeElement;\n      events.forEach(ev => hostElement[`${action}EventListener`](ev, this.domFocusListener, true));\n    }\n\n    initDomEvents() {\n      if (!this.host) {\n        return;\n      }\n\n      let hostElement = this.host.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {\n          this.handleWrapperFocus();\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', event => {\n          const closestPopup = this.popupRef ? closest$1(event.relatedTarget, element => element === this.flatColorPicker.host.nativeElement) : false;\n          const closestWrapper = closest$1(event.relatedTarget, element => element === this.host.nativeElement);\n\n          if (!closestPopup && !closestWrapper) {\n            this.handleWrapperBlur();\n          }\n        }));\n        this.handleDomEvents('add', DOM_FOCUS_EVENTS);\n        this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', event => {\n          this.handleWrapperKeyDown(event);\n        }));\n        this.subscriptions.add(this.renderer.listen(hostElement, 'click', event => {\n          this.ngZone.run(() => {\n            this.handleWrapperClick(event);\n          });\n        }));\n      });\n    }\n\n    handleHostId() {\n      const hostElement = this.host.nativeElement;\n      const existingId = hostElement.getAttribute('id');\n\n      if (existingId) {\n        this.focusableId = existingId;\n      } else {\n        const id = `k-${guid()}`;\n        hostElement.setAttribute('id', id);\n        this.focusableId = id;\n      }\n    }\n\n  }\n\n  ColorPickerComponent.ɵfac = function ColorPickerComponent_Factory(t) {\n    return new (t || ColorPickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$3.PopupService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ColorPickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorPickerComponent,\n    selectors: [[\"kendo-colorpicker\"]],\n    viewQuery: function ColorPickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c117, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c118, 7);\n        i0.ɵɵviewQuery(_c119, 7);\n        i0.ɵɵviewQuery(_c120, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.activeColor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.flatColorPicker = _t.first);\n      }\n    },\n    hostVars: 16,\n    hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"aria-readonly\", ctx.ariaReadonly)(\"aria-expanded\", ctx.ariaExpanded)(\"tabindex\", ctx.hostTabindex)(\"dir\", ctx.direction)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-colorpicker\", ctx.hostClasses)(\"k-icon-picker\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-focus\", ctx.focusedClass)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      views: \"views\",\n      view: \"view\",\n      activeView: \"activeView\",\n      readonly: \"readonly\",\n      disabled: \"disabled\",\n      format: \"format\",\n      value: \"value\",\n      popupSettings: \"popupSettings\",\n      paletteSettings: \"paletteSettings\",\n      gradientSettings: \"gradientSettings\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      clearButton: \"clearButton\",\n      tabindex: \"tabindex\",\n      preview: \"preview\",\n      actionsLayout: \"actionsLayout\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      open: \"open\",\n      close: \"close\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      cancel: \"cancel\",\n      activeColorClick: \"activeColorClick\",\n      activeViewChange: \"activeViewChange\"\n    },\n    exportAs: [\"kendoColorPicker\"],\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => ColorPickerComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => ColorPickerComponent)\n    }, ColorPickerLocalizationService, {\n      provide: LocalizationService,\n      useExisting: ColorPickerLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.colorpicker'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 12,\n    vars: 7,\n    consts: function () {\n      let i18n_121;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPicker component when the value is empty.\n         * @meaning kendo.colorpicker.colorPickerNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_122 = goog.getMsg(\"Colorpicker no color chosen\");\n        i18n_121 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_122;\n      } else {\n        i18n_121 = $localize`:kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty.:Colorpicker no color chosen`;\n      }\n\n      let i18n_123;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the FlatColorPicker component when the value is empty.\n         * @meaning kendo.colorpicker.flatColorPickerNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_124 = goog.getMsg(\"Flatcolorpicker no color chosen\");\n        i18n_123 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_124;\n      } else {\n        i18n_123 = $localize`:kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;\n      }\n\n      let i18n_125;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorGradient component when the value is empty.\n         * @meaning kendo.colorpicker.colorGradientNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_126 = goog.getMsg(\"Colorgradient no color chosen\");\n        i18n_125 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_126;\n      } else {\n        i18n_125 = $localize`:kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;\n      }\n\n      let i18n_127;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The aria-label applied to the ColorPalette component when the value is empty.\n         * @meaning kendo.colorpicker.colorPaletteNoColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_128 = goog.getMsg(\"Colorpalette no color chosen\");\n        i18n_127 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_128;\n      } else {\n        i18n_127 = $localize`:kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;\n      }\n\n      let i18n_129;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the gradient color drag handle chooser.\n         * @meaning kendo.colorpicker.colorGradientHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_130 = goog.getMsg(\"Choose color\");\n        i18n_129 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_130;\n      } else {\n        i18n_129 = $localize`:kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;\n      }\n\n      let i18n_131;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the clear button.\n         * @meaning kendo.colorpicker.clearButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_132 = goog.getMsg(\"Clear value\");\n        i18n_131 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_132;\n      } else {\n        i18n_131 = $localize`:kendo.colorpicker.clearButton|The title for the clear button.:Clear value`;\n      }\n\n      let i18n_133;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the hue slider handle.\n         * @meaning kendo.colorpicker.hueSliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_134 = goog.getMsg(\"Set hue\");\n        i18n_133 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_134;\n      } else {\n        i18n_133 = $localize`:kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;\n      }\n\n      let i18n_135;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the opacity slider handle.\n         * @meaning kendo.colorpicker.opacitySliderHandle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_136 = goog.getMsg(\"Set opacity\");\n        i18n_135 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_136;\n      } else {\n        i18n_135 = $localize`:kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;\n      }\n\n      let i18n_137;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The contrast ratio message for the contrast tool.\n         * @meaning kendo.colorpicker.contrastRatio\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_138 = goog.getMsg(\"Contrast ratio\");\n        i18n_137 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_138;\n      } else {\n        i18n_137 = $localize`:kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;\n      }\n\n      let i18n_139;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the color preview pane.\n         * @meaning kendo.colorpicker.previewColor\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_140 = goog.getMsg(\"Color preview\");\n        i18n_139 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_140;\n      } else {\n        i18n_139 = $localize`:kendo.colorpicker.previewColor|The message for the color preview pane.:Color preview`;\n      }\n\n      let i18n_141;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the selected color pane.\n         * @meaning kendo.colorpicker.revertSelection\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_142 = goog.getMsg(\"Revert selection\");\n        i18n_141 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_142;\n      } else {\n        i18n_141 = $localize`:kendo.colorpicker.revertSelection|The message for the selected color pane.:Revert selection`;\n      }\n\n      let i18n_143;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the gradient view button.\n         * @meaning kendo.colorpicker.gradientView\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_144 = goog.getMsg(\"Gradient view\");\n        i18n_143 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_144;\n      } else {\n        i18n_143 = $localize`:kendo.colorpicker.gradientView|The message for the gradient view button.:Gradient view`;\n      }\n\n      let i18n_145;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the palette view button.\n         * @meaning kendo.colorpicker.paletteView\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_146 = goog.getMsg(\"Palette view\");\n        i18n_145 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_146;\n      } else {\n        i18n_145 = $localize`:kendo.colorpicker.paletteView|The message for the palette view button.:Palette view`;\n      }\n\n      let i18n_147;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the input format toggle button.\n         * @meaning kendo.colorpicker.formatButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_148 = goog.getMsg(\"Change color format\");\n        i18n_147 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_148;\n      } else {\n        i18n_147 = $localize`:kendo.colorpicker.formatButton|The message for the input format toggle button.:Change color format`;\n      }\n\n      let i18n_149;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Apply action button.\n         * @meaning kendo.colorpicker.applyButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_150 = goog.getMsg(\"Apply\");\n        i18n_149 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_150;\n      } else {\n        i18n_149 = $localize`:kendo.colorpicker.applyButton|The message for the Apply action button.:Apply`;\n      }\n\n      let i18n_151;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The message for the Cancel action button.\n         * @meaning kendo.colorpicker.cancelButton\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_152 = goog.getMsg(\"Cancel\");\n        i18n_151 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2015_KENDO_ANGULAR_INPUTS_JS_152;\n      } else {\n        i18n_151 = $localize`:kendo.colorpicker.cancelButton|The message for the Cancel action button.:Cancel`;\n      }\n\n      return [[\"kendoColorPickerLocalizedMessages\", \"\", \"colorPickerNoColor\", i18n_121, \"flatColorPickerNoColor\", i18n_123, \"colorGradientNoColor\", i18n_125, \"colorPaletteNoColor\", i18n_127, \"colorGradientHandle\", i18n_129, \"clearButton\", i18n_131, \"hueSliderHandle\", i18n_133, \"opacitySliderHandle\", i18n_135, \"contrastRatio\", i18n_137, \"previewColor\", i18n_139, \"revertSelection\", i18n_141, \"gradientView\", i18n_143, \"paletteView\", i18n_145, \"formatButton\", i18n_147, \"applyButton\", i18n_149, \"cancelButton\", i18n_151], [1, \"k-input-inner\"], [\"activeColor\", \"\"], [1, \"k-value-icon\", \"k-color-preview\", 3, \"ngClass\"], [\"class\", \"k-color-preview-icon k-icon\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-color-preview-mask\"], [\"tabindex\", \"-1\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-button-md\", \"k-button-solid\", \"k-button-solid-base\", \"k-icon-button\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrow-s\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [1, \"k-color-preview-icon\", \"k-icon\", 3, \"ngClass\"], [3, \"value\", \"format\", \"views\", \"activeView\", \"actionsLayout\", \"preview\", \"gradientSettings\", \"paletteSettings\", \"clearButton\", \"cancel\", \"focusout\", \"valueChange\", \"keydown\", \"activeViewChange\", \"actionButtonClick\"], [\"flatColorPicker\", \"\"]];\n    },\n    template: function ColorPickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1, 2)(3, \"span\", 3);\n        i0.ɵɵtemplate(4, ColorPickerComponent_span_4_Template, 1, 1, \"span\", 4);\n        i0.ɵɵelement(5, \"span\", 5);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"button\", 6);\n        i0.ɵɵelement(7, \"span\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, ColorPickerComponent_ng_template_8_Template, 2, 9, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(10, null, 9);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(4, _c153, ctx.iconStyles, !ctx.value));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconClass || ctx.icon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"background-color\", ctx.value);\n      }\n    },\n    directives: [FlatColorPickerComponent, LocalizedColorPickerMessagesDirective, i1$1.NgClass, i1$1.NgIf],\n    encapsulation: 2\n  });\n  return ColorPickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet ColorPickerCustomMessagesComponent = /*#__PURE__*/(() => {\n  class ColorPickerCustomMessagesComponent extends ColorPickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  ColorPickerCustomMessagesComponent.ɵfac = function ColorPickerCustomMessagesComponent_Factory(t) {\n    return new (t || ColorPickerCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ColorPickerCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ColorPickerCustomMessagesComponent,\n    selectors: [[\"kendo-colorpicker-messages\"], [\"kendo-flatcolorpicker-messages\"], [\"kendo-colorgradient-messages\"], [\"kendo-colorpalette-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ColorPickerMessages,\n      useExisting: forwardRef(() => ColorPickerCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function ColorPickerCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ColorPickerCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PUBLIC_DIRECTIVES = [ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, FlatColorPickerComponent, LocalizedColorPickerMessagesDirective, ColorPickerCustomMessagesComponent];\nconst INTERNAL_DIRECTIVES = [ColorInputComponent, FocusOnDomReadyDirective, ContrastComponent, ContrastValidationComponent, FlatColorPickerHeaderComponent, FlatColorPickerActionButtonsComponent, ColorContrastSvgComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ColorPicker.\n */\n\nlet ColorPickerModule = /*#__PURE__*/(() => {\n  class ColorPickerModule {}\n\n  ColorPickerModule.ɵfac = function ColorPickerModule_Factory(t) {\n    return new (t || ColorPickerModule)();\n  };\n\n  ColorPickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ColorPickerModule\n  });\n  ColorPickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SliderModule, NumericTextBoxModule, CommonModule, PopupModule, DraggableModule]]\n  });\n  return ColorPickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED = 'medium';\n/**\n * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"checkbox\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"checkbox\" kendoCheckBox />\n * ```\n */\n\nlet CheckBoxDirective = /*#__PURE__*/(() => {\n  class CheckBoxDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.kendoClass = true;\n      this._size = 'medium';\n      this._rounded = 'medium';\n    }\n    /**\n     * The size property specifies the width and height of the CheckBox\n     * ([see example]({% slug appearance_checkboxdirective %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * The rounded property specifies the border radius of the CheckBox\n     * ([see example]({% slug appearance_checkboxdirective %}#toc-rounded)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n      this.handleClasses(newRounded, 'rounded');\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('checkbox', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n  }\n\n  CheckBoxDirective.ɵfac = function CheckBoxDirective_Factory(t) {\n    return new (t || CheckBoxDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  CheckBoxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CheckBoxDirective,\n    selectors: [[\"input\", \"kendoCheckBox\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CheckBoxDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-checkbox\", ctx.kendoClass);\n      }\n    },\n    inputs: {\n      size: \"size\",\n      rounded: \"rounded\"\n    }\n  });\n  return CheckBoxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the CheckBox directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the CheckBox module\n * import { CheckBoxModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet CheckBoxModule = /*#__PURE__*/(() => {\n  class CheckBoxModule {}\n\n  CheckBoxModule.ɵfac = function CheckBoxModule_Factory(t) {\n    return new (t || CheckBoxModule)();\n  };\n\n  CheckBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CheckBoxModule\n  });\n  CheckBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return CheckBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_SIZE = 'medium';\n/**\n * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.\n * The directive is placed on input type=\"radio\" elements.\n *\n * @example\n * ```ts-no-run\n * <input type=\"radio\" kendoRadioButton />\n * ```\n */\n\nlet RadioButtonDirective = /*#__PURE__*/(() => {\n  class RadioButtonDirective {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.kendoClass = true;\n      this._size = 'medium';\n      validatePackage(packageMetadata);\n    }\n    /**\n     * The size property specifies the width and height of the RadioButton\n     * ([see example]({% slug appearance_radiobuttondirective %}#toc-size)).\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.handleClasses(newSize, 'size');\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    ngAfterViewInit() {\n      // kept in sync with other inputs for easier refactoring\n      // to a common base class\n      const stylingInputs = ['size'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(this[input], input);\n      });\n    }\n\n    handleClasses(value, input) {\n      const elem = this.hostElement.nativeElement;\n      const classes = getStylingClasses('radio', input, this[input], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n  }\n\n  RadioButtonDirective.ɵfac = function RadioButtonDirective_Factory(t) {\n    return new (t || RadioButtonDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  RadioButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RadioButtonDirective,\n    selectors: [[\"input\", \"kendoRadioButton\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RadioButtonDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-radio\", ctx.kendoClass);\n      }\n    },\n    inputs: {\n      size: \"size\"\n    }\n  });\n  return RadioButtonDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the RadioButton directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the RadioButton module\n * import { RadioButtonModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet RadioButtonModule = /*#__PURE__*/(() => {\n  class RadioButtonModule {}\n\n  RadioButtonModule.ɵfac = function RadioButtonModule_Factory(t) {\n    return new (t || RadioButtonModule)();\n  };\n\n  RadioButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RadioButtonModule\n  });\n  RadioButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return RadioButtonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet serial$1 = 0;\n/**\n * Represents an error message that will be shown underneath\n * a Kendo control or native HTML form-bound component after a validation.\n */\n\nlet ErrorComponent = /*#__PURE__*/(() => {\n  class ErrorComponent {\n    constructor() {\n      this.hostClass = true;\n      /**\n       * Specifies the alignment of the Error message.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n\n      this.align = 'start';\n      /**\n       * @hidden\n       */\n\n      this.id = `kendo-error-${serial$1++}`;\n      this.roleAttribute = 'alert';\n    }\n\n    get startClass() {\n      return this.align === 'start';\n    }\n\n    get endClass() {\n      return this.align === 'end';\n    }\n\n    get idAttribute() {\n      return this.id;\n    }\n\n  }\n\n  ErrorComponent.ɵfac = function ErrorComponent_Factory(t) {\n    return new (t || ErrorComponent)();\n  };\n\n  ErrorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ErrorComponent,\n    selectors: [[\"kendo-formerror\"]],\n    hostVars: 8,\n    hostBindings: function ErrorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.roleAttribute)(\"id\", ctx.idAttribute);\n        i0.ɵɵclassProp(\"k-form-error\", ctx.hostClass)(\"k-text-start\", ctx.startClass)(\"k-text-end\", ctx.endClass);\n      }\n    },\n    inputs: {\n      align: \"align\"\n    },\n    ngContentSelectors: _c43,\n    decls: 1,\n    vars: 0,\n    template: function ErrorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return ErrorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet serial = 0;\n/**\n * Represents a hint message that will be shown underneath a form-bound component.\n */\n\nlet HintComponent = /*#__PURE__*/(() => {\n  class HintComponent {\n    constructor() {\n      /**\n       * Specifies the alignment of the Hint message.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n      this.align = 'start';\n      /**\n       * @hidden\n       */\n\n      this.id = `kendo-hint-${serial++}`;\n      this.hostClass = true;\n    }\n\n    get startClass() {\n      return this.align === 'start';\n    }\n\n    get endClass() {\n      return this.align === 'end';\n    }\n\n    get idAttribute() {\n      return this.id;\n    }\n\n  }\n\n  HintComponent.ɵfac = function HintComponent_Factory(t) {\n    return new (t || HintComponent)();\n  };\n\n  HintComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HintComponent,\n    selectors: [[\"kendo-formhint\"]],\n    hostVars: 7,\n    hostBindings: function HintComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.idAttribute);\n        i0.ɵɵclassProp(\"k-form-hint\", ctx.hostClass)(\"k-text-start\", ctx.startClass)(\"k-text-end\", ctx.endClass);\n      }\n    },\n    inputs: {\n      align: \"align\"\n    },\n    ngContentSelectors: _c43,\n    decls: 1,\n    vars: 0,\n    template: function HintComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return HintComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies a container for form-bound controls (Kendo controls or native HTML controls).\n * Applies styling and behavior rules.\n */\n\n\nlet FormFieldComponent = /*#__PURE__*/(() => {\n  class FormFieldComponent {\n    constructor(renderer, localizationService, hostElement) {\n      this.renderer = renderer;\n      this.localizationService = localizationService;\n      this.hostElement = hostElement;\n      this.hostClass = true;\n      /**\n       *\n       * Specifies when the Hint messages will be shown.\n       *\n       * The possible values are:\n       *\n       * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is\n       * `valid` or `untouched` and `pristine`.\n       * * `always`&mdash;Allows full control over the visibility of the hints.\n       *\n       */\n\n      this.showHints = 'initial';\n      /**\n       * Specifies the layout orientation of the form field.\n       *\n       * * The possible values are:\n       *\n       * * (Default) `vertical`\n       * * `horizontal`\n       */\n\n      this.orientation = 'vertical';\n      /**\n       * Specifies when the Error messages will be shown.\n       *\n       * The possible values are:\n       *\n       * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is\n       * `invalid` and `touched` or `dirty`.\n       * * `always`&mdash;Allows full control over the visibility of the errors.\n       *\n       */\n\n      this.showErrors = 'initial';\n      this.subscriptions = new Subscription();\n      this.rtl = false;\n      validatePackage(packageMetadata);\n      this.subscriptions.add(this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      }));\n    }\n\n    get errorClass() {\n      if (!this.control) {\n        return false;\n      }\n\n      return this.control.invalid && (this.control.touched || this.control.dirty);\n    }\n\n    get disabledClass() {\n      if (!this.control) {\n        return false;\n      } // radiobutton group\n\n\n      if (this.isRadioControl(this.control)) {\n        return false;\n      }\n\n      return this.disabledControl() || this.disabledElement() || this.disabledKendoInput();\n    }\n\n    set formControls(formControls) {\n      this.validateFormControl(formControls);\n      this.control = formControls.first;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get horizontal() {\n      return this.orientation === 'horizontal';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasHints() {\n      return this.showHints === 'always' ? true : this.showHintsInitial();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasErrors() {\n      return this.showErrors === 'always' ? true : this.showErrorsInitial();\n    }\n\n    ngAfterViewInit() {\n      this.setDescription();\n    }\n\n    ngAfterViewChecked() {\n      this.updateDescription();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    disabledKendoInput() {\n      return this.kendoInput && this.kendoInput.disabled;\n    }\n\n    disabledControl() {\n      return this.control.disabled;\n    }\n\n    disabledElement() {\n      const elements = this.controlElementRefs.toArray();\n      return elements.every(e => e.nativeElement.hasAttribute('disabled'));\n    }\n\n    validateFormControl(formControls) {\n      if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {\n        throw new Error('The `kendo-formfield` component should contain ' + 'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' + 'or an ngModel(https://angular.io/api/forms/NgModel) binding.');\n      }\n    }\n\n    isControlGroup(formControls) {\n      if (!formControls.length) {\n        return false;\n      }\n\n      const name = formControls.first.name;\n      return formControls.toArray().every(c => c.name === name && this.isRadioControl(c));\n    }\n\n    isRadioControl(control) {\n      return control.valueAccessor instanceof RadioControlValueAccessor;\n    }\n\n    updateDescription() {\n      const controls = this.findControlElements();\n\n      if (!controls) {\n        return;\n      }\n\n      controls.forEach(control => {\n        if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {\n          const ariaIds = this.generateDescriptionIds(control);\n\n          if (ariaIds !== '') {\n            this.renderer.setAttribute(control, 'aria-describedby', ariaIds);\n          } else {\n            this.renderer.removeAttribute(control, 'aria-describedby');\n          }\n        }\n      });\n    }\n\n    findControlElements() {\n      if (!this.controlElementRefs) {\n        return;\n      } // if the control is KendoInput and has focusableId - dropdowns, dateinputs\n\n\n      if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {\n        return [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];\n      }\n\n      return this.controlElementRefs.map(el => el.nativeElement);\n    }\n\n    generateDescriptionIds(control) {\n      const ids = new Set();\n      let errorAttribute = '';\n\n      if (control.hasAttribute('aria-describedby')) {\n        const attributes = control.getAttribute('aria-describedby').split(' ');\n        errorAttribute = attributes.filter(attr => attr.includes('kendo-error-'))[0];\n        attributes.forEach(attr => {\n          if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {\n            return;\n          }\n\n          ids.add(attr);\n        });\n      }\n\n      this.hintChildren.forEach(hint => {\n        ids.add(hint.id);\n      });\n\n      if (this.hasErrors) {\n        this.errorChildren.forEach(error => {\n          ids.add(error.id);\n        });\n      } else {\n        ids.delete(errorAttribute);\n      }\n\n      return Array.from(ids).join(' ');\n    }\n\n    showHintsInitial() {\n      if (!this.control) {\n        return true;\n      }\n\n      const {\n        valid,\n        untouched,\n        pristine\n      } = this.control;\n      return valid || untouched && pristine;\n    }\n\n    showErrorsInitial() {\n      if (!this.control) {\n        return false;\n      }\n\n      const {\n        invalid,\n        dirty,\n        touched\n      } = this.control;\n      return invalid && (dirty || touched);\n    }\n\n    setDescription() {\n      this.updateDescription();\n      this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));\n      this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));\n    }\n\n  }\n\n  FormFieldComponent.ɵfac = function FormFieldComponent_Factory(t) {\n    return new (t || FormFieldComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  FormFieldComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormFieldComponent,\n    selectors: [[\"kendo-formfield\"]],\n    contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KendoInput, 7);\n        i0.ɵɵcontentQuery(dirIndex, NgControl, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgControl, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, ErrorComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, HintComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.formControls = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.controlElementRefs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.errorChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hintChildren = _t);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function FormFieldComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-form-field\", ctx.hostClass)(\"k-form-field-error\", ctx.errorClass)(\"k-form-field-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      showHints: \"showHints\",\n      orientation: \"orientation\",\n      showErrors: \"showErrors\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.formfield'\n    }])],\n    ngContentSelectors: _c155,\n    decls: 5,\n    vars: 4,\n    consts: [[4, \"ngIf\"]],\n    template: function FormFieldComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c154);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"div\");\n        i0.ɵɵprojection(2, 1);\n        i0.ɵɵtemplate(3, FormFieldComponent_ng_content_3_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(4, FormFieldComponent_ng_content_4_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-form-field-wrap\", ctx.horizontal);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasHints);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasErrors);\n      }\n    },\n    directives: [i1$1.NgIf],\n    encapsulation: 2\n  });\n  return FormFieldComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the FormField, Error and Hint components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the FormField module\n * import { FormFieldModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, FormFieldModule], // import FormField module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet FormFieldModule = /*#__PURE__*/(() => {\n  class FormFieldModule {}\n\n  FormFieldModule.ɵfac = function FormFieldModule_Factory(t) {\n    return new (t || FormFieldModule)();\n  };\n\n  FormFieldModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FormFieldModule\n  });\n  FormFieldModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return FormFieldModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Inputs module\n * import { InputsModule } from '@progress/kendo-angular-inputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet InputsModule = /*#__PURE__*/(() => {\n  class InputsModule {}\n\n  InputsModule.ɵfac = function InputsModule_Factory(t) {\n    return new (t || InputsModule)();\n  };\n\n  InputsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: InputsModule\n  });\n  InputsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], TextAreaModule, TextBoxModule, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule, FormFieldModule]\n  });\n  return InputsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ActiveColorClickEvent, CheckBoxDirective, CheckBoxModule, ColorGradientComponent, ColorPaletteComponent, ColorPickerCancelEvent, ColorPickerCloseEvent, ColorPickerComponent, ColorPickerCustomMessagesComponent, ColorPickerModule, ColorPickerOpenEvent, ErrorComponent, FlatColorPickerComponent, FormFieldComponent, FormFieldModule, HintComponent, InputSeparatorComponent, InputsModule, LabelTemplateDirective, LocalizedColorPickerMessagesDirective, LocalizedNumericTextBoxMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSliderMessagesDirective, LocalizedSwitchMessagesDirective, LocalizedTextBoxMessagesDirective, MaskedTextBoxComponent, MaskedTextBoxModule, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, NumericTextBoxModule, RadioButtonDirective, RadioButtonModule, RangeSliderComponent, RangeSliderCustomMessagesComponent, RangeSliderModule, SharedModule, SliderComponent, SliderCustomMessagesComponent, SliderModule, SliderTicksComponent, SwitchComponent, SwitchCustomMessagesComponent, SwitchModule, TextAreaComponent, TextAreaDirective, TextAreaModule, TextAreaSuffixComponent, TextBoxComponent, TextBoxCustomMessagesComponent, TextBoxDirective, TextBoxModule, TextBoxPrefixTemplateDirective, TextBoxSuffixTemplateDirective };","map":null,"metadata":{},"sourceType":"module"}