{"ast":null,"code":"import CandlestickChart from '../candlestick-chart/candlestick-chart';\nimport VerticalBoxPlot from './vertical-box-plot';\nimport BoxPlot from './box-plot';\nimport ClusterLayout from '../layout/cluster-layout';\nimport areNumbers from '../utils/are-numbers';\nimport { MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { defined } from '../../common';\n\nclass BoxPlotChart extends CandlestickChart {\n  addValue(data, fields) {\n    const {\n      categoryIx,\n      category,\n      series,\n      seriesIx\n    } = fields;\n    const {\n      children,\n      options\n    } = this;\n    const value = data.valueFields;\n    const valueParts = this.splitValue(value);\n    const hasValue = areNumbers(valueParts);\n    const dataItem = series.data[categoryIx];\n    let categoryPoints = this.categoryPoints[categoryIx];\n    let point;\n\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n\n    if (hasValue) {\n      point = this.createPoint(data, fields);\n    }\n\n    let cluster = children[categoryIx];\n\n    if (!cluster) {\n      cluster = new ClusterLayout({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n\n    if (point) {\n      this.updateRange(value, fields);\n      cluster.append(point);\n      point.categoryIx = categoryIx;\n      point.category = category;\n      point.series = series;\n      point.seriesIx = seriesIx;\n      point.owner = this;\n      point.dataItem = dataItem;\n    }\n\n    this.points.push(point);\n    categoryPoints.push(point);\n  }\n\n  pointType() {\n    if (this.options.invertAxes) {\n      return VerticalBoxPlot;\n    }\n\n    return BoxPlot;\n  }\n\n  splitValue(value) {\n    return [value.lower, value.q1, value.median, value.q3, value.upper];\n  }\n\n  updateRange(value, fields) {\n    const axisName = fields.series.axis;\n    let axisRange = this.valueAxisRanges[axisName];\n    let parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\n\n    if (defined(value.mean)) {\n      parts = parts.concat(value.mean);\n    }\n\n    axisRange = this.valueAxisRanges[axisName] = axisRange || {\n      min: MAX_VALUE,\n      max: MIN_VALUE\n    };\n    axisRange = this.valueAxisRanges[axisName] = {\n      min: Math.min.apply(Math, parts.concat([axisRange.min])),\n      max: Math.max.apply(Math, parts.concat([axisRange.max]))\n    };\n  }\n\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.lower, value.q1, value.median, value.q3, value.upper, value.mean, point.category);\n  }\n\n  filterOutliers(items) {\n    const length = (items || []).length;\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n\n      if (defined(item) && item !== null) {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n\n  supportsPointInactiveOpacity() {\n    return false;\n  }\n\n}\n\nexport default BoxPlotChart;","map":null,"metadata":{},"sourceType":"module"}