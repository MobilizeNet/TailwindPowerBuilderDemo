{"ast":null,"code":"import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nclass Ring extends Class {\n  constructor(center, innerRadius, radius, startAngle, angle) {\n    super();\n    this.center = center;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.startAngle = startAngle;\n    this.angle = angle;\n  }\n\n  clone() {\n    return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n  }\n\n  middle() {\n    return this.startAngle + this.angle / 2;\n  }\n\n  setRadius(newRadius, innerRadius) {\n    if (innerRadius) {\n      this.innerRadius = newRadius;\n    } else {\n      this.radius = newRadius;\n    }\n\n    return this;\n  } // TODO: Remove and replace with Point.onCircle\n\n\n  point(angle, innerRadius) {\n    const radianAngle = rad(angle);\n    const ax = Math.cos(radianAngle);\n    const ay = Math.sin(radianAngle);\n    const radius = innerRadius ? this.innerRadius : this.radius;\n    const x = round(this.center.x - ax * radius, COORD_PRECISION);\n    const y = round(this.center.y - ay * radius, COORD_PRECISION);\n    return new Point(x, y);\n  }\n\n  adjacentBox(distance, width, height) {\n    const sector = this.clone().expand(distance);\n    const midAndle = sector.middle();\n    const midPoint = sector.point(midAndle);\n    const hw = width / 2;\n    const hh = height / 2;\n    const sa = Math.sin(rad(midAndle));\n    const ca = Math.cos(rad(midAndle));\n    let x = midPoint.x - hw;\n    let y = midPoint.y - hh;\n\n    if (Math.abs(sa) < 0.9) {\n      x += hw * -ca / Math.abs(ca);\n    }\n\n    if (Math.abs(ca) < 0.9) {\n      y += hh * -sa / Math.abs(sa);\n    }\n\n    return new Box(x, y, x + width, y + height);\n  }\n\n  containsPoint(p) {\n    const center = this.center;\n    const innerRadius = this.innerRadius;\n    const radius = this.radius;\n    const startAngle = this.startAngle;\n    const endAngle = this.startAngle + this.angle;\n    const dx = p.x - center.x;\n    const dy = p.y - center.y;\n    const vector = new Point(dx, dy);\n    const startPoint = this.point(startAngle);\n    const startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n    const endPoint = this.point(endAngle);\n    const endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n    const dist = round(dx * dx + dy * dy, COORD_PRECISION);\n    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n  }\n\n  getBBox() {\n    const box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n    const startAngle = round(this.startAngle % 360);\n    const endAngle = round((startAngle + this.angle) % 360);\n    const innerRadius = this.innerRadius;\n    const allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n    const startAngleIndex = allAngles.indexOf(startAngle);\n    const endAngleIndex = allAngles.indexOf(endAngle);\n    let angles;\n\n    if (startAngle === endAngle) {\n      angles = allAngles;\n    } else {\n      if (startAngleIndex < endAngleIndex) {\n        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n      } else {\n        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n      }\n    }\n\n    for (let i = 0; i < angles.length; i++) {\n      let point = this.point(angles[i]);\n      box.wrapPoint(point);\n      box.wrapPoint(point, innerRadius);\n    }\n\n    if (!innerRadius) {\n      box.wrapPoint(this.center);\n    }\n\n    return box;\n  }\n\n  expand(value) {\n    this.radius += value;\n    return this;\n  }\n\n}\n\nfunction numericComparer(a, b) {\n  return a - b;\n}\n\nexport default Ring;","map":null,"metadata":{},"sourceType":"module"}