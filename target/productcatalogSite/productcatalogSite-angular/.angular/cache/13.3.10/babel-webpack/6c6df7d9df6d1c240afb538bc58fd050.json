{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1179);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1057:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  1138:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  1179:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1138), __webpack_require__(1057)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"dataviz.qrcode\",\n        name: \"QRCode\",\n        category: \"dataviz\",\n        description: \"QRCode widget.\",\n        depends: [\"dataviz.core\", \"drawing\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            extend = $.extend,\n            draw = kendo.drawing,\n            dataviz = kendo.dataviz,\n            Widget = kendo.ui.Widget,\n            Box2D = dataviz.Box2D,\n            terminator = \"0000\",\n            NUMERIC = \"numeric\",\n            ALPHA_NUMERIC = \"alphanumeric\",\n            BYTE = \"byte\",\n            powersOfTwo = {\n          \"1\": 0\n        },\n            powersOfTwoResult = {\n          \"0\": 1\n        },\n            generatorPolynomials = [[1, 0], [1, 25, 0]],\n            irregularAlignmentPatternsStartDistance = {\n          15: 20,\n          16: 20,\n          18: 24,\n          19: 24,\n          22: 20,\n          24: 22,\n          26: 24,\n          28: 20,\n          30: 20,\n          31: 24,\n          32: 28,\n          33: 24,\n          36: 18,\n          37: 22,\n          39: 20,\n          40: 24\n        },\n            versionsCodewordsInformation = [{\n          L: {\n            groups: [[1, 19]],\n            totalDataCodewords: 19,\n            errorCodewordsPerBlock: 7\n          },\n          M: {\n            groups: [[1, 16]],\n            totalDataCodewords: 16,\n            errorCodewordsPerBlock: 10\n          },\n          Q: {\n            groups: [[1, 13]],\n            totalDataCodewords: 13,\n            errorCodewordsPerBlock: 13\n          },\n          H: {\n            groups: [[1, 9]],\n            totalDataCodewords: 9,\n            errorCodewordsPerBlock: 17\n          }\n        }, {\n          L: {\n            groups: [[1, 34]],\n            totalDataCodewords: 34,\n            errorCodewordsPerBlock: 10\n          },\n          M: {\n            groups: [[1, 28]],\n            totalDataCodewords: 28,\n            errorCodewordsPerBlock: 16\n          },\n          Q: {\n            groups: [[1, 22]],\n            totalDataCodewords: 22,\n            errorCodewordsPerBlock: 22\n          },\n          H: {\n            groups: [[1, 16]],\n            totalDataCodewords: 16,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[1, 55]],\n            totalDataCodewords: 55,\n            errorCodewordsPerBlock: 15\n          },\n          M: {\n            groups: [[1, 44]],\n            totalDataCodewords: 44,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[2, 17]],\n            totalDataCodewords: 34,\n            errorCodewordsPerBlock: 18\n          },\n          H: {\n            groups: [[2, 13]],\n            totalDataCodewords: 26,\n            errorCodewordsPerBlock: 22\n          }\n        }, {\n          L: {\n            groups: [[1, 80]],\n            totalDataCodewords: 80,\n            errorCodewordsPerBlock: 20\n          },\n          M: {\n            groups: [[2, 32]],\n            totalDataCodewords: 64,\n            errorCodewordsPerBlock: 18\n          },\n          Q: {\n            groups: [[2, 24]],\n            totalDataCodewords: 48,\n            errorCodewordsPerBlock: 26\n          },\n          H: {\n            groups: [[4, 9]],\n            totalDataCodewords: 36,\n            errorCodewordsPerBlock: 16\n          }\n        }, {\n          L: {\n            groups: [[1, 108]],\n            totalDataCodewords: 108,\n            errorCodewordsPerBlock: 26\n          },\n          M: {\n            groups: [[2, 43]],\n            totalDataCodewords: 86,\n            errorCodewordsPerBlock: 24\n          },\n          Q: {\n            groups: [[2, 15], [2, 16]],\n            totalDataCodewords: 62,\n            errorCodewordsPerBlock: 18\n          },\n          H: {\n            groups: [[2, 11], [2, 12]],\n            totalDataCodewords: 46,\n            errorCodewordsPerBlock: 22\n          }\n        }, {\n          L: {\n            groups: [[2, 68]],\n            totalDataCodewords: 136,\n            errorCodewordsPerBlock: 18\n          },\n          M: {\n            groups: [[4, 27]],\n            totalDataCodewords: 108,\n            errorCodewordsPerBlock: 16\n          },\n          Q: {\n            groups: [[4, 19]],\n            totalDataCodewords: 76,\n            errorCodewordsPerBlock: 24\n          },\n          H: {\n            groups: [[4, 15]],\n            totalDataCodewords: 60,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[2, 78]],\n            totalDataCodewords: 156,\n            errorCodewordsPerBlock: 20\n          },\n          M: {\n            groups: [[4, 31]],\n            totalDataCodewords: 124,\n            errorCodewordsPerBlock: 18\n          },\n          Q: {\n            groups: [[2, 14], [4, 15]],\n            totalDataCodewords: 88,\n            errorCodewordsPerBlock: 18\n          },\n          H: {\n            groups: [[4, 13], [1, 14]],\n            totalDataCodewords: 66,\n            errorCodewordsPerBlock: 26\n          }\n        }, {\n          L: {\n            groups: [[2, 97]],\n            totalDataCodewords: 194,\n            errorCodewordsPerBlock: 24\n          },\n          M: {\n            groups: [[2, 38], [2, 39]],\n            totalDataCodewords: 154,\n            errorCodewordsPerBlock: 22\n          },\n          Q: {\n            groups: [[4, 18], [2, 19]],\n            totalDataCodewords: 110,\n            errorCodewordsPerBlock: 22\n          },\n          H: {\n            groups: [[4, 14], [2, 15]],\n            totalDataCodewords: 86,\n            errorCodewordsPerBlock: 26\n          }\n        }, {\n          L: {\n            groups: [[2, 116]],\n            totalDataCodewords: 232,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[3, 36], [2, 37]],\n            totalDataCodewords: 182,\n            errorCodewordsPerBlock: 22\n          },\n          Q: {\n            groups: [[4, 16], [4, 17]],\n            totalDataCodewords: 132,\n            errorCodewordsPerBlock: 20\n          },\n          H: {\n            groups: [[4, 12], [4, 13]],\n            totalDataCodewords: 100,\n            errorCodewordsPerBlock: 24\n          }\n        }, {\n          L: {\n            groups: [[2, 68], [2, 69]],\n            totalDataCodewords: 274,\n            errorCodewordsPerBlock: 18\n          },\n          M: {\n            groups: [[4, 43], [1, 44]],\n            totalDataCodewords: 216,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[6, 19], [2, 20]],\n            totalDataCodewords: 154,\n            errorCodewordsPerBlock: 24\n          },\n          H: {\n            groups: [[6, 15], [2, 16]],\n            totalDataCodewords: 122,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[4, 81]],\n            totalDataCodewords: 324,\n            errorCodewordsPerBlock: 20\n          },\n          M: {\n            groups: [[1, 50], [4, 51]],\n            totalDataCodewords: 254,\n            errorCodewordsPerBlock: 30\n          },\n          Q: {\n            groups: [[4, 22], [4, 23]],\n            totalDataCodewords: 180,\n            errorCodewordsPerBlock: 28\n          },\n          H: {\n            groups: [[3, 12], [8, 13]],\n            totalDataCodewords: 140,\n            errorCodewordsPerBlock: 24\n          }\n        }, {\n          L: {\n            groups: [[2, 92], [2, 93]],\n            totalDataCodewords: 370,\n            errorCodewordsPerBlock: 24\n          },\n          M: {\n            groups: [[6, 36], [2, 37]],\n            totalDataCodewords: 290,\n            errorCodewordsPerBlock: 22\n          },\n          Q: {\n            groups: [[4, 20], [6, 21]],\n            totalDataCodewords: 206,\n            errorCodewordsPerBlock: 26\n          },\n          H: {\n            groups: [[7, 14], [4, 15]],\n            totalDataCodewords: 158,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[4, 107]],\n            totalDataCodewords: 428,\n            errorCodewordsPerBlock: 26\n          },\n          M: {\n            groups: [[8, 37], [1, 38]],\n            totalDataCodewords: 334,\n            errorCodewordsPerBlock: 22\n          },\n          Q: {\n            groups: [[8, 20], [4, 21]],\n            totalDataCodewords: 244,\n            errorCodewordsPerBlock: 24\n          },\n          H: {\n            groups: [[12, 11], [4, 12]],\n            totalDataCodewords: 180,\n            errorCodewordsPerBlock: 22\n          }\n        }, {\n          L: {\n            groups: [[3, 115], [1, 116]],\n            totalDataCodewords: 461,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[4, 40], [5, 41]],\n            totalDataCodewords: 365,\n            errorCodewordsPerBlock: 24\n          },\n          Q: {\n            groups: [[11, 16], [5, 17]],\n            totalDataCodewords: 261,\n            errorCodewordsPerBlock: 20\n          },\n          H: {\n            groups: [[11, 12], [5, 13]],\n            totalDataCodewords: 197,\n            errorCodewordsPerBlock: 24\n          }\n        }, {\n          L: {\n            groups: [[5, 87], [1, 88]],\n            totalDataCodewords: 523,\n            errorCodewordsPerBlock: 22\n          },\n          M: {\n            groups: [[5, 41], [5, 42]],\n            totalDataCodewords: 415,\n            errorCodewordsPerBlock: 24\n          },\n          Q: {\n            groups: [[5, 24], [7, 25]],\n            totalDataCodewords: 295,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[11, 12], [7, 13]],\n            totalDataCodewords: 223,\n            errorCodewordsPerBlock: 24\n          }\n        }, {\n          L: {\n            groups: [[5, 98], [1, 99]],\n            totalDataCodewords: 589,\n            errorCodewordsPerBlock: 24\n          },\n          M: {\n            groups: [[7, 45], [3, 46]],\n            totalDataCodewords: 453,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[15, 19], [2, 20]],\n            totalDataCodewords: 325,\n            errorCodewordsPerBlock: 24\n          },\n          H: {\n            groups: [[3, 15], [13, 16]],\n            totalDataCodewords: 253,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[1, 107], [5, 108]],\n            totalDataCodewords: 647,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[10, 46], [1, 47]],\n            totalDataCodewords: 507,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[1, 22], [15, 23]],\n            totalDataCodewords: 367,\n            errorCodewordsPerBlock: 28\n          },\n          H: {\n            groups: [[2, 14], [17, 15]],\n            totalDataCodewords: 283,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[5, 120], [1, 121]],\n            totalDataCodewords: 721,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[9, 43], [4, 44]],\n            totalDataCodewords: 563,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[17, 22], [1, 23]],\n            totalDataCodewords: 397,\n            errorCodewordsPerBlock: 28\n          },\n          H: {\n            groups: [[2, 14], [19, 15]],\n            totalDataCodewords: 313,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[3, 113], [4, 114]],\n            totalDataCodewords: 795,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[3, 44], [11, 45]],\n            totalDataCodewords: 627,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[17, 21], [4, 22]],\n            totalDataCodewords: 445,\n            errorCodewordsPerBlock: 26\n          },\n          H: {\n            groups: [[9, 13], [16, 14]],\n            totalDataCodewords: 341,\n            errorCodewordsPerBlock: 26\n          }\n        }, {\n          L: {\n            groups: [[3, 107], [5, 108]],\n            totalDataCodewords: 861,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[3, 41], [13, 42]],\n            totalDataCodewords: 669,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[15, 24], [5, 25]],\n            totalDataCodewords: 485,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[15, 15], [10, 16]],\n            totalDataCodewords: 385,\n            errorCodewordsPerBlock: 28\n          }\n        }, {\n          L: {\n            groups: [[4, 116], [4, 117]],\n            totalDataCodewords: 932,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[17, 42]],\n            totalDataCodewords: 714,\n            errorCodewordsPerBlock: 26\n          },\n          Q: {\n            groups: [[17, 22], [6, 23]],\n            totalDataCodewords: 512,\n            errorCodewordsPerBlock: 28\n          },\n          H: {\n            groups: [[19, 16], [6, 17]],\n            totalDataCodewords: 406,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[2, 111], [7, 112]],\n            totalDataCodewords: 1006,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[17, 46]],\n            totalDataCodewords: 782,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[7, 24], [16, 25]],\n            totalDataCodewords: 568,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[34, 13]],\n            totalDataCodewords: 442,\n            errorCodewordsPerBlock: 24\n          }\n        }, {\n          L: {\n            groups: [[4, 121], [5, 122]],\n            totalDataCodewords: 1094,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[4, 47], [14, 48]],\n            totalDataCodewords: 860,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[11, 24], [14, 25]],\n            totalDataCodewords: 614,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[16, 15], [14, 16]],\n            totalDataCodewords: 464,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[6, 117], [4, 118]],\n            totalDataCodewords: 1174,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[6, 45], [14, 46]],\n            totalDataCodewords: 914,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[11, 24], [16, 25]],\n            totalDataCodewords: 664,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[30, 16], [2, 17]],\n            totalDataCodewords: 514,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[8, 106], [4, 107]],\n            totalDataCodewords: 1276,\n            errorCodewordsPerBlock: 26\n          },\n          M: {\n            groups: [[8, 47], [13, 48]],\n            totalDataCodewords: 1000,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[7, 24], [22, 25]],\n            totalDataCodewords: 718,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[22, 15], [13, 16]],\n            totalDataCodewords: 538,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[10, 114], [2, 115]],\n            totalDataCodewords: 1370,\n            errorCodewordsPerBlock: 28\n          },\n          M: {\n            groups: [[19, 46], [4, 47]],\n            totalDataCodewords: 1062,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[28, 22], [6, 23]],\n            totalDataCodewords: 754,\n            errorCodewordsPerBlock: 28\n          },\n          H: {\n            groups: [[33, 16], [4, 17]],\n            totalDataCodewords: 596,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[8, 122], [4, 123]],\n            totalDataCodewords: 1468,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[22, 45], [3, 46]],\n            totalDataCodewords: 1128,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[8, 23], [26, 24]],\n            totalDataCodewords: 808,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[12, 15], [28, 16]],\n            totalDataCodewords: 628,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[3, 117], [10, 118]],\n            totalDataCodewords: 1531,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[3, 45], [23, 46]],\n            totalDataCodewords: 1193,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[4, 24], [31, 25]],\n            totalDataCodewords: 871,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[11, 15], [31, 16]],\n            totalDataCodewords: 661,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[7, 116], [7, 117]],\n            totalDataCodewords: 1631,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[21, 45], [7, 46]],\n            totalDataCodewords: 1267,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[1, 23], [37, 24]],\n            totalDataCodewords: 911,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[19, 15], [26, 16]],\n            totalDataCodewords: 701,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[5, 115], [10, 116]],\n            totalDataCodewords: 1735,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[19, 47], [10, 48]],\n            totalDataCodewords: 1373,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[15, 24], [25, 25]],\n            totalDataCodewords: 985,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[23, 15], [25, 16]],\n            totalDataCodewords: 745,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[13, 115], [3, 116]],\n            totalDataCodewords: 1843,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[2, 46], [29, 47]],\n            totalDataCodewords: 1455,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[42, 24], [1, 25]],\n            totalDataCodewords: 1033,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[23, 15], [28, 16]],\n            totalDataCodewords: 793,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[17, 115]],\n            totalDataCodewords: 1955,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[10, 46], [23, 47]],\n            totalDataCodewords: 1541,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[10, 24], [35, 25]],\n            totalDataCodewords: 1115,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[19, 15], [35, 16]],\n            totalDataCodewords: 845,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[17, 115], [1, 116]],\n            totalDataCodewords: 2071,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[14, 46], [21, 47]],\n            totalDataCodewords: 1631,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[29, 24], [19, 25]],\n            totalDataCodewords: 1171,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[11, 15], [46, 16]],\n            totalDataCodewords: 901,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[13, 115], [6, 116]],\n            totalDataCodewords: 2191,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[14, 46], [23, 47]],\n            totalDataCodewords: 1725,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[44, 24], [7, 25]],\n            totalDataCodewords: 1231,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[59, 16], [1, 17]],\n            totalDataCodewords: 961,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[12, 121], [7, 122]],\n            totalDataCodewords: 2306,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[12, 47], [26, 48]],\n            totalDataCodewords: 1812,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[39, 24], [14, 25]],\n            totalDataCodewords: 1286,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[22, 15], [41, 16]],\n            totalDataCodewords: 986,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[6, 121], [14, 122]],\n            totalDataCodewords: 2434,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[6, 47], [34, 48]],\n            totalDataCodewords: 1914,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[46, 24], [10, 25]],\n            totalDataCodewords: 1354,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[2, 15], [64, 16]],\n            totalDataCodewords: 1054,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[17, 122], [4, 123]],\n            totalDataCodewords: 2566,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[29, 46], [14, 47]],\n            totalDataCodewords: 1992,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[49, 24], [10, 25]],\n            totalDataCodewords: 1426,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[24, 15], [46, 16]],\n            totalDataCodewords: 1096,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[4, 122], [18, 123]],\n            totalDataCodewords: 2702,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[13, 46], [32, 47]],\n            totalDataCodewords: 2102,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[48, 24], [14, 25]],\n            totalDataCodewords: 1502,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[42, 15], [32, 16]],\n            totalDataCodewords: 1142,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[20, 117], [4, 118]],\n            totalDataCodewords: 2812,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[40, 47], [7, 48]],\n            totalDataCodewords: 2216,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[43, 24], [22, 25]],\n            totalDataCodewords: 1582,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[10, 15], [67, 16]],\n            totalDataCodewords: 1222,\n            errorCodewordsPerBlock: 30\n          }\n        }, {\n          L: {\n            groups: [[19, 118], [6, 119]],\n            totalDataCodewords: 2956,\n            errorCodewordsPerBlock: 30\n          },\n          M: {\n            groups: [[18, 47], [31, 48]],\n            totalDataCodewords: 2334,\n            errorCodewordsPerBlock: 28\n          },\n          Q: {\n            groups: [[34, 24], [34, 25]],\n            totalDataCodewords: 1666,\n            errorCodewordsPerBlock: 30\n          },\n          H: {\n            groups: [[20, 15], [61, 16]],\n            totalDataCodewords: 1276,\n            errorCodewordsPerBlock: 30\n          }\n        }],\n            finderPattern = [1, 0, 1, 1, 1],\n            alignmentPattern = [1, 0, 1],\n            errorCorrectionPatterns = {\n          L: \"01\",\n          M: \"00\",\n          Q: \"11\",\n          H: \"10\"\n        },\n            formatMaskPattern = \"101010000010010\",\n            formatGeneratorPolynomial = \"10100110111\",\n            versionGeneratorPolynomial = \"1111100100101\",\n            paddingCodewords = [\"11101100\", \"00010001\"],\n            finderPatternValue = 93,\n            maskPatternConditions = [function (row, column) {\n          return (row + column) % 2 === 0;\n        }, function (row) {\n          return row % 2 === 0;\n        }, function (row, column) {\n          return column % 3 === 0;\n        }, function (row, column) {\n          return (row + column) % 3 === 0;\n        }, function (row, column) {\n          return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;\n        }, function (row, column) {\n          return row * column % 2 + row * column % 3 === 0;\n        }, function (row, column) {\n          return (row * column % 2 + row * column % 3) % 2 === 0;\n        }, function (row, column) {\n          return ((row + column) % 2 + row * column % 3) % 2 === 0;\n        }],\n            numberRegex = /^\\d+/,\n            alphaPattern = \"A-Z0-9 $%*+./:-\",\n            alphaExclusiveSet = \"A-Z $%*+./:-\",\n            alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n            alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n            byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n            initMinNumericBeforeAlpha = 8,\n            initMinNumericBeforeByte = 5,\n            initMinAlphaBeforeByte = 8,\n            minNumericBeforeAlpha = 17,\n            minNumericBeforeByte = 9,\n            minAlphaBeforeByte = 16,\n            round = Math.round,\n            IMAGE = \"image\",\n            SWISS_QR = \"swiss\",\n            crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]],\n            squarePattern = [[0, 1], [1, 1], [1, 0]],\n            DEFAULT_LOGO_SIZE = 7;\n\n        function toDecimal(value) {\n          return parseInt(value, 2);\n        }\n\n        function toBitsString(value, length) {\n          var result = Number(value).toString(2);\n\n          if (result.length < length) {\n            result = new Array(length - result.length + 1).join(0) + result;\n          }\n\n          return result;\n        }\n\n        function splitInto(str, n) {\n          var result = [],\n              idx = 0;\n\n          while (idx < str.length) {\n            result.push(str.substring(idx, idx + n));\n            idx += n;\n          }\n\n          return result;\n        }\n\n        var QRDataMode = kendo.Class.extend({\n          getVersionIndex: function (version) {\n            if (version < 10) {\n              return 0;\n            } else if (version > 26) {\n              return 2;\n            }\n\n            return 1;\n          },\n          getBitsCharacterCount: function (version) {\n            var mode = this;\n            return mode.bitsInCharacterCount[mode.getVersionIndex(version || 40)];\n          },\n          getModeCountString: function (length, version) {\n            var mode = this;\n            return mode.modeIndicator + toBitsString(length, mode.getBitsCharacterCount(version));\n          },\n          encode: function () {},\n          getStringBitsLength: function () {},\n          getValue: function () {},\n          modeIndicator: \"\",\n          bitsInCharacterCount: []\n        });\n        var modes = {};\n        modes[NUMERIC] = QRDataMode.extend({\n          bitsInCharacterCount: [10, 12, 14],\n          modeIndicator: \"0001\",\n          getValue: function (character) {\n            return parseInt(character, 10);\n          },\n          encode: function (str, version) {\n            var mode = this,\n                parts = splitInto(str, 3),\n                result = mode.getModeCountString(str.length, version);\n\n            for (var i = 0; i < parts.length - 1; i++) {\n              result += toBitsString(parts[i], 10);\n            }\n\n            return result + toBitsString(parts[i], 1 + 3 * parts[i].length);\n          },\n          getStringBitsLength: function (inputLength, version) {\n            var mod3 = inputLength % 3;\n            return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);\n          }\n        });\n        modes[ALPHA_NUMERIC] = QRDataMode.extend({\n          characters: {\n            \"0\": 0,\n            \"1\": 1,\n            \"2\": 2,\n            \"3\": 3,\n            \"4\": 4,\n            \"5\": 5,\n            \"6\": 6,\n            \"7\": 7,\n            \"8\": 8,\n            \"9\": 9,\n            \"A\": 10,\n            \"B\": 11,\n            \"C\": 12,\n            \"D\": 13,\n            \"E\": 14,\n            \"F\": 15,\n            \"G\": 16,\n            \"H\": 17,\n            \"I\": 18,\n            \"J\": 19,\n            \"K\": 20,\n            \"L\": 21,\n            \"M\": 22,\n            \"N\": 23,\n            \"O\": 24,\n            \"P\": 25,\n            \"Q\": 26,\n            \"R\": 27,\n            \"S\": 28,\n            \"T\": 29,\n            \"U\": 30,\n            \"V\": 31,\n            \"W\": 32,\n            \"X\": 33,\n            \"Y\": 34,\n            \"Z\": 35,\n            \" \": 36,\n            \"$\": 37,\n            \"%\": 38,\n            \"*\": 39,\n            \"+\": 40,\n            \"-\": 41,\n            \".\": 42,\n            \"/\": 43,\n            \":\": 44\n          },\n          bitsInCharacterCount: [9, 11, 13],\n          modeIndicator: \"0010\",\n          getValue: function (character) {\n            return this.characters[character];\n          },\n          encode: function (str, version) {\n            var mode = this,\n                parts = splitInto(str, 2),\n                result = mode.getModeCountString(str.length, version),\n                value;\n\n            for (var i = 0; i < parts.length - 1; i++) {\n              value = 45 * mode.getValue(parts[i].charAt(0)) + mode.getValue(parts[i].charAt(1));\n              result += toBitsString(value, 11);\n            }\n\n            value = parts[i].length == 2 ? 45 * mode.getValue(parts[i].charAt(0)) + mode.getValue(parts[i].charAt(1)) : mode.getValue(parts[i].charAt(0));\n            return result + toBitsString(value, 1 + 5 * parts[i].length);\n          },\n          getStringBitsLength: function (inputLength, version) {\n            return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);\n          }\n        });\n        modes[BYTE] = QRDataMode.extend({\n          bitsInCharacterCount: [8, 16, 16],\n          modeIndicator: \"0100\",\n          getValue: function (character) {\n            var code = character.charCodeAt(0);\n\n            if (code <= 127 || 160 <= code && code <= 255) {\n              return code;\n            } else {\n              throw new Error(\"Unsupported character: \" + character);\n            }\n          },\n          encode: function (str, version) {\n            var mode = this,\n                result = mode.getModeCountString(str.length, version);\n\n            for (var i = 0; i < str.length; i++) {\n              result += toBitsString(mode.getValue(str.charAt(i)), 8);\n            }\n\n            return result;\n          },\n          getStringBitsLength: function (inputLength, version) {\n            return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;\n          }\n        });\n        var modeInstances = {};\n\n        for (var mode in modes) {\n          modeInstances[mode] = new modes[mode]();\n        }\n\n        var FreeCellVisitor = function (matrix) {\n          var that = this,\n              row = matrix.length - 1,\n              column = matrix.length - 1,\n              startColumn = column,\n              dir = -1,\n              c = 0;\n\n          that.move = function () {\n            row += dir * c;\n            c ^= 1;\n            column = startColumn - c;\n          };\n\n          that.getNextCell = function () {\n            while (matrix[row][column] !== undefined) {\n              that.move();\n\n              if (row < 0 || row >= matrix.length) {\n                dir = -dir;\n                startColumn -= startColumn != 8 ? 2 : 3;\n                column = startColumn;\n                row = dir < 0 ? matrix.length - 1 : 0;\n              }\n            }\n\n            return {\n              row: row,\n              column: column\n            };\n          };\n\n          that.getNextRemainderCell = function () {\n            that.move();\n\n            if (matrix[row][column] === undefined) {\n              return {\n                row: row,\n                column: column\n              };\n            }\n          };\n        };\n\n        function fillFunctionCell(matrices, bit, x, y) {\n          for (var i = 0; i < matrices.length; i++) {\n            matrices[i][x][y] = bit;\n          }\n        }\n\n        function fillDataCell(matrices, bit, x, y) {\n          for (var i = 0; i < maskPatternConditions.length; i++) {\n            matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n          }\n        }\n\n        var fillData = function (matrices, blocks) {\n          var cellVisitor = new FreeCellVisitor(matrices[0]),\n              block,\n              codewordIdx,\n              cell;\n\n          for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n            block = blocks[blockIdx];\n            codewordIdx = 0;\n\n            while (block.length > 0) {\n              for (var i = 0; i < block.length; i++) {\n                for (var j = 0; j < 8; j++) {\n                  cell = cellVisitor.getNextCell();\n                  fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n                }\n              }\n\n              codewordIdx++;\n\n              while (block[0] && codewordIdx == block[0].length) {\n                block.splice(0, 1);\n              }\n            }\n          }\n\n          while (cell = cellVisitor.getNextRemainderCell()) {\n            fillDataCell(matrices, 0, cell.row, cell.column);\n          }\n        };\n\n        var padDataString = function (dataString, totalDataCodewords) {\n          var dataBitsCount = totalDataCodewords * 8,\n              terminatorIndex = 0,\n              paddingCodewordIndex = 0;\n\n          while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n            dataString += terminator.charAt(terminatorIndex++);\n          }\n\n          if (dataString.length % 8 !== 0) {\n            dataString += new Array(9 - dataString.length % 8).join(\"0\");\n          }\n\n          while (dataString.length < dataBitsCount) {\n            dataString += paddingCodewords[paddingCodewordIndex];\n            paddingCodewordIndex ^= 1;\n          }\n\n          return dataString;\n        };\n\n        function generatePowersOfTwo() {\n          var result;\n\n          for (var power = 1; power < 255; power++) {\n            result = powersOfTwoResult[power - 1] * 2;\n\n            if (result > 255) {\n              result = result ^ 285;\n            }\n\n            powersOfTwoResult[power] = result;\n            powersOfTwo[result] = power;\n          }\n\n          result = powersOfTwoResult[power - 1] * 2 ^ 285;\n          powersOfTwoResult[power] = result;\n          powersOfTwoResult[-1] = 0;\n        }\n\n        var xorPolynomials = function (x, y) {\n          var result = [],\n              idx = x.length - 2;\n\n          for (var i = idx; i >= 0; i--) {\n            result[i] = x[i] ^ y[i];\n          }\n\n          return result;\n        };\n\n        var multiplyPolynomials = function (x, y) {\n          var result = [];\n\n          for (var i = 0; i < x.length; i++) {\n            for (var j = 0; j < y.length; j++) {\n              if (result[i + j] === undefined) {\n                result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n              } else {\n                result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n              }\n            }\n          }\n\n          return result;\n        };\n\n        function generateGeneratorPolynomials() {\n          var maxErrorCorrectionCodeWordsCount = 68;\n\n          for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n            var firstPolynomial = generatorPolynomials[idx - 1],\n                secondPolynomial = [idx, 0];\n            generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n          }\n        } //possibly generate on demand\n\n\n        generatePowersOfTwo();\n        generateGeneratorPolynomials();\n\n        function multiplyByConstant(polynomial, power) {\n          var result = [],\n              idx = polynomial.length - 1;\n\n          do {\n            result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n            idx--;\n          } while (polynomial[idx] !== undefined);\n\n          return result;\n        }\n\n        var generateErrorCodewords = function (data, errorCodewordsCount) {\n          var generator = generatorPolynomials[errorCodewordsCount - 1],\n              result = new Array(errorCodewordsCount).concat(data),\n              generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n              steps = data.length,\n              errorCodewords = [],\n              divisor,\n              idx;\n\n          for (idx = 0; idx < steps; idx++) {\n            divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n            generatorPolynomial.splice(0, 1);\n            result = xorPolynomials(divisor, result);\n          }\n\n          for (idx = result.length - 1; idx >= 0; idx--) {\n            errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n          }\n\n          return errorCodewords;\n        };\n\n        var getBlocks = function (dataStream, versionCodewordsInformation) {\n          var codewordStart = 0,\n              dataBlocks = [],\n              errorBlocks = [],\n              dataBlock,\n              versionGroups = versionCodewordsInformation.groups,\n              blockCodewordsCount,\n              groupBlocksCount,\n              messagePolynomial,\n              codeword;\n\n          for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n            groupBlocksCount = versionGroups[groupIdx][0];\n\n            for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n              blockCodewordsCount = versionGroups[groupIdx][1];\n              dataBlock = [];\n              messagePolynomial = [];\n\n              for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n                codeword = dataStream.substring(codewordStart, codewordStart + 8);\n                dataBlock.push(codeword);\n                messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n                codewordStart += 8;\n              }\n\n              dataBlocks.push(dataBlock);\n              errorBlocks.push(generateErrorCodewords(messagePolynomial, versionCodewordsInformation.errorCodewordsPerBlock));\n            }\n          }\n\n          return [dataBlocks, errorBlocks];\n        };\n\n        var chooseMode = function (str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n          var numeric = numberRegex.exec(str),\n              numericMatch = numeric ? numeric[0] : \"\",\n              alpha = alphaRegex.exec(str),\n              alphaMatch = alpha ? alpha[0] : \"\",\n              alphaNumeric = alphaNumericRegex.exec(str),\n              alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n              mode,\n              modeString;\n\n          if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha || str.length == numericMatch.length || numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {\n            mode = NUMERIC;\n            modeString = numericMatch;\n          } else if (alphaNumericMatch && (str.length == alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte || previousMode == ALPHA_NUMERIC)) {\n            mode = ALPHA_NUMERIC;\n            modeString = numericMatch || alphaMatch;\n          } else {\n            mode = BYTE;\n\n            if (alphaNumericMatch) {\n              modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n            } else {\n              modeString = byteRegex.exec(str)[0];\n            }\n          }\n\n          return {\n            mode: mode,\n            modeString: modeString\n          };\n        };\n\n        var getModes = function (str) {\n          var modes = [],\n              previousMode,\n              idx = 0;\n          modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n          previousMode = modes[0].mode;\n          str = str.substr(modes[0].modeString.length);\n\n          while (str.length > 0) {\n            var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n\n            if (nextMode.mode != previousMode) {\n              previousMode = nextMode.mode;\n              modes.push(nextMode);\n              idx++;\n            } else {\n              modes[idx].modeString += nextMode.modeString;\n            }\n\n            str = str.substr(nextMode.modeString.length);\n          }\n\n          return modes;\n        };\n\n        var getDataCodewordsCount = function (modes) {\n          var length = 0,\n              mode;\n\n          for (var i = 0; i < modes.length; i++) {\n            mode = modeInstances[modes[i].mode];\n            length += mode.getStringBitsLength(modes[i].modeString.length);\n          }\n\n          return Math.ceil(length / 8);\n        };\n\n        var getVersion = function (dataCodewordsCount, errorCorrectionLevel) {\n          var x = 0,\n              y = versionsCodewordsInformation.length - 1,\n              version = Math.floor(versionsCodewordsInformation.length / 2);\n\n          do {\n            if (dataCodewordsCount < versionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n              y = version;\n            } else {\n              x = version;\n            }\n\n            version = x + Math.floor((y - x) / 2);\n          } while (y - x > 1);\n\n          if (dataCodewordsCount <= versionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n            return version + 1;\n          }\n\n          return y + 1;\n        };\n\n        var getDataString = function (modes, version) {\n          var dataString = \"\",\n              mode;\n\n          for (var i = 0; i < modes.length; i++) {\n            mode = modeInstances[modes[i].mode];\n            dataString += mode.encode(modes[i].modeString, version);\n          }\n\n          return dataString;\n        }; //fix case all zeros\n\n\n        var encodeFormatInformation = function (format) {\n          var formatNumber = toDecimal(format),\n              encodedString,\n              result = \"\";\n\n          if (formatNumber === 0) {\n            return \"101010000010010\";\n          } else {\n            encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n          }\n\n          for (var i = 0; i < encodedString.length; i++) {\n            result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n          }\n\n          return result;\n        };\n\n        var encodeBCH = function (value, generatorPolynomial, codeLength) {\n          var generatorNumber = toDecimal(generatorPolynomial),\n              polynomialLength = generatorPolynomial.length - 1,\n              valueNumber = value << polynomialLength,\n              length = codeLength - polynomialLength,\n              valueString = toBitsString(value, length),\n              result = dividePolynomials(valueNumber, generatorNumber);\n          result = valueString + toBitsString(result, polynomialLength);\n          return result;\n        };\n\n        var dividePolynomials = function (numberX, numberY) {\n          var yLength = numberY.toString(2).length,\n              xLength = numberX.toString(2).length;\n\n          do {\n            numberX ^= numberY << xLength - yLength;\n            xLength = numberX.toString(2).length;\n          } while (xLength >= yLength);\n\n          return numberX;\n        };\n\n        function getNumberAt(str, idx) {\n          return parseInt(str.charAt(idx), 10);\n        }\n\n        var initMatrices = function (version) {\n          var matrices = [],\n              modules = 17 + 4 * version;\n\n          for (var i = 0; i < maskPatternConditions.length; i++) {\n            matrices[i] = new Array(modules);\n\n            for (var j = 0; j < modules; j++) {\n              matrices[i][j] = new Array(modules);\n            }\n          }\n\n          return matrices;\n        };\n\n        var addFormatInformation = function (matrices, formatString) {\n          var matrix = matrices[0],\n              x,\n              y,\n              idx = 0,\n              length = formatString.length;\n\n          for (x = 0, y = 8; x <= 8; x++) {\n            if (x !== 6) {\n              fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n            }\n          }\n\n          for (x = 8, y = 7; y >= 0; y--) {\n            if (y !== 6) {\n              fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n            }\n          }\n\n          idx = 0;\n\n          for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n          }\n\n          fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n\n          for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n          }\n        };\n\n        var encodeVersionInformation = function (version) {\n          return encodeBCH(version, versionGeneratorPolynomial, 18);\n        };\n\n        var addVersionInformation = function (matrices, dataString) {\n          var matrix = matrices[0],\n              modules = matrix.length,\n              x1 = 0,\n              y1 = modules - 11,\n              x2 = modules - 11,\n              y2 = 0,\n              quotient,\n              mod,\n              value;\n\n          for (var idx = 0; idx < dataString.length; idx++) {\n            quotient = Math.floor(idx / 3);\n            mod = idx % 3;\n            value = getNumberAt(dataString, dataString.length - idx - 1);\n            fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n            fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n          }\n        };\n\n        var addCentricPattern = function (matrices, pattern, x, y) {\n          var size = pattern.length + 2,\n              length = pattern.length + 1,\n              value;\n\n          for (var i = 0; i < pattern.length; i++) {\n            for (var j = i; j < size - i; j++) {\n              value = pattern[i];\n              fillFunctionCell(matrices, value, x + j, y + i);\n              fillFunctionCell(matrices, value, x + i, y + j);\n              fillFunctionCell(matrices, value, x + length - j, y + length - i);\n              fillFunctionCell(matrices, value, x + length - i, y + length - j);\n            }\n          }\n        };\n\n        var addFinderSeparator = function (matrices, direction, x, y) {\n          var nextX = x,\n              nextY = y,\n              matrix = matrices[0];\n\n          do {\n            fillFunctionCell(matrices, 0, nextX, y);\n            fillFunctionCell(matrices, 0, x, nextY);\n            nextX += direction[0];\n            nextY += direction[1];\n          } while (nextX >= 0 && nextX < matrix.length);\n        };\n\n        var addFinderPatterns = function (matrices) {\n          var modules = matrices[0].length;\n          addCentricPattern(matrices, finderPattern, 0, 0);\n          addFinderSeparator(matrices, [-1, -1], 7, 7);\n          addCentricPattern(matrices, finderPattern, modules - 7, 0);\n          addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n          addCentricPattern(matrices, finderPattern, 0, modules - 7);\n          addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n        };\n\n        var addAlignmentPatterns = function (matrices, version) {\n          if (version < 2) {\n            return;\n          }\n\n          var matrix = matrices[0],\n              modules = matrix.length,\n              pointsCount = Math.floor(version / 7),\n              points = [6],\n              startDistance,\n              distance,\n              idx = 0;\n\n          if (startDistance = irregularAlignmentPatternsStartDistance[version]) {\n            distance = (modules - 13 - startDistance) / pointsCount;\n          } else {\n            startDistance = distance = (modules - 13) / (pointsCount + 1);\n          }\n\n          points.push(points[idx++] + startDistance);\n\n          while (points[idx] + distance < modules) {\n            points.push(points[idx++] + distance);\n          }\n\n          for (var i = 0; i < points.length; i++) {\n            for (var j = 0; j < points.length; j++) {\n              if (matrix[points[i]][points[j]] === undefined) {\n                addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n              }\n            }\n          }\n        };\n\n        var addTimingFunctions = function (matrices) {\n          var row = 6,\n              column = 6,\n              value = 1,\n              modules = matrices[0].length;\n\n          for (var i = 8; i < modules - 8; i++) {\n            fillFunctionCell(matrices, value, row, i);\n            fillFunctionCell(matrices, value, i, column);\n            value ^= 1;\n          }\n        };\n\n        var scoreMaskMatrixes = function (matrices) {\n          var scores = [],\n              previousBits = [],\n              darkModules = [],\n              patterns = [],\n              adjacentSameBits = [],\n              matrix,\n              i,\n              row = 0,\n              column = 1,\n              modules = matrices[0].length;\n\n          for (i = 0; i < matrices.length; i++) {\n            scores[i] = 0;\n            darkModules[i] = 0;\n            adjacentSameBits[i] = [0, 0];\n            patterns[i] = [0, 0];\n            previousBits[i] = [];\n          }\n\n          for (i = 0; i < modules; i++) {\n            for (var j = 0; j < modules; j++) {\n              for (var k = 0; k < matrices.length; k++) {\n                matrix = matrices[k];\n                darkModules[k] += parseInt(matrix[i][j], 10);\n\n                if (previousBits[k][row] === matrix[i][j] && i + 1 < modules && j - 1 >= 0 && matrix[i + 1][j] == previousBits[k][row] && matrix[i + 1][j - 1] == previousBits[k][row]) {\n                  scores[k] += 3;\n                }\n\n                scoreFinderPatternOccurance(k, patterns, scores, row, matrix[i][j]);\n                scoreFinderPatternOccurance(k, patterns, scores, column, matrix[j][i]);\n                scoreAdjacentSameBits(k, scores, previousBits, matrix[i][j], adjacentSameBits, row);\n                scoreAdjacentSameBits(k, scores, previousBits, matrix[j][i], adjacentSameBits, column);\n              }\n            }\n          }\n\n          var total = modules * modules,\n              minIdx,\n              min = Number.MAX_VALUE;\n\n          for (i = 0; i < scores.length; i++) {\n            scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n\n            if (scores[i] < min) {\n              min = scores[i];\n              minIdx = i;\n            }\n          }\n\n          return minIdx;\n        };\n\n        function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n          patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;\n\n          if (patterns[idx][rowColumn] == finderPatternValue) {\n            scores[idx] += 40;\n          }\n        }\n\n        function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n          if (previousBits[idx][rowColumn] == bit) {\n            adjacentBits[idx][rowColumn]++;\n          } else {\n            previousBits[idx][rowColumn] = bit;\n\n            if (adjacentBits[idx][rowColumn] >= 5) {\n              scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n            }\n\n            adjacentBits[idx][rowColumn] = 1;\n          }\n        }\n\n        function calculateDarkModulesRatioScore(darkModules, total) {\n          var percent = Math.floor(darkModules / total * 100),\n              mod5 = percent % 5,\n              previous = Math.abs(percent - mod5 - 50),\n              next = Math.abs(percent + 5 - mod5 - 50),\n              score = 10 * Math.min(previous / 5, next / 5);\n          return score;\n        }\n\n        var EncodingResult = function (dataString, version) {\n          this.dataString = dataString;\n          this.version = version;\n        };\n\n        var IsoEncoder = function () {\n          this.getEncodingResult = function (inputString, errorCorrectionLevel) {\n            var modes = getModes(inputString),\n                dataCodewordsCount = getDataCodewordsCount(modes),\n                version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n                dataString = getDataString(modes, version);\n            return new EncodingResult(dataString, version);\n          };\n        };\n\n        var UTF8Encoder = function () {\n          this.mode = modeInstances[this.encodingMode];\n        };\n\n        UTF8Encoder.fn = UTF8Encoder.prototype = {\n          encodingMode: BYTE,\n          utfBOM: \"111011111011101110111111\",\n          initialModeCountStringLength: 20,\n          getEncodingResult: function (inputString, errorCorrectionLevel) {\n            var that = this,\n                data = that.encode(inputString),\n                dataCodewordsCount = that.getDataCodewordsCount(data),\n                version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n                dataString = that.mode.getModeCountString(data.length / 8, version) + data;\n            return new EncodingResult(dataString, version);\n          },\n          getDataCodewordsCount: function (data) {\n            var that = this,\n                dataLength = data.length,\n                dataCodewordsCount = Math.ceil((that.initialModeCountStringLength + dataLength) / 8);\n            return dataCodewordsCount;\n          },\n          encode: function (str) {\n            var that = this,\n                result = that.utfBOM;\n\n            for (var i = 0; i < str.length; i++) {\n              result += that.encodeCharacter(str.charCodeAt(i));\n            }\n\n            return result;\n          },\n          encodeCharacter: function (code) {\n            var bytesCount = this.getBytesCount(code),\n                bc = bytesCount - 1,\n                result = \"\";\n\n            if (bytesCount == 1) {\n              result = toBitsString(code, 8);\n            } else {\n              var significantOnes = 8 - bytesCount;\n\n              for (var i = 0; i < bc; i++) {\n                result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;\n              }\n\n              result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;\n            }\n\n            return result;\n          },\n          getBytesCount: function (code) {\n            var ranges = this.ranges;\n\n            for (var i = 0; i < ranges.length; i++) {\n              if (code < ranges[i]) {\n                return i + 1;\n              }\n            }\n          },\n          ranges: [128, 2048, 65536, 2097152, 67108864]\n        };\n\n        var QRCodeDataEncoder = function (encoding) {\n          if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n            return new UTF8Encoder();\n          } else {\n            return new IsoEncoder();\n          }\n        };\n\n        var encodeData = function (inputString, errorCorrectionLevel, encoding) {\n          var encoder = new QRCodeDataEncoder(encoding),\n              encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n              version = encodingResult.version,\n              versionInformation = versionsCodewordsInformation[version - 1][errorCorrectionLevel],\n              dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n              blocks = getBlocks(dataString, versionInformation),\n              matrices = initMatrices(version);\n          addFinderPatterns(matrices);\n          addAlignmentPatterns(matrices, version);\n          addTimingFunctions(matrices);\n\n          if (version >= 7) {\n            addVersionInformation(matrices, toBitsString(0, 18));\n          }\n\n          addFormatInformation(matrices, toBitsString(0, 15));\n          fillData(matrices, blocks);\n          var minIdx = scoreMaskMatrixes(matrices),\n              optimalMatrix = matrices[minIdx];\n\n          if (version >= 7) {\n            addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n          }\n\n          var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n          addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n          return optimalMatrix;\n        };\n\n        var QRCodeDefaults = {\n          DEFAULT_SIZE: 200,\n          QUIET_ZONE_LENGTH: 4,\n          DEFAULT_ERROR_CORRECTION_LEVEL: \"L\",\n          DEFAULT_BACKGROUND: \"#fff\",\n          DEFAULT_DARK_MODULE_COLOR: \"#000\",\n          MIN_BASE_UNIT_SIZE: 1\n        };\n        var QRCode = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that.element = $(element);\n            that.wrapper = that.element;\n            that.element.addClass(\"k-qrcode\");\n            that.surfaceWrap = $(\"<div />\").css(\"position\", \"relative\").appendTo(this.element);\n            that.surface = draw.Surface.create(that.surfaceWrap, {\n              type: that.options.renderAs\n            });\n            that.setOptions(options);\n          },\n          redraw: function () {\n            var size = this._getSize();\n\n            this.surfaceWrap.css({\n              width: size,\n              height: size\n            });\n            this.surface.clear();\n            this.surface.resize();\n            this.createVisual();\n            this.surface.draw(this.visual);\n          },\n          getSize: function () {\n            return kendo.dimensions(this.element);\n          },\n          _resize: function () {\n            this.redraw();\n          },\n          createVisual: function () {\n            this.visual = this._render();\n          },\n          exportVisual: function () {\n            return this._render();\n          },\n          _render: function () {\n            var that = this,\n                value = that._value,\n                baseUnit,\n                border = that.options.border || {},\n                padding = that.options.padding || 0,\n                borderWidth = border.width || 0,\n                quietZoneSize,\n                matrix,\n                size,\n                dataSize,\n                contentSize;\n            border.width = borderWidth;\n            var visual = new draw.Group();\n\n            if (value) {\n              matrix = encodeData(value, that.options.errorCorrection, that.options.encoding);\n              size = that._getSize();\n              contentSize = size - 2 * (borderWidth + padding);\n              baseUnit = that._calculateBaseUnit(contentSize, matrix.length);\n              dataSize = matrix.length * baseUnit;\n              quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;\n              visual.append(that._renderBackground(size, border));\n              visual.append(that._renderMatrix(matrix, baseUnit, quietZoneSize));\n\n              if (that._hasCustomLogo()) {\n                visual.append(that._renderLogo(size, baseUnit));\n              } else if (that._isSwiss()) {\n                visual.append(that._renderSwissCode(size, baseUnit));\n              }\n            }\n\n            return visual;\n          },\n          _renderLogo: function name(qrSize, baseUnit) {\n            var image;\n            var imageRect;\n            var center = round(qrSize / 2);\n\n            var logoSize = this._getLogoSize(baseUnit * DEFAULT_LOGO_SIZE);\n\n            var logoUrl = this.options.overlay.imageUrl;\n            var position = {\n              x: center - logoSize.width / 2,\n              y: center - logoSize.height / 2\n            };\n            imageRect = new kendo.geometry.Rect(new kendo.geometry.Point(position.x, position.y), new kendo.geometry.Size(logoSize.width, logoSize.height));\n            image = new draw.Image(logoUrl, imageRect);\n            return image;\n          },\n          _renderSwissCode: function (qrSize, baseUnit) {\n            var logoSize = this._getLogoSize(baseUnit * DEFAULT_LOGO_SIZE);\n\n            logoSize = Math.max(logoSize.width, logoSize.height);\n            var crossSize = logoSize / 4;\n            var crossOffset = crossSize / 2;\n            var center = qrSize / 2;\n            var start = {};\n            var visual = new draw.Group();\n            start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);\n            visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, \"#fff\"));\n            start.x = start.y = center - logoSize / 2;\n            visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));\n            start.x = center + crossOffset - logoSize / 2;\n            start.y = center + crossOffset + crossSize - logoSize / 2;\n            visual.append(this._renderShape(start, crossSize, crossPattern, \"#fff\"));\n            return visual;\n          },\n          _renderShape: function (start, step, pattern, color) {\n            var path = new draw.MultiPath({\n              fill: {\n                color: color\n              },\n              stroke: null\n            });\n            path.moveTo(start.x, start.y);\n\n            for (var i = 0; i < pattern.length; i++) {\n              path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);\n            }\n\n            path.close();\n            return path;\n          },\n          _getSize: function () {\n            var that = this,\n                size;\n\n            if (that.options.size) {\n              size = parseInt(that.options.size, 10);\n            } else {\n              var element = that.element,\n                  min = Math.min(element.width(), element.height());\n\n              if (min > 0) {\n                size = min;\n              } else {\n                size = QRCodeDefaults.DEFAULT_SIZE;\n              }\n            }\n\n            return size;\n          },\n          _calculateBaseUnit: function (size, matrixSize) {\n            var baseUnit = Math.floor(size / matrixSize);\n\n            if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n              throw new Error(\"Insufficient size.\");\n            }\n\n            if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n              baseUnit--;\n            }\n\n            return baseUnit;\n          },\n          _renderMatrix: function (matrix, baseUnit, quietZoneSize) {\n            var path = new draw.MultiPath({\n              fill: {\n                color: this.options.color\n              },\n              stroke: null\n            });\n\n            for (var row = 0; row < matrix.length; row++) {\n              var y = quietZoneSize + row * baseUnit;\n              var column = 0;\n\n              while (column < matrix.length) {\n                while (matrix[row][column] === 0 && column < matrix.length) {\n                  column++;\n                }\n\n                if (column < matrix.length) {\n                  var x = column;\n\n                  while (matrix[row][column] == 1) {\n                    column++;\n                  }\n\n                  var x1 = round(quietZoneSize + x * baseUnit);\n                  var y1 = round(y);\n                  var x2 = round(quietZoneSize + column * baseUnit);\n                  var y2 = round(y + baseUnit);\n                  path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();\n                }\n              }\n            }\n\n            return path;\n          },\n          _renderBackground: function (size, border) {\n            var box = new Box2D(0, 0, size, size).unpad(border.width / 2);\n            return draw.Path.fromRect(box.toRect(), {\n              fill: {\n                color: this.options.background\n              },\n              stroke: {\n                color: border.color,\n                width: border.width\n              }\n            });\n          },\n          setOptions: function (options) {\n            var that = this;\n            options = options || {};\n            that.options = extend(that.options, options);\n\n            if (options.value !== undefined) {\n              that._value = that.options.value + \"\";\n            }\n\n            that.redraw();\n          },\n          value: function (value) {\n            var that = this;\n\n            if (value === undefined) {\n              return that._value;\n            }\n\n            that._value = value + \"\";\n            that.redraw();\n          },\n          options: {\n            name: \"QRCode\",\n            renderAs: \"svg\",\n            encoding: \"ISO_8859_1\",\n            value: \"\",\n            errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,\n            background: QRCodeDefaults.DEFAULT_BACKGROUND,\n            color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,\n            size: \"\",\n            padding: 0,\n            border: {\n              color: \"\",\n              width: 0\n            },\n            overlay: {\n              type: IMAGE,\n              imageUrl: \"\",\n              width: 0,\n              height: 0\n            }\n          },\n          _hasCustomLogo: function () {\n            return !!this.options.overlay.imageUrl;\n          },\n          _isSwiss: function () {\n            return this.options.overlay.type === SWISS_QR;\n          },\n          _getLogoSize: function (defautLogoSize) {\n            var width = this.options.overlay.width;\n            var height = this.options.overlay.height;\n\n            if (!width && !height) {\n              width = height = defautLogoSize;\n            } else if (width && !height) {\n              height = width;\n            } else if (!width && height) {\n              width = height;\n            }\n\n            return {\n              width: width,\n              height: height\n            };\n          }\n        });\n        dataviz.ExportMixin.extend(QRCode.fn);\n        dataviz.ui.plugin(QRCode);\n        kendo.deepExtend(dataviz, {\n          QRCode: QRCode,\n          QRCodeDefaults: QRCodeDefaults,\n          QRCodeFunctions: {\n            FreeCellVisitor: FreeCellVisitor,\n            fillData: fillData,\n            padDataString: padDataString,\n            generateErrorCodewords: generateErrorCodewords,\n            xorPolynomials: xorPolynomials,\n            getBlocks: getBlocks,\n            multiplyPolynomials: multiplyPolynomials,\n            chooseMode: chooseMode,\n            getModes: getModes,\n            getDataCodewordsCount: getDataCodewordsCount,\n            getVersion: getVersion,\n            getDataString: getDataString,\n            encodeFormatInformation: encodeFormatInformation,\n            encodeBCH: encodeBCH,\n            dividePolynomials: dividePolynomials,\n            initMatrices: initMatrices,\n            addFormatInformation: addFormatInformation,\n            encodeVersionInformation: encodeVersionInformation,\n            addVersionInformation: addVersionInformation,\n            addCentricPattern: addCentricPattern,\n            addFinderSeparator: addFinderSeparator,\n            addFinderPatterns: addFinderPatterns,\n            addAlignmentPatterns: addAlignmentPatterns,\n            addTimingFunctions: addTimingFunctions,\n            scoreMaskMatrixes: scoreMaskMatrixes,\n            encodeData: encodeData,\n            UTF8Encoder: UTF8Encoder\n          },\n          QRCodeFields: {\n            modes: modeInstances,\n            powersOfTwo: powersOfTwo,\n            powersOfTwoResult: powersOfTwoResult,\n            generatorPolynomials: generatorPolynomials\n          }\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}