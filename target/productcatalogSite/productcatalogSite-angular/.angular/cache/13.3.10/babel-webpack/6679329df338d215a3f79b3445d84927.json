{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(936);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  936:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(893), __webpack_require__(937)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var math = Math,\n            abs = math.abs,\n            atan = math.atan,\n            atan2 = math.atan2,\n            cos = math.cos,\n            max = math.max,\n            min = math.min,\n            sin = math.sin,\n            tan = math.tan,\n            kendo = window.kendo,\n            Class = kendo.Class,\n            dataviz = kendo.dataviz,\n            deepExtend = kendo.deepExtend,\n            util = kendo.drawing.util,\n            defined = util.defined,\n            deg = util.deg,\n            rad = util.rad,\n            round = util.round,\n            valueOrDefault = util.valueOrDefault,\n            sqr = kendo.util.sqr; // Implementation =========================================================\n\n        var Location = Class.extend({\n          init: function (lat, lng) {\n            if (arguments.length === 1) {\n              this.lat = lat[0];\n              this.lng = lat[1];\n            } else {\n              this.lat = lat;\n              this.lng = lng;\n            }\n          },\n          DISTANCE_ITERATIONS: 100,\n          DISTANCE_CONVERGENCE: 1e-12,\n          DISTANCE_PRECISION: 2,\n          FORMAT: \"{0:N6},{1:N6}\",\n          toArray: function () {\n            return [this.lat, this.lng];\n          },\n          equals: function (loc) {\n            return loc && loc.lat === this.lat && loc.lng === this.lng;\n          },\n          clone: function () {\n            return new Location(this.lat, this.lng);\n          },\n          round: function (precision) {\n            this.lng = round(this.lng, precision);\n            this.lat = round(this.lat, precision);\n            return this;\n          },\n          wrap: function () {\n            this.lng = this.lng % 180;\n            this.lat = this.lat % 90;\n            return this;\n          },\n          distanceTo: function (dest, datum) {\n            return this.greatCircleTo(dest, datum).distance;\n          },\n          destination: function (distance, bearing, datum) {\n            bearing = rad(bearing);\n            datum = datum || dataviz.map.datums.WGS84;\n            var fromLat = rad(this.lat);\n            var fromLng = rad(this.lng);\n            var dToR = distance / kendo.dataviz.map.datums.WGS84.a;\n            var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));\n            var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));\n            return new Location(deg(lat), deg(lng));\n          },\n          greatCircleTo: function (dest, datum) {\n            dest = Location.create(dest);\n            datum = datum || dataviz.map.datums.WGS84;\n\n            if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {\n              return {\n                distance: 0,\n                azimuthFrom: 0,\n                azimuthTo: 0\n              };\n            } // See http://en.wikipedia.org/wiki/Vincenty's_formulae#Notation\n            // o == sigma\n            // A == alpha\n\n\n            var a = datum.a;\n            var b = datum.b;\n            var f = datum.f;\n            var L = rad(dest.lng - this.lng);\n            var U1 = atan((1 - f) * tan(rad(this.lat)));\n            var sinU1 = sin(U1);\n            var cosU1 = cos(U1);\n            var U2 = atan((1 - f) * tan(rad(dest.lat)));\n            var sinU2 = sin(U2);\n            var cosU2 = cos(U2);\n            var lambda = L;\n            var prevLambda;\n            var i = this.DISTANCE_ITERATIONS;\n            var converged = false;\n            var sinLambda;\n            var cosLambda;\n            var sino;\n            var cosA2;\n            var coso;\n            var cos2om;\n            var sigma;\n\n            while (!converged && i-- > 0) {\n              sinLambda = sin(lambda);\n              cosLambda = cos(lambda);\n              sino = math.sqrt(sqr(cosU2 * sinLambda) + sqr(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n              coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n              sigma = atan2(sino, coso);\n              var sinA = cosU1 * cosU2 * sinLambda / sino;\n              cosA2 = 1 - sqr(sinA);\n              cos2om = 0;\n\n              if (cosA2 !== 0) {\n                cos2om = coso - 2 * sinU1 * sinU2 / cosA2;\n              }\n\n              prevLambda = lambda;\n              var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));\n              lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * sqr(cos2om))));\n              converged = abs(lambda - prevLambda) <= this.DISTANCE_CONVERGENCE;\n            }\n\n            var u2 = cosA2 * (sqr(a) - sqr(b)) / sqr(b);\n            var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n            var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n            var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * sqr(cos2om)) - B / 6 * cos2om * (-3 + 4 * sqr(sino)) * (-3 + 4 * sqr(cos2om))));\n            var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);\n            var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);\n            return {\n              distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),\n              azimuthFrom: deg(azimuthFrom),\n              azimuthTo: deg(azimuthTo)\n            };\n          }\n        }); // IE < 9 doesn't allow to override toString on definition\n\n        Location.fn.toString = function () {\n          return kendo.format(this.FORMAT, this.lat, this.lng);\n        };\n\n        Location.fromLngLat = function (ll) {\n          return new Location(ll[1], ll[0]);\n        };\n\n        Location.fromLatLng = function (ll) {\n          return new Location(ll[0], ll[1]);\n        };\n\n        Location.create = function (a, b) {\n          if (defined(a)) {\n            if (a instanceof Location) {\n              return a.clone();\n            } else if (arguments.length === 1 && a.length === 2) {\n              return Location.fromLatLng(a);\n            } else {\n              return new Location(a, b);\n            }\n          }\n        };\n\n        var Extent = Class.extend({\n          init: function (nw, se) {\n            nw = Location.create(nw);\n            se = Location.create(se);\n\n            if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {\n              this.se = nw;\n              this.nw = se;\n            } else {\n              this.se = se;\n              this.nw = nw;\n            }\n          },\n          contains: function (loc) {\n            var nw = this.nw,\n                se = this.se,\n                lng = valueOrDefault(loc.lng, loc[1]),\n                lat = valueOrDefault(loc.lat, loc[0]);\n            return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;\n          },\n          center: function () {\n            var nw = this.nw;\n            var se = this.se;\n            var lng = nw.lng + (se.lng - nw.lng) / 2;\n            var lat = nw.lat + (se.lat - nw.lat) / 2;\n            return new Location(lat, lng);\n          },\n          containsAny: function (locs) {\n            var result = false;\n\n            for (var i = 0; i < locs.length; i++) {\n              result = result || this.contains(locs[i]);\n            }\n\n            return result;\n          },\n          include: function (loc) {\n            var nw = this.nw,\n                se = this.se,\n                lng = valueOrDefault(loc.lng, loc[1]),\n                lat = valueOrDefault(loc.lat, loc[0]);\n            nw.lng = min(nw.lng, lng);\n            nw.lat = max(nw.lat, lat);\n            se.lng = max(se.lng, lng);\n            se.lat = min(se.lat, lat);\n          },\n          includeAll: function (locs) {\n            for (var i = 0; i < locs.length; i++) {\n              this.include(locs[i]);\n            }\n          },\n          edges: function () {\n            var nw = this.nw,\n                se = this.se;\n            return {\n              nw: this.nw,\n              ne: new Location(nw.lat, se.lng),\n              se: this.se,\n              sw: new Location(se.lat, nw.lng)\n            };\n          },\n          toArray: function () {\n            var nw = this.nw,\n                se = this.se;\n            return [nw, new Location(nw.lat, se.lng), se, new Location(se.lat, nw.lng)];\n          },\n          overlaps: function (extent) {\n            return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());\n          }\n        });\n        Extent.World = new Extent([90, -180], [-90, 180]);\n\n        Extent.create = function (a, b) {\n          if (a instanceof Extent) {\n            return a;\n          } else if (a && b) {\n            return new Extent(a, b);\n          } else if (a && a.length === 4 && !b) {\n            return new Extent([a[0], a[1]], [a[2], a[3]]);\n          }\n        }; // Exports ================================================================\n\n\n        deepExtend(dataviz, {\n          map: {\n            Extent: Extent,\n            Location: Location\n          }\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  937:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../util/main\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}