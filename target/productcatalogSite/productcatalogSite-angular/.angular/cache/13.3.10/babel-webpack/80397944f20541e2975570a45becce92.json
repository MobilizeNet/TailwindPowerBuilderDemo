{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1680);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1680:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        var Axis = kendo.Class.extend({\n          init: function (count, value) {\n            this._value = value;\n            this._count = count;\n            this.values = new kendo.spreadsheet.RangeList(0, count - 1, value);\n            this._hidden = new kendo.spreadsheet.RangeList(0, count - 1, 0);\n            this.scrollBarSize = kendo.support.scrollbar();\n\n            this._refresh();\n          },\n          _resize: function (count) {\n            if (count > this._count) {\n              this.values.value(this._count, count - 1, this._value);\n\n              this._hidden.value(this._count, count - 1, 0);\n            } else if (count < this._count) {\n              this.values.value(count, this._count - 1, 0);\n\n              this._hidden.value(count, this._count - 1, 0);\n            }\n\n            this._count = count;\n\n            this._refresh();\n          },\n          adjust: function (start, delta) {\n            // adjust this axis for insert/remove rows/cols operation\n            if (delta < 0) {\n              // removing -- copy from start+|delta| to start\n              this.values.copy(start - delta, this._count - 1, start);\n\n              this._hidden.copy(start - delta, this._count - 1, start);\n            } else {\n              // adding -- copy from start to start+delta, and set\n              // values for inserted things to default.\n              this.values.copy(start, this._count, start + delta);\n\n              this._hidden.copy(start, this._count, start + delta);\n\n              this.values.value(start, start + delta - 1, this._value);\n\n              this._hidden.value(start, start + delta - 1, 0);\n            }\n\n            this._refresh();\n          },\n          toJSON: function (field, positions) {\n            var values = [];\n            var iterator = this.values.iterator(0, this._count - 1);\n\n            for (var idx = 0; idx < this._count; idx++) {\n              var value = iterator.at(idx);\n\n              var hidden = this._hidden.value(idx, idx);\n\n              if (value === this._value && !hidden) {\n                continue;\n              }\n\n              var position = positions[idx];\n\n              if (position === undefined) {\n                position = values.length;\n                var item = {\n                  index: idx\n                };\n                item[field] = value;\n\n                if (hidden) {\n                  item.hidden = hidden;\n                }\n\n                values.push(item);\n                positions[idx] = position;\n              }\n            }\n\n            return values;\n          },\n          fromJSON: function (field, values) {\n            for (var idx = 0; idx < values.length; idx++) {\n              var el = values[idx];\n              var index = el.index;\n\n              if (index === undefined) {\n                index = idx;\n              } // when this particular axis is hidden, the value for\n              // the field (\"height\" or \"width\") will be zero, and\n              // in the \"hidden\" field we'll have the actual value\n              // before it was hidden.\n              // https://github.com/telerik/kendo-ui-core/issues/3523\n\n\n              var value = el[field];\n\n              if (value === 0) {\n                this._hidden.value(index, index, el.hidden || this._value);\n\n                this.value(index, index, 0);\n              } else {\n                this.value(index, index, value);\n              }\n            }\n          },\n          hide: function (index) {\n            if (!this.hidden(index)) {\n              var value = this.value(index, index);\n\n              this._hidden.value(index, index, value);\n\n              this.value(index, index, 0);\n            }\n          },\n          hidden: function (index) {\n            return this._hidden.value(index, index) !== 0;\n          },\n          includesHidden: function (start, end) {\n            return this._hidden.intersecting(start, end).length > 1;\n          },\n          nextVisible: function (index) {\n            var end = this._count - 1,\n                i = index;\n\n            while (++i <= end) {\n              if (!this.hidden(i)) {\n                return i;\n              }\n            }\n\n            return index;\n          },\n          nextUntil: function (index, pred) {\n            var end = this._count - 1,\n                i = index,\n                advanced = false;\n\n            while (++i <= end) {\n              var val = pred(i, advanced, this.hidden(i));\n\n              if (typeof val == \"number\") {\n                return val;\n              } else if (val) {\n                break;\n              }\n\n              advanced = true;\n            }\n\n            return i - 1;\n          },\n          nextPage: function (index, pageSize) {\n            return this.index(this.sum(0, index - 1) + pageSize);\n          },\n          prevPage: function (index, pageSize) {\n            return this.index(this.sum(0, index) - pageSize);\n          },\n          firstVisible: function () {\n            var firstHidden = this._hidden.first();\n\n            if (firstHidden.value === 0) {\n              return 0;\n            } else {\n              return firstHidden.end + 1;\n            }\n          },\n          lastVisible: function () {\n            var lastHidden = this._hidden.last();\n\n            if (lastHidden.value === 0) {\n              return this._count - 1;\n            } else {\n              return lastHidden.start - 1;\n            }\n          },\n          prevVisible: function (index) {\n            var i = index;\n\n            while (--i >= 0) {\n              if (!this.hidden(i)) {\n                return i;\n              }\n            }\n\n            return index;\n          },\n          prevUntil: function (index, pred) {\n            var i = index,\n                advanced = false;\n\n            while (--i >= 0) {\n              var val = pred(i, advanced, this.hidden(i));\n\n              if (typeof val == \"number\") {\n                return val;\n              } else if (val) {\n                break;\n              }\n\n              advanced = true;\n            }\n\n            return i + 1;\n          },\n          unhide: function (index) {\n            if (this.hidden(index)) {\n              var value = this._hidden.value(index, index);\n\n              this._hidden.value(index, index, 0);\n\n              this.value(index, index, value);\n            }\n          },\n          value: function (start, end, value) {\n            if (value !== undefined) {\n              this.values.value(start, end, value);\n\n              this._refresh();\n            } else {\n              return this.values.iterator(start, end).at(0);\n            }\n          },\n          sum: function (start, end) {\n            var values = this.values.iterator(start, end);\n            var sum = 0;\n\n            for (var idx = start; idx <= end; idx++) {\n              sum += values.at(idx);\n            }\n\n            return sum;\n          },\n          locate: function (start, end, predicate) {\n            var values = this.values.iterator(start, end);\n            var sum = 0;\n\n            for (var idx = start; idx <= end; idx++) {\n              sum += values.at(idx);\n              var val = predicate(sum);\n\n              if (val) {\n                return idx;\n              }\n            }\n\n            return null;\n          },\n          visible: function (start, end) {\n            var startSegment = null;\n            var endSegment = null;\n            var lastPage = false;\n\n            if (end >= this.total + this.scrollBarSize) {\n              lastPage = true;\n            }\n\n            var ranges = this._pixelValues.intersecting(start, end);\n\n            startSegment = ranges[0];\n            endSegment = ranges[ranges.length - 1];\n\n            if (!startSegment) {\n              return {\n                values: this.values.iterator(0, 0),\n                offset: 0\n              };\n            }\n\n            var startOffset = start - startSegment.start;\n            var startIndex = (startOffset / startSegment.value.value >> 0) + startSegment.value.start;\n            var offset = startOffset - (startIndex - startSegment.value.start) * startSegment.value.value;\n            var endOffset = end - endSegment.start;\n            var endIndex = (endOffset / endSegment.value.value >> 0) + endSegment.value.start;\n\n            if (endIndex > endSegment.value.end) {\n              endIndex = endSegment.value.end;\n            }\n\n            if (lastPage) {\n              offset += endSegment.value.value - (endOffset - (endIndex - endSegment.value.start) * endSegment.value.value);\n            }\n\n            offset = Math.min(-offset, 0);\n            return {\n              values: this.values.iterator(startIndex, endIndex),\n              offset: offset\n            };\n          },\n          index: function (value) {\n            var index = 0;\n            var iterator = this.values.iterator(0, this._count - 1);\n            var current = iterator.at(0);\n\n            while (current < value && index < this._count - 1) {\n              current += iterator.at(++index);\n            }\n\n            return index;\n          },\n          indexVisible: function (value) {\n            var index = this.index(value);\n\n            if (this.hidden(index)) {\n              index = this.prevVisible(index);\n            }\n\n            return index;\n          },\n          _refresh: function () {\n            var current = 0;\n            this._pixelValues = this.values.map(function (range) {\n              var start = current;\n              current += (range.end - range.start + 1) * range.value;\n              var end = current - 1;\n              return new kendo.spreadsheet.ValueRange(start, end, range);\n            });\n            this.total = current;\n          },\n          getState: function () {\n            return {\n              values: this.values.getState(),\n              hidden: this._hidden.getState(),\n              count: this._count\n            };\n          },\n          setState: function (state) {\n            this.values.setState(state.values);\n\n            this._hidden.setState(state.hidden);\n\n            var nowCount = this._count;\n\n            if (nowCount > state.count) {\n              this._count = state.count;\n\n              this._resize(nowCount); // calls _refresh too\n\n            } else {\n              this._refresh();\n            }\n          }\n        });\n        var PaneAxis = kendo.Class.extend({\n          init: function (axis, start, count, headerSize) {\n            this._axis = axis;\n            this._start = start;\n            this._count = count;\n            this.hasHeader = start === 0;\n            this.headerSize = headerSize;\n            this.defaultValue = axis._value;\n            this.frozen = count > 0;\n          },\n          viewSize: function (viewSize) {\n            this._viewSize = viewSize;\n          },\n          sum: function (start, end) {\n            return this._axis.sum(start, end - 1);\n          },\n          start: function () {\n            return this.sum(0, this._start);\n          },\n          size: function () {\n            return this.sum(this._start, this._start + this._count);\n          },\n          index: function (value, offset) {\n            return this._axis.index(value + (this.frozen ? 0 : offset) - this.headerSize);\n          },\n          indexVisible: function (value, offset) {\n            return this._axis.indexVisible(value + (this.frozen ? 0 : offset) - this.headerSize);\n          },\n          //XXX: rename this method\n          paneSegment: function () {\n            var offset = this.start();\n            var length;\n\n            if (!this.hasHeader) {\n              offset += this.headerSize;\n            }\n\n            if (this.frozen) {\n              length = this.size();\n\n              if (this.hasHeader) {\n                length += this.headerSize;\n              } else {\n                length -= this.headerSize;\n              }\n            } else {\n              length = this._viewSize - offset;\n            }\n\n            return {\n              offset: offset,\n              length: length\n            };\n          },\n          visible: function (offset) {\n            var start = this.start();\n            var size;\n\n            if (this.frozen) {\n              size = this.size();\n\n              if (!this.hasHeader) {\n                size -= this.headerSize;\n              }\n            } else {\n              size = this._viewSize - start - this.headerSize;\n              start += offset;\n            }\n\n            var result = this._axis.visible(start, start + size - 1);\n\n            if (this.frozen) {\n              result.offset = 0;\n            }\n\n            result.start = start;\n\n            if (this.hasHeader) {\n              result.offset += this.headerSize;\n              result.start -= this.headerSize;\n            }\n\n            return result;\n          },\n          contains: function (start, end) {\n            if (this.frozen) {\n              if (start > this._start + this._count) {\n                return false;\n              }\n\n              if (end < this._start) {\n                return false;\n              }\n\n              return true;\n            } else {\n              return end >= this._start;\n            }\n          }\n        });\n        kendo.spreadsheet.Axis = Axis;\n        kendo.spreadsheet.PaneAxis = PaneAxis;\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}