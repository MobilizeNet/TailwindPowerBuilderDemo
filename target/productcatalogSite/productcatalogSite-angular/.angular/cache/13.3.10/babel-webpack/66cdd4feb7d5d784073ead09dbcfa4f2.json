{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport ScatterChart from '../scatter-charts/scatter-chart';\nimport ScatterLineChart from '../scatter-charts/scatter-line-chart';\nimport BubbleChart from '../bubble-chart/bubble-chart';\nimport SeriesBinder from '../series-binder';\nimport { NumericAxis, LogarithmicAxis, DateValueAxis, Point } from '../../core';\nimport filterSeriesByType from '../utils/filter-series-by-type';\nimport equalsIgnoreCase from '../utils/equals-ignore-case';\nimport singleItemOrArray from '../utils/single-item-or-array';\nimport { SCATTER, SCATTER_LINE, BUBBLE, LOGARITHMIC } from '../constants';\nimport { DATE } from '../../common/constants';\nimport { deepExtend, eventElement, grep, inArray, setDefaultOptions } from '../../common';\n\nclass XYPlotArea extends PlotAreaBase {\n  initFields() {\n    this.namedXAxes = {};\n    this.namedYAxes = {};\n    this.xAxisRangeTracker = new AxisGroupRangeTracker();\n    this.yAxisRangeTracker = new AxisGroupRangeTracker();\n  }\n\n  render(panes = this.panes) {\n    const seriesByPane = this.groupSeriesByPane();\n\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this.addToLegend(paneSeries);\n      const filteredSeries = this.filterVisibleSeries(paneSeries);\n\n      if (!filteredSeries) {\n        continue;\n      }\n\n      this.createScatterChart(filterSeriesByType(filteredSeries, SCATTER), pane);\n      this.createScatterLineChart(filterSeriesByType(filteredSeries, SCATTER_LINE), pane);\n      this.createBubbleChart(filterSeriesByType(filteredSeries, BUBBLE), pane);\n    }\n\n    this.createAxes(panes);\n  }\n\n  appendChart(chart, pane) {\n    this.xAxisRangeTracker.update(chart.xAxisRanges);\n    this.yAxisRangeTracker.update(chart.yAxisRanges);\n    super.appendChart(chart, pane);\n  }\n\n  removeAxis(axis) {\n    const axisName = axis.options.name;\n    super.removeAxis(axis);\n\n    if (axis.options.vertical) {\n      this.yAxisRangeTracker.reset(axisName);\n      delete this.namedYAxes[axisName];\n    } else {\n      this.xAxisRangeTracker.reset(axisName);\n      delete this.namedXAxes[axisName];\n    }\n\n    if (axis === this.axisX) {\n      delete this.axisX;\n    }\n\n    if (axis === this.axisY) {\n      delete this.axisY;\n    }\n  } // TODO: Refactor, optionally use series.pane option\n\n\n  seriesPaneName(series) {\n    const options = this.options;\n    const xAxisName = series.xAxis;\n    const xAxisOptions = [].concat(options.xAxis);\n    const xAxis = grep(xAxisOptions, function (a) {\n      return a.name === xAxisName;\n    })[0];\n    const yAxisName = series.yAxis;\n    const yAxisOptions = [].concat(options.yAxis);\n    const yAxis = grep(yAxisOptions, function (a) {\n      return a.name === yAxisName;\n    })[0];\n    const panes = options.panes || [{}];\n    const defaultPaneName = panes[0].name || \"default\";\n    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n    return paneName;\n  }\n\n  createScatterChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n\n  createScatterLineChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterLineChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n\n  createBubbleChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new BubbleChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n\n  createXYAxis(options, vertical, axisIndex) {\n    const axisName = options.name;\n    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n    const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n    const axisOptions = deepExtend({\n      reverse: !vertical && this.chartService.rtl\n    }, options, {\n      vertical: vertical\n    });\n    const isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n    const defaultRange = tracker.query();\n    const defaultAxisRange = isLog ? {\n      min: 0.1,\n      max: 1\n    } : {\n      min: 0,\n      max: 1\n    };\n    const range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n    const typeSamples = [axisOptions.min, axisOptions.max];\n    const series = this.series;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n\n      if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n        const firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n        typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n        break;\n      }\n    }\n\n    if (axisIndex === 0 && defaultRange) {\n      range.min = Math.min(range.min, defaultRange.min);\n      range.max = Math.max(range.max, defaultRange.max);\n    }\n\n    let inferredDate;\n\n    for (let i = 0; i < typeSamples.length; i++) {\n      if (typeSamples[i] instanceof Date) {\n        inferredDate = true;\n        break;\n      }\n    }\n\n    let axisType;\n\n    if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n      axisType = DateValueAxis;\n    } else if (isLog) {\n      axisType = LogarithmicAxis;\n    } else {\n      axisType = NumericAxis;\n    }\n\n    const axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n    axis.axisIndex = axisIndex;\n\n    if (axisName) {\n      if (namedAxes[axisName]) {\n        throw new Error(`${vertical ? \"Y\" : \"X\"} axis with name ${axisName} is already defined`);\n      }\n\n      namedAxes[axisName] = axis;\n    }\n\n    this.appendAxis(axis);\n    return axis;\n  }\n\n  createAxes(panes) {\n    const options = this.options;\n    const xAxesOptions = [].concat(options.xAxis);\n    const xAxes = [];\n    const yAxesOptions = [].concat(options.yAxis);\n    const yAxes = [];\n\n    for (let idx = 0; idx < xAxesOptions.length; idx++) {\n      const axisPane = this.findPane(xAxesOptions[idx].pane);\n\n      if (inArray(axisPane, panes)) {\n        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));\n      }\n    }\n\n    for (let idx = 0; idx < yAxesOptions.length; idx++) {\n      const axisPane = this.findPane(yAxesOptions[idx].pane);\n\n      if (inArray(axisPane, panes)) {\n        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));\n      }\n    }\n\n    this.axisX = this.axisX || xAxes[0];\n    this.axisY = this.axisY || yAxes[0];\n  }\n\n  _dispatchEvent(chart, e, eventType) {\n    const coords = chart._eventCoordinates(e);\n\n    const point = new Point(coords.x, coords.y);\n    const allAxes = this.axes;\n    const length = allAxes.length;\n    const xValues = [];\n    const yValues = [];\n\n    for (let i = 0; i < length; i++) {\n      const axis = allAxes[i];\n      const values = axis.options.vertical ? yValues : xValues;\n      const currentValue = axis.getValue(point);\n\n      if (currentValue !== null) {\n        values.push(currentValue);\n      }\n    }\n\n    if (xValues.length > 0 && yValues.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        x: singleItemOrArray(xValues),\n        y: singleItemOrArray(yValues)\n      });\n    }\n  }\n\n  updateAxisOptions(axis, options) {\n    const vertical = axis.options.vertical;\n    const axes = this.groupAxes(this.panes);\n    const index = (vertical ? axes.y : axes.x).indexOf(axis);\n    updateAxisOptions(this.options, index, vertical, options);\n    updateAxisOptions(this.originalOptions, index, vertical, options);\n  }\n\n}\n\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n  const axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n  deepExtend(axisOptions, options);\n}\n\nsetDefaultOptions(XYPlotArea, {\n  xAxis: {},\n  yAxis: {}\n});\ndeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\nexport default XYPlotArea;","map":null,"metadata":{},"sourceType":"module"}