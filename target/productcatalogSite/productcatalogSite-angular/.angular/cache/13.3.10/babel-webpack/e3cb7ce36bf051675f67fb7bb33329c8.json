{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(910);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  910:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(911)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Graph = diagram.Graph,\n            Node = diagram.Node,\n            Link = diagram.Link,\n            deepExtend = kendo.deepExtend,\n            Size = diagram.Size,\n            Rect = diagram.Rect,\n            Dictionary = diagram.Dictionary,\n            Set = diagram.Set,\n            HyperTree = diagram.Graph,\n            Utils = diagram.Utils,\n            Point = diagram.Point,\n            EPSILON = 1e-06,\n            DEG_TO_RAD = Math.PI / 180,\n            contains = Utils.contains,\n            grep = $.grep;\n        /**\n         * Base class for layout algorithms.\n         * @type {*}\n         */\n\n        var LayoutBase = kendo.Class.extend({\n          defaultOptions: {\n            type: \"Tree\",\n            subtype: \"Down\",\n            roots: null,\n            animate: false,\n            //-------------------------------------------------------------------\n\n            /**\n             * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n             */\n            limitToView: false,\n\n            /**\n             * Force-directed option: the amount of friction applied to the motion of the nodes.\n             */\n            friction: 0.9,\n\n            /**\n             * Force-directed option: the optimal distance between nodes (minimum energy).\n             */\n            nodeDistance: 50,\n\n            /**\n             * Force-directed option: the number of time things are being calculated.\n             */\n            iterations: 300,\n            //-------------------------------------------------------------------\n\n            /**\n             * Tree option: the separation in one direction (depends on the subtype what direction this is).\n             */\n            horizontalSeparation: 90,\n\n            /**\n             * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n             */\n            verticalSeparation: 50,\n            //-------------------------------------------------------------------\n\n            /**\n             * Tip-over tree option: children-to-parent vertical distance.\n             */\n            underneathVerticalTopOffset: 15,\n\n            /**\n             * Tip-over tree option: children-to-parent horizontal distance.\n             */\n            underneathHorizontalOffset: 15,\n\n            /**\n             * Tip-over tree option: leaf-to-next-branch vertical distance.\n             */\n            underneathVerticalSeparation: 15,\n            //-------------------------------------------------------------------\n\n            /**\n             * Settings object to organize the different components of the diagram in a grid layout structure\n             */\n            grid: {\n              /**\n               * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n               */\n              width: 1500,\n\n              /**\n               * The left offset of the grid.\n               */\n              offsetX: 50,\n\n              /**\n               * The top offset of the grid.\n               */\n              offsetY: 50,\n\n              /**\n               * The horizontal padding within a cell of the grid where a single component resides.\n               */\n              componentSpacingX: 20,\n\n              /**\n               * The vertical padding within a cell of the grid where a single component resides.\n               */\n              componentSpacingY: 20\n            },\n            //-------------------------------------------------------------------\n\n            /**\n             * Layered option: the separation height/width between the layers.\n             */\n            layerSeparation: 50,\n\n            /**\n             * Layered option: how many rounds of shifting and fine-tuning.\n             */\n            layeredIterations: 2,\n\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            startRadialAngle: 0,\n\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            endRadialAngle: 360,\n\n            /**\n             * Tree-radial option: the separation between levels.\n             */\n            radialSeparation: 150,\n\n            /**\n             * Tree-radial option: the separation between the root and the first level.\n             */\n            radialFirstLevelSeparation: 200,\n\n            /**\n             * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n             */\n            keepComponentsInOneRadialLayout: false,\n            //-------------------------------------------------------------------\n            // TODO: ensure to change this to false when containers are around\n            ignoreContainers: true,\n            layoutContainerChildren: false,\n            ignoreInvisible: true,\n            animateTransitions: false\n          },\n          init: function () {},\n\n          /**\n           * Organizes the components in a grid.\n           * Returns the final set of nodes (not the Graph).\n           * @param components\n           */\n          gridLayoutComponents: function (components) {\n            if (!components) {\n              throw \"No components supplied.\";\n            } // calculate and cache the bounds of the components\n\n\n            Utils.forEach(components, function (c) {\n              c.calcBounds();\n            }); // order by decreasing width\n\n            components.sort(function (a, b) {\n              return b.bounds.width - a.bounds.width;\n            });\n            var maxWidth = this.options.grid.width,\n                offsetX = this.options.grid.componentSpacingX,\n                offsetY = this.options.grid.componentSpacingY,\n                height = 0,\n                startX = this.options.grid.offsetX,\n                startY = this.options.grid.offsetY,\n                x = startX,\n                y = startY,\n                i,\n                resultLinkSet = [],\n                resultNodeSet = [];\n\n            while (components.length > 0) {\n              if (x >= maxWidth) {\n                // start a new row\n                x = startX;\n                y += height + offsetY; // reset the row height\n\n                height = 0;\n              }\n\n              var component = components.pop();\n              this.moveToOffset(component, new Point(x, y));\n\n              for (i = 0; i < component.nodes.length; i++) {\n                resultNodeSet.push(component.nodes[i]); // to be returned in the end\n              }\n\n              for (i = 0; i < component.links.length; i++) {\n                resultLinkSet.push(component.links[i]);\n              }\n\n              var boundingRect = component.bounds;\n              var currentHeight = boundingRect.height;\n\n              if (currentHeight <= 0 || isNaN(currentHeight)) {\n                currentHeight = 0;\n              }\n\n              var currentWidth = boundingRect.width;\n\n              if (currentWidth <= 0 || isNaN(currentWidth)) {\n                currentWidth = 0;\n              }\n\n              if (currentHeight >= height) {\n                height = currentHeight;\n              }\n\n              x += currentWidth + offsetX;\n            }\n\n            return {\n              nodes: resultNodeSet,\n              links: resultLinkSet\n            };\n          },\n          moveToOffset: function (component, p) {\n            var i,\n                j,\n                bounds = component.bounds,\n                deltax = p.x - bounds.x,\n                deltay = p.y - bounds.y;\n\n            for (i = 0; i < component.nodes.length; i++) {\n              var node = component.nodes[i];\n              var nodeBounds = node.bounds();\n\n              if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                nodeBounds = new Rect(0, 0, 0, 0);\n              }\n\n              nodeBounds.x += deltax;\n              nodeBounds.y += deltay;\n              node.bounds(nodeBounds);\n            }\n\n            for (i = 0; i < component.links.length; i++) {\n              var link = component.links[i];\n\n              if (link.points) {\n                var newpoints = [];\n                var points = link.points;\n\n                for (j = 0; j < points.length; j++) {\n                  var pt = points[j];\n                  pt.x += deltax;\n                  pt.y += deltay;\n                  newpoints.push(pt);\n                }\n\n                link.points = newpoints;\n              }\n            }\n\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltax, deltay);\n          },\n          transferOptions: function (options) {\n            // Size options lead to stackoverflow and need special handling\n            this.options = kendo.deepExtend({}, this.defaultOptions);\n\n            if (Utils.isUndefined(options)) {\n              return;\n            }\n\n            this.options = kendo.deepExtend(this.options, options || {});\n          }\n        });\n        /**\n         * The data bucket a hypertree holds in its nodes.     *\n         * @type {*}\n         */\n\n        /* var ContainerGraph = kendo.Class.extend({\n         init: function (diagram) {\n         this.diagram = diagram;\n         this.graph = new Graph(diagram);\n         this.container = null;\n         this.containerNode = null;\n         }\n          });*/\n\n        /**\n         * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n         * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n         * to investigate how the effective graph structure looks like and how the layout has to be performed.\n         * @type {*}\n         */\n\n        var DiagramToHyperTreeAdapter = kendo.Class.extend({\n          init: function (diagram) {\n            /**\n             * The mapping to/from the original nodes.\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             * @type {Dictionary}\n             */\n\n            this.shapeMap = new Dictionary();\n            /**\n             * The nodes being mapped.\n             * @type {Dictionary}\n             */\n\n            this.nodes = [];\n            /**\n             * The connections being mapped.\n             * @type {Dictionary}\n             */\n\n            this.edges = []; // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n\n            this.edgeMap = new Dictionary();\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             * @type {Array}\n             */\n\n            this.finalNodes = [];\n            /**\n             * The resulting set of Links when the analysis has finished.\n             * @type {Array}\n             */\n\n            this.finalLinks = [];\n            /**\n             * The items being omitted because of multigraph edges.\n             * @type {Array}\n             */\n\n            this.ignoredConnections = [];\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             * @type {Array}\n             */\n\n            this.ignoredShapes = [];\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             * @type {Dictionary}\n             */\n\n            this.hyperMap = new Dictionary();\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             * @type {HyperTree}\n             */\n\n            this.hyperTree = new Graph();\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             * @type {null}\n             */\n\n            this.finalGraph = null;\n            this.diagram = diagram;\n          },\n\n          /**\n           * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n           * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n           *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n           *    since there is no node mapped for the container.\n           *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n           *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n           *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n           * @param options\n           */\n          convert: function (options) {\n            if (Utils.isUndefined(this.diagram)) {\n              throw \"No diagram to convert.\";\n            }\n\n            this.options = kendo.deepExtend({\n              ignoreInvisible: true,\n              ignoreContainers: true,\n              layoutContainerChildren: false\n            }, options || {});\n            this.clear(); // create the nodes which participate effectively in the graph analysis\n\n            this._renormalizeShapes(); // recreate the incoming and outgoing collections of each and every node\n\n\n            this._renormalizeConnections(); // export the resulting graph\n\n\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function (n) {\n              this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function (l) {\n              this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n          },\n\n          /**\n           * Maps the specified connection to an edge of the graph deduced from the given diagram.\n           * @param connection\n           * @returns {*}\n           */\n          mapConnection: function (connection) {\n            return this.edgeMap.get(connection.id);\n          },\n\n          /**\n           * Maps the specified shape to a node of the graph deduced from the given diagram.\n           * @param shape\n           * @returns {*}\n           */\n          mapShape: function (shape) {\n            return this.nodeMap.get(shape.id);\n          },\n\n          /**\n           * Gets the edge, if any, between the given nodes.\n           * @param a\n           * @param b\n           */\n          getEdge: function (a, b) {\n            return Utils.first(a.links, function (link) {\n              return link.getComplement(a) === b;\n            });\n          },\n\n          /**\n           * Clears all the collections used by the conversion process.\n           */\n          clear: function () {\n            this.finalGraph = null;\n            this.hyperTree = !this.options.ignoreContainers && this.options.layoutContainerChildren ? new HyperTree() : null;\n            this.hyperMap = !this.options.ignoreContainers && this.options.layoutContainerChildren ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n          },\n\n          /**\n           * The path from a given ContainerGraph to the root (container).\n           * @param containerGraph\n           * @returns {Array}\n           */\n          listToRoot: function (containerGraph) {\n            var list = [];\n            var s = containerGraph.container;\n\n            if (!s) {\n              return list;\n            }\n\n            list.push(s);\n\n            while (s.parentContainer) {\n              s = s.parentContainer;\n              list.push(s);\n            }\n\n            list.reverse();\n            return list;\n          },\n          firstNonIgnorableContainer: function (shape) {\n            if (shape.isContainer && !this._isIgnorableItem(shape)) {\n              return shape;\n            }\n\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n          },\n          isContainerConnection: function (a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n              return true;\n            }\n\n            return b.isContainer && this.isDescendantOf(b, a);\n          },\n\n          /**\n           * Returns true if the given shape is a direct child or a nested container child of the given container.\n           * If the given container and shape are the same this will return false since a shape cannot be its own child.\n           * @param scope\n           * @param a\n           * @returns {boolean}\n           */\n          isDescendantOf: function (scope, a) {\n            if (!scope.isContainer) {\n              throw \"Expecting a container.\";\n            }\n\n            if (scope === a) {\n              return false;\n            }\n\n            if (contains(scope.children, a)) {\n              return true;\n            }\n\n            var containers = [];\n\n            for (var i = 0, len = scope.children.length; i < len; i++) {\n              var c = scope.children[i];\n\n              if (c.isContainer && this.isDescendantOf(c, a)) {\n                containers.push(c);\n              }\n            }\n\n            return containers.length > 0;\n          },\n          isIgnorableItem: function (shape) {\n            if (this.options.ignoreInvisible) {\n              if (shape.isCollapsed && this._isVisible(shape)) {\n                return false;\n              }\n\n              if (!shape.isCollapsed && this._isVisible(shape)) {\n                return false;\n              }\n\n              return true;\n            } else {\n              return shape.isCollapsed && !this._isTop(shape);\n            }\n          },\n\n          /**\n           *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n           * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n           * necessarily a container in the parent hierarchy of the shape.\n           * @param shape\n           */\n          isShapeMapped: function (shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n          },\n          leastCommonAncestor: function (a, b) {\n            if (!a) {\n              throw \"Parameter should not be null.\";\n            }\n\n            if (!b) {\n              throw \"Parameter should not be null.\";\n            }\n\n            if (!this.hyperTree) {\n              throw \"No hypertree available.\";\n            }\n\n            var al = this.listToRoot(a);\n            var bl = this.listToRoot(b);\n            var found = null;\n\n            if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n              return this.hyperTree.root.data;\n            }\n\n            var xa = al[0];\n            var xb = bl[0];\n            var i = 0;\n\n            while (xa === xb) {\n              found = al[i];\n              i++;\n\n              if (i >= al.length || i >= bl.length) {\n                break;\n              }\n\n              xa = al[i];\n              xb = bl[i];\n            }\n\n            if (!found) {\n              return this.hyperTree.root.data;\n            } else {\n              return grep(this.hyperTree.nodes, function (n) {\n                return n.data.container === found;\n              });\n            }\n          },\n\n          /**\n           * Determines whether the specified item is a top-level shape or container.\n           * @param item\n           * @returns {boolean}\n           * @private\n           */\n          _isTop: function (item) {\n            return !item.parentContainer;\n          },\n\n          /**\n           * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n           * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n           * @param shape\n           * @returns {*}\n           * @private\n           */\n          _isVisible: function (shape) {\n            if (!shape.visible()) {\n              return false;\n            }\n\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n          },\n          _isCollapsed: function (shape) {\n            if (shape.isContainer && shape.isCollapsed) {\n              return true;\n            }\n\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n          },\n\n          /**\n           * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n           * @private\n           */\n          _renormalizeShapes: function () {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n              for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                var shape = this.diagram.shapes[i]; // if not visible (and ignoring the invisible ones) or a container we skip\n\n                if (this.options.ignoreInvisible && !this._isVisible(shape) || shape.isContainer) {\n                  this.ignoredShapes.push(shape);\n                  continue;\n                }\n\n                var node = new Node(shape.id, shape);\n                node.isVirtual = false; // the mapping will always contain singletons and the hyperTree will be null\n\n                this.nodeMap.add(shape.id, node);\n                this.nodes.push(node);\n              }\n            } else {\n              throw \"Containers are not supported yet, but stay tuned.\";\n            }\n          },\n\n          /**\n           * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n           * @private\n           */\n          _renormalizeConnections: function () {\n            if (this.diagram.connections.length === 0) {\n              return;\n            }\n\n            for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n              var conn = this.diagram.connections[i];\n\n              if (this.isIgnorableItem(conn)) {\n                this.ignoredConnections.push(conn);\n                continue;\n              }\n\n              var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n              var sink = !conn.targetConnector ? null : conn.targetConnector.shape; // no layout for floating connections\n\n              if (!source || !sink) {\n                this.ignoredConnections.push(conn);\n                continue;\n              }\n\n              if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                this.ignoredConnections.push(conn);\n                continue;\n              }\n\n              if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                this.ignoredConnections.push(conn);\n                continue;\n              } // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n\n\n              if (this.shapeMap.containsKey(source)) {\n                source = this.shapeMap[source];\n              }\n\n              if (this.shapeMap.containsKey(sink)) {\n                sink = this.shapeMap[sink];\n              }\n\n              var sourceNode = this.mapShape(source);\n              var sinkNode = this.mapShape(sink);\n\n              if (sourceNode === sinkNode || this.areConnectedAlready(sourceNode, sinkNode)) {\n                this.ignoredConnections.push(conn);\n                continue;\n              }\n\n              if (sourceNode === null || sinkNode === null) {\n                throw \"A shape was not mapped to a node.\";\n              }\n\n              if (this.options.ignoreContainers) {\n                // much like a floating connection here since at least one end is attached to a container\n                if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                }\n\n                var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n                this.edgeMap.add(conn.id, newEdge);\n                this.edges.push(newEdge);\n              } else {\n                throw \"Containers are not supported yet, but stay tuned.\";\n              }\n            }\n          },\n          areConnectedAlready: function (n, m) {\n            return Utils.any(this.edges, function (l) {\n              return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n          }\n          /**\n           * Depth-first traversal of the given container.\n           * @param container\n           * @param action\n           * @param includeStart\n           * @private\n           */\n\n          /* _visitContainer: function (container, action, includeStart) {\n            */\n\n          /*if (container == null) throw new ArgumentNullException(\"container\");\n          if (action == null) throw new ArgumentNullException(\"action\");\n          if (includeStart) action(container);\n          if (container.children.isEmpty()) return;\n          foreach(\n          var item\n          in\n          container.children.OfType < IShape > ()\n          )\n          {\n          var childContainer = item\n          as\n          IContainerShape;\n          if (childContainer != null) this.VisitContainer(childContainer, action);\n          else action(item);\n          }*/\n\n          /*\n          }*/\n\n        });\n        /**\n         * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n         * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n         *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n         *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n         *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n         * @type {*}\n         */\n\n        var SpringLayout = LayoutBase.extend({\n          init: function (diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n\n            if (Utils.isUndefined(diagram)) {\n              throw \"Diagram is not specified.\";\n            }\n\n            this.diagram = diagram;\n          },\n          layout: function (options) {\n            this.transferOptions(options);\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n\n            if (graph.isEmpty()) {\n              return;\n            } // split into connected components\n\n\n            var components = graph.getConnectedComponents();\n\n            if (Utils.isEmpty(components)) {\n              return;\n            }\n\n            for (var i = 0; i < components.length; i++) {\n              var component = components[i];\n              this.layoutGraph(component, options);\n            }\n\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n          },\n          layoutGraph: function (graph, options) {\n            if (Utils.isDefined(options)) {\n              this.transferOptions(options);\n            }\n\n            this.graph = graph;\n            var initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n\n            var guessBounds = this._expectedBounds();\n\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n\n            for (var step = 0; step < this.options.iterations; step++) {\n              this.refineStage = step >= this.options.iterations * 5 / 6;\n              this.tick(); // exponential cooldown\n\n              this.temperature = this.refineStage ? initialTemperature / 30 : initialTemperature * (1 - step / (2 * this.options.iterations));\n            }\n          },\n\n          /**\n           * Single iteration of the simulation.\n           */\n          tick: function () {\n            var i; // collect the repulsive forces on each node\n\n            for (i = 0; i < this.graph.nodes.length; i++) {\n              this._repulsion(this.graph.nodes[i]);\n            } // collect the attractive forces on each node\n\n\n            for (i = 0; i < this.graph.links.length; i++) {\n              this._attraction(this.graph.links[i]);\n            } // update the positions\n\n\n            for (i = 0; i < this.graph.nodes.length; i++) {\n              var node = this.graph.nodes[i];\n              var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n\n              if (offset === 0) {\n                return;\n              }\n\n              node.x += Math.min(offset, this.temperature) * node.dx / offset;\n              node.y += Math.min(offset, this.temperature) * node.dy / offset;\n\n              if (this.options.limitToView) {\n                node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n              }\n            }\n          },\n\n          /**\n           * Shakes the node away from its current position to escape the deadlock.\n           * @param node A Node.\n           * @private\n           */\n          _shake: function (node) {\n            // just a simple polar neighborhood\n            var rho = Math.random() * this.options.nodeDistance / 4;\n            var alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n          },\n\n          /**\n           * The typical Coulomb-Newton force law F=k/r^2\n           * @remark This only works in dimensions less than three.\n           * @param d\n           * @param n A Node.\n           * @param m Another Node.\n           * @returns {number}\n           * @private\n           */\n          _InverseSquareForce: function (d, n, m) {\n            var force;\n\n            if (!this.refineStage) {\n              force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            } else {\n              var deltax = n.x - m.x;\n              var deltay = n.y - m.y;\n              var wn = n.width / 2;\n              var hn = n.height / 2;\n              var wm = m.width / 2;\n              var hm = m.height / 2;\n              force = Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2) + Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2);\n            }\n\n            return force * 4 / 3;\n          },\n\n          /**\n           * The typical Hooke force law F=kr^2\n           * @param d\n           * @param n\n           * @param m\n           * @returns {number}\n           * @private\n           */\n          _SquareForce: function (d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n          },\n          _repulsion: function (n) {\n            n.dx = 0;\n            n.dy = 0;\n            Utils.forEach(this.graph.nodes, function (m) {\n              if (m === n) {\n                return;\n              }\n\n              while (n.x === m.x && n.y === m.y) {\n                this._shake(m);\n              }\n\n              var vx = n.x - m.x;\n              var vy = n.y - m.y;\n              var distance = Math.sqrt(vx * vx + vy * vy);\n              var r = this._SquareForce(distance, n, m) * 2;\n              n.dx += vx / distance * r;\n              n.dy += vy / distance * r;\n            }, this);\n          },\n          _attraction: function (link) {\n            var t = link.target;\n            var s = link.source;\n\n            if (s === t) {\n              // loops induce endless shakes\n              return;\n            }\n\n            while (s.x === t.x && s.y === t.y) {\n              this._shake(t);\n            }\n\n            var vx = s.x - t.x;\n            var vy = s.y - t.y;\n            var distance = Math.sqrt(vx * vx + vy * vy);\n            var a = this._InverseSquareForce(distance, s, t) * 5;\n            var dx = vx / distance * a;\n            var dy = vy / distance * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n          },\n\n          /**\n           * Calculates the expected bounds after layout.\n           * @returns {*}\n           * @private\n           */\n          _expectedBounds: function () {\n            var size,\n                N = this.graph.nodes.length,\n\n            /*golden ration optimal?*/\n            ratio = 1.5,\n                multiplier = 4;\n\n            if (N === 0) {\n              return size;\n            }\n\n            size = Utils.fold(this.graph.nodes, function (s, node) {\n              var area = node.width * node.height;\n\n              if (area > 0) {\n                s += Math.sqrt(area);\n                return s;\n              }\n\n              return 0;\n            }, 0, this);\n            var av = size / N;\n            var squareSize = av * Math.ceil(Math.sqrt(N));\n            var width = squareSize * Math.sqrt(ratio);\n            var height = squareSize / Math.sqrt(ratio);\n            return {\n              width: width * multiplier,\n              height: height * multiplier\n            };\n          }\n        });\n        var TreeLayoutProcessor = kendo.Class.extend({\n          init: function (options) {\n            this.center = null;\n            this.options = options;\n          },\n          layout: function (treeGraph, root) {\n            this.graph = treeGraph;\n\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n              return;\n            }\n\n            if (!contains(this.graph.nodes, root)) {\n              throw \"The given root is not in the graph.\";\n            }\n\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n            // transfer the rects\n\n            /*nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n              );*/\n            // caching the children\n\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n\n            this.layoutSwitch(); // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n          },\n          layoutLeft: function (left) {\n            this.setChildrenDirection(this.center, \"Left\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0,\n                w = 0,\n                y,\n                i,\n                node;\n\n            for (i = 0; i < left.length; i++) {\n              node = left[i];\n              node.TreeDirection = \"Left\";\n              var s = this.measure(node, Size.Empty);\n              w = Math.max(w, s.Width);\n              h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + (this.center.height - h) / 2;\n\n            for (i = 0; i < left.length; i++) {\n              node = left[i];\n              var p = new Point(x - node.Size.width, y);\n              this.arrange(node, p);\n              y += node.Size.height + this.options.verticalSeparation;\n            }\n          },\n          layoutRight: function (right) {\n            this.setChildrenDirection(this.center, \"Right\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0,\n                w = 0,\n                y,\n                i,\n                node;\n\n            for (i = 0; i < right.length; i++) {\n              node = right[i];\n              node.TreeDirection = \"Right\";\n              var s = this.measure(node, Size.Empty);\n              w = Math.max(w, s.Width);\n              h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + (this.center.height - h) / 2;\n\n            for (i = 0; i < right.length; i++) {\n              node = right[i];\n              var p = new Point(x, y);\n              this.arrange(node, p);\n              y += node.Size.height + this.options.verticalSeparation;\n            }\n          },\n          layoutUp: function (up) {\n            this.setChildrenDirection(this.center, \"Up\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0,\n                y,\n                node,\n                i;\n\n            for (i = 0; i < up.length; i++) {\n              node = up[i];\n              node.TreeDirection = \"Up\";\n              var s = this.measure(node, Size.Empty);\n              w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + this.center.width / 2 - w / 2; // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n\n            for (i = 0; i < up.length; i++) {\n              node = up[i];\n              y = this.center.y - this.options.verticalSeparation - node.Size.height;\n              var p = new Point(x, y);\n              this.arrange(node, p);\n              x += node.Size.width + this.options.horizontalSeparation;\n            }\n          },\n          layoutDown: function (down) {\n            var node, i;\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0,\n                y;\n\n            for (i = 0; i < down.length; i++) {\n              node = down[i];\n              node.treeDirection = \"Down\";\n              var s = this.measure(node, Size.Empty);\n              w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + this.center.width / 2 - w / 2;\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n\n            for (i = 0; i < down.length; i++) {\n              node = down[i];\n              var p = new Point(x, y);\n              this.arrange(node, p);\n              x += node.Size.width + this.options.horizontalSeparation;\n            }\n          },\n          layoutRadialTree: function () {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, \"Radial\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.previousRoot = null;\n            var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n\n            if (endAngle <= startAngle) {\n              throw \"Final angle should not be less than the start angle.\";\n            }\n\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0); // perform the layout\n\n            if (this.maxDepth > 0) {\n              this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            } // update properties of the root node\n\n\n            this.center.Angle = endAngle - startAngle;\n          },\n          tipOverTree: function (down, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n              startFromLevel = 0;\n            }\n\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n            var w = 0,\n                y,\n                node,\n                i;\n\n            for (i = 0; i < down.length; i++) {\n              node = down[i]; // if (node.IsSpecial) continue;\n\n              node.TreeDirection = \"Down\";\n              var s = this.measure(node, Size.Empty);\n              w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation; // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n            var x = this.center.x + this.center.width / 2 - w / 2;\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n\n            for (i = 0; i < down.length; i++) {\n              node = down[i]; // if (node.IsSpecial) continue;\n\n              var p = new Point(x, y);\n              this.arrange(node, p);\n              x += node.Size.width + this.options.horizontalSeparation;\n            }\n            /*//let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n\n          },\n          calculateAngularWidth: function (n, d) {\n            if (d > this.maxDepth) {\n              this.maxDepth = d;\n            }\n\n            var aw = 0,\n                w = 1000,\n                h = 1000,\n                diameter = d === 0 ? 0 : Math.sqrt(w * w + h * h) / d;\n\n            if (n.children.length > 0) {\n              // eventually with n.IsExpanded\n              for (var i = 0, len = n.children.length; i < len; i++) {\n                var child = n.children[i];\n                aw += this.calculateAngularWidth(child, d + 1);\n              }\n\n              aw = Math.max(diameter, aw);\n            } else {\n              aw = diameter;\n            }\n\n            n.sectorAngle = aw;\n            return aw;\n          },\n          sortChildren: function (n) {\n            var basevalue = 0,\n                i; // update basevalue angle for node ordering\n\n            if (n.parents.length > 1) {\n              throw \"Node is not part of a tree.\";\n            }\n\n            var p = n.parents[0];\n\n            if (p) {\n              var pl = new Point(p.x, p.y);\n              var nl = new Point(n.x, n.y);\n              basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n\n            var count = n.children.length;\n\n            if (count === 0) {\n              return null;\n            }\n\n            var angle = [];\n            var idx = [];\n\n            for (i = 0; i < count; ++i) {\n              var c = n.children[i];\n              var l = new Point(c.x, c.y);\n              idx[i] = i;\n              angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n\n            Utils.bisort(angle, idx);\n            var col = []; // list of nodes\n\n            var children = n.children;\n\n            for (i = 0; i < count; ++i) {\n              col.push(children[idx[i]]);\n            }\n\n            return col;\n          },\n          normalizeAngle: function (angle) {\n            while (angle > Math.PI * 2) {\n              angle -= 2 * Math.PI;\n            }\n\n            while (angle < 0) {\n              angle += Math.PI * 2;\n            }\n\n            return angle;\n          },\n          radialLayout: function (node, radius, startAngle, endAngle) {\n            var deltaTheta = endAngle - startAngle;\n            var deltaThetaHalf = deltaTheta / 2.0;\n            var parentSector = node.sectorAngle;\n            var fraction = 0;\n            var sorted = this.sortChildren(node);\n\n            for (var i = 0, len = sorted.length; i < len; i++) {\n              var childNode = sorted[i];\n              var cp = childNode;\n              var childAngleFraction = cp.sectorAngle / parentSector;\n\n              if (childNode.children.length > 0) {\n                this.radialLayout(childNode, radius + this.options.radialSeparation, startAngle + fraction * deltaTheta, startAngle + (fraction + childAngleFraction) * deltaTheta);\n              }\n\n              this.setPolarLocation(childNode, radius, startAngle + fraction * deltaTheta + childAngleFraction * deltaThetaHalf);\n              cp.angle = childAngleFraction * deltaTheta;\n              fraction += childAngleFraction;\n            }\n          },\n          setPolarLocation: function (node, radius, angle) {\n            node.x = this.origin.x + radius * Math.cos(angle);\n            node.y = this.origin.y + radius * Math.sin(angle);\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n          },\n\n          /**\n           * Sets the children direction recursively.\n           * @param node\n           * @param direction\n           * @param includeStart\n           */\n          setChildrenDirection: function (node, direction, includeStart) {\n            var rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, function (n) {\n              n.treeDirection = direction;\n            });\n\n            if (!includeStart) {\n              node.treeDirection = rootDirection;\n            }\n          },\n\n          /**\n           * Sets the children layout recursively.\n           * @param node\n           * @param layout\n           * @param includeStart\n           * @param startFromLevel\n           */\n          setChildrenLayout: function (node, layout, includeStart, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n              startFromLevel = 0;\n            }\n\n            var rootLayout = node.childrenLayout;\n\n            if (startFromLevel > 0) {\n              // assign levels to the Node.Level property\n              this.graph.assignLevels(node); // assign the layout on the condition that the level is at least the 'startFromLevel'\n\n              this.graph.depthFirstTraversal(node, function (s) {\n                if (s.level >= startFromLevel + 1) {\n                  s.childrenLayout = layout;\n                }\n              });\n            } else {\n              this.graph.depthFirstTraversal(node, function (s) {\n                s.childrenLayout = layout;\n              }); // if the start should not be affected we put the state back\n\n              if (!includeStart) {\n                node.childrenLayout = rootLayout;\n              }\n            }\n          },\n\n          /**\n           * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n           * @param node\n           * @param givenSize\n           * @returns {Size}\n           */\n          measure: function (node, givenSize) {\n            var w = 0,\n                h = 0,\n                s;\n            var result = new Size(0, 0);\n\n            if (!node) {\n              throw \"\";\n            }\n\n            var b = node.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n\n            if (node.parents.length !== 1) {\n              throw \"Node not in a spanning tree.\";\n            }\n\n            var parent = node.parents[0];\n\n            if (node.treeDirection === \"Undefined\") {\n              node.treeDirection = parent.treeDirection;\n            }\n\n            if (Utils.isEmpty(node.children)) {\n              result = new Size(Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth, Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            } else if (node.children.length === 1) {\n              switch (node.treeDirection) {\n                case \"Radial\":\n                  s = this.measure(node.children[0], givenSize); // child size\n\n                  w = shapeWidth + this.options.radialSeparation * Math.cos(node.AngleToParent) + s.width;\n                  h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                  break;\n\n                case \"Left\":\n                case \"Right\":\n                  switch (node.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                      break;\n\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      s = this.measure(node.children[0], givenSize);\n                      w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                      h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                      break;\n\n                    case \"Default\":\n                      s = this.measure(node.children[0], givenSize);\n                      w = shapeWidth + this.options.horizontalSeparation + s.width;\n                      h = Math.max(shapeHeight, s.height);\n                      break;\n\n                    default:\n                      throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                  }\n\n                  break;\n\n                case \"Up\":\n                case \"Down\":\n                  switch (node.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      s = this.measure(node.children[0], givenSize);\n                      w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                      h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                      break;\n\n                    case \"Default\":\n                      s = this.measure(node.children[0], givenSize);\n                      h = shapeHeight + this.options.verticalSeparation + s.height;\n                      w = Math.max(shapeWidth, s.width);\n                      break;\n\n                    default:\n                      throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                  }\n\n                  break;\n\n                default:\n                  throw \"Unhandled TreeDirection in the layout measuring.\";\n              }\n\n              result = new Size(w, h);\n            } else {\n              var i, childNode;\n\n              switch (node.treeDirection) {\n                case \"Left\":\n                case \"Right\":\n                  switch (node.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      w = shapeWidth;\n                      h = shapeHeight + this.options.underneathVerticalTopOffset;\n\n                      for (i = 0; i < node.children.length; i++) {\n                        childNode = node.children[i];\n                        s = this.measure(childNode, givenSize);\n                        w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                        h += s.height + this.options.underneathVerticalSeparation;\n                      }\n\n                      h -= this.options.underneathVerticalSeparation;\n                      break;\n\n                    case \"Default\":\n                      w = shapeWidth;\n                      h = 0;\n\n                      for (i = 0; i < node.children.length; i++) {\n                        childNode = node.children[i];\n                        s = this.measure(childNode, givenSize);\n                        w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                        h += s.height + this.options.verticalSeparation;\n                      }\n\n                      h -= this.options.verticalSeparation;\n                      break;\n\n                    default:\n                      throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                  }\n\n                  break;\n\n                case \"Up\":\n                case \"Down\":\n                  switch (node.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      w = shapeWidth;\n                      h = shapeHeight + this.options.underneathVerticalTopOffset;\n\n                      for (i = 0; i < node.children.length; i++) {\n                        childNode = node.children[i];\n                        s = this.measure(childNode, givenSize);\n                        w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                        h += s.height + this.options.underneathVerticalSeparation;\n                      }\n\n                      h -= this.options.underneathVerticalSeparation;\n                      break;\n\n                    case \"Default\":\n                      w = 0;\n                      h = 0;\n\n                      for (i = 0; i < node.children.length; i++) {\n                        childNode = node.children[i];\n                        s = this.measure(childNode, givenSize);\n                        w += s.width + this.options.horizontalSeparation;\n                        h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                      }\n\n                      w -= this.options.horizontalSeparation;\n                      break;\n\n                    default:\n                      throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                  }\n\n                  break;\n\n                default:\n                  throw \"Unhandled TreeDirection in the layout measuring.\";\n              }\n\n              result = new Size(w, h);\n            }\n\n            node.SectorAngle = Math.sqrt(w * w / 4 + h * h / 4);\n            node.Size = result;\n            return result;\n          },\n          arrange: function (n, p) {\n            var i,\n                pp,\n                child,\n                node,\n                childrenwidth,\n                b = n.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n\n            if (Utils.isEmpty(n.children)) {\n              n.x = p.x;\n              n.y = p.y;\n              n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            } else {\n              var x, y;\n              var selfLocation;\n\n              switch (n.treeDirection) {\n                case \"Left\":\n                  switch (n.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      selfLocation = p;\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                      y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                      for (i = 0; i < node.children.length; i++) {\n                        node = node.children[i];\n                        x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                        pp = new Point(x, y);\n                        this.arrange(node, pp);\n                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                      }\n\n                      break;\n\n                    case \"Default\":\n                      selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + (n.Size.height - shapeHeight) / 2);\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                      x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n\n                      y = p.y;\n\n                      for (i = 0; i < n.children.length; i++) {\n                        node = n.children[i];\n                        pp = new Point(x - node.Size.width, y);\n                        this.arrange(node, pp);\n                        y += node.Size.height + this.options.verticalSeparation;\n                      }\n\n                      break;\n\n                    default:\n                      throw \"Unsupported TreeDirection\";\n                  }\n\n                  break;\n\n                case \"Right\":\n                  switch (n.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      selfLocation = p;\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                      x = p.x + shapeWidth + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n\n                      y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                      for (i = 0; i < n.children.length; i++) {\n                        node = n.children[i];\n                        pp = new Point(x, y);\n                        this.arrange(node, pp);\n                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                      }\n\n                      break;\n\n                    case \"Default\":\n                      selfLocation = new Point(p.x, p.y + (n.Size.height - shapeHeight) / 2);\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                      x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n\n                      y = p.y;\n\n                      for (i = 0; i < n.children.length; i++) {\n                        node = n.children[i];\n                        pp = new Point(x, y);\n                        this.arrange(node, pp);\n                        y += node.Size.height + this.options.verticalSeparation;\n                      }\n\n                      break;\n\n                    default:\n                      throw \"Unsupported TreeDirection\";\n                  }\n\n                  break;\n\n                case \"Up\":\n                  selfLocation = new Point(p.x + (n.Size.width - shapeWidth) / 2, p.y + n.Size.height - shapeHeight);\n                  n.x = selfLocation.x;\n                  n.y = selfLocation.y;\n                  n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n\n                  if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                    childrenwidth = 0; // means there is an aberration due to the oversized Element with respect to the children\n\n                    for (i = 0; i < n.children.length; i++) {\n                      child = n.children[i];\n                      childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                    }\n\n                    childrenwidth -= this.options.horizontalSeparation;\n                    x = p.x + (shapeWidth - childrenwidth) / 2;\n                  } else {\n                    x = p.x;\n                  }\n\n                  for (i = 0; i < n.children.length; i++) {\n                    node = n.children[i];\n                    y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                    pp = new Point(x, y);\n                    this.arrange(node, pp);\n                    x += node.Size.width + this.options.horizontalSeparation;\n                  }\n\n                  break;\n\n                case \"Down\":\n                  switch (n.childrenLayout) {\n                    case \"TopAlignedWithParent\":\n                    case \"BottomAlignedWithParent\":\n                      break;\n\n                    case \"Underneath\":\n                      selfLocation = p;\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                      x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n\n                      y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                      for (i = 0; i < n.children.length; i++) {\n                        node = n.children[i];\n                        pp = new Point(x, y);\n                        this.arrange(node, pp);\n                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                      }\n\n                      break;\n\n                    case \"Default\":\n                      selfLocation = new Point(p.x + (n.Size.width - shapeWidth) / 2, p.y);\n                      n.x = selfLocation.x;\n                      n.y = selfLocation.y;\n                      n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n\n                      if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                        childrenwidth = 0; // means there is an aberration due to the oversized Element with respect to the children\n\n                        for (i = 0; i < n.children.length; i++) {\n                          child = n.children[i];\n                          childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                        }\n\n                        childrenwidth -= this.options.horizontalSeparation;\n                        x = p.x + (shapeWidth - childrenwidth) / 2;\n                      } else {\n                        x = p.x;\n                      }\n\n                      for (i = 0; i < n.children.length; i++) {\n                        node = n.children[i];\n                        y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                        pp = new Point(x, y);\n                        this.arrange(node, pp);\n                        x += node.Size.width + this.options.horizontalSeparation;\n                      }\n\n                      break;\n\n                    default:\n                      throw \"Unsupported TreeDirection\";\n                  }\n\n                  break;\n\n                case \"None\":\n                  break;\n\n                default:\n                  throw \"Unsupported TreeDirection\";\n              }\n            }\n          },\n          layoutSwitch: function () {\n            if (!this.center) {\n              return;\n            }\n\n            if (Utils.isEmpty(this.center.children)) {\n              return;\n            }\n\n            var type = this.options.subtype;\n\n            if (Utils.isUndefined(type)) {\n              type = \"Down\";\n            }\n\n            var single, male, female, leftcount;\n            var children = this.center.children;\n\n            switch (type.toLowerCase()) {\n              case \"radial\":\n              case \"radialtree\":\n                this.layoutRadialTree();\n                break;\n\n              case \"mindmaphorizontal\":\n              case \"mindmap\":\n                single = this.center.children;\n\n                if (this.center.children.length === 1) {\n                  this.layoutRight(single);\n                } else {\n                  // odd number will give one more at the right\n                  leftcount = children.length / 2;\n                  male = grep(this.center.children, function (n) {\n                    return Utils.indexOf(children, n) < leftcount;\n                  });\n                  female = grep(this.center.children, function (n) {\n                    return Utils.indexOf(children, n) >= leftcount;\n                  });\n                  this.layoutLeft(male);\n                  this.layoutRight(female);\n                }\n\n                break;\n\n              case \"mindmapvertical\":\n                single = this.center.children;\n\n                if (this.center.children.length === 1) {\n                  this.layoutDown(single);\n                } else {\n                  // odd number will give one more at the right\n                  leftcount = children.length / 2;\n                  male = grep(this.center.children, function (n) {\n                    return Utils.indexOf(children, n) < leftcount;\n                  });\n                  female = grep(this.center.children, function (n) {\n                    return Utils.indexOf(children, n) >= leftcount;\n                  });\n                  this.layoutUp(male);\n                  this.layoutDown(female);\n                }\n\n                break;\n\n              case \"right\":\n                this.layoutRight(this.center.children);\n                break;\n\n              case \"left\":\n                this.layoutLeft(this.center.children);\n                break;\n\n              case \"up\":\n              case \"bottom\":\n                this.layoutUp(this.center.children);\n                break;\n\n              case \"down\":\n              case \"top\":\n                this.layoutDown(this.center.children);\n                break;\n\n              case \"tipover\":\n              case \"tipovertree\":\n                if (this.options.tipOverTreeStartLevel < 0) {\n                  throw \"The tip-over level should be a positive integer.\";\n                }\n\n                this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                break;\n\n              case \"undefined\":\n              case \"none\":\n                break;\n            }\n          }\n        });\n        /**\n         * The various tree layout algorithms.\n         * @type {*}\n         */\n\n        var TreeLayout = LayoutBase.extend({\n          init: function (diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n\n            if (Utils.isUndefined(diagram)) {\n              throw \"No diagram specified.\";\n            }\n\n            this.diagram = diagram;\n          },\n\n          /**\n           * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n           */\n          layout: function (options) {\n            this.transferOptions(options); // transform the diagram into a Graph\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            /**\n             * The Graph reduction from the given diagram.\n             * @type {*}\n             */\n\n            this.graph = adapter.convert();\n            var finalNodeSet = this.layoutComponents(); // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n          },\n          layoutComponents: function () {\n            if (this.graph.isEmpty()) {\n              return;\n            } // split into connected components\n\n\n            var components = this.graph.getConnectedComponents();\n\n            if (Utils.isEmpty(components)) {\n              return;\n            }\n\n            var layout = new TreeLayoutProcessor(this.options);\n            var trees = []; // find a spanning tree for each component\n\n            for (var i = 0; i < components.length; i++) {\n              var component = components[i];\n              var treeGraph = this.getTree(component);\n\n              if (!treeGraph) {\n                throw \"Failed to find a spanning tree for the component.\";\n              }\n\n              var root = treeGraph.root;\n              var tree = treeGraph.tree;\n              layout.layout(tree, root);\n              trees.push(tree);\n            }\n\n            return this.gridLayoutComponents(trees);\n          },\n\n          /**\n           * Gets a spanning tree (and root) for the given graph.\n           * Ensure that the given graph is connected!\n           * @param graph\n           * @returns {*} A literal object consisting of the found root and the spanning tree.\n           */\n          getTree: function (graph) {\n            var root = null;\n\n            if (this.options.roots && this.options.roots.length > 0) {\n              for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                var node = graph.nodes[i];\n\n                for (var j = 0; j < this.options.roots.length; j++) {\n                  var givenRootShape = this.options.roots[j];\n\n                  if (givenRootShape === node.associatedShape) {\n                    root = node;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (!root) {\n              // finds the most probable root on the basis of the longest path in the component\n              root = graph.root(); // should not happen really\n\n              if (!root) {\n                throw \"Unable to find a root for the tree.\";\n              }\n            }\n\n            return this.getTreeForRoot(graph, root);\n          },\n          getTreeForRoot: function (graph, root) {\n            var tree = graph.getSpanningTree(root);\n\n            if (Utils.isUndefined(tree) || tree.isEmpty()) {\n              return null;\n            }\n\n            return {\n              tree: tree,\n              root: tree.root\n            };\n          }\n        });\n        /**\n         * The Sugiyama aka layered layout algorithm.\n         * @type {*}\n         */\n\n        var LayeredLayout = LayoutBase.extend({\n          init: function (diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n\n            if (Utils.isUndefined(diagram)) {\n              throw \"Diagram is not specified.\";\n            }\n\n            this.diagram = diagram;\n          },\n          layout: function (options) {\n            this.transferOptions(options);\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n\n            if (graph.isEmpty()) {\n              return;\n            } // split into connected components\n\n\n            var components = graph.getConnectedComponents();\n\n            if (Utils.isEmpty(components)) {\n              return;\n            }\n\n            for (var i = 0; i < components.length; i++) {\n              var component = components[i];\n              this.layoutGraph(component, options);\n            }\n\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n          },\n\n          /**\n           * Initializes the runtime data properties of the layout.\n           * @private\n           */\n          _initRuntimeProperties: function () {\n            for (var k = 0; k < this.graph.nodes.length; k++) {\n              var node = this.graph.nodes[k];\n              node.layer = -1;\n              node.downstreamLinkCount = 0;\n              node.upstreamLinkCount = 0;\n              node.isVirtual = false;\n              node.uBaryCenter = 0.0;\n              node.dBaryCenter = 0.0;\n              node.upstreamPriority = 0;\n              node.downstreamPriority = 0;\n              node.gridPosition = 0;\n            }\n          },\n          _prepare: function (graph) {\n            var current = [],\n                i,\n                l,\n                link; // defines a mapping of a node to the layer index\n\n            var layerMap = new Dictionary();\n            var layerCount = 0;\n            var targetLayer, next, target;\n            Utils.forEach(graph.nodes, function (node) {\n              if (node.incoming.length === 0) {\n                layerMap.set(node, 0);\n                current.push(node);\n              }\n            });\n\n            while (current.length > 0) {\n              next = current.shift();\n\n              for (i = 0; i < next.outgoing.length; i++) {\n                link = next.outgoing[i];\n                target = link.target;\n\n                if (layerMap.containsKey(target)) {\n                  targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                } else {\n                  targetLayer = layerMap.get(next) + 1;\n                }\n\n                layerMap.set(target, targetLayer);\n\n                if (targetLayer > layerCount) {\n                  layerCount = targetLayer;\n                }\n\n                if (!contains(current, target)) {\n                  current.push(target);\n                }\n              }\n            }\n\n            var sortedNodes = layerMap.keys();\n            sortedNodes.sort(function (o1, o2) {\n              var o1layer = layerMap.get(o1);\n              var o2layer = layerMap.get(o2);\n              return Utils.sign(o2layer - o1layer);\n            });\n\n            for (var n = 0; n < sortedNodes.length; ++n) {\n              var node = sortedNodes[n];\n              var minLayer = Number.MAX_VALUE;\n\n              if (node.outgoing.length === 0) {\n                continue;\n              }\n\n              for (l = 0; l < node.outgoing.length; ++l) {\n                link = node.outgoing[l];\n                minLayer = Math.min(minLayer, layerMap.get(link.target));\n              }\n\n              if (minLayer > 1) {\n                layerMap.set(node, minLayer - 1);\n              }\n            }\n\n            this.layers = [];\n            var layer;\n\n            for (i = 0; i < layerCount + 1; i++) {\n              layer = [];\n              layer.linksTo = {};\n              this.layers.push(layer);\n            }\n\n            layerMap.forEach(function (node, layer) {\n              node.layer = layer;\n              this.layers[layer].push(node);\n            }, this); // set initial grid positions\n\n            for (l = 0; l < this.layers.length; l++) {\n              layer = this.layers[l];\n\n              for (i = 0; i < layer.length; i++) {\n                layer[i].gridPosition = i;\n              }\n            }\n          },\n\n          /**\n           * Performs the layout of a single component.\n           */\n          layoutGraph: function (graph, options) {\n            if (Utils.isUndefined(graph)) {\n              throw \"No graph given or graph analysis of the diagram failed.\";\n            }\n\n            if (Utils.isDefined(options)) {\n              this.transferOptions(options);\n            }\n\n            this.graph = graph; // sets unique indices on the nodes\n\n            graph.setItemIndices(); // ensures no cycles present for this layout\n\n            var reversedEdges = graph.makeAcyclic(); // define the runtime props being used by the layout algorithm\n\n            this._initRuntimeProperties();\n\n            this._prepare(graph, options);\n\n            this._dummify();\n\n            this._optimizeCrossings();\n\n            this._swapPairs();\n\n            this.arrangeNodes();\n\n            this._moveThingsAround();\n\n            this._dedummify(); // re-reverse the links which were switched earlier\n\n\n            Utils.forEach(reversedEdges, function (e) {\n              if (e.points) {\n                e.points.reverse();\n              }\n            });\n          },\n          setMinDist: function (m, n, minDist) {\n            var l = m.layer;\n            var i = m.layerIndex;\n            this.minDistances[l][i] = minDist;\n          },\n          getMinDist: function (m, n) {\n            var dist = 0,\n                i1 = m.layerIndex,\n                i2 = n.layerIndex,\n                l = m.layer,\n                min = Math.min(i1, i2),\n                max = Math.max(i1, i2); // use Sum()?\n\n            for (var k = min; k < max; ++k) {\n              dist += this.minDistances[l][k];\n            }\n\n            return dist;\n          },\n          placeLeftToRight: function (leftClasses) {\n            var leftPos = new Dictionary(),\n                n,\n                node;\n\n            for (var c = 0; c < this.layers.length; ++c) {\n              var classNodes = leftClasses[c];\n\n              if (!classNodes) {\n                continue;\n              }\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n\n                if (!leftPos.containsKey(node)) {\n                  this.placeLeft(node, leftPos, c);\n                }\n              } // adjust class\n\n\n              var d = Number.POSITIVE_INFINITY;\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n                var rightSibling = this.rightSibling(node);\n\n                if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                  d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                }\n              }\n\n              if (d === Number.POSITIVE_INFINITY) {\n                var D = [];\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  var neighbors = [];\n                  Utils.addRange(neighbors, this.upNodes.get(node));\n                  Utils.addRange(neighbors, this.downNodes.get(node));\n\n                  for (var e = 0; e < neighbors.length; e++) {\n                    var neighbor = neighbors[e];\n\n                    if (this.nodeLeftClass.get(neighbor) < c) {\n                      D.push(leftPos.get(neighbor) - leftPos.get(node));\n                    }\n                  }\n                }\n\n                D.sort();\n\n                if (D.length === 0) {\n                  d = 0;\n                } else if (D.length % 2 === 1) {\n                  d = D[this.intDiv(D.length, 2)];\n                } else {\n                  d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                }\n              }\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n                leftPos.set(node, leftPos.get(node) + d);\n              }\n            }\n\n            return leftPos;\n          },\n          placeRightToLeft: function (rightClasses) {\n            var rightPos = new Dictionary(),\n                n,\n                node;\n\n            for (var c = 0; c < this.layers.length; ++c) {\n              var classNodes = rightClasses[c];\n\n              if (!classNodes) {\n                continue;\n              }\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n\n                if (!rightPos.containsKey(node)) {\n                  this.placeRight(node, rightPos, c);\n                }\n              } // adjust class\n\n\n              var d = Number.NEGATIVE_INFINITY;\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n                var leftSibling = this.leftSibling(node);\n\n                if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                  d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                }\n              }\n\n              if (d === Number.NEGATIVE_INFINITY) {\n                var D = [];\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  var neighbors = [];\n                  Utils.addRange(neighbors, this.upNodes.get(node));\n                  Utils.addRange(neighbors, this.downNodes.get(node));\n\n                  for (var e = 0; e < neighbors.length; e++) {\n                    var neighbor = neighbors[e];\n\n                    if (this.nodeRightClass.get(neighbor) < c) {\n                      D.push(rightPos.get(node) - rightPos.get(neighbor));\n                    }\n                  }\n                }\n\n                D.sort();\n\n                if (D.length === 0) {\n                  d = 0;\n                } else if (D.length % 2 === 1) {\n                  d = D[this.intDiv(D.length, 2)];\n                } else {\n                  d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                }\n              }\n\n              for (n = 0; n < classNodes.length; n++) {\n                node = classNodes[n];\n                rightPos.set(node, rightPos.get(node) + d);\n              }\n            }\n\n            return rightPos;\n          },\n          _getLeftWing: function () {\n            var leftWing = {\n              value: null\n            };\n            var result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n          },\n          _getRightWing: function () {\n            var rightWing = {\n              value: null\n            };\n            var result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n          },\n          computeClasses: function (wingPair, d) {\n            var currentWing = 0,\n                wing = wingPair.value = new Dictionary();\n\n            for (var l = 0; l < this.layers.length; ++l) {\n              currentWing = l;\n              var layer = this.layers[l];\n\n              for (var n = d === 1 ? 0 : layer.length - 1; 0 <= n && n < layer.length; n += d) {\n                var node = layer[n];\n\n                if (!wing.containsKey(node)) {\n                  wing.set(node, currentWing);\n\n                  if (node.isVirtual) {\n                    var ndsinl = this._nodesInLink(node);\n\n                    for (var kk = 0; kk < ndsinl.length; kk++) {\n                      var vnode = ndsinl[kk];\n                      wing.set(vnode, currentWing);\n                    }\n                  }\n                } else {\n                  currentWing = wing.get(node);\n                }\n              }\n            }\n\n            var wings = [];\n\n            for (var i = 0; i < this.layers.length; i++) {\n              wings.push(null);\n            }\n\n            wing.forEach(function (node, classIndex) {\n              if (wings[classIndex] === null) {\n                wings[classIndex] = [];\n              }\n\n              wings[classIndex].push(node);\n            });\n            return wings;\n          },\n          _isVerticalLayout: function () {\n            return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n          },\n          _isHorizontalLayout: function () {\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n          },\n          _isIncreasingLayout: function () {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n          },\n          _moveThingsAround: function () {\n            var i, l, node, layer, n, w; // sort the layers by their grid position\n\n            for (l = 0; l < this.layers.length; ++l) {\n              layer = this.layers[l];\n              layer.sort(this._gridPositionComparer);\n            }\n\n            this.minDistances = [];\n\n            for (l = 0; l < this.layers.length; ++l) {\n              layer = this.layers[l];\n              this.minDistances[l] = [];\n\n              for (n = 0; n < layer.length; ++n) {\n                node = layer[n];\n                node.layerIndex = n;\n                this.minDistances[l][n] = this.options.nodeDistance;\n\n                if (n < layer.length - 1) {\n                  if (this._isVerticalLayout()) {\n                    this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                  } else {\n                    this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                  }\n                }\n              }\n            }\n\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            Utils.forEach(this.graph.nodes, function (node) {\n              this.downNodes.set(node, []);\n              this.upNodes.set(node, []);\n            }, this);\n            Utils.forEach(this.graph.links, function (link) {\n              var origin = link.source;\n              var dest = link.target;\n              var down = null,\n                  up = null;\n\n              if (origin.layer > dest.layer) {\n                down = link.source;\n                up = link.target;\n              } else {\n                up = link.source;\n                down = link.target;\n              }\n\n              this.downNodes.get(up).push(down);\n              this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function (list) {\n              list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function (list) {\n              list.sort(this._gridPositionComparer);\n            }, this);\n\n            for (l = 0; l < this.layers.length - 1; ++l) {\n              layer = this.layers[l];\n\n              for (w = 0; w < layer.length - 1; w++) {\n                var currentNode = layer[w];\n\n                if (!currentNode.isVirtual) {\n                  continue;\n                }\n\n                var currDown = this.downNodes.get(currentNode)[0];\n\n                if (!currDown.isVirtual) {\n                  continue;\n                }\n\n                for (n = w + 1; n < layer.length; ++n) {\n                  node = layer[n];\n\n                  if (!node.isVirtual) {\n                    continue;\n                  }\n\n                  var downNode = this.downNodes.get(node)[0];\n\n                  if (!downNode.isVirtual) {\n                    continue;\n                  }\n\n                  if (currDown.gridPosition > downNode.gridPosition) {\n                    var pos = currDown.gridPosition;\n                    currDown.gridPosition = downNode.gridPosition;\n                    downNode.gridPosition = pos;\n                    var i1 = currDown.layerIndex;\n                    var i2 = downNode.layerIndex;\n                    this.layers[l + 1][i1] = downNode;\n                    this.layers[l + 1][i2] = currDown;\n                    currDown.layerIndex = i2;\n                    downNode.layerIndex = i1;\n                  }\n                }\n              }\n            }\n\n            var leftClasses = this._getLeftWing();\n\n            var rightClasses = this._getRightWing();\n\n            var leftPos = this.placeLeftToRight(leftClasses);\n            var rightPos = this.placeRightToLeft(rightClasses);\n            var x = new Dictionary();\n            Utils.forEach(this.graph.nodes, function (node) {\n              x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n            });\n            var order = new Dictionary();\n            var placed = new Dictionary();\n\n            for (l = 0; l < this.layers.length; ++l) {\n              layer = this.layers[l];\n              var sequenceStart = -1,\n                  sequenceEnd = -1;\n\n              for (n = 0; n < layer.length; ++n) {\n                node = layer[n];\n                order.set(node, 0);\n                placed.set(node, false);\n\n                if (node.isVirtual) {\n                  if (sequenceStart === -1) {\n                    sequenceStart = n;\n                  } else if (sequenceStart === n - 1) {\n                    sequenceStart = n;\n                  } else {\n                    sequenceEnd = n;\n                    order.set(layer[sequenceStart], 0);\n\n                    if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                      placed.set(layer[sequenceStart], true);\n                    } else {\n                      placed.set(layer[sequenceStart], false);\n                    }\n\n                    sequenceStart = n;\n                  }\n                }\n              }\n            }\n\n            var directions = [1, -1];\n            Utils.forEach(directions, function (d) {\n              var start = d === 1 ? 0 : this.layers.length - 1;\n\n              for (var l = start; 0 <= l && l < this.layers.length; l += d) {\n                var layer = this.layers[l];\n\n                var virtualStartIndex = this._firstVirtualNode(layer);\n\n                var virtualStart = null;\n                var sequence = null;\n\n                if (virtualStartIndex !== -1) {\n                  virtualStart = layer[virtualStartIndex];\n                  sequence = [];\n\n                  for (i = 0; i < virtualStartIndex; i++) {\n                    sequence.push(layer[i]);\n                  }\n                } else {\n                  virtualStart = null;\n                  sequence = layer;\n                }\n\n                if (sequence.length > 0) {\n                  this._sequencer(x, null, virtualStart, d, sequence);\n\n                  for (i = 0; i < sequence.length - 1; ++i) {\n                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                  }\n\n                  if (virtualStart) {\n                    this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                  }\n                }\n\n                while (virtualStart) {\n                  var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n\n                  if (!virtualEnd) {\n                    virtualStartIndex = virtualStart.layerIndex;\n                    sequence = [];\n\n                    for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                      sequence.push(layer[i]);\n                    }\n\n                    if (sequence.length > 0) {\n                      this._sequencer(x, virtualStart, null, d, sequence);\n\n                      for (i = 0; i < sequence.length - 1; ++i) {\n                        this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                      }\n\n                      this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                    }\n                  } else if (order.get(virtualStart) === d) {\n                    virtualStartIndex = virtualStart.layerIndex;\n                    var virtualEndIndex = virtualEnd.layerIndex;\n                    sequence = [];\n\n                    for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                      sequence.push(layer[i]);\n                    }\n\n                    if (sequence.length > 0) {\n                      this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                    }\n\n                    placed.set(virtualStart, true);\n                  }\n\n                  virtualStart = virtualEnd;\n                }\n\n                this.adjustDirections(l, d, order, placed);\n              }\n            }, this);\n            var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n\n            var reachedFinalLayerIndex = function (k, ctx) {\n              if (ctx._isIncreasingLayout()) {\n                return k < ctx.layers.length;\n              } else {\n                return k >= 0;\n              }\n            };\n\n            var layerIncrement = this._isIncreasingLayout() ? +1 : -1,\n                offset = 0;\n            /**\n             * Calcs the max height of the given layer.\n             */\n\n            function maximumHeight(layer, ctx) {\n              var height = Number.MIN_VALUE;\n\n              for (var n = 0; n < layer.length; ++n) {\n                var node = layer[n];\n\n                if (ctx._isVerticalLayout()) {\n                  height = Math.max(height, node.height);\n                } else {\n                  height = Math.max(height, node.width);\n                }\n              }\n\n              return height;\n            }\n\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n              layer = this.layers[i];\n              var height = maximumHeight(layer, this);\n\n              for (n = 0; n < layer.length; ++n) {\n                node = layer[n];\n\n                if (this._isVerticalLayout()) {\n                  node.x = x.get(node);\n                  node.y = offset + height / 2;\n                } else {\n                  node.x = offset + height / 2;\n                  node.y = x.get(node);\n                }\n              }\n\n              offset += this.options.layerSeparation + height;\n            }\n          },\n          adjustDirections: function (l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n              return;\n            }\n\n            var prevBridge = null,\n                prevBridgeTarget = null;\n            var layer = this.layers[l + d];\n\n            for (var n = 0; n < layer.length; ++n) {\n              var nextBridge = layer[n];\n\n              if (nextBridge.isVirtual) {\n                var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n\n                if (nextBridgeTarget.isVirtual) {\n                  if (prevBridge) {\n                    var p = placed.get(prevBridgeTarget);\n                    var clayer = this.layers[l];\n                    var i1 = prevBridgeTarget.layerIndex;\n                    var i2 = nextBridgeTarget.layerIndex;\n\n                    for (var i = i1 + 1; i < i2; ++i) {\n                      if (clayer[i].isVirtual) {\n                        p = p && placed.get(clayer[i]);\n                      }\n                    }\n\n                    if (p) {\n                      order.set(prevBridge, d);\n                      var j1 = prevBridge.layerIndex;\n                      var j2 = nextBridge.layerIndex;\n\n                      for (var j = j1 + 1; j < j2; ++j) {\n                        if (layer[j].isVirtual) {\n                          order.set(layer[j], d);\n                        }\n                      }\n                    }\n                  }\n\n                  prevBridge = nextBridge;\n                  prevBridgeTarget = nextBridgeTarget;\n                }\n              }\n            }\n          },\n          getNeighborOnLayer: function (node, l) {\n            var neighbor = this.upNodes.get(node)[0];\n\n            if (neighbor.layer === l) {\n              return neighbor;\n            }\n\n            neighbor = this.downNodes.get(node)[0];\n\n            if (neighbor.layer === l) {\n              return neighbor;\n            }\n\n            return null;\n          },\n          _sequencer: function (x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n              this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n\n            if (sequence.length > 1) {\n              var r = sequence.length,\n                  t = this.intDiv(r, 2);\n\n              this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n\n              this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n\n              this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n          },\n          _sequenceSingle: function (x, virtualStart, virtualEnd, dir, node) {\n            var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n            var n = neighbors.length;\n\n            if (n !== 0) {\n              if (n % 2 === 1) {\n                x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n              } else {\n                x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n              }\n\n              if (virtualStart) {\n                x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n              }\n\n              if (virtualEnd) {\n                x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n              }\n            }\n          },\n          combineSequences: function (x, virtualStart, virtualEnd, dir, sequence) {\n            var r = sequence.length,\n                t = this.intDiv(r, 2); // collect left changes\n\n            var leftHeap = [],\n                i,\n                c,\n                n,\n                neighbors,\n                neighbor,\n                pair;\n\n            for (i = 0; i < t; ++i) {\n              c = 0;\n              neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n\n              for (n = 0; n < neighbors.length; ++n) {\n                neighbor = neighbors[n];\n\n                if (x.get(neighbor) >= x.get(sequence[i])) {\n                  c++;\n                } else {\n                  c--;\n                  leftHeap.push({\n                    k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]),\n                    v: 2\n                  });\n                }\n              }\n\n              leftHeap.push({\n                k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]),\n                v: c\n              });\n            }\n\n            if (virtualStart) {\n              leftHeap.push({\n                k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]),\n                v: Number.MAX_VALUE\n              });\n            }\n\n            leftHeap.sort(this._positionDescendingComparer); // collect right changes\n\n            var rightHeap = [];\n\n            for (i = t; i < r; ++i) {\n              c = 0;\n              neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n\n              for (n = 0; n < neighbors.length; ++n) {\n                neighbor = neighbors[n];\n\n                if (x.get(neighbor) <= x.get(sequence[i])) {\n                  c++;\n                } else {\n                  c--;\n                  rightHeap.push({\n                    k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]),\n                    v: 2\n                  });\n                }\n              }\n\n              rightHeap.push({\n                k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]),\n                v: c\n              });\n            }\n\n            if (virtualEnd) {\n              rightHeap.push({\n                k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]),\n                v: Number.MAX_VALUE\n              });\n            }\n\n            rightHeap.sort(this._positionAscendingComparer);\n            var leftRes = 0,\n                rightRes = 0;\n            var m = this.getMinDist(sequence[t - 1], sequence[t]);\n\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n              if (leftRes < rightRes) {\n                if (leftHeap.length === 0) {\n                  x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                  break;\n                } else {\n                  pair = leftHeap.shift();\n                  leftRes = leftRes + pair.v;\n                  x.set(sequence[t - 1], pair.k);\n                  x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                }\n              } else {\n                if (rightHeap.length === 0) {\n                  x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                  break;\n                } else {\n                  pair = rightHeap.shift();\n                  rightRes = rightRes + pair.v;\n                  x.set(sequence[t], pair.k);\n                  x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                }\n              }\n            }\n\n            for (i = t - 2; i >= 0; i--) {\n              x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n\n            for (i = t + 1; i < r; i++) {\n              x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n          },\n          placeLeft: function (node, leftPos, leftClass) {\n            var pos = Number.NEGATIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function (v) {\n              var leftSibling = this.leftSibling(v);\n\n              if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                if (!leftPos.containsKey(leftSibling)) {\n                  this.placeLeft(leftSibling, leftPos, leftClass);\n                }\n\n                pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n              }\n            }, this);\n\n            if (pos === Number.NEGATIVE_INFINITY) {\n              pos = 0;\n            }\n\n            Utils.forEach(this._getComposite(node), function (v) {\n              leftPos.set(v, pos);\n            });\n          },\n          placeRight: function (node, rightPos, rightClass) {\n            var pos = Number.POSITIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function (v) {\n              var rightSibling = this.rightSibling(v);\n\n              if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                if (!rightPos.containsKey(rightSibling)) {\n                  this.placeRight(rightSibling, rightPos, rightClass);\n                }\n\n                pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n              }\n            }, this);\n\n            if (pos === Number.POSITIVE_INFINITY) {\n              pos = 0;\n            }\n\n            Utils.forEach(this._getComposite(node), function (v) {\n              rightPos.set(v, pos);\n            });\n          },\n          leftSibling: function (node) {\n            var layer = this.layers[node.layer],\n                layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n          },\n          rightSibling: function (node) {\n            var layer = this.layers[node.layer];\n            var layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n          },\n          _getComposite: function (node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n          },\n          arrangeNodes: function () {\n            var i, l, ni, layer, node; // Initialize node's base priority\n\n            for (l = 0; l < this.layers.length; l++) {\n              layer = this.layers[l];\n\n              for (ni = 0; ni < layer.length; ni++) {\n                node = layer[ni];\n                node.upstreamPriority = node.upstreamLinkCount;\n                node.downstreamPriority = node.downstreamLinkCount;\n              }\n            } // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n\n\n            var maxLayoutIterations = 2;\n\n            for (var it = 0; it < maxLayoutIterations; it++) {\n              for (i = this.layers.length - 1; i >= 1; i--) {\n                this.layoutLayer(false, i);\n              }\n\n              for (i = 0; i < this.layers.length - 1; i++) {\n                this.layoutLayer(true, i);\n              }\n            } // Offset the whole structure so that there are no gridPositions < 0\n\n\n            var gridPos = Number.MAX_VALUE;\n\n            for (l = 0; l < this.layers.length; l++) {\n              layer = this.layers[l];\n\n              for (ni = 0; ni < layer.length; ni++) {\n                node = layer[ni];\n                gridPos = Math.min(gridPos, node.gridPosition);\n              }\n            }\n\n            if (gridPos < 0) {\n              for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                  node = layer[ni];\n                  node.gridPosition = node.gridPosition - gridPos;\n                }\n              }\n            }\n          },\n          /// <summary>\n          /// Layout of a single layer.\n          /// </summary>\n          /// <param name=\"layerIndex\">The layer to organize.</param>\n          /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n          /// <seealso cref=\"OptimizeCrossings()\"/>\n          layoutLayer: function (down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n              considered = this.layers[iconsidered = layer + 1];\n            } else {\n              considered = this.layers[iconsidered = layer - 1];\n            } // list containing the nodes in the considered layer sorted by priority\n\n\n            var sorted = [];\n\n            for (var n = 0; n < considered.length; n++) {\n              sorted.push(considered[n]);\n            }\n\n            sorted.sort(function (n1, n2) {\n              var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n              var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n              if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                return 0;\n              }\n\n              if (n1Priority < n2Priority) {\n                return 1;\n              }\n\n              return -1;\n            }); // each node strives for its barycenter; high priority nodes start first\n\n            Utils.forEach(sorted, function (node) {\n              var nodeGridPos = node.gridPosition;\n              var nodeBaryCenter = this.calcBaryCenter(node);\n              var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n              if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                // This node is exactly at its barycenter -> perfect\n                return;\n              }\n\n              if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                // This node is close enough to the barycenter -> should work\n                return;\n              }\n\n              if (nodeGridPos < nodeBaryCenter) {\n                // Try to move the node to the right in an\n                // attempt to reach its barycenter\n                while (nodeGridPos < nodeBaryCenter) {\n                  if (!this.moveRight(node, considered, nodePriority)) {\n                    break;\n                  }\n\n                  nodeGridPos = node.gridPosition;\n                }\n              } else {\n                // Try to move the node to the left in an\n                // attempt to reach its barycenter\n                while (nodeGridPos > nodeBaryCenter) {\n                  if (!this.moveLeft(node, considered, nodePriority)) {\n                    break;\n                  }\n\n                  nodeGridPos = node.gridPosition;\n                }\n              }\n            }, this); // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n\n            if (iconsidered > 0) {\n              this.calcDownData(iconsidered - 1);\n            }\n\n            if (iconsidered < this.layers.length - 1) {\n              this.calcUpData(iconsidered + 1);\n            }\n          },\n          /// <summary>\n          /// Moves the node to the right and returns <c>true</c> if this was possible.\n          /// </summary>\n          /// <param name=\"node\">The node.</param>\n          /// <param name=\"layer\">The layer.</param>\n          /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n          moveRight: function (node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n\n            if (index === layer.length - 1) {\n              // this is the last node in the layer, so we can move to the right without troubles\n              node.gridPosition = node.gridPosition + 0.5;\n              return true;\n            }\n\n            var rightNode = layer[index + 1];\n            var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2; // check if there is space between the right and the current node\n\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n              node.gridPosition = node.gridPosition + 0.5;\n              return true;\n            } // we have reached a node with higher priority; no movement is allowed\n\n\n            if (rightNodePriority > priority || Math.abs(rightNodePriority - priority) < 0.0001) {\n              return false;\n            } // the right node has lower priority - try to move it\n\n\n            if (this.moveRight(rightNode, layer, priority)) {\n              node.gridPosition = node.gridPosition + 0.5;\n              return true;\n            }\n\n            return false;\n          },\n          /// <summary>\n          /// Moves the node to the left and returns <c>true</c> if this was possible.\n          /// </summary>\n          /// <param name=\"node\">The node.</param>\n          /// <param name=\"layer\">The layer.</param>\n          /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n          moveLeft: function (node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n\n            if (index === 0) {\n              // this is the last node in the layer, so we can move to the left without troubles\n              node.gridPosition = node.gridPosition - 0.5;\n              return true;\n            }\n\n            var leftNode = layer[index - 1];\n            var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2; // check if there is space between the left and the current node\n\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n              node.gridPosition = node.gridPosition - 0.5;\n              return true;\n            } // we have reached a node with higher priority; no movement is allowed\n\n\n            if (leftNodePriority > priority || Math.abs(leftNodePriority - priority) < 0.0001) {\n              return false;\n            } // The left node has lower priority - try to move it\n\n\n            if (this.moveLeft(leftNode, layer, priority)) {\n              node.gridPosition = node.gridPosition - 0.5;\n              return true;\n            }\n\n            return false;\n          },\n          mapVirtualNode: function (node, link) {\n            this.nodeToLinkMap.set(node, link);\n\n            if (!this.linkToNodeMap.containsKey(link)) {\n              this.linkToNodeMap.set(link, []);\n            }\n\n            this.linkToNodeMap.get(link).push(node);\n          },\n          _nodesInLink: function (node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n          },\n          /// <summary>\n          /// Inserts dummy nodes to break long links.\n          /// </summary>\n          _dummify: function () {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n            var layer,\n                pos,\n                newNode,\n                node,\n                r,\n                newLink,\n                i,\n                l,\n                links = this.graph.links.slice(0);\n            var layers = this.layers;\n\n            var addLinkBetweenLayers = function (upLayer, downLayer, link) {\n              layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n              layers[upLayer].linksTo[downLayer].push(link);\n            };\n\n            for (l = 0; l < links.length; l++) {\n              var link = links[l];\n              var o = link.source;\n              var d = link.target;\n              var oLayer = o.layer;\n              var dLayer = d.layer;\n              var oPos = o.gridPosition;\n              var dPos = d.gridPosition;\n              var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n              var p = o;\n\n              if (oLayer - dLayer > 1) {\n                for (i = oLayer - 1; i > dLayer; i--) {\n                  newNode = new Node();\n                  newNode.x = o.x;\n                  newNode.y = o.y;\n                  newNode.width = o.width / 100;\n                  newNode.height = o.height / 100;\n                  layer = layers[i];\n                  pos = (i - dLayer) * step + oPos;\n\n                  if (pos > layer.length) {\n                    pos = layer.length;\n                  } // check if origin and dest are both last\n\n\n                  if (oPos >= layers[oLayer].length - 1 && dPos >= layers[dLayer].length - 1) {\n                    pos = layer.length;\n                  } // check if origin and destination are both first\n                  else if (oPos === 0 && dPos === 0) {\n                    pos = 0;\n                  }\n\n                  newNode.layer = i;\n                  newNode.uBaryCenter = 0.0;\n                  newNode.dBaryCenter = 0.0;\n                  newNode.upstreamLinkCount = 0;\n                  newNode.downstreamLinkCount = 0;\n                  newNode.gridPosition = pos;\n                  newNode.isVirtual = true;\n                  Utils.insert(layer, newNode, pos); // translate rightwards nodes' positions\n\n                  for (r = pos + 1; r < layer.length; r++) {\n                    node = layer[r];\n                    node.gridPosition = node.gridPosition + 1;\n                  }\n\n                  newLink = new Link(p, newNode);\n                  newLink.depthOfDumminess = 0;\n                  addLinkBetweenLayers(i - 1, i, newLink);\n                  p = newNode; // add the new node and the new link to the graph\n\n                  this.graph._addNode(newNode);\n\n                  this.graph.addLink(newLink);\n                  newNode.index = this.graph.nodes.length - 1;\n                  this.mapVirtualNode(newNode, link);\n                } // set the origin of the real arrow to the last dummy\n\n\n                addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                link.changeSource(p);\n                link.depthOfDumminess = oLayer - dLayer - 1;\n              } else if (oLayer - dLayer < -1) {\n                for (i = oLayer + 1; i < dLayer; i++) {\n                  newNode = new Node();\n                  newNode.x = o.x;\n                  newNode.y = o.y;\n                  newNode.width = o.width / 100;\n                  newNode.height = o.height / 100;\n                  layer = layers[i];\n                  pos = (i - oLayer) * step + oPos;\n\n                  if (pos > layer.length) {\n                    pos = layer.length;\n                  } // check if origin and dest are both last\n\n\n                  if (oPos >= layers[oLayer].length - 1 && dPos >= layers[dLayer].length - 1) {\n                    pos = layer.length;\n                  } // check if origin and destination are both first\n                  else if (oPos === 0 && dPos === 0) {\n                    pos = 0;\n                  }\n\n                  newNode.layer = i;\n                  newNode.uBaryCenter = 0.0;\n                  newNode.dBaryCenter = 0.0;\n                  newNode.upstreamLinkCount = 0;\n                  newNode.downstreamLinkCount = 0;\n                  newNode.gridPosition = pos;\n                  newNode.isVirtual = true;\n                  pos &= pos; // truncates to int\n\n                  Utils.insert(layer, newNode, pos); // translate rightwards nodes' positions\n\n                  for (r = pos + 1; r < layer.length; r++) {\n                    node = layer[r];\n                    node.gridPosition = node.gridPosition + 1;\n                  }\n\n                  newLink = new Link(p, newNode);\n                  newLink.depthOfDumminess = 0;\n                  addLinkBetweenLayers(i - 1, i, newLink);\n                  p = newNode; // add the new node and the new link to the graph\n\n                  this.graph._addNode(newNode);\n\n                  this.graph.addLink(newLink);\n                  newNode.index = this.graph.nodes.length - 1;\n                  this.mapVirtualNode(newNode, link);\n                }\n\n                addLinkBetweenLayers(dLayer - 1, dLayer, link); // Set the origin of the real arrow to the last dummy\n\n                link.changeSource(p);\n                link.depthOfDumminess = dLayer - oLayer - 1;\n              } else {\n                addLinkBetweenLayers(oLayer, dLayer, link);\n              }\n            }\n          },\n          /// <summary>\n          /// Removes the dummy nodes inserted earlier to break long links.\n          /// </summary>\n          /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n          _dedummify: function () {\n            var dedum = true;\n\n            while (dedum) {\n              dedum = false;\n\n              for (var l = 0; l < this.graph.links.length; l++) {\n                var link = this.graph.links[l];\n\n                if (!link.depthOfDumminess) {\n                  continue;\n                }\n\n                var points = []; // add points in reverse order\n\n                points.unshift({\n                  x: link.target.x,\n                  y: link.target.y\n                });\n                points.unshift({\n                  x: link.source.x,\n                  y: link.source.y\n                }); // _dedummify the link\n\n                var temp = link;\n                var depthOfDumminess = link.depthOfDumminess;\n\n                for (var d = 0; d < depthOfDumminess; d++) {\n                  var node = temp.source;\n                  var prevLink = node.incoming[0];\n                  points.unshift({\n                    x: prevLink.source.x,\n                    y: prevLink.source.y\n                  });\n                  temp = prevLink;\n                } // restore the original link origin\n\n\n                link.changeSource(temp.source); // reset dummification flag\n\n                link.depthOfDumminess = 0; // note that we only need the intermediate points, floating links have been dropped in the analysis\n\n                if (points.length > 2) {\n                  // first and last are the endpoints\n                  points.splice(0, 1);\n                  points.splice(points.length - 1);\n                  link.points = points;\n                } else {\n                  link.points = [];\n                } // we are not going to delete the dummy elements;\n                // they won't be needed anymore anyway.\n\n\n                dedum = true;\n                break;\n              }\n            }\n          },\n          /// <summary>\n          /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n          /// </summary>\n          _optimizeCrossings: function () {\n            var moves = -1,\n                i;\n            var maxIterations = 3;\n            var iter = 0;\n\n            while (moves !== 0) {\n              if (iter++ > maxIterations) {\n                break;\n              }\n\n              moves = 0;\n\n              for (i = this.layers.length - 1; i >= 1; i--) {\n                moves += this.optimizeLayerCrossings(false, i);\n              }\n\n              for (i = 0; i < this.layers.length - 1; i++) {\n                moves += this.optimizeLayerCrossings(true, i);\n              }\n            }\n          },\n          calcUpData: function (layer) {\n            if (layer === 0) {\n              return;\n            }\n\n            var considered = this.layers[layer],\n                i,\n                l,\n                link;\n            var upLayer = new Set();\n            var temp = this.layers[layer - 1];\n\n            for (i = 0; i < temp.length; i++) {\n              upLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n              var node = considered[i]; // calculate barycenter\n\n              var sum = 0;\n              var total = 0;\n\n              for (l = 0; l < node.incoming.length; l++) {\n                link = node.incoming[l];\n\n                if (upLayer.contains(link.source)) {\n                  total++;\n                  sum += link.source.gridPosition;\n                }\n              }\n\n              for (l = 0; l < node.outgoing.length; l++) {\n                link = node.outgoing[l];\n\n                if (upLayer.contains(link.target)) {\n                  total++;\n                  sum += link.target.gridPosition;\n                }\n              }\n\n              if (total > 0) {\n                node.uBaryCenter = sum / total;\n                node.upstreamLinkCount = total;\n              } else {\n                node.uBaryCenter = i;\n                node.upstreamLinkCount = 0;\n              }\n            }\n          },\n          calcDownData: function (layer) {\n            if (layer === this.layers.length - 1) {\n              return;\n            }\n\n            var considered = this.layers[layer],\n                i,\n                l,\n                link;\n            var downLayer = new Set();\n            var temp = this.layers[layer + 1];\n\n            for (i = 0; i < temp.length; i++) {\n              downLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n              var node = considered[i]; // calculate barycenter\n\n              var sum = 0;\n              var total = 0;\n\n              for (l = 0; l < node.incoming.length; l++) {\n                link = node.incoming[l];\n\n                if (downLayer.contains(link.source)) {\n                  total++;\n                  sum += link.source.gridPosition;\n                }\n              }\n\n              for (l = 0; l < node.outgoing.length; l++) {\n                link = node.outgoing[l];\n\n                if (downLayer.contains(link.target)) {\n                  total++;\n                  sum += link.target.gridPosition;\n                }\n              }\n\n              if (total > 0) {\n                node.dBaryCenter = sum / total;\n                node.downstreamLinkCount = total;\n              } else {\n                node.dBaryCenter = i;\n                node.downstreamLinkCount = 0;\n              }\n            }\n          },\n          /// <summary>\n          /// Optimizes the crossings.\n          /// </summary>\n          /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n          /// to an a problem of ordering numbers.</remarks>\n          /// <param name=\"layerIndex\">The layer index.</param>\n          /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n          /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n          optimizeLayerCrossings: function (down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n              considered = this.layers[iconsidered = layer + 1];\n            } else {\n              considered = this.layers[iconsidered = layer - 1];\n            } // remember what it was\n\n\n            var presorted = considered.slice(0); // calculate barycenters for all nodes in the considered layer\n\n            if (down) {\n              this.calcUpData(iconsidered);\n            } else {\n              this.calcDownData(iconsidered);\n            }\n\n            var that = this; // sort nodes within this layer according to the barycenters\n\n            considered.sort(function (n1, n2) {\n              var n1BaryCenter = that.calcBaryCenter(n1),\n                  n2BaryCenter = that.calcBaryCenter(n2);\n\n              if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                // in case of coinciding barycenters compare by the count of in/out links\n                if (n1.degree() === n2.degree()) {\n                  return that.compareByIndex(n1, n2);\n                } else if (n1.degree() < n2.degree()) {\n                  return 1;\n                }\n\n                return -1;\n              }\n\n              var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n\n              if (compareValue > 0) {\n                return -1;\n              } else if (compareValue < 0) {\n                return 1;\n              }\n\n              return that.compareByIndex(n1, n2);\n            }); // count relocations\n\n            var i,\n                moves = 0;\n\n            for (i = 0; i < considered.length; i++) {\n              if (considered[i] !== presorted[i]) {\n                moves++;\n              }\n            }\n\n            if (moves > 0) {\n              // now that the boxes have been arranged, update their grid positions\n              var inode = 0;\n\n              for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n                node.gridPosition = inode++;\n              }\n            }\n\n            return moves;\n          },\n          /// <summary>\n          /// Swaps a pair of nodes in a layer.\n          /// </summary>\n          /// <param name=\"layerIndex\">Index of the layer.</param>\n          /// <param name=\"n\">The Nth node in the layer.</param>\n          _swapPairs: function () {\n            var maxIterations = this.options.layeredIterations;\n            var iter = 0;\n\n            while (true) {\n              if (iter++ > maxIterations) {\n                break;\n              }\n\n              var downwards = iter % 4 <= 1;\n              var secondPass = iter % 4 === 1;\n\n              for (var l = downwards ? 0 : this.layers.length - 1; downwards ? l <= this.layers.length - 1 : l >= 0; l += downwards ? 1 : -1) {\n                var layer = this.layers[l];\n                var hasSwapped = false; // there is no need to recalculate crossings if they were calculated\n                // on the previous step and nothing has changed\n\n                var calcCrossings = true;\n                var memCrossings = 0;\n\n                for (var n = 0; n < layer.length - 1; n++) {\n                  // count crossings\n                  var up = 0;\n                  var down = 0;\n                  var crossBefore = 0;\n\n                  if (calcCrossings) {\n                    if (l !== 0) {\n                      up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                    }\n\n                    if (l !== this.layers.length - 1) {\n                      down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                    }\n\n                    if (downwards) {\n                      up *= 2;\n                    } else {\n                      down *= 2;\n                    }\n\n                    crossBefore = up + down;\n                  } else {\n                    crossBefore = memCrossings;\n                  }\n\n                  if (crossBefore === 0) {\n                    continue;\n                  } // Swap nodes\n\n\n                  var node1 = layer[n];\n                  var node2 = layer[n + 1];\n                  var node1GridPos = node1.gridPosition;\n                  var node2GridPos = node2.gridPosition;\n                  layer[n] = node2;\n                  layer[n + 1] = node1;\n                  node1.gridPosition = node2GridPos;\n                  node2.gridPosition = node1GridPos; // count crossings again and if worse than before, restore swapping\n\n                  up = 0;\n\n                  if (l !== 0) {\n                    up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                  }\n\n                  down = 0;\n\n                  if (l !== this.layers.length - 1) {\n                    down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                  }\n\n                  if (downwards) {\n                    up *= 2;\n                  } else {\n                    down *= 2;\n                  }\n\n                  var crossAfter = up + down;\n                  var revert = false;\n\n                  if (secondPass) {\n                    revert = crossAfter >= crossBefore;\n                  } else {\n                    revert = crossAfter > crossBefore;\n                  }\n\n                  if (revert) {\n                    node1 = layer[n];\n                    node2 = layer[n + 1];\n                    node1GridPos = node1.gridPosition;\n                    node2GridPos = node2.gridPosition;\n                    layer[n] = node2;\n                    layer[n + 1] = node1;\n                    node1.gridPosition = node2GridPos;\n                    node2.gridPosition = node1GridPos; // nothing has changed, remember the crossings so that\n                    // they are not calculated again on the next step\n\n                    memCrossings = crossBefore;\n                    calcCrossings = false;\n                  } else {\n                    hasSwapped = true;\n                    calcCrossings = true;\n                  }\n                }\n\n                if (hasSwapped) {\n                  if (l !== this.layers.length - 1) {\n                    this.calcUpData(l + 1);\n                  }\n\n                  if (l !== 0) {\n                    this.calcDownData(l - 1);\n                  }\n                }\n              }\n            }\n          },\n          /// <summary>\n          /// Counts the number of links crossing between two layers.\n          /// </summary>\n          /// <param name=\"layerIndex1\">The layer index.</param>\n          /// <param name=\"layerIndex2\">Another layer index.</param>\n          /// <returns></returns>\n          countLinksCrossingBetweenTwoLayers: function (ulayer, dlayer) {\n            var links = this.layers[ulayer].linksTo[dlayer];\n            var link1, link2, n11, n12, n21, n22, l1, l2;\n            var crossings = 0;\n            var length = links.length;\n\n            for (l1 = 0; l1 < length; l1++) {\n              link1 = links[l1];\n\n              for (l2 = l1 + 1; l2 < length; l2++) {\n                link2 = links[l2];\n\n                if (link1.target.layer === dlayer) {\n                  n11 = link1.source;\n                  n12 = link1.target;\n                } else {\n                  n11 = link1.target;\n                  n12 = link1.source;\n                }\n\n                if (link2.target.layer === dlayer) {\n                  n21 = link2.source;\n                  n22 = link2.target;\n                } else {\n                  n21 = link2.target;\n                  n22 = link2.source;\n                }\n\n                var n11gp = n11.gridPosition;\n                var n12gp = n12.gridPosition;\n                var n21gp = n21.gridPosition;\n                var n22gp = n22.gridPosition;\n\n                if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                  crossings++;\n                }\n              }\n            }\n\n            return crossings;\n          },\n          calcBaryCenter: function (node) {\n            var upstreamLinkCount = node.upstreamLinkCount;\n            var downstreamLinkCount = node.downstreamLinkCount;\n            var uBaryCenter = node.uBaryCenter;\n            var dBaryCenter = node.dBaryCenter;\n\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n              return (uBaryCenter + dBaryCenter) / 2;\n            }\n\n            if (upstreamLinkCount > 0) {\n              return uBaryCenter;\n            }\n\n            if (downstreamLinkCount > 0) {\n              return dBaryCenter;\n            }\n\n            return 0;\n          },\n          _gridPositionComparer: function (x, y) {\n            if (x.gridPosition < y.gridPosition) {\n              return -1;\n            }\n\n            if (x.gridPosition > y.gridPosition) {\n              return 1;\n            }\n\n            return 0;\n          },\n          _positionAscendingComparer: function (x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n          },\n          _positionDescendingComparer: function (x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n          },\n          _firstVirtualNode: function (layer) {\n            for (var c = 0; c < layer.length; c++) {\n              if (layer[c].isVirtual) {\n                return c;\n              }\n            }\n\n            return -1;\n          },\n          compareByIndex: function (o1, o2) {\n            var i1 = o1.index;\n            var i2 = o2.index;\n\n            if (i1 < i2) {\n              return 1;\n            }\n\n            if (i1 > i2) {\n              return -1;\n            }\n\n            return 0;\n          },\n          intDiv: function (numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n          },\n          nextVirtualNode: function (layer, node) {\n            var nodeIndex = node.layerIndex;\n\n            for (var i = nodeIndex + 1; i < layer.length; ++i) {\n              if (layer[i].isVirtual) {\n                return layer[i];\n              }\n            }\n\n            return null;\n          }\n        });\n        /**\n         * Captures the state of a diagram; node positions, link points and so on.\n         * @type {*}\n         */\n\n        var LayoutState = kendo.Class.extend({\n          init: function (diagram, graphOrNodes) {\n            if (Utils.isUndefined(diagram)) {\n              throw \"No diagram given\";\n            }\n\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n          },\n\n          /**\n           * Will capture either\n           * - the state of the shapes and the intermediate points of the connections in the diagram\n           * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n           * - the bounds of the nodes in the Array<Node>\n           * - the links points and node bounds in the literal object\n           * @param diagramOrGraphOrNodes\n           */\n          capture: function (diagramOrGraphOrNodes) {\n            var node, nodes, shape, i, conn, link, links;\n\n            if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n              for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                node = diagramOrGraphOrNodes.nodes[i];\n                shape = node.associatedShape; //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n\n                this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n              }\n\n              for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                link = diagramOrGraphOrNodes.links[i];\n                conn = link.associatedConnection;\n                this.linkMap.set(conn.visual.id, link.points());\n              }\n            } else if (diagramOrGraphOrNodes instanceof Array) {\n              nodes = diagramOrGraphOrNodes;\n\n              for (i = 0; i < nodes.length; i++) {\n                node = nodes[i];\n                shape = node.associatedShape;\n\n                if (shape) {\n                  this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n              }\n            } else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n              nodes = diagramOrGraphOrNodes.nodes;\n              links = diagramOrGraphOrNodes.links;\n\n              for (i = 0; i < nodes.length; i++) {\n                node = nodes[i];\n                shape = node.associatedShape;\n\n                if (shape) {\n                  this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n              }\n\n              for (i = 0; i < links.length; i++) {\n                link = links[i];\n                conn = link.associatedConnection;\n\n                if (conn) {\n                  this.linkMap.set(conn.visual.id, link.points);\n                }\n              }\n            } else {\n              // capture the diagram\n              var shapes = this.diagram.shapes;\n              var connections = this.diagram.connections;\n\n              for (i = 0; i < shapes.length; i++) {\n                shape = shapes[i];\n                this.nodeMap.set(shape.visual.id, shape.bounds());\n              }\n\n              for (i = 0; i < connections.length; i++) {\n                conn = connections[i];\n                this.linkMap.set(conn.visual.id, conn.points());\n              }\n            }\n          }\n        });\n        deepExtend(diagram, {\n          init: function (element) {\n            kendo.init(element, diagram.ui);\n          },\n          SpringLayout: SpringLayout,\n          TreeLayout: TreeLayout,\n          GraphAdapter: DiagramToHyperTreeAdapter,\n          LayeredLayout: LayeredLayout,\n          LayoutBase: LayoutBase,\n          LayoutState: LayoutState\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  911:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./math\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}