{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(901);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  890:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.data\");\n    /***/\n  },\n\n  /***/\n  891:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  892:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.themes\");\n    /***/\n  },\n\n  /***/\n  901:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(890), __webpack_require__(902), __webpack_require__(903), __webpack_require__(904), __webpack_require__(905), __webpack_require__(906), __webpack_require__(891), __webpack_require__(892), __webpack_require__(907), __webpack_require__(908), __webpack_require__(909)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var dataviz = kendo.dataviz,\n            draw = kendo.drawing,\n            geom = kendo.geometry,\n            diagram = dataviz.diagram,\n            Widget = kendo.ui.Widget,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n            Canvas = diagram.Canvas,\n            Group = diagram.Group,\n            Rectangle = diagram.Rectangle,\n            Circle = diagram.Circle,\n            CompositeTransform = diagram.CompositeTransform,\n            Rect = diagram.Rect,\n            Path = diagram.Path,\n            DeleteShapeUnit = diagram.DeleteShapeUnit,\n            DeleteConnectionUnit = diagram.DeleteConnectionUnit,\n            TextBlock = diagram.TextBlock,\n            Image = diagram.Image,\n            Point = diagram.Point,\n            Intersect = diagram.Intersect,\n            ConnectionEditAdorner = diagram.ConnectionEditAdorner,\n            UndoRedoService = diagram.UndoRedoService,\n            ToolService = diagram.ToolService,\n            Selector = diagram.Selector,\n            ResizingAdorner = diagram.ResizingAdorner,\n            ConnectorsAdorner = diagram.ConnectorsAdorner,\n            Cursors = diagram.Cursors,\n            Utils = diagram.Utils,\n            Observable = kendo.Observable,\n            ToBackUnit = diagram.ToBackUnit,\n            ToFrontUnit = diagram.ToFrontUnit,\n            PolylineRouter = diagram.PolylineRouter,\n            CascadingRouter = diagram.CascadingRouter,\n            isUndefined = Utils.isUndefined,\n            isDefined = Utils.isDefined,\n            defined = draw.util.defined,\n            isArray = Array.isArray,\n            isFunction = kendo.isFunction,\n            isString = Utils.isString,\n            isPlainObject = $.isPlainObject,\n            math = Math; // Constants ==============================================================\n\n        var NS = \".kendoDiagram\",\n            CASCADING = \"cascading\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            CHANGE = \"change\",\n            CLICK = \"click\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            DRAG_START = \"dragStart\",\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ERROR = \"error\",\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            MAXINT = 9007199254740992,\n            SELECT = \"select\",\n            ITEMROTATE = \"itemRotate\",\n            PAN = \"pan\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            NONE = \"none\",\n            DEFAULT_CANVAS_WIDTH = 600,\n            DEFAULT_CANVAS_HEIGHT = 600,\n            DEFAULT_SHAPE_TYPE = \"rectangle\",\n            DEFAULT_SHAPE_WIDTH = 100,\n            DEFAULT_SHAPE_HEIGHT = 100,\n            DEFAULT_SHAPE_MINWIDTH = 20,\n            DEFAULT_SHAPE_MINHEIGHT = 20,\n            DEFAULT_SHAPE_POSITION = 0,\n            DEFAULT_CONNECTION_BACKGROUND = \"Yellow\",\n            MAX_VALUE = Number.MAX_VALUE,\n            MIN_VALUE = -Number.MAX_VALUE,\n            ABSOLUTE = \"absolute\",\n            TRANSFORMED = \"transformed\",\n            ROTATED = \"rotated\",\n            TRANSPARENT = \"transparent\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            X = \"x\",\n            Y = \"y\",\n            MOUSEWHEEL_NS = \"DOMMouseScroll\" + NS + \" mousewheel\" + NS,\n            MOBILE_ZOOM_RATE = 0.05,\n            MOBILE_PAN_DISTANCE = 5,\n            BUTTON_TEMPLATE = '<a class=\"k-button k-button-md k-rounded-md k-button-solid k-button-solid-base #=className#\" href=\"\\\\#\">' + '<span class=\"k-button-icon #=iconClass# #=imageClass#\"></span>' + '<span class=\"k-button-text\">#=text#</span>' + '</a>',\n            CONNECTION_CONTENT_OFFSET = 5;\n        diagram.DefaultConnectors = [{\n          name: TOP\n        }, {\n          name: BOTTOM\n        }, {\n          name: LEFT\n        }, {\n          name: RIGHT\n        }, {\n          name: AUTO,\n          position: function (shape) {\n            return shape.getPosition(\"center\");\n          }\n        }];\n        var defaultButtons = {\n          cancel: {\n            text: \"Cancel\",\n            imageClass: \"k-i-cancel\",\n            className: \"k-diagram-cancel\",\n            iconClass: \"k-icon\"\n          },\n          update: {\n            text: \"Update\",\n            imageClass: \"k-i-checkmark\",\n            className: \"k-diagram-update\",\n            iconClass: \"k-icon\"\n          }\n        };\n\n        diagram.shapeDefaults = function (extra) {\n          var defaults = {\n            type: DEFAULT_SHAPE_TYPE,\n            path: \"\",\n            autoSize: true,\n            visual: null,\n            x: DEFAULT_SHAPE_POSITION,\n            y: DEFAULT_SHAPE_POSITION,\n            minWidth: DEFAULT_SHAPE_MINWIDTH,\n            minHeight: DEFAULT_SHAPE_MINHEIGHT,\n            width: DEFAULT_SHAPE_WIDTH,\n            height: DEFAULT_SHAPE_HEIGHT,\n            hover: {},\n            editable: {\n              connect: true,\n              tools: []\n            },\n            connectors: diagram.DefaultConnectors,\n            rotation: {\n              angle: 0\n            }\n          };\n          Utils.simpleExtend(defaults, extra);\n          return defaults;\n        };\n\n        function mwDelta(e) {\n          var origEvent = e.originalEvent,\n              delta = 0;\n\n          if (origEvent.wheelDelta) {\n            delta = -origEvent.wheelDelta / 40;\n            delta = delta > 0 ? math.ceil(delta) : math.floor(delta);\n          } else if (origEvent.detail) {\n            delta = origEvent.detail;\n          }\n\n          return delta;\n        }\n\n        function isAutoConnector(connector) {\n          return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n        }\n\n        function closestConnector(point, connectors) {\n          var minimumDistance = MAXINT,\n              resCtr,\n              connector;\n\n          for (var i = 0; i < connectors.length; i++) {\n            connector = connectors[i];\n\n            if (!isAutoConnector(connector)) {\n              var dist = point.distanceTo(connector.position());\n\n              if (dist < minimumDistance) {\n                minimumDistance = dist;\n                resCtr = connector;\n              }\n            }\n          }\n\n          return resCtr;\n        }\n\n        function indicesOfItems(group, visuals) {\n          var i,\n              indices = [],\n              visual;\n          var children = group.drawingContainer().children;\n          var length = children.length;\n\n          for (i = 0; i < visuals.length; i++) {\n            visual = visuals[i];\n\n            for (var j = 0; j < length; j++) {\n              if (children[j] == visual.drawingContainer()) {\n                indices.push(j);\n                break;\n              }\n            }\n          }\n\n          return indices;\n        }\n\n        var DiagramElement = Observable.extend({\n          init: function (options) {\n            var that = this;\n            that.dataItem = (options || {}).dataItem;\n            Observable.fn.init.call(that);\n            that.options = deepExtend({\n              id: diagram.randomId()\n            }, that.options, options);\n            that.isSelected = false;\n            that.visual = new Group({\n              id: that.options.id,\n              autoSize: that.options.autoSize\n            });\n            that.id = that.options.id;\n\n            that._template();\n          },\n          options: {\n            hover: {},\n            cursor: Cursors.grip,\n            content: {\n              align: \"center middle\"\n            },\n            selectable: true,\n            serializable: true,\n            enable: true\n          },\n          _getCursor: function (point) {\n            if (this.adorner) {\n              return this.adorner._getCursor(point);\n            }\n\n            return this.options.cursor;\n          },\n          visible: function (value) {\n            if (isUndefined(value)) {\n              return this.visual.visible();\n            } else {\n              this.visual.visible(value);\n            }\n          },\n          bounds: function () {},\n          refresh: function () {\n            this.visual.redraw();\n          },\n          position: function (point) {\n            this.options.x = point.x;\n            this.options.y = point.y;\n            this.visual.position(point);\n          },\n          toString: function () {\n            return this.options.id;\n          },\n          serialize: function () {\n            // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n            var json = deepExtend({}, {\n              options: this.options\n            });\n\n            if (this.dataItem) {\n              json.dataItem = this.dataItem.toString();\n            }\n\n            return json;\n          },\n          _content: function (content) {\n            if (content !== undefined) {\n              var options = this.options;\n\n              if (diagram.Utils.isString(content)) {\n                options.content.text = content;\n              } else {\n                deepExtend(options.content, content);\n              }\n\n              var contentOptions = options.content;\n              var contentVisual = this._contentVisual;\n\n              if (!contentVisual) {\n                this._createContentVisual(contentOptions);\n              } else {\n                this._updateContentVisual(contentOptions);\n              }\n            }\n\n            return this.options.content.text;\n          },\n          _createContentVisual: function (options) {\n            if (options.text) {\n              this._contentVisual = new TextBlock(options);\n              this._contentVisual._includeInBBox = false;\n              this.visual.append(this._contentVisual);\n            }\n          },\n          _updateContentVisual: function (options) {\n            this._contentVisual.redraw(options);\n          },\n          _hitTest: function (point) {\n            var bounds = this.bounds();\n            return this.visible() && bounds.contains(point) && this.options.enable;\n          },\n          _template: function () {\n            var that = this;\n\n            if (that.options.content.template) {\n              var data = that.dataItem || {},\n                  elementTemplate = kendo.template(that.options.content.template, {\n                paramName: \"dataItem\"\n              });\n              that.options.content.text = elementTemplate(data);\n            }\n          },\n          _canSelect: function () {\n            return this.options.selectable !== false;\n          },\n          toJSON: function () {\n            return {\n              id: this.options.id\n            };\n          }\n        });\n        var Connector = Class.extend({\n          init: function (shape, options) {\n            this.options = deepExtend({}, this.options, options);\n            this.connections = [];\n            this.shape = shape;\n          },\n          options: {\n            width: 7,\n            height: 7,\n            fill: {\n              color: DEFAULT_CONNECTION_BACKGROUND\n            },\n            hover: {}\n          },\n          position: function () {\n            if (this.options.position) {\n              return this.options.position(this.shape);\n            } else {\n              return this.shape.getPosition(this.options.name);\n            }\n          },\n          toJSON: function () {\n            return {\n              shapeId: this.shape.toString(),\n              connector: this.options.name\n            };\n          }\n        });\n\n        Connector.parse = function (diagram, str) {\n          var tempStr = str.split(\":\"),\n              id = tempStr[0],\n              name = tempStr[1] || AUTO;\n\n          for (var i = 0; i < diagram.shapes.length; i++) {\n            var shape = diagram.shapes[i];\n\n            if (shape.options.id == id) {\n              return shape.getConnector(name.trim());\n            }\n          }\n        };\n\n        var Shape = DiagramElement.extend({\n          init: function (options, diagram) {\n            var that = this;\n            DiagramElement.fn.init.call(that, options);\n            this.diagram = diagram;\n            this.updateOptionsFromModel();\n            options = that.options;\n            that.connectors = [];\n            that.type = options.type;\n            that.createShapeVisual();\n            that.updateBounds();\n            that.content(that.content());\n\n            that._createConnectors();\n          },\n          options: diagram.shapeDefaults(),\n          _setOptionsFromModel: function (model) {\n            var modelOptions = filterShapeDataItem(model || this.dataItem);\n            this.options = deepExtend({}, this.options, modelOptions);\n            this.redrawVisual();\n          },\n          updateOptionsFromModel: function (model, field) {\n            if (this.diagram && this.diagram._isEditable) {\n              var modelOptions = filterShapeDataItem(model || this.dataItem);\n\n              if (model && field) {\n                if (!dataviz.inArray(field, [\"x\", \"y\", \"width\", \"height\"])) {\n                  if (this.options.visual) {\n                    this._redrawVisual();\n                  } else if (modelOptions.type) {\n                    this.options = deepExtend({}, this.options, modelOptions);\n\n                    this._redrawVisual();\n                  }\n\n                  if (this.options.content) {\n                    this._template();\n\n                    this.content(this.options.content);\n                  }\n                } else {\n                  var bounds = this.bounds();\n                  bounds[field] = model[field];\n                  this.bounds(bounds);\n                }\n              } else {\n                this.options = deepExtend({}, this.options, modelOptions);\n              }\n            }\n          },\n          _redrawVisual: function () {\n            this.visual.clear();\n            this._contentVisual = null;\n            this.options.dataItem = this.dataItem;\n            this.createShapeVisual();\n            this.updateBounds();\n          },\n          redrawVisual: function () {\n            this._redrawVisual();\n\n            if (this.options.content) {\n              this._template();\n\n              this.content(this.options.content);\n            }\n          },\n          updateModel: function (syncChanges) {\n            var diagram = this.diagram;\n\n            if (diagram && diagram._isEditable) {\n              var bounds = this._bounds;\n              var model = this.dataItem;\n\n              if (model) {\n                diagram._suspendModelRefresh();\n\n                if (defined(model.x) && bounds.x !== model.x) {\n                  model.set(\"x\", bounds.x);\n                }\n\n                if (defined(model.y) && bounds.y !== model.y) {\n                  model.set(\"y\", bounds.y);\n                }\n\n                if (defined(model.width) && bounds.width !== model.width) {\n                  model.set(\"width\", bounds.width);\n                }\n\n                if (defined(model.height) && bounds.height !== model.height) {\n                  model.set(\"height\", bounds.height);\n                }\n\n                this.dataItem = model;\n\n                diagram._resumeModelRefresh();\n\n                if (syncChanges) {\n                  diagram._syncShapeChanges();\n                }\n              }\n            }\n          },\n          updateBounds: function () {\n            var bounds = this.visual._measure(true);\n\n            var options = this.options;\n            this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n\n            this._rotate();\n\n            this._alignContent();\n          },\n          content: function (content) {\n            var result = this._content(content);\n\n            this._alignContent();\n\n            return result;\n          },\n          _alignContent: function () {\n            var contentOptions = this.options.content || {};\n            var contentVisual = this._contentVisual;\n\n            if (contentVisual && contentOptions.align) {\n              var containerRect = this.visual._measure();\n\n              var aligner = new diagram.RectAlign(containerRect);\n              var contentBounds = contentVisual.drawingElement.bbox(null);\n              var contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n              var alignedBounds = aligner.align(contentRect, contentOptions.align);\n              contentVisual.position(alignedBounds.topLeft());\n            }\n          },\n          _createConnectors: function () {\n            var options = this.options,\n                length = options.connectors.length,\n                connectorDefaults = options.connectorDefaults,\n                connector,\n                i;\n\n            for (i = 0; i < length; i++) {\n              connector = new Connector(this, deepExtend({}, connectorDefaults, options.connectors[i]));\n              this.connectors.push(connector);\n            }\n          },\n          bounds: function (value) {\n            var bounds;\n\n            if (value) {\n              if (isString(value)) {\n                switch (value) {\n                  case TRANSFORMED:\n                    bounds = this._transformedBounds();\n                    break;\n\n                  case ABSOLUTE:\n                    bounds = this._transformedBounds();\n                    var pan = this.diagram._pan;\n                    bounds.x += pan.x;\n                    bounds.y += pan.y;\n                    break;\n\n                  case ROTATED:\n                    bounds = this._rotatedBounds();\n                    break;\n\n                  default:\n                    bounds = this._bounds;\n                }\n              } else {\n                this._setBounds(value);\n\n                this._triggerBoundsChange();\n\n                if (!(this.diagram && this.diagram._layouting)) {\n                  this.refreshConnections();\n                }\n              }\n            } else {\n              bounds = this._bounds;\n            }\n\n            return bounds;\n          },\n          _setBounds: function (rect) {\n            var options = this.options;\n            var topLeft = rect.topLeft();\n            var x = options.x = topLeft.x;\n            var y = options.y = topLeft.y;\n            var width = options.width = math.max(rect.width, options.minWidth);\n            var height = options.height = math.max(rect.height, options.minHeight);\n            this._bounds = new Rect(x, y, width, height);\n            this.visual.redraw({\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n          },\n          position: function (point) {\n            if (point) {\n              this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n            } else {\n              return this._bounds.topLeft();\n            }\n          },\n\n          /**\n           * Returns a clone of this shape.\n           * @returns {Shape}\n           */\n          clone: function () {\n            var json = this.serialize();\n            json.options.id = diagram.randomId();\n\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n              json.options.dataItem = cloneDataItem(this.dataItem);\n            }\n\n            return new Shape(json.options);\n          },\n          select: function (value) {\n            var diagram = this.diagram,\n                selected,\n                deselected;\n\n            if (isUndefined(value)) {\n              value = true;\n            }\n\n            if (this._canSelect()) {\n              if (this.isSelected != value) {\n                selected = [];\n                deselected = [];\n                this.isSelected = value;\n\n                if (this.isSelected) {\n                  diagram._selectedItems.push(this);\n\n                  selected.push(this);\n                } else {\n                  Utils.remove(diagram._selectedItems, this);\n                  deselected.push(this);\n                }\n\n                if (!diagram._internalSelection) {\n                  diagram._selectionChanged(selected, deselected);\n                }\n\n                return true;\n              }\n            }\n          },\n          rotate: function (angle, center, undoable) {\n            // we assume the center is always the center of the shape.\n            var rotate = this.visual.rotate();\n\n            if (angle !== undefined) {\n              if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                this.diagram.undoRedoService.add(new diagram.RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n              }\n\n              var b = this.bounds(),\n                  sc = new Point(b.width / 2, b.height / 2),\n                  deltaAngle,\n                  newPosition;\n\n              if (center) {\n                deltaAngle = angle - rotate.angle;\n                newPosition = b.center().rotate(center, 360 - deltaAngle).minus(sc);\n                this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                this.position(newPosition);\n              }\n\n              this.visual.rotate(angle, sc);\n              this.options.rotation.angle = angle;\n\n              if (this.diagram && this.diagram._connectorsAdorner) {\n                this.diagram._connectorsAdorner.refresh();\n              }\n\n              this.refreshConnections();\n\n              if (this.diagram) {\n                this.diagram.trigger(ITEMROTATE, {\n                  item: this\n                });\n              }\n            }\n\n            return rotate;\n          },\n          connections: function (type) {\n            // in, out, undefined = both\n            var result = [],\n                i,\n                j,\n                con,\n                cons,\n                ctr;\n\n            for (i = 0; i < this.connectors.length; i++) {\n              ctr = this.connectors[i];\n              cons = ctr.connections;\n\n              for (j = 0, cons; j < cons.length; j++) {\n                con = cons[j];\n\n                if (type == \"out\") {\n                  var source = con.source();\n\n                  if (source.shape && source.shape == this) {\n                    result.push(con);\n                  }\n                } else if (type == \"in\") {\n                  var target = con.target();\n\n                  if (target.shape && target.shape == this) {\n                    result.push(con);\n                  }\n                } else {\n                  result.push(con);\n                }\n              }\n            }\n\n            return result;\n          },\n          refreshConnections: function () {\n            $.each(this.connections(), function () {\n              this.refresh();\n            });\n          },\n\n          /**\n           * Gets a connector of this shape either by the connector's supposed name or\n           * via a Point in which case the closest connector will be returned.\n           * @param nameOrPoint The name of a Connector or a Point.\n           * @returns {Connector}\n           */\n          getConnector: function (nameOrPoint) {\n            var i, ctr;\n\n            if (isString(nameOrPoint)) {\n              nameOrPoint = nameOrPoint.toLocaleLowerCase();\n\n              for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n\n                if (ctr.options.name.toLocaleLowerCase() == nameOrPoint) {\n                  return ctr;\n                }\n              }\n            } else if (nameOrPoint instanceof Point) {\n              return closestConnector(nameOrPoint, this.connectors);\n            } else {\n              return this.connectors.length ? this.connectors[0] : null;\n            }\n          },\n          getPosition: function (side) {\n            var b = this.bounds(),\n                fnName = side.charAt(0).toLowerCase() + side.slice(1);\n\n            if (isFunction(b[fnName])) {\n              return this._transformPoint(b[fnName]());\n            }\n\n            return b.center();\n          },\n          redraw: function (options) {\n            if (options) {\n              var shapeOptions = this.options;\n              var boundsChange;\n              this.shapeVisual.redraw(this._visualOptions(options));\n\n              if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                boundsChange = true;\n              }\n\n              if (options.connectors) {\n                shapeOptions.connectors = options.connectors;\n\n                this._updateConnectors();\n              }\n\n              shapeOptions = deepExtend(shapeOptions, options);\n\n              if (options.rotation || boundsChange) {\n                this._rotate();\n              }\n\n              if (shapeOptions.content) {\n                this.content(shapeOptions.content);\n              }\n            }\n          },\n          _updateConnectors: function () {\n            var connections = this.connections();\n            this.connectors = [];\n\n            this._createConnectors();\n\n            var connection;\n            var source;\n            var target;\n\n            for (var idx = 0; idx < connections.length; idx++) {\n              connection = connections[idx];\n              source = connection.source();\n              target = connection.target();\n\n              if (source.shape && source.shape === this) {\n                connection.source(this.getConnector(source.options.name) || null);\n              } else if (target.shape && target.shape === this) {\n                connection.target(this.getConnector(target.options.name) || null);\n              }\n\n              connection.updateModel();\n            }\n          },\n          _diffNumericOptions: diagram.diffNumericOptions,\n          _visualOptions: function (options) {\n            return {\n              data: options.path,\n              source: options.source,\n              hover: options.hover,\n              fill: options.fill,\n              stroke: options.stroke\n            };\n          },\n          _triggerBoundsChange: function () {\n            if (this.diagram) {\n              this.diagram.trigger(ITEMBOUNDSCHANGE, {\n                item: this,\n                bounds: this._bounds.clone()\n              }); // the trigger modifies the arguments internally.\n            }\n          },\n          _transformPoint: function (point) {\n            var rotate = this.rotate(),\n                bounds = this.bounds(),\n                tl = bounds.topLeft();\n\n            if (rotate.angle) {\n              point.rotate(rotate.center().plus(tl), 360 - rotate.angle);\n            }\n\n            return point;\n          },\n          _transformedBounds: function () {\n            var bounds = this.bounds(),\n                tl = bounds.topLeft(),\n                br = bounds.bottomRight();\n            return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n          },\n          _rotatedBounds: function () {\n            var bounds = this.bounds().rotatedBounds(this.rotate().angle),\n                tl = bounds.topLeft(),\n                br = bounds.bottomRight();\n            return Rect.fromPoints(tl, br);\n          },\n          _rotate: function () {\n            var rotation = this.options.rotation;\n\n            if (rotation && rotation.angle) {\n              this.rotate(rotation.angle);\n            }\n\n            this._rotationOffset = new Point();\n          },\n          _hover: function (value) {\n            var options = this.options,\n                hover = options.hover,\n                stroke = options.stroke,\n                fill = options.fill;\n\n            if (value && isDefined(hover.stroke)) {\n              stroke = deepExtend({}, stroke, hover.stroke);\n            }\n\n            if (value && isDefined(hover.fill)) {\n              fill = hover.fill;\n            }\n\n            this.shapeVisual.redraw({\n              stroke: stroke,\n              fill: fill\n            });\n\n            if (options.editable && options.editable.connect) {\n              this.diagram._showConnectors(this, value);\n            }\n          },\n          _hitTest: function (value) {\n            if (this.visible()) {\n              var bounds = this.bounds(),\n                  rotatedPoint,\n                  angle = this.rotate().angle;\n\n              if (value.isEmpty && !value.isEmpty()) {\n                // rect selection\n                return Intersect.rects(value, bounds, angle ? angle : 0);\n              } else {\n                // point\n                rotatedPoint = value.clone().rotate(bounds.center(), angle); // cloning is important because rotate modifies the point inline.\n\n                if (bounds.contains(rotatedPoint)) {\n                  return this;\n                }\n              }\n            }\n          },\n          toJSON: function () {\n            return {\n              shapeId: this.options.id\n            };\n          },\n          createShapeVisual: function () {\n            var options = this.options;\n\n            var visualOptions = this._visualOptions(options);\n\n            var visualTemplate = options.visual;\n            var type = (options.type + \"\").toLocaleLowerCase();\n            var shapeVisual;\n            visualOptions.width = options.width;\n            visualOptions.height = options.height;\n\n            if (isFunction(visualTemplate)) {\n              // custom template\n              shapeVisual = visualTemplate.call(this, options);\n            } else if (visualOptions.data) {\n              shapeVisual = new Path(visualOptions);\n              translateToOrigin(shapeVisual);\n            } else if (type == \"rectangle\") {\n              shapeVisual = new Rectangle(visualOptions);\n            } else if (type == \"circle\") {\n              shapeVisual = new Circle(visualOptions);\n            } else if (type == \"text\") {\n              shapeVisual = new TextBlock(visualOptions);\n            } else if (type == \"image\") {\n              shapeVisual = new Image(visualOptions);\n            } else {\n              shapeVisual = new Path(visualOptions);\n            }\n\n            this.shapeVisual = shapeVisual;\n            this.visual.append(this.shapeVisual);\n          }\n        });\n        /**\n         * The visual link between two Shapes through the intermediate of Connectors.\n         */\n\n        var Connection = DiagramElement.extend({\n          init: function (from, to, options) {\n            var that = this;\n            DiagramElement.fn.init.call(that, options);\n            this.updateOptionsFromModel();\n\n            this._initRouter();\n\n            that.path = new diagram.Polyline(that.options);\n            that.path.fill(TRANSPARENT);\n            that.visual.append(that.path);\n            that._sourcePoint = that._targetPoint = new Point();\n\n            that._setSource(from);\n\n            that._setTarget(to);\n\n            that.content(that.options.content);\n            that.definers = [];\n\n            if (defined(options) && options.points) {\n              that.points(options.points);\n            }\n          },\n          options: {\n            hover: {\n              stroke: {}\n            },\n            startCap: NONE,\n            endCap: NONE,\n            points: [],\n            selectable: true,\n            fromConnector: AUTO,\n            toConnector: AUTO\n          },\n          _setOptionsFromModel: function (model) {\n            this.updateOptionsFromModel(model || this.dataItem);\n          },\n          updateOptionsFromModel: function (model) {\n            if (this.diagram && this.diagram._isEditable) {\n              var dataMap = this.diagram._dataMap;\n              var options = filterConnectionDataItem(model || this.dataItem);\n\n              if (model) {\n                if (defined(options.from)) {\n                  var from = dataMap[options.from];\n\n                  if (from && defined(options.fromConnector)) {\n                    from = from.getConnector(options.fromConnector);\n                  }\n\n                  this.source(from);\n                } else if (defined(options.fromX) && defined(options.fromY)) {\n                  this.source(new Point(options.fromX, options.fromY));\n                }\n\n                if (defined(options.to)) {\n                  var to = dataMap[options.to];\n\n                  if (to && defined(options.toConnector)) {\n                    to = to.getConnector(options.toConnector);\n                  }\n\n                  this.target(to);\n                } else if (defined(options.toX) && defined(options.toY)) {\n                  this.target(new Point(options.toX, options.toY));\n                }\n\n                if (defined(options.type) && this.type() !== options.type) {\n                  this.points([]);\n                  this.type(options.type);\n                }\n\n                this.dataItem = model;\n\n                this._template();\n\n                this.redraw(this.options);\n              } else {\n                this.options = deepExtend({}, options, this.options);\n              }\n            }\n          },\n          updateModel: function (syncChanges) {\n            if (this.diagram && this.diagram._isEditable) {\n              if (this.diagram.connectionsDataSource) {\n                var model = this.diagram.connectionsDataSource.getByUid(this.dataItem.uid);\n\n                if (model) {\n                  this.diagram._suspendModelRefresh();\n\n                  if (defined(this.options.fromX) && this.options.fromX !== null) {\n                    clearField(\"from\", model);\n                    clearField(\"fromConnector\", model);\n                    model.set(\"fromX\", this.options.fromX);\n                    model.set(\"fromY\", this.options.fromY);\n                  } else {\n                    model.set(\"from\", this.options.from);\n\n                    if (defined(model.fromConnector)) {\n                      model.set(\"fromConnector\", this.sourceConnector ? this.sourceConnector.options.name : null);\n                    }\n\n                    clearField(\"fromX\", model);\n                    clearField(\"fromY\", model);\n                  }\n\n                  if (defined(this.options.toX) && this.options.toX !== null) {\n                    clearField(\"to\", model);\n                    clearField(\"toConnector\", model);\n                    model.set(\"toX\", this.options.toX);\n                    model.set(\"toY\", this.options.toY);\n                  } else {\n                    model.set(\"to\", this.options.to);\n\n                    if (defined(model.toConnector)) {\n                      model.set(\"toConnector\", this.targetConnector ? this.targetConnector.options.name : null);\n                    }\n\n                    clearField(\"toX\", model);\n                    clearField(\"toY\", model);\n                  }\n\n                  if (defined(this.options.type) && defined(model.type)) {\n                    model.set(\"type\", this.options.type);\n                  }\n\n                  this.dataItem = model;\n\n                  this.diagram._resumeModelRefresh();\n\n                  if (syncChanges) {\n                    this.diagram._syncConnectionChanges();\n                  }\n                }\n              }\n            }\n          },\n\n          /**\n           * Gets the Point where the source of the connection resides.\n           * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n           * If the endpoint is floating the location of the endpoint is returned.\n           */\n          sourcePoint: function () {\n            return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n          },\n          _setSource: function (source) {\n            var shapeSource = source instanceof Shape;\n            var defaultConnector = this.options.fromConnector || AUTO;\n            var dataItem;\n\n            if (shapeSource && !source.getConnector(defaultConnector)) {\n              return;\n            }\n\n            if (source !== undefined) {\n              this.from = source;\n            }\n\n            this._removeFromSourceConnector();\n\n            if (source === null) {\n              // detach\n              if (this.sourceConnector) {\n                this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n\n                this._clearSourceConnector();\n\n                this._setFromOptions(null, this._sourcePoint);\n              }\n            } else if (source instanceof Connector) {\n              dataItem = source.shape.dataItem;\n\n              if (dataItem) {\n                this._setFromOptions(dataItem.id);\n              }\n\n              this.sourceConnector = source;\n              this.sourceConnector.connections.push(this);\n            } else if (source instanceof Point) {\n              this._setFromOptions(null, source);\n\n              this._sourcePoint = source;\n\n              if (this.sourceConnector) {\n                this._clearSourceConnector();\n              }\n            } else if (shapeSource) {\n              dataItem = source.dataItem;\n\n              if (dataItem) {\n                this._setFromOptions(dataItem.id);\n              }\n\n              this.sourceConnector = source.getConnector(defaultConnector);\n              this.sourceConnector.connections.push(this);\n            }\n          },\n          source: function (source, undoable) {\n            if (isDefined(source)) {\n              if (undoable && this.diagram) {\n                this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, source));\n              }\n\n              this._setSource(source);\n\n              this.refresh();\n            }\n\n            return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n          },\n          _setFromOptions: function (from, fromPoint) {\n            this.options.from = from;\n\n            if (fromPoint) {\n              this.options.fromX = fromPoint.x;\n              this.options.fromY = fromPoint.y;\n            } else {\n              this.options.fromX = null;\n              this.options.fromY = null;\n            }\n          },\n\n          /**\n           * Gets or sets the PathDefiner of the sourcePoint.\n           * The left part of this definer is always null since it defines the source tangent.\n           * @param value\n           * @returns {*}\n           */\n          sourceDefiner: function (value) {\n            if (value) {\n              if (value instanceof diagram.PathDefiner) {\n                value.left = null;\n                this._sourceDefiner = value;\n                this.source(value.point); // refresh implicit here\n              } else {\n                throw \"The sourceDefiner needs to be a PathDefiner.\";\n              }\n            } else {\n              if (!this._sourceDefiner) {\n                this._sourceDefiner = new diagram.PathDefiner(this.sourcePoint(), null, null);\n              }\n\n              return this._sourceDefiner;\n            }\n          },\n\n          /**\n           * Gets  the Point where the target of the connection resides.\n           */\n          targetPoint: function () {\n            return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n          },\n          _setTarget: function (target) {\n            var shapeTarget = target instanceof Shape;\n            var defaultConnector = this.options.toConnector || AUTO;\n            var dataItem;\n\n            if (shapeTarget && !target.getConnector(defaultConnector)) {\n              return;\n            }\n\n            if (target !== undefined) {\n              this.to = target;\n            }\n\n            this._removeFromTargetConnector();\n\n            if (target === null) {\n              // detach\n              if (this.targetConnector) {\n                this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n\n                this._clearTargetConnector();\n\n                this._setToOptions(null, this._targetPoint);\n              }\n            } else if (target instanceof Connector) {\n              dataItem = target.shape.dataItem;\n\n              if (dataItem) {\n                this._setToOptions(dataItem.id);\n              }\n\n              this.targetConnector = target;\n              this.targetConnector.connections.push(this);\n            } else if (target instanceof Point) {\n              this._setToOptions(null, target);\n\n              this._targetPoint = target;\n\n              if (this.targetConnector) {\n                this._clearTargetConnector();\n              }\n            } else if (shapeTarget) {\n              dataItem = target.dataItem;\n\n              if (dataItem) {\n                this._setToOptions(dataItem.id);\n              }\n\n              this.targetConnector = target.getConnector(defaultConnector);\n              this.targetConnector.connections.push(this);\n            }\n          },\n          target: function (target, undoable) {\n            if (isDefined(target)) {\n              if (undoable && this.diagram) {\n                this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, undefined, target));\n              }\n\n              this._setTarget(target);\n\n              this.refresh();\n            }\n\n            return this.targetConnector ? this.targetConnector : this._targetPoint;\n          },\n          _setToOptions: function (to, toPoint) {\n            this.options.to = to;\n\n            if (toPoint) {\n              this.options.toX = toPoint.x;\n              this.options.toY = toPoint.y;\n            } else {\n              this.options.toX = null;\n              this.options.toY = null;\n            }\n          },\n\n          /**\n           * Gets or sets the PathDefiner of the targetPoint.\n           * The right part of this definer is always null since it defines the target tangent.\n           * @param value\n           * @returns {*}\n           */\n          targetDefiner: function (value) {\n            if (value) {\n              if (value instanceof diagram.PathDefiner) {\n                value.right = null;\n                this._targetDefiner = value;\n                this.target(value.point); // refresh implicit here\n              } else {\n                throw \"The sourceDefiner needs to be a PathDefiner.\";\n              }\n            } else {\n              if (!this._targetDefiner) {\n                this._targetDefiner = new diagram.PathDefiner(this.targetPoint(), null, null);\n              }\n\n              return this._targetDefiner;\n            }\n          },\n          _updateConnectors: function () {\n            this._updateConnector(this.source(), \"source\");\n\n            this._updateConnector(this.target(), \"target\");\n          },\n          _updateConnector: function (instance, name) {\n            var that = this;\n            var diagram = that.diagram;\n\n            if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n              var dataItem = instance.shape.dataItem;\n              var connectorName = instance.options.name;\n\n              var setNewTarget = function () {\n                var shape = diagram._dataMap[dataItem.id];\n                instance = shape.getConnector(connectorName);\n                that[name](instance, false);\n                that.updateModel();\n              };\n\n              if (diagram._dataMap[dataItem.id]) {\n                setNewTarget();\n              } else {\n                var inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n\n                if (inactiveItem) {\n                  diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                }\n              }\n            } else {\n              that[name](instance, false);\n            }\n          },\n          content: function (content) {\n            var result = this._content(content);\n\n            if (defined(content)) {\n              this._alignContent();\n            }\n\n            return result;\n          },\n          _createContentVisual: function (options) {\n            var visual;\n\n            if (isFunction(options.visual)) {\n              visual = options.visual.call(this, options);\n            } else if (options.text) {\n              visual = new TextBlock(options);\n            }\n\n            if (visual) {\n              this._contentVisual = visual;\n              visual._includeInBBox = false;\n              this.visual.append(visual);\n            }\n\n            return visual;\n          },\n          _updateContentVisual: function (options) {\n            if (isFunction(options.visual)) {\n              this.visual.remove(this._contentVisual);\n\n              this._createContentVisual(options);\n            } else {\n              this._contentVisual.redraw(options);\n            }\n          },\n          _alignContent: function () {\n            if (this._contentVisual) {\n              var offset = CONNECTION_CONTENT_OFFSET;\n              var points = this.allPoints();\n              var endIdx = math.floor(points.length / 2);\n              var startIdx = endIdx - 1;\n\n              while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                startIdx--;\n                endIdx++;\n              }\n\n              var endPoint = points[endIdx];\n              var startPoint = points[startIdx];\n\n              var boundingBox = this._contentVisual._measure();\n\n              var width = boundingBox.width;\n              var height = boundingBox.height;\n              var alignToPath = points.length % 2 === 0;\n              var distance = startPoint.distanceTo(endPoint);\n\n              if (alignToPath && points.length > 2 && distance > 0 && (startPoint.y === endPoint.y && distance < width || startPoint.x === endPoint.x && distance < height)) {\n                alignToPath = false;\n                offset = 0;\n              }\n\n              var point;\n\n              if (alignToPath) {\n                var angle = draw.util.deg(math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n\n                if (math.abs(angle) === 90) {\n                  point.x += offset;\n                  point.y -= height / 2;\n                } else if (angle % 180 === 0) {\n                  point.x -= width / 2;\n                  point.y -= height + offset;\n                } else if (angle < -90 || 0 < angle && angle < 90) {\n                  point.y -= height;\n                } else if (angle < 0 || angle > 90) {\n                  point.x -= width;\n                  point.y -= height;\n                }\n              } else {\n                var midIdx = math.floor(points.length / 2);\n                point = points[midIdx].clone();\n                startPoint = points[midIdx - 1];\n                endPoint = points[midIdx + 1];\n                var offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                var offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n                point.x += offsetX;\n                point.y += offsetY;\n              }\n\n              this._contentVisual.position(point);\n            }\n          },\n\n          /**\n           * Selects or unselects this connections.\n           * @param value True to select, false to unselect.\n           */\n          select: function (value) {\n            var diagram = this.diagram,\n                selected,\n                deselected;\n\n            if (this._canSelect()) {\n              if (this.isSelected !== value) {\n                this.isSelected = value;\n                selected = [];\n                deselected = [];\n\n                if (this.isSelected) {\n                  this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n\n                  diagram._adorn(this.adorner, true);\n\n                  diagram._selectedItems.push(this);\n\n                  selected.push(this);\n                } else {\n                  if (this.adorner) {\n                    diagram._adorn(this.adorner, false);\n\n                    Utils.remove(diagram._selectedItems, this);\n                    this.adorner = undefined;\n                    deselected.push(this);\n                  }\n                }\n\n                if (this.adorner) {\n                  this.adorner.refresh();\n                }\n\n                if (!diagram._internalSelection) {\n                  diagram._selectionChanged(selected, deselected);\n                }\n\n                return true;\n              }\n            }\n          },\n\n          /**\n           * Gets or sets the bounds of this connection.\n           * @param value A Rect object.\n           * @remark This is automatically set in the refresh().\n           * @returns {Rect}\n           */\n          bounds: function (value) {\n            if (value && !isString(value)) {\n              this._bounds = value;\n            } else {\n              return this._bounds;\n            }\n          },\n\n          /**\n           * Gets or sets the connection type (see ConnectionType enumeration).\n           * @param value A ConnectionType value.\n           * @returns {ConnectionType}\n           */\n          type: function (value) {\n            var options = this.options;\n\n            if (value) {\n              if (value !== options.type) {\n                options.type = value;\n\n                this._initRouter();\n\n                this.refresh();\n              }\n            } else {\n              return options.type;\n            }\n          },\n          _initRouter: function () {\n            var type = (this.options.type || \"\").toLowerCase();\n\n            if (type == CASCADING) {\n              this._router = new CascadingRouter(this);\n            } else {\n              this._router = new PolylineRouter(this);\n            }\n          },\n\n          /**\n           * Gets or sets the collection of *intermediate* points.\n           * The 'allPoints()' property will return all the points.\n           * The 'definers' property returns the definers of the intermediate points.\n           * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n           * @param value\n           */\n          points: function (value) {\n            if (value) {\n              this.definers = [];\n\n              for (var i = 0; i < value.length; i++) {\n                var definition = value[i];\n\n                if (definition instanceof diagram.Point) {\n                  this.definers.push(new diagram.PathDefiner(definition));\n                } else if (definition.hasOwnProperty(\"x\") && definition.hasOwnProperty(\"y\")) {\n                  // e.g. Clipboard does not preserve the Point definition and tunred into an Object\n                  this.definers.push(new diagram.PathDefiner(new Point(definition.x, definition.y)));\n                } else {\n                  throw \"A Connection point needs to be a Point or an object with x and y properties.\";\n                }\n              }\n            } else {\n              var pts = [];\n\n              if (isDefined(this.definers)) {\n                for (var k = 0; k < this.definers.length; k++) {\n                  pts.push(this.definers[k].point);\n                }\n              }\n\n              return pts;\n            }\n          },\n\n          /**\n           * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n           * @returns {Array}\n           */\n          allPoints: function () {\n            var pts = [this.sourcePoint()];\n\n            if (this.definers) {\n              for (var k = 0; k < this.definers.length; k++) {\n                pts.push(this.definers[k].point);\n              }\n            }\n\n            pts.push(this.targetPoint());\n            return pts;\n          },\n          refresh: function () {\n            this._resolveConnectors();\n\n            this._refreshPath();\n\n            this._alignContent();\n\n            if (this.adorner) {\n              this.adorner.refresh();\n            }\n          },\n          _resolveConnectors: function () {\n            var connection = this,\n                sourcePoint,\n                targetPoint,\n                sourceConnectors,\n                targetConnectors,\n                source = connection.source(),\n                target = connection.target();\n\n            if (source instanceof Point) {\n              sourcePoint = source;\n            } else if (source instanceof Connector) {\n              if (isAutoConnector(source)) {\n                sourceConnectors = source.shape.connectors;\n              } else {\n                sourceConnectors = [source];\n              }\n            }\n\n            if (target instanceof Point) {\n              targetPoint = target;\n            } else if (target instanceof Connector) {\n              if (isAutoConnector(target)) {\n                targetConnectors = target.shape.connectors;\n              } else {\n                targetConnectors = [target];\n              }\n            }\n\n            if (sourcePoint) {\n              if (targetConnectors) {\n                connection._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n              }\n            } else if (sourceConnectors) {\n              if (targetPoint) {\n                connection._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n              } else if (targetConnectors) {\n                this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n              }\n            }\n          },\n          _resolveAutoConnectors: function (sourceConnectors, targetConnectors) {\n            var minNonConflict = MAXINT;\n            var minDist = MAXINT;\n            var minNonConflictSource, minNonConflictTarget;\n            var sourcePoint, targetPoint;\n            var minSource, minTarget;\n            var sourceConnector, targetConnector;\n            var sourceIdx, targetIdx;\n            var dist;\n\n            for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n              sourceConnector = sourceConnectors[sourceIdx];\n\n              if (!isAutoConnector(sourceConnector)) {\n                sourcePoint = sourceConnector.position();\n\n                for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                  targetConnector = targetConnectors[targetIdx];\n\n                  if (!isAutoConnector(targetConnector)) {\n                    targetPoint = targetConnector.position();\n                    dist = math.round(sourcePoint.distanceTo(targetPoint));\n\n                    if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                      minNonConflict = dist;\n                      minNonConflictSource = sourceConnector;\n                      minNonConflictTarget = targetConnector;\n                    }\n\n                    if (dist < minDist) {\n                      minSource = sourceConnector;\n                      minTarget = targetConnector;\n                      minDist = dist;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (minNonConflictSource) {\n              minSource = minNonConflictSource;\n              minTarget = minNonConflictTarget;\n            }\n\n            this._resolvedSourceConnector = minSource;\n            this._resolvedTargetConnector = minTarget;\n          },\n          _testRoutePoints: function (sourcePoint, targetPoint, sourceConnector, targetConnector) {\n            var router = this._router;\n            var passRoute = true;\n\n            if (router instanceof CascadingRouter) {\n              var points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector),\n                  start,\n                  end,\n                  rect,\n                  exclude;\n              exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n              points.unshift(sourcePoint);\n              points.push(targetPoint);\n\n              for (var idx = 1; idx < points.length; idx++) {\n                start = points[idx - 1];\n                end = points[idx];\n                rect = new Rect(math.min(start.x, end.x), math.min(start.y, end.y), math.abs(start.x - end.x), math.abs(start.y - end.y));\n\n                if (rect.width > 0) {\n                  rect.x++;\n                  rect.width -= 2;\n                }\n\n                if (rect.height > 0) {\n                  rect.y++;\n                  rect.height -= 2;\n                }\n\n                if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                  passRoute = false;\n                  break;\n                }\n              }\n            }\n\n            return passRoute;\n          },\n          _getRouteExclude: function (sourcePoint, targetPoint, sourceShape, targetShape) {\n            var exclude = [];\n\n            if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n              exclude.push(sourceShape);\n            }\n\n            if (this._isPointInsideShape(targetPoint, targetShape)) {\n              exclude.push(targetShape);\n            }\n\n            return exclude;\n          },\n          _isPointInsideShape: function (point, shape) {\n            var bounds = shape.bounds(),\n                rotatedPoint,\n                angle = shape.rotate().angle,\n                pointX,\n                pointY,\n                boundsX = bounds.x,\n                boundsY = bounds.y;\n            rotatedPoint = point.clone().rotate(bounds.center(), angle);\n            pointX = rotatedPoint.x;\n            pointY = rotatedPoint.y;\n            return pointX > boundsX && pointX < boundsX + bounds.width && pointY > boundsY && pointY < boundsY + bounds.height;\n          },\n          redraw: function (options) {\n            if (options) {\n              this.options = deepExtend({}, this.options, options);\n              var points = this.options.points;\n\n              if (defined(points) && points.length > 0) {\n                this.points(points);\n\n                this._refreshPath();\n              }\n\n              if (options && options.content || options.text) {\n                this.content(options.content);\n              }\n\n              this.path.redraw({\n                fill: options.fill,\n                stroke: options.stroke,\n                startCap: options.startCap,\n                endCap: options.endCap\n              });\n            }\n          },\n\n          /**\n           * Returns a clone of this connection.\n           * @returns {Connection}\n           */\n          clone: function () {\n            var json = this.serialize();\n\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n              json.options.dataItem = cloneDataItem(this.dataItem);\n            }\n\n            return new Connection(this.from, this.to, json.options);\n          },\n\n          /**\n           * Returns a serialized connection in json format. Consist of the options and the dataItem.\n           * @returns {Connection}\n           */\n          serialize: function () {\n            var from = this.from.toJSON ? this.from.toJSON : this.from.toString(),\n                to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n            var json = deepExtend({}, {\n              options: this.options,\n              from: from,\n              to: to\n            });\n\n            if (defined(this.dataItem)) {\n              json.dataItem = this.dataItem.toString();\n            }\n\n            json.options.points = this.points();\n            return json;\n          },\n\n          /**\n           * Returns whether the given Point or Rect hits this connection.\n           * @param value\n           * @returns {Connection}\n           * @private\n           */\n          _hitTest: function (value) {\n            if (this.visible()) {\n              var p = new Point(value.x, value.y),\n                  from = this.sourcePoint(),\n                  to = this.targetPoint();\n\n              if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                return this;\n              }\n\n              if (this._router.hitTest(p)) {\n                return this;\n              }\n            }\n          },\n          _hover: function (value) {\n            var color = (this.options.stroke || {}).color;\n\n            if (value && isDefined(this.options.hover.stroke.color)) {\n              color = this.options.hover.stroke.color;\n            }\n\n            this.path.redraw({\n              stroke: {\n                color: color\n              }\n            });\n          },\n          _refreshPath: function () {\n            if (!defined(this.path)) {\n              return;\n            }\n\n            this._drawPath();\n\n            this.bounds(this._router.getBounds());\n          },\n          _drawPath: function () {\n            if (this._router) {\n              this._router.route(); // sets the intermediate points\n\n            }\n\n            var source = this.sourcePoint();\n            var target = this.targetPoint();\n            var points = this.points();\n            this.path.redraw({\n              points: [source].concat(points, [target])\n            });\n          },\n          _clearSourceConnector: function () {\n            this.sourceConnector = undefined;\n            this._resolvedSourceConnector = undefined;\n          },\n          _clearTargetConnector: function () {\n            this.targetConnector = undefined;\n            this._resolvedTargetConnector = undefined;\n          },\n          _removeFromSourceConnector: function () {\n            if (this.sourceConnector) {\n              Utils.remove(this.sourceConnector.connections, this);\n            }\n          },\n          _removeFromTargetConnector: function () {\n            if (this.targetConnector) {\n              Utils.remove(this.targetConnector.connections, this);\n            }\n          },\n          toJSON: function () {\n            var connection = this;\n            var from, to, point;\n\n            if (connection.from && connection.from.toJSON) {\n              from = connection.from.toJSON();\n            } else {\n              point = connection._sourcePoint;\n              from = {\n                x: point.x,\n                y: point.y\n              };\n            }\n\n            if (connection.to && connection.to.toJSON) {\n              to = connection.to.toJSON();\n            } else {\n              point = connection._targetPoint;\n              to = {\n                x: point.x,\n                y: point.y\n              };\n            }\n\n            return {\n              from: from,\n              to: to\n            };\n          }\n        });\n        var Diagram = Widget.extend({\n          init: function (element, userOptions) {\n            var that = this;\n            kendo.destroy(element);\n            Widget.fn.init.call(that, element, userOptions);\n\n            that._initTheme();\n\n            that._initElements();\n\n            that._extendLayoutOptions(that.options);\n\n            that._initDefaults(userOptions);\n\n            that._interactionDefaults();\n\n            that._initCanvas();\n\n            that.mainLayer = new Group({\n              id: \"main-layer\"\n            });\n            that.canvas.append(that.mainLayer);\n            that._shapesQuadTree = new ShapesQuadTree(that);\n            that._pan = new Point();\n            that._adorners = [];\n            that.adornerLayer = new Group({\n              id: \"adorner-layer\"\n            });\n            that.canvas.append(that.adornerLayer);\n\n            that._createHandlers();\n\n            that._initialize();\n\n            that._resizingAdorner = new ResizingAdorner(that, {\n              editable: that.options.editable\n            });\n            that._connectorsAdorner = new ConnectorsAdorner(that);\n\n            that._adorn(that._resizingAdorner, true);\n\n            that._adorn(that._connectorsAdorner, true);\n\n            that.selector = new Selector(that); // TODO: We may consider using real Clipboard API once is supported by the standard.\n\n            that._clipboard = [];\n            that.pauseMouseHandlers = false;\n\n            that._fetchFreshData();\n\n            that._createGlobalToolBar();\n\n            that._createOptionElements();\n\n            that.zoom(that.options.zoom);\n            that.canvas.draw();\n          },\n          options: {\n            name: \"Diagram\",\n            theme: \"default\",\n            layout: \"\",\n            zoomRate: 0.1,\n            zoom: 1,\n            zoomMin: 0,\n            zoomMax: 2,\n            dataSource: {},\n            draggable: true,\n            template: \"\",\n            autoBind: true,\n            editable: {\n              rotate: {},\n              resize: {},\n              text: true,\n              tools: [],\n              drag: {\n                snap: {\n                  size: 10,\n                  angle: 10\n                }\n              },\n              remove: true\n            },\n            pannable: {},\n            selectable: {\n              key: \"none\"\n            },\n            tooltip: {\n              enabled: true,\n              format: \"{0}\"\n            },\n            copy: {\n              enabled: true,\n              offsetX: 20,\n              offsetY: 20\n            },\n            shapeDefaults: diagram.shapeDefaults({\n              undoable: true\n            }),\n            connectionDefaults: {\n              editable: {\n                tools: []\n              },\n              type: CASCADING\n            },\n            shapes: [],\n            connections: []\n          },\n          events: [ZOOM_END, ZOOM_START, PAN, SELECT, ITEMROTATE, ITEMBOUNDSCHANGE, CHANGE, CLICK, MOUSE_ENTER, MOUSE_LEAVE, \"toolBarClick\", \"save\", \"cancel\", \"edit\", \"remove\", \"add\", \"dataBound\", DRAG_START, DRAG, DRAG_END],\n          items: function () {\n            return $();\n          },\n          _createGlobalToolBar: function () {\n            var editable = this.options.editable;\n\n            if (editable) {\n              var tools = editable.tools;\n\n              if (this._isEditable && tools !== false && (!tools || tools.length === 0)) {\n                tools = [\"createShape\", \"undo\", \"redo\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n              }\n\n              if (tools && tools.length) {\n                this.toolBar = new DiagramToolBar(this, {\n                  tools: tools || {},\n                  click: this._toolBarClick.bind(this),\n                  modal: false\n                });\n                this.toolBar.element.css({\n                  textAlign: \"left\"\n                });\n                this.element.prepend(this.toolBar.element);\n\n                this._resize();\n              }\n            }\n          },\n          createShape: function () {\n            if (this.editor && this.editor.end() || !this.editor) {\n              var dataSource = this.dataSource;\n              var view = dataSource.view() || [];\n              var index = view.length;\n              var model = createModel(dataSource, {});\n\n              var shape = this._createShape(model, {});\n\n              if (!this.trigger(\"add\", {\n                shape: shape\n              })) {\n                dataSource.insert(index, model);\n\n                var inactiveItem = this._inactiveShapeItems.getByUid(model.uid);\n\n                inactiveItem.element = shape;\n                this.edit(shape);\n              }\n            }\n          },\n          _createShape: function (dataItem, options) {\n            options = deepExtend({}, this.options.shapeDefaults, options);\n            options.dataItem = dataItem;\n            var shape = new Shape(options, this);\n            return shape;\n          },\n          createConnection: function () {\n            if (this.editor && this.editor.end() || !this.editor) {\n              var connectionsDataSource = this.connectionsDataSource;\n              var view = connectionsDataSource.view() || [];\n              var index = view.length;\n              var model = createModel(connectionsDataSource, {});\n\n              var connection = this._createConnection(model);\n\n              if (!this.trigger(\"add\", {\n                connection: connection\n              })) {\n                this._connectionsDataMap[model.uid] = connection;\n                connectionsDataSource.insert(index, model);\n                this.addConnection(connection, false);\n                this.edit(connection);\n              }\n            }\n          },\n          _createConnection: function (dataItem, source, target) {\n            var options = deepExtend({}, this.options.connectionDefaults);\n            options.dataItem = dataItem;\n            var connection = new Connection(source || new Point(), target || new Point(), options);\n            return connection;\n          },\n          editModel: function (dataItem, editorType) {\n            this.cancelEdit();\n            var editors, template;\n            var editable = this.options.editable;\n\n            if (editorType == \"shape\") {\n              editors = editable.shapeEditors;\n              template = editable.shapeTemplate;\n            } else if (editorType == \"connection\") {\n              var connectionSelectorHandler = connectionSelector.bind(this);\n              editors = deepExtend({}, {\n                from: connectionSelectorHandler,\n                to: connectionSelectorHandler\n              }, editable.connectionEditors);\n              template = editable.connectionTemplate;\n            } else {\n              return;\n            }\n\n            this.editor = new PopupEditor(this.element, {\n              update: this._update.bind(this),\n              cancel: this._cancel.bind(this),\n              model: dataItem,\n              type: editorType,\n              target: this,\n              editors: editors,\n              template: template\n            });\n            this.trigger(\"edit\", this._editArgs());\n          },\n          edit: function (item) {\n            if (item.dataItem) {\n              var editorType = item instanceof Shape ? \"shape\" : \"connection\";\n              this.editModel(item.dataItem, editorType);\n            }\n          },\n          cancelEdit: function () {\n            if (this.editor) {\n              this._getEditDataSource().cancelChanges(this.editor.model);\n\n              this._destroyEditor();\n            }\n          },\n          saveEdit: function () {\n            if (this.editor && this.editor.end() && !this.trigger(\"save\", this._editArgs())) {\n              this._getEditDataSource().sync();\n            }\n          },\n          _update: function () {\n            if (this.editor && this.editor.end() && !this.trigger(\"save\", this._editArgs())) {\n              this._getEditDataSource().sync();\n\n              this._destroyEditor();\n            }\n          },\n          _cancel: function () {\n            if (this.editor && !this.trigger(\"cancel\", this._editArgs())) {\n              var model = this.editor.model;\n\n              this._getEditDataSource().cancelChanges(model);\n\n              var element = this._connectionsDataMap[model.uid] || this._dataMap[model.id];\n\n              if (element) {\n                element._setOptionsFromModel(model);\n              }\n\n              this._destroyEditor();\n            }\n          },\n          _getEditDataSource: function () {\n            return this.editor.options.type === \"shape\" ? this.dataSource : this.connectionsDataSource;\n          },\n          _editArgs: function () {\n            var result = {\n              container: this.editor.wrapper\n            };\n            result[this.editor.options.type] = this.editor.model;\n            return result;\n          },\n          _destroyEditor: function () {\n            if (this.editor) {\n              this.editor.close();\n              this.editor = null;\n            }\n          },\n          _initElements: function () {\n            this.wrapper = this.element.empty().css(\"position\", \"relative\").attr(\"tabindex\", 0).addClass(\"k-widget k-diagram\");\n            this.scrollable = $(\"<div />\").appendTo(this.element);\n          },\n          _initDefaults: function (userOptions) {\n            var options = this.options;\n            var editable = options.editable;\n            var shapeDefaults = options.shapeDefaults;\n            var connectionDefaults = options.connectionDefaults;\n            var userShapeDefaults = (userOptions || {}).shapeDefaults;\n\n            if (editable === false) {\n              shapeDefaults.editable = false;\n              connectionDefaults.editable = false;\n            } else {\n              copyDefaultOptions(editable, shapeDefaults.editable, [\"drag\", \"remove\", \"connect\"]);\n              copyDefaultOptions(editable, connectionDefaults.editable, [\"drag\", \"remove\"]);\n            }\n\n            if (userShapeDefaults && userShapeDefaults.connectors) {\n              options.shapeDefaults.connectors = userShapeDefaults.connectors;\n            }\n          },\n          _interactionDefaults: function () {\n            var options = this.options;\n            var selectable = options.selectable;\n            var pannable = options.pannable;\n            var mobile = kendo.support.mobileOS;\n\n            if (selectable && !defined(selectable.multiple)) {\n              options.selectable = deepExtend({\n                multiple: mobile ? false : true\n              }, options.selectable);\n            }\n\n            if (pannable && !defined(pannable.key)) {\n              options.pannable = deepExtend({\n                key: mobile ? \"none\" : \"ctrl\"\n              }, options.pannable);\n            }\n          },\n          _initCanvas: function () {\n            var canvasContainer = $(\"<div class='k-layer'></div>\").appendTo(this.scrollable)[0];\n            var viewPort = this.viewport();\n            this.canvas = new Canvas(canvasContainer, {\n              width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n              height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n            });\n          },\n          _createHandlers: function () {\n            var that = this;\n            var element = that.element;\n            element.on(MOUSEWHEEL_NS, that._wheel.bind(that)).on(\"keydown\" + NS, that._keydown.bind(that));\n            that._userEvents = new kendo.UserEvents(this.scrollable, {\n              multiTouch: true,\n              fastTap: true,\n              tap: that._tap.bind(that),\n              start: that._dragStart.bind(that),\n              move: that._drag.bind(that),\n              end: that._dragEnd.bind(that),\n              gesturestart: that._gestureStart.bind(that),\n              gesturechange: that._gestureChange.bind(that),\n              gestureend: that._gestureEnd.bind(that),\n              doubleTap: that._doubleTap.bind(that),\n              supportDoubleTap: true\n            });\n            that.toolService = new ToolService(that);\n            this.scrollable.on(\"mouseover\" + NS, that._mouseover.bind(that)).on(\"mouseout\" + NS, that._mouseout.bind(that)).on(\"mousemove\" + NS, that._mouseMove.bind(that)).on(\"mousedown\" + NS, that._mouseDown.bind(that)).on(\"mouseup\" + NS, that._mouseUp.bind(that));\n            this._syncHandler = that._syncChanges.bind(that);\n            that._resizeHandler = that.resize.bind(that, false);\n            kendo.onResize(that._resizeHandler);\n            this.bind(ZOOM_START, that._destroyToolBar.bind(that));\n            this.bind(PAN, that._destroyToolBar.bind(that));\n          },\n          _dragStart: function (e) {\n            this._pauseMouseHandlers = true;\n\n            var point = this._eventPositions(e, true);\n\n            var event = e.event;\n\n            if (this.toolService.start(point, this._meta(event))) {\n              this._destroyToolBar();\n\n              event.preventDefault();\n            }\n          },\n          _drag: function (e) {\n            var p = this._eventPositions(e);\n\n            var event = e.event;\n\n            if (this.toolService.move(p, this._meta(event))) {\n              event.preventDefault();\n            }\n          },\n          _dragEnd: function (e) {\n            this._pauseMouseHandlers = false;\n\n            var p = this._eventPositions(e);\n\n            var event = e.event;\n\n            if (this.toolService.end(p, this._meta(event))) {\n              this._createToolBar();\n\n              event.preventDefault();\n            }\n          },\n          _mouseMove: function (e) {\n            if (!this._pauseMouseHandlers) {\n              var p = this._eventPositions(e);\n\n              this.toolService._updateHoveredItem(p);\n\n              this.toolService._updateCursor(p);\n            }\n          },\n          _mouseDown: function () {\n            this._pauseMouseHandlers = true;\n          },\n          _mouseUp: function () {\n            this._pauseMouseHandlers = false;\n          },\n          _tap: function (e) {\n            var toolService = this.toolService;\n            var selectable = this.options.selectable;\n\n            var point = this._eventPositions(e);\n\n            var focused = this.focus();\n\n            toolService._updateHoveredItem(point);\n\n            if (toolService.hoveredItem) {\n              var item = toolService.hoveredItem;\n              this.trigger(\"click\", {\n                item: item,\n                point: point,\n                meta: this._meta(e.event)\n              });\n\n              if (selectable && item.options.selectable !== false) {\n                var multiple = selectable.multiple !== false;\n\n                var ctrlPressed = kendo.support.mobileOS || this._meta(e.event).ctrlKey;\n\n                if (item.isSelected) {\n                  if (ctrlPressed) {\n                    this._destroyToolBar();\n\n                    item.select(false);\n                  } else {\n                    this._createToolBar(focused);\n                  }\n                } else {\n                  this._destroyToolBar();\n\n                  this.select(item, {\n                    addToSelection: multiple && ctrlPressed\n                  });\n\n                  this._createToolBar(focused);\n                }\n              }\n            } else if (selectable) {\n              this._destroyToolBar();\n\n              this.deselect();\n            }\n          },\n          _keydown: function (e) {\n            if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n              e.preventDefault();\n            }\n          },\n          _wheel: function (e) {\n            var delta = mwDelta(e),\n                p = this._eventPositions(e),\n                meta = deepExtend(this._meta(e), {\n              delta: delta\n            });\n\n            if (this.toolService.wheel(p, meta)) {\n              e.preventDefault();\n            }\n          },\n          _meta: function (e) {\n            return {\n              ctrlKey: e.ctrlKey,\n              metaKey: e.metaKey,\n              altKey: e.altKey,\n              shiftKey: e.shiftKey,\n              type: e.type\n            };\n          },\n          _eventPositions: function (e, start) {\n            var point;\n\n            if (e.touch) {\n              var field = start ? \"startLocation\" : \"location\";\n              point = new Point(e.x[field], e.y[field]);\n            } else {\n              var event = e.originalEvent;\n              point = new Point(event.pageX, event.pageY);\n            }\n\n            return this.documentToModel(point);\n          },\n          _gestureStart: function (e) {\n            this._destroyToolBar();\n\n            this.scroller.disable();\n            var initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n            var eventArgs = {\n              point: initialCenter,\n              zoom: this.zoom()\n            };\n\n            if (this.trigger(ZOOM_START, eventArgs)) {\n              return;\n            }\n\n            this._gesture = e;\n            this._initialCenter = initialCenter;\n          },\n          _gestureChange: function (e) {\n            var previousGesture = this._gesture;\n            var initialCenter = this._initialCenter;\n            var center = this.documentToView(new Point(e.center.x, e.center.y));\n            var scaleDelta = e.distance / previousGesture.distance;\n            var zoom = this._zoom;\n            var updateZoom = false;\n\n            if (math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n              this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n              this.options.zoom = zoom;\n              this._gesture = e;\n              updateZoom = true;\n            }\n\n            var zoomedPoint = initialCenter.times(zoom);\n            var pan = center.minus(zoomedPoint);\n\n            if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n              this._panTransform(pan);\n\n              this._updateAdorners();\n            }\n\n            e.preventDefault();\n          },\n          _doubleTap: function (e) {\n            var diagram = this;\n\n            var pointPosition = this._eventPositions(e);\n\n            var options = diagram.options;\n            var zoomRate = options.zoomRate;\n            var zoom = diagram.zoom() + zoomRate;\n\n            var meta = this._meta(e);\n\n            var zoomOptions = {\n              point: pointPosition,\n              meta: meta,\n              zoom: zoom\n            };\n\n            if (diagram.trigger(ZOOM_START, zoomOptions)) {\n              return;\n            }\n\n            zoom = kendo.dataviz.round(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n            zoomOptions.zoom = zoom;\n            diagram.zoom(zoom, zoomOptions);\n            diagram.trigger(ZOOM_END, zoomOptions);\n          },\n          _gestureEnd: function () {\n            if (this.options.pannable !== false) {\n              this.scroller.enable();\n            }\n\n            this.trigger(ZOOM_END, {\n              point: this._initialCenter,\n              zoom: this.zoom()\n            });\n          },\n          _resize: function () {\n            var viewport = this.viewport();\n\n            if (this.canvas) {\n              this.canvas.size(viewport);\n            }\n\n            if (this.scrollable && this.toolBar) {\n              this.scrollable.height(viewport.height);\n            }\n          },\n          _mouseover: function (e) {\n            var node = e.target._kendoNode;\n\n            if (node && node.srcElement._hover) {\n              node.srcElement._hover(true, node.srcElement);\n            }\n          },\n          _mouseout: function (e) {\n            var node = e.target._kendoNode;\n\n            if (node && node.srcElement._hover) {\n              node.srcElement._hover(false, node.srcElement);\n            }\n          },\n          _initTheme: function () {\n            var that = this;\n            var themeName = ((that.options || {}).theme || \"\").toLowerCase();\n            var themes = dataviz.ui.themes || {};\n            var themeOptions;\n\n            if (dataviz.SASS_THEMES.indexOf(themeName) != -1) {\n              themeOptions = dataviz.autoTheme().diagram;\n            } else {\n              themeOptions = (themes[themeName] || {}).diagram;\n            }\n\n            that.options = deepExtend({}, themeOptions, that.options);\n\n            if (that.options.editable === true) {\n              deepExtend(that.options, {\n                editable: (themeOptions || {}).editable\n              });\n            }\n          },\n          _createOptionElements: function () {\n            var options = this.options;\n            var shapesLength = options.shapes.length;\n\n            if (shapesLength) {\n              this._createShapes();\n            }\n\n            if (options.connections.length) {\n              this._createConnections();\n            }\n\n            if (shapesLength && options.layout) {\n              this.layout(options.layout);\n            }\n          },\n          _createShapes: function () {\n            var that = this,\n                options = that.options,\n                shapes = options.shapes,\n                shape,\n                i;\n\n            for (i = 0; i < shapes.length; i++) {\n              shape = shapes[i];\n              that.addShape(shape);\n            }\n          },\n          _createConnections: function () {\n            var diagram = this,\n                options = diagram.options,\n                defaults = options.connectionDefaults,\n                connections = options.connections,\n                conn,\n                source,\n                target,\n                i;\n\n            for (i = 0; i < connections.length; i++) {\n              conn = connections[i];\n              source = diagram._findConnectionTarget(conn.from);\n              target = diagram._findConnectionTarget(conn.to);\n              diagram.connect(source, target, deepExtend({}, defaults, conn));\n            }\n          },\n          _findConnectionTarget: function (options) {\n            options = options || {};\n            var diagram = this;\n            var shapeId = isString(options) ? options : options.shapeId || options.id;\n            var target;\n\n            if (shapeId) {\n              target = diagram.getShapeById(shapeId);\n\n              if (options.connector) {\n                target = target.getConnector(options.connector);\n              }\n            } else {\n              target = new Point(options.x || 0, options.y || 0);\n            }\n\n            return target;\n          },\n          destroy: function () {\n            var that = this;\n            Widget.fn.destroy.call(that);\n\n            if (this._userEvents) {\n              this._userEvents.destroy();\n            }\n\n            kendo.unbindResize(that._resizeHandler);\n            that.clear();\n            that.element.off(NS);\n            that.scroller.wrapper.off(NS);\n            that.canvas.destroy(true);\n            that.canvas = undefined;\n\n            that._destroyEditor();\n\n            that.destroyScroller();\n\n            that._destroyGlobalToolBar();\n\n            that._destroyToolBar();\n          },\n          destroyScroller: function () {\n            var scroller = this.scroller;\n\n            if (!scroller) {\n              return;\n            }\n\n            scroller.destroy();\n            scroller.element.remove();\n            this.scroller = null;\n          },\n          save: function () {\n            var json = {\n              shapes: [],\n              connections: []\n            };\n            var i, connection, shape;\n\n            for (i = 0; i < this.shapes.length; i++) {\n              shape = this.shapes[i];\n\n              if (shape.options.serializable) {\n                json.shapes.push(shape.options);\n              }\n            }\n\n            for (i = 0; i < this.connections.length; i++) {\n              connection = this.connections[i];\n              json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n            }\n\n            return json;\n          },\n          focus: function () {\n            if (!this.element.is(kendo._activeElement())) {\n              var element = this.element,\n                  scrollContainer = element[0],\n                  containers = [],\n                  offsets = [],\n                  documentElement = document.documentElement,\n                  i;\n\n              do {\n                scrollContainer = scrollContainer.parentNode;\n\n                if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                  containers.push(scrollContainer);\n                  offsets.push(scrollContainer.scrollTop);\n                }\n              } while (scrollContainer != documentElement);\n\n              element.trigger(\"focus\");\n\n              for (i = 0; i < containers.length; i++) {\n                containers[i].scrollTop = offsets[i];\n              }\n\n              return true;\n            }\n          },\n          load: function (options) {\n            this.clear();\n            this.setOptions(options);\n\n            this._createShapes();\n\n            this._createConnections();\n          },\n          setOptions: function (options) {\n            deepExtend(this.options, options);\n          },\n          clear: function () {\n            var that = this;\n            that.select(false);\n            that.mainLayer.clear();\n\n            that._shapesQuadTree.clear();\n\n            that._initialize();\n          },\n\n          /**\n           * Connects two items.\n           * @param source Shape, Connector, Point.\n           * @param target Shape, Connector, Point.\n           * @param options Connection options that will be passed to the newly created connection.\n           * @returns The newly created connection.\n           */\n          connect: function (source, target, options) {\n            var connection;\n\n            if (this.connectionsDataSource && this._isEditable) {\n              var dataItem = this.connectionsDataSource.add({});\n              connection = this._connectionsDataMap[dataItem.uid];\n              connection.source(source);\n              connection.target(target);\n              connection.redraw(options);\n              connection.updateModel();\n            } else {\n              connection = new Connection(source, target, deepExtend({}, this.options.connectionDefaults, options));\n              this.addConnection(connection);\n            }\n\n            return connection;\n          },\n\n          /**\n           * Determines whether the the two items are connected.\n           * @param source Shape, Connector, Point.\n           * @param target Shape, Connector, Point.\n           * @returns true if the two items are connected.\n           */\n          connected: function (source, target) {\n            for (var i = 0; i < this.connections.length; i++) {\n              var c = this.connections[i];\n\n              if (c.from == source && c.to == target) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n\n          /**\n           * Adds connection to the diagram.\n           * @param connection Connection.\n           * @param undoable Boolean.\n           * @returns The newly created connection.\n           */\n          addConnection: function (connection, undoable) {\n            if (undoable !== false) {\n              this.undoRedoService.add(new diagram.AddConnectionUnit(connection, this), false);\n            }\n\n            connection.diagram = this;\n\n            connection._setOptionsFromModel();\n\n            connection.refresh();\n            this.mainLayer.append(connection.visual);\n            this.connections.push(connection);\n            this.trigger(CHANGE, {\n              added: [connection],\n              removed: []\n            });\n            return connection;\n          },\n          _addConnection: function (connection, undoable) {\n            var connectionsDataSource = this.connectionsDataSource;\n            var dataItem;\n\n            if (connectionsDataSource && this._isEditable) {\n              dataItem = createModel(connectionsDataSource, cloneDataItem(connection.dataItem));\n              connection.dataItem = dataItem;\n              connection.updateModel();\n\n              if (!this.trigger(\"add\", {\n                connection: connection\n              })) {\n                this._connectionsDataMap[dataItem.uid] = connection;\n                connectionsDataSource.add(dataItem);\n                this.addConnection(connection, undoable);\n\n                connection._updateConnectors();\n\n                return connection;\n              }\n            } else if (!this.trigger(\"add\", {\n              connection: connection\n            })) {\n              this.addConnection(connection, undoable);\n\n              connection._updateConnectors();\n\n              return connection;\n            }\n          },\n\n          /**\n           * Adds shape to the diagram.\n           * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n           * @param options. The options to be passed to the newly created Shape.\n           * @returns The newly created shape.\n           */\n          addShape: function (item, undoable) {\n            var shape,\n                shapeDefaults = this.options.shapeDefaults;\n\n            if (item instanceof Shape) {\n              shape = item;\n\n              this._parseBounds(shape.bounds());\n            } else if (!(item instanceof kendo.Class)) {\n              shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n              shape = new Shape(shapeDefaults, this);\n\n              this._parseBounds(shape.bounds());\n            } else {\n              return;\n            }\n\n            if (undoable !== false) {\n              this.undoRedoService.add(new diagram.AddShapeUnit(shape, this), false);\n            }\n\n            this.shapes.push(shape);\n\n            if (shape.diagram !== this) {\n              this._shapesQuadTree.insert(shape);\n\n              shape.diagram = this;\n            }\n\n            this.mainLayer.append(shape.visual);\n            this.trigger(CHANGE, {\n              added: [shape],\n              removed: []\n            });\n            return shape;\n          },\n          _addShape: function (shape, undoable) {\n            var that = this;\n            var dataSource = that.dataSource;\n            var dataItem;\n\n            if (dataSource && this._isEditable) {\n              dataItem = createModel(dataSource, cloneDataItem(shape.dataItem));\n              shape.dataItem = dataItem;\n              shape.updateModel();\n\n              if (!this.trigger(\"add\", {\n                shape: shape\n              })) {\n                this.dataSource.add(dataItem);\n\n                var inactiveItem = this._inactiveShapeItems.getByUid(dataItem.uid);\n\n                inactiveItem.element = shape;\n                inactiveItem.undoable = undoable;\n                return shape;\n              }\n            } else if (!this.trigger(\"add\", {\n              shape: shape\n            })) {\n              return this.addShape(shape, undoable);\n            }\n          },\n          _parseBounds: function (bounds) {\n            bounds.x = typeof bounds.x == \"string\" ? parseFloat(bounds.x) : bounds.x;\n            bounds.y = typeof bounds.y == \"string\" ? parseFloat(bounds.y) : bounds.y;\n          },\n\n          /**\n           * Removes items (or single item) from the diagram.\n           * @param items DiagramElement, Array of Items.\n           * @param undoable.\n           */\n          remove: function (items, undoable) {\n            items = isArray(items) ? items.slice(0) : [items];\n            var elements = splitDiagramElements(items);\n            var shapes = elements.shapes;\n            var connections = elements.connections;\n            var i;\n\n            if (!defined(undoable)) {\n              undoable = true;\n            }\n\n            if (undoable) {\n              this.undoRedoService.begin();\n            }\n\n            this._suspendModelRefresh();\n\n            for (i = shapes.length - 1; i >= 0; i--) {\n              this._removeItem(shapes[i], undoable, connections);\n            }\n\n            for (i = connections.length - 1; i >= 0; i--) {\n              this._removeItem(connections[i], undoable);\n            }\n\n            this._resumeModelRefresh();\n\n            if (undoable) {\n              this.undoRedoService.commit(false);\n            }\n\n            this.trigger(CHANGE, {\n              added: [],\n              removed: items\n            });\n          },\n          _removeShapeDataItem: function (item) {\n            if (this._isEditable) {\n              this.dataSource.remove(item.dataItem);\n              delete this._dataMap[item.dataItem.id];\n            }\n          },\n          _removeConnectionDataItem: function (item) {\n            if (this._isEditable) {\n              this.connectionsDataSource.remove(item.dataItem);\n              delete this._connectionsDataMap[item.dataItem.uid];\n            }\n          },\n          _triggerRemove: function (items) {\n            var toRemove = [];\n            var item, args, editable;\n\n            for (var idx = 0; idx < items.length; idx++) {\n              item = items[idx];\n              editable = item.options.editable;\n\n              if (item instanceof Shape) {\n                args = {\n                  shape: item\n                };\n              } else {\n                args = {\n                  connection: item\n                };\n              }\n\n              if (editable && editable.remove !== false && !this.trigger(\"remove\", args)) {\n                toRemove.push(item);\n              }\n            }\n\n            return toRemove;\n          },\n\n          /**\n           * Executes the next undoable action on top of the undo stack if any.\n           */\n          undo: function () {\n            this.undoRedoService.undo();\n          },\n\n          /**\n           * Executes the previous undoable action on top of the redo stack if any.\n           */\n          redo: function () {\n            this.undoRedoService.redo();\n          },\n\n          /**\n           * Selects items on the basis of the given input or returns the current selection if none.\n           * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n           * @param options\n           * @returns {Array}\n           */\n          select: function (item, options) {\n            if (isDefined(item)) {\n              options = deepExtend({\n                addToSelection: false\n              }, options);\n              var addToSelection = options.addToSelection,\n                  items = [],\n                  selected = [],\n                  i,\n                  element;\n\n              if (!addToSelection) {\n                this.deselect();\n              }\n\n              this._internalSelection = true;\n\n              if (item instanceof Array) {\n                items = item;\n              } else if (item instanceof DiagramElement) {\n                items = [item];\n              }\n\n              for (i = 0; i < items.length; i++) {\n                element = items[i];\n\n                if (element.select(true)) {\n                  selected.push(element);\n                }\n              }\n\n              this._selectionChanged(selected, []);\n\n              this._internalSelection = false;\n            } else {\n              return this._selectedItems;\n            }\n          },\n          selectAll: function () {\n            this.select(this.shapes.concat(this.connections));\n          },\n          selectArea: function (rect) {\n            var i, items, item;\n            this._internalSelection = true;\n            var selected = [];\n\n            if (rect instanceof Rect) {\n              items = this.shapes.concat(this.connections);\n\n              for (i = 0; i < items.length; i++) {\n                item = items[i];\n\n                if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                  if (item.select(true)) {\n                    selected.push(item);\n                  }\n                }\n              }\n            }\n\n            this._selectionChanged(selected, []);\n\n            this._internalSelection = false;\n          },\n          deselect: function (item) {\n            this._internalSelection = true;\n            var deselected = [],\n                items = [],\n                element,\n                i;\n\n            if (item instanceof Array) {\n              items = item;\n            } else if (item instanceof DiagramElement) {\n              items.push(item);\n            } else if (!isDefined(item)) {\n              items = this._selectedItems.slice(0);\n            }\n\n            for (i = 0; i < items.length; i++) {\n              element = items[i];\n\n              if (element.select(false)) {\n                deselected.push(element);\n              }\n            }\n\n            this._selectionChanged([], deselected);\n\n            this._internalSelection = false;\n          },\n\n          /**\n           * Brings to front the passed items.\n           * @param items DiagramElement, Array of Items.\n           * @param undoable. By default the action is undoable.\n           */\n          toFront: function (items, undoable) {\n            if (!items) {\n              items = this._selectedItems.slice();\n            }\n\n            var result = this._getDiagramItems(items),\n                indices;\n\n            if (!defined(undoable) || undoable) {\n              indices = indicesOfItems(this.mainLayer, result.visuals);\n              var unit = new ToFrontUnit(this, items, indices);\n              this.undoRedoService.add(unit);\n            } else {\n              this.mainLayer.toFront(result.visuals);\n\n              this._fixOrdering(result, true);\n            }\n          },\n\n          /**\n           * Sends to back the passed items.\n           * @param items DiagramElement, Array of Items.\n           * @param undoable. By default the action is undoable.\n           */\n          toBack: function (items, undoable) {\n            if (!items) {\n              items = this._selectedItems.slice();\n            }\n\n            var result = this._getDiagramItems(items),\n                indices;\n\n            if (!defined(undoable) || undoable) {\n              indices = indicesOfItems(this.mainLayer, result.visuals);\n              var unit = new ToBackUnit(this, items, indices);\n              this.undoRedoService.add(unit);\n            } else {\n              this.mainLayer.toBack(result.visuals);\n\n              this._fixOrdering(result, false);\n            }\n          },\n\n          /**\n           * Bring into view the passed item(s) or rectangle.\n           * @param items DiagramElement, Array of Items, Rect.\n           * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n           * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n           */\n          bringIntoView: function (item, options) {\n            // jQuery|Item|Array|Rect\n            var viewport = this.viewport();\n            var aligner = new diagram.RectAlign(viewport);\n            var current, rect, original, newPan;\n\n            if (viewport.width === 0 || viewport.height === 0) {\n              return;\n            }\n\n            options = deepExtend({\n              animate: false,\n              align: \"center middle\"\n            }, options);\n\n            if (options.align == \"none\") {\n              options.align = \"center middle\";\n            }\n\n            if (item instanceof DiagramElement) {\n              rect = item.bounds(TRANSFORMED);\n            } else if (isArray(item)) {\n              rect = this.boundingBox(item);\n            } else if (item instanceof Rect) {\n              rect = item.clone();\n            }\n\n            original = rect.clone();\n            rect.zoom(this._zoom);\n\n            if (rect.width > viewport.width || rect.height > viewport.height) {\n              this._zoom = this._getValidZoom(math.min(viewport.width / original.width, viewport.height / original.height));\n              rect = original.clone().zoom(this._zoom);\n            }\n\n            this._zoomMainLayer();\n\n            current = rect.clone();\n            aligner.align(rect, options.align);\n            newPan = rect.topLeft().minus(current.topLeft());\n            this.pan(newPan.times(-1), options.animate);\n          },\n          alignShapes: function (direction) {\n            if (isUndefined(direction)) {\n              direction = \"Left\";\n            }\n\n            var items = this.select(),\n                val,\n                item,\n                i;\n\n            if (items.length === 0) {\n              return;\n            }\n\n            switch (direction.toLowerCase()) {\n              case \"left\":\n              case \"top\":\n                val = MAX_VALUE;\n                break;\n\n              case \"right\":\n              case \"bottom\":\n                val = MIN_VALUE;\n                break;\n            }\n\n            for (i = 0; i < items.length; i++) {\n              item = items[i];\n\n              if (item instanceof Shape) {\n                switch (direction.toLowerCase()) {\n                  case \"left\":\n                    val = math.min(val, item.options.x);\n                    break;\n\n                  case \"top\":\n                    val = math.min(val, item.options.y);\n                    break;\n\n                  case \"right\":\n                    val = math.max(val, item.options.x);\n                    break;\n\n                  case \"bottom\":\n                    val = math.max(val, item.options.y);\n                    break;\n                }\n              }\n            }\n\n            var undoStates = [];\n            var shapes = [];\n\n            for (i = 0; i < items.length; i++) {\n              item = items[i];\n\n              if (item instanceof Shape) {\n                shapes.push(item);\n                undoStates.push(item.bounds());\n\n                switch (direction.toLowerCase()) {\n                  case \"left\":\n                  case \"right\":\n                    item.position(new Point(val, item.options.y));\n                    break;\n\n                  case \"top\":\n                  case \"bottom\":\n                    item.position(new Point(item.options.x, val));\n                    break;\n                }\n              }\n            }\n\n            var unit = new diagram.TransformUnit(shapes, undoStates);\n            this.undoRedoService.add(unit, false);\n          },\n          zoom: function (zoom, options) {\n            if (zoom) {\n              var staticPoint = options ? options.point : new diagram.Point(0, 0); // var meta = options ? options.meta : 0;\n\n              zoom = this._zoom = this._getValidZoom(zoom);\n\n              if (!isUndefined(staticPoint)) {\n                //Viewpoint vector is constant\n                staticPoint = new diagram.Point(math.round(staticPoint.x), math.round(staticPoint.y));\n                var zoomedPoint = staticPoint.times(zoom);\n                var viewportVector = this.modelToView(staticPoint);\n                var raw = viewportVector.minus(zoomedPoint); //pan + zoomed point = viewpoint vector\n\n                this._storePan(new diagram.Point(math.round(raw.x), math.round(raw.y)));\n              }\n\n              if (options) {\n                options.zoom = zoom;\n              }\n\n              this._panTransform();\n\n              this.canvas.surface.hideTooltip();\n\n              this._updateAdorners();\n            }\n\n            return this._zoom;\n          },\n          _getPan: function (pan) {\n            var canvas = this.canvas;\n\n            if (!canvas.translate) {\n              pan = pan.plus(this._pan);\n            }\n\n            return pan;\n          },\n          pan: function (pan, animate) {\n            if (pan instanceof Point) {\n              var that = this;\n              var scroller = that.scroller;\n              pan = that._getPan(pan);\n              pan = pan.times(-1);\n\n              if (animate) {\n                scroller.animatedScrollTo(pan.x, pan.y, function () {\n                  that._updateAdorners();\n                });\n              } else {\n                scroller.scrollTo(pan.x, pan.y);\n\n                that._updateAdorners();\n              }\n            } else {\n              return this._pan.times(-1);\n            }\n          },\n          viewport: function () {\n            var element = this.element;\n            var width = element.width();\n            var height = element.height();\n\n            if (this.toolBar) {\n              height -= outerHeight(this.toolBar.element);\n            }\n\n            return new Rect(0, 0, width, height);\n          },\n          copy: function () {\n            if (this.options.copy.enabled) {\n              this._clipboard = [];\n              this._copyOffset = 1;\n\n              for (var i = 0; i < this._selectedItems.length; i++) {\n                var item = this._selectedItems[i];\n\n                this._clipboard.push(item);\n              }\n            }\n          },\n          cut: function () {\n            if (this.options.copy.enabled) {\n              this._clipboard = [];\n              this._copyOffset = 0;\n\n              for (var i = 0; i < this._selectedItems.length; i++) {\n                var item = this._selectedItems[i];\n\n                this._clipboard.push(item);\n              }\n\n              this.remove(this._clipboard, true);\n            }\n          },\n          paste: function () {\n            if (this._clipboard.length > 0) {\n              var item, copied, i;\n              var mapping = {};\n              var elements = splitDiagramElements(this._clipboard);\n              var connections = elements.connections;\n              var shapes = elements.shapes;\n              var offset = {\n                x: this._copyOffset * this.options.copy.offsetX,\n                y: this._copyOffset * this.options.copy.offsetY\n              };\n              this.deselect(); // first the shapes\n\n              for (i = 0; i < shapes.length; i++) {\n                item = shapes[i];\n                copied = item.clone();\n                mapping[item.id] = copied;\n                copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                copied.diagram = this;\n                copied = this._addShape(copied);\n\n                if (copied) {\n                  copied.select();\n                }\n              } // then the connections\n\n\n              for (i = 0; i < connections.length; i++) {\n                item = connections[i];\n                copied = this._addConnection(item.clone());\n\n                if (copied) {\n                  this._updateCopiedConnection(copied, item, \"source\", mapping, offset);\n\n                  this._updateCopiedConnection(copied, item, \"target\", mapping, offset);\n\n                  copied.select(true);\n                  copied.updateModel();\n                }\n              }\n\n              this._syncChanges();\n\n              this._copyOffset += 1;\n            }\n          },\n          _updateCopiedConnection: function (connection, sourceConnection, connectorName, mapping, offset) {\n            var onActivate, inactiveItem, targetShape;\n            var target = sourceConnection[connectorName]();\n            var diagram = this;\n\n            if (target instanceof Connector && mapping[target.shape.id]) {\n              targetShape = mapping[target.shape.id];\n\n              if (diagram.getShapeById(targetShape.id)) {\n                connection[connectorName](targetShape.getConnector(target.options.name));\n              } else {\n                inactiveItem = diagram._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n\n                if (inactiveItem) {\n                  onActivate = function (item) {\n                    targetShape = diagram._dataMap[item.id];\n                    connection[connectorName](targetShape.getConnector(target.options.name));\n                    connection.updateModel();\n                  };\n\n                  diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                }\n              }\n            } else {\n              connection[connectorName](new Point(sourceConnection[connectorName + \"Point\"]().x + offset.x, sourceConnection[connectorName + \"Point\"]().y + offset.y));\n            }\n          },\n\n          /**\n           * Gets the bounding rectangle of the given items.\n           * @param items DiagramElement, Array of elements.\n           * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n           * @returns {Rect}\n           */\n          boundingBox: function (items, origin) {\n            var rect = Rect.empty(),\n                temp,\n                di = isDefined(items) ? this._getDiagramItems(items) : {\n              shapes: this.shapes\n            };\n\n            if (di.shapes.length > 0) {\n              var item = di.shapes[0];\n              rect = item.bounds(ROTATED);\n\n              for (var i = 1; i < di.shapes.length; i++) {\n                item = di.shapes[i];\n                temp = item.bounds(ROTATED);\n\n                if (origin === true) {\n                  temp.x -= item._rotationOffset.x;\n                  temp.y -= item._rotationOffset.y;\n                }\n\n                rect = rect.union(temp);\n              }\n            }\n\n            return rect;\n          },\n          _containerOffset: function () {\n            var containerOffset = this.element.offset();\n\n            if (this.toolBar) {\n              containerOffset.top += outerHeight(this.toolBar.element);\n            }\n\n            return containerOffset;\n          },\n          documentToView: function (point) {\n            var containerOffset = this._containerOffset();\n\n            return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n          },\n          viewToDocument: function (point) {\n            var containerOffset = this._containerOffset();\n\n            return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n          },\n          viewToModel: function (point) {\n            return this._transformWithMatrix(point, this._matrixInvert);\n          },\n          modelToView: function (point) {\n            return this._transformWithMatrix(point, this._matrix);\n          },\n          modelToLayer: function (point) {\n            return this._transformWithMatrix(point, this._layerMatrix);\n          },\n          layerToModel: function (point) {\n            return this._transformWithMatrix(point, this._layerMatrixInvert);\n          },\n          documentToModel: function (point) {\n            var viewPoint = this.documentToView(point);\n\n            if (!this.canvas.translate) {\n              viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n              viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n            }\n\n            return this.viewToModel(viewPoint);\n          },\n          modelToDocument: function (point) {\n            return this.viewToDocument(this.modelToView(point));\n          },\n          _transformWithMatrix: function (point, matrix) {\n            var result = point;\n\n            if (point instanceof Point) {\n              if (matrix) {\n                result = matrix.apply(point);\n              }\n            } else {\n              var tl = this._transformWithMatrix(point.topLeft(), matrix),\n                  br = this._transformWithMatrix(point.bottomRight(), matrix);\n\n              result = Rect.fromPoints(tl, br);\n            }\n\n            return result;\n          },\n          setDataSource: function (dataSource) {\n            this.options.dataSource = dataSource;\n\n            this._dataSource();\n\n            if (this.options.autoBind) {\n              this.dataSource.fetch();\n            }\n          },\n          setConnectionsDataSource: function (dataSource) {\n            this.options.connectionsDataSource = dataSource;\n\n            this._connectionDataSource();\n\n            if (this.options.autoBind) {\n              this.connectionsDataSource.fetch();\n            }\n          },\n\n          /**\n           * Performs a diagram layout of the given type.\n           * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n           * @param options Layout-specific options.\n           */\n          layout: function (options) {\n            this._layouting = true; // TODO: raise layout event?\n\n            var type;\n\n            if (isUndefined(options)) {\n              options = this.options.layout;\n            }\n\n            if (isUndefined(options) || isUndefined(options.type)) {\n              type = \"Tree\";\n            } else {\n              type = options.type;\n            }\n\n            var l;\n\n            switch (type.toLowerCase()) {\n              case \"tree\":\n                l = new diagram.TreeLayout(this);\n                break;\n\n              case \"layered\":\n                l = new diagram.LayeredLayout(this);\n                break;\n\n              case \"forcedirected\":\n              case \"force\":\n              case \"spring\":\n              case \"springembedder\":\n                l = new diagram.SpringLayout(this);\n                break;\n\n              default:\n                throw \"Layout algorithm '\" + type + \"' is not supported.\";\n            }\n\n            var initialState = new diagram.LayoutState(this);\n            var finalState = l.layout(options);\n\n            if (finalState) {\n              var unit = new diagram.LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n              this.undoRedoService.add(unit);\n            }\n\n            this._layouting = false;\n\n            this._redrawConnections();\n          },\n\n          /**\n           * Gets a shape on the basis of its identifier.\n           * @param id (string) the identifier of a shape.\n           * @returns {Shape}\n           */\n          getShapeById: function (id) {\n            var found;\n            found = Utils.first(this.shapes, function (s) {\n              return s.visual.id === id;\n            });\n\n            if (found) {\n              return found;\n            }\n\n            found = Utils.first(this.connections, function (c) {\n              return c.visual.id === id;\n            });\n            return found;\n          },\n          getShapeByModelId: function (id) {\n            var shape;\n\n            if (this._isEditable) {\n              shape = this._dataMap[id];\n            } else {\n              shape = Utils.first(this.shapes, function (shape) {\n                return (shape.dataItem || {}).id === id;\n              });\n            }\n\n            return shape;\n          },\n          getShapeByModelUid: function (uid) {\n            var shape;\n\n            if (this._isEditable) {\n              shape = Utils.first(this.shapes, function (shape) {\n                return (shape.dataItem || {}).uid === uid;\n              });\n            } else {\n              shape = this._dataMap[uid];\n            }\n\n            return shape;\n          },\n          getConnectionByModelId: function (id) {\n            var connection;\n\n            if (this.connectionsDataSource) {\n              connection = Utils.first(this.connections, function (connection) {\n                return (connection.dataItem || {}).id === id;\n              });\n            }\n\n            return connection;\n          },\n          getConnectionByModelUid: function (uid) {\n            var connection;\n\n            if (this.connectionsDataSource) {\n              connection = this._connectionsDataMap[uid];\n            }\n\n            return connection;\n          },\n          _extendLayoutOptions: function (options) {\n            if (options.layout) {\n              options.layout = deepExtend({}, diagram.LayoutBase.fn.defaultOptions || {}, options.layout);\n            }\n          },\n          _selectionChanged: function (selected, deselected) {\n            if (selected.length || deselected.length) {\n              this.trigger(SELECT, {\n                selected: selected,\n                deselected: deselected\n              });\n            }\n          },\n          _getValidZoom: function (zoom) {\n            return math.min(math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n          },\n          _panTransform: function (pos) {\n            var diagram = this,\n                pan = pos || diagram._pan;\n\n            if (diagram.canvas.translate) {\n              diagram.scroller.scrollTo(pan.x, pan.y);\n\n              diagram._zoomMainLayer();\n            } else {\n              diagram._storePan(pan);\n\n              diagram._transformMainLayer();\n            }\n          },\n          _finishPan: function () {\n            this.trigger(PAN, {\n              total: this._pan,\n              delta: Number.NaN\n            });\n          },\n          _storePan: function (pan) {\n            this._pan = pan;\n\n            this._storeViewMatrix();\n          },\n          _zoomMainLayer: function () {\n            var zoom = this._zoom;\n            var transform = new CompositeTransform(0, 0, zoom, zoom);\n            transform.render(this.mainLayer);\n\n            this._storeLayerMatrix(transform);\n\n            this._storeViewMatrix();\n          },\n          _transformMainLayer: function () {\n            var pan = this._pan,\n                zoom = this._zoom;\n            var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            transform.render(this.mainLayer);\n\n            this._storeLayerMatrix(transform);\n\n            this._storeViewMatrix();\n          },\n          _storeLayerMatrix: function (canvasTransform) {\n            this._layerMatrix = canvasTransform.toMatrix();\n            this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n          },\n          _storeViewMatrix: function () {\n            var pan = this._pan,\n                zoom = this._zoom;\n            var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            this._matrix = transform.toMatrix();\n            this._matrixInvert = transform.invert().toMatrix();\n          },\n          _toIndex: function (items, indices) {\n            var result = this._getDiagramItems(items);\n\n            this.mainLayer.toIndex(result.visuals, indices);\n\n            this._fixOrdering(result, false);\n          },\n          _fixOrdering: function (result, toFront) {\n            var shapePos = toFront ? this.shapes.length - 1 : 0,\n                conPos = toFront ? this.connections.length - 1 : 0,\n                i,\n                item;\n\n            for (i = 0; i < result.shapes.length; i++) {\n              item = result.shapes[i];\n              Utils.remove(this.shapes, item);\n              Utils.insert(this.shapes, item, shapePos);\n            }\n\n            for (i = 0; i < result.cons.length; i++) {\n              item = result.cons[i];\n              Utils.remove(this.connections, item);\n              Utils.insert(this.connections, item, conPos);\n            }\n          },\n          _getDiagramItems: function (items) {\n            var i,\n                result = {},\n                args = items;\n            result.visuals = [];\n            result.shapes = [];\n            result.cons = [];\n\n            if (!items) {\n              args = this._selectedItems.slice();\n            } else if (!isArray(items)) {\n              args = [items];\n            }\n\n            for (i = 0; i < args.length; i++) {\n              var item = args[i];\n\n              if (item instanceof Shape) {\n                result.shapes.push(item);\n                result.visuals.push(item.visual);\n              } else if (item instanceof Connection) {\n                result.cons.push(item);\n                result.visuals.push(item.visual);\n              }\n            }\n\n            return result;\n          },\n          _removeItem: function (item, undoable, removedConnections) {\n            item.select(false);\n\n            if (item instanceof Shape) {\n              this._removeShapeDataItem(item);\n\n              this._removeShape(item, undoable, removedConnections);\n            } else if (item instanceof Connection) {\n              this._removeConnectionDataItem(item);\n\n              this._removeConnection(item, undoable);\n            }\n\n            this.mainLayer.remove(item.visual);\n          },\n          _removeShape: function (shape, undoable, removedConnections) {\n            var i,\n                connection,\n                connector,\n                sources = [],\n                targets = [];\n\n            this.toolService._removeHover();\n\n            if (undoable) {\n              this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n            }\n\n            Utils.remove(this.shapes, shape);\n\n            this._shapesQuadTree.remove(shape);\n\n            for (i = 0; i < shape.connectors.length; i++) {\n              connector = shape.connectors[i];\n\n              for (var j = 0; j < connector.connections.length; j++) {\n                connection = connector.connections[j];\n\n                if (!removedConnections || !dataviz.inArray(connection, removedConnections)) {\n                  if (connection.sourceConnector == connector) {\n                    sources.push(connection);\n                  } else if (connection.targetConnector == connector) {\n                    targets.push(connection);\n                  }\n                }\n              }\n            }\n\n            for (i = 0; i < sources.length; i++) {\n              sources[i].source(null, undoable);\n              sources[i].updateModel();\n            }\n\n            for (i = 0; i < targets.length; i++) {\n              targets[i].target(null, undoable);\n              targets[i].updateModel();\n            }\n          },\n          _removeConnection: function (connection, undoable) {\n            if (connection.sourceConnector) {\n              Utils.remove(connection.sourceConnector.connections, connection);\n            }\n\n            if (connection.targetConnector) {\n              Utils.remove(connection.targetConnector.connections, connection);\n            }\n\n            if (undoable) {\n              this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n            }\n\n            Utils.remove(this.connections, connection);\n          },\n          _removeDataItems: function (items, recursive) {\n            var item, children, shape, idx;\n            items = isArray(items) ? items : [items];\n\n            while (items.length) {\n              item = items.shift();\n              shape = this._dataMap[item.uid];\n\n              if (shape) {\n                this._removeShapeConnections(shape);\n\n                this._removeItem(shape, false);\n\n                delete this._dataMap[item.uid];\n\n                if (recursive && item.hasChildren && item.loaded()) {\n                  children = item.children.data();\n\n                  for (idx = 0; idx < children.length; idx++) {\n                    items.push(children[idx]);\n                  }\n                }\n              }\n            }\n          },\n          _removeShapeConnections: function (shape) {\n            var connections = shape.connections();\n            var idx;\n\n            if (connections) {\n              for (idx = 0; idx < connections.length; idx++) {\n                this._removeItem(connections[idx], false);\n              }\n            }\n          },\n          _addDataItem: function (dataItem, undoable) {\n            if (!defined(dataItem)) {\n              return;\n            }\n\n            var shape = this._dataMap[dataItem.id];\n\n            if (shape) {\n              return shape;\n            }\n\n            var options = deepExtend({}, this.options.shapeDefaults);\n            options.dataItem = dataItem;\n            shape = new Shape(options, this);\n            this.addShape(shape, undoable !== false);\n            this._dataMap[dataItem.id] = shape;\n            return shape;\n          },\n          _addDataItemByUid: function (dataItem) {\n            if (!defined(dataItem)) {\n              return;\n            }\n\n            var shape = this._dataMap[dataItem.uid];\n\n            if (shape) {\n              return shape;\n            }\n\n            var options = deepExtend({}, this.options.shapeDefaults);\n            options.dataItem = dataItem;\n            shape = new Shape(options, this);\n            this.addShape(shape);\n            this._dataMap[dataItem.uid] = shape;\n            return shape;\n          },\n          _addDataItems: function (items, parent) {\n            var item, idx, shape, parentShape, connection;\n\n            for (idx = 0; idx < items.length; idx++) {\n              item = items[idx];\n              shape = this._addDataItemByUid(item);\n              parentShape = this._addDataItemByUid(parent);\n\n              if (parentShape && !this.connected(parentShape, shape)) {\n                // check if connected to not duplicate connections.\n                connection = this.connect(parentShape, shape);\n              }\n            }\n          },\n          _refreshSource: function (e) {\n            var that = this,\n                node = e.node,\n                action = e.action,\n                items = e.items,\n                options = that.options,\n                idx,\n                dataBound;\n\n            if (e.field) {\n              for (idx = 0; idx < items.length; idx++) {\n                if (this._dataMap[items[idx].uid]) {\n                  this._dataMap[items[idx].uid].redrawVisual();\n                }\n              }\n\n              return;\n            }\n\n            if (action == \"remove\") {\n              this._removeDataItems(e.items, true);\n            } else {\n              if ((!action || action === \"itemloaded\") && !this._bindingRoots) {\n                this._bindingRoots = true;\n                dataBound = true;\n              }\n\n              if (!action && !node) {\n                that.clear();\n              }\n\n              this._addDataItems(items, node);\n\n              for (idx = 0; idx < items.length; idx++) {\n                items[idx].load();\n              }\n            }\n\n            if (options.layout && (dataBound || action == \"remove\" || action == \"add\")) {\n              that.layout(options.layout);\n            }\n\n            if (dataBound) {\n              this.trigger(\"dataBound\");\n              this._bindingRoots = false;\n            }\n          },\n          _addItem: function (item) {\n            if (item instanceof Shape) {\n              this.addShape(item);\n            } else if (item instanceof Connection) {\n              this.addConnection(item);\n            }\n          },\n          _createToolBar: function (preventClosing) {\n            var diagram = this.toolService.diagram;\n\n            if (!this.singleToolBar && diagram.select().length === 1) {\n              var element = diagram.select()[0];\n\n              if (element && element.options.editable !== false) {\n                var editable = element.options.editable;\n                var tools = editable.tools;\n\n                if (this._isEditable && tools.length === 0) {\n                  if (element instanceof Shape) {\n                    tools = [\"edit\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                  } else if (element instanceof Connection) {\n                    tools = [\"edit\"];\n                  }\n\n                  if (editable && editable.remove !== false) {\n                    tools.push(\"delete\");\n                  }\n                }\n\n                if (tools && tools.length) {\n                  var padding = 20;\n                  var point;\n                  this.singleToolBar = new DiagramToolBar(diagram, {\n                    tools: tools,\n                    click: this._toolBarClick.bind(this),\n                    modal: true,\n                    popupZIndex: parseInt(diagram.element.closest(\".k-window\").css(\"zIndex\"), 10) + 10\n                  });\n                  var popupWidth = outerWidth(this.singleToolBar._popup.element);\n                  var popupHeight = outerHeight(this.singleToolBar._popup.element);\n\n                  if (element instanceof Shape) {\n                    var shapeBounds = this.modelToView(element.bounds(ROTATED));\n                    point = new Point(shapeBounds.x, shapeBounds.y).minus(new Point((popupWidth - shapeBounds.width) / 2, popupHeight + padding));\n                  } else if (element instanceof Connection) {\n                    var connectionBounds = this.modelToView(element.bounds());\n                    point = new Point(connectionBounds.x, connectionBounds.y).minus(new Point((popupWidth - connectionBounds.width - 20) / 2, popupHeight + padding));\n                  }\n\n                  if (point) {\n                    if (!this.canvas.translate) {\n                      point = point.minus(new Point(this.scroller.scrollLeft, this.scroller.scrollTop));\n                    }\n\n                    point = this.viewToDocument(point);\n                    point = new Point(math.max(point.x, 0), math.max(point.y, 0));\n                    this.singleToolBar.showAt(point);\n\n                    if (preventClosing) {\n                      this.singleToolBar._popup.one(\"close\", preventDefault);\n                    }\n                  } else {\n                    this._destroyToolBar();\n                  }\n                }\n              }\n            }\n          },\n          _toolBarClick: function (e) {\n            this.trigger(\"toolBarClick\", e);\n\n            this._destroyToolBar();\n          },\n          _normalizePointZoom: function (point) {\n            return point.times(1 / this.zoom());\n          },\n          _initialize: function () {\n            this.shapes = [];\n            this._selectedItems = [];\n            this.connections = [];\n            this._dataMap = {};\n            this._connectionsDataMap = {};\n            this._inactiveShapeItems = new InactiveItemsCollection();\n            this._deferredConnectionUpdates = [];\n            this.undoRedoService = new UndoRedoService({\n              undone: this._syncHandler,\n              redone: this._syncHandler\n            });\n            this.id = diagram.randomId();\n          },\n          _fetchFreshData: function () {\n            var that = this;\n\n            that._dataSource();\n\n            if (that._isEditable) {\n              that._connectionDataSource();\n            }\n\n            if (that.options.autoBind) {\n              if (that._isEditable) {\n                this._loadingShapes = true;\n                this._loadingConnections = true;\n                that.dataSource.fetch();\n                that.connectionsDataSource.fetch();\n              } else {\n                that.dataSource.fetch();\n              }\n            }\n          },\n          _dataSource: function () {\n            if (defined(this.options.connectionsDataSource)) {\n              this._isEditable = true;\n              var dsOptions = this.options.dataSource || {};\n              var ds = isArray(dsOptions) ? {\n                data: dsOptions\n              } : dsOptions;\n\n              if (this.dataSource && this._shapesRefreshHandler) {\n                this.dataSource.unbind(\"change\", this._shapesRefreshHandler).unbind(\"requestStart\", this._shapesRequestStartHandler).unbind(\"error\", this._shapesErrorHandler);\n              } else {\n                this._shapesRefreshHandler = this._refreshShapes.bind(this);\n                this._shapesRequestStartHandler = this._shapesRequestStart.bind(this);\n                this._shapesErrorHandler = this._error.bind(this);\n              }\n\n              this.dataSource = kendo.data.DataSource.create(ds).bind(\"change\", this._shapesRefreshHandler).bind(\"requestStart\", this._shapesRequestStartHandler).bind(\"error\", this._shapesErrorHandler);\n            } else {\n              this._treeDataSource();\n\n              this._isEditable = false;\n            }\n          },\n          _connectionDataSource: function () {\n            var dsOptions = this.options.connectionsDataSource;\n\n            if (dsOptions) {\n              var ds = isArray(dsOptions) ? {\n                data: dsOptions\n              } : dsOptions;\n\n              if (this.connectionsDataSource && this._connectionsRefreshHandler) {\n                this.connectionsDataSource.unbind(\"change\", this._connectionsRefreshHandler).unbind(\"requestStart\", this._connectionsRequestStartHandler).unbind(\"error\", this._connectionsErrorHandler);\n              } else {\n                this._connectionsRefreshHandler = this._refreshConnections.bind(this);\n                this._connectionsRequestStartHandler = this._connectionsRequestStart.bind(this);\n                this._connectionsErrorHandler = this._connectionsError.bind(this);\n              }\n\n              this.connectionsDataSource = kendo.data.DataSource.create(ds).bind(\"change\", this._connectionsRefreshHandler).bind(\"requestStart\", this._connectionsRequestStartHandler).bind(\"error\", this._connectionsErrorHandler);\n            }\n          },\n          _shapesRequestStart: function (e) {\n            if (e.type == \"read\") {\n              this._loadingShapes = true;\n            }\n          },\n          _connectionsRequestStart: function (e) {\n            if (e.type == \"read\") {\n              this._loadingConnections = true;\n            }\n          },\n          _error: function () {\n            this._loadingShapes = false;\n          },\n          _connectionsError: function () {\n            this._loadingConnections = false;\n          },\n          _refreshShapes: function (e) {\n            if (e.action === \"remove\") {\n              if (this._shouldRefresh()) {\n                this._removeShapes(e.items);\n              }\n            } else if (e.action === \"itemchange\") {\n              if (this._shouldRefresh()) {\n                this._updateShapes(e.items, e.field);\n              }\n            } else if (e.action === \"add\") {\n              this._inactiveShapeItems.add(e.items);\n            } else if (e.action === \"sync\") {\n              this._syncShapes(e.items);\n            } else {\n              this.refresh();\n            }\n          },\n          _shouldRefresh: function () {\n            return !this._suspended;\n          },\n          _suspendModelRefresh: function () {\n            this._suspended = (this._suspended || 0) + 1;\n          },\n          _resumeModelRefresh: function () {\n            this._suspended = math.max((this._suspended || 0) - 1, 0);\n          },\n          refresh: function () {\n            this._loadingShapes = false;\n\n            if (!this._loadingConnections) {\n              this._rebindShapesAndConnections();\n            }\n          },\n          _rebindShapesAndConnections: function () {\n            this.clear();\n\n            this._addShapes(this.dataSource.view());\n\n            if (this.connectionsDataSource) {\n              this._addConnections(this.connectionsDataSource.view(), false);\n            }\n\n            if (this.options.layout) {\n              this.layout(this.options.layout);\n            } else {\n              this._redrawConnections();\n            }\n\n            this.trigger(\"dataBound\");\n          },\n          refreshConnections: function () {\n            this._loadingConnections = false;\n\n            if (!this._loadingShapes) {\n              this._rebindShapesAndConnections();\n            }\n          },\n          _redrawConnections: function () {\n            var connections = this.connections;\n\n            for (var idx = 0; idx < connections.length; idx++) {\n              connections[idx].refresh();\n            }\n          },\n          _removeShapes: function (items) {\n            var dataMap = this._dataMap;\n            var item, i;\n\n            for (i = 0; i < items.length; i++) {\n              item = items[i];\n\n              if (dataMap[item.id]) {\n                this.remove(dataMap[item.id], false);\n                dataMap[item.id] = null;\n              }\n            }\n          },\n          _syncShapes: function () {\n            var diagram = this;\n            var inactiveItems = diagram._inactiveShapeItems;\n            inactiveItems.forEach(function (inactiveItem) {\n              var dataItem = inactiveItem.dataItem;\n              var shape = inactiveItem.element;\n\n              if (!dataItem.isNew()) {\n                if (shape) {\n                  shape._setOptionsFromModel();\n\n                  diagram.addShape(shape, inactiveItem.undoable);\n                  diagram._dataMap[dataItem.id] = shape;\n                } else {\n                  diagram._addDataItem(dataItem);\n                }\n\n                inactiveItem.activate();\n                inactiveItems.remove(dataItem);\n              }\n            });\n          },\n          _updateShapes: function (items, field) {\n            for (var i = 0; i < items.length; i++) {\n              var dataItem = items[i];\n              var shape = this._dataMap[dataItem.id];\n\n              if (shape) {\n                shape.updateOptionsFromModel(dataItem, field);\n              }\n            }\n          },\n          _addShapes: function (dataItems) {\n            for (var i = 0; i < dataItems.length; i++) {\n              this._addDataItem(dataItems[i], false);\n            }\n          },\n          _refreshConnections: function (e) {\n            if (e.action === \"remove\") {\n              if (this._shouldRefresh()) {\n                this._removeConnections(e.items);\n              }\n            } else if (e.action === \"add\") {\n              this._addConnections(e.items);\n            } else if (e.action === \"sync\") {//TO DO: include logic to update the connections with different values returned from the server.\n            } else if (e.action === \"itemchange\") {\n              if (this._shouldRefresh()) {\n                this._updateConnections(e.items);\n              }\n            } else {\n              this.refreshConnections();\n            }\n          },\n          _removeConnections: function (items) {\n            for (var i = 0; i < items.length; i++) {\n              this.remove(this._connectionsDataMap[items[i].uid], false);\n              this._connectionsDataMap[items[i].uid] = null;\n            }\n          },\n          _updateConnections: function (items) {\n            for (var i = 0; i < items.length; i++) {\n              var dataItem = items[i];\n              var connection = this._connectionsDataMap[dataItem.uid];\n              connection.updateOptionsFromModel(dataItem);\n            }\n          },\n          _addConnections: function (connections, undoable) {\n            var length = connections.length;\n\n            for (var i = 0; i < length; i++) {\n              var dataItem = connections[i];\n\n              this._addConnectionDataItem(dataItem, undoable);\n            }\n          },\n          _addConnectionDataItem: function (dataItem, undoable) {\n            if (!this._connectionsDataMap[dataItem.uid]) {\n              var from = this._validateConnector(dataItem.from);\n\n              if (!defined(from) || from === null) {\n                from = new Point(dataItem.fromX, dataItem.fromY);\n              }\n\n              var to = this._validateConnector(dataItem.to);\n\n              if (!defined(to) || to === null) {\n                to = new Point(dataItem.toX, dataItem.toY);\n              }\n\n              if (defined(from) && defined(to)) {\n                var options = deepExtend({}, this.options.connectionDefaults);\n                options.dataItem = dataItem;\n                var connection = new Connection(from, to, options);\n                this._connectionsDataMap[dataItem.uid] = connection;\n                this.addConnection(connection, undoable);\n              }\n            }\n          },\n          _validateConnector: function (value) {\n            var connector;\n\n            if (defined(value) && value !== null) {\n              connector = this._dataMap[value];\n            }\n\n            return connector;\n          },\n          _treeDataSource: function () {\n            var that = this,\n                options = that.options,\n                dataSource = options.dataSource;\n            dataSource = isArray(dataSource) ? {\n              data: dataSource\n            } : dataSource;\n\n            if (dataSource instanceof kendo.data.DataSource && !(dataSource instanceof kendo.data.HierarchicalDataSource)) {\n              throw new Error(\"Incorrect DataSource type. If a single dataSource instance is set to the diagram then it should be a HierarchicalDataSource. You should set only the options instead of an instance or a HierarchicalDataSource instance or supply connectionsDataSource as well.\");\n            }\n\n            if (!dataSource.fields) {\n              dataSource.fields = [{\n                field: \"text\"\n              }, {\n                field: \"url\"\n              }, {\n                field: \"spriteCssClass\"\n              }, {\n                field: \"imageUrl\"\n              }];\n            }\n\n            if (that.dataSource && that._refreshHandler) {\n              that._unbindDataSource();\n            }\n\n            that._refreshHandler = that._refreshSource.bind(that);\n            that._errorHandler = that._error.bind(that);\n            that.dataSource = HierarchicalDataSource.create(dataSource).bind(CHANGE, that._refreshHandler).bind(ERROR, that._errorHandler);\n          },\n          _unbindDataSource: function () {\n            var that = this;\n            that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(ERROR, that._errorHandler);\n          },\n          _adorn: function (adorner, isActive) {\n            if (isActive !== undefined && adorner) {\n              if (isActive) {\n                this._adorners.push(adorner);\n\n                this.adornerLayer.append(adorner.visual);\n              } else {\n                Utils.remove(this._adorners, adorner);\n                this.adornerLayer.remove(adorner.visual);\n              }\n            }\n          },\n          _showConnectors: function (shape, value) {\n            if (value) {\n              this._connectorsAdorner.show(shape);\n            } else {\n              this._connectorsAdorner.destroy();\n            }\n          },\n          _updateAdorners: function () {\n            var adorners = this._adorners;\n\n            for (var i = 0; i < adorners.length; i++) {\n              var adorner = adorners[i];\n\n              if (adorner.refreshBounds) {\n                adorner.refreshBounds();\n              }\n\n              adorner.refresh();\n            }\n          },\n          _refresh: function () {\n            for (var i = 0; i < this.connections.length; i++) {\n              this.connections[i].refresh();\n            }\n          },\n          _destroyToolBar: function () {\n            if (this.singleToolBar) {\n              this.singleToolBar.hide();\n              this.singleToolBar.destroy();\n              this.singleToolBar = null;\n            }\n          },\n          _destroyGlobalToolBar: function () {\n            if (this.toolBar) {\n              this.toolBar.hide();\n              this.toolBar.destroy();\n              this.toolBar = null;\n            }\n          },\n          exportDOMVisual: function () {\n            var viewBox = this.canvas._viewBox;\n            var scrollOffset = geom.transform().translate(-viewBox.x, -viewBox.y);\n            var viewRect = new geom.Rect([0, 0], [viewBox.width, viewBox.height]);\n            var clipPath = draw.Path.fromRect(viewRect);\n            var wrap = new draw.Group({\n              transform: scrollOffset\n            });\n            var clipWrap = new draw.Group({\n              clip: clipPath\n            });\n            var root = this.canvas.drawingElement.children[0];\n            clipWrap.append(wrap); // Don't reparent the root\n\n            wrap.children.push(root);\n            return clipWrap;\n          },\n          exportVisual: function () {\n            var scale = geom.transform().scale(1 / this._zoom);\n            var wrap = new draw.Group({\n              transform: scale\n            });\n            var root = this.mainLayer.drawingElement;\n            wrap.children.push(root);\n            return wrap;\n          },\n          _syncChanges: function () {\n            this._syncShapeChanges();\n\n            this._syncConnectionChanges();\n          },\n          _syncShapeChanges: function () {\n            if (this.dataSource && this._isEditable) {\n              this.dataSource.sync();\n            }\n          },\n          _syncConnectionChanges: function () {\n            var that = this;\n\n            if (that.connectionsDataSource && that._isEditable) {\n              $.when.apply($, that._deferredConnectionUpdates).then(function () {\n                that.connectionsDataSource.sync();\n              });\n              that.deferredConnectionUpdates = [];\n            }\n          }\n        });\n        dataviz.ExportMixin.extend(Diagram.fn, true);\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(Diagram.fn);\n        }\n\n        function filterShapeDataItem(dataItem) {\n          var result = {};\n          dataItem = dataItem || {};\n\n          if (defined(dataItem.text) && dataItem.text !== null) {\n            result.text = dataItem.text;\n          }\n\n          if (defined(dataItem.x) && dataItem.x !== null) {\n            result.x = dataItem.x;\n          }\n\n          if (defined(dataItem.y) && dataItem.y !== null) {\n            result.y = dataItem.y;\n          }\n\n          if (defined(dataItem.width) && dataItem.width !== null) {\n            result.width = dataItem.width;\n          }\n\n          if (defined(dataItem.height) && dataItem.height !== null) {\n            result.height = dataItem.height;\n          }\n\n          if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n          }\n\n          return result;\n        }\n\n        function filterConnectionDataItem(dataItem) {\n          var result = {};\n          dataItem = dataItem || {};\n\n          if (defined(dataItem.text) && dataItem.text !== null) {\n            result.content = dataItem.text;\n          }\n\n          if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n          }\n\n          if (defined(dataItem.from) && dataItem.from !== null) {\n            result.from = dataItem.from;\n          }\n\n          if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n            result.fromConnector = dataItem.fromConnector;\n          }\n\n          if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n            result.fromX = dataItem.fromX;\n          }\n\n          if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n            result.fromY = dataItem.fromY;\n          }\n\n          if (defined(dataItem.to) && dataItem.to !== null) {\n            result.to = dataItem.to;\n          }\n\n          if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n            result.toConnector = dataItem.toConnector;\n          }\n\n          if (defined(dataItem.toX) && dataItem.toX !== null) {\n            result.toX = dataItem.toX;\n          }\n\n          if (defined(dataItem.toY) && dataItem.toY !== null) {\n            result.toY = dataItem.toY;\n          }\n\n          return result;\n        }\n\n        var DiagramToolBar = kendo.Observable.extend({\n          init: function (diagram, options) {\n            kendo.Observable.fn.init.call(this);\n            this.diagram = diagram;\n            this.options = deepExtend({}, this.options, options);\n            this._tools = [];\n            this.createToolBar();\n            this.createTools();\n            this.appendTools();\n\n            if (this.options.modal) {\n              this.createPopup();\n            }\n\n            this.bind(this.events, options);\n          },\n          events: [\"click\"],\n          createPopup: function () {\n            this.container = $(\"<div/>\").append(this.element);\n            this._popup = this.container.kendoPopup({}).getKendoPopup();\n          },\n          appendTools: function () {\n            for (var i = 0; i < this._tools.length; i++) {\n              var tool = this._tools[i];\n\n              if (tool.buttons && tool.buttons.length || !defined(tool.buttons)) {\n                this._toolBar.add(tool);\n              }\n            }\n          },\n          createToolBar: function () {\n            this.element = $(\"<div/>\");\n            this._toolBar = this.element.kendoToolBar({\n              click: this.click.bind(this),\n              resizable: false\n            }).getKendoToolBar();\n            this.element.css(\"border\", \"none\");\n          },\n          createTools: function () {\n            for (var i = 0; i < this.options.tools.length; i++) {\n              this.createTool(this.options.tools[i]);\n            }\n          },\n          createTool: function (tool) {\n            if (!isPlainObject(tool)) {\n              tool = {\n                name: tool\n              };\n            }\n\n            var toolName = tool.name + \"Tool\";\n\n            if (this[toolName]) {\n              this[toolName](tool);\n            } else {\n              this._tools.push(deepExtend({}, tool, {\n                attributes: this._setAttributes({\n                  action: tool.name\n                })\n              }));\n            }\n          },\n          showAt: function (point) {\n            var popupZIndex = parseInt(this.options.popupZIndex, 10);\n\n            if (this._popup) {\n              this._popup.open(point.x, point.y);\n\n              if (popupZIndex) {\n                this._popup.wrapper.css(\"zIndex\", popupZIndex);\n              }\n            }\n          },\n          hide: function () {\n            if (this._popup) {\n              this._popup.close();\n            }\n          },\n          newGroup: function () {\n            return {\n              type: \"buttonGroup\",\n              buttons: []\n            };\n          },\n          editTool: function () {\n            this._tools.push({\n              icon: \"edit\",\n              showText: \"overflow\",\n              type: \"button\",\n              text: \"Edit\",\n              attributes: this._setAttributes({\n                action: \"edit\"\n              })\n            });\n          },\n          deleteTool: function () {\n            this._tools.push({\n              icon: \"close\",\n              showText: \"overflow\",\n              type: \"button\",\n              text: \"Delete\",\n              attributes: this._setAttributes({\n                action: \"delete\"\n              })\n            });\n          },\n          rotateAnticlockwiseTool: function (options) {\n            this._appendGroup(\"rotate\");\n\n            this._rotateGroup.buttons.push({\n              icon: \"rotate-left\",\n              showText: \"overflow\",\n              text: \"RotateAnticlockwise\",\n              group: \"rotate\",\n              attributes: this._setAttributes({\n                action: \"rotateAnticlockwise\",\n                step: options.step\n              })\n            });\n          },\n          rotateClockwiseTool: function (options) {\n            this._appendGroup(\"rotate\");\n\n            this._rotateGroup.buttons.push({\n              icon: \"rotate-right\",\n              attributes: this._setAttributes({\n                action: \"rotateClockwise\",\n                step: options.step\n              }),\n              showText: \"overflow\",\n              text: \"RotateClockwise\",\n              group: \"rotate\"\n            });\n          },\n          createShapeTool: function () {\n            this._appendGroup(\"create\");\n\n            this._createGroup.buttons.push({\n              icon: \"shape\",\n              showText: \"overflow\",\n              text: \"CreateShape\",\n              group: \"create\",\n              attributes: this._setAttributes({\n                action: \"createShape\"\n              })\n            });\n          },\n          createConnectionTool: function () {\n            this._appendGroup(\"create\");\n\n            this._createGroup.buttons.push({\n              icon: \"connector\",\n              showText: \"overflow\",\n              text: \"CreateConnection\",\n              group: \"create\",\n              attributes: this._setAttributes({\n                action: \"createConnection\"\n              })\n            });\n          },\n          undoTool: function () {\n            this._appendGroup(\"history\");\n\n            this._historyGroup.buttons.push({\n              icon: \"undo\",\n              showText: \"overflow\",\n              text: \"Undo\",\n              group: \"history\",\n              attributes: this._setAttributes({\n                action: \"undo\"\n              })\n            });\n          },\n          redoTool: function () {\n            this._appendGroup(\"history\");\n\n            this._historyGroup.buttons.push({\n              icon: \"redo\",\n              showText: \"overflow\",\n              text: \"Redo\",\n              group: \"history\",\n              attributes: this._setAttributes({\n                action: \"redo\"\n              })\n            });\n          },\n          _appendGroup: function (name) {\n            var prop = \"_\" + name + \"Group\";\n\n            if (!this[prop]) {\n              this[prop] = this.newGroup();\n\n              this._tools.push(this[prop]);\n            }\n          },\n          _setAttributes: function (attributes) {\n            var attr = {};\n\n            if (attributes.action) {\n              attr[kendo.attr(\"action\")] = attributes.action;\n            }\n\n            if (attributes.step) {\n              attr[kendo.attr(\"step\")] = attributes.step;\n            }\n\n            return attr;\n          },\n          _getAttributes: function (element) {\n            var attr = {};\n            var action = element.attr(kendo.attr(\"action\"));\n\n            if (action) {\n              attr.action = action;\n            }\n\n            var step = element.attr(kendo.attr(\"step\"));\n\n            if (step) {\n              attr.step = step;\n            }\n\n            return attr;\n          },\n          click: function (e) {\n            var attributes = this._getAttributes($(e.target));\n\n            var action = attributes.action;\n\n            if (action && this[action]) {\n              this[action](attributes);\n            }\n\n            this.trigger(\"click\", this.eventData(action, e.target));\n          },\n          eventData: function (action, target) {\n            var elements = this.selectedElements(),\n                length = elements.length,\n                shapes = [],\n                connections = [],\n                element;\n\n            for (var idx = 0; idx < length; idx++) {\n              element = elements[idx];\n\n              if (element instanceof Shape) {\n                shapes.push(element);\n              } else {\n                connections.push(element);\n              }\n            }\n\n            return {\n              shapes: shapes,\n              connections: connections,\n              action: action,\n              target: target\n            };\n          },\n          \"delete\": function () {\n            var diagram = this.diagram;\n\n            var toRemove = diagram._triggerRemove(this.selectedElements());\n\n            if (toRemove.length) {\n              this.diagram.remove(toRemove, true);\n\n              this.diagram._syncChanges();\n            }\n          },\n          edit: function () {\n            var selectedElemens = this.selectedElements();\n\n            if (selectedElemens.length === 1) {\n              this.diagram.edit(selectedElemens[0]);\n            }\n          },\n          rotateClockwise: function (options) {\n            var angle = parseFloat(options.step || 90);\n\n            this._rotate(angle);\n          },\n          rotateAnticlockwise: function (options) {\n            var angle = parseFloat(options.step || 90);\n\n            this._rotate(-angle);\n          },\n          _rotate: function (angle) {\n            var adorner = this.diagram._resizingAdorner;\n            adorner.angle(adorner.angle() + angle);\n            adorner.rotate();\n          },\n          selectedElements: function () {\n            return this.diagram.select();\n          },\n          createShape: function () {\n            this.diagram.createShape();\n          },\n          createConnection: function () {\n            this.diagram.createConnection();\n          },\n          undo: function () {\n            this.diagram.undo();\n          },\n          redo: function () {\n            this.diagram.redo();\n          },\n          destroy: function () {\n            this.diagram = null;\n            this.element = null;\n            this.options = null;\n\n            if (this._toolBar) {\n              this._toolBar.destroy();\n            }\n\n            if (this._popup) {\n              this._popup.destroy();\n            }\n          }\n        });\n        var Editor = kendo.Observable.extend({\n          init: function (element, options) {\n            kendo.Observable.fn.init.call(this);\n            this.options = extend(true, {}, this.options, options);\n            this.element = element;\n            this.model = this.options.model;\n            this.fields = this._getFields();\n\n            this._initContainer();\n\n            this.createEditable();\n          },\n          options: {\n            editors: {}\n          },\n          _initContainer: function () {\n            this.wrapper = this.element;\n          },\n          createEditable: function () {\n            var options = this.options;\n            this.editable = new kendo.ui.Editable(this.wrapper, {\n              fields: this.fields,\n              target: options.target,\n              clearContainer: false,\n              model: this.model\n            });\n          },\n          _isEditable: function (field) {\n            return this.model.editable && this.model.editable(field);\n          },\n          _getFields: function () {\n            var fields = [];\n            var modelFields = this.model.fields;\n\n            for (var field in modelFields) {\n              var result = {};\n\n              if (this._isEditable(field)) {\n                var editor = this.options.editors[field];\n\n                if (editor) {\n                  result.editor = editor;\n                }\n\n                result.field = field;\n                fields.push(result);\n              }\n            }\n\n            return fields;\n          },\n          end: function () {\n            return this.editable.end();\n          },\n          destroy: function () {\n            this.editable.destroy();\n            this.editable.element.find(\"[\" + kendo.attr(\"container-for\") + \"]\").empty();\n            this.model = this.wrapper = this.element = this.columns = this.editable = null;\n          }\n        });\n        var PopupEditor = Editor.extend({\n          init: function (element, options) {\n            Editor.fn.init.call(this, element, options);\n            this.bind(this.events, this.options);\n            this.open();\n          },\n          events: [\"update\", \"cancel\"],\n          options: {\n            window: {\n              modal: true,\n              resizable: false,\n              draggable: true,\n              title: \"Edit\",\n              visible: false\n            }\n          },\n          _initContainer: function () {\n            var that = this;\n            this.wrapper = $('<div class=\"k-popup-edit-form\"/>').attr(kendo.attr(\"uid\"), this.model.uid);\n            var formContent = \"\";\n\n            if (this.options.template) {\n              formContent += this._renderTemplate();\n              this.fields = [];\n            } else {\n              formContent += this._renderFields();\n            }\n\n            formContent += this._renderButtons();\n            this.wrapper.append($('<div class=\"k-edit-form-container\"/>').append(formContent));\n            this.window = new kendo.ui.Window(this.wrapper.appendTo(this.element), this.options.window);\n            this.window.bind(\"close\", function (e) {\n              //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n              if (e.userTriggered) {\n                e.sender.element.trigger(\"focus\");\n\n                that._cancelClick(e);\n              }\n            });\n\n            this._attachButtonEvents();\n          },\n          _renderTemplate: function () {\n            var template = this.options.template;\n\n            if (typeof template === \"string\") {\n              template = kendo.unescape(template);\n            }\n\n            template = kendo.template(template)(this.model);\n            return template;\n          },\n          _renderFields: function () {\n            var form = \"\";\n\n            for (var i = 0; i < this.fields.length; i++) {\n              var field = this.fields[i];\n              form += '<div class=\"k-edit-label\"><label for=\"' + field.field + '\">' + (field.field || \"\") + '</label></div>';\n\n              if (this._isEditable(field.field)) {\n                form += '<div ' + kendo.attr(\"container-for\") + '=\"' + field.field + '\" class=\"k-edit-field\"></div>';\n              }\n            }\n\n            return form;\n          },\n          _renderButtons: function () {\n            var form = '<div class=\"k-edit-buttons\">';\n            form += this._createButton(\"update\");\n            form += this._createButton(\"cancel\");\n            form += '</div>';\n            return form;\n          },\n          _createButton: function (name) {\n            return kendo.template(BUTTON_TEMPLATE)(defaultButtons[name]);\n          },\n          _attachButtonEvents: function () {\n            this._cancelClickHandler = this._cancelClick.bind(this);\n            this.window.element.on(CLICK + NS, \"a.k-diagram-cancel\", this._cancelClickHandler);\n            this._updateClickHandler = this._updateClick.bind(this);\n            this.window.element.on(CLICK + NS, \"a.k-diagram-update\", this._updateClickHandler);\n          },\n          _updateClick: function (e) {\n            e.preventDefault();\n            this.trigger(\"update\");\n          },\n          _cancelClick: function (e) {\n            e.preventDefault();\n            this.trigger(\"cancel\");\n          },\n          open: function () {\n            this.window.center().open();\n          },\n          close: function () {\n            this.window.bind(\"deactivate\", this.destroy.bind(this)).close();\n          },\n          destroy: function () {\n            this.window.close().destroy();\n            this.window.element.off(CLICK + NS, \"a.k-diagram-cancel\", this._cancelClickHandler);\n            this.window.element.off(CLICK + NS, \"a.k-diagram-update\", this._updateClickHandler);\n            this._cancelClickHandler = null;\n            this._editUpdateClickHandler = null;\n            this.window = null;\n            Editor.fn.destroy.call(this);\n          }\n        });\n\n        function connectionSelector(container, options) {\n          var model = this.dataSource.reader.model;\n\n          if (model) {\n            var textField = model.fn.fields.text ? \"text\" : model.idField;\n            $(\"<input name='\" + options.field + \"' />\").appendTo(container).kendoDropDownList({\n              dataValueField: model.idField,\n              dataTextField: textField,\n              dataSource: this.dataSource.data().toJSON(),\n              optionLabel: \" \",\n              valuePrimitive: true\n            });\n          }\n        }\n\n        function InactiveItem(dataItem) {\n          this.dataItem = dataItem;\n          this.callbacks = [];\n        }\n\n        InactiveItem.fn = InactiveItem.prototype = {\n          onActivate: function (callback) {\n            var deffered = $.Deferred();\n            this.callbacks.push({\n              callback: callback,\n              deferred: deffered\n            });\n            return deffered;\n          },\n          activate: function () {\n            var callbacks = this.callbacks;\n            var item;\n\n            for (var idx = 0; idx < callbacks.length; idx++) {\n              item = this.callbacks[idx];\n              item.callback(this.dataItem);\n              item.deferred.resolve();\n            }\n\n            this.callbacks = [];\n          }\n        };\n\n        function InactiveItemsCollection() {\n          this.items = {};\n        }\n\n        InactiveItemsCollection.fn = InactiveItemsCollection.prototype = {\n          add: function (items) {\n            for (var idx = 0; idx < items.length; idx++) {\n              this.items[items[idx].uid] = new InactiveItem(items[idx]);\n            }\n          },\n          forEach: function (callback) {\n            for (var uid in this.items) {\n              callback(this.items[uid]);\n            }\n          },\n          getByUid: function (uid) {\n            return this.items[uid];\n          },\n          remove: function (item) {\n            delete this.items[item.uid];\n          }\n        };\n        var QuadRoot = Class.extend({\n          init: function () {\n            this.shapes = [];\n          },\n          _add: function (shape, bounds) {\n            this.shapes.push({\n              bounds: bounds,\n              shape: shape\n            });\n            shape._quadNode = this;\n          },\n          insert: function (shape, bounds) {\n            this._add(shape, bounds);\n          },\n          remove: function (shape) {\n            var shapes = this.shapes;\n            var length = shapes.length;\n\n            for (var idx = 0; idx < length; idx++) {\n              if (shapes[idx].shape === shape) {\n                shapes.splice(idx, 1);\n                break;\n              }\n            }\n          },\n          hitTestRect: function (rect, exclude) {\n            var shapes = this.shapes;\n            var length = shapes.length;\n\n            for (var i = 0; i < length; i++) {\n              if (this._testRect(shapes[i].shape, rect) && !dataviz.inArray(shapes[i].shape, exclude)) {\n                return true;\n              }\n            }\n          },\n          _testRect: function (shape, rect) {\n            var angle = shape.rotate().angle;\n            var bounds = shape.bounds();\n            var hit;\n\n            if (!angle) {\n              hit = bounds.overlaps(rect);\n            } else {\n              hit = Intersect.rects(rect, bounds, -angle);\n            }\n\n            return hit;\n          }\n        });\n        var QuadNode = QuadRoot.extend({\n          init: function (rect) {\n            QuadRoot.fn.init.call(this);\n            this.children = [];\n            this.rect = rect;\n          },\n          inBounds: function (rect) {\n            var nodeRect = this.rect;\n            var nodeBottomRight = nodeRect.bottomRight();\n            var bottomRight = rect.bottomRight();\n            var inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;\n            return inBounds;\n          },\n          overlapsBounds: function (rect) {\n            return this.rect.overlaps(rect);\n          },\n          insert: function (shape, bounds) {\n            var inserted = false;\n            var children = this.children;\n            var length = children.length;\n\n            if (this.inBounds(bounds)) {\n              if (!length && this.shapes.length < 4) {\n                this._add(shape, bounds);\n              } else {\n                if (!length) {\n                  this._initChildren();\n                }\n\n                for (var idx = 0; idx < children.length; idx++) {\n                  if (children[idx].insert(shape, bounds)) {\n                    inserted = true;\n                    break;\n                  }\n                }\n\n                if (!inserted) {\n                  this._add(shape, bounds);\n                }\n              }\n\n              inserted = true;\n            }\n\n            return inserted;\n          },\n          _initChildren: function () {\n            var rect = this.rect,\n                children = this.children,\n                shapes = this.shapes,\n                center = rect.center(),\n                halfWidth = rect.width / 2,\n                halfHeight = rect.height / 2,\n                childIdx,\n                shapeIdx;\n            children.push(new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight)));\n\n            for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n              for (childIdx = 0; childIdx < children.length; childIdx++) {\n                if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                  shapes.splice(shapeIdx, 1);\n                  break;\n                }\n              }\n            }\n          },\n          hitTestRect: function (rect, exclude) {\n            var idx;\n            var children = this.children;\n            var length = children.length;\n            var hit = false;\n\n            if (this.overlapsBounds(rect)) {\n              if (QuadRoot.fn.hitTestRect.call(this, rect, exclude)) {\n                hit = true;\n              } else {\n                for (idx = 0; idx < length; idx++) {\n                  if (children[idx].hitTestRect(rect, exclude)) {\n                    hit = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            return hit;\n          }\n        });\n        var ShapesQuadTree = Class.extend({\n          ROOT_SIZE: 1000,\n          init: function (diagram) {\n            var boundsChangeHandler = this._boundsChange.bind(this);\n\n            diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n            diagram.bind(ITEMROTATE, boundsChangeHandler);\n            this.initRoots();\n          },\n          initRoots: function () {\n            this.rootMap = {};\n            this.root = new QuadRoot();\n          },\n          clear: function () {\n            this.initRoots();\n          },\n          _boundsChange: function (e) {\n            if (e.item._quadNode) {\n              e.item._quadNode.remove(e.item);\n            }\n\n            this.insert(e.item);\n          },\n          insert: function (shape) {\n            var bounds = shape.bounds(ROTATED);\n            var rootSize = this.ROOT_SIZE;\n            var sectors = this.getSectors(bounds);\n            var x = sectors[0][0];\n            var y = sectors[1][0];\n\n            if (this.inRoot(sectors)) {\n              this.root.insert(shape, bounds);\n            } else {\n              if (!this.rootMap[x]) {\n                this.rootMap[x] = {};\n              }\n\n              if (!this.rootMap[x][y]) {\n                this.rootMap[x][y] = new QuadNode(new Rect(x * rootSize, y * rootSize, rootSize, rootSize));\n              }\n\n              this.rootMap[x][y].insert(shape, bounds);\n            }\n          },\n          remove: function (shape) {\n            if (shape._quadNode) {\n              shape._quadNode.remove(shape);\n            }\n          },\n          inRoot: function (sectors) {\n            return sectors[0].length > 1 || sectors[1].length > 1;\n          },\n          getSectors: function (rect) {\n            var rootSize = this.ROOT_SIZE;\n            var bottomRight = rect.bottomRight();\n            var bottomX = math.floor(bottomRight.x / rootSize);\n            var bottomY = math.floor(bottomRight.y / rootSize);\n            var sectors = [[], []];\n\n            for (var x = math.floor(rect.x / rootSize); x <= bottomX; x++) {\n              sectors[0].push(x);\n            }\n\n            for (var y = math.floor(rect.y / rootSize); y <= bottomY; y++) {\n              sectors[1].push(y);\n            }\n\n            return sectors;\n          },\n          hitTestRect: function (rect, exclude) {\n            var sectors = this.getSectors(rect);\n            var xIdx, yIdx, x, y;\n            var root;\n\n            if (this.root.hitTestRect(rect, exclude)) {\n              return true;\n            }\n\n            for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n              x = sectors[0][xIdx];\n\n              for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                y = sectors[1][yIdx];\n                root = (this.rootMap[x] || {})[y];\n\n                if (root && root.hitTestRect(rect, exclude)) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          }\n        });\n\n        function cloneDataItem(dataItem) {\n          var result = dataItem;\n\n          if (dataItem instanceof kendo.data.Model) {\n            result = dataItem.toJSON();\n            result[dataItem.idField] = dataItem._defaultId;\n          }\n\n          return result;\n        }\n\n        function splitDiagramElements(elements) {\n          var connections = [];\n          var shapes = [];\n          var element, idx;\n\n          for (idx = 0; idx < elements.length; idx++) {\n            element = elements[idx];\n\n            if (element instanceof Shape) {\n              shapes.push(element);\n            } else {\n              connections.push(element);\n            }\n          }\n\n          return {\n            shapes: shapes,\n            connections: connections\n          };\n        }\n\n        function createModel(dataSource, model) {\n          if (dataSource.reader.model) {\n            return new dataSource.reader.model(model);\n          }\n\n          return new kendo.data.ObservableObject(model);\n        }\n\n        function clearField(field, model) {\n          if (defined(model[field])) {\n            model.set(field, null);\n          }\n        }\n\n        function copyDefaultOptions(mainOptions, elementOptions, fields) {\n          var field;\n\n          for (var idx = 0; idx < fields.length; idx++) {\n            field = fields[idx];\n\n            if (elementOptions && !defined(elementOptions[field])) {\n              elementOptions[field] = mainOptions[field];\n            }\n          }\n        }\n\n        function translateToOrigin(visual) {\n          var bbox = visual.drawingContainer().clippedBBox(null);\n\n          if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n            visual.position(-bbox.origin.x, -bbox.origin.y);\n          }\n        }\n\n        function preventDefault(e) {\n          e.preventDefault();\n        }\n\n        dataviz.ui.plugin(Diagram);\n        deepExtend(diagram, {\n          Shape: Shape,\n          Connection: Connection,\n          Connector: Connector,\n          DiagramToolBar: DiagramToolBar,\n          QuadNode: QuadNode,\n          QuadRoot: QuadRoot,\n          ShapesQuadTree: ShapesQuadTree,\n          PopupEditor: PopupEditor\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  902:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.draganddrop\");\n    /***/\n  },\n\n  /***/\n  903:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.toolbar\");\n    /***/\n  },\n\n  /***/\n  904:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.editable\");\n    /***/\n  },\n\n  /***/\n  905:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.window\");\n    /***/\n  },\n\n  /***/\n  906:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dropdownlist\");\n    /***/\n  },\n\n  /***/\n  907:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./svg\");\n    /***/\n  },\n\n  /***/\n  908:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./services\");\n    /***/\n  },\n\n  /***/\n  909:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./layout\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}