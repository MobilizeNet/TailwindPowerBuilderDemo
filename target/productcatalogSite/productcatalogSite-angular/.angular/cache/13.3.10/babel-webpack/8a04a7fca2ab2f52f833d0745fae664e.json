{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1716);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1716:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        var Property = kendo.Class.extend({\n          init: function (list) {\n            this.list = list;\n          },\n          get: function (index) {\n            return this.parse(this.list.value(index, index));\n          },\n          set: function (start, end, value) {\n            if (value === undefined) {\n              value = end;\n              end = start;\n            }\n\n            this.list.value(start, end, value);\n          },\n          parse: function (value) {\n            return value;\n          },\n          copy: function (start, end, dst) {\n            this.list.copy(start, end, dst);\n          },\n          iterator: function (start, end) {\n            return this.list.iterator(start, end);\n          }\n        });\n        var JsonProperty = Property.extend({\n          set: function (start, end, value) {\n            this.list.value(start, end, JSON.stringify(value));\n          },\n          parse: function (value) {\n            return JSON.parse(value);\n          }\n        });\n        var ValueProperty = Property.extend({\n          init: function (values, formats) {\n            Property.prototype.init.call(this, values);\n            this.formats = formats;\n          },\n          set: function (start, end, value) {\n            if (value instanceof Date) {\n              value = kendo.spreadsheet.dateToNumber(value);\n\n              if (!this.formats.value(start, end)) {\n                this.formats.value(start, end, toExcelFormat(kendo.culture().calendar.patterns.d));\n              }\n            } else if (typeof value == \"number\") {\n              value = kendo.spreadsheet.calc.runtime.limitPrecision(value);\n            }\n\n            this.list.value(start, end, value);\n          }\n        });\n\n        function toExcelFormat(format) {\n          return format.replace(/M/g, \"m\").replace(/'/g, '\"').replace(/tt/, \"am/pm\");\n        }\n\n        kendo.spreadsheet.PropertyBag = kendo.Class.extend({\n          specs: [{\n            property: Property,\n            name: \"format\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: ValueProperty,\n            name: \"value\",\n            value: null,\n            sortable: true,\n            serializable: true,\n            depends: \"format\"\n          }, {\n            property: Property,\n            name: \"formula\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"background\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: JsonProperty,\n            name: \"vBorders\",\n            value: null,\n            sortable: false,\n            serializable: false\n          }, {\n            property: JsonProperty,\n            name: \"hBorders\",\n            value: null,\n            sortable: false,\n            serializable: false\n          }, {\n            property: Property,\n            name: \"color\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"fontFamily\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"underline\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"fontSize\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"italic\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"bold\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"textAlign\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"indent\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"verticalAlign\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"wrap\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"validation\",\n            value: null,\n            sortable: false,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"enable\",\n            value: null,\n            sortable: false,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"link\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"editor\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"comment\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }, {\n            property: Property,\n            name: \"html\",\n            value: null,\n            sortable: true,\n            serializable: true\n          }],\n          init: function (rowCount, columnCount, defaultValues) {\n            defaultValues = defaultValues || {};\n            var cellCount = rowCount * columnCount - 1;\n            this.rowCount = rowCount;\n            this.columnCount = columnCount;\n            this.cellCount = cellCount;\n            this.properties = {};\n            this.lists = {};\n            this.specs.forEach(function (spec) {\n              var name = spec.name;\n              var value = defaultValues[name];\n\n              if (value === undefined) {\n                value = spec.value;\n              }\n\n              this.lists[name] = new kendo.spreadsheet.SparseRangeList(0, cellCount, value);\n              var prop = this.properties[name] = new spec.property(this.lists[name], this.lists[spec.depends]);\n              prop.spec = spec;\n            }, this); // XXX: this is a hack but I have no better ideas at this\n            // point.  The getState() method in a SparseRangeList\n            // clones the tree (which just copies values over), but\n            // formulas are objects maintaining complex state.\n            // https://github.com/telerik/kendo-ui-core/issues/2816\n\n            this.lists.formula.tree.clone = cloneFormulaTree;\n            this.lists.validation.tree.clone = cloneFormulaTree;\n          },\n          _resize: function (new_rows, new_cols) {\n            var self = this;\n            var old_rows = self.rowCount;\n            var cell_count = new_rows * new_cols - 1;\n\n            function scaleIndex(index) {\n              var col = index / old_rows | 0;\n              var row = index % old_rows;\n              return col * new_rows + row;\n            }\n\n            function scaleNode(node) {\n              // node is a ValueRange from rangelist.js\n              // start/end are rowCount * col + row\n              node.start = scaleIndex(node.start);\n              node.end = scaleIndex(node.end);\n            }\n\n            Object.keys(self.lists).forEach(function (name) {\n              var list = self.lists[name];\n\n              if (new_rows != old_rows) {\n                list.forEach(scaleNode);\n              }\n\n              list.range.end = cell_count;\n            });\n            self.rowCount = new_rows;\n            self.columnCount = new_cols;\n            self.cellCount = cell_count;\n          },\n          getState: function () {\n            var state = {};\n            this.specs.forEach(function (spec) {\n              state[spec.name] = this.lists[spec.name].getState();\n            }, this);\n            return state;\n          },\n          setState: function (state) {\n            this.specs.forEach(function (spec) {\n              this.lists[spec.name].setState(state[spec.name]);\n            }, this);\n          },\n          get: function (name, index) {\n            if (index === undefined) {\n              return this.lists[name];\n            }\n\n            switch (name) {\n              case \"borderRight\":\n                index += this.rowCount;\n\n              /* falls through */\n\n              case \"borderLeft\":\n                name = \"vBorders\";\n                break;\n\n              case \"borderBottom\":\n                index++;\n\n              /* falls through */\n\n              case \"borderTop\":\n                name = \"hBorders\";\n                break;\n            }\n\n            return index > this.cellCount ? null : this.properties[name].get(index);\n          },\n          set: function (name, start, end, value) {\n            switch (name) {\n              case \"borderRight\":\n                start += this.rowCount;\n                end += this.rowCount;\n\n              /* falls through */\n\n              case \"borderLeft\":\n                name = \"vBorders\";\n                break;\n\n              case \"borderBottom\":\n                start++;\n                end++;\n\n              /* falls through */\n\n              case \"borderTop\":\n                name = \"hBorders\";\n                break;\n            }\n\n            if (start <= end && end <= this.cellCount) {\n              this.properties[name].set(start, end, value);\n            }\n          },\n          fromJSON: function (index, value) {\n            for (var si = 0; si < this.specs.length; si++) {\n              var spec = this.specs[si];\n\n              if (spec.serializable) {\n                if (value[spec.name] !== undefined) {\n                  this.set(spec.name, index, index, value[spec.name], false);\n                }\n              }\n            }\n\n            [\"borderLeft\", \"borderRight\", \"borderTop\", \"borderBottom\"].forEach(function (b) {\n              if (value[b] !== undefined) {\n                this.set(b, index, index, value[b]);\n              }\n            }, this);\n          },\n          copy: function (sourceStart, sourceEnd, targetStart) {\n            this.specs.forEach(function (spec) {\n              this.properties[spec.name].copy(sourceStart, sourceEnd, targetStart);\n            }, this);\n          },\n          iterator: function (name, start, end) {\n            var prop = this.properties[name];\n            var iter = prop.iterator(start, end),\n                at = iter.at;\n            var cellCount = this.cellCount;\n\n            iter.at = function (index) {\n              return index > cellCount ? null : prop.parse(at.call(iter, index));\n            };\n\n            iter.name = name;\n            iter.value = prop.spec.value;\n            return iter;\n          },\n          sortable: function () {\n            return this.specs.filter(function (spec) {\n              return spec.sortable;\n            }).map(function (spec) {\n              return this.lists[spec.name];\n            }, this);\n          },\n          iterators: function (start, end) {\n            return this.specs.reduce(function (ret, spec) {\n              if (spec.serializable) {\n                ret.push(this.iterator(spec.name, start, end));\n              }\n\n              return ret;\n            }.bind(this), []);\n          },\n          forEach: function (start, end, callback) {\n            var iterators = this.iterators(start, end);\n            var hBorders = this.iterator(\"hBorders\", start, end + 1);\n            var leftBorders = this.iterator(\"vBorders\", start, end);\n            var rightBorders = this.iterator(\"vBorders\", start + this.rowCount, end + this.rowCount);\n            var values, index;\n\n            function addBorder(name, iterator, index) {\n              var val = iterator.at(index);\n\n              if (val !== iterator.value) {\n                values[name] = val;\n              }\n            }\n\n            for (index = start; index <= end; index++) {\n              values = {};\n\n              for (var i = 0; i < iterators.length; i++) {\n                var iterator = iterators[i];\n                var value = iterator.at(index);\n\n                if (value !== iterator.value) {\n                  values[iterator.name] = value;\n                }\n              }\n\n              addBorder(\"borderLeft\", leftBorders, index);\n              addBorder(\"borderRight\", rightBorders, index + this.rowCount);\n              addBorder(\"borderTop\", hBorders, index);\n\n              if ((index + 1) % this.rowCount) {\n                addBorder(\"borderBottom\", hBorders, index + 1);\n              }\n\n              callback(values);\n            }\n          },\n          forEachProperty: function (callback) {\n            for (var name in this.properties) {\n              callback(this.properties[name]);\n            }\n          }\n        });\n\n        function cloneFormulaValue(x) {\n          x = x.clone();\n          x.value = x.value.deepClone(); // x.value is Formula or Validation\n\n          return x;\n        }\n\n        function cloneFormulaTree() {\n          var tree = this.map(cloneFormulaValue);\n          tree.clone = cloneFormulaTree; // because it's a new RangeTree now\n\n          return tree;\n        }\n\n        kendo.spreadsheet.ALL_PROPERTIES = kendo.spreadsheet.PropertyBag.prototype.specs.reduce(function (a, spec) {\n          if (spec.serializable) {\n            a.push(spec.name);\n          }\n\n          return a;\n        }, [\"borderTop\", \"borderRight\", \"borderBottom\", \"borderLeft\"]);\n      })(window.kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}