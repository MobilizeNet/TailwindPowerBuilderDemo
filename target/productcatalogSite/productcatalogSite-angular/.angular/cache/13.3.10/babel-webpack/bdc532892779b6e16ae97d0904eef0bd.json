{"ast":null,"code":"import { Chart } from '../chart';\nimport { BAR, BULLET, PIE, COLUMN, VERTICAL_BULLET } from '../chart/constants';\nimport { addClass, deepExtend, elementSize, getSpacing, inArray, isArray, isNumber, setDefaultOptions } from '../common';\nimport SharedTooltip from './shared-tooltip';\nconst DEAULT_BAR_WIDTH = 150;\nconst DEAULT_BULLET_WIDTH = 150;\nconst NO_CROSSHAIR = [BAR, BULLET];\n\nfunction hide(children) {\n  const state = [];\n\n  for (let idx = 0; idx < children.length; idx++) {\n    const child = children[idx];\n    state[idx] = child.style.display;\n    child.style.display = \"none\";\n  }\n\n  return state;\n}\n\nfunction show(children, state) {\n  for (let idx = 0; idx < children.length; idx++) {\n    children[idx].style.display = state[idx];\n  }\n}\n\nfunction wrapNumber(value) {\n  return isNumber(value) ? [value] : value;\n}\n\nclass Sparkline extends Chart {\n  _setElementClass(element) {\n    addClass(element, 'k-sparkline');\n  }\n\n  _initElement(element) {\n    super._initElement(element);\n\n    this._initialWidth = Math.floor(elementSize(element).width);\n  }\n\n  _resize() {\n    const element = this.element;\n    const state = hide(element.childNodes);\n    this._initialWidth = Math.floor(elementSize(element).width);\n    show(element.childNodes, state);\n\n    super._resize();\n  }\n\n  _modelOptions() {\n    const chartOptions = this.options;\n\n    const stage = this._surfaceWrap();\n\n    const displayState = hide(stage.childNodes);\n    const space = document.createElement('span');\n    space.innerHTML = '&nbsp;';\n    stage.appendChild(space);\n    const options = deepExtend({\n      width: this._autoWidth,\n      height: elementSize(stage).height,\n      transitions: chartOptions.transitions\n    }, chartOptions.chartArea, {\n      inline: true,\n      align: false\n    });\n    elementSize(stage, {\n      width: options.width,\n      height: options.height\n    });\n    stage.removeChild(space);\n    show(stage.childNodes, displayState);\n\n    if (this.surface) {\n      this.surface.resize();\n    }\n\n    return options;\n  }\n\n  _surfaceWrap() {\n    if (!this.stage) {\n      const stage = this.stage = document.createElement('span');\n      this.element.appendChild(stage);\n    }\n\n    return this.stage;\n  }\n\n  _createPlotArea(skipSeries) {\n    const plotArea = super._createPlotArea(skipSeries);\n\n    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);\n    return plotArea;\n  }\n\n  _calculateWidth(plotArea) {\n    const options = this.options;\n    const margin = getSpacing(options.chartArea.margin);\n    const charts = plotArea.charts;\n\n    const stage = this._surfaceWrap();\n\n    let total = 0;\n\n    for (let i = 0; i < charts.length; i++) {\n      const currentChart = charts[i];\n      const firstSeries = (currentChart.options.series || [])[0];\n\n      if (!firstSeries) {\n        continue;\n      }\n\n      if (firstSeries.type === BAR) {\n        return DEAULT_BAR_WIDTH;\n      }\n\n      if (firstSeries.type === BULLET) {\n        return DEAULT_BULLET_WIDTH;\n      }\n\n      if (firstSeries.type === PIE) {\n        return elementSize(stage).height;\n      }\n\n      const categoryAxis = currentChart.categoryAxis;\n\n      if (categoryAxis) {\n        const pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);\n        total = Math.max(total, pointsCount);\n      }\n    }\n\n    let size = total * options.pointWidth;\n\n    if (size > 0) {\n      size += margin.left + margin.right;\n    }\n\n    return size;\n  }\n\n  _createSharedTooltip(options) {\n    return new SharedTooltip(this._plotArea, options);\n  }\n\n  static normalizeOptions(userOptions) {\n    let options = wrapNumber(userOptions);\n\n    if (isArray(options)) {\n      options = {\n        seriesDefaults: {\n          data: options\n        }\n      };\n    } else {\n      options = deepExtend({}, options);\n    }\n\n    if (!options.series) {\n      options.series = [{\n        data: wrapNumber(options.data)\n      }];\n    }\n\n    deepExtend(options, {\n      seriesDefaults: {\n        type: options.type\n      }\n    });\n\n    if (inArray(options.series[0].type, NO_CROSSHAIR) || inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {\n      options = deepExtend({}, {\n        categoryAxis: {\n          crosshair: {\n            visible: false\n          }\n        }\n      }, options);\n    }\n\n    return options;\n  }\n\n}\n\nsetDefaultOptions(Sparkline, {\n  chartArea: {\n    margin: 2\n  },\n  axisDefaults: {\n    visible: false,\n    majorGridLines: {\n      visible: false\n    },\n    valueAxis: {\n      narrowRange: true\n    }\n  },\n  seriesDefaults: {\n    type: \"line\",\n    area: {\n      line: {\n        width: 0.5\n      }\n    },\n    bar: {\n      stack: true\n    },\n    padding: 2,\n    width: 0.5,\n    overlay: {\n      gradient: null\n    },\n    highlight: {\n      visible: false\n    },\n    border: {\n      width: 0\n    },\n    markers: {\n      size: 2,\n      visible: false\n    }\n  },\n  tooltip: {\n    visible: true,\n    shared: true\n  },\n  categoryAxis: {\n    crosshair: {\n      visible: true,\n      tooltip: {\n        visible: false\n      }\n    }\n  },\n  legend: {\n    visible: false\n  },\n  transitions: false,\n  pointWidth: 5,\n  panes: [{\n    clip: false\n  }]\n});\nexport default Sparkline;","map":null,"metadata":{},"sourceType":"module"}