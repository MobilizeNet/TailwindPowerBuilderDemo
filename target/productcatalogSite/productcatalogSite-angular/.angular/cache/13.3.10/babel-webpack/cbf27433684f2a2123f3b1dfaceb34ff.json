{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1676);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1676:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function () {\n        window.kendo.pivotgrid = window.kendo.pivotgrid || {};\n\n        window.kendo.pivotgrid.common = function (exports) {\n          var filterFunctionFormats = {\n            contains: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\") > 0\",\n            doesnotcontain: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\")\",\n            endswith: \", Right({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\",\n            eq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\",\n            neq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\",\n            startswith: \", Left({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\"\n          };\n          var operators = {\n            doesnotcontain: 'doesnotcontain',\n            in: 'in',\n            neq: \"neq\"\n          };\n          /**\n           * @hidden\n           */\n\n          function serializeFilters(filters, cube) {\n            var command = \"\";\n            var current = \"\";\n\n            for (var idx = filters.length - 1; idx >= 0; idx--) {\n              current = \"SELECT (\";\n              current += serializeExpression(filters[idx]);\n              current += \") ON 0\";\n\n              if (idx === filters.length - 1) {\n                current += \" FROM [\" + cube + \"]\";\n                command = current;\n              } else {\n                command = current + \" FROM ( \" + command + \" )\";\n              }\n            }\n\n            return command;\n          }\n\n          function serializeExpression(expression) {\n            var command = '';\n            var value = String(expression.value);\n            var field = expression.field;\n            var operator = expression.operator;\n\n            if (operator === operators.in) {\n              command += \"{\";\n              command += value;\n              command += \"}\";\n            } else {\n              command += operator === operators.neq || operator === operators.doesnotcontain ? '-' : '';\n              command += \"Filter(\";\n              command += field + \".MEMBERS\";\n              command += formatString(filterFunctionFormats[operator], field, value);\n              command += \")\";\n            }\n\n            return command;\n          }\n\n          function formatString(str) {\n            var values = [];\n\n            for (var _i = 1; _i < arguments.length; _i++) {\n              values[_i - 1] = arguments[_i];\n            }\n\n            values.forEach(function (value, index) {\n              str = str.replace(new RegExp(\"\\\\{\" + index + \"\\\\}\", 'g'), value);\n            });\n            return str;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function serializeMembers(members, measures, sort) {\n            var command = \"\";\n            members = members || [];\n            var parsed = parseDescriptors(members);\n            var expanded = parsed.expanded;\n            var rootNames = getRootNames(parsed.root);\n            var crossJoinCommands = [];\n            var length = expanded.length;\n            var idx = 0;\n            var memberName;\n            var names = [];\n\n            if (rootNames.length > 1 || measures.length > 1) {\n              crossJoinCommands.push(crossJoinCommand(rootNames, measures));\n\n              for (; idx < length; idx++) {\n                memberName = expandMemberDescriptor(expanded[idx].name, sort);\n                names = mapNames(memberName, rootNames);\n                crossJoinCommands.push(crossJoinCommand(names, measures));\n              }\n\n              command += crossJoinCommands.join(\",\");\n            } else {\n              for (; idx < length; idx++) {\n                memberName = expandMemberDescriptor(expanded[idx].name, sort);\n                names.push(memberName[0]);\n              }\n\n              command += rootNames.concat(names).join(\",\");\n            }\n\n            return command;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function measureNames(measures) {\n            var length = measures.length;\n            var result = [];\n            var measure;\n\n            for (var idx = 0; idx < length; idx++) {\n              measure = measures[idx];\n              result.push(measure.name !== undefined ? measure.name : measure);\n            }\n\n            return result;\n          }\n\n          function getRootNames(members) {\n            var root = [];\n            members.forEach(function (member) {\n              var name = member.name[0];\n              var hierarchyName = baseHierarchyPath(name);\n\n              if (!root.some(function (n) {\n                return n.indexOf(hierarchyName) === 0;\n              })) {\n                root.push(name);\n              }\n            });\n            return root;\n          }\n\n          function parseDescriptors(members) {\n            var expanded = [];\n            var child = [];\n            var root = [];\n            var idx = 0;\n            var found;\n\n            for (; idx < members.length; idx++) {\n              var member = members[idx];\n              var name_1 = member.name;\n              found = false;\n\n              if (name_1.length > 1) {\n                child.push(member);\n              } else {\n                var hierarchyName = baseHierarchyPath(name_1[0]);\n\n                for (var j = 0, l = root.length; j < l; j++) {\n                  if (root[j].name[0].indexOf(hierarchyName) === 0) {\n                    found = true;\n                    break;\n                  }\n                }\n\n                if (!found) {\n                  root.push(member);\n                }\n\n                if (member.expand) {\n                  expanded.push(member);\n                }\n              }\n            }\n\n            expanded = expanded.concat(child);\n            return {\n              expanded: expanded,\n              root: root\n            };\n          }\n\n          function mapNames(names, rootNames) {\n            var rootLength = rootNames.length;\n            rootNames = rootNames.slice(0);\n\n            for (var idx = 0; idx < names.length; idx++) {\n              var name_2 = names[idx];\n\n              for (var j = 0; j < rootLength; j++) {\n                var rootName = baseHierarchyPath(rootNames[j]);\n\n                if (name_2.indexOf(rootName) !== -1) {\n                  rootNames[j] = name_2;\n                  break;\n                }\n              }\n            }\n\n            return rootNames;\n          }\n\n          function crossJoinCommand(members, measures) {\n            var tmp = members.slice(0);\n\n            if (measures.length > 1) {\n              tmp.push(\"{\" + measureNames(measures).join(\",\") + \"}\");\n            }\n\n            return crossJoin(tmp);\n          }\n\n          function expandMemberDescriptor(names, sort) {\n            var idx = names.length - 1;\n            var name = names[idx];\n            var sortDescriptor = sortDescriptorForMember(sort, name);\n\n            if (sortDescriptor && sortDescriptor.dir) {\n              name = \"ORDER(\" + name + \".Children,\" + sortDescriptor.field + \".CurrentMember.MEMBER_CAPTION,\" + sortDescriptor.dir + \")\";\n            } else {\n              name += \".Children\";\n            }\n\n            names[idx] = name;\n            return names;\n          }\n\n          function sortDescriptorForMember(sort, member) {\n            for (var idx = 0, length_1 = sort.length; idx < length_1; idx++) {\n              if (member.indexOf(sort[idx].field) === 0) {\n                return sort[idx];\n              }\n            }\n\n            return null;\n          }\n\n          function baseHierarchyPath(memberName) {\n            var parts = memberName.split(\".\");\n\n            if (parts.length > 2) {\n              return parts[0] + \".\" + parts[1];\n            }\n\n            return memberName;\n          }\n\n          function crossJoin(names) {\n            var result = \"CROSSJOIN({\";\n            var name;\n\n            if (names.length > 2) {\n              name = names.pop();\n              result += crossJoin(names);\n            } else {\n              result += names.shift();\n              name = names.pop();\n            }\n\n            result += \"},{\";\n            result += name;\n            result += \"})\";\n            return result;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function createRequestBody(options) {\n            var command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>';\n            var _a = options.columnAxes,\n                columnAxes = _a === void 0 ? [] : _a,\n                _b = options.rowAxes,\n                rowAxes = _b === void 0 ? [] : _b;\n            var _c = options.measureAxes,\n                measureAxes = _c === void 0 ? [] : _c,\n                _d = options.sort,\n                sort = _d === void 0 ? [] : _d,\n                _e = options.filter,\n                filter = _e === void 0 ? [] : _e;\n            var measuresRowAxis = options.measuresAxis === \"rows\";\n            command += \"SELECT NON EMPTY {\";\n\n            if (!columnAxes.length && rowAxes.length && (!measureAxes.length || measureAxes.length && measuresRowAxis)) {\n              columnAxes = rowAxes;\n              rowAxes = [];\n              measuresRowAxis = false;\n            }\n\n            if (!columnAxes.length && !rowAxes.length) {\n              measuresRowAxis = false;\n            }\n\n            if (columnAxes.length) {\n              command += serializeMembers(columnAxes, !measuresRowAxis ? measureAxes : [], sort);\n            } else if (measureAxes.length && !measuresRowAxis) {\n              command += measureNames(measureAxes).join(\",\");\n            }\n\n            command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON COLUMNS\";\n\n            if (rowAxes.length || measuresRowAxis && measureAxes.length > 1) {\n              command += \", NON EMPTY {\";\n\n              if (rowAxes.length) {\n                command += serializeMembers(rowAxes, measuresRowAxis ? measureAxes : [], sort);\n              } else {\n                command += measureNames(measureAxes).join(\",\");\n              }\n\n              command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON ROWS\";\n            }\n\n            if (filter.length) {\n              command += \" FROM \";\n              command += \"(\";\n              command += serializeFilters(filter, options.connection.cube);\n              command += \")\";\n            } else {\n              command += \" FROM [\" + options.connection.cube + \"]\";\n            }\n\n            if (measureAxes.length === 1 && columnAxes.length) {\n              command += \" WHERE (\" + measureNames(measureAxes).join(\",\") + \")\";\n            }\n\n            command += '</Statement></Command><Properties><PropertyList><Catalog>' + options.connection.catalog + '</Catalog><Format>Multidimensional</Format></PropertyList></Properties></Execute></Body></Envelope>';\n            return command.replace(/&/g, \"&amp;\");\n          }\n          /*! *****************************************************************************\n          Copyright (c) Microsoft Corporation.\n           Permission to use, copy, modify, and/or distribute this software for any\n          purpose with or without fee is hereby granted.\n           THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n          REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n          AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n          INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n          LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n          OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n          PERFORMANCE OF THIS SOFTWARE.\n          ***************************************************************************** */\n\n\n          var __assign = function () {\n            __assign = Object.assign || function __assign(t) {\n              for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n              }\n\n              return t;\n            };\n\n            return __assign.apply(this, arguments);\n          };\n\n          function __awaiter(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function (resolve) {\n                resolve(value);\n              });\n            }\n\n            return new (P || (P = Promise))(function (resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          }\n\n          function __generator(thisArg, body) {\n            var _ = {\n              label: 0,\n              sent: function () {\n                if (t[0] & 1) throw t[1];\n                return t[1];\n              },\n              trys: [],\n              ops: []\n            },\n                f,\n                y,\n                t,\n                g;\n            return g = {\n              next: verb(0),\n              \"throw\": verb(1),\n              \"return\": verb(2)\n            }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n              return this;\n            }), g;\n\n            function verb(n) {\n              return function (v) {\n                return step([n, v]);\n              };\n            }\n\n            function step(op) {\n              if (f) throw new TypeError(\"Generator is already executing.\");\n\n              while (_) try {\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                if (y = 0, t) op = [op[0] & 2, t.value];\n\n                switch (op[0]) {\n                  case 0:\n                  case 1:\n                    t = op;\n                    break;\n\n                  case 4:\n                    _.label++;\n                    return {\n                      value: op[1],\n                      done: false\n                    };\n\n                  case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [0];\n                    continue;\n\n                  case 7:\n                    op = _.ops.pop();\n\n                    _.trys.pop();\n\n                    continue;\n\n                  default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                      _ = 0;\n                      continue;\n                    }\n\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                      _.label = op[1];\n                      break;\n                    }\n\n                    if (op[0] === 6 && _.label < t[1]) {\n                      _.label = t[1];\n                      t = op;\n                      break;\n                    }\n\n                    if (t && _.label < t[2]) {\n                      _.label = t[2];\n\n                      _.ops.push(op);\n\n                      break;\n                    }\n\n                    if (t[2]) _.ops.pop();\n\n                    _.trys.pop();\n\n                    continue;\n                }\n\n                op = body.call(thisArg, _);\n              } catch (e) {\n                op = [6, e];\n                y = 0;\n              } finally {\n                f = t = 0;\n              }\n\n              if (op[0] & 5) throw op[1];\n              return {\n                value: op[0] ? op[1] : void 0,\n                done: true\n              };\n            }\n          }\n          /** @deprecated */\n\n\n          function __spreadArrays() {\n            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n            for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n            return r;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseResponse(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var axes = Array.from(xmlDoc.querySelectorAll(\"Axis\"));\n            var cells = Array.from(xmlDoc.querySelectorAll(\"CellData > Cell\")).map(function (cell) {\n              return {\n                fmtValue: getPropertyValue(cell, \"FmtValue\"),\n                ordinal: parseInt(cell.getAttribute(\"CellOrdinal\"), 10),\n                value: getPropertyValue(cell, \"Value\")\n              };\n            });\n            var columns = {\n              tuples: []\n            };\n            var rows = {\n              tuples: []\n            };\n            var data = [];\n            axes.forEach(function (axis) {\n              if (axis.getAttribute('name') !== \"SlicerAxis\") {\n                var tuples = columns.tuples.length === 0 ? columns.tuples : rows.tuples;\n                Array.prototype.push.apply(tuples, translateAxis(axis));\n              }\n            });\n            var indexedData = new Array(rows.tuples.length * columns.tuples.length).fill(null);\n            cells.forEach(function (c) {\n              indexedData[c.ordinal] = c;\n            });\n            var counter = 0;\n            rows.tuples.forEach(function (rowTuple) {\n              columns.tuples.forEach(function (colTuple) {\n                data.push({\n                  columnTuple: colTuple,\n                  data: indexedData[counter],\n                  rowTuple: rowTuple\n                });\n                counter++;\n              });\n            });\n            return {\n              columns: columns,\n              data: data,\n              rows: rows\n            };\n          }\n          /**\n           * @hidden\n           */\n\n\n          function getPropertyValue(member, name) {\n            var node = member.querySelector(name);\n            return node ? node.textContent : \"\";\n          }\n\n          function translateAxis(axis) {\n            var tuples = Array.from(axis.querySelectorAll(\"Tuple\"));\n            return tuples.map(function (tuple) {\n              var memberElements = Array.from(tuple.querySelectorAll(\"Member\"));\n              var members = memberElements.map(function (member) {\n                var lNum = parseInt(getPropertyValue(member, \"LNum\") || \"0\", 10);\n                var hasChildren = parseInt(getPropertyValue(member, \"CHILDREN_CARDINALITY\") || \"0\", 10) > 0;\n                return {\n                  caption: getPropertyValue(member, \"Caption\"),\n                  children: [],\n                  hasChildren: hasChildren,\n                  hierarchy: member.getAttribute('Hierarchy'),\n                  levelName: getPropertyValue(member, \"LName\"),\n                  levelNum: lNum,\n                  name: getPropertyValue(member, \"UName\"),\n                  parentName: getPropertyValue(member, \"PARENT_UNIQUE_NAME\")\n                };\n              });\n              return {\n                members: members\n              };\n            });\n          }\n          /**\n           * @hidden\n           */\n\n\n          var discoverCommands = {\n            schemaCatalogs: \"DBSCHEMA_CATALOGS\",\n            schemaCubes: \"MDSCHEMA_CUBES\",\n            schemaDimensions: \"MDSCHEMA_DIMENSIONS\",\n            schemaHierarchies: \"MDSCHEMA_HIERARCHIES\",\n            schemaKPIs: \"MDSCHEMA_KPIS\",\n            schemaLevels: \"MDSCHEMA_LEVELS\",\n            schemaMeasures: \"MDSCHEMA_MEASURES\",\n            schemaMembers: \"MDSCHEMA_MEMBERS\"\n          };\n          /**\n           * @hidden\n           */\n\n          function createDiscoverBody(options) {\n            var properties = {};\n            var command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\">';\n            command += \"<RequestType>\" + (discoverCommands[options.command] || options.command) + \"</RequestType>\";\n            command += \"<Restrictions>\" + serializeOptions(\"RestrictionList\", options.restrictions, true) + \"</Restrictions>\";\n\n            if (options.connection && options.connection.catalog) {\n              properties.Catalog = options.connection.catalog;\n            }\n\n            command += \"<Properties>\" + serializeOptions(\"PropertyList\", properties, false) + \"</Properties>\";\n            command += '</Discover></Body></Envelope>';\n            return command;\n          }\n\n          function serializeOptions(parentTagName, options, capitalize) {\n            var result = \"\";\n\n            if (options) {\n              result += \"<\" + parentTagName + \">\";\n              var value = void 0;\n\n              for (var key in options) {\n                if (options[key]) {\n                  value = options[key];\n\n                  if (capitalize) {\n                    key = key.replace(/([A-Z]+(?=$|[A-Z][a-z])|[A-Z]?[a-z]+)/g, \"$1_\").toUpperCase().replace(/_$/, \"\");\n                  }\n\n                  result += \"<\" + key + \">\" + value + \"</\" + key + \">\";\n                }\n              }\n\n              result += \"</\" + parentTagName + \">\";\n            } else {\n              result += \"<\" + parentTagName + \"/>\";\n            }\n\n            return result;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseCubes(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"CUBE_NAME\"),\n                caption: getPropertyValue(row, \"CUBE_CAPTION\"),\n                description: getPropertyValue(row, \"DESCRIPTION\"),\n                type: getPropertyValue(row, \"CUBE_TYPE\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseCatalogs(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"CATALOG_NAME\"),\n                description: getPropertyValue(row, \"DESCRIPTION\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseMeasures(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"MEASURE_NAME\"),\n                caption: getPropertyValue(row, \"MEASURE_CAPTION\"),\n                uniqueName: getPropertyValue(row, \"MEASURE_UNIQUE_NAME\"),\n                description: getPropertyValue(row, \"DESCRIPTION\"),\n                aggregator: getPropertyValue(row, \"MEASURE_AGGREGATOR\"),\n                groupName: getPropertyValue(row, \"MEASUREGROUP_NAME\"),\n                displayFolder: getPropertyValue(row, \"MEASURE_DISPLAY_FOLDER\"),\n                defaultFormat: getPropertyValue(row, \"DEFAULT_FORMAT_STRING\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseKPIs(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"KPI_NAME\"),\n                uniqueName: getPropertyValue(row, \"KPI_NAME\"),\n                caption: getPropertyValue(row, \"KPI_CAPTION\"),\n                value: getPropertyValue(row, \"KPI_VALUE\"),\n                goal: getPropertyValue(row, \"KPI_GOAL\"),\n                status: getPropertyValue(row, \"KPI_STATUS\"),\n                trend: getPropertyValue(row, \"KPI_TREND\"),\n                statusGraphic: getPropertyValue(row, \"KPI_STATUS_GRAPHIC\"),\n                trendGraphic: getPropertyValue(row, \"KPI_TREND_GRAPHIC\"),\n                description: getPropertyValue(row, \"KPI_DESCRIPTION\"),\n                groupName: getPropertyValue(row, \"MEASUREGROUP_NAME\"),\n                type: \"kpi\"\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseDimensions(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                caption: getPropertyValue(row, \"DIMENSION_CAPTION\"),\n                defaultHierarchy: getPropertyValue(row, \"DEFAULT_HIERARCHY\"),\n                description: getPropertyValue(row, \"DESCRIPTION\"),\n                name: getPropertyValue(row, \"DIMENSION_NAME\"),\n                type: parseInt(getPropertyValue(row, \"DIMENSION_TYPE\"), 10),\n                uniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseHierarchies(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"HIERARCHY_NAME\"),\n                caption: getPropertyValue(row, \"HIERARCHY_CAPTION\"),\n                description: getPropertyValue(row, \"DESCRIPTION\"),\n                uniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\"),\n                dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n                displayFolder: getPropertyValue(row, \"HIERARCHY_DISPLAY_FOLDER\"),\n                origin: getPropertyValue(row, \"HIERARCHY_ORIGIN\"),\n                defaultMember: getPropertyValue(row, \"DEFAULT_MEMBER\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseLevels(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"LEVEL_NAME\"),\n                caption: getPropertyValue(row, \"LEVEL_CAPTION\"),\n                description: getPropertyValue(row, \"DESCRIPTION\"),\n                uniqueName: getPropertyValue(row, \"LEVEL_UNIQUE_NAME\"),\n                dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n                displayFolder: getPropertyValue(row, \"LEVEL_DISPLAY_FOLDER\"),\n                orderingProperty: getPropertyValue(row, \"LEVEL_ORDERING_PROPERTY\"),\n                origin: getPropertyValue(row, \"LEVEL_ORIGIN\"),\n                hierarchyUniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\")\n              };\n            });\n            return rows;\n          }\n          /**\n           * @hidden\n           */\n\n\n          function parseMembers(response) {\n            var xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n            var rows = Array.from(xmlDoc.querySelectorAll(\"DiscoverResponse > return > root > row\")).map(function (row) {\n              return {\n                name: getPropertyValue(row, \"MEMBER_NAME\"),\n                caption: getPropertyValue(row, \"MEMBER_CAPTION\"),\n                uniqueName: getPropertyValue(row, \"MEMBER_UNIQUE_NAME\"),\n                dimensionUniqueName: getPropertyValue(row, \"DIMENSION_UNIQUE_NAME\"),\n                hierarchyUniqueName: getPropertyValue(row, \"HIERARCHY_UNIQUE_NAME\"),\n                levelUniqueName: getPropertyValue(row, \"LEVEL_UNIQUE_NAME\"),\n                childrenCardinality: getPropertyValue(row, \"CHILDREN_CARDINALITY\")\n              };\n            });\n            return rows;\n          }\n\n          var discoverParser = {\n            schemaCatalogs: parseCatalogs,\n            schemaCubes: parseCubes,\n            schemaDimensions: parseDimensions,\n            schemaHierarchies: parseHierarchies,\n            schemaKPIs: parseKPIs,\n            schemaLevels: parseLevels,\n            schemaMeasures: parseMeasures,\n            schemaMembers: parseMembers\n          };\n          /**\n           * Fetches the data.\n           *\n           * @param options RequestOptions\n           * @returns Promise<ResponseData>\n           *\n           * @example\n           * const options: RequestOptions = { ... };\n           *\n           * fetchData(options).then(createDataState).then((dataState: DataState) => {\n           *  // Update the UI\n           * });\n           */\n\n          /**\n           * @hidden\n           */\n\n          var fetchData = function (fetchOptions, options) {\n            return __awaiter(void 0, void 0, void 0, function () {\n              var init, response, stringResponse;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    init = __assign({\n                      body: createRequestBody(options),\n                      headers: {\n                        'Content-Type': 'text/xml'\n                      },\n                      method: 'POST'\n                    }, fetchOptions.init);\n                    return [4\n                    /*yield*/\n                    , fetch(fetchOptions.url, init)];\n\n                  case 1:\n                    response = _a.sent();\n                    return [4\n                    /*yield*/\n                    , response.text()];\n\n                  case 2:\n                    stringResponse = _a.sent();\n                    return [2\n                    /*return*/\n                    , parseResponse(stringResponse)];\n                }\n              });\n            });\n          };\n          /**\n           * @hidden\n           */\n\n\n          var fetchDiscover = function (fetchOptions, options) {\n            return __awaiter(void 0, void 0, void 0, function () {\n              var init, response, stringResponse;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    init = __assign({\n                      body: createDiscoverBody(options),\n                      headers: {\n                        'Content-Type': 'text/xml'\n                      },\n                      method: 'POST'\n                    }, fetchOptions.init);\n                    return [4\n                    /*yield*/\n                    , fetch(fetchOptions.url, init)];\n\n                  case 1:\n                    response = _a.sent();\n                    return [4\n                    /*yield*/\n                    , response.text()];\n\n                  case 2:\n                    stringResponse = _a.sent();\n                    return [2\n                    /*return*/\n                    , discoverParser[options.command](stringResponse)];\n                }\n              });\n            });\n          };\n          /**\n           * Creates the state object. See `fetchData`.\n           *\n           * @param response - ResponseData\n           * @returns DataState\n           */\n\n          /**\n           * @hidden\n           */\n\n\n          var createDataState = function (response) {\n            var state = {\n              columns: response.columns.tuples,\n              data: response.data,\n              rows: response.rows.tuples\n            };\n            return state;\n          };\n          /**\n           * Creates a collection of AxisDescriptor base on the expandTree.\n           * @param expandTree - { [key: string]: boolean }\n           * @returns AxisDescriptor[]\n           *\n           * @example\n           * See `setRowExpand` or `setColumnExpand` functions.\n           */\n\n          /**\n           * @hidden\n           */\n\n\n          function createAxisDescriptors(expandTree) {\n            var descriptors = [];\n\n            for (var _i = 0, _a = Object.keys(expandTree); _i < _a.length; _i++) {\n              var key = _a[_i];\n              descriptors.push({\n                name: JSON.parse(key),\n                expand: expandTree[key]\n              });\n            }\n\n            return descriptors;\n          }\n          /**\n           * Sets sort descriptors to request options.\n           *\n           * @param options - RequestOptions\n           * @param sort - SortDescriptor[]\n           *\n           * @example\n           * const options: RequestOptions = { ... };\n           * const sort: SortDescriptor[] = [{ ... }, { ... }];\n           * setSort(options, sort);\n           * // skip the sort parameter to clear current filter - setSort(options);\n           *\n           * fetchData(options).then(createDataState).then((dataState: DataState) => {\n           *  // Update the UI\n           * });\n           */\n\n          /**\n           * @hidden\n           */\n\n\n          var setSort = function (options, sort) {\n            if (sort === void 0) {\n              sort = [];\n            }\n\n            options.sort = sort;\n          };\n          /**\n           * Sets filter descriptors to request options.\n           *\n           * @param options - RequestOptions\n           * @param filter - FilterDescriptor[]\n           *\n           * @example\n           * const options: RequestOptions = { ... };\n           * const filter: FilterDescriptor[] = [{ ... }, { ... }];\n           * setFilter(options, filter);\n           * // skip the filter parameter to clear current filter - setFilter(options);\n           *\n           * fetchData(options).then(createDataState).then((dataState: DataState) => {\n           *  // Update the UI\n           * });\n           */\n\n          /**\n           * @hidden\n           */\n\n\n          var setFilter = function (options, filter) {\n            if (filter === void 0) {\n              filter = [];\n            }\n\n            options.filter = filter;\n          }; // A typical tree depth count won't work for the Pivot,\n          // as each branch can have lower number of nodes than the total number of levels\n\n          /**\n           * @hidden\n           */\n\n\n          var getMaxNesting = function (node, set) {\n            if (set === void 0) {\n              set = new Set();\n            }\n\n            (node.children || []).forEach(function (child) {\n              set.add(child.levelName);\n              getMaxNesting(child, set);\n            });\n            return set.size;\n          };\n          /**\n           * @hidden\n           */\n\n\n          var getMaxExpansion = function (node) {\n            var expanded = 0;\n            (node.children || []).forEach(function (child) {\n              expanded += getMaxExpansion(child) || 1;\n            });\n            return expanded;\n          };\n          /**\n           * @hidden\n           */\n\n\n          var generateNormalizedPath = function (node, parent) {\n            return (parent && parent.hierarchy === node.hierarchy ? __spreadArrays((parent.normalizedPath || []).slice(0, -1), [node.name || null]) : __spreadArrays(parent && parent.normalizedPath ? parent.normalizedPath : [], [node.name])).filter(Boolean);\n          };\n          /**\n           * @hidden\n           */\n\n\n          var generatePath = function (node, parent) {\n            return (parent && parent.hierarchy === node.hierarchy ? __spreadArrays((parent.path || []).slice(0, -1), [(node.levelNum === 0 ? node.hierarchy : node.name) || null]) : __spreadArrays(parent && parent.path ? parent.path : [], [node.levelNum === 0 ? node.hierarchy : node.name])).filter(Boolean);\n          };\n          /**\n           * @hidden\n           */\n\n\n          var toMatrix = function (node, rowIndex, colIndex, maxDepth, maxBreadth, matrix, leafs, parent) {\n            if (rowIndex === void 0) {\n              rowIndex = -1;\n            }\n\n            if (colIndex === void 0) {\n              colIndex = 0;\n            }\n\n            if (maxDepth === void 0) {\n              maxDepth = undefined;\n            }\n\n            if (maxBreadth === void 0) {\n              maxBreadth = undefined;\n            }\n\n            if (matrix === void 0) {\n              matrix = undefined;\n            }\n\n            if (leafs === void 0) {\n              leafs = undefined;\n            }\n\n            if (parent === void 0) {\n              parent = undefined;\n            }\n\n            var branchDepth = getMaxNesting(node);\n            var branchBreadth = getMaxExpansion(node);\n            var depth = maxDepth || branchDepth;\n            var breadth = maxBreadth || branchBreadth;\n            var matrixResult = matrix ? matrix.slice() : [];\n            var leafsResult = leafs ? leafs.slice() : new Array(breadth);\n            var index = matrixResult.findIndex(function (l) {\n              return l && l.name === node.levelName && l.level === node.levelNum;\n            });\n            var level = matrixResult[index];\n            var row = {\n              name: node.levelName,\n              level: node.levelNum,\n              index: rowIndex,\n              cells: new Array(breadth).fill(null)\n            };\n            var inject = rowIndex !== -1 && colIndex !== -1;\n            var cell = {\n              caption: node.caption,\n              name: node.name,\n              levelName: node.levelName,\n              levelNum: node.levelNum,\n              hasChildren: node.hasChildren,\n              parentName: node.parentName,\n              hierarchy: node.hierarchy,\n              total: (node.total !== undefined ? node.total : false) || parent && parent.children.length <= 1 && parent.total,\n              parent: parent,\n              rowIndex: rowIndex,\n              colIndex: colIndex,\n              depth: 1,\n              breadth: 1,\n              path: node.path || [],\n              normalizedPath: node.normalizedPath || [],\n              children: node.children.filter(function (c) {\n                return c.hierarchy === node.hierarchy;\n              })\n            };\n\n            if (inject) {\n              if (level) {\n                level.cells[colIndex] = cell;\n\n                if (level.index >= rowIndex) {\n                  rowIndex = level.index;\n                }\n              } else {\n                if (matrixResult[rowIndex] && matrixResult[rowIndex].cells.length) {\n                  for (var idx = rowIndex; idx < matrixResult.length; idx++) {\n                    var shiftedRow = matrixResult[idx];\n                    shiftedRow.index++;\n                  }\n\n                  matrixResult.splice(rowIndex, 0, row);\n                  matrixResult[rowIndex].cells[colIndex] = cell;\n                } else {\n                  matrixResult[rowIndex] = row;\n                  matrixResult[rowIndex].cells[colIndex] = cell;\n                }\n              }\n            }\n\n            var collOffset = 0;\n\n            if (node.children && node.children.length) {\n              node.children.forEach(function (child) {\n                var _a = toMatrix(child, rowIndex + 1, colIndex + collOffset, depth, breadth, matrixResult, leafsResult, cell),\n                    newMatrix = _a[0],\n                    newLeafs = _a[1],\n                    childBreadth = _a[3];\n\n                collOffset += childBreadth || 1;\n                matrixResult = newMatrix.slice();\n                leafsResult = newLeafs.slice();\n              });\n            } else if (node.normalizedPath) {\n              leafsResult[colIndex] = {\n                total: cell.total,\n                path: node.normalizedPath\n              };\n            }\n\n            cell.depth = branchDepth;\n            cell.breadth = branchBreadth;\n            return [matrixResult, leafsResult, branchDepth, branchBreadth];\n          };\n\n          var withTotal = function (root, parent, index) {\n            if (parent === void 0) {\n              parent = null;\n            }\n\n            if (index === void 0) {\n              index = 0;\n            }\n\n            var hierarchy;\n\n            var alt = __assign(__assign({}, root), {\n              total: true,\n              hasChildren: false,\n              children: []\n            });\n\n            for (var childIndex = 0; childIndex < root.children.length; childIndex++) {\n              var child = withTotal(root.children[childIndex], root, childIndex);\n              hierarchy = hierarchy || child.hierarchy;\n\n              if (child.hierarchy !== hierarchy && parent && !parent.children.some(function (c) {\n                return c.total && c.name === alt.name;\n              }) && !root.total) {\n                alt.children.push(child);\n                root.children.splice(childIndex, 1);\n                childIndex--;\n              }\n            }\n\n            if (root.children.filter(function (c) {\n              return !c.total;\n            }).length >= 1 && parent && !parent.children.some(function (c) {\n              return c.total && c.name === alt.name;\n            }) && !root.total) {\n              var childHierarchy = root.children[0].hierarchy;\n\n              if (root.hierarchy === childHierarchy) {\n                parent.children.splice(index + 1, 0, alt);\n              }\n            }\n\n            return root;\n          };\n          /**\n           * @hidden\n           */\n\n\n          var toTree = function (tuples) {\n            var root = {\n              children: []\n            };\n            var map = {};\n\n            var _loop_1 = function (tupleIndex) {\n              var tuple = copy(tuples[tupleIndex]);\n              var key = \"\";\n\n              var _loop_2 = function (memberIndex) {\n                var member = tuple.members[memberIndex];\n                var parent_1;\n\n                if (root.children && root.children.length === 0) {\n                  parent_1 = root;\n                } else if (map[key] && !map[key + member.name] && member.levelNum === 0) {\n                  parent_1 = map[key];\n                } else if (map[key + member.parentName] && member.levelNum > 0 && !map[key + member.parentName + member.name]) {\n                  parent_1 = map[key + member.parentName];\n                } else if (!map[key + member.parentName] && member.levelNum > 0 && !map[key + member.parentName + member.name]) {\n                  var parentKey = Object.keys(map).find(function (e) {\n                    return e.indexOf(member.hierarchy) === 0 && e.lastIndexOf(key + member.parentName) + (key + member.parentName).length === e.length;\n                  });\n\n                  if (parentKey) {\n                    parent_1 = map[parentKey];\n                  }\n                }\n\n                if (parent_1) {\n                  member.path = generatePath(member, parent_1);\n                  member.normalizedPath = generateNormalizedPath(member, parent_1);\n                  var intruderIndex = parent_1.children.findIndex(function (c) {\n                    return c.hierarchy !== parent_1.hierarchy;\n                  });\n\n                  if (intruderIndex !== -1) {\n                    parent_1.children.splice(Math.max(intruderIndex, 0), 0, member);\n                  } else {\n                    parent_1.children.push(member);\n                  }\n                }\n\n                key += member.parentName += member.name;\n\n                if (!map[key]) {\n                  map[key] = member;\n                }\n              };\n\n              for (var memberIndex = 0; memberIndex < tuple.members.length; memberIndex++) {\n                _loop_2(memberIndex);\n              }\n            };\n\n            for (var tupleIndex = 0; tupleIndex < tuples.length; tupleIndex++) {\n              _loop_1(tupleIndex);\n            }\n\n            return copy(withTotal(root));\n          };\n          /**\n           * @hidden\n           */\n\n\n          var toData = function (data, columns, rows, breadth, depth) {\n            var result = Array.from(new Array(depth), function () {\n              return {\n                cells: Array.from(new Array(breadth), function () {\n                  return null;\n                })\n              };\n            });\n\n            var hash = function (names) {\n              return names.join('|');\n            };\n\n            var membersNames = function (tuple) {\n              return tuple.members.map(function (m) {\n                return m.name;\n              });\n            };\n\n            var columnsIndexes = new Map();\n            var rowsIndexes = new Map();\n            columns.forEach(function (colMembers, idx) {\n              columnsIndexes.set(hash(colMembers.path), idx);\n            });\n            rows.forEach(function (rowMembers, idx) {\n              rowsIndexes.set(hash(rowMembers.path), idx);\n            });\n            data.forEach(function (item) {\n              var colIndex = columnsIndexes.get(hash(membersNames(item.columnTuple)));\n              var rowIndex = rowsIndexes.get(hash(membersNames(item.rowTuple)));\n\n              if (colIndex !== undefined && rowIndex !== undefined) {\n                if (!result[rowIndex].cells[colIndex]) {\n                  result[rowIndex].row = rows[rowIndex].path;\n                  result[rowIndex].cells[colIndex] = item;\n                }\n              }\n            });\n            return result;\n          };\n\n          var rotateMatrix = function (matrix, leafs, depth, breadth) {\n            var result = new Array(breadth);\n\n            for (var colIndex = 0; colIndex < breadth; colIndex++) {\n              for (var rowIndex = 0; rowIndex < depth; rowIndex++) {\n                if (matrix[rowIndex] && matrix[rowIndex].cells[colIndex]) {\n                  var cell = matrix[rowIndex].cells[colIndex];\n\n                  if (!result[colIndex]) {\n                    result[colIndex] = {\n                      cells: new Array(depth).fill(null)\n                    };\n                  }\n\n                  result[colIndex].cells[rowIndex] = __assign(__assign({}, cell), {\n                    rowSpan: cell.colSpan,\n                    colSpan: cell.rowSpan\n                  });\n                }\n              }\n            }\n\n            return [result, leafs, breadth, depth];\n          };\n          /**\n           * @hidden\n           */\n\n\n          var toColumns = function (root) {\n            var _a = toMatrix(root),\n                matrix = _a[0],\n                leafs = _a[1],\n                depth = _a[2],\n                breadth = _a[3];\n\n            for (var colIndex = 0; colIndex < breadth; colIndex++) {\n              var cell = null;\n\n              for (var rowIndex = 0; rowIndex < depth; rowIndex++) {\n                if (matrix[rowIndex]) {\n                  var next = matrix[rowIndex].cells[colIndex];\n\n                  if (!next && cell) {\n                    cell.rowSpan = (cell.rowSpan || 1) + 1;\n                  }\n\n                  if (cell) {\n                    cell.colSpan = cell.breadth || 1;\n                  }\n\n                  if (next) {\n                    cell = next;\n                  }\n                }\n              }\n            }\n\n            return [matrix, leafs, depth, breadth];\n          };\n          /**\n           * @hidden\n           */\n\n\n          var toRows = function (root) {\n            var _a = toMatrix(root),\n                matrix = _a[0],\n                leafs = _a[1],\n                depth = _a[2],\n                breadth = _a[3];\n\n            for (var colIndex = 0; colIndex < breadth; colIndex++) {\n              var cell = null;\n\n              for (var rowIndex = 0; rowIndex < depth; rowIndex++) {\n                if (matrix[rowIndex]) {\n                  var next = matrix[rowIndex].cells[colIndex];\n\n                  if (!next && cell) {\n                    cell.rowSpan = (cell.rowSpan || 1) + 1;\n                  }\n\n                  if (cell) {\n                    cell.colSpan = cell.breadth;\n                  }\n\n                  if (next) {\n                    cell = next;\n                  }\n                }\n              }\n            }\n\n            return rotateMatrix(matrix, leafs, depth, breadth);\n          };\n          /**\n           * @hidden\n           */\n\n\n          function copy(obj) {\n            return JSON.parse(JSON.stringify(obj));\n          }\n\n          var kpiMeasure = function (name, measure, type) {\n            return {\n              hierarchyUniqueName: name,\n              uniqueName: measure,\n              caption: measure,\n              measure: measure,\n              name: measure,\n              type: type,\n              kpi: true\n            };\n          };\n          /**\n           * @hidden\n           */\n\n\n          function buildKPIMeasures(node) {\n            var name = node.name;\n            return [kpiMeasure(name, node.value, \"value\"), kpiMeasure(name, node.goal, \"goal\"), kpiMeasure(name, node.status, \"status\"), kpiMeasure(name, node.trend, \"trend\")];\n          }\n          /**\n           * @hidden\n           */\n\n\n          var addKPI = function (data) {\n            var found;\n            var idx = 0;\n\n            for (; idx < data.length; idx++) {\n              if (data[idx].type === 2) {\n                found = true;\n                break;\n              }\n            }\n\n            if (found) {\n              data.splice(idx + 1, 0, {\n                caption: \"KPIs\",\n                defaultHierarchy: \"[KPIs]\",\n                name: \"KPIs\",\n                uniqueName: \"[KPIs]\"\n              });\n            }\n          };\n          /**\n           * @hidden\n           */\n\n\n          var compareAxisWithField = function (a, b) {\n            return String(a.name) === String([b.defaultHierarchy ? b.defaultHierarchy : b.uniqueName]);\n          };\n          /**\n           * @hidden\n           */\n\n\n          var compareAxes = function (a, b) {\n            return String(a.name) === String(b.name);\n          };\n          /**\n           * @hidden\n           */\n\n\n          exports.HEADERS_ACTION = void 0;\n\n          (function (HEADERS_ACTION) {\n            HEADERS_ACTION[\"toggle\"] = \"HEADERS_ACTION_TOGGLE\";\n            HEADERS_ACTION[\"expand\"] = \"HEADERS_ACTION_EXPAND\";\n            HEADERS_ACTION[\"collapse\"] = \"HEADERS_ACTION_COLLAPSE\";\n          })(exports.HEADERS_ACTION || (exports.HEADERS_ACTION = {}));\n\n          var findPath = function (node, matchFn, matched) {\n            var result = new Set();\n            node.children.forEach(function (child) {\n              var match = matchFn(child);\n\n              if (matched) {\n                result.add(String(child.path));\n              }\n\n              findPath(child, matchFn, matched || match).map(function (h) {\n                result.add(h);\n              });\n            });\n            return Array.from(result.values());\n          };\n          /**\n           * @hidden\n           */\n\n\n          var headersReducer = function (state, action) {\n            switch (action.type) {\n              case exports.HEADERS_ACTION.toggle:\n                {\n                  var existing = state.find(function (s) {\n                    return String(s.name) === String(action.payload);\n                  });\n                  return headersReducer(state, __assign(__assign({}, action), {\n                    type: existing && existing.expand ? exports.HEADERS_ACTION.collapse : exports.HEADERS_ACTION.expand\n                  }));\n                }\n\n              case exports.HEADERS_ACTION.expand:\n                {\n                  var existing_1 = state.find(function (s) {\n                    return String(s.name) === String(action.payload);\n                  });\n\n                  if (existing_1 && existing_1.expand === true) {\n                    return state;\n                  } else if (existing_1 && (existing_1.expand === false || existing_1.expand === undefined)) {\n                    return state.map(function (s) {\n                      return s === existing_1 ? __assign(__assign({}, existing_1), {\n                        expand: true\n                      }) : s;\n                    });\n                  } else {\n                    return __spreadArrays(state, [{\n                      name: action.payload,\n                      expand: true\n                    }]);\n                  }\n                }\n\n              case exports.HEADERS_ACTION.collapse:\n                {\n                  var filtered_1 = findPath(action.tree, function (node) {\n                    return !node.total && String(node.path) === String(action.payload);\n                  });\n\n                  var newState = __spreadArrays(state).filter(function (h) {\n                    return !filtered_1.some(function (f) {\n                      return f === String(h.name);\n                    });\n                  }).map(function (h) {\n                    return __assign(__assign({}, h), {\n                      expand: Boolean(h.expand)\n                    });\n                  }).map(function (h) {\n                    return String(h.name) === String(action.payload) ? action.payload.length > 1 ? undefined : {\n                      name: action.payload,\n                      expand: false\n                    } : h;\n                  }).filter(Boolean);\n\n                  return newState;\n                }\n\n              default:\n                {\n                  return state;\n                }\n            }\n          };\n          /**\n           * @hidden\n           */\n\n\n          exports.PIVOT_CONFIGURATOR_ACTION = void 0;\n\n          (function (PIVOT_CONFIGURATOR_ACTION) {\n            // Selection\n            PIVOT_CONFIGURATOR_ACTION[\"toggleSelection\"] = \"PIVOT_CONFIGURATOR_ACTION_TOGGLE_SELECTION\";\n            PIVOT_CONFIGURATOR_ACTION[\"addColumnAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_COLUMN_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"addColumnAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_COLUMN_AXES\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeColumnAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_COLUMN_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeColumnAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_COLUMN_AXES\";\n            PIVOT_CONFIGURATOR_ACTION[\"addRowAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_ROW_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"addRowAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_ROW_AXES\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeRowAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_ROW_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeRowAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_ROW_AXES\";\n            PIVOT_CONFIGURATOR_ACTION[\"addMeasureAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_MEASURE_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"addMeasureAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_MEASURE_AXES\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeMeasureAxis\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_MEASURE_AXIS\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeMeasureAxes\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_MEASURE_AXES\"; // Removal\n\n            PIVOT_CONFIGURATOR_ACTION[\"remove\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE\"; // Sort\n\n            PIVOT_CONFIGURATOR_ACTION[\"setSort\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_SORT\"; // Filter\n\n            PIVOT_CONFIGURATOR_ACTION[\"setFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_FILTER\";\n            PIVOT_CONFIGURATOR_ACTION[\"addFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_ADD_FILTER\";\n            PIVOT_CONFIGURATOR_ACTION[\"changeFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_CHANGE_FILTER\";\n            PIVOT_CONFIGURATOR_ACTION[\"removeFilter\"] = \"PIVOT_CONFIGURATOR_ACTION_REMOVE_FILTER\"; // Drag\n\n            PIVOT_CONFIGURATOR_ACTION[\"setDragItem\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DRAGITEM\";\n            PIVOT_CONFIGURATOR_ACTION[\"drop\"] = \"PIVOT_CONFIGURATOR_ACTION_DROP\";\n            PIVOT_CONFIGURATOR_ACTION[\"setDropZone\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_ZONE\";\n            PIVOT_CONFIGURATOR_ACTION[\"setDropTarget\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_TARGET\";\n            PIVOT_CONFIGURATOR_ACTION[\"setDropDirection\"] = \"PIVOT_CONFIGURATOR_ACTION_SET_DROP_DIRECTION\";\n          })(exports.PIVOT_CONFIGURATOR_ACTION || (exports.PIVOT_CONFIGURATOR_ACTION = {}));\n          /**\n           * @hidden\n           */\n\n\n          var configuratorReducer = function (state, action) {\n            var newRows;\n            var newColumns;\n            var newMeasures;\n            var newSort;\n            var newFilter;\n            var newDragitem;\n            var newDropZone;\n            var newDropDirection;\n            var newDropTarget;\n\n            switch (action.type) {\n              case exports.PIVOT_CONFIGURATOR_ACTION.toggleSelection:\n                {\n                  if (Array.isArray(action.payload)) ;else {\n                    var payload_1 = action.payload;\n\n                    if (payload_1.type === 2 || 'aggregator' in payload_1) {\n                      if (state.measureAxes.some(function (s) {\n                        return compareAxisWithField(s, payload_1);\n                      })) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis\n                        }));\n                      } else {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.addMeasureAxis\n                        }));\n                      }\n                    } else if (payload_1.type === 'kpi') {\n                      var measures = buildKPIMeasures(payload_1);\n\n                      if (measures.every(function (m) {\n                        return state.measureAxes.some(function (s) {\n                          return compareAxisWithField(s, m);\n                        });\n                      })) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.removeMeasureAxes,\n                          payload: measures\n                        }));\n                      } else {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.addMeasureAxes,\n                          payload: measures.filter(function (m) {\n                            return !state.measureAxes.some(function (s) {\n                              return compareAxisWithField(s, m);\n                            });\n                          })\n                        }));\n                      }\n                    } else if (action.payload.kpi) {\n                      if (state.measureAxes.some(function (s) {\n                        return compareAxisWithField(s, payload_1);\n                      })) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis\n                        }));\n                      } else {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.addMeasureAxis\n                        }));\n                      }\n                    } else {\n                      if (state.columnAxes.some(function (s) {\n                        return compareAxisWithField(s, payload_1);\n                      })) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.removeColumnAxis\n                        }));\n                      } else if (state.rowAxes.some(function (s) {\n                        return compareAxisWithField(s, payload_1);\n                      })) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.removeRowAxis\n                        }));\n                      } else if (state.columnAxes && state.columnAxes.length && (!state.rowAxes || !state.rowAxes.length)) {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.addRowAxis\n                        }));\n                      } else {\n                        return configuratorReducer(state, __assign(__assign({}, action), {\n                          type: exports.PIVOT_CONFIGURATOR_ACTION.addColumnAxis\n                        }));\n                      }\n                    }\n                  }\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addColumnAxis:\n                {\n                  newColumns = __spreadArrays(state.columnAxes || [], [{\n                    name: [action.payload.defaultHierarchy || action.payload.uniqueName]\n                  }]);\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addColumnAxes:\n                {\n                  // TODO;\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeColumnAxis:\n                {\n                  newColumns = __spreadArrays((state.columnAxes || []).filter(function (s) {\n                    return !compareAxisWithField(s, action.payload);\n                  }));\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeColumnAxes:\n                {\n                  // TODO;\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addRowAxis:\n                {\n                  newRows = __spreadArrays(state.rowAxes || [], [{\n                    name: [action.payload.defaultHierarchy || action.payload.uniqueName]\n                  }]);\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addRowAxes:\n                {\n                  // TODO;\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeRowAxis:\n                {\n                  newRows = __spreadArrays((state.rowAxes || []).filter(function (s) {\n                    return !compareAxisWithField(s, action.payload);\n                  }));\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeRowAxes:\n                {\n                  // TODO;\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addMeasureAxis:\n                {\n                  newMeasures = __spreadArrays(state.measureAxes || [], [{\n                    name: [action.payload.defaultHierarchy || action.payload.uniqueName]\n                  }]);\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeMeasureAxis:\n                {\n                  newMeasures = __spreadArrays((state.measureAxes || []).filter(function (s) {\n                    return !compareAxisWithField(s, action.payload);\n                  }));\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addMeasureAxes:\n                {\n                  newMeasures = __spreadArrays(state.measureAxes || [], (action.payload || []).map(function (p) {\n                    return {\n                      name: [p.defaultHierarchy || p.uniqueName]\n                    };\n                  }));\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeMeasureAxes:\n                {\n                  newMeasures = __spreadArrays((state.measureAxes || []).filter(function (s) {\n                    return !action.payload.some(function (p) {\n                      return compareAxisWithField(s, p);\n                    });\n                  }));\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.remove:\n                {\n                  if (state.columnAxes.some(function (s) {\n                    return compareAxes(s, action.payload);\n                  })) {\n                    newColumns = __spreadArrays(state.columnAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  if (state.rowAxes.some(function (s) {\n                    return compareAxes(s, action.payload);\n                  })) {\n                    newRows = __spreadArrays(state.rowAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  if (state.measureAxes.some(function (s) {\n                    return compareAxes(s, action.payload);\n                  })) {\n                    newMeasures = __spreadArrays(state.measureAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  break;\n                }\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setDragItem:\n                newDragitem = action.payload;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setDropZone:\n                newDropZone = action.payload;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setDropTarget:\n                newDropTarget = action.payload;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setDropDirection:\n                newDropDirection = action.payload;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.drop:\n                if (state.dragItem && state.dropZone) {\n                  var currentColumn = state.columnAxes.find(function (s) {\n                    return compareAxes(s, action.payload);\n                  });\n                  var currentRow = state.rowAxes.find(function (s) {\n                    return compareAxes(s, action.payload);\n                  });\n                  var currentMeasure = state.measureAxes.find(function (s) {\n                    return compareAxes(s, action.payload);\n                  });\n                  var current = void 0;\n\n                  if (currentColumn) {\n                    current = currentColumn;\n                    newColumns = __spreadArrays(state.columnAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  if (currentRow) {\n                    current = currentRow;\n                    newRows = __spreadArrays(state.rowAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  if (currentMeasure) {\n                    current = currentMeasure;\n                    newMeasures = __spreadArrays(state.measureAxes.filter(function (s) {\n                      return !compareAxes(s, action.payload);\n                    }));\n                  }\n\n                  switch (state.dropZone) {\n                    case 'columnAxes':\n                      {\n                        newColumns = newColumns || state.columnAxes.slice();\n                        var insertAtIndex = -1;\n\n                        if (state.dropTarget && state.dropDirection) {\n                          var offset = state.dropDirection ? state.dropDirection === 'before' ? 0 : 1 : 0;\n                          insertAtIndex = newColumns.findIndex(function (c) {\n                            return compareAxes(c, state.dropTarget);\n                          }) + offset;\n                        }\n\n                        if (insertAtIndex >= 0) {\n                          newColumns.splice(insertAtIndex, 0, current);\n                        } else {\n                          newColumns.push(current);\n                        }\n\n                        break;\n                      }\n\n                    case 'rowAxes':\n                      {\n                        newRows = newRows || state.rowAxes.slice();\n                        var insertAtIndex = -1;\n\n                        if (state.dropTarget && state.dropDirection) {\n                          var offset = state.dropDirection ? state.dropDirection === 'before' ? 0 : 1 : 0;\n                          insertAtIndex = newRows.findIndex(function (c) {\n                            return compareAxes(c, state.dropTarget);\n                          }) + offset;\n                        }\n\n                        if (insertAtIndex >= 0) {\n                          newRows.splice(insertAtIndex, 0, current);\n                        } else {\n                          newRows.push(current);\n                        }\n\n                        break;\n                      }\n\n                    case 'measureAxes':\n                      {\n                        newMeasures = newMeasures || state.measureAxes.slice();\n                        var insertAtIndex = -1;\n\n                        if (state.dropTarget && state.dropDirection) {\n                          var offset = state.dropDirection ? state.dropDirection === 'before' ? 0 : 1 : 0;\n                          insertAtIndex = newMeasures.findIndex(function (c) {\n                            return compareAxes(c, state.dropTarget);\n                          }) + offset;\n                        }\n\n                        if (insertAtIndex >= 0) {\n                          newMeasures.splice(insertAtIndex, 0, current);\n                        } else {\n                          newMeasures.push(current);\n                        }\n\n                        break;\n                      }\n                  }\n                }\n\n                newDragitem = null;\n                newDropZone = null;\n                newDropTarget = null;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setSort:\n                newSort = action.payload;\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.setFilter:\n                if (Array.isArray(action.payload)) {\n                  newFilter = action.payload;\n                } else {\n                  newFilter = [action.payload];\n                }\n\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.addFilter:\n                newFilter = (state.filter || []).slice();\n\n                if (Array.isArray(action.payload)) {\n                  newFilter.push.apply(newFilter, action.payload);\n                } else {\n                  newFilter.push(action.payload);\n                }\n\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.changeFilter:\n                newFilter = Array.isArray(action.payload) ? (state.filter || []).map(function (f) {\n                  return action.payload.some(function (a) {\n                    return a.field === f.field;\n                  }) ? action.payload.find(function (a) {\n                    return a.field === f.field;\n                  }) : f;\n                }) : (state.filter || []).map(function (f) {\n                  return f.field === action.payload.field ? action.payload : f;\n                });\n                break;\n\n              case exports.PIVOT_CONFIGURATOR_ACTION.removeFilter:\n                newFilter = (state.filter || []).slice();\n\n                if (Array.isArray(action.payload)) {\n                  newFilter = newFilter.filter(function (f) {\n                    return !action.payload.some(function (p) {\n                      return p.field === f.field && p.operator === f.operator;\n                    });\n                  });\n                } else {\n                  newFilter = newFilter.filter(function (f) {\n                    return !(f.field === action.payload.field && f.operator === action.payload.operator);\n                  });\n                }\n\n                break;\n            }\n\n            return {\n              dragItem: newDragitem,\n              dropTarget: newDropTarget,\n              dropDirection: newDropDirection,\n              dropZone: newDropZone,\n              columnAxes: newColumns,\n              rowAxes: newRows,\n              measureAxes: newMeasures,\n              filter: newFilter,\n              sort: newSort\n            };\n          };\n\n          exports.addKPI = addKPI;\n          exports.buildKPIMeasures = buildKPIMeasures;\n          exports.compareAxes = compareAxes;\n          exports.configuratorReducer = configuratorReducer;\n          exports.createAxisDescriptors = createAxisDescriptors;\n          exports.createDataState = createDataState;\n          exports.createDiscoverBody = createDiscoverBody;\n          exports.createRequestBody = createRequestBody;\n          exports.discoverCommands = discoverCommands;\n          exports.fetchData = fetchData;\n          exports.fetchDiscover = fetchDiscover;\n          exports.headersReducer = headersReducer;\n          exports.parseResponse = parseResponse;\n          exports.setFilter = setFilter;\n          exports.setSort = setSort;\n          exports.toColumns = toColumns;\n          exports.toData = toData;\n          exports.toRows = toRows;\n          exports.toTree = toTree;\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          return exports;\n        }({});\n      })();\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}