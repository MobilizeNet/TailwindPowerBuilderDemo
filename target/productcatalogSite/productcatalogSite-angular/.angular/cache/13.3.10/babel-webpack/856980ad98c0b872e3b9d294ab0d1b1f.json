{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1683);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  },\n\n  /***/\n  1683:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1678)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\"; // WARNING: removing the following jshint declaration and turning\n      // == into === to make JSHint happy will break functionality.\n\n      /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */\n\n      /* jshint latedef: false */\n\n      var util = kendo.util;\n      var spreadsheet = kendo.spreadsheet;\n      var Ref = spreadsheet.Ref;\n      var RangeRef = spreadsheet.RangeRef;\n      var CellRef = spreadsheet.CellRef;\n      var NameRef = spreadsheet.NameRef;\n      var exports = spreadsheet.calc;\n      var runtime = exports.runtime; // Excel formula parser and compiler to JS.\n      // some code adapted from http://lisperator.net/pltut/\n      // these two will hold the same operators, except that when the comma is used as decimal\n      // separator, the union operator must be the semicolon (;) instead of comma.\n\n      var OPERATORS_STANDARD = Object.create(null);\n      var OPERATORS_COMMA = Object.create(null);\n\n      (function (ops) {\n        ops.forEach(function (cls, i) {\n          cls.forEach(function (op) {\n            OPERATORS_STANDARD[op] = ops.length - i;\n            OPERATORS_COMMA[op == \",\" ? \";\" : op] = ops.length - i;\n          });\n        });\n      })([[\":\"], [\" \"], [\",\"], [\"%\"], [\"^\"], [\"*\", \"/\"], [\"+\", \"-\"], [\"&\"], [\"=\", \"<\", \">\", \"<=\", \">=\", \"<>\"]]);\n\n      var OPERATORS = OPERATORS_STANDARD;\n      var SEPARATORS = {\n        DEC: \".\",\n        ARG: \",\",\n        COL: \",\"\n      };\n\n      function setDecimalSeparator(sep) {\n        SEPARATORS.DEC = sep;\n        SEPARATORS.ARG = sep == \",\" ? \";\" : \",\";\n        SEPARATORS.COL = sep == \",\" ? \"\\\\\" : \",\";\n        OPERATORS = sep == \",\" ? OPERATORS_COMMA : OPERATORS_STANDARD;\n      }\n\n      exports.withDecimalSeparator = function (sep, f) {\n        if (SEPARATORS.DEC == sep) {\n          return f();\n        }\n\n        var save = SEPARATORS.DEC;\n        setDecimalSeparator(sep);\n\n        try {\n          return f();\n        } finally {\n          setDecimalSeparator(save);\n        }\n      };\n\n      exports._separators = SEPARATORS;\n      var ParseError = kendo.Class.extend({\n        init: function ParseError(message, pos) {\n          this.message = message;\n          this.pos = pos;\n        },\n        toString: function () {\n          return this.message;\n        }\n      });\n      var TRUE = {\n        type: \"bool\",\n        value: true\n      };\n      var FALSE = {\n        type: \"bool\",\n        value: false\n      };\n\n      function getcol(str) {\n        str = str.toUpperCase();\n\n        for (var col = 0, i = 0; i < str.length; ++i) {\n          col = col * 26 + str.charCodeAt(i) - 64;\n        }\n\n        return col - 1;\n      }\n\n      function getrow(str) {\n        return parseInt(str, 10) - 1;\n      }\n\n      function parseReference(name, noThrow) {\n        if (name.toLowerCase() == \"#sheet\") {\n          return spreadsheet.SHEETREF;\n        }\n\n        OUT: {\n          // this is redundant, but let's keep it fast for the most\n          // common case — A1.  If this fails, we'll try to employ the\n          // whole tokenizer.\n          var m;\n\n          if (m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name)) {\n            var row = getrow(m[4]),\n                col = getcol(m[2]);\n\n            if (row < 0x100000 && col < 0x4000) {\n              return new CellRef(getrow(m[4]), getcol(m[2]));\n            } // no NameRef-s from this function\n\n\n            break OUT; // jshint ignore:line\n          }\n\n          var stream = TokenStream(name, {});\n          var a = [];\n\n          while (true) {\n            var ref = stream.next();\n\n            if (ref instanceof CellRef) {\n              // this function always makes absolute references\n              ref.rel = 0;\n            } else if (ref instanceof RangeRef) {\n              ref.topLeft.rel = 0;\n              ref.bottomRight.rel = 0;\n            } else {\n              break OUT; // jshint ignore:line\n            }\n\n            a.push(ref);\n\n            if (stream.eof()) {\n              break;\n            }\n\n            if (!stream.is(\"op\", SEPARATORS.ARG)) {\n              break OUT; // jshint ignore:line\n            }\n\n            stream.next();\n          }\n\n          return a.length == 1 ? a[0] : new spreadsheet.UnionRef(a);\n        }\n\n        if (!noThrow) {\n          throw new Error(\"Cannot parse reference: \" + name);\n        }\n      }\n\n      function parseFormula(sheet, row, col, input) {\n        var refs = [];\n        input = TokenStream(input, {\n          row: row,\n          col: col\n        });\n        var is = input.is;\n        return {\n          type: \"exp\",\n          ast: parseExpression(true),\n          refs: refs,\n          sheet: sheet,\n          row: row,\n          col: col\n        };\n\n        function addReference(ref) {\n          ref.index = refs.length;\n          refs.push(ref);\n          return ref;\n        }\n\n        function skip(type, value, allowEOF) {\n          if (is(type, value)) {\n            return input.next();\n          } else {\n            var tok = input.peek();\n\n            if (tok) {\n              input.croak(\"Expected \" + type + \" «\" + value + \"» but found \" + tok.type + \" «\" + tok.value + \"»\");\n            } else if (!allowEOF) {\n              input.croak(\"Expected \" + type + \" «\" + value + \"»\");\n            }\n          }\n        }\n\n        function parseExpression(commas) {\n          return maybeBinary(maybeIntersect(parseAtom()), 0, commas);\n        }\n\n        function parseSymbol(tok) {\n          if (tok.upper == \"TRUE\" || tok.upper == \"FALSE\") {\n            return tok.upper == \"TRUE\" ? TRUE : FALSE;\n          }\n\n          return addReference(new NameRef(tok.value));\n        }\n\n        function parseFuncall() {\n          var fname = input.next();\n          fname = fname.value;\n          skip(\"punc\", \"(\");\n          var args = [];\n\n          while (1) {\n            if (is(\"punc\", \")\")) {\n              break;\n            }\n\n            if (is(\"op\", SEPARATORS.ARG)) {\n              args.push({\n                type: \"null\"\n              });\n              input.next();\n              continue;\n            }\n\n            args.push(parseExpression(false));\n\n            if (input.eof() || is(\"punc\", \")\")) {\n              break;\n            }\n\n            skip(\"op\", SEPARATORS.ARG);\n          }\n\n          skip(\"punc\", \")\", true);\n          return {\n            type: \"func\",\n            func: fname,\n            args: args\n          };\n        }\n\n        function fixReference(ref) {\n          if (!ref.hasSheet()) {\n            ref.setSheet(sheet);\n          }\n\n          return addReference(ref);\n        }\n\n        function parseAtom() {\n          var exp;\n\n          if (is(\"ref\")) {\n            exp = fixReference(input.next());\n          } else if (is(\"func\")) {\n            exp = parseFuncall();\n          } else if (is(\"punc\", \"(\")) {\n            input.next();\n            exp = parseExpression(true);\n            skip(\"punc\", \")\", true);\n          } else if (is(\"punc\", \"{\")) {\n            input.next();\n            exp = parseArray();\n            skip(\"punc\", \"}\", true);\n          } else if (is(\"num\") || is(\"str\") || is(\"error\")) {\n            exp = input.next();\n          } else if (is(\"sym\")) {\n            exp = parseSymbol(input.next());\n          } else if (is(\"op\", \"+\") || is(\"op\", \"-\")) {\n            exp = {\n              type: \"prefix\",\n              op: input.next().value,\n              exp: parseAtom()\n            };\n          } else if (!input.peek()) {\n            input.croak(\"Incomplete expression\");\n          } else if (is(\"punc\", \"[\")) {\n            input.croak(\"External reference not supported\");\n          } else {\n            input.croak(\"Parse error\");\n          }\n\n          return maybePercent(exp);\n        }\n\n        function parseArray() {\n          var row = [],\n              value = [row],\n              first = true;\n\n          while (!input.eof() && !is(\"punc\", \"}\")) {\n            if (first) {\n              first = false;\n            } else if (is(null, \";\")) {\n              value.push(row = []);\n              input.next();\n            } else {\n              skip(null, SEPARATORS.COL);\n            }\n\n            row.push(parseExpression(false));\n          }\n\n          return {\n            type: \"matrix\",\n            value: value\n          };\n        }\n\n        function maybeIntersect(exp) {\n          if (is(\"punc\", \"(\") || is(\"ref\") || is(\"num\") || is(\"func\")) {\n            return {\n              type: \"binary\",\n              op: \" \",\n              left: exp,\n              right: parseExpression(false)\n            };\n          } else {\n            return exp;\n          }\n        }\n\n        function maybePercent(exp) {\n          if (is(\"op\", \"%\")) {\n            input.next();\n            return maybePercent({\n              type: \"postfix\",\n              op: \"%\",\n              exp: exp\n            });\n          } else {\n            return exp;\n          }\n        }\n\n        function maybeBinary(left, my_prec, commas) {\n          var tok = is(\"op\");\n\n          if (tok && (commas || tok.value != SEPARATORS.ARG)) {\n            var his_prec = OPERATORS[tok.value];\n\n            if (his_prec > my_prec) {\n              input.next();\n              var right = maybeBinary(parseAtom(), his_prec, commas);\n              return maybeBinary({\n                type: \"binary\",\n                op: tok.value == \";\" ? \",\" : tok.value,\n                // translate union back to comma\n                left: left,\n                right: right\n              }, my_prec, commas);\n            }\n          }\n\n          return left;\n        }\n      }\n\n      function parseNameDefinition(name, def) {\n        var nameRef = parseFormula(null, 0, 0, name);\n\n        if (!(nameRef.ast instanceof NameRef)) {\n          throw new ParseError(\"Invalid name: \" + name);\n        }\n\n        nameRef = nameRef.ast;\n\n        if (!(def instanceof Ref)) {\n          var defAST = parseFormula(nameRef.sheet, 0, 0, def);\n\n          if (defAST.ast instanceof Ref) {\n            def = defAST.ast; // single reference\n          } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {\n            def = defAST.ast.value; // constant\n          } else {\n            def = makeFormula(defAST); // formula\n          }\n        }\n\n        return {\n          name: nameRef,\n          value: def\n        };\n      }\n\n      var makeClosure = function (cache) {\n        return function (code) {\n          var f = cache[code];\n\n          if (!f) {\n            f = cache[code] = new Function(\"'use strict';return(\" + code + \")\")();\n          }\n\n          return f;\n        };\n      }(Object.create(null));\n\n      function makePrinter(exp) {\n        return makeClosure(\"function(row, col, mod){return(\" + print(exp.ast, exp, 0) + \")}\");\n\n        function print(node, parent, prec) {\n          // jshint ignore:line, because you are stupid.\n          switch (node.type) {\n            case \"num\":\n              return \"(kendo.spreadsheet.calc._separators.DEC == '.' ? \" + JSON.stringify(JSON.stringify(node.value)) + \" : \" + JSON.stringify(JSON.stringify(node.value)) + \".replace('.' , kendo.spreadsheet.calc._separators.DEC))\";\n\n            case \"bool\":\n              return JSON.stringify(node.value);\n\n            case \"error\":\n              return JSON.stringify(\"#\" + node.value);\n\n            case \"str\":\n              return JSON.stringify(JSON.stringify(node.value));\n\n            case \"ref\":\n              return \"this.refs[\" + node.index + \"].print(row, col, mod)\";\n\n            case \"prefix\":\n              return withParens(function () {\n                return JSON.stringify(node.op) + \" + \" + print(node.exp, node, OPERATORS[node.op]);\n              });\n\n            case \"postfix\":\n              return withParens(function () {\n                return print(node.exp, node, OPERATORS[node.op]) + \" + \" + JSON.stringify(node.op);\n              });\n\n            case \"binary\":\n              return withParens(function () {\n                var left = parenthesize(print(node.left, node, OPERATORS[node.op]), node.left instanceof NameRef && node.op == \":\");\n                var right = parenthesize(print(node.right, node, OPERATORS[node.op]), node.right instanceof NameRef && node.op == \":\");\n\n                if (/^[,;]/.test(node.op)) {\n                  return left + \" + kendo.spreadsheet.calc._separators.ARG + \" + right;\n                } else {\n                  return left + \" + \" + JSON.stringify(node.op) + \" + \" + right;\n                }\n              });\n\n            case \"func\":\n              return JSON.stringify(node.func + \"(\") + \" + \" + (node.args.length > 0 ? node.args.map(function (arg) {\n                return print(arg, node, 0);\n              }).join(\" + kendo.spreadsheet.calc._separators.ARG + ' ' + \") : \"''\") + \" + ')'\";\n\n            case \"matrix\":\n              return \"'{ ' + \" + node.value.map(function (el) {\n                return el.map(function (el) {\n                  return print(el, node, 0);\n                }).join(\" + kendo.spreadsheet.calc._separators.COL + ' ' + \");\n              }).join(\" + '; ' + \") + \"+ ' }'\";\n\n            case \"null\":\n              return \"''\";\n          }\n\n          throw new Error(\"Cannot make printer for node \" + node.type);\n\n          function withParens(f) {\n            var op = node.op;\n            var needParens = OPERATORS[op] < prec || !prec && op == \",\" || parent.type == \"prefix\" && prec == OPERATORS[op] && parent.op == \"-\" || parent.type == \"binary\" && prec == OPERATORS[op] && node === parent.right;\n            return parenthesize(f(), needParens);\n          }\n        }\n\n        function parenthesize(code, cond) {\n          return cond ? \"'(' + \" + code + \" + ')'\" : code;\n        }\n      }\n\n      function toCPS(ast, k) {\n        var GENSYM = 0;\n        return cps(ast, k);\n\n        function cps(node, k) {\n          switch (node.type) {\n            case \"ref\":\n              return cpsRef(node, k);\n\n            case \"num\":\n            case \"str\":\n            case \"null\":\n            case \"error\":\n            case \"bool\":\n              return cpsAtom(node, k);\n\n            case \"prefix\":\n            case \"postfix\":\n              return cpsUnary(node, k);\n\n            case \"binary\":\n              return cpsBinary(node, k);\n\n            case \"func\":\n              return cpsFunc(node, k);\n\n            case \"lambda\":\n              return cpsLambda(node, k);\n\n            case \"matrix\":\n              return cpsMatrix(node.value, k, true);\n          }\n\n          throw new Error(\"Cannot CPS \" + node.type);\n        }\n\n        function cpsRef(node, k) {\n          return node.ref == \"name\" ? cpsNameRef(node, k) : cpsAtom(node, k);\n        }\n\n        function cpsAtom(node, k) {\n          return k(node);\n        }\n\n        function cpsNameRef(node, k) {\n          return {\n            type: \"func\",\n            func: \",getname\",\n            args: [makeContinuation(k), node]\n          };\n        }\n\n        function cpsUnary(node, k) {\n          return cps({\n            type: \"func\",\n            func: \"unary\" + node.op,\n            args: [node.exp]\n          }, k);\n        }\n\n        function cpsBinary(node, k) {\n          return cps({\n            type: \"func\",\n            func: \"binary\" + node.op,\n            args: [node.left, node.right]\n          }, k);\n        }\n\n        function cpsIf(co, th, el, k) {\n          return cps(co, function (co) {\n            // compile THEN and ELSE into a lambda which takes a callback to invoke with the\n            // result of the branches, and the IF itself will become a call the internal \"if\"\n            // function.\n            var rest = makeContinuation(k);\n            var thenK = gensym(\"T\");\n            var elseK = gensym(\"E\");\n            return {\n              type: \"func\",\n              func: \"if\",\n              args: [rest, co, // condition\n              {\n                // then\n                type: \"lambda\",\n                vars: [thenK],\n                body: cps(th || TRUE, function (th) {\n                  return {\n                    type: \"call\",\n                    func: {\n                      type: \"var\",\n                      name: thenK\n                    },\n                    args: [th]\n                  };\n                })\n              }, {\n                // else\n                type: \"lambda\",\n                vars: [elseK],\n                body: cps(el || FALSE, function (el) {\n                  return {\n                    type: \"call\",\n                    func: {\n                      type: \"var\",\n                      name: elseK\n                    },\n                    args: [el]\n                  };\n                })\n              }]\n            };\n          });\n        }\n\n        function cpsAnd(args, k) {\n          if (args.length === 0) {\n            return cpsAtom(TRUE, k);\n          }\n\n          return cps({\n            type: \"func\",\n            func: \"IF\",\n            args: [// first item\n            args[0], // if true, apply AND for the rest\n            {\n              type: \"func\",\n              func: \"AND\",\n              args: args.slice(1)\n            }, // otherwise return false\n            FALSE]\n          }, k);\n        }\n\n        function cpsOr(args, k) {\n          if (args.length === 0) {\n            return cpsAtom(FALSE, k);\n          }\n\n          return cps({\n            type: \"func\",\n            func: \"IF\",\n            args: [// first item\n            args[0], // if true, return true\n            TRUE, // otherwise apply OR for the rest\n            {\n              type: \"func\",\n              func: \"OR\",\n              args: args.slice(1)\n            }]\n          }, k);\n        }\n\n        function cpsFunc(node, k) {\n          switch (node.func.toLowerCase()) {\n            case \"if\":\n              return cpsIf(node.args[0], node.args[1], node.args[2], k);\n\n            case \"and\":\n              return cpsAnd(node.args, k);\n\n            case \"or\":\n              return cpsOr(node.args, k);\n\n            case \"true\":\n              return k(TRUE);\n\n            case \"false\":\n              return k(FALSE);\n          } // actual function\n\n\n          return function loop(args, i) {\n            if (i == node.args.length) {\n              return {\n                type: \"func\",\n                func: node.func,\n                args: args\n              };\n            } else {\n              return cps(node.args[i], function (value) {\n                return loop(args.concat([value]), i + 1);\n              });\n            }\n          }([makeContinuation(k)], 0);\n        }\n\n        function cpsLambda(node, k) {\n          var cont = gensym(\"K\");\n          var body = cps(node.body, function (body) {\n            return {\n              type: \"call\",\n              func: {\n                type: \"var\",\n                value: cont\n              },\n              args: [body]\n            };\n          });\n          return k({\n            type: \"lambda\",\n            vars: [cont].concat(node.vars),\n            body: body\n          });\n        }\n\n        function cpsMatrix(elements, k, isMatrix) {\n          var a = [];\n          return function loop(i) {\n            if (i == elements.length) {\n              return k({\n                type: \"matrix\",\n                value: a\n              });\n            } else {\n              return (isMatrix ? cpsMatrix : cps)(elements[i], function (val) {\n                a[i] = val;\n                return loop(i + 1);\n              });\n            }\n          }(0);\n        }\n\n        function makeContinuation(k) {\n          var cont = gensym(\"R\");\n          return {\n            type: \"lambda\",\n            vars: [cont],\n            body: k({\n              type: \"var\",\n              name: cont\n            })\n          };\n        }\n\n        function gensym(name) {\n          if (!name) {\n            name = \"\";\n          }\n\n          name = \"_\" + name;\n          return name + ++GENSYM;\n        }\n      }\n\n      var FORMULA_CACHE = Object.create(null);\n\n      function makeFormula(exp) {\n        var printer = makePrinter(exp);\n        var hash = printer.call(exp); // needs .refs\n\n        var formula = FORMULA_CACHE[hash];\n\n        if (formula) {\n          // we need to clone because formulas cache the result; even if the formula is the same,\n          // its value will depend on its location, hence we need different objects.  Still, using\n          // this cache is a good idea because we'll reuse the same refs array, handler and\n          // printer instead of allocating new ones (and we skip compiling it).\n          return formula.clone(exp.sheet, exp.row, exp.col);\n        }\n\n        var code = js(toCPS(exp.ast, function (ret) {\n          return {\n            type: \"return\",\n            value: ret\n          };\n        }));\n        code = [\"function(){\", \"var context = this, refs = context.formula.absrefs\", code, \"}\"].join(\";\\n\");\n        formula = new runtime.Formula(exp.refs, makeClosure(code), printer, exp.sheet, exp.row, exp.col);\n        FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);\n        return formula;\n\n        function js(node) {\n          var type = node.type;\n\n          if (type == \"num\") {\n            return node.value + \"\";\n          } else if (type == \"str\") {\n            return JSON.stringify(node.value);\n          } else if (type == \"error\") {\n            return \"context.error(\" + JSON.stringify(node.value) + \")\";\n          } else if (type == \"return\") {\n            return \"context.resolve(\" + js(node.value) + \")\";\n          } else if (type == \"func\") {\n            return \"context.func(\" + JSON.stringify(node.func) + \", \" + js(node.args[0]) + \", \" // the callback\n            + jsArray(node.args.slice(1)) // the arguments\n            + \")\";\n          } else if (type == \"call\") {\n            return js(node.func) + \"(\" + node.args.map(js).join(\", \") + \")\";\n          } else if (type == \"ref\") {\n            return \"refs[\" + node.index + \"]\";\n          } else if (type == \"bool\") {\n            return \"\" + node.value;\n          } else if (type == \"if\") {\n            return \"(context.bool(\" + js(node.co) + \") ? \" + js(node.th) + \" : \" + js(node.el) + \")\";\n          } else if (type == \"lambda\") {\n            return \"(function(\" + node.vars.join(\", \") + \"){ return(\" + js(node.body) + \") })\";\n          } else if (type == \"var\") {\n            return node.name;\n          } else if (type == \"matrix\") {\n            return jsArray(node.value);\n          } else if (type == \"null\") {\n            return \"null\";\n          } else {\n            throw new Error(\"Cannot compile expression \" + type);\n          }\n        }\n\n        function jsArray(a) {\n          return \"[ \" + a.map(js).join(\", \") + \" ]\";\n        }\n      }\n\n      function identity(x) {\n        return x;\n      }\n\n      function TokenStream(input, options) {\n        input = RawTokenStream(InputStream(input), options);\n        var ahead = input.ahead;\n        var skip = input.skip;\n        var token = null;\n        var fixCell = options.row != null && options.col != null ? function (cell) {\n          if (cell.rel & 1) {\n            cell.col -= options.col;\n          }\n\n          if (cell.rel & 2) {\n            cell.row -= options.row;\n          }\n\n          return cell;\n        } : identity;\n        var addPos = options.forEditor ? function (thing, startToken, endToken) {\n          thing.begin = startToken.begin;\n          thing.end = endToken.end;\n          return thing;\n        } : identity;\n        return {\n          peek: peek,\n          next: next,\n          croak: input.croak,\n          eof: input.eof,\n          is: is\n        };\n\n        function is(type, value) {\n          var tok = peek();\n          return tok != null && (type == null || tok.type === type) && (value == null || tok.value === value) ? tok : null;\n        }\n\n        function peek() {\n          if (token == null) {\n            token = readNext();\n          }\n\n          return token;\n        }\n\n        function next() {\n          if (token != null) {\n            var tmp = token;\n            token = null;\n            return tmp;\n          }\n\n          return readNext();\n        }\n\n        function readNext() {\n          var ret;\n          var t = input.peek();\n\n          if (t) {\n            if (t.type == \"sym\" || t.type == \"rc\" || t.type == \"num\") {\n              ret = ahead(8, refRange3D) || ahead(6, refCell3D) || ahead(6, refSheetRange) || ahead(4, refSheetCell) || ahead(4, refRange) || ahead(2, refCell) || ahead(2, funcall);\n            }\n\n            if (!ret) {\n              ret = input.next();\n            }\n          }\n\n          return ret;\n        }\n\n        function toCell(tok, isFirst) {\n          if (tok.type == \"rc\") {\n            // RC notation is read properly without knowing where\n            // we are, so no need to fixCell on this one.\n            // However, if only absolute refs were asked for (from\n            // i.e. parseReference) I feel it's alright to yell\n            // about it here.\n            if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {\n              input.croak(\"Cannot read relative cell in RC notation\");\n            }\n\n            return new CellRef(tok.row, tok.col, tok.rel);\n          }\n\n          if (tok.type == \"num\") {\n            if (tok.value <= 1048577) {\n              // whole row\n              return fixCell(new CellRef(getrow(tok.value), isFirst ? -Infinity : +Infinity, 2));\n            } else {\n              return null;\n            }\n          } // otherwise it's \"sym\".  The OOXML spec (SpreadsheetML\n          // 18.2.5) defines the maximum value to be interpreted as\n          // a cell reference to be XFD1048576.\n\n\n          var name = tok.value;\n          var m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name);\n\n          if (m) {\n            var row = getrow(m[4]),\n                col = getcol(m[2]);\n\n            if (row <= 1048576 && col <= 16383) {\n              return fixCell(new CellRef(getrow(m[4]), getcol(m[2]), (m[1] ? 0 : 1) | (m[3] ? 0 : 2)));\n            } else {\n              return null;\n            }\n          }\n\n          var abs = name.charAt(0) == \"$\";\n\n          if (abs) {\n            name = name.substr(1);\n          }\n\n          if (/^\\d+$/.test(name)) {\n            var row = getrow(name);\n\n            if (row <= 1048576) {\n              return fixCell(new CellRef(getrow(name), isFirst ? -Infinity : +Infinity, abs ? 0 : 2));\n            }\n          } else {\n            var col = getcol(name);\n\n            if (col <= 16383) {\n              return fixCell(new CellRef(isFirst ? -Infinity : +Infinity, getcol(name), abs ? 0 : 1));\n            }\n          }\n        } // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)\n\n\n        function refRange3D(a, b, c, d, e, f, g, h) {\n          if (a.type == \"sym\" && b.type == \"op\" && b.value == \":\" && c.type == \"sym\" && d.type == \"punc\" && d.value == \"!\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && f.type == \"op\" && f.value == \":\" && (g.type == \"sym\" || g.type == \"rc\" || g.type == \"num\" && g.value == g.value | 0) && g.type == e.type && !(h.type == \"punc\" && h.value == \"(\" && !g.space)) {\n            var tl = toCell(e, true),\n                br = toCell(g, false);\n\n            if (tl && br) {\n              // skip them except the last one, we only wanted to\n              // ensure it's not paren.\n              skip(7);\n              return addPos(new RangeRef(tl.setSheet(a.value, true), br.setSheet(c.value, true)).setSheet(a.value, true), a, g);\n            }\n          }\n        } // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)\n\n\n        function refCell3D(a, b, c, d, e, f) {\n          if (a.type == \"sym\" && b.type == \"op\" && b.value == \":\" && c.type == \"sym\" && d.type == \"punc\" && d.value == \"!\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && !(f.type == \"punc\" && f.value == \"(\" && !e.space)) {\n            var tl = toCell(e);\n\n            if (tl) {\n              skip(5);\n              var br = tl.clone();\n              return addPos(new RangeRef(tl.setSheet(a.value, true), br.setSheet(c.value, true)).setSheet(a.value, true), a, e);\n            }\n          }\n        } // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)\n\n\n        function refSheetRange(a, b, c, d, e, f) {\n          if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"!\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && d.type == \"op\" && d.value == \":\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && !(f.type == \"punc\" && f.value == \"(\" && !e.space)) {\n            var tl = toCell(c, true),\n                br = toCell(e, false);\n\n            if (tl && br) {\n              skip(5);\n              return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);\n            }\n          }\n        } // Sheet1(a) !(b) A1(c) not followed by paren (d)\n\n\n        function refSheetCell(a, b, c, d) {\n          if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"!\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && !(d.type == \"punc\" && d.value == \"(\" && !c.space)) {\n            skip(3);\n            var x = toCell(c);\n\n            if (!x || !isFinite(x.row)) {\n              x = new NameRef(c.value);\n            }\n\n            return addPos(x.setSheet(a.value, true), a, c);\n          }\n        } // A1(a) :(b) C3(c) not followed by paren (d)\n\n\n        function refRange(a, b, c, d) {\n          if ((a.type == \"sym\" || a.type == \"rc\" || a.type == \"num\" && a.value == a.value | 0) && b.type == \"op\" && b.value == \":\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && !(d.type == \"punc\" && d.value == \"(\" && !c.space)) {\n            var tl = toCell(a, true),\n                br = toCell(c, false);\n\n            if (tl && br) {\n              skip(3);\n              return addPos(new RangeRef(tl, br), a, c);\n            }\n          }\n        } // A1(a) not followed by paren (b)\n\n\n        function refCell(a, b) {\n          if ((a.type == \"sym\" || a.type == \"rc\") && !(b.type == \"punc\" && b.value == \"(\" && !a.space)) {\n            var x = toCell(a);\n\n            if (x && isFinite(x.row) && isFinite(x.col)) {\n              skip(1);\n              return addPos(x, a, a);\n            }\n          }\n        }\n\n        function funcall(a, b) {\n          if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"(\" && !a.space) {\n            a.type = \"func\";\n            skip(1);\n            return a; // already has position\n          }\n        }\n      }\n\n      function isWhitespace(ch) {\n        return \" \\t\\r\\n\\xa0\\u200b\".indexOf(ch) >= 0;\n      }\n\n      var EOF = {\n        type: \"eof\"\n      };\n\n      function RawTokenStream(input, options) {\n        var tokens = [],\n            index = 0;\n        var readWhile = input.readWhile;\n        return {\n          next: next,\n          peek: peek,\n          eof: eof,\n          croak: input.croak,\n          ahead: ahead,\n          skip: skip\n        };\n\n        function isDigit(ch) {\n          return /[0-9]/i.test(ch);\n        }\n\n        function isIdStart(ch) {\n          return /[a-z$_]/i.test(ch) || util.isUnicodeLetter(ch);\n        }\n\n        function isId(ch) {\n          return isIdStart(ch) || isDigit(ch) || ch == \".\";\n        }\n\n        function isOpChar(ch) {\n          return ch in OPERATORS;\n        }\n\n        function isPunc(ch) {\n          return \"\\\\!;(){}[]\".indexOf(ch) >= 0;\n        }\n\n        function readNumber() {\n          // XXX: TODO: exponential notation\n          var has_dot = false;\n          var number = readWhile(function (ch) {\n            if (ch == SEPARATORS.DEC) {\n              if (has_dot) {\n                return false;\n              }\n\n              has_dot = true;\n              return true;\n            }\n\n            return isDigit(ch);\n          });\n\n          if (number == SEPARATORS.DEC) {\n            return {\n              type: \"punc\",\n              value: SEPARATORS.DEC\n            };\n          } else {\n            return {\n              type: \"num\",\n              value: parseFloat(number.replace(SEPARATORS.DEC, \".\"))\n            };\n          }\n        }\n\n        function symbol(id, quote) {\n          return {\n            type: \"sym\",\n            value: id,\n            upper: id.toUpperCase(),\n            space: isWhitespace(input.peek()),\n            quote: quote\n          };\n        }\n\n        function getRC(a, b, c) {\n          if (!a && !b && !c) {\n            return null;\n          }\n\n          if (!a && !c || a && c) {\n            var num = b ? parseInt(b, 10) : 0;\n            return a ? num : num - 1;\n          }\n        }\n\n        function readSymbol() {\n          var m = input.lookingAt(/^R(\\[)?(-?[0-9]+)?(\\])?C(\\[)?(-?[0-9]+)?(\\])?/i);\n\n          if (m) {\n            var row = getRC(m[1], m[2], m[3]);\n            var col = getRC(m[4], m[5], m[6]);\n\n            if (row != null && col != null) {\n              input.skip(m);\n              return {\n                type: \"rc\",\n                row: row,\n                col: col,\n                rel: (m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0 // col\n                ) | (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row\n\n              };\n            }\n          }\n\n          return symbol(readWhile(isId));\n        }\n\n        function readString() {\n          input.next();\n          return {\n            type: \"str\",\n            value: input.readEscaped('\"')\n          };\n        }\n\n        function readSheetName() {\n          input.next();\n          return symbol(input.readEscaped(\"'\"), true);\n        }\n\n        function readOperator() {\n          return {\n            type: \"op\",\n            value: readWhile(function (ch, op) {\n              return op + ch in OPERATORS;\n            })\n          };\n        }\n\n        function readPunc() {\n          return {\n            type: \"punc\",\n            value: input.next()\n          };\n        }\n\n        function readNext() {\n          if (input.eof()) {\n            return null;\n          }\n\n          var ch = input.peek(),\n              m;\n\n          if (ch == '\"') {\n            return readString();\n          }\n\n          if (ch == \"'\") {\n            return readSheetName();\n          }\n\n          if (isDigit(ch) || ch == SEPARATORS.DEC) {\n            return readNumber();\n          }\n\n          if (isIdStart(ch)) {\n            return readSymbol();\n          }\n\n          if (isOpChar(ch)) {\n            return readOperator();\n          }\n\n          if (isPunc(ch)) {\n            return readPunc();\n          }\n\n          if (m = input.lookingAt(/^#([a-z\\/]+)[?!]?/i)) {\n            input.skip(m);\n            return {\n              type: \"error\",\n              value: m[1]\n            };\n          }\n\n          if (!options.forEditor) {\n            input.croak(\"Can't handle character with code: \" + ch.charCodeAt(0));\n          }\n\n          return {\n            type: \"error\",\n            value: input.next()\n          };\n        }\n\n        function peek() {\n          while (tokens.length <= index) {\n            readWhile(isWhitespace);\n            var begin = input.pos();\n            var tok = readNext();\n\n            if (options.forEditor && tok) {\n              tok.begin = begin;\n              tok.end = input.pos();\n            }\n\n            tokens.push(tok);\n          }\n\n          return tokens[index];\n        }\n\n        function next() {\n          var tok = peek();\n\n          if (tok) {\n            index++;\n          }\n\n          return tok;\n        }\n\n        function ahead(n, f) {\n          var pos = index,\n              a = [];\n\n          while (n-- > 0) {\n            a.push(next() || EOF);\n          }\n\n          index = pos;\n          return f.apply(a, a);\n        }\n\n        function skip(n) {\n          index += n;\n        }\n\n        function eof() {\n          return peek() == null;\n        }\n      }\n\n      function InputStream(input) {\n        var pos = 0,\n            line = 1,\n            col = 0;\n        return {\n          next: next,\n          peek: peek,\n          eof: eof,\n          croak: croak,\n          readWhile: readWhile,\n          readEscaped: readEscaped,\n          lookingAt: lookingAt,\n          skip: skip,\n          forward: forward,\n          pos: location\n        };\n\n        function location() {\n          // jshint ignore:line, :-(\n          return pos;\n        }\n\n        function next() {\n          var ch = input.charAt(pos++);\n\n          if (ch == \"\\n\") {\n            line++;\n            col = 0;\n          } else {\n            col++;\n          }\n\n          return ch;\n        }\n\n        function peek() {\n          return input.charAt(pos);\n        }\n\n        function eof() {\n          return peek() === \"\";\n        }\n\n        function croak(msg) {\n          throw new ParseError(msg + \" (input: \" + input + \")\", pos);\n        }\n\n        function skip(ch) {\n          if (typeof ch == \"string\") {\n            if (input.substr(pos, ch.length) != ch) {\n              croak(\"Expected \" + ch);\n            }\n\n            forward(ch.length);\n          } else if (ch instanceof RegExp) {\n            var m = ch.exec(input.substr(pos));\n\n            if (m) {\n              forward(m[0].length);\n              return m;\n            }\n          } else {\n            // assuming RegExp match data\n            forward(ch[0].length);\n          }\n        }\n\n        function forward(n) {\n          while (n-- > 0) {\n            next();\n          }\n        }\n\n        function readEscaped(end) {\n          var escaped = false,\n              str = \"\";\n\n          while (!eof()) {\n            var ch = next();\n\n            if (escaped) {\n              str += ch;\n              escaped = false;\n            } else if (ch == \"\\\\\") {\n              escaped = true;\n            } else if (ch == end) {\n              break;\n            } else {\n              str += ch;\n            }\n          }\n\n          return str;\n        }\n\n        function readWhile(predicate) {\n          var str = \"\";\n\n          while (!eof() && predicate(peek(), str)) {\n            str += next();\n          }\n\n          return str;\n        }\n\n        function lookingAt(rx) {\n          return rx.exec(input.substr(pos));\n        }\n      } //// exports\n\n\n      var FORMAT_PARSERS = [];\n\n      var registerFormatParser = exports.registerFormatParser = function (p) {\n        FORMAT_PARSERS.push(p);\n      };\n\n      exports.parse = function (sheet, row, col, input, format) {\n        if (input instanceof Date) {\n          return {\n            type: \"date\",\n            value: runtime.dateToSerial(input)\n          };\n        }\n\n        if (typeof input == \"number\") {\n          return {\n            type: \"number\",\n            value: input\n          };\n        }\n\n        if (typeof input == \"boolean\") {\n          return {\n            type: \"boolean\",\n            value: input\n          };\n        }\n\n        input += \"\";\n\n        if (/^'/.test(input)) {\n          return {\n            type: \"string\",\n            value: input.substr(1)\n          };\n        } // trivial (integer) percent values; more complex formats are handled below via\n        // registerFormatParser; this case could be dropped completely.\n\n\n        if (/^-?[0-9]+%$/.test(input)) {\n          var str = input.substr(0, input.length - 1);\n          var num = parseFloat(str);\n\n          if (!isNaN(num) && num == str) {\n            return {\n              type: \"percent\",\n              value: num / 100\n            };\n          }\n        }\n\n        if (/^=/.test(input)) {\n          input = input.substr(1);\n\n          if (/\\S/.test(input)) {\n            return parseFormula(sheet, row, col, input);\n          } else {\n            return {\n              type: \"string\",\n              value: \"=\" + input\n            };\n          }\n        }\n\n        for (var i = 0; i < FORMAT_PARSERS.length; ++i) {\n          var result = FORMAT_PARSERS[i](input);\n\n          if (result) {\n            return result;\n          }\n        }\n\n        if (input.toLowerCase() == \"true\") {\n          return {\n            type: \"boolean\",\n            value: true\n          };\n        }\n\n        if (input.toLowerCase() == \"false\") {\n          return {\n            type: \"boolean\",\n            value: false\n          };\n        }\n\n        var date = runtime.parseDate(input, format);\n\n        if (date) {\n          return {\n            type: \"date\",\n            value: runtime.dateToSerial(date)\n          };\n        }\n\n        var num = parseFloat(input);\n\n        if (!isNaN(num) && input.length > 0 && num == input) {\n          format = null;\n\n          if (num != Math.floor(num)) {\n            format = \"0.\" + String(num).split(\".\")[1].replace(/\\d/g, \"0\");\n          }\n\n          return {\n            type: \"number\",\n            value: num,\n            format: format\n          };\n        }\n\n        return {\n          type: \"string\",\n          value: input\n        };\n      };\n\n      function tokenize(input, row, col) {\n        var tokens = [];\n        input = TokenStream(input, {\n          forEditor: true,\n          row: row,\n          col: col\n        });\n\n        while (!input.eof()) {\n          tokens.push(next());\n        }\n\n        var tok = tokens[0];\n\n        if (tok.type == \"op\" && tok.value == \"=\") {\n          tok.type = \"startexp\";\n        }\n\n        return tokens;\n\n        function next() {\n          var tok = input.next();\n\n          if (tok.type == \"sym\") {\n            if (tok.upper == \"TRUE\") {\n              tok.type = \"bool\";\n              tok.value = true;\n            } else if (tok.upper == \"FALSE\") {\n              tok.type = \"bool\";\n              tok.value = false;\n            }\n          } else if (tok.type == \"ref\") {\n            tok = {\n              type: \"ref\",\n              ref: row != null && col != null ? tok.absolute(row, col) : tok,\n              begin: tok.begin,\n              end: tok.end\n            };\n          }\n\n          return tok;\n        }\n      } // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of\n      // references.  This helper is called from excel-reader.js to parse them.\n\n\n      function parseSqref(input, row, col) {\n        row = row || 0;\n        col = col || 0;\n        input = TokenStream(input, {\n          row: row,\n          col: col\n        });\n        var refs = [];\n\n        while (!input.eof()) {\n          var ref = input.next();\n\n          if (ref.type != \"ref\") {\n            throw new ParseError(\"Expecting a reference but got: \" + JSON.stringify(ref));\n          }\n\n          refs.push(ref.absolute(row, col));\n        }\n\n        return refs;\n      }\n\n      exports.parseNameDefinition = parseNameDefinition;\n      exports.parseFormula = parseFormula;\n      exports.parseReference = parseReference;\n      exports.compile = makeFormula;\n      exports.parseSqref = parseSqref;\n      exports.InputStream = InputStream;\n      exports.ParseError = ParseError;\n      exports.tokenize = tokenize;\n      /* -----[ a few special formats ]----- */\n      // various time formats\n\n      registerFormatParser(function (input) {\n        var m,\n            date = 0,\n            format = \"\"; // have date part?\n\n        if (m = /^(\\d+)([-/.])(\\d+)\\2(\\d{2}(?:\\d{2})?)(\\s*)/.exec(input)) {\n          var mo = parseInt(m[1], 10);\n          var sep = m[2];\n          var da = parseInt(m[3], 10);\n          var yr = parseInt(m[4], 10);\n\n          if (yr < 30) {\n            yr += 2000;\n          } else if (yr < 100) {\n            yr += 1900;\n          }\n\n          var monthFirst = true;\n\n          if (mo > 12) {\n            var tmp = mo;\n            mo = da;\n            da = tmp;\n            monthFirst = false;\n          }\n\n          if (!runtime.validDate(yr, mo, da)) {\n            return null;\n          }\n\n          date = runtime.packDate(yr, mo - 1, da);\n\n          if (date < 0) {\n            date--;\n          }\n\n          if (monthFirst) {\n            format = [\"mm\", \"dd\", \"yyyy\"].join(sep);\n          } else {\n            format = [\"dd\", \"mm\", \"yyyy\"].join(sep);\n          }\n\n          format += m[5];\n          input = input.substr(m[0].length); // skip the date\n        } // hh:mm\n\n\n        if (m = /^(\\d+):(\\d+)$/.exec(input)) {\n          var hh = parseInt(m[1], 10);\n          var mm = parseInt(m[2], 10);\n          return {\n            type: \"date\",\n            format: format + \"hh:mm\",\n            value: date + runtime.packTime(hh, mm, 0, 0)\n          };\n        } // mm:ss.ms\n\n\n        if (m = /^(\\d+):(\\d+)(\\.\\d+)$/.exec(input)) {\n          var mm = parseInt(m[1], 10);\n          var ss = parseInt(m[2], 10);\n          var ms = parseFloat(m[3]) * 1000;\n          return {\n            type: \"date\",\n            format: format + \"mm:ss.00\",\n            value: date + runtime.packTime(0, mm, ss, ms)\n          };\n        } // hh:mm:ss\n\n\n        if (m = /^(\\d+):(\\d+):(\\d+)$/.exec(input)) {\n          var hh = parseInt(m[1], 10);\n          var mm = parseInt(m[2], 10);\n          var ss = parseInt(m[3], 10);\n          return {\n            type: \"date\",\n            format: format + \"hh:mm:ss\",\n            value: date + runtime.packTime(hh, mm, ss, 0)\n          };\n        } // hh:mm:ss.ms\n\n\n        if (m = /^(\\d+):(\\d+):(\\d+)(\\.\\d+)$/.exec(input)) {\n          var hh = parseInt(m[1], 10);\n          var mm = parseInt(m[2], 10);\n          var ss = parseInt(m[3], 10);\n          var ms = parseFloat(m[4]) * 1000;\n          return {\n            type: \"date\",\n            format: format + \"hh:mm:ss.00\",\n            value: date + runtime.packTime(hh, mm, ss, ms)\n          };\n        }\n      }); // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,\n      // `$1234`, `123,456.78 $` etc.  I apologize for this code.\n\n      registerFormatParser(function (input) {\n        var m, n;\n        var culture = kendo.culture();\n        var comma = culture.numberFormat[\",\"];\n        var dot = culture.numberFormat[\".\"];\n        var currency = culture.numberFormat.currency.symbol;\n        var rxnum = getNumberRegexp(comma, dot);\n        var rxcur = new RegExp(\"^\\\\s*\\\\\" + currency + \"\\\\s*\");\n        var sign = 1;\n        var format = \"\";\n        var suffix = \"\";\n        var has_currency = false;\n        var has_percent = false;\n        input = InputStream(input.replace(/^\\s+|\\s+$/g, \"\")); // has minus before currency?\n\n        if (input.skip(/^-\\s*/)) {\n          sign = -1;\n        } // has currency before number?\n\n\n        if (m = input.skip(rxcur)) {\n          has_currency = true;\n          format += '\"' + m[0] + '\"';\n        } // has minus after currency?\n\n\n        if (input.skip(/^-\\s*/)) {\n          if (sign < 0) {\n            return null; // not a number\n          }\n\n          sign = -1;\n        } // read the number itself\n\n\n        if (!(n = input.skip(rxnum))) {\n          return null; // not a number\n        }\n\n        format += \"0\"; // has currency after number?\n\n        if (m = input.skip(rxcur)) {\n          if (has_currency) {\n            return null; // either before or after, not both.\n          }\n\n          has_currency = true;\n          suffix = '\"' + m[0] + '\"';\n        } // has percent after number?\n\n\n        if (!has_currency && (m = input.skip(/^\\s*%\\s*/))) {\n          has_percent = true;\n          suffix = m[0]; // no quotes this time, % is special in format\n        }\n\n        if (!input.eof()) {\n          return null; // should anything else follow, not a number\n        }\n\n        if (n[2] || has_currency) {\n          format = format.replace(\"0\", \"#\");\n          format += \",0\";\n        }\n\n        if (n[3]) {\n          format += \".\" + repeat(\"0\", n[3].length - 1);\n        }\n\n        var value = n[0].replace(new RegExp(\"\\\\\" + comma, \"g\"), \"\").replace(new RegExp(\"\\\\\" + dot, \"g\"), \".\");\n        value = parseFloat(value);\n\n        if (has_percent) {\n          value /= 100;\n        }\n\n        format += suffix;\n\n        if (has_currency) {\n          format += ';-' + format;\n        }\n\n        return {\n          type: \"number\",\n          currency: has_currency,\n          format: format,\n          value: sign * value\n        };\n      });\n      registerFormatParser(function (input) {\n        var m;\n\n        if (m = /^([0-9]*)\\.([0-9]+)(\\s*%)$/.exec(input)) {\n          return {\n            type: \"number\",\n            value: parseFloat(input) / 100,\n            format: \"0.\" + repeat(\"0\", m[2].length) + m[3]\n          };\n        }\n      });\n      var NUMBER_FORMAT_RX = {};\n\n      function getNumberRegexp(comma, dot) {\n        var id = comma + dot;\n        var rx = NUMBER_FORMAT_RX[id];\n\n        if (!rx) {\n          rx = \"^(\\\\d+(COM\\\\d{3})*(DOT\\\\d+)?)\";\n          rx = rx.replace(/DOT/g, \"\\\\\" + dot).replace(/COM/g, \"\\\\\" + comma);\n          rx = new RegExp(rx);\n          NUMBER_FORMAT_RX[id] = rx;\n        }\n\n        return rx;\n      }\n\n      function repeat(str, len) {\n        var out = \"\";\n\n        while (len-- > 0) {\n          out += str;\n        }\n\n        return out;\n      }\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}