{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, TemplateRef, Component, Input, Output, HostBinding, InjectionToken, Injectable, Inject, Optional, Directive, forwardRef, ContentChildren, ViewChildren, ViewChild, isDevMode, Renderer2, Host, HostListener, ContentChild, NgModule } from '@angular/core';\nimport * as i2 from '@angular/animations';\nimport { style, animate, keyframes, trigger, state, transition } from '@angular/animations';\nimport { of, Subscription, Subject, merge } from 'rxjs';\nimport { delay, takeUntil, take, filter, map, share, tap, switchMap } from 'rxjs/operators';\nimport * as i6 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { DraggableDirective, isChanged, isDocumentAvailable, DraggableModule } from '@progress/kendo-angular-common';\nimport { offset, scrollPosition, positionWithScroll, getDocumentElement, getWindowViewPort } from '@progress/kendo-popup-common';\nimport { Button } from '@progress/kendo-angular-buttons';\n/**\n * @hidden\n */\n\nfunction DialogActionsComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!actions\"]);\n  }\n}\n\nfunction DialogActionsComponent_ng_container_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 5);\n    i0.ɵɵlistener(\"click\", function DialogActionsComponent_ng_container_1_button_1_Template_button_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const action_r5 = restoredCtx.$implicit;\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.onButtonClick(action_r5, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const action_r5 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r4.buttonClass(action_r5));\n    i0.ɵɵattribute(\"aria-label\", action_r5.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", action_r5.text, \" \");\n  }\n}\n\nfunction DialogActionsComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, DialogActionsComponent_ng_container_1_button_1_Template, 2, 3, \"button\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.actionsArray);\n  }\n}\n\nfunction DialogActionsComponent_ng_template_2_Template(rf, ctx) {}\n\nconst _c0 = [\"*\"];\nconst _c3 = [\"dialog\"];\n\nfunction DialogComponent_kendo_dialog_titlebar_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-dialog-titlebar\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"closeTitle\", ctx_r1.closeTitle)(\"id\", ctx_r1.titleId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.title);\n  }\n}\n\nfunction DialogComponent_ng_content_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!title\"]);\n  }\n}\n\nfunction DialogComponent_ng_content_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!contentTemplate\"]);\n  }\n}\n\nfunction DialogComponent_8_ng_template_0_Template(rf, ctx) {}\n\nfunction DialogComponent_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DialogComponent_8_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.contentTemplate);\n  }\n}\n\nfunction DialogComponent_ng_content_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"!actions\"]);\n  }\n}\n\nfunction DialogComponent_kendo_dialog_actions_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-dialog-actions\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"actions\", ctx_r6.actions)(\"layout\", ctx_r6.actionsLayout);\n  }\n}\n\nconst _c6 = [[[\"kendo-dialog-titlebar\"]], \"*\", [[\"kendo-dialog-actions\"]]];\nconst _c7 = [\"kendo-dialog-titlebar\", \"*\", \"kendo-dialog-actions\"];\n\nfunction WindowTitleBarComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!template\"]);\n  }\n}\n\nfunction WindowTitleBarComponent_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c8 = function (a0) {\n  return {\n    \"$implicit\": a0\n  };\n};\n\nfunction WindowTitleBarComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, WindowTitleBarComponent_1_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c8, ctx_r1.service));\n  }\n}\n\nfunction WindowComponent_kendo_window_titlebar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-window-titlebar\", 5)(1, \"div\", 6);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 7);\n    i0.ɵɵelement(4, \"button\", 8)(5, \"button\", 9)(6, \"button\", 10)(7, \"button\", 11);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"template\", ctx_r0.titleBarTemplate);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"title\", ctx_r0.minimizeButtonTitle)(\"aria-label\", ctx_r0.minimizeButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.maximizeButtonTitle)(\"aria-label\", ctx_r0.maximizeButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.restoreButtonTitle)(\"aria-label\", ctx_r0.restoreButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r0.closeButtonTitle)(\"aria-label\", ctx_r0.closeButtonTitle);\n  }\n}\n\nfunction WindowComponent_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!showDefaultTitleBar\"]);\n  }\n}\n\nfunction WindowComponent_div_4_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!contentTemplate\"]);\n  }\n}\n\nfunction WindowComponent_div_4_2_ng_template_0_Template(rf, ctx) {}\n\nfunction WindowComponent_div_4_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, WindowComponent_div_4_2_ng_template_0_Template, 0, 0, \"ng-template\", 13);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.contentTemplate);\n  }\n}\n\nfunction WindowComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtemplate(1, WindowComponent_div_4_ng_content_1_Template, 1, 0, \"ng-content\", 2);\n    i0.ɵɵtemplate(2, WindowComponent_div_4_2_Template, 1, 1, null, 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"hidden\", ctx_r2.state === \"minimized\" && ctx_r2.keepContent);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.contentTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.contentTemplate);\n  }\n}\n\nfunction WindowComponent_ng_template_5_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 15);\n  }\n\n  if (rf & 2) {\n    const dir_r8 = ctx.$implicit;\n    i0.ɵɵproperty(\"direction\", dir_r8);\n  }\n}\n\nfunction WindowComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, WindowComponent_ng_template_5_div_0_Template, 1, 1, \"div\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.resizeDirections);\n  }\n}\n\nconst _c17 = [[[\"kendo-window-titlebar\"]], \"*\"];\nconst _c18 = [\"kendo-window-titlebar\", \"*\"];\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isTruthy = value => !!value;\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\n\nvar Keys = /*#__PURE__*/(() => {\n  (function (Keys) {\n    Keys[Keys[\"esc\"] = 27] = \"esc\";\n    Keys[Keys[\"tab\"] = 9] = \"tab\";\n    Keys[Keys[\"enter\"] = 13] = \"enter\";\n    Keys[Keys[\"space\"] = 32] = \"space\";\n    Keys[Keys[\"ctrl\"] = 17] = \"ctrl\";\n    Keys[Keys[\"shift\"] = 16] = \"shift\";\n    Keys[Keys[\"left\"] = 37] = \"left\";\n    Keys[Keys[\"up\"] = 38] = \"up\";\n    Keys[Keys[\"right\"] = 39] = \"right\";\n    Keys[Keys[\"down\"] = 40] = \"down\";\n  })(Keys || (Keys = {}));\n\n  return Keys;\n})();\n\n/**\n * @hidden\n */\nconst DIALOG_ELEMENTS_HANDLING_ESC_KEY = 'k-dialog-wrapper k-dialog-buttongroup k-dialog-action';\n/**\n * @hidden\n */\n\nconst DIALOG_ELEMENTS_HANDLING_ARROWS = 'k-dialog-buttongroup';\n/**\n * @hidden\n */\n\nconst WINDOW_CLASSES = 'k-window';\n/**\n * @hidden\n */\n\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n/**\n * @hidden\n */\n\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  return !!(rect.width && rect.height) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = (element, checkVisibility = true) => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const validTabIndex = tabIndex !== null && !isNaN(tabIndex) && tabIndex > -1;\n    let focusable = false;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled;\n    } else {\n      focusable = validTabIndex;\n    }\n\n    return focusable && (!checkVisibility || isVisible(element));\n  }\n\n  return false;\n};\n/**\n * @hidden\n */\n\n\nconst setHTMLAttributes = (attributes, renderer, element) => {\n  for (const attribute in attributes) {\n    if (attribute) {\n      renderer.setAttribute(element, attribute, attributes[attribute]);\n    }\n  }\n};\n/**\n * Receives CSS class declarations either as an object, string or array and returns an array of the class names.\n *\n * @hidden\n */\n\n\nconst parseCSSClassNames = value => {\n  if (isObject(value)) {\n    return parseObjectClassNames(value);\n  }\n\n  if (isString(value)) {\n    return parseStringClassNames(value);\n  }\n\n  if (Array.isArray(value)) {\n    return parseArrayClassNames(value);\n  }\n};\n\nconst parseObjectClassNames = value => {\n  const classes = [];\n  Object.keys(value).forEach(className => {\n    const currentClassName = splitStringToArray(className);\n\n    if (value[className] && currentClassName[0]) {\n      classes.push(...currentClassName);\n    }\n  });\n  return classes;\n};\n\nconst parseStringClassNames = value => {\n  const classes = [];\n  const classesArray = splitStringToArray(value);\n  classesArray.forEach(className => {\n    classes.push(className);\n  });\n  return classes;\n};\n\nconst parseArrayClassNames = value => {\n  const classes = [];\n  value.forEach(className => {\n    const current = splitStringToArray(className);\n\n    if (current[0]) {\n      classes.push(...current);\n    }\n  });\n  return classes;\n};\n/**\n * @hidden\n */\n\n\nconst focusableSelector = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '*[tabindex]', '*[contenteditable]'].join(',');\n/**\n * @hidden\n */\n\nconst preventDefault = ({\n  originalEvent: event\n}) => {\n  event.stopPropagation();\n  event.preventDefault();\n};\n/**\n * @hidden\n */\n\n\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n/**\n * @hidden\n */\n\n\nconst RESIZE_DIRECTIONS = ['n', 'e', 's', 'w', 'se', 'sw', 'ne', 'nw'];\n/**\n * @hidden\n */\n\nconst OFFSET_STYLES = ['top', 'left', 'width', 'height'];\n/**\n * @hidden\n */\n\nconst isString = value => value instanceof String || typeof value === 'string';\n/**\n * @hidden\n */\n\n\nconst isObject = value => isPresent(value) && !Array.isArray(value) && typeof value === 'object';\n/**\n * @hidden\n */\n\n\nconst isNumber = value => typeof value === 'number' && isFinite(value);\n/**\n * @hidden\n */\n\n\nconst createValueWithUnit = value => value + (isNumber(value) ? 'px' : '');\n/**\n * @hidden\n */\n\n\nconst splitStringToArray = value => value.trim().replace(/\\s+/g, \" \").split(' ');\n/**\n * @hidden\n */\n\n\nconst findPrimaryButton = buttons => {\n  for (let i = buttons.length - 1; i >= 0; i--) {\n    const classList = buttons[i].classList;\n\n    for (let j = 0; j < classList.length; j++) {\n      if (classList[j].endsWith('-primary')) {\n        return buttons[i];\n      }\n    }\n  }\n};\n/**\n * Specifies the action buttons of the Dialog\n * ([see example]({% slug actionbuttons_dialog %})).\n */\n\n\nlet DialogActionsComponent = /*#__PURE__*/(() => {\n  class DialogActionsComponent {\n    constructor(el) {\n      this.el = el;\n      /**\n       * Specifies the possible layout of the action buttons.\n       */\n\n      this.layout = 'stretched';\n      /**\n       * Fires when the user clicks an action button.\n       */\n\n      this.action = new EventEmitter();\n      this.buttonGroupClassName = true;\n    }\n    /**\n     * Allows the declarative specification of the actions.\n     */\n\n\n    set actions(value) {\n      if (value instanceof TemplateRef) {\n        this.actionsTemplate = value;\n      } else if (Array.isArray(value)) {\n        this.actionsArray = value;\n      } else {\n        throw new Error('\"actions\" must be either TemplateRef or DialogAction[] instance.');\n      }\n    }\n\n    get className() {\n      return this.layout === 'stretched';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onButtonClick(action, _e) {\n      this.action.emit(action);\n    }\n    /**\n     * @hidden\n     */\n\n\n    buttonClass(action) {\n      let classes = ['k-button k-button-md k-rounded-md'];\n      const fillMode = action.fillMode ? action.fillMode : 'solid';\n      const themeColor = action.themeColor ? action.themeColor : 'base';\n      const cssClasses = action.cssClass ? parseCSSClassNames(action.cssClass) : [];\n      classes.push(`k-button-${fillMode} k-button-${fillMode}-${themeColor}`);\n\n      if (cssClasses.length > 0) {\n        classes = classes.concat(cssClasses);\n      }\n\n      return classes.join(' ');\n    }\n\n  }\n\n  DialogActionsComponent.ɵfac = function DialogActionsComponent_Factory(t) {\n    return new (t || DialogActionsComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  DialogActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DialogActionsComponent,\n    selectors: [[\"kendo-dialog-actions\"]],\n    hostVars: 6,\n    hostBindings: function DialogActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-dialog-buttongroup\", ctx.buttonGroupClassName)(\"k-actions\", ctx.buttonGroupClassName)(\"k-actions-stretched\", ctx.className);\n      }\n    },\n    inputs: {\n      actions: \"actions\",\n      layout: \"layout\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 4,\n    consts: [[4, \"ngIf\"], [4, \"ngIf\", \"ngIfElse\"], [3, \"ngTemplateOutlet\"], [\"actionTemplate\", \"\"], [\"type\", \"button\", 3, \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 3, \"ngClass\", \"click\"]],\n    template: function DialogActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, DialogActionsComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, DialogActionsComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, DialogActionsComponent_ng_template_2_Template, 0, 0, \"ng-template\", 2, 3, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(3);\n\n        i0.ɵɵproperty(\"ngIf\", !ctx.actions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsArray)(\"ngIfElse\", _r2);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.actionsTemplate);\n      }\n    },\n    directives: [i6.NgIf, i6.NgForOf, i6.NgClass, i6.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return DialogActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst DIALOG_LOCALIZATION_SERVICE = new InjectionToken('Dialog LocalizationService');\n/**\n * @hidden\n */\n\nlet TitleBarLocalizationService = /*#__PURE__*/(() => {\n  class TitleBarLocalizationService extends LocalizationService {\n    constructor(prefix, messageService, rtl, dialogLocalization) {\n      super(prefix, messageService, rtl);\n      this.dialogLocalization = dialogLocalization;\n    }\n\n    get(shortKey) {\n      if (this.dialogLocalization) {\n        return this.dialogLocalization.get(shortKey);\n      }\n\n      return super.get(shortKey);\n    }\n\n  }\n\n  TitleBarLocalizationService.ɵfac = function TitleBarLocalizationService_Factory(t) {\n    return new (t || TitleBarLocalizationService)(i0.ɵɵinject(L10N_PREFIX), i0.ɵɵinject(i1.MessageService, 8), i0.ɵɵinject(RTL, 8), i0.ɵɵinject(DIALOG_LOCALIZATION_SERVICE, 8));\n  };\n\n  TitleBarLocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TitleBarLocalizationService,\n    factory: TitleBarLocalizationService.ɵfac\n  });\n  return TitleBarLocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n\n  Messages.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = i0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n\n  Messages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages,\n    selectors: [[\"kendo-dialog-messages-base\"]],\n    inputs: {\n      closeTitle: \"closeTitle\",\n      restoreTitle: \"restoreTitle\",\n      maximizeTitle: \"maximizeTitle\",\n      minimizeTitle: \"minimizeTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n    return new (t || LocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoDialogLocalizedMessages\", \"\"], [\"\", \"kendoWindowLocalizedMessages\", \"\"], [\"\", \"kendoDialogTitleBarLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => LocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI DialogTitleBar component for Angular]({% slug api_dialog_dialogtitlebarcomponent %}).\n *\n * It is used as part of the Dialog content when the component is created dynamically by using an [Angular service]({% slug service_dialog %}).\n */\n\n\nlet DialogTitleBarComponent = /*#__PURE__*/(() => {\n  class DialogTitleBarComponent {\n    constructor(zone, hostElement, localizationService) {\n      this.zone = zone;\n      this.hostElement = hostElement;\n      this.localizationService = localizationService;\n      /**\n       * Fires when the close button of the title-bar is clicked.\n       */\n\n      this.close = new EventEmitter();\n    }\n\n    get className() {\n      return true;\n    }\n\n    get closeButtonTitle() {\n      return this.closeTitle || this.localizationService.get('closeTitle');\n    }\n\n    ngAfterViewInit() {\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        const element = this.hostElement.nativeElement.querySelector('.k-dialog-title');\n        element.setAttribute('id', this.id);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    onCloseClick(e) {\n      e.preventDefault();\n      const eventArgs = new PreventableEvent();\n      this.close.emit(eventArgs);\n    }\n\n  }\n\n  DialogTitleBarComponent.ɵfac = function DialogTitleBarComponent_Factory(t) {\n    return new (t || DialogTitleBarComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService, 8));\n  };\n\n  DialogTitleBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DialogTitleBarComponent,\n    selectors: [[\"kendo-dialog-titlebar\"]],\n    hostVars: 4,\n    hostBindings: function DialogTitleBarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-window-titlebar\", ctx.className)(\"k-dialog-titlebar\", ctx.className);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      closeTitle: \"closeTitle\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    features: [i0.ɵɵProvidersFeature([TitleBarLocalizationService, {\n      provide: LocalizationService,\n      useExisting: TitleBarLocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dialog'\n    }])],\n    ngContentSelectors: _c0,\n    decls: 6,\n    vars: 2,\n    consts: function () {\n      let i18n_1;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.dialog.closeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_2 = goog.getMsg(\"Close\");\n        i18n_1 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_2;\n      } else {\n        i18n_1 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;\n      }\n\n      return [[\"kendoDialogTitleBarLocalizedMessages\", \"\", \"closeTitle\", i18n_1], [1, \"k-window-title\", \"k-dialog-title\"], [1, \"k-window-actions\", \"k-dialog-actions\"], [\"role\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\", \"k-window-action\", \"k-dialog-action\", \"k-dialog-close\", 3, \"click\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-x\"]];\n    },\n    template: function DialogTitleBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2)(4, \"button\", 3);\n        i0.ɵɵlistener(\"click\", function DialogTitleBarComponent_Template_button_click_4_listener($event) {\n          return ctx.onCloseClick($event);\n        });\n        i0.ɵɵelement(5, \"span\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵattribute(\"title\", ctx.closeButtonTitle)(\"aria-label\", ctx.closeButtonTitle);\n      }\n    },\n    directives: [LocalizedMessagesDirective],\n    encapsulation: 2\n  });\n  return DialogTitleBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dialog',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654175123,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Indicates that the **Close** button is clicked. Used when the results from\n * the Dialogs that are opened through `DialogService` are filtered\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\n\nclass DialogCloseResult {}\n/**\n * @hidden\n */\n\n\nfunction animations(duration, direction, animationType) {\n  switch (animationType) {\n    case 'slide':\n      const translate = direction === 'left' || direction === 'right' ? 'translateX' : 'translateY';\n      const start = direction === 'right' || direction === 'down' ? -100 : 100;\n      const end = 0;\n      return [style({\n        transform: `${translate}(${start}%)`\n      }), animate(`${duration}ms ease-in`, style({\n        transform: `${translate}(${end}%)`\n      }))];\n\n    case 'expand':\n      const scale = direction === 'up' || direction === 'down' ? 'scaleY' : 'scaleX';\n      const startScale = 0;\n      const endScale = 1;\n      let origin;\n\n      if (direction === 'down') {\n        origin = 'top';\n      } else if (direction === 'left') {\n        origin = 'right';\n      } else if (direction === 'right') {\n        origin = 'left';\n      } else {\n        origin = 'bottom';\n      }\n\n      return [style({\n        transform: `${scale}(${startScale})`,\n        transformOrigin: origin\n      }), animate(`${duration}ms ease-in`, style({\n        transform: `${scale}(${endScale})`\n      }))];\n\n    case 'zoom':\n      const startZoom = 0;\n      const endZoom = 1;\n      return [animate(duration, keyframes([style({\n        transform: `scale(${startZoom})`\n      }), style({\n        transform: `scale(${endZoom})`\n      })]))];\n\n    case 'fade':\n      const startFade = 0;\n      const endFade = 1;\n      return [animate(duration, keyframes([style({\n        opacity: `${startFade}`\n      }), style({\n        opacity: `${endFade}`\n      })]))];\n\n    case 'translate':\n      return [style({\n        transform: 'translate(0, -10%)'\n      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];\n\n    default:\n      return [style({\n        transform: 'translate(0, -10%)'\n      }), animate(`${duration}ms cubic-bezier(.2, 1, .2, 1)`)];\n  }\n}\n/**\n * @hidden\n */\n\n\nconst createPlayer = (builder, animation, animatedElement) => {\n  const factory = builder.build(animation);\n  let player = factory.create(animatedElement);\n  player.onDone(() => {\n    if (player) {\n      player.destroy();\n      player = null;\n    }\n  });\n  return player;\n};\n/**\n * @hidden\n */\n\n\nconst animateContent = (animation, defAnimationConfig, animatedElement, builder) => {\n  let animationConfig = defAnimationConfig;\n\n  if (typeof animation !== 'boolean') {\n    animationConfig = animation;\n    animationConfig.duration = animationConfig.duration ? animationConfig.duration : defAnimationConfig.duration;\n  }\n\n  const animationSpecs = animations(animationConfig.duration, animationConfig.direction, animationConfig.type);\n  const player = createPlayer(builder, animationSpecs, animatedElement);\n  player.play();\n};\n\nconst DEFAULT_ANIMATION_CONFIG = {\n  duration: 300,\n  type: 'translate'\n};\n/**\n * Represents the [Kendo UI Dialog component for Angular]({% slug overview_dialog_dialogs %}).\n */\n\nlet DialogComponent = /*#__PURE__*/(() => {\n  class DialogComponent {\n    constructor(wrapper, renderer, localization, cdr, ngZone, builder) {\n      this.wrapper = wrapper;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.builder = builder;\n      /**\n       * Specifies the layout of the action buttons in the Dialog.\n       * This option is only applicable if the action buttons are specified through the `actions` options.\n       *\n       * @default 'stretched'\n       */\n\n      this.actionsLayout = 'stretched';\n      /**\n       * Configures the Dialog opening animation ([see example]({% slug animations_dialog %})).\n       * By default the animation type is set to `translate` and its duration is `300ms`.\n       *\n       * @default true\n       */\n\n      this.animation = true;\n      /**\n       * @hidden\n       */\n\n      this.titleId = null;\n      /**\n       * @hidden\n       */\n\n      this.contentId = null;\n      /**\n       * Fires when the user clicks an action button of the Dialog.\n       * The event is fired only when the action buttons are specified through the `actions` options.\n       */\n\n      this.action = new EventEmitter();\n      /**\n       * Fires when the user clicks the **Close** button of the Dialog or the **ESC** key.\n       */\n\n      this.close = new EventEmitter();\n      this.tabIndex = 0;\n      this.subscriptions = [];\n      this.domSubs = new Subscription();\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscriptions.push(localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n      this.titleId = this.generateTitleId();\n      this.contentId = this.generateContentId();\n    }\n    /**\n     * @hidden\n     */\n\n\n    set htmlAttributes(attributes) {\n      setHTMLAttributes(attributes, this.renderer, this.wrapper.nativeElement);\n      const el = this.wrapper.nativeElement;\n      const dir = el.getAttribute('dir');\n      const tIndex = el.getAttribute('tabindex');\n\n      if (this.direction !== dir && dir) {\n        this.direction = dir;\n      }\n\n      if (this.tabIndex !== tIndex && tIndex) {\n        this.tabIndex = tIndex;\n      }\n\n      this._htmlAttributes = attributes;\n    }\n\n    get htmlAttributes() {\n      return this._htmlAttributes;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set cssClass(classes) {\n      this.setServiceClasses(this._cssClass, classes);\n      this._cssClass = classes;\n    }\n\n    get cssClass() {\n      return this._cssClass;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    ngAfterContentInit() {\n      this.bubble('close', this.titlebarContent.first);\n      this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-describedby', this.contentId);\n\n      if (this.titlebarContent.first) {\n        this.titlebarContent.first.id = this.titleId;\n      } else {\n        this.subscriptions.push(this.titlebarContent.changes.subscribe(() => {\n          if (isPresent(this.titlebarContent.first)) {\n            this.titlebarContent.first.id = this.titleId;\n            this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n              this.bubble('close', this.titlebarContent.first);\n              this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n            });\n          }\n        }));\n      }\n    }\n\n    ngAfterViewInit() {\n      this.handleInitialFocus();\n      this.bubble('close', this.titlebarView.first);\n      this.bubble('action', this.actionsView);\n\n      if (this.titlebarView.first || this.titlebarContent.first) {\n        //Needed for Dialogs created via service\n        this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n      } else {\n        this.subscriptions.push(this.titlebarView.changes.subscribe(() => {\n          if (isPresent(this.titlebarView.first)) {\n            this.titlebarView.first.id = this.titleId;\n            this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n              this.bubble('close', this.titlebarView.first);\n              this.renderer.setAttribute(this.wrapper.nativeElement.querySelector('.k-dialog'), 'aria-labelledby', this.titleId);\n            });\n          }\n        }));\n      }\n\n      this.initDomEvents();\n    }\n\n    ngOnInit() {\n      if (this.animation) {\n        animateContent(this.animation, DEFAULT_ANIMATION_CONFIG, this.dialog.nativeElement, this.builder);\n      }\n\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'title');\n      this.cdr.detectChanges();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n      this.subscriptions = [];\n\n      if (this.domSubs) {\n        this.domSubs.unsubscribe();\n      }\n    }\n    /**\n     * Focuses the wrapper of the Dialog component.\n     */\n\n\n    focus() {\n      const wrapper = this.wrapper.nativeElement;\n\n      if (isPresent(wrapper)) {\n        wrapper.focus();\n      }\n    }\n\n    initDomEvents() {\n      if (!this.wrapper) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubs.add(this.renderer.listen(this.wrapper.nativeElement, 'keydown', ev => {\n          this.onKeyDown(ev);\n        }));\n      });\n    }\n\n    onKeyDown(event) {\n      const target = event.target;\n      const parent = target.parentElement;\n\n      if (hasClasses(target, DIALOG_ELEMENTS_HANDLING_ESC_KEY) || hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ESC_KEY)) {\n        if (event.keyCode === Keys.esc) {\n          this.ngZone.run(() => {\n            this.close.emit(new DialogCloseResult());\n          });\n        }\n      }\n\n      if (hasClasses(target, 'k-button') && hasClasses(parent, DIALOG_ELEMENTS_HANDLING_ARROWS) && (event.keyCode === Keys.left || event.keyCode === Keys.right)) {\n        this.ngZone.run(() => {\n          this.handleActionButtonFocus(parent, event.keyCode);\n        });\n      }\n\n      if (event.keyCode === Keys.tab) {\n        this.ngZone.run(() => {\n          this.keepFocusWithinComponent(target, event);\n        });\n      }\n    }\n\n    setServiceClasses(prevValue, value) {\n      const el = this.wrapper.nativeElement;\n\n      if (prevValue) {\n        parseCSSClassNames(prevValue).forEach(className => {\n          this.renderer.removeClass(el, className);\n        });\n      }\n\n      if (value) {\n        parseCSSClassNames(value).forEach(className => {\n          this.renderer.addClass(el, className);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleInitialFocus() {\n      const wrapper = this.wrapper.nativeElement;\n      const primaryButton = this.findPrimary(wrapper);\n\n      if (this.autoFocusedElement) {\n        const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n\n        if (initiallyFocusedElement) {\n          initiallyFocusedElement.focus();\n        }\n      } else if (this.shouldFocusPrimary(primaryButton)) {\n        primaryButton.focus();\n      } else {\n        wrapper.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    findPrimary(wrapper) {\n      const actionBtns = wrapper.querySelectorAll('.k-actions .k-button');\n      return findPrimaryButton(actionBtns);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleActionButtonFocus(parent, key) {\n      const focusableActionButtons = this.getAllFocusableChildren(parent);\n\n      for (let i = 0; i < focusableActionButtons.length; i++) {\n        const current = focusableActionButtons[i];\n\n        if (current === document.activeElement) {\n          if (key === Keys.left && i > 0) {\n            focusableActionButtons[i - 1].focus();\n            break;\n          }\n\n          if (key === Keys.right && i < focusableActionButtons.length - 1) {\n            focusableActionButtons[i + 1].focus();\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    keepFocusWithinComponent(target, event) {\n      const wrapper = this.wrapper.nativeElement;\n      const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);\n      const tabAfterLastFocusable = !event.shiftKey && target === lastFocusable;\n      const shiftTabAfterFirstFocusable = event.shiftKey && target === firstFocusable;\n\n      if (tabAfterLastFocusable) {\n        event.preventDefault();\n        firstFocusable.focus();\n      }\n\n      if (shiftTabAfterFirstFocusable) {\n        event.preventDefault();\n        lastFocusable.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    shouldFocusPrimary(el) {\n      return isPresent(el) && isFocusable(el);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getAllFocusableChildren(parent) {\n      return parent.querySelectorAll(focusableSelector);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getFirstAndLastFocusable(parent) {\n      const all = this.getAllFocusableChildren(parent);\n      const firstFocusable = all.length > 0 ? all[0] : parent;\n      const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;\n      return [firstFocusable, lastFocusable];\n    }\n    /**\n     * @hidden\n     */\n\n\n    generateTitleId() {\n      return 'kendo-dialog-title-' + Math.ceil(Math.random() * 1000000).toString();\n    }\n    /**\n     * @hidden\n     */\n\n\n    generateContentId() {\n      return 'kendo-dialog-content-' + Math.ceil(Math.random() * 1000000).toString();\n    }\n\n    get wrapperClass() {\n      return true;\n    }\n\n    get styles() {\n      const styles = {};\n\n      if (this.width) {\n        styles.width = createValueWithUnit(this.width);\n      }\n\n      if (this.height) {\n        styles.height = createValueWithUnit(this.height);\n      }\n\n      if (this.minWidth) {\n        styles.minWidth = createValueWithUnit(this.minWidth);\n      }\n\n      if (this.maxWidth) {\n        styles.maxWidth = createValueWithUnit(this.maxWidth);\n      }\n\n      if (this.minHeight) {\n        styles.minHeight = createValueWithUnit(this.minHeight);\n      }\n\n      if (this.maxHeight) {\n        styles.maxHeight = createValueWithUnit(this.maxHeight);\n      }\n\n      return styles;\n    }\n\n    bubble(eventName, component) {\n      if (component) {\n        const emit = e => this[eventName].emit(e);\n\n        const s = component[eventName].subscribe(emit);\n        this.subscriptions.push(s);\n      }\n    }\n\n  }\n\n  DialogComponent.ɵfac = function DialogComponent_Factory(t) {\n    return new (t || DialogComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AnimationBuilder));\n  };\n\n  DialogComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DialogComponent,\n    selectors: [[\"kendo-dialog\"]],\n    contentQueries: function DialogComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DialogTitleBarComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titlebarContent = _t);\n      }\n    },\n    viewQuery: function DialogComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DialogActionsComponent, 5);\n        i0.ɵɵviewQuery(_c3, 7);\n        i0.ɵɵviewQuery(DialogTitleBarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionsView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialog = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titlebarView = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function DialogComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir)(\"tabIndex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"k-dialog-wrapper\", ctx.wrapperClass);\n      }\n    },\n    inputs: {\n      actions: \"actions\",\n      actionsLayout: \"actionsLayout\",\n      autoFocusedElement: \"autoFocusedElement\",\n      title: \"title\",\n      width: \"width\",\n      minWidth: \"minWidth\",\n      maxWidth: \"maxWidth\",\n      height: \"height\",\n      minHeight: \"minHeight\",\n      maxHeight: \"maxHeight\",\n      animation: \"animation\"\n    },\n    outputs: {\n      action: \"action\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoDialog\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: DIALOG_LOCALIZATION_SERVICE,\n      useExisting: LocalizationService\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dialog'\n    }])],\n    ngContentSelectors: _c7,\n    decls: 11,\n    vars: 9,\n    consts: function () {\n      let i18n_4;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.dialog.closeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_5 = goog.getMsg(\"Close\");\n        i18n_4 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_5;\n      } else {\n        i18n_4 = $localize`:kendo.dialog.closeTitle|The title of the close button:Close`;\n      }\n\n      return [[\"kendoDialogLocalizedMessages\", \"\", \"closeTitle\", i18n_4], [1, \"k-overlay\"], [\"role\", \"dialog\", \"aria-modal\", \"true\", 1, \"k-window\", \"k-dialog\", 3, \"ngStyle\"], [\"dialog\", \"\"], [3, \"closeTitle\", \"id\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-content\", \"k-window-content\", \"k-dialog-content\", 3, \"id\"], [3, \"actions\", \"layout\", 4, \"ngIf\"], [3, \"closeTitle\", \"id\"], [3, \"ngTemplateOutlet\"], [3, \"actions\", \"layout\"]];\n    },\n    template: function DialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c6);\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2, 3);\n        i0.ɵɵtemplate(4, DialogComponent_kendo_dialog_titlebar_4_Template, 2, 3, \"kendo-dialog-titlebar\", 4);\n        i0.ɵɵtemplate(5, DialogComponent_ng_content_5_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementStart(6, \"div\", 6);\n        i0.ɵɵtemplate(7, DialogComponent_ng_content_7_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵtemplate(8, DialogComponent_8_Template, 1, 1, null, 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, DialogComponent_ng_content_9_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵtemplate(10, DialogComponent_kendo_dialog_actions_10_Template, 1, 2, \"kendo-dialog-actions\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"@overlayAppear\", undefined);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngStyle\", ctx.styles);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.contentId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.contentTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.contentTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.actions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actions);\n      }\n    },\n    directives: [DialogTitleBarComponent, DialogActionsComponent, LocalizedMessagesDirective, i6.NgStyle, i6.NgIf, i6.NgTemplateOutlet],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('overlayAppear', [state('in', style({\n        opacity: 1\n      })), transition('void => *', [style({\n        opacity: 0.1\n      }), animate('.3s cubic-bezier(.2, .6, .4, 1)')])])]\n    }\n  });\n  return DialogComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Holds references to the object instance and published events of the Dialog.\n * Controls the Dialogs that were opened through the `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\n\n\nclass DialogRef {}\n/**\n * The base class  which will be extended by a component that is provided as content through `content`\n * ([see example]({% slug service_dialog %}#toc-passing-title-content-and-actions-as-a-single-component)).\n */\n\n\nlet DialogContentBase = /*#__PURE__*/(() => {\n  class DialogContentBase {\n    constructor(dialog) {\n      this.dialog = dialog;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      if (this.dialogTitleBar) {\n        // when opening component inside dialog with service AND the component has defined its own titlebar\n        this.dialogTitleBar.close.pipe(filter(e => !e.isDefaultPrevented())).subscribe(() => {\n          this.dialog.close();\n        });\n      }\n\n      if (this.dialogActions) {\n        if (this.dialogActions.actions) {\n          this.dialogActions.action.subscribe(action => this.dialog.dialog.instance.action.emit(action));\n        }\n      }\n    }\n\n  }\n\n  DialogContentBase.ɵfac = function DialogContentBase_Factory(t) {\n    return new (t || DialogContentBase)(i0.ɵɵdirectiveInject(DialogRef));\n  };\n\n  DialogContentBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DialogContentBase,\n    viewQuery: function DialogContentBase_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(DialogTitleBarComponent, 5);\n        i0.ɵɵviewQuery(DialogActionsComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialogTitleBar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dialogActions = _t.first);\n      }\n    }\n  });\n  return DialogContentBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DialogContainerService = /*#__PURE__*/(() => {\n  class DialogContainerService {\n    set container(container) {\n      DialogContainerService.container = container;\n    }\n\n    get container() {\n      return DialogContainerService.container;\n    }\n\n  }\n\n  DialogContainerService.container = null;\n\n  DialogContainerService.ɵfac = function DialogContainerService_Factory(t) {\n    return new (t || DialogContainerService)();\n  };\n\n  DialogContainerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DialogContainerService,\n    factory: DialogContainerService.ɵfac\n  });\n  return DialogContainerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The settings for the Dialog actions when the Dialog is opened through `DialogService`\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\n\n\nclass DialogAction {}\n/**\n * The settings that can be used when the Dialog is opened through `DialogService`.\n * ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n */\n\n\nclass DialogSettings {} // eslint-disable max-line-length\n\n\nconst isNotComponent$1 = component => isString(component) || component instanceof TemplateRef;\n\nclass DialogInjector {\n  constructor(getDialogRef, parentInjector) {\n    this.getDialogRef = getDialogRef;\n    this.parentInjector = parentInjector;\n  }\n\n  get(token, notFoundValue) {\n    if (token === DialogRef) {\n      return this.getDialogRef();\n    }\n\n    return this.parentInjector.get(token, notFoundValue);\n  }\n\n}\n/**\n * A service for opening Dialog windows dynamically\n * ([see example]({% slug service_dialog %})).\n */\n\n\nlet DialogService = /*#__PURE__*/(() => {\n  class DialogService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n      this.resolver = resolver;\n      this.containerService = containerService;\n    }\n    /**\n     * Opens a Dialog window. Requires an element in the application that uses the\n     * [`kendoDialogContainer`]({% slug api_dialog_dialogcontainerdirective %}) directive.\n     * Created Dialogs will be mounted in the DOM directly after that element.\n     *\n     * @param {DialogAction} options - The options that define the Dialog.\n     * @returns {DialogRef} - A reference to the Dialog object and the convenience properties.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Harmless button</button>\n     *     <div kendoDialogContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private dialogService: DialogService ) {}\n     *\n     *     public open() {\n     *         var dialog = this.dialogService.open({\n     *           title: \"Please confirm\",\n     *           content: \"Are you sure?\",\n     *           actions: [\n     *             { text: \"No\" },\n     *             { text: \"Yes\", themeColor: 'primary' }\n     *           ]\n     *         });\n     *\n     *         dialog.result.subscribe((result) => {\n     *           if (result instanceof DialogCloseResult) {\n     *             console.log(\"close\");\n     *           } else {\n     *             console.log(\"action\", result);\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n\n\n    open(options) {\n      const factory = this.resolver.resolveComponentFactory(DialogComponent);\n      const container = options.appendTo || this.containerService.container;\n\n      if (!container) {\n        throw new Error(`\nCannot attach dialog to the page.\nAdd an element that uses the kendoDialogContainer directive, or set the 'appendTo' property.\nSee https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/.\n          `);\n      } // create DialogRef to (1) pass as result, (2) provide through injector\n\n\n      const dialogRef = {\n        close: () => {\n          /* noop */\n        },\n        content: null,\n        dialog: null,\n        result: null\n      };\n      return this.initializeDialog(options.content, factory, container, dialogRef, options);\n    }\n\n    initializeDialog(component, factory, container, dialogRef, options) {\n      const content = this.contentFrom(component, container, dialogRef);\n      const dialog = container.createComponent(factory, undefined, undefined, content.nodes);\n      dialogRef.dialog = dialog;\n      dialog.changeDetectorRef.markForCheck(); // copy @Input options to dialog instance\n\n      this.applyOptions(dialog.instance, options); // create close handler and result stream\n\n      const apiClose = new Subject();\n\n      const close = e => {\n        if (e instanceof PreventableEvent) {\n          e = new DialogCloseResult();\n        }\n\n        apiClose.next(e || new DialogCloseResult());\n\n        if (content.componentRef) {\n          content.componentRef.destroy();\n        }\n\n        dialog.destroy();\n      };\n\n      const result = merge(apiClose, // triggered when the titlebar or actions are defined in DialogSettings\n      merge(dialog.instance.close, dialog.instance.action).pipe(map(e => e instanceof PreventableEvent ? new DialogCloseResult() : e), filter(e => {\n        if (options.preventAction) {\n          // add dialogRef only when using component\n          const dialogRefParameter = isNotComponent$1(component) ? undefined : dialogRef;\n          return !options.preventAction(e, dialogRefParameter);\n        }\n\n        return true;\n      }))).pipe(take(1), // Takes care for multiple subscriptions:\n      // We subscribe internaly and the user may subscribe to get a close result - dialog.result.subscribe().\n      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.\n      share());\n      result.subscribe(close);\n      dialogRef.close = close;\n      dialogRef.result = result;\n\n      if (component && isDevMode()) {\n        const hasContentTitle = content.nodes[0] && content.nodes[0].length > 0;\n        const hasContentActions = content.nodes[2] && content.nodes[2].length > 0;\n        const multipleTitles = options.title && hasContentTitle;\n        const multipleActions = options.actions && hasContentActions;\n\n        if (component.prototype instanceof DialogContentBase) {\n          // content component extends DialogContentBase\n          if (multipleTitles || multipleActions) {\n            console.warn(`\n                    Multiple Title and/or Actions configurations detected.\n                    When using a component as content, provide the title and actions either in the component's markup\n                    or via the title and actions properties of the DialogSettings object, but not both.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);\n          }\n        } else {\n          if (hasContentTitle || hasContentActions) {\n            console.warn(`\n                    When Title and/or Actions markup is provided in content component's template,\n                    the component needs to inherit the DialogContentBase class to ensure that close and result events are properly hooked.\n                    See https://www.telerik.com/kendo-angular-ui/components/dialogs/dialog/service/#toc-passing-title-content-and-actions-as-a-single-component'`);\n          }\n        }\n      }\n\n      return dialogRef;\n    }\n\n    applyOptions(instance, options) {\n      instance.title = options.title;\n      instance.actions = options.actions;\n      instance.actionsLayout = options.actionsLayout || 'stretched';\n      instance.width = options.width;\n      instance.minWidth = options.minWidth;\n      instance.maxWidth = options.maxWidth;\n      instance.height = options.height;\n      instance.minHeight = options.minHeight;\n      instance.maxHeight = options.maxHeight;\n      instance.autoFocusedElement = options.autoFocusedElement;\n      instance.closeTitle = options.closeTitle;\n      instance.cssClass = options.cssClass;\n      instance.htmlAttributes = options.htmlAttributes;\n      instance.animation = options.animation !== undefined ? options.animation : true;\n\n      if (options.content instanceof TemplateRef) {\n        instance.contentTemplate = options.content;\n      }\n    }\n\n    contentFrom(content, container, dialogRef) {\n      const renderer = container.injector.get(Renderer2);\n      let nodes = [];\n      let titleNodes = [];\n      let actionNodes = [];\n      let componentRef = null;\n\n      if (typeof content === 'string') {\n        nodes = [renderer.createText(content)];\n      } else if (content && !(content instanceof TemplateRef)) {\n        // Component\n        const injector = new DialogInjector(() => dialogRef, container.injector);\n        const factory = this.resolver.resolveComponentFactory(content);\n        componentRef = container.createComponent(factory, undefined, injector);\n        titleNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-titlebar'));\n        nodes = [componentRef.location.nativeElement];\n        actionNodes = Array.from(componentRef.location.nativeElement.querySelectorAll('kendo-dialog-actions'));\n        dialogRef.content = componentRef;\n      }\n\n      return {\n        componentRef,\n        nodes: [titleNodes, nodes, actionNodes // <ng-content select=\"kendo-dialog-actions\">\n        ]\n      };\n    }\n\n  }\n\n  DialogService.ɵfac = function DialogService_Factory(t) {\n    return new (t || DialogService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(DialogContainerService));\n  };\n\n  DialogService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DialogService,\n    factory: DialogService.ɵfac\n  });\n  return DialogService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet newZIndex = 10002;\n/**\n * @hidden\n */\n\nconst DEFAULT_OPTIONS = {\n  draggable: true,\n  height: null,\n  left: null,\n  minHeight: 100,\n  minWidth: 120,\n  position: 'absolute',\n  resizable: true,\n  state: 'default',\n  top: null,\n  width: null\n};\n/**\n * @hidden\n */\n\nconst createMoveStream = (el, ev) => mouseDown => {\n  return el.kendoDrag.pipe(takeUntil(el.kendoRelease.pipe(tap(() => {\n    ev.emit();\n  }))), map(({\n    pageX,\n    pageY\n  }) => ({\n    originalX: mouseDown.pageX,\n    originalY: mouseDown.pageY,\n    pageX,\n    pageY\n  })));\n};\n/**\n * @hidden\n */\n\n\nlet DragResizeService = /*#__PURE__*/(() => {\n  class DragResizeService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.close = new EventEmitter();\n      this.focus = new EventEmitter();\n      this.change = new EventEmitter();\n      this.stateChange = new EventEmitter();\n      this.dragStart = new EventEmitter();\n      this.dragEnd = new EventEmitter();\n      this.resizeStart = new EventEmitter();\n      this.resizeEnd = new EventEmitter();\n      this.options = Object.assign({}, DEFAULT_OPTIONS);\n      this.lastAction = null;\n      this.subscriptions = new Subscription();\n      this.dragSubscription = new Subscription();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n\n      if (this.dragSubscription) {\n        this.dragSubscription.unsubscribe();\n      }\n    }\n\n    init(el) {\n      const state = this.options.state;\n      let options = this.options;\n      this.window = el;\n\n      if (state !== 'default') {\n        this.restoreOptions = Object.assign({}, options);\n      }\n\n      if (state === 'minimized') {\n        options.height = 0;\n        options.minHeight = 0;\n      }\n\n      if (state === 'maximized') {\n        options.position = 'fixed';\n      }\n    }\n\n    onDrag(el) {\n      this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n        let startPosition;\n        let dragStarted;\n        this.dragSubscription = el.kendoPress.pipe(tap(ev => {\n          if (!ev.isTouch) {\n            preventDefault(ev);\n          }\n\n          this.focus.emit();\n          startPosition = this.currentPosition();\n          dragStarted = false;\n        }), switchMap(createMoveStream(el, this.dragEnd))).subscribe(({\n          pageX,\n          pageY,\n          originalX,\n          originalY\n        }) => {\n          if (!dragStarted) {\n            this.ensureWidth();\n            this.dragStart.emit();\n            dragStarted = true;\n          }\n\n          this.handleDrag({\n            originalX,\n            originalY,\n            pageX,\n            pageY,\n            startPosition\n          });\n        });\n      }));\n    }\n\n    handleDrag({\n      originalX,\n      originalY,\n      pageX,\n      pageY,\n      startPosition\n    }) {\n      this.options.left = startPosition.x + pageX - originalX;\n      this.options.top = startPosition.y + pageY - originalY;\n\n      if (this.options.state === 'minimized' && isPresent(this.restoreOptions)) {\n        this.restoreOptions.left = this.options.left;\n        this.restoreOptions.top = this.options.top;\n      }\n\n      this.change.emit({\n        left: startPosition.x + pageX - originalX,\n        top: startPosition.y + pageY - originalY\n      });\n    }\n\n    onResize(handle, direction) {\n      this.subscriptions.add(this.ngZone.runOutsideAngular(() => {\n        let startOffsetAndPosition;\n        let resizeStarted = false;\n        handle.kendoPress.pipe(tap(ev => {\n          preventDefault(ev);\n          this.focus.emit();\n          startOffsetAndPosition = this.currentOffsetAndPosition();\n          resizeStarted = false;\n        }), switchMap(createMoveStream(handle, this.resizeEnd))).subscribe(({\n          pageX,\n          pageY,\n          originalX,\n          originalY\n        }) => {\n          if (!resizeStarted) {\n            this.resizeStart.emit(direction);\n            resizeStarted = true;\n          }\n\n          let deltaX = pageX - originalX;\n          let deltaY = pageY - originalY;\n          this.handleResize(startOffsetAndPosition, direction, deltaX, deltaY);\n        });\n      }));\n    }\n\n    handleResize(initial, dir, deltaX, deltaY) {\n      const old = this.options;\n      let ev = {};\n\n      if (dir.indexOf('e') >= 0) {\n        const newWidth = initial.width + deltaX;\n\n        if (newWidth !== old.width && newWidth >= old.minWidth) {\n          ev.width = newWidth;\n        }\n      }\n\n      if (dir.indexOf('n') >= 0) {\n        const newHeight = initial.height - deltaY;\n        const newTop = initial.y + deltaY;\n\n        if (newHeight !== old.height && newHeight >= old.minHeight && newTop !== old.top) {\n          ev.height = newHeight;\n          ev.top = newTop;\n        }\n      }\n\n      if (dir.indexOf('s') >= 0) {\n        const newHeight = initial.height + deltaY;\n\n        if (newHeight !== old.height && newHeight >= old.minHeight) {\n          ev.height = newHeight;\n        }\n      }\n\n      if (dir.indexOf('w') >= 0) {\n        const newLeft = initial.x + deltaX;\n        const newWidth = initial.width - deltaX;\n\n        if (newWidth !== old.width && newWidth >= old.minWidth && newLeft !== old.left) {\n          ev.width = newWidth;\n          ev.left = newLeft;\n        }\n      }\n\n      if (isPresent(ev.width) || isPresent(ev.height)) {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.options[style] = ev[style];\n          }\n        });\n        this.change.emit(ev);\n      }\n    }\n\n    restoreAction() {\n      this.lastAction = 'restore';\n      this.defaultState();\n    }\n\n    defaultState() {\n      if (isPresent(this.restoreOptions)) {\n        this.options = Object.assign({}, this.restoreOptions);\n      }\n\n      this.options.state = 'default';\n      this.stateChange.emit('default');\n    }\n\n    storeOptions() {\n      this.restoreOptions = Object.assign({}, this.options);\n    }\n\n    maximizeAction() {\n      this.lastAction = 'maximize';\n      this.maximizeState();\n    }\n\n    maximizeState() {\n      this.storeOptions();\n      const wnd = this.windowViewPort;\n      this.options = Object.assign({}, this.options, {\n        height: wnd.height,\n        left: 0,\n        position: 'fixed',\n        state: 'maximized',\n        top: 0,\n        width: wnd.width\n      });\n      this.stateChange.emit('maximized');\n    }\n\n    minimizeAction() {\n      this.lastAction = 'minimize';\n      this.minimizeState();\n    }\n\n    minimizeState() {\n      this.storeOptions();\n      this.options = Object.assign({}, this.options, {\n        height: null,\n        minHeight: 0,\n        state: 'minimized'\n      });\n      this.stateChange.emit('minimized');\n    }\n    /**\n     * Handles manual changes of the 'state' property.\n     * Required to distinguish them from action clicks.\n     */\n\n\n    applyManualState() {\n      const state = this.options.state;\n\n      switch (state) {\n        case 'default':\n          this.clearHeight();\n          this.defaultState();\n          break;\n\n        case 'maximized':\n          this.clearHeight();\n          this.maximizeState();\n          break;\n\n        case 'minimized':\n          this.minimizeState();\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    closeAction() {\n      this.close.emit();\n    }\n\n    ensureWidth() {\n      const windowOffset = offset(this.window.nativeElement);\n\n      if (!isPresent(this.options.width)) {\n        this.options.width = windowOffset.width;\n        this.change.emit({\n          width: windowOffset.width\n        });\n      }\n    }\n\n    clearHeight() {\n      if (this.options.height === 0) {\n        delete this.options.height;\n      }\n\n      if (this.options.minHeight === 0) {\n        delete this.options.minHeight;\n      }\n    }\n\n    center() {\n      if (this.options.state === 'maximized') {\n        return;\n      }\n\n      let scroll = scrollPosition(this.window.nativeElement);\n      let wnd = this.windowViewPort;\n      let wrapper = offset(this.window.nativeElement);\n      let ev = {};\n\n      if (!isPresent(this.options.left)) {\n        this.options.left = scroll.x + Math.max(0, (wnd.width - wrapper.width) / 2);\n        ev.left = this.options.left;\n      }\n\n      if (!isPresent(this.options.top)) {\n        this.options.top = scroll.y + Math.max(0, (wnd.height - wrapper.height) / 2);\n        ev.top = this.options.top;\n      }\n\n      this.change.emit(ev);\n    }\n\n    currentOffsetAndPosition() {\n      const o = this.options;\n      const off = offset(this.window.nativeElement);\n      return Object.assign({}, this.currentPosition(), {\n        height: o.height ? o.height : off.height,\n        width: o.width ? o.width : off.width\n      });\n    }\n\n    currentPosition() {\n      const o = this.options;\n\n      if (!o.top || !o.left) {\n        this.setPosition();\n      }\n\n      return {\n        x: this.options.left,\n        y: this.options.top\n      };\n    }\n\n    setPosition() {\n      const wrapper = positionWithScroll(this.window.nativeElement, getDocumentElement(this.window.nativeElement));\n      this.options.left = wrapper.left;\n      this.options.top = wrapper.top;\n    }\n\n    setRestoreOption(style, value) {\n      if (isPresent(this.restoreOptions)) {\n        this.restoreOptions[style] = value;\n      }\n    }\n\n    get nextPossibleZIndex() {\n      return newZIndex;\n    }\n\n    get nextZIndex() {\n      return newZIndex++;\n    }\n\n    get windowViewPort() {\n      return getWindowViewPort(this.window.nativeElement);\n    }\n\n  }\n\n  DragResizeService.ɵfac = function DragResizeService_Factory(t) {\n    return new (t || DragResizeService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  DragResizeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DragResizeService,\n    factory: DragResizeService.ɵfac\n  });\n  return DragResizeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ResizeHandleDirective = /*#__PURE__*/(() => {\n  class ResizeHandleDirective {\n    constructor(draggable, el, renderer, service) {\n      this.draggable = draggable;\n      this.el = el;\n      this.renderer = renderer;\n      this.service = service;\n      this.subscriptions = new Subscription();\n    }\n\n    get hostClass() {\n      return true;\n    }\n\n    ngOnInit() {\n      this.setDisplay();\n      this.renderer.addClass(this.el.nativeElement, 'k-resize-' + this.direction);\n      this.subscriptions.add(of(this.draggable).subscribe(handle => {\n        this.service.onResize(handle, this.direction);\n      }));\n      this.subscriptions.add(this.service.resizeStart.subscribe(dir => {\n        if (dir !== this.direction) {\n          this.setDisplay('none');\n        }\n      }));\n      this.subscriptions.add(this.service.dragStart.subscribe(() => {\n        this.setDisplay('none');\n      }));\n      this.subscriptions.add(merge(this.service.resizeEnd, this.service.dragEnd).subscribe(() => {\n        this.setDisplay('block');\n      }));\n      this.subscriptions.add(this.service.stateChange.subscribe(state => {\n        this.setDisplay(state === 'default' ? 'block' : 'none');\n      }));\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    setDisplay(value = 'block') {\n      this.renderer.setStyle(this.el.nativeElement, 'display', this.service.options.state === 'default' ? value : 'none');\n    }\n\n  }\n\n  ResizeHandleDirective.ɵfac = function ResizeHandleDirective_Factory(t) {\n    return new (t || ResizeHandleDirective)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService));\n  };\n\n  ResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ResizeHandleDirective,\n    selectors: [[\"\", \"kendoWindowResizeHandle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function ResizeHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-resize-handle\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      direction: \"direction\"\n    }\n  });\n  return ResizeHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WindowTitleBarComponent = /*#__PURE__*/(() => {\n  class WindowTitleBarComponent {\n    constructor(el, service, ngZone) {\n      this.el = el;\n      this.ngZone = ngZone;\n      this.service = service;\n    }\n\n    ngOnInit() {\n      this.dragDirective = new DraggableDirective(this.el, this.ngZone);\n      this.dragDirective.ngOnInit();\n\n      if (this.isDraggable) {\n        this.subscribeDrag();\n      }\n\n      this.subscribeStateChange();\n    }\n\n    ngOnDestroy() {\n      this.dragDirective.ngOnDestroy();\n      this.unsubscribeDrag();\n      this.unsubscribeState();\n    }\n    /**\n     * @hidden\n     */\n\n\n    subscribeDrag() {\n      this.unsubscribeDrag();\n      this.dragSubscription = of(this.dragDirective).subscribe(titleBar => {\n        this.service.onDrag(titleBar);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    subscribeStateChange() {\n      this.stateSubscription = this.service.stateChange.subscribe(state => {\n        if (this.service.options.draggable) {\n          if (state === 'maximized') {\n            this.unsubscribeDrag();\n          } else {\n            this.subscribeDrag();\n          }\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    unsubscribeDrag() {\n      if (this.dragSubscription) {\n        this.service.dragSubscription.unsubscribe();\n        this.dragSubscription.unsubscribe();\n        this.dragSubscription = null;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    unsubscribeState() {\n      if (this.stateSubscription) {\n        this.stateSubscription.unsubscribe();\n        this.stateSubscription = null;\n      }\n    }\n\n    get className() {\n      return true;\n    }\n\n    get touchAction() {\n      if (this.isDraggable) {\n        return 'none';\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handle(ev) {\n      const target = ev.target;\n      const state = this.service.options.state;\n\n      if (!hasClasses(target, 'k-icon') && !isFocusable(target, false) && this.service.options.resizable) {\n        if (state === 'default') {\n          this.service.maximizeAction();\n        } else if (state === 'maximized') {\n          this.service.restoreAction();\n        }\n      }\n    }\n\n    get isDraggable() {\n      const options = this.service.options;\n      return options.draggable && options.state !== 'maximized';\n    }\n\n  }\n\n  WindowTitleBarComponent.ɵfac = function WindowTitleBarComponent_Factory(t) {\n    return new (t || WindowTitleBarComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DragResizeService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  WindowTitleBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WindowTitleBarComponent,\n    selectors: [[\"kendo-window-titlebar\"]],\n    hostVars: 6,\n    hostBindings: function WindowTitleBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function WindowTitleBarComponent_dblclick_HostBindingHandler($event) {\n          return ctx.handle($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchAction);\n        i0.ɵɵclassProp(\"k-window-titlebar\", ctx.className)(\"k-dialog-titlebar\", ctx.className);\n      }\n    },\n    inputs: {\n      template: \"template\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function WindowTitleBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, WindowTitleBarComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, WindowTitleBarComponent_1_Template, 1, 4, null, 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    directives: [i6.NgIf, i6.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return WindowTitleBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(window, ngZone) {\n      this.window = window;\n      this.ngZone = ngZone;\n    }\n\n    process(ev) {\n      const key = ev.keyCode;\n\n      switch (key) {\n        case Keys.up:\n        case Keys.down:\n        case Keys.left:\n        case Keys.right:\n          {\n            ev.preventDefault();\n            this.ngZone.run(() => {\n              this.handleArrow(key, ev);\n            });\n            break;\n          }\n\n        case Keys.esc:\n          this.ngZone.run(() => {\n            this.handleEscape();\n          });\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    handleArrow(key, ev) {\n      const options = this.window.options;\n\n      if (ev.altKey) {\n        this.handleStateChange(key, options.state);\n        return;\n      }\n\n      if ((ev.ctrlKey || ev.metaKey) && options.state === 'default') {\n        this.handleResize(key);\n      } else {\n        this.handleDrag(key);\n      }\n    }\n\n    handleEscape() {\n      this.window.closeAction();\n    }\n\n    handleDrag(key) {\n      let options = this.window.options;\n\n      if (!options.draggable) {\n        return;\n      }\n\n      const offset = this.window.currentOffsetAndPosition();\n      let restoreOptions = this.window.restoreOptions;\n      let ev = {};\n      let delta = 10;\n\n      if (key === Keys.left || key === Keys.up) {\n        delta *= -1;\n      }\n\n      switch (key) {\n        case Keys.left:\n        case Keys.right:\n          {\n            ev.left = offset.x + delta;\n            options.left = ev.left;\n            break;\n          }\n\n        case Keys.up:\n        case Keys.down:\n          {\n            ev.top = offset.y + delta;\n            options.top = ev.top;\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      if (options.state === 'minimized' && isPresent(restoreOptions)) {\n        restoreOptions.left = options.left;\n        restoreOptions.top = options.top;\n      }\n\n      this.window.change.emit(ev);\n    }\n\n    handleResize(key) {\n      const options = this.window.options;\n\n      if (!options.resizable) {\n        return;\n      }\n\n      const offset = this.window.currentOffsetAndPosition();\n      let newWidth;\n      let newHeight;\n      let ev = {};\n      let delta = 10;\n\n      if (key === Keys.left || key === Keys.up) {\n        delta *= -1;\n      }\n\n      switch (key) {\n        case Keys.left:\n        case Keys.right:\n          {\n            newWidth = offset.width + delta;\n\n            if (newWidth !== options.width && newWidth >= options.minWidth) {\n              ev.width = newWidth;\n            }\n\n            break;\n          }\n\n        case Keys.up:\n        case Keys.down:\n          {\n            newHeight = offset.height + delta;\n\n            if (newHeight !== options.height && newHeight >= options.minHeight) {\n              ev.height = newHeight;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      if (isPresent(ev.width) || isPresent(ev.height)) {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.window.options[style] = ev[style];\n          }\n        });\n        this.window.change.emit(ev);\n      }\n    }\n\n    handleStateChange(key, state) {\n      if (state === 'minimized' && key === Keys.up || state === 'maximized' && key === Keys.down) {\n        this.window.restoreAction();\n        return;\n      }\n\n      if (state === 'default') {\n        if (key === Keys.up) {\n          this.window.maximizeAction();\n        } else if (key === Keys.down) {\n          this.window.minimizeAction();\n        }\n      }\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(DragResizeService), i0.ɵɵinject(i0.NgZone));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WindowMinimizeActionDirective = /*#__PURE__*/(() => {\n  class WindowMinimizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      this.buttonType = 'button';\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window-minimize';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.minimizeAction();\n      }\n    }\n\n    get visible() {\n      return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n\n  }\n\n  WindowMinimizeActionDirective.ɵfac = function WindowMinimizeActionDirective_Factory(t) {\n    return new (t || WindowMinimizeActionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  WindowMinimizeActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WindowMinimizeActionDirective,\n    selectors: [[\"button\", \"kendoWindowMinimizeAction\", \"\"]],\n    hostVars: 3,\n    hostBindings: function WindowMinimizeActionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function WindowMinimizeActionDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowMinimizeAction\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return WindowMinimizeActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WindowMaximizeActionDirective = /*#__PURE__*/(() => {\n  class WindowMaximizeActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      this.buttonType = 'button';\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window-maximize';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.maximizeAction();\n      }\n    }\n\n    get visible() {\n      return this.window.options.state === 'default' ? 'inline-flex' : 'none';\n    }\n\n  }\n\n  WindowMaximizeActionDirective.ɵfac = function WindowMaximizeActionDirective_Factory(t) {\n    return new (t || WindowMaximizeActionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  WindowMaximizeActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WindowMaximizeActionDirective,\n    selectors: [[\"button\", \"kendoWindowMaximizeAction\", \"\"]],\n    hostVars: 3,\n    hostBindings: function WindowMaximizeActionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function WindowMaximizeActionDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowMaximizeAction\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return WindowMaximizeActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WindowRestoreActionDirective = /*#__PURE__*/(() => {\n  class WindowRestoreActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      this.buttonType = 'button';\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'window-restore';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.restoreAction();\n      }\n    }\n\n    get visible() {\n      return this.window.options.state === 'default' ? 'none' : 'inline-flex';\n    }\n\n  }\n\n  WindowRestoreActionDirective.ɵfac = function WindowRestoreActionDirective_Factory(t) {\n    return new (t || WindowRestoreActionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  WindowRestoreActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WindowRestoreActionDirective,\n    selectors: [[\"button\", \"kendoWindowRestoreAction\", \"\"]],\n    hostVars: 3,\n    hostBindings: function WindowRestoreActionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function WindowRestoreActionDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n        i0.ɵɵstyleProp(\"display\", ctx.visible);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowRestoreAction\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return WindowRestoreActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WindowCloseActionDirective = /*#__PURE__*/(() => {\n  class WindowCloseActionDirective extends Button {\n    constructor(el, renderer, _service, localization, ngZone) {\n      super(el, renderer, null, localization, ngZone);\n      this.buttonType = 'button';\n      this.window = _service;\n      this.fillMode = 'flat';\n      this.icon = 'close';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (!this.isDisabled) {\n        this.window.closeAction();\n      }\n    }\n\n  }\n\n  WindowCloseActionDirective.ɵfac = function WindowCloseActionDirective_Factory(t) {\n    return new (t || WindowCloseActionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService, 8), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  WindowCloseActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WindowCloseActionDirective,\n    selectors: [[\"button\", \"kendoWindowCloseAction\", \"\"]],\n    hostVars: 1,\n    hostBindings: function WindowCloseActionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function WindowCloseActionDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"type\", ctx.buttonType);\n      }\n    },\n    inputs: {\n      window: \"window\"\n    },\n    exportAs: [\"kendoWindowCloseAction\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.button'\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return WindowCloseActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Window component for Angular]({% slug overview_window_dialogs %}).\n */\n\n\nlet WindowComponent = /*#__PURE__*/(() => {\n  class WindowComponent {\n    constructor(el, renderer, service, navigation, ngZone, localization) {\n      this.el = el;\n      this.renderer = renderer;\n      this.service = service;\n      this.navigation = navigation;\n      this.ngZone = ngZone;\n      this.localization = localization;\n      /**\n       * Specifies if the content of the component is persisted in the DOM when minimized.\n       * @default false\n       */\n\n      this.keepContent = false;\n      /**\n       * Fires when the user starts to move the Window.\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Fires when the Window was moved by the user.\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * Fires when the user starts to resize the Window.\n       */\n\n      this.resizeStart = new EventEmitter();\n      /**\n       * Fires when the Window was resized by the user.\n       */\n\n      this.resizeEnd = new EventEmitter();\n      /**\n       * Fires when the user closes the Window.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires when the `width` property of the component was updated. The event is triggered only after the resizing\n       * has ended. The event data contains the new width. Allows a two-way binding of the `width` property.\n       */\n\n      this.widthChange = new EventEmitter();\n      /**\n       * Fires when the `height` property of the component was updated. The event is triggered only after the resizing\n       * has ended. The event data contains the new height. Allows a two-way binding of the `height` property.\n       */\n\n      this.heightChange = new EventEmitter();\n      /**\n       * Fires when the `top` property of the component was updated. The event is triggered only after the dragging\n       * and resizing have ended. The event data contains the new top offset. Allows a two-way binding of the `top` property.\n       */\n\n      this.topChange = new EventEmitter();\n      /**\n       * Fires when the `left` property of the component was updated. The event is triggered only after the dragging\n       * and resizing have ended. The event data contains the new left offset. Allows a two-way binding of the `left` property.\n       */\n\n      this.leftChange = new EventEmitter();\n      /**\n       * Fires when the `state` property of the component was updated. The event data contains the new state. Allows a\n       * two-way binding of the `state` property.\n       */\n\n      this.stateChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.messages = {};\n      this.tabIndex = 0;\n      this.draged = false;\n      this.resized = false;\n      this.windowSubscription = new Subscription();\n      this.domSubs = new Subscription();\n      validatePackage(packageMetadata);\n      this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n      this.localizationChangeSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n      this.resizeDirections = RESIZE_DIRECTIONS;\n      this.subscribeEvents();\n    }\n    /**\n     * Specifies whether the user will be able to drag the component.\n     * @default true\n     */\n\n\n    set draggable(value) {\n      this.options.draggable = value;\n    }\n\n    get draggable() {\n      return this.options.draggable;\n    }\n    /**\n     * Specifies whether the user will be able to resize the component.\n     * @default true\n     */\n\n\n    set resizable(value) {\n      this.options.resizable = value;\n    }\n\n    get resizable() {\n      return this.options.resizable;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set cssClass(classes) {\n      this.setServiceClasses(this._cssClass, classes);\n      this._cssClass = classes;\n    }\n\n    get cssClass() {\n      return this._cssClass;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set htmlAttributes(attributes) {\n      setHTMLAttributes(attributes, this.renderer, this.el.nativeElement);\n      const el = this.el.nativeElement;\n      const dir = el.getAttribute('dir');\n      const tIndex = el.getAttribute('tabindex');\n\n      if (this.direction !== dir) {\n        this.direction = dir;\n      }\n\n      if (this.tabIndex !== tIndex) {\n        this.tabIndex = tIndex;\n      }\n\n      this._htmlAttributes = attributes;\n    }\n\n    get htmlAttributes() {\n      return this._htmlAttributes;\n    }\n    /**\n     * Specifies the initial state of the component.\n     * If not specified, the value is set to `default`.\n     *\n     * The possible values are:\n     * * `minimized`\n     * * `maximized`\n     * * `default`\n     */\n\n\n    set state(value) {\n      this.options.state = value;\n    }\n\n    get state() {\n      return this.options.state;\n    }\n    /**\n     * Specifies the minimum width of the component.\n     * The `minWidth` property has to be set in pixels.\n     * @default 120\n     */\n\n\n    set minWidth(value) {\n      this.setOption('minWidth', value);\n    }\n\n    get minWidth() {\n      return this.options.minWidth;\n    }\n    /**\n     * Specifies the minimum height of the Window.\n     * The `minHeight` property has to be set in pixels.\n     * @default 100\n     */\n\n\n    set minHeight(value) {\n      this.setOption('minHeight', value);\n    }\n\n    get minHeight() {\n      return this.options.minHeight;\n    }\n    /**\n     * Specifies the width of the Window.\n     * The `width` property has to be set in pixels.\n     */\n\n\n    set width(value) {\n      this.setOption('width', value);\n    }\n\n    get width() {\n      return this.options.width;\n    }\n    /**\n     * Specifies the height of the Window.\n     * The `height` property has to be set in pixels.\n     */\n\n\n    set height(value) {\n      this.setOption('height', value);\n    }\n\n    get height() {\n      return this.options.height;\n    }\n    /**\n     * Specifies the initial top offset of the Window.\n     * The `top` property has to be set in pixels.\n     */\n\n\n    set top(value) {\n      this.setOption('top', value);\n    }\n\n    get top() {\n      return this.options.top;\n    }\n    /**\n     * Specifies the initial left offset of the Window.\n     * Numeric values are treated as pixels.\n     */\n\n\n    set left(value) {\n      this.setOption('left', value);\n    }\n\n    get left() {\n      return this.options.left;\n    }\n\n    get closeButtonTitle() {\n      if (this.messages && this.messages.closeTitle) {\n        return this.messages.closeTitle;\n      }\n\n      return this.localization.get('closeTitle');\n    }\n\n    get restoreButtonTitle() {\n      if (this.messages && this.messages.restoreTitle) {\n        return this.messages.restoreTitle;\n      }\n\n      return this.localization.get('restoreTitle');\n    }\n\n    get maximizeButtonTitle() {\n      if (this.messages && this.messages.maximizeTitle) {\n        return this.messages.maximizeTitle;\n      }\n\n      return this.localization.get('maximizeTitle');\n    }\n\n    get minimizeButtonTitle() {\n      if (this.messages && this.messages.minimizeTitle) {\n        return this.messages.minimizeTitle;\n      }\n\n      return this.localization.get('minimizeTitle');\n    }\n\n    get hostClasses() {\n      return true;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    ngAfterViewInit() {\n      this.setNextZIndex();\n      this.handleInitialFocus();\n      this.ngZone.runOutsideAngular(() => Promise.resolve(null).then(() => this.setInitialOffset()));\n      this.initDomEvents();\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.el.nativeElement, 'title');\n      this.service.init(this.el);\n    }\n\n    ngOnChanges(changes) {\n      OFFSET_STYLES.forEach(style => {\n        if (isChanged(style, changes)) {\n          this.setStyle(style, this.options[style]);\n        }\n      });\n\n      if (isChanged('draggable', changes)) {\n        const titleBar = isPresent(this.titleBarContent) ? this.titleBarContent : this.titleBarView;\n\n        if (isTruthy(changes.draggable.currentValue)) {\n          titleBar.subscribeDrag();\n        } else {\n          titleBar.unsubscribeDrag();\n        }\n      }\n\n      if (isChanged('state', changes)) {\n        if (isPresent(this.service.lastAction)) {\n          this.service.lastAction = null;\n        } else {\n          this.service.applyManualState();\n          this.updateAllOffset();\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.windowSubscription) {\n        this.windowSubscription.unsubscribe();\n      }\n\n      if (this.domSubs) {\n        this.domSubs.unsubscribe();\n      }\n\n      this.localizationChangeSubscription.unsubscribe();\n    }\n    /**\n     * Focuses the wrapper of the Window component.\n     */\n\n\n    focus() {\n      const wrapper = this.el.nativeElement;\n\n      if (isPresent(wrapper)) {\n        wrapper.focus();\n      }\n    }\n    /**\n     * Brings the current Window component on top of other Window components on the page.\n     */\n\n\n    bringToFront() {\n      this.setNextZIndex();\n    }\n    /**\n     * Manually updates the `width` or `height` option of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for sizing dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowDimensionSetting} dimension - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n\n\n    setDimension(dimension, value) {\n      this.setOption(dimension, value);\n      this.setStyle(dimension, value);\n    }\n    /**\n     * Manually updates the `top` or `left` offset of the Window.\n     * The required style will be applied to the Window wrapper element and the\n     * corresponding property of the component instance will be updated.\n     * This method is intended to be used for positioning dynamically created components using the\n     * [`WindowService`]({% slug api_dialog_windowservice %})\n     * @param {WindowOffsetSetting} offset - The option that will be updated\n     * @param {number} value - The value set in pixels\n     */\n\n\n    setOffset(offset, value) {\n      this.setOption(offset, value);\n      this.setStyle(offset, value);\n    }\n\n    get showDefaultTitleBar() {\n      return !isPresent(this.titleBarContent);\n    }\n\n    get styleMinWidth() {\n      return this.minWidth + 'px';\n    }\n\n    get styleMinHeight() {\n      return this.minHeight + 'px';\n    }\n\n    get stylePosition() {\n      return this.options.position;\n    }\n\n    get wrapperMaximizedClass() {\n      return this.state === 'maximized';\n    }\n\n    get wrapperMinimizedClass() {\n      return this.state === 'minimized';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentFocus() {\n      this.renderer.addClass(this.el.nativeElement, 'k-focus');\n      this.setNextZIndex();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentBlur() {\n      this.renderer.removeClass(this.el.nativeElement, 'k-focus');\n    }\n\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.windowSubscription.add(this.service.focus.subscribe(() => {\n        this.el.nativeElement.focus();\n      }));\n      this.windowSubscription.add(this.service.dragStart.subscribe(() => {\n        this.draged = true;\n        this.ngZone.run(() => {\n          this.dragStart.emit();\n        });\n      }));\n      this.windowSubscription.add(this.service.dragEnd.subscribe(() => {\n        if (this.draged) {\n          this.draged = false;\n          this.ngZone.run(() => {\n            this.dragEnd.emit();\n          });\n        }\n      }));\n      this.windowSubscription.add(this.service.close.subscribe(() => {\n        this.close.emit();\n      }));\n      this.windowSubscription.add(this.service.resizeStart.subscribe(() => {\n        this.resized = true;\n        this.ngZone.run(() => {\n          this.resizeStart.emit();\n        });\n      }));\n      this.windowSubscription.add(this.service.resizeEnd.subscribe(() => {\n        if (this.resized) {\n          this.resized = false;\n          this.ngZone.run(() => {\n            this.resizeEnd.emit();\n          });\n        }\n      }));\n      this.windowSubscription.add(this.service.change.subscribe(ev => {\n        OFFSET_STYLES.forEach(style => {\n          if (isPresent(ev[style])) {\n            this.setStyle(style, ev[style]);\n\n            if (this.state !== 'maximized') {\n              const emitter = this[style + 'Change'];\n\n              if (emitter.observers.length) {\n                this.ngZone.run(() => {\n                  emitter.emit(ev[style]);\n                });\n              }\n            }\n          }\n        });\n      }));\n      this.windowSubscription.add(this.service.stateChange.subscribe(state => {\n        if (isPresent(this.service.lastAction)) {\n          this.updateAllOffset();\n          this.stateChange.emit(state);\n        }\n      }));\n    }\n\n    initDomEvents() {\n      if (!this.el) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.domSubs.add(this.renderer.listen(this.el.nativeElement, 'keydown', ev => {\n          this.onKeyDown(ev);\n        }));\n      });\n    }\n\n    onKeyDown(event) {\n      if (hasClasses(event.target, WINDOW_CLASSES)) {\n        this.navigation.process(event);\n      }\n    }\n\n    setServiceClasses(prevValue, value) {\n      const el = this.el.nativeElement;\n\n      if (prevValue) {\n        parseCSSClassNames(prevValue).forEach(className => {\n          this.renderer.removeClass(el, className);\n        });\n      }\n\n      if (value) {\n        parseCSSClassNames(value).forEach(className => {\n          this.renderer.addClass(el, className);\n        });\n      }\n    }\n\n    setNextZIndex() {\n      const currentZIndex = this.el.nativeElement.style['z-index'];\n      const nextPossibleZIndex = this.service.nextPossibleZIndex;\n\n      if (!currentZIndex || nextPossibleZIndex - currentZIndex > 1) {\n        this.renderer.setStyle(this.el.nativeElement, \"z-index\", this.service.nextZIndex);\n      }\n    }\n\n    setInitialOffset() {\n      if (this.state !== 'maximized') {\n        this.updateAllOffset();\n\n        if (!isPresent(this.left) || !isPresent(this.top)) {\n          this.service.center();\n        }\n      } else {\n        const viewPort = this.service.windowViewPort;\n        this.setStyle('width', viewPort.width);\n        this.setStyle('height', viewPort.height);\n        this.setStyle('top', 0);\n        this.setStyle('left', 0);\n      }\n    }\n\n    updateAllOffset() {\n      OFFSET_STYLES.forEach(style => {\n        if (isPresent(this[style])) {\n          this.setStyle(style, this[style]);\n        } else {\n          this.removeStyle(style);\n        }\n      });\n    }\n\n    setStyle(style, value) {\n      this.renderer.setStyle(this.el.nativeElement, style, value + 'px');\n    }\n\n    removeStyle(style) {\n      this.renderer.removeStyle(this.el.nativeElement, style);\n    }\n\n    get options() {\n      return this.service.options;\n    }\n\n    setOption(style, value) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        return;\n      }\n\n      const parsedValue = typeof value === 'number' ? value : parseInt(value, 10);\n      this.options[style] = parsedValue;\n      this.service.setRestoreOption(style, parsedValue);\n    }\n\n    handleInitialFocus() {\n      const wrapper = this.el.nativeElement;\n\n      if (this.autoFocusedElement) {\n        const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);\n\n        if (initiallyFocusedElement) {\n          initiallyFocusedElement.focus();\n        }\n      } else {\n        this.focus();\n      }\n    }\n\n  }\n\n  WindowComponent.ɵfac = function WindowComponent_Factory(t) {\n    return new (t || WindowComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragResizeService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  WindowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WindowComponent,\n    selectors: [[\"kendo-window\"]],\n    contentQueries: function WindowComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, WindowTitleBarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleBarContent = _t.first);\n      }\n    },\n    viewQuery: function WindowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(WindowTitleBarComponent, 5);\n        i0.ɵɵviewQuery(ResizeHandleDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleBarView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeHandles = _t);\n      }\n    },\n    hostVars: 14,\n    hostBindings: function WindowComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function WindowComponent_focus_HostBindingHandler() {\n          return ctx.onComponentFocus();\n        })(\"blur\", function WindowComponent_blur_HostBindingHandler() {\n          return ctx.onComponentBlur();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabIndex\", ctx.tabIndex)(\"dir\", ctx.dir);\n        i0.ɵɵstyleProp(\"min-width\", ctx.styleMinWidth)(\"min-height\", ctx.styleMinHeight)(\"position\", ctx.stylePosition);\n        i0.ɵɵclassProp(\"k-window\", ctx.hostClasses)(\"k-window-maximized\", ctx.wrapperMaximizedClass)(\"k-window-minimized\", ctx.wrapperMinimizedClass);\n      }\n    },\n    inputs: {\n      autoFocusedElement: \"autoFocusedElement\",\n      title: \"title\",\n      draggable: \"draggable\",\n      resizable: \"resizable\",\n      keepContent: \"keepContent\",\n      state: \"state\",\n      minWidth: \"minWidth\",\n      minHeight: \"minHeight\",\n      width: \"width\",\n      height: \"height\",\n      top: \"top\",\n      left: \"left\"\n    },\n    outputs: {\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\",\n      resizeStart: \"resizeStart\",\n      resizeEnd: \"resizeEnd\",\n      close: \"close\",\n      widthChange: \"widthChange\",\n      heightChange: \"heightChange\",\n      topChange: \"topChange\",\n      leftChange: \"leftChange\",\n      stateChange: \"stateChange\"\n    },\n    exportAs: [\"kendoWindow\"],\n    features: [i0.ɵɵProvidersFeature([DragResizeService, NavigationService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.window'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c18,\n    decls: 6,\n    vars: 4,\n    consts: function () {\n      let i18n_9;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.window.closeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_10 = goog.getMsg(\"Close\");\n        i18n_9 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_10;\n      } else {\n        i18n_9 = $localize`:kendo.window.closeTitle|The title of the close button:Close`;\n      }\n\n      let i18n_11;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the restore button\n         * @meaning kendo.window.restoreTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_12 = goog.getMsg(\"Restore\");\n        i18n_11 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_12;\n      } else {\n        i18n_11 = $localize`:kendo.window.restoreTitle|The title of the restore button:Restore`;\n      }\n\n      let i18n_13;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the maximize button\n         * @meaning kendo.window.maximizeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_14 = goog.getMsg(\"Maximize\");\n        i18n_13 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_14;\n      } else {\n        i18n_13 = $localize`:kendo.window.maximizeTitle|The title of the maximize button:Maximize`;\n      }\n\n      let i18n_15;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the minimize button\n         * @meaning kendo.window.minimizeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_16 = goog.getMsg(\"Minimize\");\n        i18n_15 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DIALOG_FESM2015_KENDO_ANGULAR_DIALOG_JS_16;\n      } else {\n        i18n_15 = $localize`:kendo.window.minimizeTitle|The title of the minimize button:Minimize`;\n      }\n\n      return [[\"kendoWindowLocalizedMessages\", \"\", \"closeTitle\", i18n_9, \"restoreTitle\", i18n_11, \"maximizeTitle\", i18n_13, \"minimizeTitle\", i18n_15], [3, \"template\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-content k-window-content\", 3, \"hidden\", 4, \"ngIf\"], [3, \"ngIf\"], [3, \"template\"], [1, \"k-window-title\"], [1, \"k-window-actions\"], [\"kendoWindowMinimizeAction\", \"\"], [\"kendoWindowMaximizeAction\", \"\"], [\"kendoWindowRestoreAction\", \"\"], [\"kendoWindowCloseAction\", \"\"], [1, \"k-content\", \"k-window-content\", 3, \"hidden\"], [3, \"ngTemplateOutlet\"], [\"kendoWindowResizeHandle\", \"\", \"kendoDraggable\", \"\", 3, \"direction\", 4, \"ngFor\", \"ngForOf\"], [\"kendoWindowResizeHandle\", \"\", \"kendoDraggable\", \"\", 3, \"direction\"]];\n    },\n    template: function WindowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c17);\n        i0.ɵɵelementContainerStart(0, 0)(1);\n        i0.ɵɵtemplate(2, WindowComponent_kendo_window_titlebar_2_Template, 8, 10, \"kendo-window-titlebar\", 1);\n        i0.ɵɵtemplate(3, WindowComponent_ng_content_3_Template, 1, 0, \"ng-content\", 2);\n        i0.ɵɵtemplate(4, WindowComponent_div_4_Template, 3, 3, \"div\", 3);\n        i0.ɵɵtemplate(5, WindowComponent_ng_template_5_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementContainerEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showDefaultTitleBar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.showDefaultTitleBar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.state !== \"minimized\" || ctx.keepContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.resizable);\n      }\n    },\n    directives: [WindowTitleBarComponent, LocalizedMessagesDirective, i6.NgIf, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowCloseActionDirective, i6.NgTemplateOutlet, i6.NgForOf, ResizeHandleDirective, i1$1.DraggableDirective],\n    encapsulation: 2\n  });\n  return WindowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Indicates that the **Close** button of a Window that is opened through `WindowService` is clicked.\n */\n\n\nclass WindowCloseResult {}\n/**\n * Holds references to the object instance of the Window.\n * Controls the Windows that were opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\n\n\nclass WindowRef {}\n/**\n * The settings for the Window actions when the Window is opened through `WindowService`\n * ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n */\n\n\nclass WindowSettings {}\n/**\n * @hidden\n */\n\n\nlet WindowContainerService = /*#__PURE__*/(() => {\n  class WindowContainerService {\n    set container(container) {\n      WindowContainerService.container = container;\n    }\n\n    get container() {\n      return WindowContainerService.container;\n    }\n\n  }\n\n  WindowContainerService.container = null;\n\n  WindowContainerService.ɵfac = function WindowContainerService_Factory(t) {\n    return new (t || WindowContainerService)();\n  };\n\n  WindowContainerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WindowContainerService,\n    factory: WindowContainerService.ɵfac\n  });\n  return WindowContainerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isNotComponent = component => isString(component) || component instanceof TemplateRef;\n\nclass WindowInjector {\n  constructor(getWindowRef, parentInjector) {\n    this.getWindowRef = getWindowRef;\n    this.parentInjector = parentInjector;\n  }\n\n  get(token, notFoundValue) {\n    if (token === WindowRef) {\n      return this.getWindowRef();\n    }\n\n    return this.parentInjector.get(token, notFoundValue);\n  }\n\n}\n/**\n * A service for opening Windows dynamically\n * ([see example]({% slug service_window %})).\n */\n\n\nlet WindowService = /*#__PURE__*/(() => {\n  class WindowService {\n    constructor(\n    /**\n     * @hidden\n     */\n    resolver, containerService) {\n      this.resolver = resolver;\n      this.containerService = containerService;\n    }\n    /**\n     * Opens a Window component.\n     *\n     * @param {WindowSettings} settings - The settings that define the Window.\n     * @returns {WindowRef} - A reference to the Window object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button kendoButton (click)=\"open()\">Open window</button>\n     *     <div kendoWindowContainer></div>\n     *   `\n     * })\n     * export class AppComponent {\n     *     constructor( private windowService: WindowService ) {}\n     *\n     *     public open() {\n     *         var window = this.windowService.open({\n     *           title: \"My window\",\n     *           content: \"My content!\"\n     *         });\n     *\n     *         window.result.subscribe((result) => {\n     *           if (result instanceof WindowCloseResult) {\n     *             console.log(\"Window was closed\");\n     *           }\n     *         });\n     *     }\n     * }\n     * ```\n     *\n     */\n\n\n    open(settings) {\n      const factory = this.resolver.resolveComponentFactory(WindowComponent);\n      const container = settings.appendTo || this.containerService.container;\n\n      if (!container) {\n        throw new Error(`Cannot attach window to the page.\n                Add an element that uses the kendoWindowContainer directive, or set the 'appendTo' property.\n                See https://www.telerik.com/kendo-angular-ui/components/dialogs/window/service/\n            `);\n      }\n\n      const windowRef = {\n        close: () => {},\n        content: null,\n        result: null,\n        window: null\n      };\n      const content = this.contentFrom(settings.content, container, windowRef);\n      const window = container.createComponent(factory, undefined, undefined, content.nodes);\n      windowRef.window = window;\n      this.applyOptions(window.instance, settings);\n      const apiClose = new Subject();\n\n      const close = e => {\n        apiClose.next(e || new WindowCloseResult());\n\n        if (content.componentRef) {\n          content.componentRef.destroy();\n        }\n\n        window.destroy();\n      };\n\n      const result = merge(apiClose, window.instance.close.pipe(map(e => e ? e : new WindowCloseResult()), filter(e => {\n        if (settings.preventClose) {\n          // add windowRef only when using component\n          const windowRefParameter = isNotComponent(settings.content) ? undefined : windowRef;\n          return !settings.preventClose(e, windowRefParameter);\n        }\n\n        return true;\n      }))).pipe(take(1), // Takes care for multiple subscriptions:\n      // We subscribe internally and the user may subscribe to get a close result - window.result.subscribe().\n      // This causes multiple subscriptions to the same source and thus multiple emissions. share() solves that.\n      share());\n      result.subscribe(close);\n      windowRef.close = close;\n      windowRef.result = result;\n      window.changeDetectorRef.markForCheck();\n      return windowRef;\n    }\n\n    applyOptions(instance, options) {\n      if (isPresent(options.htmlAttributes)) {\n        instance.htmlAttributes = options.htmlAttributes;\n      }\n\n      if (isPresent(options.cssClass)) {\n        instance.cssClass = options.cssClass;\n      }\n\n      if (isPresent(options.title)) {\n        instance.title = options.title;\n      }\n\n      if (isPresent(options.keepContent)) {\n        instance.keepContent = options.keepContent;\n      }\n\n      if (isPresent(options.width)) {\n        instance.width = options.width;\n      }\n\n      if (isPresent(options.minWidth)) {\n        instance.minWidth = options.minWidth;\n      }\n\n      if (isPresent(options.height)) {\n        instance.height = options.height;\n      }\n\n      if (isPresent(options.minHeight)) {\n        instance.minHeight = options.minHeight;\n      }\n\n      if (isPresent(options.left)) {\n        instance.left = options.left;\n      }\n\n      if (isPresent(options.top)) {\n        instance.top = options.top;\n      }\n\n      if (isPresent(options.draggable)) {\n        instance.draggable = options.draggable;\n      }\n\n      if (isPresent(options.resizable)) {\n        instance.resizable = options.resizable;\n      }\n\n      if (isPresent(options.messages && options.messages.closeTitle)) {\n        instance.messages.closeTitle = options.messages.closeTitle;\n      }\n\n      if (isPresent(options.messages && options.messages.restoreTitle)) {\n        instance.messages.restoreTitle = options.messages.restoreTitle;\n      }\n\n      if (isPresent(options.messages && options.messages.maximizeTitle)) {\n        instance.messages.maximizeTitle = options.messages.maximizeTitle;\n      }\n\n      if (isPresent(options.messages && options.messages.minimizeTitle)) {\n        instance.messages.minimizeTitle = options.messages.minimizeTitle;\n      }\n\n      if (isPresent(options.autoFocusedElement)) {\n        instance.autoFocusedElement = options.autoFocusedElement;\n      }\n\n      if (isPresent(options.state)) {\n        instance.state = options.state;\n\n        if (options.state === 'minimized') {\n          instance.keepContent = true;\n        }\n      }\n\n      if (options.content instanceof TemplateRef) {\n        instance.contentTemplate = options.content;\n      }\n\n      if (options.titleBarContent instanceof TemplateRef) {\n        instance.titleBarTemplate = options.titleBarContent;\n      }\n    }\n\n    contentFrom(content, container, windowRef) {\n      const renderer = container.injector.get(Renderer2);\n      let nodes = [];\n      let componentRef = null;\n\n      if (typeof content === 'string') {\n        nodes = [renderer.createText(content)];\n      } else if (content && !(content instanceof TemplateRef)) {\n        const injector = new WindowInjector(() => windowRef, container.injector);\n        const factory = this.resolver.resolveComponentFactory(content);\n        componentRef = container.createComponent(factory, undefined, injector);\n        nodes = [componentRef.location.nativeElement];\n        windowRef.content = componentRef;\n      }\n\n      return {\n        componentRef,\n        nodes: [[], nodes // Content\n        ]\n      };\n    }\n\n  }\n\n  WindowService.ɵfac = function WindowService_Factory(t) {\n    return new (t || WindowService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(WindowContainerService));\n  };\n\n  WindowService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WindowService,\n    factory: WindowService.ɵfac\n  });\n  return WindowService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides an insertion point for the Dialogs which are created through the\n * Dialog service ([see example]({% slug api_dialog_dialogservice %}#toc-open)).\n * Created Dialogs will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoDialogContainer></div>\n * ```\n */\n\n\nlet DialogContainerDirective = /*#__PURE__*/(() => {\n  class DialogContainerDirective {\n    constructor(container, service) {\n      service.container = container;\n    }\n\n  }\n\n  DialogContainerDirective.ɵfac = function DialogContainerDirective_Factory(t) {\n    return new (t || DialogContainerDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DialogContainerService));\n  };\n\n  DialogContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DialogContainerDirective,\n    selectors: [[\"\", \"kendoDialogContainer\", \"\"]]\n  });\n  return DialogContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug globalization_dialogs %}#toc-localization)).\n */\n\n\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  class CustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) {\n    return new (t || CustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  CustomMessagesComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CustomMessagesComponent,\n    selectors: [[\"kendo-dialog-messages\"], [\"kendo-window-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => CustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst SHARED_DIRECTIVES = [DialogActionsComponent, CustomMessagesComponent, LocalizedMessagesDirective];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {}\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], CommonModule]\n  });\n  return SharedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst DIALOG_DIRECTIVES = [DialogComponent, DialogTitleBarComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dialog component that includes all Dialog components and directives.\n * Imports `DialogModule` into the [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)\n * of your application or into any other sub-module that will use the Dialog component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { DialogModule } from '@progress/kendo-angular-dialog';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\n\nlet DialogModule = /*#__PURE__*/(() => {\n  class DialogModule {}\n\n  DialogModule.ɵfac = function DialogModule_Factory(t) {\n    return new (t || DialogModule)();\n  };\n\n  DialogModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DialogModule\n  });\n  DialogModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DialogContainerService, DialogService],\n    imports: [[SharedModule]]\n  });\n  return DialogModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides an insertion point for the Windows which are created through the\n * Window service ([see example]({% slug api_dialog_windowservice %}#toc-open)).\n * Created Windows will be mounted after that element.\n *\n * @example\n * ```html-no-run\n * <div kendoWindowContainer></div>\n * ```\n */\n\n\nlet WindowContainerDirective = /*#__PURE__*/(() => {\n  class WindowContainerDirective {\n    constructor(container, service) {\n      service.container = container;\n    }\n\n  }\n\n  WindowContainerDirective.ɵfac = function WindowContainerDirective_Factory(t) {\n    return new (t || WindowContainerDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(WindowContainerService));\n  };\n\n  WindowContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WindowContainerDirective,\n    selectors: [[\"\", \"kendoWindowContainer\", \"\"]]\n  });\n  return WindowContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst WINDOW_DIRECTIVES = [ResizeHandleDirective, WindowComponent, WindowTitleBarComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective];\nconst ENTRY_COMPONENTS = [WindowComponent, WindowTitleBarComponent];\nconst exportedModules = [WindowComponent, WindowCloseActionDirective, WindowMinimizeActionDirective, WindowMaximizeActionDirective, WindowRestoreActionDirective, WindowTitleBarComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Window component. Imports `WindowModule` into the\n * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)\n * of your application or into any other sub-module that will use the Window component.\n *\n * @example\n * ```ts-no-run\n * import { NgModule } from '@angular/core';\n * import { BrowserModule } from '@angular/platform-browser';\n * import { WindowModule } from '@progress/kendo-angular-window';\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     bootstrap:    [AppComponent],\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, WindowModule]\n * })\n * export class AppModule {\n * }\n * ```\n */\n\nlet WindowModule = /*#__PURE__*/(() => {\n  class WindowModule {}\n\n  WindowModule.ɵfac = function WindowModule_Factory(t) {\n    return new (t || WindowModule)();\n  };\n\n  WindowModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: WindowModule\n  });\n  WindowModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [WindowContainerService, WindowService],\n    imports: [[SharedModule, DraggableModule]]\n  });\n  return WindowModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dialogs components.\n *\n * @example\n *\n * ```ts-no-run\n * import { DialogsModule } from '@progress/kendo-angular-dialog';\n *\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { NgModule } from '@angular/core';\n *\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, DialogsModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet DialogsModule = /*#__PURE__*/(() => {\n  class DialogsModule {}\n\n  DialogsModule.ɵfac = function DialogsModule_Factory(t) {\n    return new (t || DialogsModule)();\n  };\n\n  DialogsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DialogsModule\n  });\n  DialogsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [DialogModule, WindowModule]\n  });\n  return DialogsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CustomMessagesComponent, DialogAction, DialogActionsComponent, DialogCloseResult, DialogComponent, DialogContainerDirective, DialogContentBase, DialogModule, DialogRef, DialogService, DialogSettings, DialogTitleBarComponent, DialogsModule, LocalizedMessagesDirective, Messages, PreventableEvent, WindowCloseActionDirective, WindowCloseResult, WindowComponent, WindowContainerDirective, WindowMaximizeActionDirective, WindowMinimizeActionDirective, WindowModule, WindowRef, WindowRestoreActionDirective, WindowService, WindowSettings, WindowTitleBarComponent };","map":null,"metadata":{},"sourceType":"module"}