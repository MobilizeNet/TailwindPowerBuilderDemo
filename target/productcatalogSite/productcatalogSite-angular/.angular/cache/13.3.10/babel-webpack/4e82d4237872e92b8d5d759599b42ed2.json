{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Directive, Optional, Injectable, isDevMode, Component, SkipSelf, Host, Input, ViewChild, HostBinding, ViewChildren, ContentChildren, EventEmitter, Output, ContentChild, HostListener, Inject, QueryList, NgZone, forwardRef, ElementRef, ViewEncapsulation, TemplateRef, NgModule } from '@angular/core';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';\nimport * as i1$1 from '@progress/kendo-angular-common';\nimport { Keys, PreventableEvent as PreventableEvent$1, isDocumentAvailable, hasObservers, EventsModule, DraggableModule, ResizeSensorModule, isChanged } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1$2 from '@angular/animations';\nimport { trigger, state, style, transition, animate, AUTO_STYLE } from '@angular/animations';\nimport { Subject, BehaviorSubject, Subscription, of } from 'rxjs';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { delay, takeUntil, map, tap, filter, switchMap, take } from 'rxjs/operators';\nimport * as i4 from '@progress/kendo-angular-progressbar';\nimport { ProgressBarModule } from '@progress/kendo-angular-progressbar';\nimport Draggable from '@progress/kendo-draggable';\n/**\n * @hidden\n */\n\nconst _c0 = [\"header\"];\nconst _c1 = [\"contentWrapper\"];\n\nfunction PanelBarItemComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.iconClasses);\n  }\n}\n\nfunction PanelBarItemComponent_img_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"src\", ctx_r2.imageUrl, i0.ɵɵsanitizeUrl);\n  }\n}\n\nfunction PanelBarItemComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 8);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.title);\n  }\n}\n\nfunction PanelBarItemComponent_5_ng_template_0_Template(rf, ctx) {}\n\nconst _c2 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n  return {\n    title: a0,\n    id: a1,\n    icon: a2,\n    iconClass: a3,\n    imageUrl: a4,\n    selected: a5,\n    expanded: a6,\n    disabled: a7,\n    focused: a8,\n    content: a9\n  };\n};\n\nconst _c3 = function (a0) {\n  return {\n    item: a0\n  };\n};\n\nfunction PanelBarItemComponent_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PanelBarItemComponent_5_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.titleTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(13, _c3, i0.ɵɵpureFunctionV(2, _c2, [ctx_r4.title, ctx_r4.id, ctx_r4.icon, ctx_r4.iconClass, ctx_r4.imageUrl, ctx_r4.selected, ctx_r4.expanded, ctx_r4.disabled, ctx_r4.focused, ctx_r4.content])));\n  }\n}\n\nconst _c4 = function (a0, a1) {\n  return {\n    \"k-i-arrow-chevron-up k-panelbar-collapse\": a0,\n    \"k-i-arrow-chevron-down k-panelbar-expand\": a1\n  };\n};\n\nfunction PanelBarItemComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(1, _c4, ctx_r5.expanded, !ctx_r5.expanded));\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r9.contentOverflow)(\"height\", ctx_r9.contentHeight);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_3_ng_template_1_Template(rf, ctx) {}\n\nconst _c5 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    title: a0,\n    id: a1,\n    icon: a2,\n    imageUrl: a3,\n    disabled: a4,\n    content: a5\n  };\n};\n\nconst _c6 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction PanelBarItemComponent_div_7_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r10.contentOverflow)(\"height\", ctx_r10.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r10.contentTemplate.first.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(13, _c6, i0.ɵɵpureFunction6(6, _c5, ctx_r10.title, ctx_r10.id, ctx_r10.icon, ctx_r10.imageUrl, ctx_r10.disabled, ctx_r10.content)));\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-panelbar-item\", 18);\n  }\n\n  if (rf & 2) {\n    const item_r15 = i0.ɵɵnextContext().$implicit;\n    const ctx_r16 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"title\", item_r15.title)(\"id\", item_r15.id)(\"icon\", item_r15.icon)(\"iconClass\", item_r15.iconClass)(\"imageUrl\", item_r15.imageUrl)(\"selected\", !!item_r15.selected)(\"expanded\", !!item_r15.expanded)(\"disabled\", !!item_r15.disabled)(\"template\", ctx_r16.template)(\"items\", item_r15.children)(\"content\", item_r15.content);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template, 1, 11, \"kendo-panelbar-item\", 17);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r15 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r15.hidden);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_Template, 2, 1, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r11.contentOverflow)(\"height\", ctx_r11.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r11.items);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_5_ng_template_1_Template(rf, ctx) {}\n\nfunction PanelBarItemComponent_div_7_div_5_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(3);\n    i0.ɵɵtextInterpolate(ctx_r19.content);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_5_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_5_ng_template_2_Template, 1, 1, \"ng-template\", 19);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"overflow\", ctx_r12.contentOverflow)(\"height\", ctx_r12.contentHeight);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r12.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(14, _c6, i0.ɵɵpureFunction6(7, _c5, ctx_r12.title, ctx_r12.id, ctx_r12.icon, ctx_r12.imageUrl, ctx_r12.disabled, ctx_r12.content)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.template);\n  }\n}\n\nfunction PanelBarItemComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", null, 11);\n    i0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_2_Template, 2, 4, \"div\", 12);\n    i0.ɵɵtemplate(3, PanelBarItemComponent_div_7_div_3_Template, 2, 15, \"div\", 13);\n    i0.ɵɵtemplate(4, PanelBarItemComponent_div_7_div_4_Template, 2, 5, \"div\", 12);\n    i0.ɵɵtemplate(5, PanelBarItemComponent_div_7_div_5_Template, 3, 16, \"div\", 13);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@toggle\", ctx_r6.state);\n    i0.ɵɵattribute(\"role\", \"group\")(\"aria-hidden\", !ctx_r6.disabled && !ctx_r6.expanded);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasChildItems && !(ctx_r6.items == null ? null : ctx_r6.items.length));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasContent && !ctx_r6.content);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.hasItems);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.content);\n  }\n}\n\nconst _c7 = [[[\"kendo-panelbar-item\"]]];\nconst _c8 = [\"kendo-panelbar-item\"];\n\nfunction PanelBarComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"contentChildItems && !items\"]);\n  }\n}\n\nfunction PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-panelbar-item\", 4);\n  }\n\n  if (rf & 2) {\n    const item_r3 = i0.ɵɵnextContext().$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", item_r3.title)(\"id\", item_r3.id)(\"icon\", item_r3.icon)(\"iconClass\", item_r3.iconClass)(\"imageUrl\", item_r3.imageUrl)(\"selected\", !!item_r3.selected)(\"expanded\", !!item_r3.expanded)(\"disabled\", !!item_r3.disabled)(\"template\", ctx_r4.templateRef)(\"items\", item_r3.children)(\"content\", item_r3.content);\n  }\n}\n\nfunction PanelBarComponent_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template, 1, 11, \"kendo-panelbar-item\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r3 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r3.hidden);\n  }\n}\n\nfunction PanelBarComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PanelBarComponent_ng_template_1_ng_container_0_Template, 2, 1, \"ng-container\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.items);\n  }\n}\n\nfunction SplitterPaneComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction SplitterPaneComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 2);\n  }\n}\n\nconst _c9 = [\"*\"];\n\nfunction SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-splitter-bar\", 2);\n  }\n\n  if (rf & 2) {\n    const index_r2 = i0.ɵɵnextContext().index;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"index\", index_r2)(\"orientation\", ctx_r4.orientation);\n  }\n}\n\nfunction SplitterComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template, 1, 2, \"kendo-splitter-bar\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const last_r3 = ctx.last;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !last_r3);\n  }\n}\n\nconst _c10 = [[[\"kendo-splitter-pane\"]]];\nconst _c11 = [\"kendo-splitter-pane\"];\nconst _c12 = [\"kendoTabStripScrollableButton\", \"\"];\nconst _c13 = [\"kendoTabStripTab\", \"\"];\n\nfunction TabComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.tab.title);\n  }\n}\n\nfunction TabComponent_span_1_ng_template_1_Template(rf, ctx) {}\n\nfunction TabComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵtemplate(1, TabComponent_span_1_ng_template_1_Template, 0, 0, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.tab.tabTitle == null ? null : ctx_r1.tab.tabTitle.templateRef);\n  }\n}\n\nfunction TabComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵlistener(\"click\", function TabComponent_span_2_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.closeTab(ctx_r4.index);\n    });\n    i0.ɵɵelement(1, \"span\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r2.closeButtonTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.closeButtonTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r2.closeButtonClasses);\n  }\n}\n\nconst _c14 = [\"tablist\"];\nconst _c15 = [\"prevScrollButton\"];\nconst _c16 = [\"nextScrollButton\"];\nconst _c17 = [\"tabHeaderContainer\"];\n\nfunction TabStripComponent_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction TabStripComponent_ng_container_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction TabStripComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TabStripComponent_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵtemplate(2, TabStripComponent_ng_container_1_ng_container_2_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(4);\n\n    const _r4 = i0.ɵɵreference(6);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n  }\n}\n\nfunction TabStripComponent_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction TabStripComponent_ng_container_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction TabStripComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TabStripComponent_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵtemplate(2, TabStripComponent_ng_container_2_ng_container_2_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(6);\n\n    const _r2 = i0.ɵɵreference(4);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nfunction TabStripComponent_ng_template_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 11, 12);\n    i0.ɵɵlistener(\"tabScroll\", function TabStripComponent_ng_template_3_span_1_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.tabScroll.emit($event);\n    })(\"onClick\", function TabStripComponent_ng_template_3_span_1_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return ctx_r18.onScrollButtonClick($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r11.scrollable)(\"tabPosition\", ctx_r11.tabPosition)(\"prev\", true);\n  }\n}\n\nfunction TabStripComponent_ng_template_3_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"li\", 13, 14);\n    i0.ɵɵlistener(\"tabClose\", function TabStripComponent_ng_template_3_ng_container_4_Template_li_tabClose_1_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.tabClose.emit($event);\n    })(\"click\", function TabStripComponent_ng_template_3_ng_container_4_Template_li_click_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r23);\n      const i_r20 = restoredCtx.index;\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.onTabClick($event, i_r20);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r19 = ctx.$implicit;\n    const i_r20 = ctx.index;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", tab_r19.cssClass)(\"ngStyle\", tab_r19.cssStyle)(\"tab\", tab_r19)(\"index\", i_r20)(\"tabStripClosable\", ctx_r13.closable)(\"tabStripCloseIcon\", ctx_r13.closeIcon)(\"id\", \"k-tabstrip-tab-\" + i_r20);\n    i0.ɵɵattribute(\"aria-controls\", \"k-tabstrip-tabpanel-\" + i_r20);\n  }\n}\n\nfunction TabStripComponent_ng_template_3_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 11, 15);\n    i0.ɵɵlistener(\"tabScroll\", function TabStripComponent_ng_template_3_span_5_Template_span_tabScroll_0_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.tabScroll.emit($event);\n    })(\"onClick\", function TabStripComponent_ng_template_3_span_5_Template_span_onClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.onScrollButtonClick($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"scrollable\", ctx_r14.scrollable)(\"tabPosition\", ctx_r14.tabPosition)(\"prev\", false);\n  }\n}\n\nfunction TabStripComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 6);\n    i0.ɵɵtemplate(1, TabStripComponent_ng_template_3_span_1_Template, 2, 3, \"span\", 7);\n    i0.ɵɵelementStart(2, \"ul\", 8, 9);\n    i0.ɵɵtemplate(4, TabStripComponent_ng_template_3_ng_container_4_Template, 3, 8, \"ng-container\", 10);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, TabStripComponent_ng_template_3_span_5_Template, 2, 3, \"span\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.itemsWrapperClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"justify-content\", ctx_r3.tabsAlignmentStyles)(\"width\", ctx_r3.tabListWidth)(\"height\", ctx_r3.tabListHeight);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.tabs);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.hasScrollButtons);\n  }\n}\n\nfunction TabStripComponent_ng_template_5_ng_template_0_div_0_ng_template_1_Template(rf, ctx) {}\n\nfunction TabStripComponent_ng_template_5_ng_template_0_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18);\n    i0.ɵɵtemplate(1, TabStripComponent_ng_template_5_ng_template_0_div_0_ng_template_1_Template, 0, 0, \"ng-template\", 19);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r34 = i0.ɵɵnextContext();\n    const tab_r30 = ctx_r34.$implicit;\n    const i_r31 = ctx_r34.index;\n    const ctx_r32 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"@state\", tab_r30.selected && ctx_r32.animate ? \"active\" : \"inactive\")(\"ngClass\", !ctx_r32.keepTabContent || tab_r30.selected ? \"k-content k-state-active\" : \"k-content\")(\"tabIndex\", 0)(\"id\", \"k-tabstrip-tabpanel-\" + i_r31);\n    i0.ɵɵattribute(\"aria-hidden\", !tab_r30.selected)(\"aria-expanded\", tab_r30.selected)(\"aria-labelledby\", \"k-tabstrip-tab-\" + i_r31)(\"aria-disabled\", tab_r30.disabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r30.tabContent == null ? null : tab_r30.tabContent.templateRef);\n  }\n}\n\nfunction TabStripComponent_ng_template_5_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TabStripComponent_ng_template_5_ng_template_0_div_0_Template, 2, 9, \"div\", 17);\n  }\n\n  if (rf & 2) {\n    const tab_r30 = ctx.$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", tab_r30.selected || ctx_r29.keepTabContent);\n  }\n}\n\nfunction TabStripComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TabStripComponent_ng_template_5_ng_template_0_Template, 1, 1, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r5.tabs);\n  }\n}\n\nfunction TabStripComponent_kendo_resize_sensor_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 20);\n    i0.ɵɵlistener(\"resize\", function TabStripComponent_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext();\n      return ctx_r35.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c20 = [\"kendoDrawerItem\", \"\"];\n\nfunction DrawerItemComponent_0_ng_template_0_Template(rf, ctx) {}\n\nconst _c21 = function (a0, a1, a2, a3) {\n  return {\n    $implicit: a0,\n    isItemExpanded: a1,\n    hasChildren: a2,\n    level: a3\n  };\n};\n\nfunction DrawerItemComponent_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DrawerItemComponent_0_ng_template_0_Template, 0, 0, \"ng-template\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c21, ctx_r0.item, ctx_r0.viewItem.isExpanded, ctx_r0.viewItem.hasChildren, ctx_r0.viewItem.level));\n  }\n}\n\nfunction DrawerItemComponent_ng_template_1_ng_container_0_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵclassProp(\"k-i-arrow-chevron-up\", ctx_r6.viewItem.isExpanded)(\"k-i-arrow-chevron-down\", !ctx_r6.viewItem.isExpanded);\n  }\n}\n\nfunction DrawerItemComponent_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementStart(2, \"span\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, DrawerItemComponent_ng_template_1_ng_container_0_span_4_Template, 1, 4, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r4.iconClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r4.item.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.viewItem.hasChildren);\n  }\n}\n\nfunction DrawerItemComponent_ng_template_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r5.iconClasses);\n  }\n}\n\nfunction DrawerItemComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DrawerItemComponent_ng_template_1_ng_container_0_Template, 5, 3, \"ng-container\", 3);\n    i0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_ng_container_1_Template, 2, 1, \"ng-container\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.expanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.mini && !ctx_r2.expanded);\n  }\n}\n\nconst _c22 = [\"kendoDrawerList\", \"\"];\n\nfunction DrawerListComponent_ng_container_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"li\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    const v_r1 = ctx_r5.$implicit;\n    const idx_r2 = ctx_r5.index;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"k-drawer-item \", ctx_r3.expanded ? \" k-level-\" + v_r1.level : \"\", \"\");\n    i0.ɵɵproperty(\"viewItem\", v_r1)(\"index\", idx_r2)(\"mini\", ctx_r3.mini)(\"expanded\", ctx_r3.expanded)(\"itemTemplate\", ctx_r3.itemTemplate)(\"ngClass\", v_r1.item.cssClass)(\"ngStyle\", v_r1.item.cssStyle);\n    i0.ɵɵattribute(\"data-kendo-drawer-index\", v_r1.index);\n  }\n}\n\nfunction DrawerListComponent_ng_container_0_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 4);\n    i0.ɵɵtext(1, \" \\xA0 \");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const v_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngClass\", v_r1.item.cssClass)(\"ngStyle\", v_r1.item.cssStyle);\n  }\n}\n\nfunction DrawerListComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, DrawerListComponent_ng_container_0_li_1_Template, 1, 11, \"li\", 1);\n    i0.ɵɵtemplate(2, DrawerListComponent_ng_container_0_li_2_Template, 2, 2, \"li\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const v_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !v_r1.item.separator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", v_r1.item.separator);\n  }\n}\n\nfunction DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template(rf, ctx) {}\n\nfunction DrawerComponent_div_0_ng_container_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.headerTemplate == null ? null : ctx_r3.headerTemplate.templateRef);\n  }\n}\n\nfunction DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template(rf, ctx) {}\n\nfunction DrawerComponent_div_0_ng_container_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.footerTemplate == null ? null : ctx_r4.footerTemplate.templateRef);\n  }\n}\n\nfunction DrawerComponent_div_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_1_Template, 1, 1, null, 2);\n    i0.ɵɵelementStart(2, \"ul\", 3);\n    i0.ɵɵlistener(\"select\", function DrawerComponent_div_0_ng_container_1_Template_ul_select_2_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.onSelect($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, DrawerComponent_div_0_ng_container_1_3_Template, 1, 1, null, 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"mini\", ctx_r1.mini)(\"expanded\", ctx_r1.expanded)(\"view\", ctx_r1.viewItems)(\"itemTemplate\", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.footerTemplate);\n  }\n}\n\nfunction DrawerComponent_div_0_2_ng_template_0_Template(rf, ctx) {}\n\nfunction DrawerComponent_div_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DrawerComponent_div_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.drawerTemplate == null ? null : ctx_r2.drawerTemplate.templateRef);\n  }\n}\n\nfunction DrawerComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_Template, 4, 6, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, DrawerComponent_div_0_2_Template, 1, 1, null, 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.drawerWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.drawerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.drawerTemplate);\n  }\n}\n\nfunction DrawerContainerComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function DrawerContainerComponent_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.closeDrawer();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c23 = [\"stepLink\"];\nconst _c24 = [\"kendoStepperStep\", \"\"];\n\nfunction StepperStepComponent_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c25 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    index: a1\n  };\n};\n\nfunction StepperStepComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, StepperStepComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.stepTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c25, ctx_r1.step, ctx_r1.index));\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template(rf, ctx) {}\n\nfunction StepperStepComponent_ng_container_3_span_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.indicatorTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c25, ctx_r6.step, ctx_r6.index));\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"ngClass\", ctx_r9.indicatorIconClasses);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r10.indicatorText);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template, 1, 1, \"span\", 7);\n    i0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template, 2, 1, \"span\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.showIndicatorIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.showIndicatorIcon);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_1_Template, 1, 5, null, 2);\n    i0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_Template, 3, 2, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"transition-duration\", ctx_r4.transitionDuration, \"ms\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.indicatorTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.indicatorTemplate);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template(rf, ctx) {}\n\nfunction StepperStepComponent_ng_container_3_span_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r11.labelTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c25, ctx_r11.step, ctx_r11.index));\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r14.step.label);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"ngClass\", ctx_r15.validationIconClasses);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 17);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\"(\", ctx_r16.optionalText, \")\");\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template, 2, 1, \"span\", 12);\n    i0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template, 1, 1, \"span\", 13);\n    i0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template, 2, 1, \"span\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.showLabelText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.showLabelIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.step.optional);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_1_Template, 1, 5, null, 2);\n    i0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_Template, 4, 3, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.labelTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.labelTemplate);\n  }\n}\n\nfunction StepperStepComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_Template, 3, 4, \"span\", 4);\n    i0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_Template, 3, 2, \"span\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.showIndicator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.showLabel);\n  }\n}\n\nconst _c26 = [\"kendoStepperList\", \"\"];\n\nfunction StepperListComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"li\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const step_r1 = ctx.$implicit;\n    const idx_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"max-width\", ctx_r0.maxStepWidth, \"%\")(\"max-height\", ctx_r0.maxStepHeight, \"%\");\n    i0.ɵɵclassProp(\"k-step-first\", idx_r2 === 0)(\"k-step-last\", idx_r2 === ctx_r0.steps.length - 1)(\"k-step-done\", idx_r2 < ctx_r0.currentStep)(\"k-step-current\", idx_r2 === ctx_r0.currentStep)(\"k-step-optional\", step_r1.optional)(\"k-step-disabled\", step_r1.disabled);\n    i0.ɵɵproperty(\"type\", ctx_r0.stepType)(\"step\", step_r1)(\"index\", idx_r2)(\"current\", ctx_r0.currentStep)(\"successIcon\", ctx_r0.successIcon)(\"errorIcon\", ctx_r0.errorIcon)(\"indicatorTemplate\", ctx_r0.indicatorTemplate)(\"labelTemplate\", ctx_r0.labelTemplate)(\"stepTemplate\", ctx_r0.stepTemplate)(\"ngClass\", step_r1.cssClass)(\"ngStyle\", step_r1.cssStyle);\n    i0.ɵɵattribute(\"data-kendo-stepper-index\", idx_r2);\n  }\n}\n\nfunction StepperComponent_kendo_progressbar_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-progressbar\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"animation\", ctx_r0.progressAnimation)(\"max\", ctx_r0.steps.length - 1)(\"label\", false)(\"orientation\", ctx_r0.orientation)(\"reverse\", !ctx_r0.isHorizontal)(\"value\", ctx_r0.currentStep)(\"ngStyle\", ctx_r0.progressBarStyling);\n    i0.ɵɵattribute(\"aria-hidden\", true);\n  }\n}\n\nfunction AvatarComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"customAvatar\"]);\n  }\n}\n\nfunction AvatarComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 1);\n    i0.ɵɵelement(2, \"img\", 2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵpropertyInterpolate(\"src\", ctx_r1.imageSrc, i0.ɵɵsanitizeUrl);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.cssStyle);\n  }\n}\n\nfunction AvatarComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.cssStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.initials.substring(0, 2));\n  }\n}\n\nfunction AvatarComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r3.cssStyle)(\"ngClass\", ctx_r3.iconClasses());\n  }\n}\n\nfunction CardActionsComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!actionsArray && !actionsTemplate\"]);\n  }\n}\n\nfunction CardActionsComponent_ng_container_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function CardActionsComponent_ng_container_1_button_1_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r6);\n      const action_r4 = restoredCtx.$implicit;\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.onClick(action_r4);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const action_r4 = ctx.$implicit;\n    i0.ɵɵclassProp(\"k-primary\", action_r4.primary)(\"k-flat\", action_r4.flat);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", action_r4.text, \" \");\n  }\n}\n\nfunction CardActionsComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_button_1_Template, 2, 5, \"button\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.actionsArray);\n  }\n}\n\nfunction CardActionsComponent_2_ng_template_0_Template(rf, ctx) {}\n\nfunction CardActionsComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CardActionsComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.actionsTemplate);\n  }\n}\n\nconst _c29 = [\"content\"];\n\nfunction ExpansionPanelComponent_ng_container_1_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.title);\n  }\n}\n\nfunction ExpansionPanelComponent_ng_container_1_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.subtitle, \" \");\n  }\n}\n\nfunction ExpansionPanelComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ExpansionPanelComponent_ng_container_1_div_1_Template, 2, 1, \"div\", 7);\n    i0.ɵɵelement(2, \"span\", 8);\n    i0.ɵɵtemplate(3, ExpansionPanelComponent_ng_container_1_div_3_Template, 2, 1, \"div\", 9);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.subtitle);\n  }\n}\n\nfunction ExpansionPanelComponent_2_ng_template_0_Template(rf, ctx) {}\n\nfunction ExpansionPanelComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ExpansionPanelComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.titleTemplate == null ? null : ctx_r1.titleTemplate.templateRef);\n  }\n}\n\nfunction TileLayoutItemComponent_kendo_tilelayout_item_header_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-tilelayout-item-header\", 2)(1, \"h5\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"reorderable\", ctx_r0.reorderableHeader);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\n\nfunction TileLayoutItemComponent_ng_container_2_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 5);\n  }\n\n  if (rf & 2) {\n    const dir_r3 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMapInterpolate1(\"k-resize-handle k-cursor-\", dir_r3, \"-resize k-touch-action-none\");\n    i0.ɵɵproperty(\"rtl\", ctx_r2.rtl)(\"resizeDirection\", dir_r3);\n  }\n}\n\nfunction TileLayoutItemComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TileLayoutItemComponent_ng_container_2_div_1_Template, 1, 5, \"div\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.resizeDirections);\n  }\n}\n\nconst _c30 = [\"hint\"];\nconst packageMetadata = {\n  name: '@progress/kendo-angular-layout',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1655110279,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Represents the expand modes of the PanelBar.\n * By default, the expand mode is set to `multiple`.\n */\n\nvar PanelBarExpandMode = /*#__PURE__*/(() => {\n  (function (PanelBarExpandMode) {\n    /**\n     * Allows you to expand only one item at a time.\n     * When you expand an item, the item that was previously expanded is coll.\n     */\n    PanelBarExpandMode[PanelBarExpandMode[\"Single\"] = 0] = \"Single\";\n    /**\n     * Allows you to expand only one item at a time and requires you to set the `height` property.\n     * The expanded area occupies the entire height of the PanelBar.\n     */\n\n    PanelBarExpandMode[PanelBarExpandMode[\"Full\"] = 1] = \"Full\";\n    /**\n     * The default mode of the PanelBar.\n     * Allows you to expand more than one item at a time. Items can also be toggled.\n     */\n\n    PanelBarExpandMode[PanelBarExpandMode[\"Multiple\"] = 2] = \"Multiple\";\n    /**\n     * By default, the expand mode is set to `multiple`.\n     */\n\n    PanelBarExpandMode[PanelBarExpandMode[\"Default\"] = 2] = \"Default\";\n  })(PanelBarExpandMode || (PanelBarExpandMode = {}));\n\n  return PanelBarExpandMode;\n})();\n\n/**\n * Represents the content template of the declaratively initialized PanelBar items.\n * The content can be expanded or collapsed through the item.\n */\nlet PanelBarContentDirective = /*#__PURE__*/(() => {\n  class PanelBarContentDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PanelBarContentDirective.ɵfac = function PanelBarContentDirective_Factory(t) {\n    return new (t || PanelBarContentDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  PanelBarContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PanelBarContentDirective,\n    selectors: [[\"\", \"kendoPanelBarContent\", \"\"]]\n  });\n  return PanelBarContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template directive of the PanelBar which helps to customize the item title\n * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).\n *\n * > The `kendoPanelBarItemTitle` directive overrides the PanelBarItem [title]({% slug api_layout_panelbaritemcomponent %}#toc-title) option.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *        <kendo-panelbar>\n *            <kendo-panelbar-item [expanded]=\"true\">\n *                <ng-template kendoPanelBarItemTitle>\n *                    Item Title\n *                </ng-template>\n *            </kendo-panelbar-item>\n *        </kendo-panelbar>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\n\n\nlet PanelBarItemTitleDirective = /*#__PURE__*/(() => {\n  class PanelBarItemTitleDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PanelBarItemTitleDirective.ɵfac = function PanelBarItemTitleDirective_Factory(t) {\n    return new (t || PanelBarItemTitleDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PanelBarItemTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PanelBarItemTitleDirective,\n    selectors: [[\"\", \"kendoPanelBarItemTitle\", \"\"]]\n  });\n  return PanelBarItemTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet nextId$1 = 0;\nconst SIZES = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg'\n};\nconst ROUNDNESS = {\n  small: 'sm',\n  medium: 'md',\n  large: 'lg',\n  full: 'full'\n};\nconst SHAPE_TO_ROUNDED = {\n  rounded: 'large',\n  circle: 'full'\n};\n/**\n * @hidden\n */\n\nconst parsePanelBarItems = data => {\n  return data.map(item => {\n    if (!item.id) {\n      item.id = `default-${nextId$1++}`;\n    }\n\n    if (item.children) {\n      item.children = parsePanelBarItems(item.children);\n    }\n\n    return item;\n  });\n};\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isHorizontalArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight;\n/**\n * @hidden\n */\n\n\nconst isVerticalArrowKey = keyCode => keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;\n/**\n * @hidden\n */\n\n\nconst isArrowKey = keyCode => isHorizontalArrowKey(keyCode) || isVerticalArrowKey(keyCode);\n/**\n * @hidden\n */\n\n\nconst isNavigationKey = keyCode => keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;\n/**\n * @hidden\n *\n * Returns the styling classes to be added and removed\n */\n\n\nconst getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {\n  switch (stylingOption) {\n    case 'size':\n      return {\n        toRemove: `k-${componentType}-${SIZES[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-${componentType}-${SIZES[newValue]}` : ''\n      };\n\n    case 'rounded':\n      return {\n        toRemove: `k-rounded-${ROUNDNESS[previousValue]}`,\n        toAdd: newValue !== 'none' ? `k-rounded-${ROUNDNESS[newValue]}` : ''\n      };\n\n    default:\n      break;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst mapShapeToRounded = shape => SHAPE_TO_ROUNDED[shape] || 'none';\n/**\n * @hidden\n */\n\n\nconst isNumber = value => typeof value === 'number' && isFinite(value);\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n/**\n * @hidden\n */\n\n\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n\n    return focusable;\n  }\n\n  return false;\n};\n/**\n * @hidden\n */\n\n\nconst hasClass = (element, className) => Boolean(toClassList(element.className).find(name => name === className));\n/**\n * @hidden\n */\n\n\nconst closestInScope = (target, predicate, scope, targetAttr) => {\n  while (target && target !== scope && !predicate(target, targetAttr)) {\n    target = target.parentNode;\n  }\n\n  if (target !== scope) {\n    return target;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);\n\nconst hasItemIndex = (item, indexAttr) => isPresent(item.getAttribute(indexAttr));\n/**\n * @hidden\n */\n\n\nconst closestItem = (target, targetAttr, scope) => closestInScope(target, hasItemIndex, scope, targetAttr);\n/**\n * @hidden\n */\n\n\nlet nextPanelbarId = 0;\n/**\n * @hidden\n */\n\nlet PanelBarService = /*#__PURE__*/(() => {\n  class PanelBarService {\n    constructor() {\n      this.parentSource = new Subject();\n      this.keepContentSource = new BehaviorSubject(false);\n      this.childSource = new Subject();\n      this.parent$ = this.parentSource.asObservable();\n      this.children$ = this.childSource.asObservable();\n      this.keepContent$ = this.keepContentSource.asObservable();\n      this.pbId = nextPanelbarId++;\n    }\n\n    onKeepContent(keepContent) {\n      this.keepContentSource.next(keepContent);\n    }\n\n    onSelect(event) {\n      this.childSource.next(event);\n    }\n\n    onFocus() {\n      this.parentSource.next(true);\n    }\n\n    onBlur() {\n      this.parentSource.next(false);\n    }\n\n  }\n\n  PanelBarService.ɵfac = function PanelBarService_Factory(t) {\n    return new (t || PanelBarService)();\n  };\n\n  PanelBarService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PanelBarService,\n    factory: PanelBarService.ɵfac\n  });\n  return PanelBarService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet nextId = 0;\n/**\n * Represents the items of the PanelBar.\n */\n\nlet PanelBarItemComponent = /*#__PURE__*/(() => {\n  class PanelBarItemComponent {\n    constructor(parent, eventService, element, renderer) {\n      this.parent = parent;\n      this.eventService = eventService;\n      this.element = element;\n      this.renderer = renderer;\n      /**\n       * Allows the component to set the `\"id\"` property to each item.\n       * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.\n       */\n\n      this.id = `default-${nextId++}`;\n      /**\n       * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).\n       */\n\n      this.icon = '';\n      /**\n       * Defines  the icon that will be rendered next to the title by using a custom CSS class\n       * ([see example]({% slug items_panelbar %}#toc-title-icons)).\n       */\n\n      this.iconClass = '';\n      /**\n       * Defines the location of the image that will be displayed next to the title\n       * ([see example]({% slug items_panelbar %}#toc-title-images)).\n       */\n\n      this.imageUrl = '';\n      /**\n       * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).\n       */\n\n      this.selected = false;\n      this.keepContent = false;\n      this.hasChildItems = false;\n      this.hasItems = false;\n      this.hasContent = false;\n      this.state = \"inactive\";\n      this.role = \"treeitem\";\n      this.titleAttribute = null; // eslint-disable-line\n\n      this.kItemClass = true;\n      this.focused = false;\n      this.wrapperFocused = false;\n      this.subscriptions = new Subscription(() => {});\n      this._expanded = false;\n      this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));\n      this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));\n      this.wrapperFocused = parent ? parent.focused : false;\n      this.level = this.parent ? this.parent.level + 1 : 0;\n    }\n    /**\n     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).\n     */\n\n\n    set expanded(value) {\n      const activeState = this.animate ? \"active\" : \"activeWithoutAnimation\";\n      this.state = value ? activeState : \"inactive\";\n\n      if (!this.keepContent) {\n        this.toggleExpandedChildAnimations(value);\n      }\n\n      this._expanded = value;\n    }\n\n    get expanded() {\n      return this._expanded;\n    }\n\n    get animate() {\n      return this.eventService.animate;\n    }\n\n    get kStateDefaultClass() {\n      return !this.disabled;\n    }\n\n    get kStateDisabledClass() {\n      return this.disabled;\n    }\n\n    get kStateExpandedClass() {\n      return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);\n    }\n\n    get itemId() {\n      return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;\n    }\n\n    get ariaExpanded() {\n      return this.hasChildItems || this.hasContent ? !this.disabled && this.expanded : null;\n    }\n\n    get ariaSelected() {\n      return !this.disabled && this.selected;\n    }\n\n    get ariaDisabled() {\n      return this.disabled ? true : null;\n    }\n\n    get headerClass() {\n      return this.parent ? null : true;\n    }\n\n    get childClass() {\n      return this.parent ? true : null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get titleTemplate() {\n      return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    headerHeight() {\n      return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);\n    }\n\n    ngOnInit() {\n      this.addLevelClass();\n    }\n\n    ngAfterContentChecked() {\n      this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;\n      this.hasChildItems = this.contentItems.filter(item => item !== this).length > 0 || this.hasItems;\n      this.hasContent = this.contentTemplate !== undefined && this.contentTemplate.length > 0 || this.content !== undefined;\n      this.validateConfiguration();\n    }\n\n    ngAfterViewChecked() {\n      if (this.items) {\n        this.childrenItems = this.viewChildItems.toArray();\n      } else {\n        this.childrenItems = this.contentItems.filter(item => item !== this);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onItemAction() {\n      if (!this.disabled) {\n        this.eventService.onSelect(this);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onItemClick(e) {\n      if (!isFocusable(e.target)) {\n        this.onItemAction();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconClasses() {\n      let icon = this.icon ? 'k-i-' + this.icon : null;\n      return {\n        [icon || this.iconClass]: true\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    serialize() {\n      return {\n        content: this.content,\n        disabled: this.disabled,\n        expanded: this.expanded,\n        focused: this.focused,\n        icon: this.icon,\n        iconClass: this.iconClass,\n        id: this.id,\n        imageUrl: this.imageUrl,\n        selected: this.selected,\n        title: this.title\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    subTreeViewItems() {\n      let subTree = [];\n      this.viewChildItems.forEach(item => {\n        subTree = subTree.concat(item.subTreeViewItems());\n        subTree.push(item);\n      });\n      return subTree;\n    }\n    /**\n     * @hidden\n     */\n\n\n    validateConfiguration() {\n      if (isDevMode()) {\n        if (this.content && this.contentTemplate !== undefined && this.contentTemplate.length > 0) {\n          throw new Error(\"Invalid configuration: mixed template components and component property.\");\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleAnimationState(value) {\n      if (!this.animate) {\n        return;\n      }\n\n      this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleExpandedChildAnimations(value) {\n      if (this.childrenItems) {\n        this.childrenItems.forEach(child => {\n          if (child.expanded) {\n            child.toggleAnimationState(value);\n            child.toggleExpandedChildAnimations(value);\n          }\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    addLevelClass() {\n      if (this.level >= 0) {\n        this.renderer.addClass(this.element.nativeElement, `k-level-${this.level}`);\n      }\n    }\n\n    onWrapperFocusChange(focused) {\n      this.wrapperFocused = focused;\n    }\n\n  }\n\n  PanelBarItemComponent.ɵfac = function PanelBarItemComponent_Factory(t) {\n    return new (t || PanelBarItemComponent)(i0.ɵɵdirectiveInject(PanelBarItemComponent, 13), i0.ɵɵdirectiveInject(PanelBarService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  PanelBarItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PanelBarItemComponent,\n    selectors: [[\"kendo-panelbar-item\"]],\n    contentQueries: function PanelBarItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 4);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarContentDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemTitleDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItems = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleTemplates = _t);\n      }\n    },\n    viewQuery: function PanelBarItemComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(PanelBarItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);\n      }\n    },\n    hostVars: 18,\n    hostBindings: function PanelBarItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.itemId);\n        i0.ɵɵattribute(\"role\", ctx.role)(\"title\", ctx.titleAttribute)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-selected\", ctx.ariaSelected)(\"aria-disabled\", ctx.ariaDisabled);\n        i0.ɵɵclassProp(\"k-item\", ctx.kItemClass)(\"k-state-default\", ctx.kStateDefaultClass)(\"k-state-disabled\", ctx.kStateDisabledClass)(\"k-state-expanded\", ctx.kStateExpandedClass)(\"k-panelbar-header\", ctx.headerClass)(\"k-panelbar-item\", ctx.childClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      id: \"id\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      disabled: \"disabled\",\n      expanded: \"expanded\",\n      selected: \"selected\",\n      content: \"content\",\n      items: \"items\",\n      template: \"template\"\n    },\n    exportAs: [\"kendoPanelbarItem\"],\n    ngContentSelectors: _c8,\n    decls: 8,\n    vars: 12,\n    consts: [[3, \"click\"], [\"header\", \"\"], [\"class\", \"k-icon k-panelbar-item-icon\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-image k-panelbar-item-icon\", \"alt\", \"\", 3, \"src\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-icon k-panelbar-toggle\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-icon\", \"k-panelbar-item-icon\", 3, \"ngClass\"], [\"alt\", \"\", 1, \"k-image\", \"k-panelbar-item-icon\", 3, \"src\"], [1, \"k-panelbar-item-text\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-icon\", \"k-panelbar-toggle\", 3, \"ngClass\"], [\"contentWrapper\", \"\"], [\"class\", \"k-panel k-group k-panelbar-group\", 3, \"overflow\", \"height\", 4, \"ngIf\"], [\"class\", \"k-content k-panelbar-content\", 3, \"overflow\", \"height\", 4, \"ngIf\"], [1, \"k-panel\", \"k-group\", \"k-panelbar-group\"], [1, \"k-content\", \"k-panelbar-content\"], [4, \"ngFor\", \"ngForOf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\", 4, \"ngIf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\"], [3, \"ngIf\"]],\n    template: function PanelBarItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c7);\n        i0.ɵɵelementStart(0, \"span\", 0, 1);\n        i0.ɵɵlistener(\"click\", function PanelBarItemComponent_Template_span_click_0_listener($event) {\n          return ctx.onItemClick($event);\n        });\n        i0.ɵɵtemplate(2, PanelBarItemComponent_span_2_Template, 1, 1, \"span\", 2);\n        i0.ɵɵtemplate(3, PanelBarItemComponent_img_3_Template, 1, 1, \"img\", 3);\n        i0.ɵɵtemplate(4, PanelBarItemComponent_ng_container_4_Template, 3, 1, \"ng-container\", 4);\n        i0.ɵɵtemplate(5, PanelBarItemComponent_5_Template, 1, 15, null, 4);\n        i0.ɵɵtemplate(6, PanelBarItemComponent_span_6_Template, 1, 4, \"span\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, PanelBarItemComponent_div_7_Template, 6, 7, \"div\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-link\", true)(\"k-state-selected\", !ctx.disabled && ctx.selected)(\"k-state-focused\", ctx.focused && ctx.wrapperFocused);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.iconClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageUrl);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasChildItems || ctx.hasContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.keepContent || !ctx.disabled && ctx.expanded && (ctx.hasChildItems || ctx.hasContent));\n      }\n    },\n    directives: [PanelBarItemComponent, i2.NgIf, i2.NgClass, i2.NgTemplateOutlet, i2.NgForOf],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [state('inactive', style({\n        display: 'none'\n      })), transition('* => active', [style({\n        overflow: 'hidden',\n        display: 'block',\n        height: 0\n      }), animate(200, style({\n        height: AUTO_STYLE\n      }))]), transition('active => *', [style({\n        overflow: 'hidden',\n        height: AUTO_STYLE\n      }), animate(200, style({\n        height: 0,\n        display: 'none'\n      }))])])]\n    }\n  });\n  return PanelBarItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template directive of the PanelBar which helps to customize the item content.\n */\n\n\nlet PanelBarItemTemplateDirective = /*#__PURE__*/(() => {\n  class PanelBarItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PanelBarItemTemplateDirective.ɵfac = function PanelBarItemTemplateDirective_Factory(t) {\n    return new (t || PanelBarItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PanelBarItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PanelBarItemTemplateDirective,\n    selectors: [[\"\", \"kendoPanelBarItemTemplate\", \"\"]]\n  });\n  return PanelBarItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    this.prevented = false;\n    Object.assign(this, args);\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Arguments for the `collapse` event of the PanelBar.\n */\n\n\nclass PanelBarCollapseEvent extends PreventableEvent {}\n/**\n * Arguments for the `expand` event of the PanelBar.\n */\n\n\nclass PanelBarExpandEvent extends PreventableEvent {}\n/**\n * Arguments for the `select` event of the PanelBar.\n */\n\n\nclass PanelBarSelectEvent extends PreventableEvent {}\n/**\n * Arguments for the `stateChange` event of the PanelBar.\n */\n\n\nclass PanelBarStateChangeEvent {}\n/**\n * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).\n */\n// TODO: add styles as input prop\n\n\nlet PanelBarComponent = /*#__PURE__*/(() => {\n  class PanelBarComponent {\n    constructor(elementRef, eventService, localization) {\n      this.localization = localization;\n      /**\n       * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).\n       *\n       * The available modes are:\n       * - `\"single\"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.\n       * - `\"multiple\"`&mdash;The default mode of the PanelBar.\n       * Expands more than one item at a time. Items can also be toggled.\n       * - `\"full\"`&mdash;Expands only one item at a time.\n       * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.\n       */\n\n      this.expandMode = PanelBarExpandMode.Default;\n      /**\n       * Allows the PanelBar to modify the selected state of the items.\n       */\n\n      this.selectable = true;\n      /**\n       * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).\n       */\n\n      this.animate = true;\n      /**\n       * Sets the height of the component when the `\"full\"` expand mode is used.\n       * This option is ignored in the `\"multiple\"` and `\"single\"` expand modes.\n       */\n\n      this.height = '400px';\n      /**\n       * Fires each time the user interacts with a PanelBar item\n       * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).\n       * The event data contains a collection of all items that are modified.\n       */\n\n      this.stateChange = new EventEmitter();\n      /**\n       * Fires when an item is about to be selected.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will not be selected.\n       */\n\n      this.select = new EventEmitter();\n      /**\n       * Fires when an item is about to be expanded.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will remain collapsed.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when an item is about to be collapsed.\n       * ([see example]({% slug events_panelbar %}))\n       * This event is preventable. If you cancel it, the item will remain expanded.\n       */\n\n      this.collapse = new EventEmitter();\n      this.tabIndex = 0;\n      this.role = 'tree';\n      this.hostClass = true;\n      this.activeDescendant = '';\n      this.isViewInit = true;\n      this.focused = false;\n      this._keepItemContent = false;\n\n      this.updateChildrenHeight = () => {\n        let childrenHeight = 0;\n        const panelbarHeight = this.elementRef.nativeElement.offsetHeight;\n        const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';\n        this.childrenItems.forEach(item => {\n          childrenHeight += item.headerHeight();\n        });\n        this.childrenItems.forEach(item => {\n          item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? panelbarHeight - childrenHeight + 'px' : 'auto';\n          item.contentOverflow = contentOverflow;\n        });\n      };\n\n      validatePackage(packageMetadata);\n      /* eslint-disable-line*/\n\n      this.keyBindings = this.computedKeys;\n      this.elementRef = elementRef;\n      this.eventService = eventService;\n      this.eventService.children$.subscribe(event => this.onItemAction(event));\n    }\n    /**\n     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM\n     * ([see example]({% slug templates_panelbar %}#toc-collections)).\n     * By default, this option is set to `false`.\n     */\n\n\n    get keepItemContent() {\n      return this._keepItemContent;\n    }\n\n    set keepItemContent(keepItemContent) {\n      this._keepItemContent = keepItemContent;\n      this.eventService.onKeepContent(keepItemContent);\n    }\n    /**\n     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances\n     * ([see example]({% slug items_panelbar %})).\n     */\n\n\n    set items(data) {\n      if (data) {\n        this._items = parsePanelBarItems(data);\n      }\n    }\n\n    get items() {\n      return this._items;\n    }\n\n    get hostHeight() {\n      return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';\n    }\n\n    get overflow() {\n      return this.expandMode === PanelBarExpandMode.Full ? 'hidden' : 'visible';\n    }\n\n    get dir() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n\n\n    invertKeys(original, inverted) {\n      return this.localization.rtl ? inverted : original;\n    }\n\n    get computedKeys() {\n      return {\n        [Keys.Space]: () => this.selectFocusedItem(),\n        [Keys.Enter]: () => this.selectFocusedItem(),\n        [Keys.ArrowUp]: () => this.focusPreviousItem(),\n        [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),\n        [Keys.ArrowDown]: () => this.focusNextItem(),\n        [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),\n        [Keys.End]: () => this.focusLastItem(),\n        [Keys.Home]: () => this.focusFirstItem()\n      };\n    }\n\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n    }\n\n    ngOnInit() {\n      this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.keyBindings = this.computedKeys);\n      this.eventService.animate = this.animate;\n      this.eventService.expandMode = this.expandMode;\n    }\n\n    ngAfterViewChecked() {\n      if (this.items) {\n        this.childrenItems = this.viewChildItems.toArray();\n        this.allItems = this.viewItems;\n      } else {\n        this.childrenItems = this.contentChildItems.toArray();\n        this.allItems = this.contentItems.toArray();\n      }\n\n      if (this.isViewInit && this.childrenItems.length) {\n        this.isViewInit = false;\n        setTimeout(() => this.updateChildrenHeight());\n      }\n\n      this.validateConfiguration();\n    }\n\n    ngOnChanges(changes) {\n      if (changes['height'] || changes['expandMode'] || changes['items']) {\n        // eslint-disable-line\n        if (this.childrenItems) {\n          setTimeout(this.updateChildrenHeight);\n        }\n      }\n\n      if (changes.animate) {\n        this.eventService.animate = this.animate;\n      }\n\n      if (changes.expandMode) {\n        this.eventService.expandMode = this.expandMode;\n      }\n    }\n\n    get templateRef() {\n      return this.template ? this.template.templateRef : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentClick(event) {\n      const itemClicked = this.visibleItems().some(item => {\n        return item.header.nativeElement.contains(event.target);\n      });\n\n      if (!isFocusable(event.target) && !this.focused && itemClicked) {\n        this.elementRef.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentFocus() {\n      this.eventService.onFocus();\n      this.focused = true;\n\n      if (this.allItems.length > 0) {\n        const visibleItems = this.visibleItems();\n        const focusedItems = visibleItems.filter(item => item.focused);\n\n        if (!focusedItems.length && visibleItems.length > 0) {\n          visibleItems[0].focused = true;\n          this.activeDescendant = visibleItems[0].itemId;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentBlur() {\n      this.eventService.onBlur();\n      this.focused = false;\n      this.activeDescendant = '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentKeyDown(event) {\n      if (event.target === this.elementRef.nativeElement) {\n        if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home || event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {\n          event.preventDefault();\n        }\n\n        const handler = this.keyBindings[event.keyCode]; //TODO: check if next item is disabled and skip operation?\n\n        if (handler) {\n          handler();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitEvent(event, item) {\n      let eventArgs;\n\n      switch (event) {\n        case 'select':\n          eventArgs = new PanelBarSelectEvent();\n          break;\n\n        case 'collapse':\n          eventArgs = new PanelBarCollapseEvent();\n          break;\n\n        default:\n          eventArgs = new PanelBarExpandEvent();\n          break;\n      }\n\n      eventArgs.item = item.serialize();\n      this[event].emit(eventArgs);\n      return eventArgs;\n    }\n\n    get viewItems() {\n      let treeItems = [];\n      this.viewChildItems.toArray().forEach(item => {\n        treeItems.push(item);\n        treeItems = treeItems.concat(item.subTreeViewItems());\n      });\n      return treeItems;\n    }\n\n    validateConfiguration() {\n      if (isDevMode()) {\n        if (this.items && this.contentItems && this.contentItems.length > 0) {\n          throw new Error('Invalid configuration: mixed template components and items property.');\n        }\n      }\n    }\n\n    onItemAction(item) {\n      if (!item) {\n        return;\n      }\n\n      let modifiedItems = new Array();\n      let selectPreventedItems = [];\n      this.allItems.forEach(currentItem => {\n        let selectedState = currentItem === item;\n        let focusedState = selectedState;\n        selectedState = this.selectable ? selectedState : currentItem.selected;\n\n        if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {\n          const isSelectPrevented = selectedState ? this.emitEvent('select', currentItem).isDefaultPrevented() : false;\n\n          if (!isSelectPrevented) {\n            currentItem.selected = selectedState;\n            currentItem.focused = focusedState;\n            this.activeDescendant = focusedState ? currentItem.itemId : '';\n            modifiedItems.push(currentItem);\n          } else {\n            selectPreventedItems.push(currentItem);\n          }\n        }\n      });\n\n      if (this.expandMode === PanelBarExpandMode.Multiple) {\n        if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {\n          const isEventPrevented = item.expanded ? this.emitEvent('collapse', item).isDefaultPrevented() : this.emitEvent('expand', item).isDefaultPrevented();\n\n          if (!isEventPrevented) {\n            item.expanded = !item.expanded;\n\n            if (modifiedItems.indexOf(item) < 0) {\n              modifiedItems.push(item);\n            }\n          }\n        }\n      } else {\n        let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;\n        let preventedCollapseItem;\n        let expandedItems = [];\n\n        if ((item.hasChildItems || item.hasContent) && !selectPreventedItems.includes(item)) {\n          siblings.forEach(currentItem => {\n            let expandedState = currentItem === item;\n\n            if (currentItem.expanded !== expandedState) {\n              const isEventPrevented = currentItem.expanded ? this.emitEvent('collapse', currentItem).isDefaultPrevented() : this.emitEvent('expand', currentItem).isDefaultPrevented();\n\n              if (!isEventPrevented) {\n                currentItem.expanded = expandedState;\n\n                if (currentItem.expanded) {\n                  expandedItems.push(currentItem);\n                }\n\n                if (modifiedItems.indexOf(currentItem) < 0) {\n                  modifiedItems.push(currentItem);\n                }\n              } else if (isEventPrevented && currentItem.expanded) {\n                preventedCollapseItem = currentItem;\n              }\n            } else if (currentItem.expanded === expandedState && expandedState) {\n              const isCollapsePrevented = this.emitEvent('collapse', currentItem).isDefaultPrevented();\n\n              if (!isCollapsePrevented) {\n                currentItem.expanded = !currentItem.expanded;\n\n                if (modifiedItems.indexOf(currentItem) < 0) {\n                  modifiedItems.push(currentItem);\n                }\n              }\n            }\n          });\n          expandedItems.forEach(item => {\n            if (preventedCollapseItem && item.id !== preventedCollapseItem.id) {\n              item.expanded = false;\n\n              if (isDevMode()) {\n                const expandMode = PanelBarExpandMode[this.expandMode].toLowerCase();\n                console.warn(`\n                            The ${expandMode} expandMode allows the expansion of only one item at a time.\n                            See https://www.telerik.com/kendo-angular-ui-develop/components/layout/panelbar/expand-modes/`);\n              }\n            }\n          });\n        }\n      }\n\n      if (modifiedItems.length > 0) {\n        let eventArgs = new PanelBarStateChangeEvent();\n        eventArgs.items = modifiedItems.map(currentItem => currentItem.serialize());\n        this.stateChange.emit(eventArgs);\n      }\n    }\n\n    isVisible(item) {\n      const visibleItems = this.visibleItems();\n      return visibleItems.some(i => i === item);\n    }\n\n    getVisibleParent(item) {\n      const visibleItems = this.visibleItems();\n\n      if (!item.parent) {\n        return item;\n      }\n\n      return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);\n    }\n\n    focusItem(action) {\n      const visibleItems = this.visibleItems();\n      let currentIndex = visibleItems.findIndex(item => item.focused);\n      let currentItem = visibleItems[currentIndex];\n      let nextItem;\n\n      if (currentIndex === -1) {\n        let focusedItem = this.allItems.find(item => item.focused);\n        focusedItem.focused = false;\n        currentItem = this.getVisibleParent(focusedItem);\n        currentIndex = visibleItems.findIndex(item => item === currentItem);\n      }\n\n      switch (action) {\n        case 'lastItem':\n          nextItem = visibleItems[visibleItems.length - 1];\n          break;\n\n        case 'firstItem':\n          nextItem = visibleItems[0];\n          break;\n\n        case 'nextItem':\n          nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];\n          break;\n\n        case 'previousItem':\n          nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];\n          break;\n\n        default:\n      }\n\n      if (currentItem && nextItem && currentItem !== nextItem) {\n        this.moveFocus(currentItem, nextItem);\n      }\n    }\n\n    moveFocus(from, to) {\n      from.focused = false;\n      to.focused = true;\n      this.activeDescendant = to.itemId;\n      const modifiedItems = new Array(from.serialize(), to.serialize());\n      let eventArgs = new PanelBarStateChangeEvent();\n      eventArgs.items = modifiedItems;\n      this.stateChange.emit(eventArgs);\n    }\n\n    focusLastItem() {\n      this.focusItem('lastItem');\n    }\n\n    focusFirstItem() {\n      this.focusItem('firstItem');\n    }\n\n    focusNextItem() {\n      this.focusItem('nextItem');\n    }\n\n    focusPreviousItem() {\n      this.focusItem('previousItem');\n    }\n\n    expandItem() {\n      let currentItem = this.allItems.filter(item => item.focused)[0];\n\n      if (!this.isVisible(currentItem)) {\n        currentItem.focused = false;\n        currentItem = this.getVisibleParent(currentItem);\n      }\n\n      if (currentItem.hasChildItems || currentItem.hasContent) {\n        if (!currentItem.expanded) {\n          this.onItemAction(currentItem);\n        } else if (currentItem.hasChildItems) {\n          const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);\n\n          if (firstChildIndex > -1) {\n            this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);\n          }\n        }\n      }\n    }\n\n    collapseItem() {\n      const currentItem = this.allItems.filter(item => item.focused)[0];\n\n      if (currentItem.expanded) {\n        this.onItemAction(currentItem);\n      } else if (currentItem.parent) {\n        this.moveFocus(currentItem, currentItem.parent);\n      }\n    }\n\n    selectFocusedItem() {\n      let focusedItem = this.allItems.filter(item => item.focused)[0];\n\n      if (!this.isVisible(focusedItem)) {\n        focusedItem.focused = false;\n        focusedItem = this.getVisibleParent(focusedItem);\n      }\n\n      if (focusedItem) {\n        focusedItem.onItemAction();\n      }\n    }\n\n    visibleItems() {\n      return this.flatVisibleItems(this.childrenItems);\n    }\n\n    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {\n      listOfItems.forEach(item => {\n        flattedItems.push(item);\n\n        if (item.expanded && item.hasChildItems) {\n          this.flatVisibleItems(item.childrenItems, flattedItems);\n        }\n      });\n      return flattedItems;\n    }\n\n  }\n\n  PanelBarComponent.ɵfac = function PanelBarComponent_Factory(t) {\n    return new (t || PanelBarComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PanelBarService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  PanelBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PanelBarComponent,\n    selectors: [[\"kendo-panelbar\"]],\n    contentQueries: function PanelBarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItems = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentChildItems = _t);\n      }\n    },\n    viewQuery: function PanelBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(PanelBarItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function PanelBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function PanelBarComponent_click_HostBindingHandler($event) {\n          return ctx.onComponentClick($event);\n        })(\"focus\", function PanelBarComponent_focus_HostBindingHandler() {\n          return ctx.onComponentFocus();\n        })(\"blur\", function PanelBarComponent_blur_HostBindingHandler() {\n          return ctx.onComponentBlur();\n        })(\"keydown\", function PanelBarComponent_keydown_HostBindingHandler($event) {\n          return ctx.onComponentKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabIndex\", ctx.tabIndex)(\"role\", ctx.role)(\"aria-activedescendant\", ctx.activeDescendant)(\"dir\", ctx.dir);\n        i0.ɵɵstyleProp(\"height\", ctx.hostHeight)(\"overflow\", ctx.overflow);\n        i0.ɵɵclassProp(\"k-panelbar\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      expandMode: \"expandMode\",\n      selectable: \"selectable\",\n      animate: \"animate\",\n      height: \"height\",\n      keepItemContent: \"keepItemContent\",\n      items: \"items\"\n    },\n    outputs: {\n      stateChange: \"stateChange\",\n      select: \"select\",\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    exportAs: [\"kendoPanelbar\"],\n    features: [i0.ɵɵProvidersFeature([PanelBarService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.panelbar'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c8,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\", 4, \"ngIf\"], [3, \"title\", \"id\", \"icon\", \"iconClass\", \"imageUrl\", \"selected\", \"expanded\", \"disabled\", \"template\", \"items\", \"content\"]],\n    template: function PanelBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c7);\n        i0.ɵɵtemplate(0, PanelBarComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_Template, 1, 1, \"ng-template\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.contentChildItems && !ctx.items);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.items == null ? null : ctx.items.length);\n      }\n    },\n    directives: [PanelBarItemComponent, i2.NgIf, i2.NgForOf],\n    encapsulation: 2\n  });\n  return PanelBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the pane component of the Splitter.\n */\n\n\nlet SplitterPaneComponent = /*#__PURE__*/(() => {\n  class SplitterPaneComponent {\n    constructor(element, renderer, cdr) {\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      /**\n       * Specifies if the user is allowed to resize the pane and provide space for other panes.\n       */\n\n      this.resizable = true;\n      /**\n       * Specifies if the user is allowed to hide the pane and provide space for other panes.\n       */\n\n      this.collapsible = false;\n      /**\n       * Specifies if overflowing content is scrollable or hidden.\n       */\n\n      this.scrollable = true;\n      /**\n       * Specifies if the pane is initially collapsed.\n       */\n\n      this.collapsed = false;\n      /**\n       * @hidden\n       */\n\n      this.orientation = 'horizontal';\n      /**\n       * @hidden\n       */\n\n      this.overlayContent = false;\n      /**\n       * Fires each time the user resizes the Splitter pane.\n       * The event data contains the new pane size.\n       * Allows a two-way binding of the pane `size` property.\n       */\n\n      this.sizeChange = new EventEmitter();\n      /**\n       * Fires each time the `collapsed` property changes.\n       * The event data contains the new property state.\n       * Allows a two-way binding of the `collapsed` pane property.\n       */\n\n      this.collapsedChange = new EventEmitter();\n      this.ariaRole = 'group';\n      this.hostClass = true;\n      /**\n       * @hidden\n       */\n\n      this.forceExpand = false;\n      /**\n       * @hidden\n       */\n\n      this.isResized = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set order(paneOrder) {\n      this._order = paneOrder;\n      this.setOrderStyles();\n    }\n\n    get order() {\n      return this._order;\n    }\n    /**\n     * Sets the initial size of the pane.\n     * Has to be between the `min` and `max` properties.\n     */\n\n\n    set size(newSize) {\n      this._size = newSize;\n      const element = this.element.nativeElement;\n      this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);\n      this.renderer.setStyle(element, 'flex-basis', newSize);\n\n      if (this.staticPaneClass) {\n        this.renderer.addClass(element, 'k-pane-static');\n      } else {\n        this.renderer.removeClass(element, 'k-pane-static');\n      }\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set containsSplitter(value) {\n      const element = this.element.nativeElement;\n\n      if (value) {\n        this.renderer.addClass(element, 'k-pane-flex');\n      } else {\n        this.renderer.removeClass(element, 'k-pane-flex');\n      }\n    }\n\n    get isHidden() {\n      return this.collapsed;\n    }\n\n    get staticPaneClass() {\n      if (this.forceExpand) {\n        return false;\n      }\n\n      return !this.resizable && !this.collapsible || this.fixedSize;\n    }\n\n    get scrollablePaneClass() {\n      return this.scrollable;\n    }\n\n    get fixedSize() {\n      return this.size && this.size.length > 0;\n    }\n\n    ngAfterViewChecked() {\n      const element = this.element.nativeElement;\n\n      if (this.isHidden) {\n        this.renderer.addClass(element, 'k-state-hidden');\n        this.renderer.addClass(element, 'hidden');\n      } else {\n        this.renderer.removeClass(element, 'k-state-hidden');\n        this.renderer.removeClass(element, 'hidden');\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get computedSize() {\n      if (this.orientation === 'vertical') {\n        return this.element.nativeElement.offsetHeight;\n      } else {\n        return this.element.nativeElement.offsetWidth;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleOverlay(show) {\n      this.overlayContent = show;\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n\n    setOrderStyles() {\n      const element = this.element.nativeElement;\n      this.renderer.setStyle(element, '-ms-flex-order', this.order);\n      this.renderer.setStyle(element, 'order', this.order);\n    }\n\n  }\n\n  SplitterPaneComponent.ɵfac = function SplitterPaneComponent_Factory(t) {\n    return new (t || SplitterPaneComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  SplitterPaneComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitterPaneComponent,\n    selectors: [[\"kendo-splitter-pane\"]],\n    hostVars: 7,\n    hostBindings: function SplitterPaneComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.ariaRole);\n        i0.ɵɵclassProp(\"k-pane\", ctx.hostClass)(\"k-pane-static\", ctx.staticPaneClass)(\"k-scrollable\", ctx.scrollablePaneClass);\n      }\n    },\n    inputs: {\n      order: \"order\",\n      size: \"size\",\n      min: \"min\",\n      max: \"max\",\n      resizable: \"resizable\",\n      collapsible: \"collapsible\",\n      scrollable: \"scrollable\",\n      collapsed: \"collapsed\",\n      orientation: \"orientation\",\n      containsSplitter: \"containsSplitter\",\n      overlayContent: \"overlayContent\"\n    },\n    outputs: {\n      sizeChange: \"sizeChange\",\n      collapsedChange: \"collapsedChange\"\n    },\n    exportAs: [\"kendoSplitterPane\"],\n    ngContentSelectors: _c9,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [\"class\", \"k-splitter-overlay k-overlay\", 4, \"ngIf\"], [1, \"k-splitter-overlay\", \"k-overlay\"]],\n    template: function SplitterPaneComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, SplitterPaneComponent_ng_container_0_Template, 2, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, SplitterPaneComponent_div_1_Template, 1, 0, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.collapsed);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.overlayContent);\n      }\n    },\n    directives: [i2.NgIf],\n    encapsulation: 2\n  });\n  return SplitterPaneComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';\n/**\n * @hidden\n */\n\nlet SplitterService = /*#__PURE__*/(() => {\n  class SplitterService {\n    constructor(zone) {\n      this.zone = zone;\n      this.layoutChange = new EventEmitter();\n\n      this.containerSize = () => {};\n    }\n\n    tryToggle(paneIndex) {\n      const pane = this.pane(paneIndex);\n\n      if (pane.collapsible) {\n        pane.collapsed = !pane.collapsed;\n        pane.collapsedChange.emit(pane.collapsed);\n        this.emit(this.layoutChange, {});\n\n        if (pane.collapsed) {\n          pane.detectChanges();\n        }\n      }\n\n      const notCollapsed = this.panes.filter(p => !p.collapsed);\n      const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);\n      notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;\n      return pane.collapsible;\n    }\n\n    toggleContentOverlay(index, show) {\n      this.pane(index).toggleOverlay(show);\n      this.pane(index + 1).toggleOverlay(show);\n    }\n\n    dragState(splitbarIndex) {\n      let prev = this.pane(splitbarIndex);\n      let next = this.pane(splitbarIndex + 1);\n      const total = prev.computedSize + next.computedSize;\n\n      const px = s => this.toPixels(s);\n\n      return {\n        prev: {\n          index: splitbarIndex,\n          initialSize: prev.computedSize,\n          min: px(prev.min) || total - px(next.max) || 0,\n          max: px(prev.max) || total - px(next.min) || total\n        },\n        next: {\n          index: splitbarIndex + 1,\n          initialSize: next.computedSize,\n          min: px(next.min) || total - px(prev.max) || 0,\n          max: px(next.max) || total - px(prev.min) || total\n        }\n      };\n    }\n\n    setSize(state, delta) {\n      const clamp = (min, max, v) => Math.min(max, Math.max(min, v));\n\n      const resize = (paneState, change) => {\n        const pane = this.pane(paneState.index);\n        const splitterSize = this.containerSize();\n        const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);\n        let size = \"\";\n\n        if (this.isPercent(pane.size)) {\n          size = 100 * newSize / splitterSize + \"%\";\n        } else {\n          size = newSize + \"px\";\n        }\n\n        pane.size = size;\n        pane.isResized = true;\n        this.emit(pane.sizeChange, size);\n      };\n\n      const prev = this.pane(state.prev.index);\n      const next = this.pane(state.next.index); // determine which pane to resize\n\n      if (prev.fixedSize && next.fixedSize) {\n        // resizing both panes\n        resize(state.prev, delta);\n        resize(state.next, -delta);\n      } else if (next.collapsible || next.fixedSize) {\n        // resizing next\n        resize(state.next, -delta);\n      } else {\n        // resizing prev\n        resize(state.prev, delta);\n      }\n\n      this.emit(this.layoutChange, {});\n    }\n\n    isDraggable(splitBarIndex) {\n      const prev = this.pane(splitBarIndex);\n      const next = this.pane(splitBarIndex + 1);\n      const betweenResizablePanes = prev.resizable && next.resizable;\n      const nearCollapsedPane = prev.collapsed || next.collapsed;\n      return betweenResizablePanes && !nearCollapsedPane;\n    }\n\n    isStatic(splitBarIndex) {\n      const prev = this.pane(splitBarIndex);\n      const next = this.pane(splitBarIndex + 1);\n      const betweenResizablePanes = prev.resizable && next.resizable;\n      const nearCollapsiblePane = prev.collapsible || next.collapsible;\n      return !betweenResizablePanes && !nearCollapsiblePane;\n    }\n\n    pane(index) {\n      if (!this.panes) {\n        throw new Error(\"Panes not initialized\");\n      }\n\n      if (index < 0 || index >= this.panes.length) {\n        throw new Error(\"Index out of range\");\n      }\n\n      return this.panes[index];\n    }\n\n    configure({\n      panes,\n      orientation,\n      containerSize\n    }) {\n      this.panes = panes;\n      this.panes.forEach((pane, index) => {\n        pane.order = index * 2;\n        pane.orientation = orientation;\n      });\n\n      if (isDevMode()) {\n        const allPanesWithSize = panes.length && !panes.some(pane => !pane.fixedSize);\n        const hasResizedPane = panes.length && panes.some(pane => pane.isResized);\n\n        if (allPanesWithSize && !hasResizedPane) {\n          throw new Error(`\n                    The Splitter should have at least one pane without a set size.\n                    See ${SIZING_DOC_LINK} for more information.\n                `);\n        }\n      }\n\n      this.containerSize = containerSize;\n    }\n\n    isPercent(size) {\n      return /%$/.test(size);\n    }\n\n    toPixels(size) {\n      let result = parseFloat(size);\n\n      if (this.isPercent(size)) {\n        result = this.containerSize() * result / 100;\n      }\n\n      return result;\n    }\n\n    emit(emitter, args) {\n      if (emitter.observers.length) {\n        this.zone.run(() => emitter.emit(args));\n      }\n    }\n\n  }\n\n  SplitterService.ɵfac = function SplitterService_Factory(t) {\n    return new (t || SplitterService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  SplitterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SplitterService,\n    factory: SplitterService.ɵfac\n  });\n  return SplitterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst stopPropagation = ({\n  originalEvent: event\n}) => {\n  event.stopPropagation();\n  event.preventDefault();\n};\n\nconst preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));\n\nconst classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');\n\nconst createMoveStream = draggable => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease), map(({\n  pageX,\n  pageY\n}) => ({\n  originalX: mouseDown.pageX,\n  originalY: mouseDown.pageY,\n  pageX,\n  pageY\n})));\n/**\n * @hidden\n */\n\n\nlet SplitterBarComponent = /*#__PURE__*/(() => {\n  class SplitterBarComponent {\n    constructor(draggable, element, splitter, localization) {\n      this.draggable = draggable;\n      this.element = element;\n      this.splitter = splitter;\n      this.localization = localization;\n      this.orientation = 'horizontal';\n      this.index = 0;\n      this.ariaRole = 'separator';\n      this.focused = false;\n      this.subscriptions = new Subscription();\n    }\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n\n    get tabIndex() {\n      return this.splitter.isStatic(this.index) ? -1 : 0;\n    }\n\n    get hostClasses() {\n      const isHorizontal = this.orientation === 'horizontal';\n      const isDraggable = this.splitter.isDraggable(this.index);\n      const isStatic = this.splitter.isStatic(this.index);\n      return classFromObject({\n        'k-state-focused': this.focused,\n        'k-splitbar': true,\n        'k-splitbar-horizontal': isHorizontal,\n        'k-splitbar-vertical': !isHorizontal,\n        'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,\n        'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,\n        'k-splitbar-static-horizontal': isHorizontal && isStatic,\n        'k-splitbar-static-vertical': !isHorizontal && isStatic,\n        'k-touch-action-none': isDraggable\n      });\n    }\n\n    get order() {\n      return 2 * this.index + 1;\n    }\n\n    collapseAny() {\n      if (this.expandLast) {\n        this.toggleNext();\n      } else {\n        this.tryToggleNearest();\n      }\n    }\n\n    onFocusIn() {\n      this.focused = true;\n    }\n\n    onFocusOut() {\n      this.focused = false;\n    }\n\n    onKeyDown(event) {\n      const keyCode = event && event.keyCode;\n      const isHorizontal = this.orientation === 'horizontal';\n\n      const resize = delta => {\n        event.preventDefault();\n        const state = this.splitter.dragState(this.index);\n        this.splitter.setSize(state, delta);\n      };\n\n      if (keyCode === Keys.Enter) {\n        event.preventDefault();\n        this.collapseAny();\n      } else if (isHorizontal && keyCode === Keys.ArrowLeft) {\n        resize(-10);\n      } else if (isHorizontal && keyCode === Keys.ArrowRight) {\n        resize(10);\n      } else if (!isHorizontal && keyCode === Keys.ArrowUp) {\n        resize(-10);\n      } else if (!isHorizontal && keyCode === Keys.ArrowDown) {\n        resize(10);\n      }\n    }\n\n    get expandLast() {\n      const panes = this.splitter.panes;\n      return panes.length === 2 && panes[1].collapsed;\n    }\n\n    ngOnInit() {\n      let state;\n      const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitter.isDraggable(this.index)), tap(() => state = this.splitter.dragState(this.index)), tap(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({\n        pageX,\n        pageY,\n        originalX,\n        originalY\n      }) => {\n        let delta;\n\n        if (this.orientation === 'vertical') {\n          delta = pageY - originalY;\n        } else if (this.direction === 'rtl') {\n          delta = originalX - pageX;\n        } else {\n          delta = pageX - originalX;\n        }\n\n        this.splitter.setSize(state, delta);\n      });\n      this.subscriptions.add(listener);\n      this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n\n    togglePrevious() {\n      this.splitter.tryToggle(this.index);\n    }\n\n    toggleNext() {\n      this.splitter.tryToggle(this.index + 1);\n    }\n\n    previousArrowClass() {\n      const pane = this.splitter.pane(this.index);\n      const nextPane = this.splitter.pane(this.index + 1);\n      const isCollapsible = pane.collapsible;\n      const isCollapsed = pane.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      return classFromObject({\n        'k-icon': true,\n        'k-hidden': !isCollapsible || nextPane.isHidden,\n        'k-collapse-prev': isCollapsible,\n        'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,\n        'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,\n        'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,\n        'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed\n      });\n    }\n\n    nextArrowClass() {\n      const pane = this.splitter.pane(this.index + 1);\n      const prevPane = this.splitter.pane(this.index);\n      const isCollapsible = pane.collapsible;\n      const isCollapsed = pane.collapsed;\n      const isHorizontal = this.orientation === 'horizontal';\n      return classFromObject({\n        'k-icon': true,\n        'k-hidden': !isCollapsible || prevPane.isHidden,\n        'k-collapse-next': isCollapsible,\n        'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,\n        'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,\n        'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,\n        'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed\n      });\n    }\n\n    tryToggleNearest() {\n      const prev = this.index;\n      const next = this.index + 1;\n\n      if (!this.splitter.tryToggle(prev)) {\n        this.splitter.tryToggle(next);\n      }\n    }\n\n  }\n\n  SplitterBarComponent.ɵfac = function SplitterBarComponent_Factory(t) {\n    return new (t || SplitterBarComponent)(i0.ɵɵdirectiveInject(i1$1.DraggableDirective, 1), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SplitterService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  SplitterBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitterBarComponent,\n    selectors: [[\"kendo-splitter-bar\"]],\n    hostVars: 11,\n    hostBindings: function SplitterBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function SplitterBarComponent_dblclick_HostBindingHandler() {\n          return ctx.collapseAny();\n        })(\"focusin\", function SplitterBarComponent_focusin_HostBindingHandler() {\n          return ctx.onFocusIn();\n        })(\"focusout\", function SplitterBarComponent_focusout_HostBindingHandler() {\n          return ctx.onFocusOut();\n        })(\"keydown\", function SplitterBarComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"role\", ctx.ariaRole)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassMap(ctx.hostClasses);\n        i0.ɵɵstyleProp(\"-ms-flex-order\", ctx.order)(\"order\", ctx.order);\n        i0.ɵɵclassProp(\"k-state-focused\", ctx.focused);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      index: \"index\"\n    },\n    decls: 3,\n    vars: 4,\n    consts: [[3, \"click\"], [1, \"k-resize-handle\"]],\n    template: function SplitterBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"click\", function SplitterBarComponent_Template_div_click_0_listener() {\n          return ctx.togglePrevious();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 0);\n        i0.ɵɵlistener(\"click\", function SplitterBarComponent_Template_div_click_2_listener() {\n          return ctx.toggleNext();\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.previousArrowClass());\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassMap(ctx.nextArrowClass());\n      }\n    },\n    encapsulation: 2\n  });\n  return SplitterBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).\n *\n * ```ts-preview\n *\n *  @Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-splitter style=\"height: 280px;\">\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / left pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane>\n *            <h3>Inner splitter / center pane</h3>\n *            <p>Resizable only.</p>\n *          </kendo-splitter-pane>\n *\n *          <kendo-splitter-pane [collapsible]=\"true\" size=\"30%\">\n *            <h3>Inner splitter / right pane</h3>\n *            <p>Resizable and collapsible.</p>\n *          </kendo-splitter-pane>\n *\n *        </kendo-splitter>\n *      `,\n *    styles: [ `\n *        h3 { font-size: 1.2em; }\n *        h3, p { margin: 10px; padding: 0; }\n *    ` ]\n *  })\n *  class AppComponent {}\n * ```\n */\n\n\nlet SplitterComponent = /*#__PURE__*/(() => {\n  class SplitterComponent {\n    constructor(element, splitterService, localization, renderer, enclosingPane) {\n      this.element = element;\n      this.splitterService = splitterService;\n      this.localization = localization;\n      this.renderer = renderer;\n      this.enclosingPane = enclosingPane;\n      /**\n       * Specifies the orientation of the panes within the Splitter.\n       * Panes in a horizontal Splitter are placed horizontally.\n       * Panes in a vertical Splitter are placed vertically.\n       */\n\n      this.orientation = 'horizontal';\n      validatePackage(packageMetadata);\n\n      if (enclosingPane) {\n        enclosingPane.containsSplitter = true;\n      } // the handler only runs in NgZone if there are bound handlers\n      // this line merges both streams\n\n\n      this.layoutChange = this.splitterService.layoutChange;\n      this.configure = this.configure.bind(this);\n    }\n\n    get hostClasses() {\n      return true;\n    }\n\n    get horizontalHostClasses() {\n      return this.orientation === 'horizontal';\n    }\n\n    get verticalHostClasses() {\n      return this.orientation === 'vertical';\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    set splitbars(splitbars) {\n      if (!isPresent(splitbars) || !isPresent(this.panes)) {\n        return;\n      }\n\n      const components = [...this.panes.toArray(), ...splitbars.toArray()].sort((a, b) => a.order - b.order);\n      const elements = components.map(component => component.element.nativeElement);\n      elements.forEach(element => this.renderer.appendChild(this.element.nativeElement, element));\n    }\n\n    ngAfterContentInit() {\n      this.reconfigure();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.orientation && !changes.orientation.isFirstChange()) {\n        this.reconfigure();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.enclosingPane) {\n        this.enclosingPane.containsSplitter = false;\n      }\n\n      this.unsubscribeChanges();\n    }\n\n    reconfigure() {\n      this.unsubscribeChanges();\n      this.configure();\n      this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);\n    }\n\n    unsubscribeChanges() {\n      if (this.paneChangesSubscription) {\n        this.paneChangesSubscription.unsubscribe();\n        this.paneChangesSubscription = null;\n      }\n    }\n\n    configure() {\n      this.splitterService.configure({\n        panes: this.panes.toArray(),\n        orientation: this.orientation,\n        containerSize: () => {\n          if (this.orientation === 'vertical') {\n            return this.element.nativeElement.clientHeight;\n          } else {\n            return this.element.nativeElement.clientWidth;\n          }\n        }\n      });\n    }\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n\n  }\n\n  SplitterComponent.ɵfac = function SplitterComponent_Factory(t) {\n    return new (t || SplitterComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SplitterService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(SplitterPaneComponent, 9));\n  };\n\n  SplitterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SplitterComponent,\n    selectors: [[\"kendo-splitter\"]],\n    contentQueries: function SplitterComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SplitterPaneComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panes = _t);\n      }\n    },\n    viewQuery: function SplitterComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(SplitterBarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.splitbars = _t);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function SplitterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-splitter\", ctx.hostClasses)(\"k-splitter-flex\", ctx.hostClasses)(\"k-splitter-horizontal\", ctx.horizontalHostClasses)(\"k-splitter-vertical\", ctx.verticalHostClasses);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\"\n    },\n    outputs: {\n      layoutChange: \"layoutChange\"\n    },\n    exportAs: [\"kendoSplitter\"],\n    features: [i0.ɵɵProvidersFeature([SplitterService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.spliter'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c11,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoDraggable\", \"\", 3, \"index\", \"orientation\", 4, \"ngIf\"], [\"kendoDraggable\", \"\", 3, \"index\", \"orientation\"]],\n    template: function SplitterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c10);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, SplitterComponent_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.panes);\n      }\n    },\n    directives: [SplitterBarComponent, i2.NgForOf, i2.NgIf, i1$1.DraggableDirective],\n    encapsulation: 2\n  });\n  return SplitterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the content template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip [ngStyle]=\"{'width': '400px'}\" [animate]=\"true\">\n *           <kendo-tabstrip-tab title=\"Paris\" [selected]=\"true\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab title=\"Sofia\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\n\n\nlet TabContentDirective = /*#__PURE__*/(() => {\n  class TabContentDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  TabContentDirective.ɵfac = function TabContentDirective_Factory(t) {\n    return new (t || TabContentDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  TabContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TabContentDirective,\n    selectors: [[\"\", \"kendoTabContent\", \"\"]]\n  });\n  return TabContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the title template of the Kendo UI TabStrip.\n * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.\n *\n * > The `kendoTabTitle` directive overrides the TabStripTab [title]({% slug api_layout_tabstriptabcomponent %}#toc-title) option.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *         <kendo-tabstrip>\n *           <kendo-tabstrip-tab [selected]=\"true\">\n *             <ng-template kendoTabTitle>\n *               <h4>Custom Title</h4>\n *             </ng-template>\n *             <ng-template kendoTabContent>\n *               <h3>Content 1</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *\n *           <kendo-tabstrip-tab title=\"Sofia\">\n *             <ng-template kendoTabContent>\n *               <h3>Content 2</h3>\n *             </ng-template>\n *           </kendo-tabstrip-tab>\n *         </kendo-tabstrip>\n *     `\n * })\n *\n * class AppComponent {}\n *\n * ```\n */\n\n\nlet TabTitleDirective = /*#__PURE__*/(() => {\n  class TabTitleDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  TabTitleDirective.ɵfac = function TabTitleDirective_Factory(t) {\n    return new (t || TabTitleDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  TabTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TabTitleDirective,\n    selectors: [[\"\", \"kendoTabTitle\", \"\"]]\n  });\n  return TabTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the tab component of the TabStrip.\n */\n\n\nlet TabStripTabComponent = /*#__PURE__*/(() => {\n  class TabStripTabComponent {\n    constructor() {\n      /**\n       * Used to disable a tab ([see example]({% slug tabs_tabstrip %}#toc-disabled-tabs)).\n       *\n       * Defaults to `false`.\n       */\n      this.disabled = false;\n      this._tabContent = new QueryList();\n      /**\n       * @hidden\n       *\n       * Currently only disabled tabs can be focused. Otherwise they will be\n       * immediately selected\n       */\n\n      this.focused = false;\n    }\n\n    get tabContent() {\n      return this._tabContent.first;\n    }\n\n    get tabTitle() {\n      return this._tabTitleDirective.first;\n    }\n\n  }\n\n  TabStripTabComponent.ɵfac = function TabStripTabComponent_Factory(t) {\n    return new (t || TabStripTabComponent)();\n  };\n\n  TabStripTabComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabStripTabComponent,\n    selectors: [[\"kendo-tabstrip-tab\"]],\n    contentQueries: function TabStripTabComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TabContentDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, TabTitleDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tabContent = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._tabTitleDirective = _t);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      disabled: \"disabled\",\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\",\n      selected: \"selected\",\n      closable: \"closable\",\n      closeIcon: \"closeIcon\"\n    },\n    exportAs: [\"kendoTabStripTab\"],\n    decls: 0,\n    vars: 0,\n    template: function TabStripTabComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TabStripTabComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `tabClose` event of the TabStrip.\n * The `tabClose` event fires when the close button of the tab is clicked.\n *\n */\n\n\nclass TabCloseEvent {\n  /**\n   * Constructs the event arguments for the `tabClose` event.\n   * @param index - The index of the closed tab.\n   * @param tab - The closed tab instance\n   */\n  constructor(index, tab) {\n    this.index = index;\n    this.tab = tab;\n  }\n\n}\n/**\n * Arguments for the `select` event of the TabStrip.\n * The `select` event fires when a tab is selected (clicked).\n */\n\n\nclass SelectEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `select` event.\n   * @param index - The index of the selected tab.\n   * @param title - The title of the selected tab.\n   */\n  constructor(index, title) {\n    super();\n    this.index = index;\n    this.title = title;\n  }\n\n}\n/**\n * @hidden\n *\n * Checks if the current target is a TabStrip tab element\n */\n\n\nconst isTabElement = target => {\n  const targetId = target.getAttribute('id');\n\n  if (isPresent(targetId) || targetId.indexOf('k-tabstrip-tab-') >= 0) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * @hidden\n *\n * Checks if the current tab is closable. Depends on the value of the TabStrip closable property.\n */\n\n\nconst isTabClosable = (tab, tabStripClosable) => {\n  if (tab.closable !== undefined) {\n    return tab.closable;\n  }\n\n  return tabStripClosable;\n};\n/**\n * @hidden\n *\n * Checks if the TabStrip scroll buttons will be rendered. Depends on the value of the TabStrip scrollable settings.\n */\n\n\nconst tabStripHasScrollButtons = scrollableSettings => {\n  return scrollableSettings.enabled && scrollableSettings.scrollButtons !== 'hidden';\n};\n/**\n * @hidden\n *\n * Checks if the TabStrip mouse scroll will be enabled. Depends on the value of the TabStrip scrollable settings.\n */\n\n\nconst mouseScrollEnabled = scrollableSettings => {\n  return scrollableSettings.enabled && scrollableSettings.mouseScroll;\n};\n/**\n * @hidden\n *\n * Retrieves the current active tab element and its index.\n * This could either be the currently selected tab or the currently focused tab.\n */\n\n\nconst getActiveTab = tabs => {\n  let focusedTab;\n  let selectedTab;\n  let focusedIndex = -1;\n  let selectedIndex = -1;\n  tabs.forEach((tab, index) => {\n    if (tab.selected) {\n      selectedTab = tab;\n      selectedIndex = index;\n    } else if (tab.focused) {\n      focusedTab = tab;\n      focusedIndex = index;\n    }\n  });\n  return focusedIndex >= 0 ? {\n    tab: focusedTab,\n    index: focusedIndex\n  } : {\n    tab: selectedTab,\n    index: selectedIndex\n  };\n};\n/**\n * @hidden\n */\n\n\nconst getTabByIndex = (tabs, index) => {\n  const filtered = tabs.filter((_tab, i) => i === index);\n\n  if (filtered.length > 0) {\n    return filtered[0];\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nconst getTabHeaderByIndex = (tabHeaderContainers, index) => {\n  const filtered = tabHeaderContainers.filter((_tabHeader, i) => i === index);\n\n  if (filtered.length > 0) {\n    return filtered[0];\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nconst resetTabFocus = tabs => {\n  tabs.forEach(tab => {\n    tab.focused = false;\n  });\n};\n/**\n * @hidden\n */\n\n\nconst resetTabSelection = tabs => {\n  tabs.forEach(tab => {\n    tab.selected = false;\n  });\n};\n/**\n * @hidden\n */\n\n\nconst isTablistHorizontal = tabPosition => tabPosition === 'top' || tabPosition === 'bottom';\n/**\n * @hidden\n */\n\n\nlet TabStripService = /*#__PURE__*/(() => {\n  class TabStripService {\n    constructor(localization, ngZone) {\n      this.localization = localization;\n      this.ngZone = ngZone;\n    }\n\n    onKeyDown(event) {\n      if (!isTabElement(event.target)) {\n        return;\n      }\n\n      const key = event.keyCode;\n\n      if (this.shouldHandleKey(key)) {\n        event.preventDefault();\n      } else {\n        return;\n      }\n\n      if (isNavigationKey(key) || isArrowKey(key)) {\n        this.onNavigate(key);\n      } else if (key === Keys.Delete) {\n        this.onDelete();\n      }\n    }\n\n    onTabSelect(tab, index) {\n      const selectArgs = new SelectEvent(index, tab.title);\n      this.owner.tabSelect.emit(selectArgs);\n\n      if (!selectArgs.isDefaultPrevented()) {\n        if (tab.selected) {\n          this.focusTabHeader(index);\n          return;\n        }\n\n        this.selectTab(tab, index);\n      }\n    }\n\n    selectTab(tab, index) {\n      resetTabSelection(this.owner.tabs);\n      this.focusTabHeader(index);\n      tab.selected = true;\n\n      if (this.owner.isScrollable) {\n        this.owner.scrollToSelectedTab();\n      }\n    }\n\n    onNavigate(keyCode) {\n      let {\n        tab: activeTab,\n        index: activeIndex\n      } = getActiveTab(this.owner.tabs);\n\n      if (!NgZone.isInAngularZone()) {\n        this.ngZone.run(() => {\n          if (activeIndex < 0) {\n            this.owner.selectTab(this.firstNavigatableIndex());\n            return;\n          }\n\n          activeTab.focused = false;\n          const nextIndex = this.computeNextIndex(activeIndex, keyCode);\n          this.activateTab(nextIndex);\n        });\n      }\n    }\n\n    onDelete() {\n      let {\n        tab: activeTab,\n        index: activeTabIndex\n      } = getActiveTab(this.owner.tabs);\n\n      if (isTabClosable(activeTab, this.owner.closable) && !activeTab.disabled) {\n        this.ngZone.run(() => {\n          this.owner.tabClose.emit({\n            tab: activeTab,\n            index: activeTabIndex\n          });\n        });\n      }\n    }\n\n    activateTab(index) {\n      const tab = getTabByIndex(this.owner.tabs, index);\n\n      if (tab.disabled) {\n        this.focusTabHeader(index);\n        tab.focused = true;\n      } else {\n        this.onTabSelect(tab, index);\n      }\n    }\n\n    focusTabHeader(index) {\n      const tabHeader = getTabHeaderByIndex(this.owner.tabHeaderContainers, index);\n      tabHeader.nativeElement.focus();\n    }\n\n    shouldHandleKey(keyCode) {\n      if (isNavigationKey(keyCode)) {\n        return true;\n      }\n\n      if (isTablistHorizontal(this.owner.tabPosition) && isHorizontalArrowKey(keyCode)) {\n        return true;\n      }\n\n      if (!isTablistHorizontal(this.owner.tabPosition) && isVerticalArrowKey(keyCode)) {\n        return true;\n      }\n\n      if (keyCode === Keys.Delete) {\n        return true;\n      }\n\n      return false;\n    }\n\n    computeNextIndex(activeIndex, keyCode) {\n      switch (keyCode) {\n        case this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight):\n        case this.invertKeys(Keys.ArrowUp, Keys.ArrowDown):\n          return this.prevNavigatableIndex(activeIndex);\n\n        case this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft):\n        case this.invertKeys(Keys.ArrowDown, Keys.ArrowUp):\n          return this.nextNavigatableIndex(activeIndex);\n\n        case Keys.Home:\n          return this.firstNavigatableIndex();\n\n        case Keys.End:\n          return this.lastNavigatableIndex();\n\n        default:\n          return;\n      }\n    }\n\n    invertKeys(original, inverted) {\n      return this.localization.rtl ? inverted : original;\n    }\n\n    firstNavigatableIndex() {\n      return 0;\n    }\n\n    lastNavigatableIndex() {\n      return this.owner.tabs.length - 1;\n    }\n\n    prevNavigatableIndex(selectedIndex) {\n      if (selectedIndex - 1 < 0) {\n        return this.lastNavigatableIndex();\n      }\n\n      return selectedIndex - 1;\n    }\n\n    nextNavigatableIndex(selectedIndex) {\n      if (selectedIndex + 1 >= this.owner.tabs.length) {\n        return this.firstNavigatableIndex();\n      }\n\n      return selectedIndex + 1;\n    }\n\n  }\n\n  TabStripService.ɵfac = function TabStripService_Factory(t) {\n    return new (t || TabStripService)(i0.ɵɵinject(i1.LocalizationService), i0.ɵɵinject(i0.NgZone));\n  };\n\n  TabStripService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TabStripService,\n    factory: TabStripService.ɵfac\n  });\n  return TabStripService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst MOUSE_SCROLL_SPEED = 10;\n/**\n * @hidden\n */\n\nconst BUTTON_SCROLL_SPEED = 100;\n/**\n * @hidden\n */\n\nconst SCROLLABLE_CLASS = 'k-tabstrip-scrollable';\n/**\n * @hidden\n */\n\nconst HIDDEN_CLASS = 'k-hidden';\n/**\n * @hidden\n */\n\nconst DIRECTION_CLASSES = {\n  left: 'k-i-arrow-60-left',\n  right: 'k-i-arrow-60-right',\n  up: 'k-i-arrow-60-up',\n  down: 'k-i-arrow-60-down'\n};\n/**\n * @hidden\n */\n\nconst DEFAULT_SCROLL_BEHAVIOR = 'smooth';\n/**\n * @hidden\n */\n\nlet ScrollService = /*#__PURE__*/(() => {\n  class ScrollService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.position = 0;\n      this.scrollButtonActiveStateChange = new Subject();\n\n      this.isDisabled = buttonType => this.owner[`${buttonType}ScrollButton`].host.nativeElement.classList.contains('k-disabled');\n    }\n\n    get tablistElement() {\n      return this.owner.tablist.nativeElement;\n    }\n\n    get tabstripSize() {\n      const hostElement = this.owner.wrapper.nativeElement;\n      const wrapperWidth = parseFloat(getComputedStyle(hostElement).width);\n      const wrapperHeight = parseFloat(getComputedStyle(hostElement).height);\n      return isTablistHorizontal(this.owner.tabPosition) ? wrapperWidth : wrapperHeight;\n    }\n\n    get tablistOverflowSize() {\n      if (!isDocumentAvailable()) {\n        return 0;\n      }\n\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      const overflowSize = Math.floor(this.tablistElement[isHorizontal ? 'scrollWidth' : 'scrollHeight'] - this.tablistElement.getBoundingClientRect()[isHorizontal ? 'width' : 'height']);\n      return overflowSize < 0 ? 0 : overflowSize;\n    }\n\n    get tabsOverflow() {\n      return this.tablistOverflowSize > 0;\n    }\n\n    get scrollButtonsSize() {\n      if (!this.owner.hasScrollButtons) {\n        return 0;\n      }\n\n      const prevRect = this.owner.prevScrollButton.hostBoundingClientRect;\n      const prevSize = isTablistHorizontal(this.owner.tabPosition) ? prevRect.width : prevRect.height;\n      const nextRect = this.owner.nextScrollButton.hostBoundingClientRect;\n      const nextSize = isTablistHorizontal(this.owner.tabPosition) ? nextRect.width : nextRect.height;\n      return prevSize + nextSize;\n    }\n\n    toggleScrollButtonsState() {\n      const tabStrip = this.owner;\n\n      if (!tabStrip.hasScrollButtons) {\n        return;\n      }\n\n      const currentPrevButtonActive = !this.isDisabled('prev');\n      const currentNextButtonActive = !this.isDisabled('next');\n      const calculatedPrevButtonActive = this.position > 0 && this.tablistOverflowSize > 0;\n      const calculatedNextButtonActive = this.position < this.tablistOverflowSize + this.scrollButtonsSize && this.tablistOverflowSize > 0;\n\n      if (calculatedPrevButtonActive !== currentPrevButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('prev', calculatedPrevButtonActive));\n      }\n\n      if (calculatedNextButtonActive !== currentNextButtonActive) {\n        this.ngZone.run(() => this.toggleButtonActiveState('next', calculatedNextButtonActive));\n      }\n    }\n\n    scrollToSelectedTab() {\n      if (!this.tabsOverflow) {\n        return;\n      }\n\n      let {\n        index: activeIndex\n      } = getActiveTab(this.owner.tabs);\n\n      if (activeIndex === -1) {\n        return;\n      }\n\n      this.position += this.getScrollOffset(activeIndex);\n\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollLeft = this.position;\n      } else {\n        this.tablistElement.scrollTop = this.position;\n      }\n\n      this.toggleScrollButtonsState();\n      const tabStrip = this.owner;\n\n      if (!tabStrip.hasScrollButtons) {\n        return;\n      }\n\n      const isFirstTabActive = activeIndex === 0;\n      const isLastTabActive = activeIndex === this.owner.tabs.length - 1;\n\n      if (isFirstTabActive && !this.isDisabled('prev')) {\n        this.ngZone.run(() => this.toggleButtonActiveState('prev', false));\n      }\n\n      if (isLastTabActive && !this.isDisabled('next')) {\n        this.ngZone.run(() => this.toggleButtonActiveState('next', false));\n      }\n    }\n\n    getScrollOffset(activeIndex) {\n      if (!isDocumentAvailable()) {\n        return 0;\n      }\n\n      const isHorizontal = isTablistHorizontal(this.owner.tabPosition);\n      this.tablistElement[`scroll${isHorizontal ? 'Left' : 'Top'}`] = this.position;\n      const activeTabRect = this.tablistElement.children[activeIndex].getBoundingClientRect();\n      const tablistRect = this.tablistElement.getBoundingClientRect();\n      const end = isHorizontal ? 'right' : 'bottom';\n      const start = isHorizontal ? 'left' : 'top';\n      const activeTabStart = activeTabRect[start];\n      const activeTabEnd = activeTabRect[end];\n      const tablistStart = tablistRect[start];\n      const tablistEnd = tablistRect[end];\n      const tabEndIsInVisibleRange = activeTabEnd <= tablistEnd;\n      const tabStartIsInVisibleRange = activeTabStart >= tablistStart;\n      const isWholeTabVisible = tabEndIsInVisibleRange && tabStartIsInVisibleRange;\n\n      if (isWholeTabVisible) {\n        return 0;\n      }\n\n      if (!tabEndIsInVisibleRange) {\n        return activeTabEnd - tablistEnd;\n      }\n\n      if (!tabStartIsInVisibleRange) {\n        return activeTabStart - tablistStart;\n      }\n    }\n\n    onMouseScroll(event) {\n      event.preventDefault();\n\n      if (!mouseScrollEnabled(this.owner.scrollable)) {\n        return;\n      }\n\n      const direction = event.deltaY < 0 ? 'prev' : 'next';\n      this.calculateListPosition(direction, this.owner.scrollable.mouseScrollSpeed);\n\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollLeft = this.position;\n      } else {\n        this.tablistElement.scrollTop = this.position;\n      }\n\n      this.toggleScrollButtonsState();\n    }\n\n    scrollTabs(direction) {\n      this.calculateListPosition(direction, this.owner.scrollable.buttonScrollSpeed);\n\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollTo({\n          left: this.position,\n          behavior: DEFAULT_SCROLL_BEHAVIOR\n        });\n      } else {\n        this.tablistElement.scrollTo({\n          top: this.position,\n          behavior: DEFAULT_SCROLL_BEHAVIOR\n        });\n      }\n\n      this.toggleScrollButtonsState();\n    }\n\n    calculateListPosition(direction, scrollSpeed) {\n      const adjustedMaxScroll = this.tablistOverflowSize + this.scrollButtonsSize;\n\n      if (direction === 'prev' && this.position > 0) {\n        this.position = this.position - scrollSpeed <= 0 ? 0 : this.position - scrollSpeed;\n      } else if (direction === 'next' && this.position < adjustedMaxScroll) {\n        if (this.position + scrollSpeed > adjustedMaxScroll) {\n          this.position = adjustedMaxScroll;\n          return;\n        }\n\n        this.position += scrollSpeed;\n      }\n    }\n\n    restoreScrollPosition() {\n      if (isTablistHorizontal(this.owner.tabPosition)) {\n        this.tablistElement.scrollTo({\n          left: this.position\n        });\n      } else {\n        this.tablistElement.scrollTo({\n          top: this.position\n        });\n      }\n\n      this.toggleScrollButtonsState();\n    }\n\n    toggleButtonActiveState(buttonType, active) {\n      this.scrollButtonActiveStateChange.next({\n        buttonType,\n        active\n      });\n    }\n\n  }\n\n  ScrollService.ɵfac = function ScrollService_Factory(t) {\n    return new (t || ScrollService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  ScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollService,\n    factory: ScrollService.ɵfac\n  });\n  return ScrollService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst normalizeSettings = ({\n  enabled = true,\n  scrollButtons = 'auto',\n  mouseScroll = true,\n  buttonScrollSpeed = BUTTON_SCROLL_SPEED,\n  mouseScrollSpeed = MOUSE_SCROLL_SPEED,\n  prevButtonIcon,\n  nextButtonIcon\n}) => ({\n  enabled,\n  scrollButtons,\n  mouseScroll,\n  buttonScrollSpeed,\n  mouseScrollSpeed,\n  prevButtonIcon,\n  nextButtonIcon\n});\n/**\n * @hidden\n */\n\n\nconst normalizeScrollableSettings = settings => normalizeSettings(settings === false ? {\n  enabled: false\n} : settings);\n/**\n * Arguments for the `tabScroll` event of the TabStrip.\n * The `tabScroll` event fires when the tabs are being scrolled.\n *\n */\n\n\nclass TabScrollEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet TabStripScrollableButtonComponent = /*#__PURE__*/(() => {\n  class TabStripScrollableButtonComponent {\n    constructor(host, renderer, ngZone) {\n      this.host = host;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.btnClasses = true;\n      this.prev = false;\n      this.tabScroll = new EventEmitter();\n      this.onClick = new EventEmitter();\n      this.subs = new Subscription();\n\n      this.clickHandler = scrollEvent => {\n        const tabStripScrollEvent = this.emitScrollEvent(scrollEvent);\n        const isTabStripScrollEventPrevented = tabStripScrollEvent.isDefaultPrevented();\n\n        if (isTabStripScrollEventPrevented) {\n          return;\n        }\n\n        const buttonType = this.prev ? 'prev' : 'next';\n        this.onClick.emit(buttonType);\n      };\n    }\n\n    get prevClass() {\n      return this.prev;\n    }\n\n    get nextClass() {\n      return !this.prev;\n    }\n\n    get hostBoundingClientRect() {\n      return this.host.nativeElement.getBoundingClientRect();\n    }\n\n    get iconClass() {\n      return this.scrollButtonIconClass[this.prev ? 'prevScrollButton' : 'nextScrollButton'];\n    }\n\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.subs.add(this.renderer.listen(this.host.nativeElement, 'click', this.clickHandler));\n      });\n    }\n\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n\n    toggle(show) {\n      this.renderer[show ? 'removeClass' : 'addClass'](this.host.nativeElement, HIDDEN_CLASS);\n    }\n\n    get scrollButtonIconClass() {\n      const defaultPrevIcon = isTablistHorizontal(this.tabPosition) ? DIRECTION_CLASSES.left : DIRECTION_CLASSES.up;\n      const defaultNextIcon = isTablistHorizontal(this.tabPosition) ? DIRECTION_CLASSES.right : DIRECTION_CLASSES.down;\n\n      if (typeof this.scrollable === 'object') {\n        const prevIcon = typeof this.scrollable.prevButtonIcon === 'undefined' ? defaultPrevIcon : this.scrollable.prevButtonIcon;\n        const nextIcon = typeof this.scrollable.nextButtonIcon === 'undefined' ? defaultNextIcon : this.scrollable.nextButtonIcon;\n        return {\n          prevScrollButton: prevIcon,\n          nextScrollButton: nextIcon\n        };\n      }\n\n      return {\n        prevScrollButton: defaultPrevIcon,\n        nextScrollButton: defaultNextIcon\n      };\n    }\n\n    emitScrollEvent(event) {\n      const scrollEvent = new TabScrollEvent({\n        originalEvent: event\n      });\n      this.tabScroll.emit(scrollEvent);\n      return scrollEvent;\n    }\n\n  }\n\n  TabStripScrollableButtonComponent.ɵfac = function TabStripScrollableButtonComponent_Factory(t) {\n    return new (t || TabStripScrollableButtonComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  TabStripScrollableButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabStripScrollableButtonComponent,\n    selectors: [[\"\", \"kendoTabStripScrollableButton\", \"\"]],\n    hostVars: 16,\n    hostBindings: function TabStripScrollableButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-button\", ctx.btnClasses)(\"k-button-md\", ctx.btnClasses)(\"k-icon-button\", ctx.btnClasses)(\"k-rounded-md\", ctx.btnClasses)(\"k-button-flat\", ctx.btnClasses)(\"k-button-flat-base\", ctx.btnClasses)(\"k-tabstrip-prev\", ctx.prevClass)(\"k-tabstrip-next\", ctx.nextClass);\n      }\n    },\n    inputs: {\n      prev: \"prev\",\n      tabPosition: \"tabPosition\",\n      scrollable: \"scrollable\"\n    },\n    outputs: {\n      tabScroll: \"tabScroll\",\n      onClick: \"onClick\"\n    },\n    attrs: _c12,\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"k-icon\", \"k-button-icon\", 3, \"ngClass\"]],\n    template: function TabStripScrollableButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"span\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.iconClass);\n      }\n    },\n    directives: [i2.NgClass],\n    encapsulation: 2\n  });\n  return TabStripScrollableButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TabComponent = /*#__PURE__*/(() => {\n  class TabComponent {\n    constructor(localization) {\n      this.localization = localization;\n      this.tabClose = new EventEmitter();\n      this.hostClasses = true;\n    }\n\n    get activeClass() {\n      return this.tab.selected;\n    }\n\n    get disabledClass() {\n      return this.tab.disabled;\n    }\n\n    get focusedClass() {\n      return this.tab.focused;\n    }\n\n    get tabIndex() {\n      return this.tab.selected || this.tab.focused ? 0 : -1;\n    }\n\n    get tabClosable() {\n      if (this.tab.closable !== undefined) {\n        return this.tab.closable;\n      }\n\n      return this.tabStripClosable;\n    }\n\n    get closeButtonClasses() {\n      if (isPresent(this.tab.closeIcon)) {\n        return this.tab.closeIcon;\n      }\n\n      return this.tabStripCloseIcon;\n    }\n\n    get closeButtonTitle() {\n      return this.localization.get('closeTitle');\n    }\n\n    closeTab(index) {\n      const closeArgs = new TabCloseEvent(index, this.tab);\n      this.tabClose.emit(closeArgs);\n    }\n\n  }\n\n  TabComponent.ɵfac = function TabComponent_Factory(t) {\n    return new (t || TabComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  TabComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabComponent,\n    selectors: [[\"\", \"kendoTabStripTab\", \"\"]],\n    hostVars: 13,\n    hostBindings: function TabComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-selected\", ctx.activeClass)(\"aria-disabled\", ctx.disabledClass)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"k-item\", ctx.hostClasses)(\"k-state-default\", ctx.hostClasses)(\"k-state-active\", ctx.activeClass)(\"k-state-disabled\", ctx.disabledClass)(\"k-state-focused\", ctx.focusedClass);\n      }\n    },\n    inputs: {\n      tab: \"tab\",\n      index: \"index\",\n      tabStripClosable: \"tabStripClosable\",\n      tabStripCloseIcon: \"tabStripCloseIcon\"\n    },\n    outputs: {\n      tabClose: \"tabClose\"\n    },\n    attrs: _c13,\n    decls: 3,\n    vars: 3,\n    consts: [[\"class\", \"k-link\", 4, \"ngIf\"], [\"class\", \"k-remove-tab k-button k-icon-button k-flat\", \"role\", \"button\", 3, \"title\", \"click\", 4, \"ngIf\"], [1, \"k-link\"], [3, \"ngTemplateOutlet\"], [\"role\", \"button\", 1, \"k-remove-tab\", \"k-button\", \"k-icon-button\", \"k-flat\", 3, \"title\", \"click\"], [3, \"ngClass\"]],\n    template: function TabComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TabComponent_span_0_Template, 2, 1, \"span\", 0);\n        i0.ɵɵtemplate(1, TabComponent_span_1_Template, 2, 1, \"span\", 0);\n        i0.ɵɵtemplate(2, TabComponent_span_2_Template, 2, 3, \"span\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.tab.tabTitle);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.tab.tabTitle);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.tabClosable);\n      }\n    },\n    directives: [i2.NgIf, i2.NgTemplateOutlet, i2.NgClass],\n    encapsulation: 2\n  });\n  return TabComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TabStripMessages = /*#__PURE__*/(() => {\n  class TabStripMessages extends ComponentMessages {}\n\n  TabStripMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵTabStripMessages_BaseFactory;\n    return function TabStripMessages_Factory(t) {\n      return (ɵTabStripMessages_BaseFactory || (ɵTabStripMessages_BaseFactory = i0.ɵɵgetInheritedFactory(TabStripMessages)))(t || TabStripMessages);\n    };\n  }();\n\n  TabStripMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TabStripMessages,\n    selectors: [[\"kendo-tabstrip-messages-base\"]],\n    inputs: {\n      closeTitle: \"closeTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TabStripMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedTabStripMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedTabStripMessagesDirective extends TabStripMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedTabStripMessagesDirective.ɵfac = function LocalizedTabStripMessagesDirective_Factory(t) {\n    return new (t || LocalizedTabStripMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedTabStripMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedTabStripMessagesDirective,\n    selectors: [[\"\", \"kendoTabStripLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TabStripMessages,\n      useExisting: forwardRef(() => LocalizedTabStripMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedTabStripMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).\n */\n\n\nlet TabStripComponent = /*#__PURE__*/(() => {\n  class TabStripComponent {\n    constructor(localization, renderer, wrapper, tabstripService, scrollService, ngZone) {\n      this.localization = localization;\n      this.renderer = renderer;\n      this.wrapper = wrapper;\n      this.tabstripService = tabstripService;\n      this.scrollService = scrollService;\n      this.ngZone = ngZone;\n      /**\n       * Enables the tab animation.\n       *\n       * @default true\n       */\n\n      this.animate = true;\n      /**\n       * Sets the position of the tabs. Defaults to `top`.\n       *\n       * @default 'top'\n       */\n\n      this.tabPosition = 'top';\n      /**\n       * When set to `true`, the component renders all tabs and they are persisted in the DOM.\n       * By default, `keepTabContent` is `false`.\n       *\n       * @default false\n       */\n\n      this.keepTabContent = false;\n      /**\n       * When set to `true`, a close button will be rendered inside each tab.\n       * By default, `closable` is `false`.\n       *\n       * @default false\n       */\n\n      this.closable = false;\n      /**\n       * Allows defining a custom CSS class, or multiple classes separated by spaces, which will be applied to the close button span element.\n       * Allows the usage of custom icons.\n       */\n\n      this.closeIcon = 'k-icon k-i-x';\n      /**\n       * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).\n       * The event data contains the index of the selected tab and its title.\n       */\n\n      this.tabSelect = new EventEmitter();\n      /**\n       * Fires each time the user closes a tab.\n       * The event data contains the index of the closed tab and its instance.\n       */\n\n      this.tabClose = new EventEmitter();\n      /**\n       * Fires each time the user scrolls the TabStrip list.\n       * The event is preventable.\n       */\n\n      this.tabScroll = new EventEmitter();\n      this.hostClasses = true;\n      /**\n       * A query list of all declared tabs.\n       */\n\n      this.tabs = new QueryList();\n      this._scrollableSettings = normalizeScrollableSettings(false);\n      this.subscriptions = new Subscription();\n      this.subscriptionsArePresent = false;\n      validatePackage(packageMetadata);\n      this.tabstripService.owner = this;\n      this.scrollService.owner = this;\n      this.subscriptions.add(this.scrollService.scrollButtonActiveStateChange.subscribe(activeButtonSettings => {\n        if (this.hasScrollButtons) {\n          const action = activeButtonSettings.active ? 'remove' : 'add';\n          this.renderer[`${action}Class`](this[`${activeButtonSettings.buttonType}ScrollButton`].host.nativeElement, 'k-disabled');\n        }\n      }));\n    }\n    /**\n     * Sets the height of the TabStrip.\n     */\n\n\n    set height(value) {\n      this._height = value;\n      this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);\n    }\n\n    get height() {\n      return this._height;\n    }\n    /**\n     * Enables the scrolling of the tab list. When set to `true` and the total size of all tabs\n     * is greater than the size of the TabStrip container, scroll buttons will be rendered on each end of the tab list.\n     *\n     * By default, `scrollable` is `false`.\n     *\n     * @default false\n     */\n\n\n    set scrollable(value) {\n      this._scrollableSettings = normalizeScrollableSettings(value);\n\n      if (this.tablist) {\n        this.toggleScrollButtons(this.scrollService.tabsOverflow);\n        this.attachWheelHandler(this.tablist.nativeElement);\n      }\n    }\n\n    get scrollable() {\n      return this._scrollableSettings;\n    }\n\n    get tabsAtTop() {\n      return this.tabPosition === 'top';\n    }\n\n    get tabsAtRight() {\n      return this.tabPosition === 'right';\n    }\n\n    get tabsAtBottom() {\n      return this.tabPosition === 'bottom';\n    }\n\n    get tabsAtLeft() {\n      return this.tabPosition === 'left';\n    }\n\n    get dir() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n\n    get tabStripScrollable() {\n      return this._scrollableSettings.enabled;\n    }\n\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.scrollService.tabsOverflow) {\n          this.toggleScrollButtons(true);\n        } else {\n          this.toggleScrollButtons(false);\n        }\n\n        setTimeout(() => {\n          this.scrollToSelectedTab();\n        });\n      });\n      this.initDomEvents();\n    }\n\n    ngOnChanges(changes) {\n      const positionChange = changes.tabPosition;\n\n      if (positionChange) {\n        const tabsAtBottomChanged = positionChange.previousValue === 'bottom' || positionChange.currentValue === 'bottom';\n        this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n          if (tabsAtBottomChanged) {\n            if (this.subscriptionsArePresent) {\n              this.subscriptions.unsubscribe();\n              this.subscriptions = new Subscription();\n              this.subscriptionsArePresent = false;\n            }\n\n            this.initDomEvents();\n          }\n\n          this.scrollService.restoreScrollPosition();\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tabsAlignmentStyles() {\n      return {\n        start: 'flex-start',\n        end: 'flex-end',\n        center: 'center',\n        justify: 'space-between'\n      }[this.tabAlignment];\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tabListWidth() {\n      if (this.tabPosition === 'top' || this.tabPosition === 'bottom') {\n        return '100%';\n      }\n\n      return null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tabListHeight() {\n      if (this.tabPosition === 'left' || this.tabPosition === 'right') {\n        return '100%';\n      }\n\n      return null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isScrollable() {\n      return this._scrollableSettings.enabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasScrollButtons() {\n      return tabStripHasScrollButtons(this._scrollableSettings);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get mouseScrollEnabled() {\n      return mouseScrollEnabled(this._scrollableSettings);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get itemsWrapperClass() {\n      return isTablistHorizontal(this.tabPosition) ? 'k-hstack' : 'k-vstack';\n    }\n    /**\n     * Allows the user to select a tab programmatically.\n     * @param {number} index - The index of the tab that will be selected.\n     */\n\n\n    selectTab(index) {\n      const tab = getTabByIndex(this.tabs, index);\n\n      if (!tab || tab.disabled) {\n        return;\n      }\n\n      this.tabstripService.selectTab(tab, index);\n      this.scrollToSelectedTab();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onTabClick(originalEvent, tabIndex) {\n      if (isFocusable(originalEvent.target)) {\n        return;\n      }\n\n      const targetElement = originalEvent.target;\n      const isTargetCloseButton = hasClass(targetElement, 'k-remove-tab') || hasClass(targetElement.parentElement, 'k-remove-tab');\n\n      if (isTargetCloseButton) {\n        return;\n      }\n\n      const tab = getTabByIndex(this.tabs, tabIndex);\n      this.tabstripService.onTabSelect(tab, tabIndex);\n      this.scrollToSelectedTab();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (this.scrollService.tabsOverflow) {\n        this.toggleScrollButtons(true);\n      } else {\n        this.toggleScrollButtons(false);\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        this.scrollService.toggleScrollButtonsState();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    scrollToSelectedTab() {\n      if (this._scrollableSettings.enabled) {\n        this.scrollService.scrollToSelectedTab();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onScrollButtonClick(buttonType) {\n      this.scrollService.scrollTabs(buttonType);\n    }\n\n    initDomEvents() {\n      if (!this.wrapper || this.subscriptionsArePresent) {\n        return;\n      }\n\n      const tablist = this.tablist.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(tablist, 'keydown', ev => {\n          this.tabstripService.onKeyDown(ev);\n        }));\n      });\n      this.subscriptions.add(this.renderer.listen(tablist, 'focusout', () => {\n        resetTabFocus(this.tabs);\n      }));\n\n      if (this.isScrollable && this.mouseScrollEnabled) {\n        this.attachWheelHandler(tablist);\n      }\n\n      this.subscriptionsArePresent = true;\n    }\n\n    toggleScrollButtons(tabsOverflow) {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        const scrollButtonsSetting = this._scrollableSettings.scrollButtons;\n        const scrollButtonsArePresent = this.prevScrollButton && this.nextScrollButton;\n        const shouldShowButtons = scrollButtonsArePresent && tabsOverflow;\n        const shouldHideButtons = scrollButtonsArePresent && !tabsOverflow && scrollButtonsSetting !== 'visible';\n        const alwaysVisible = scrollButtonsSetting === 'visible';\n\n        if (shouldHideButtons) {\n          this.prevScrollButton.toggle(false);\n          this.nextScrollButton.toggle(false);\n        } else if (shouldShowButtons || alwaysVisible) {\n          this.prevScrollButton.toggle(true);\n          this.nextScrollButton.toggle(true);\n        }\n\n        if (scrollButtonsArePresent && alwaysVisible) {\n          this.ngZone.runOutsideAngular(() => {\n            this.scrollService.toggleScrollButtonsState();\n          });\n        }\n      });\n    }\n\n    attachWheelHandler(tablist) {\n      this.ngZone.runOutsideAngular(() => {\n        this.subscriptions.add(this.renderer.listen(tablist, 'wheel', wheelEvent => {\n          const scrollEvent = new TabScrollEvent({\n            originalEvent: wheelEvent\n          });\n          this.tabScroll.emit(scrollEvent);\n          const isTabStripScrollEventPrevented = scrollEvent.isDefaultPrevented();\n\n          if (isTabStripScrollEventPrevented || !this.scrollService.tabsOverflow) {\n            return;\n          }\n\n          this.scrollService.onMouseScroll(wheelEvent);\n        }));\n      });\n    }\n\n  }\n\n  TabStripComponent.ɵfac = function TabStripComponent_Factory(t) {\n    return new (t || TabStripComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TabStripService), i0.ɵɵdirectiveInject(ScrollService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  TabStripComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabStripComponent,\n    selectors: [[\"kendo-tabstrip\"]],\n    contentQueries: function TabStripComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TabStripTabComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabs = _t);\n      }\n    },\n    viewQuery: function TabStripComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c14, 5);\n        i0.ɵɵviewQuery(_c15, 5);\n        i0.ɵɵviewQuery(_c16, 5);\n        i0.ɵɵviewQuery(_c17, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tablist = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextScrollButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabHeaderContainers = _t);\n      }\n    },\n    hostVars: 15,\n    hostBindings: function TabStripComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-tabstrip\", ctx.hostClasses)(\"k-floatwrap\", ctx.hostClasses)(\"k-tabstrip-top\", ctx.tabsAtTop)(\"k-tabstrip-right\", ctx.tabsAtRight)(\"k-tabstrip-bottom\", ctx.tabsAtBottom)(\"k-tabstrip-left\", ctx.tabsAtLeft)(\"k-tabstrip-scrollable\", ctx.tabStripScrollable);\n      }\n    },\n    inputs: {\n      height: \"height\",\n      animate: \"animate\",\n      tabAlignment: \"tabAlignment\",\n      tabPosition: \"tabPosition\",\n      keepTabContent: \"keepTabContent\",\n      closable: \"closable\",\n      scrollable: \"scrollable\",\n      closeIcon: \"closeIcon\"\n    },\n    outputs: {\n      tabSelect: \"tabSelect\",\n      tabClose: \"tabClose\",\n      tabScroll: \"tabScroll\"\n    },\n    exportAs: [\"kendoTabStrip\"],\n    features: [i0.ɵɵProvidersFeature([TabStripService, ScrollService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.tabstrip'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 3,\n    consts: function () {\n      let i18n_18;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title for the **Close** button in the TabStrip tab.\n         * @meaning kendo.tabstrip.closeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2015_KENDO_ANGULAR_LAYOUT_JS_19 = goog.getMsg(\"Close\");\n        i18n_18 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2015_KENDO_ANGULAR_LAYOUT_JS_19;\n      } else {\n        i18n_18 = $localize`:kendo.tabstrip.closeTitle|The title for the **Close** button in the TabStrip tab.:Close`;\n      }\n\n      return [[\"kendoTabStripLocalizedMessages\", \"\", \"closeTitle\", i18n_18], [4, \"ngIf\"], [\"heading\", \"\"], [\"content\", \"\"], [3, \"resize\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [1, \"k-tabstrip-items-wrapper\", 3, \"ngClass\"], [\"kendoTabStripScrollableButton\", \"\", 3, \"scrollable\", \"tabPosition\", \"prev\", \"tabScroll\", \"onClick\", 4, \"ngIf\"], [\"role\", \"tablist\", 1, \"k-reset\", \"k-tabstrip-items\"], [\"tablist\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"kendoTabStripScrollableButton\", \"\", 3, \"scrollable\", \"tabPosition\", \"prev\", \"tabScroll\", \"onClick\"], [\"prevScrollButton\", \"\"], [\"kendoTabStripTab\", \"\", \"role\", \"tab\", 3, \"ngClass\", \"ngStyle\", \"tab\", \"index\", \"tabStripClosable\", \"tabStripCloseIcon\", \"id\", \"tabClose\", \"click\"], [\"tabHeaderContainer\", \"\"], [\"nextScrollButton\", \"\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"role\", \"tabpanel\", 3, \"ngClass\", \"tabIndex\", \"id\", 4, \"ngIf\"], [\"role\", \"tabpanel\", 3, \"ngClass\", \"tabIndex\", \"id\"], [3, \"ngTemplateOutlet\"], [3, \"resize\"]];\n    },\n    template: function TabStripComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, TabStripComponent_ng_container_1_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, TabStripComponent_ng_container_2_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(3, TabStripComponent_ng_template_3_Template, 6, 10, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, TabStripComponent_ng_template_5_Template, 1, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, TabStripComponent_kendo_resize_sensor_7_Template, 1, 0, \"kendo-resize-sensor\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.tabsAtBottom);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.tabsAtBottom);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.isScrollable);\n      }\n    },\n    directives: [TabStripScrollableButtonComponent, TabComponent, i1$1.ResizeSensorComponent, LocalizedTabStripMessagesDirective, i2.NgIf, i2.NgTemplateOutlet, i2.NgClass, i2.NgForOf, i2.NgStyle],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('state', [state('active', style({\n        opacity: 1\n      })), transition('* => active', [style({\n        opacity: 0\n      }), animate('400ms ease-in')])])]\n    }\n  });\n  return TabStripComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\n\n\nlet TabStripCustomMessagesComponent = /*#__PURE__*/(() => {\n  class TabStripCustomMessagesComponent extends TabStripMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  TabStripCustomMessagesComponent.ɵfac = function TabStripCustomMessagesComponent_Factory(t) {\n    return new (t || TabStripCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  TabStripCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TabStripCustomMessagesComponent,\n    selectors: [[\"kendo-tabstrip-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TabStripMessages,\n      useExisting: forwardRef(() => TabStripCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function TabStripCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TabStripCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.\n * Using this template directive will override all other templates,\n * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.\n */\n\n\nlet DrawerTemplateDirective = /*#__PURE__*/(() => {\n  class DrawerTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DrawerTemplateDirective.ɵfac = function DrawerTemplateDirective_Factory(t) {\n    return new (t || DrawerTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DrawerTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DrawerTemplateDirective,\n    selectors: [[\"\", \"kendoDrawerTemplate\", \"\"]]\n  });\n  return DrawerTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the item content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.\n */\n\n\nlet DrawerItemTemplateDirective = /*#__PURE__*/(() => {\n  class DrawerItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DrawerItemTemplateDirective.ɵfac = function DrawerItemTemplateDirective_Factory(t) {\n    return new (t || DrawerItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DrawerItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DrawerItemTemplateDirective,\n    selectors: [[\"\", \"kendoDrawerItemTemplate\", \"\"]]\n  });\n  return DrawerItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the header content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.\n */\n\n\nlet DrawerHeaderTemplateDirective = /*#__PURE__*/(() => {\n  class DrawerHeaderTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DrawerHeaderTemplateDirective.ɵfac = function DrawerHeaderTemplateDirective_Factory(t) {\n    return new (t || DrawerHeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DrawerHeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DrawerHeaderTemplateDirective,\n    selectors: [[\"\", \"kendoDrawerHeaderTemplate\", \"\"]]\n  });\n  return DrawerHeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the footer content of the Drawer.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.\n */\n\n\nlet DrawerFooterTemplateDirective = /*#__PURE__*/(() => {\n  class DrawerFooterTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DrawerFooterTemplateDirective.ɵfac = function DrawerFooterTemplateDirective_Factory(t) {\n    return new (t || DrawerFooterTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DrawerFooterTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DrawerFooterTemplateDirective,\n    selectors: [[\"\", \"kendoDrawerFooterTemplate\", \"\"]]\n  });\n  return DrawerFooterTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst defaultIsItemExpanded = _item => false;\n/**\n * @hidden\n */\n\n\nlet DrawerService = /*#__PURE__*/(() => {\n  class DrawerService {\n    constructor() {\n      this.selectedIndices = [];\n      this.originalItems = [];\n      this.idxCounter = 0;\n      this.isItemExpanded = defaultIsItemExpanded;\n    }\n\n    init() {\n      this.resetViewData();\n      this.originalItems = this.owner.items || [];\n      let rootItems = this.originalItems.filter(item => !isPresent(item.parentId));\n      this.populateViewData(rootItems);\n    }\n\n    get view() {\n      return Array.from(this.viewData);\n    }\n\n    populateViewData(items, level = 0) {\n      items.forEach(item => {\n        this.setSelection(item);\n        const children = this.loadChildren(item);\n        const isExpanded = this.isItemExpanded(item);\n        this.viewData.add({\n          item: item,\n          index: this.idxCounter++,\n          level: level,\n          hasChildren: children.length > 0,\n          isExpanded: isExpanded\n        });\n\n        if (children.length > 0 && isExpanded) {\n          this.populateViewData(children, level + 1);\n        }\n      });\n    }\n\n    resetViewData() {\n      this.idxCounter = 0;\n      this.viewData = new Set();\n    }\n\n    loadChildren(item) {\n      return this.originalItems.filter(i => {\n        return isPresent(i.parentId) && i.parentId === item.id;\n      });\n    }\n\n    onSelect(selectedIdx) {\n      this.selectedIndices = [selectedIdx];\n      const drawer = this.owner;\n\n      if (drawer.autoCollapse && !drawer.minimized) {\n        drawer.toggle(false);\n      }\n    }\n\n    setSelection(item) {\n      if (this.selectedIndices.length === 0 && item.selected) {\n        this.selectedIndices.push(this.idxCounter);\n      }\n    }\n\n    resetSelection() {\n      this.selectedIndices = [];\n    }\n\n  }\n\n  DrawerService.ɵfac = function DrawerService_Factory(t) {\n    return new (t || DrawerService)();\n  };\n\n  DrawerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DrawerService,\n    factory: DrawerService.ɵfac\n  });\n  return DrawerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction miniExpandPush(duration, width, miniWidth) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: `${miniWidth}px`\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction miniCollapsePush(duration, width, miniWidth) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${miniWidth}px`\n  }))];\n}\n/**\n * @hidden\n *\n */\n\n\nfunction miniExpandOverlay(duration, width, miniWidth) {\n  return [style({\n    width: `${miniWidth}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    width: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction expandPush(duration, width) {\n  return [style({\n    overflow: 'hidden',\n    flexBasis: '0px'\n  }), animate(`${duration}ms ease-in`, style({\n    flexBasis: `${width}px`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction collapsePush(duration, width) {\n  return [style({\n    flexBasis: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    flexBasis: `0px`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction expandRTLOverlay(duration) {\n  return [style({\n    transform: `translateX(100%)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(0)`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction expandOverlay(duration, position) {\n  const translateDir = position !== 'end' ? `-100%` : `100%`;\n  return [style({\n    transform: `translateX(${translateDir})`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(0)`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction miniCollapseOverlay(duration, width, miniWidth) {\n  return [style({\n    width: `${width}px`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    width: `${miniWidth}px`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction collapseOverlay(duration, position) {\n  const translateDir = position !== 'end' ? '-100%' : '100%';\n  return [style({\n    transform: `translateX(0)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(${translateDir})`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction collapseRTLOverlay(duration) {\n  return [style({\n    transform: `translateX(0)`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    transform: `translateX(100%)`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction expandAnimation(settings) {\n  const duration = settings.animation.duration;\n  const width = settings.width;\n  const miniWidth = settings.miniWidth;\n  const mode = settings.mode;\n  const mini = settings.mini;\n  const rtl = settings.rtl;\n  const position = settings.position;\n\n  if (mini && mode === 'push') {\n    return miniExpandPush(duration, width, miniWidth);\n  }\n\n  if (!mini && mode === 'push') {\n    return expandPush(duration, width);\n  }\n\n  if (!mini && mode === 'overlay') {\n    return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);\n  }\n\n  if (mini && mode === 'overlay') {\n    return miniExpandOverlay(duration, width, miniWidth);\n  }\n}\n/**\n * @hidden\n */\n\n\nfunction collapseAnimation(settings) {\n  const duration = settings.animation.duration;\n  const width = settings.width;\n  const miniWidth = settings.miniWidth;\n  const mode = settings.mode;\n  const mini = settings.mini;\n  const rtl = settings.rtl;\n  const position = settings.position;\n\n  if (mini && mode === 'push') {\n    return miniCollapsePush(duration, width, miniWidth);\n  }\n\n  if (!mini && mode === 'push') {\n    return collapsePush(duration, width);\n  }\n\n  if (!mini && mode === 'overlay') {\n    return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);\n  }\n\n  if (mini && mode === 'overlay') {\n    return miniCollapseOverlay(duration, width, miniWidth);\n  }\n}\n/**\n * @hidden\n */\n\n\nconst DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';\n/**\n * @hidden\n */\n\nconst DRAWER_LINK_SELECTOR = '.k-drawer-link';\n/**\n * @hidden\n */\n\nconst ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-state-disabled) .k-drawer-link';\n/**\n * @hidden\n */\n\nconst nestedLink = (element, selector) => element.querySelector(selector);\n/**\n * @hidden\n */\n\n\nclass DrawerListSelectEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet DrawerItemComponent = /*#__PURE__*/(() => {\n  class DrawerItemComponent {\n    constructor(drawer, element, renderer) {\n      this.drawer = drawer;\n      this.element = element;\n      this.renderer = renderer;\n    }\n\n    get disabledClass() {\n      return this.item.disabled;\n    }\n\n    get selectedClass() {\n      return this.drawer.selectedIndices.indexOf(this.index) >= 0;\n    }\n\n    get label() {\n      return this.item.text ? this.item.text : null;\n    }\n\n    ngAfterViewInit() {\n      const elem = this.element.nativeElement;\n      const link = nestedLink(elem, DRAWER_LINK_SELECTOR);\n\n      if (link) {\n        this.renderer.removeAttribute(link, 'tabindex');\n      }\n    }\n\n    get iconClasses() {\n      const classes = [];\n\n      if (this.item.icon) {\n        classes.push(`k-icon ${this.item.icon}`);\n      }\n\n      if (this.item.iconClass) {\n        classes.push(`${this.item.iconClass}`);\n      }\n\n      return classes;\n    }\n\n    get item() {\n      return this.viewItem.item;\n    }\n\n  }\n\n  DrawerItemComponent.ɵfac = function DrawerItemComponent_Factory(t) {\n    return new (t || DrawerItemComponent)(i0.ɵɵdirectiveInject(DrawerService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  DrawerItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DrawerItemComponent,\n    selectors: [[\"\", \"kendoDrawerItem\", \"\"]],\n    hostVars: 7,\n    hostBindings: function DrawerItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"aria-current\", ctx.selectedClass)(\"aria-label\", ctx.label);\n        i0.ɵɵclassProp(\"k-state-disabled\", ctx.disabledClass)(\"k-state-selected\", ctx.selectedClass);\n      }\n    },\n    inputs: {\n      viewItem: \"viewItem\",\n      index: \"index\",\n      itemTemplate: \"itemTemplate\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      disabled: \"disabled\",\n      cssClass: \"cssClass\",\n      cssStyle: \"cssStyle\"\n    },\n    attrs: _c20,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\", \"ngIfElse\"], [\"defaultTemplate\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngIf\"], [3, \"ngClass\"], [1, \"k-item-text\"], [\"class\", \"k-icon k-drawer-toggle\", 3, \"k-i-arrow-chevron-up\", \"k-i-arrow-chevron-down\", 4, \"ngIf\"], [1, \"k-icon\", \"k-drawer-toggle\"]],\n    template: function DrawerItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DrawerItemComponent_0_Template, 1, 7, null, 0);\n        i0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n\n        i0.ɵɵproperty(\"ngIf\", ctx.itemTemplate)(\"ngIfElse\", _r1);\n      }\n    },\n    directives: [i2.NgIf, i2.NgTemplateOutlet, i2.NgClass],\n    encapsulation: 2\n  });\n  return DrawerItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DrawerListComponent = /*#__PURE__*/(() => {\n  class DrawerListComponent {\n    constructor(drawerService, renderer, ngZone, element) {\n      this.drawerService = drawerService;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.element = element;\n      this.view = [];\n      this.select = new EventEmitter();\n      this.subscriptions = new Subscription();\n    }\n\n    ngOnInit() {\n      this.initDomEvents();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    identifyItem(_index, viewItem) {\n      var _a;\n\n      return (_a = viewItem.item.id) !== null && _a !== void 0 ? _a : viewItem.index;\n    }\n\n    initDomEvents() {\n      if (!this.element) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        const nativeElement = this.element.nativeElement;\n        this.subscriptions.add(this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this)));\n        this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', this.keyDownHandler.bind(this)));\n      });\n    }\n\n    clickHandler(e) {\n      const viewItemIdx = this.getDrawerItemIndex(e.target);\n      const viewItem = this.view[viewItemIdx];\n\n      if (!viewItem) {\n        return;\n      }\n\n      if (viewItem.item.disabled) {\n        e.preventDefault();\n        return;\n      }\n\n      const args = {\n        index: viewItem.index,\n        item: viewItem.item,\n        originalEvent: e\n      };\n      this.ngZone.run(() => {\n        const event = new DrawerListSelectEvent(args);\n        this.select.emit(event);\n\n        if (!event.isDefaultPrevented()) {\n          this.drawerService.onSelect(viewItemIdx);\n          this.drawerService.init();\n          this.view = this.drawerService.view;\n        }\n      });\n    }\n\n    keyDownHandler(e) {\n      const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;\n\n      if (!isEnterOrSpace) {\n        return;\n      }\n\n      this.clickHandler(e);\n      const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);\n\n      if (link) {\n        link.click();\n      }\n\n      return false;\n    }\n\n    getDrawerItemIndex(target) {\n      const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);\n\n      if (item) {\n        return itemIndex(item, DRAWER_ITEM_INDEX);\n      }\n    }\n\n  }\n\n  DrawerListComponent.ɵfac = function DrawerListComponent_Factory(t) {\n    return new (t || DrawerListComponent)(i0.ɵɵdirectiveInject(DrawerService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  DrawerListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DrawerListComponent,\n    selectors: [[\"\", \"kendoDrawerList\", \"\"]],\n    inputs: {\n      itemTemplate: \"itemTemplate\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      view: \"view\"\n    },\n    outputs: {\n      select: \"select\"\n    },\n    attrs: _c22,\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"kendoDrawerItem\", \"\", \"tabindex\", \"0\", 3, \"class\", \"viewItem\", \"index\", \"mini\", \"expanded\", \"itemTemplate\", \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"class\", \"k-drawer-item k-drawer-separator\", 3, \"ngClass\", \"ngStyle\", 4, \"ngIf\"], [\"kendoDrawerItem\", \"\", \"tabindex\", \"0\", 3, \"viewItem\", \"index\", \"mini\", \"expanded\", \"itemTemplate\", \"ngClass\", \"ngStyle\"], [1, \"k-drawer-item\", \"k-drawer-separator\", 3, \"ngClass\", \"ngStyle\"]],\n    template: function DrawerListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DrawerListComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.view)(\"ngForTrackBy\", ctx.identifyItem);\n      }\n    },\n    directives: [DrawerItemComponent, i2.NgForOf, i2.NgIf, i2.NgClass, i2.NgStyle],\n    encapsulation: 2\n  });\n  return DrawerListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_ANIMATION = {\n  type: 'slide',\n  duration: 200\n};\n/**\n * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-drawer-container>\n *             <kendo-drawer #drawer\n *                  [items]=\"items\"\n *                  mode=\"overlay\"\n *                  [(expanded)]=\"expanded\">\n *              </kendo-drawer>\n *              <kendo-drawer-content>\n *                  <button class=\"k-button\" (click)=\"drawer.toggle()\">Open the Drawer</button>\n *              </kendo-drawer-content>\n *        </kendo-drawer-container>\n *    `\n * })\n * class AppComponent {\n *    public expanded = false;\n *\n *    public items: any[] = [\n *      { text: 'Inbox', icon: 'k-i-inbox' },\n *      { text: 'Notifications', icon: 'k-i-bell' },\n *      { text: 'Date', icon: 'k-i-calendar' }\n *    ];\n * }\n * ```\n */\n\nlet DrawerComponent = /*#__PURE__*/(() => {\n  class DrawerComponent {\n    constructor(element, builder, localizationService, drawerService) {\n      this.element = element;\n      this.builder = builder;\n      this.localizationService = localizationService;\n      this.drawerService = drawerService;\n      this.hostClasses = true;\n      /**\n       * Specifies the mode in which the Drawer will be displayed.\n       *\n       * The possible values are:\n       * * (Default) `overlay`\n       * * `push`\n       */\n\n      this.mode = 'overlay';\n      /**\n       * Specifies the position of the Drawer\n       * ([see example]({% slug positioning_drawer %})).\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `end`\n       */\n\n      this.position = 'start';\n      /**\n       * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed\n       * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).\n       */\n\n      this.mini = false;\n      /**\n       * Specifies the state of the Drawer.\n       */\n\n      this.expanded = false;\n      /**\n       * Defines the width of the Drawer when it is expanded.\n       * Defaults to `240`.\n       */\n\n      this.width = 240;\n      /**\n       * Defines the width of the Drawer when the mini view is enabled\n       * and the component is collapsed. Defaults to `60`.\n       */\n\n      this.miniWidth = 50;\n      /**\n       * Specifies if the Drawer will be automatically collapsed when an item\n       * or the overlay is clicked. Defaults to `true`.\n       */\n\n      this.autoCollapse = true;\n      /**\n       * The collection of items that will be rendered in the Drawer.\n       */\n\n      this.items = [];\n      /**\n       * Specifies the animation settings of the Drawer.\n       * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true`\n       *    * `false`\n       * * `DrawerAnimation`\n       *    * (Default) `type?: 'slide'`\n       *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.\n       */\n\n      this.animation = DEFAULT_ANIMATION;\n      /**\n       * Fires when the Drawer is expanded and its animation is complete.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the Drawer is collapsed and its animation is complete.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Fires when a Drawer item is selected. This event is preventable.\n       */\n\n      this.select = new EventEmitter();\n      /**\n       * Fires when the `expanded` property of the component was updated.\n       * Used to provide a two-way binding for the `expanded` property.\n       */\n\n      this.expandedChange = new EventEmitter();\n      this.animationEnd = new EventEmitter();\n      this.rtl = false;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n      this.drawerService.owner = this;\n    }\n\n    get startPositionClass() {\n      return this.position === 'start';\n    }\n\n    get endPositionClass() {\n      return this.position === 'end';\n    }\n\n    get overlayTransofrmStyles() {\n      if (this.mode === 'push') {\n        return;\n      }\n\n      if (this.expanded || this.minimized) {\n        return `translateX(0px)`;\n      }\n\n      return `translateX(-100%)`;\n    }\n\n    get flexStyles() {\n      if (this.mode === 'overlay') {\n        return;\n      }\n\n      if (!this.expanded && !this.minimized) {\n        return 0;\n      }\n\n      return this.drawerWidth;\n    }\n    /**\n     * Defines a callback function which determines if an item should be expanded.\n     */\n\n\n    set isItemExpanded(fn) {\n      if (isDevMode && isPresent(fn) && typeof fn !== 'function') {\n        throw new Error(`isItemExpanded must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this.drawerService.isItemExpanded = fn;\n    }\n\n    get isItemExpanded() {\n      return this.drawerService.isItemExpanded;\n    }\n\n    ngOnChanges(changes) {\n      if (changes && changes['items']) {\n        this.drawerService.resetSelection();\n        this.drawerService.init();\n        this.viewItems = this.drawerService.view;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get minimized() {\n      return this.mini && !this.expanded;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get drawerWidth() {\n      return this.minimized ? this.miniWidth : this.width;\n    }\n    /**\n     * Toggles the visibility of the Drawer.\n     *\n     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.\n     */\n\n\n    toggle(expanded) {\n      const previous = this.expanded;\n      const current = isPresent(expanded) ? expanded : !previous;\n\n      if (current === previous) {\n        return;\n      }\n\n      if (current === true) {\n        this.setExpanded(true);\n      } else if (current === false && !this.animation) {\n        this.setExpanded(false);\n      }\n\n      if (this.animation) {\n        this.animationEnd.pipe(take(1)).subscribe(() => {\n          this.onAnimationEnd(current);\n        });\n        this.animate(current);\n      } else {\n        this[current ? 'expand' : 'collapse'].emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onSelect(e) {\n      this.select.emit(Object.assign(e, {\n        sender: this\n      }));\n    }\n\n    onAnimationEnd(currentExpanded) {\n      if (currentExpanded) {\n        this.expand.emit();\n      } else {\n        this.setExpanded(false);\n        this.collapse.emit();\n      }\n    }\n\n    setExpanded(value) {\n      this.expanded = value;\n      this.expandedChange.emit(value);\n    }\n\n    animate(expanded) {\n      const settings = {\n        mode: this.mode,\n        mini: this.mini,\n        miniWidth: this.miniWidth,\n        width: this.width,\n        rtl: this.rtl,\n        position: this.position,\n        animation: typeof this.animation !== 'boolean' ? this.animation : DEFAULT_ANIMATION\n      };\n      const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);\n      const player = this.createPlayer(animation, this.element.nativeElement);\n      player.play();\n    }\n\n    createPlayer(animation, animatedElement) {\n      const factory = this.builder.build(animation);\n      let player = factory.create(animatedElement);\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n      return player;\n    }\n\n  }\n\n  DrawerComponent.ɵfac = function DrawerComponent_Factory(t) {\n    return new (t || DrawerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$2.AnimationBuilder), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(DrawerService));\n  };\n\n  DrawerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DrawerComponent,\n    selectors: [[\"kendo-drawer\"]],\n    contentQueries: function DrawerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerFooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerHeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DrawerItemTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    hostVars: 13,\n    hostBindings: function DrawerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"transform\", ctx.overlayTransofrmStyles)(\"flex-basis\", ctx.flexStyles, \"px\");\n        i0.ɵɵclassProp(\"k-widget\", ctx.hostClasses)(\"k-drawer\", ctx.hostClasses)(\"k-drawer-start\", ctx.startPositionClass)(\"k-drawer-end\", ctx.endPositionClass);\n      }\n    },\n    inputs: {\n      mode: \"mode\",\n      position: \"position\",\n      mini: \"mini\",\n      expanded: \"expanded\",\n      width: \"width\",\n      miniWidth: \"miniWidth\",\n      autoCollapse: \"autoCollapse\",\n      items: \"items\",\n      isItemExpanded: \"isItemExpanded\",\n      animation: \"animation\"\n    },\n    outputs: {\n      expand: \"expand\",\n      collapse: \"collapse\",\n      select: \"select\",\n      expandedChange: \"expandedChange\"\n    },\n    exportAs: [\"kendoDrawer\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, DrawerService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.drawer'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"k-drawer-wrapper\", 3, \"width\", 4, \"ngIf\"], [1, \"k-drawer-wrapper\"], [4, \"ngIf\"], [\"kendoDrawerList\", \"\", 1, \"k-drawer-items\", 3, \"mini\", \"expanded\", \"view\", \"itemTemplate\", \"select\"], [3, \"ngTemplateOutlet\"]],\n    template: function DrawerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DrawerComponent_div_0_Template, 3, 4, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.expanded || ctx.mini);\n      }\n    },\n    directives: [DrawerListComponent, i2.NgIf, i2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return DrawerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Serves as a container for the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}) and its content.\n */\n\n\nlet DrawerContainerComponent = /*#__PURE__*/(() => {\n  class DrawerContainerComponent {\n    constructor(localizationService) {\n      this.localizationService = localizationService;\n      this.rtl = false;\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get hostClass() {\n      return true;\n    }\n\n    get overlayClass() {\n      return this.drawer.mode === 'overlay';\n    }\n\n    get miniClass() {\n      return this.drawer.mini;\n    }\n\n    get pushClass() {\n      return this.drawer.mode === 'push';\n    }\n\n    get isExpandedClass() {\n      return this.drawer.expanded;\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get overlay() {\n      return isPresent(this.drawer) && this.drawer.expanded && this.drawer.mode === 'overlay';\n    }\n    /**\n     * @hidden\n     */\n\n\n    closeDrawer() {\n      if (this.overlay && this.drawer.autoCollapse) {\n        this.drawer.toggle(false);\n      }\n    }\n\n  }\n\n  DrawerContainerComponent.ɵfac = function DrawerContainerComponent_Factory(t) {\n    return new (t || DrawerContainerComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  DrawerContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DrawerContainerComponent,\n    selectors: [[\"kendo-drawer-container\"]],\n    contentQueries: function DrawerContainerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DrawerComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawer = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function DrawerContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassProp(\"k-drawer-container\", ctx.hostClass)(\"k-drawer-overlay\", ctx.overlayClass)(\"k-drawer-mini\", ctx.miniClass)(\"k-drawer-push\", ctx.pushClass)(\"k-drawer-expanded\", ctx.isExpandedClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.drawer.container'\n    }])],\n    ngContentSelectors: _c9,\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"k-overlay\", 3, \"click\", 4, \"ngIf\"], [1, \"k-overlay\", 3, \"click\"]],\n    template: function DrawerContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, DrawerContainerComponent_div_0_Template, 1, 0, \"div\", 0);\n        i0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.overlay);\n      }\n    },\n    directives: [i2.NgIf],\n    encapsulation: 2\n  });\n  return DrawerContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the content of the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).\n */\n\n\nlet DrawerContentComponent = /*#__PURE__*/(() => {\n  class DrawerContentComponent {\n    constructor() {\n      this.hostClasses = true;\n    }\n\n  }\n\n  DrawerContentComponent.ɵfac = function DrawerContentComponent_Factory(t) {\n    return new (t || DrawerContentComponent)();\n  };\n\n  DrawerContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DrawerContentComponent,\n    selectors: [[\"kendo-drawer-content\"]],\n    hostVars: 2,\n    hostBindings: function DrawerContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-drawer-content\", ctx.hostClasses);\n      }\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function DrawerContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return DrawerContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `select` event of the Drawer.\n */\n\n\nclass DrawerSelectEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * Represents a template that defines the content of the whole Step.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.\n */\n\n\nlet StepperStepTemplateDirective = /*#__PURE__*/(() => {\n  class StepperStepTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  StepperStepTemplateDirective.ɵfac = function StepperStepTemplateDirective_Factory(t) {\n    return new (t || StepperStepTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  StepperStepTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StepperStepTemplateDirective,\n    selectors: [[\"\", \"kendoStepperStepTemplate\", \"\"]]\n  });\n  return StepperStepTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the content of the Step label.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.\n */\n\n\nlet StepperLabelTemplateDirective = /*#__PURE__*/(() => {\n  class StepperLabelTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  StepperLabelTemplateDirective.ɵfac = function StepperLabelTemplateDirective_Factory(t) {\n    return new (t || StepperLabelTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  StepperLabelTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StepperLabelTemplateDirective,\n    selectors: [[\"\", \"kendoStepperLabelTemplate\", \"\"]]\n  });\n  return StepperLabelTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the content of the Step indicator.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.\n */\n\n\nlet StepperIndicatorTemplateDirective = /*#__PURE__*/(() => {\n  class StepperIndicatorTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  StepperIndicatorTemplateDirective.ɵfac = function StepperIndicatorTemplateDirective_Factory(t) {\n    return new (t || StepperIndicatorTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  StepperIndicatorTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StepperIndicatorTemplateDirective,\n    selectors: [[\"\", \"kendoStepperIndicatorTemplate\", \"\"]]\n  });\n  return StepperIndicatorTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_CURRENT_STEP = 0;\nconst handlers = {};\nhandlers[Keys.ArrowLeft] = 'left';\nhandlers[Keys.ArrowRight] = 'right';\nhandlers[Keys.ArrowUp] = 'up';\nhandlers[Keys.ArrowDown] = 'down';\nhandlers[Keys.Home] = 'home';\nhandlers[Keys.End] = 'end';\nhandlers[Keys.Enter] = 'enter';\nhandlers[Keys.Space] = 'enter';\nconst handlersRTL = Object.assign({}, handlers);\nhandlersRTL[Keys.ArrowLeft] = 'right';\nhandlersRTL[Keys.ArrowRight] = 'left'; // error NG3003: One or more import cycles would need to be created to compile this component,\n// which is not supported by the current compiler configuration\n\n/**\n * @hidden\n */\n\nclass StepperActivateEvent$1 extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet StepperService = /*#__PURE__*/(() => {\n  class StepperService {\n    constructor(localization, ngZone, changeDetector) {\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.changeDetector = changeDetector;\n      this.currentStep = DEFAULT_CURRENT_STEP;\n      this.triggerValidation = new EventEmitter();\n      this.focusedStepChange = new EventEmitter();\n    }\n\n    get handlers() {\n      return this.localization.rtl ? handlersRTL : handlers;\n    }\n\n    emit(event, eventArgs) {\n      const stepper = this.owner;\n\n      if (hasObservers(stepper[event])) {\n        stepper[event].emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    onActivate(currentIdx, originalEvent) {\n      const eventArgs = new StepperActivateEvent$1({\n        index: currentIdx,\n        step: this.owner.steps[currentIdx],\n        originalEvent: originalEvent,\n        sender: this.owner\n      });\n      this.ngZone.run(() => {\n        if (!this.emit('activate', eventArgs)) {\n          this.currentStep = currentIdx;\n          this.owner['currentStepChange'].emit(currentIdx);\n          this.changeDetector.detectChanges();\n        }\n      });\n    }\n\n    validateSteps() {\n      this.triggerValidation.emit();\n    }\n\n    keydown(e) {\n      const current = this.focusedStep || this.currentStep;\n      const handler = this.handlers[e.keyCode];\n\n      if (!isPresent(current)) {\n        return;\n      }\n\n      if (handler) {\n        e.preventDefault();\n        this[handler](e);\n      }\n    }\n\n    left() {\n      if (!this.isHorizontal) {\n        return;\n      }\n\n      this.focusPrevStep();\n    }\n\n    right() {\n      if (!this.isHorizontal) {\n        return;\n      }\n\n      this.focusNextStep();\n    }\n\n    up() {\n      if (this.isHorizontal) {\n        return;\n      }\n\n      this.focusPrevStep();\n    }\n\n    down() {\n      if (this.isHorizontal) {\n        return;\n      }\n\n      this.focusNextStep();\n    }\n\n    home() {\n      this.focusedStep = 0;\n      this.focusedStepChange.emit();\n    }\n\n    end() {\n      this.focusedStep = this.owner.steps.length - 1;\n      this.focusedStepChange.emit();\n    }\n\n    enter(event) {\n      if (this.focusedStep === this.currentStep) {\n        return;\n      }\n\n      if (this.isStepDisabled(this.focusedStep)) {\n        return;\n      }\n\n      if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {\n        return;\n      }\n\n      this.onActivate(this.focusedStep, event);\n    }\n\n    focus(focusedIdx) {\n      this.focusedStep = focusedIdx;\n    }\n\n    focusNextStep() {\n      if (this.focusedStep < this.owner.steps.length) {\n        this.focusedStep += 1;\n        this.focusedStepChange.emit();\n      }\n    }\n\n    focusPrevStep() {\n      if (this.focusedStep > 0) {\n        this.focusedStep -= 1;\n        this.focusedStepChange.emit();\n      }\n    }\n\n    isStepDisabled(index) {\n      return this.owner.steps[index].disabled;\n    }\n\n    isPrevOrNextStep(index) {\n      return index === this.currentStep + 1 || index === this.currentStep - 1;\n    }\n\n    get isHorizontal() {\n      return this.owner.orientation === 'horizontal';\n    }\n\n  }\n\n  StepperService.ɵfac = function StepperService_Factory(t) {\n    return new (t || StepperService)(i0.ɵɵinject(i1.LocalizationService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ChangeDetectorRef));\n  };\n\n  StepperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StepperService,\n    factory: StepperService.ɵfac\n  });\n  return StepperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst STEPPER_STEP_INDEX = 'data-kendo-stepper-index';\n/**\n * @hidden\n */\n\nlet StepperStepComponent = /*#__PURE__*/(() => {\n  class StepperStepComponent {\n    constructor(service, localization, ngZone) {\n      this.service = service;\n      this.localization = localization;\n      this.ngZone = ngZone;\n      this.isStepValid = undefined;\n      this.shouldCheckValidity = undefined;\n      validatePackage(packageMetadata);\n      this.subs = this.service.focusedStepChange.subscribe(() => {\n        this.onFocusedStepChange();\n      });\n      this.subs.add(this.service.triggerValidation.subscribe(() => {\n        this.handleValidityChecks();\n      }));\n    }\n\n    get errorStepClass() {\n      if (isPresent(this.isStepValid)) {\n        return !this.isStepValid;\n      }\n\n      return false;\n    }\n\n    get successStepClass() {\n      if (isPresent(this.isStepValid)) {\n        return this.isStepValid;\n      }\n\n      return false;\n    }\n\n    ngOnInit() {\n      this.handleValidityChecks();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.current && !changes.current.firstChange) {\n        this.handleValidityChecks();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n    }\n\n    onFocusedStepChange() {\n      this.ngZone.runOutsideAngular(() => {\n        if (this.index === this.service.focusedStep) {\n          this.stepLink.nativeElement.focus();\n        }\n      });\n    }\n\n    onFocus() {\n      this.service.focus(this.index);\n    }\n\n    get tabIndexAttr() {\n      const active = this.service.focusedStep || this.service.currentStep;\n      return this.index === active ? 0 : -1;\n    }\n\n    get indicatorIconClasses() {\n      if (this.step.icon) {\n        return `k-icon k-i-${this.step.icon}`;\n      }\n\n      if (this.step.iconClass) {\n        return `${this.step.iconClass}`;\n      }\n\n      if (this.shouldCheckValidity) {\n        return this.validationIconClasses;\n      }\n    }\n\n    get showIndicatorIcon() {\n      if (this.shouldCheckValidity) {\n        return true;\n      }\n\n      if (this.step.icon || this.step.iconClass) {\n        return true;\n      }\n\n      return false;\n    }\n\n    get showLabelIcon() {\n      if (this.shouldCheckValidity) {\n        if (this.type === 'label') {\n          return true;\n        }\n\n        if (this.step.icon || this.step.iconClass) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    get showLabelText() {\n      return this.type === 'label' || this.type === 'full';\n    }\n\n    get validationIconClasses() {\n      if (this.isStepValid) {\n        return this.successIcon ? `${this.successIcon}` : 'k-icon k-i-check';\n      } else {\n        return this.errorIcon ? `${this.errorIcon}` : 'k-icon k-i-warning';\n      }\n    }\n\n    get indicatorText() {\n      const text = this.step.text;\n      return text ? text : this.index + 1;\n    }\n\n    updateStepValidity() {\n      if (typeof this.step.isValid === 'boolean') {\n        return this.step.isValid;\n      }\n\n      if (typeof this.step.isValid === 'function') {\n        return this.step.isValid(this.index);\n      }\n\n      return undefined;\n    }\n\n    get showIndicator() {\n      return this.type === 'indicator' || this.type === 'full';\n    }\n\n    get showLabel() {\n      if (this.type === 'label' || this.type === 'full') {\n        return true;\n      }\n\n      return this.step.optional;\n    }\n\n    get optionalText() {\n      return this.localization.get('optional');\n    }\n\n    get transitionDuration() {\n      return this.service.owner.animationDuration;\n    }\n\n    _shouldCheckValidity() {\n      if (isPresent(this.step.validate)) {\n        if (typeof this.step.validate === 'boolean') {\n          return this.step.validate;\n        }\n\n        if (typeof this.step.validate === 'function') {\n          return this.step.validate(this.index);\n        }\n      }\n\n      return isPresent(this.step.isValid) && this.index < this.current;\n    }\n\n    handleValidityChecks() {\n      this.isStepValid = undefined;\n      this.shouldCheckValidity = this._shouldCheckValidity();\n\n      if (this.shouldCheckValidity) {\n        this.isStepValid = this.updateStepValidity();\n      }\n    }\n\n  }\n\n  StepperStepComponent.ɵfac = function StepperStepComponent_Factory(t) {\n    return new (t || StepperStepComponent)(i0.ɵɵdirectiveInject(StepperService), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  StepperStepComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StepperStepComponent,\n    selectors: [[\"\", \"kendoStepperStep\", \"\"]],\n    viewQuery: function StepperStepComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c23, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.stepLink = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function StepperStepComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-step-error\", ctx.errorStepClass)(\"k-step-success\", ctx.successStepClass);\n      }\n    },\n    inputs: {\n      step: \"step\",\n      index: \"index\",\n      current: \"current\",\n      type: \"type\",\n      successIcon: \"successIcon\",\n      errorIcon: \"errorIcon\",\n      indicatorTemplate: \"indicatorTemplate\",\n      labelTemplate: \"labelTemplate\",\n      stepTemplate: \"stepTemplate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c24,\n    decls: 4,\n    vars: 6,\n    consts: [[\"href\", \"#\", 1, \"k-step-link\", 3, \"focus\"], [\"stepLink\", \"\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-step-indicator\", \"aria-hidden\", \"true\", 3, \"transition-duration\", 4, \"ngIf\"], [\"class\", \"k-step-label\", 4, \"ngIf\"], [\"aria-hidden\", \"true\", 1, \"k-step-indicator\"], [\"class\", \"k-step-indicator-icon\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-step-indicator-text\", 4, \"ngIf\"], [1, \"k-step-indicator-icon\", 3, \"ngClass\"], [1, \"k-step-indicator-text\"], [1, \"k-step-label\"], [\"class\", \"k-step-text\", 4, \"ngIf\"], [\"aria-hidden\", \"true\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-step-label-optional\", 4, \"ngIf\"], [1, \"k-step-text\"], [\"aria-hidden\", \"true\", 3, \"ngClass\"], [1, \"k-step-label-optional\"]],\n    template: function StepperStepComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"a\", 0, 1);\n        i0.ɵɵlistener(\"focus\", function StepperStepComponent_Template_a_focus_0_listener() {\n          return ctx.onFocus();\n        });\n        i0.ɵɵtemplate(2, StepperStepComponent_2_Template, 1, 5, null, 2);\n        i0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_Template, 3, 2, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndexAttr)(\"title\", ctx.step.label)(\"aria-disabled\", ctx.step.disabled)(\"aria-current\", ctx.index === ctx.current ? \"step\" : null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.stepTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.stepTemplate);\n      }\n    },\n    directives: [i2.NgIf, i2.NgTemplateOutlet, i2.NgClass],\n    encapsulation: 2\n  });\n  return StepperStepComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet StepperListComponent = /*#__PURE__*/(() => {\n  class StepperListComponent {\n    constructor(renderer, ngZone, element) {\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.element = element;\n      this.listKeydown = new EventEmitter();\n      this.listClick = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.initDomEvents();\n    }\n\n    ngOnDestroy() {\n      if (this.domSubs) {\n        this.domSubs();\n      }\n    }\n\n    get maxStepWidth() {\n      return this.maxStepDimension('width');\n    }\n\n    get maxStepHeight() {\n      return this.maxStepDimension('height');\n    }\n\n    maxStepDimension(dimension) {\n      if (dimension === 'width' && this.orientation === 'vertical') {\n        return null;\n      }\n\n      if (dimension === 'height' && this.orientation === 'horizontal') {\n        return null;\n      }\n\n      return 100 / this.steps.length;\n    }\n\n    initDomEvents() {\n      if (!this.element) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        const nativeElement = this.element.nativeElement;\n        const clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));\n        const keydownSubscription = this.renderer.listen(nativeElement, 'keydown', e => {\n          if (hasClass(e.target, 'k-step-link')) {\n            this.listKeydown.emit(e);\n          }\n        });\n\n        this.domSubs = () => {\n          clickSubscription();\n          keydownSubscription();\n        };\n      });\n    }\n\n    clickHandler(e) {\n      e.preventDefault();\n      const stepIdx = this.getStepIndex(e.target);\n      const step = this.steps[stepIdx];\n\n      if (!step || step.disabled) {\n        return;\n      }\n\n      const eventArgs = {\n        stepIdx,\n        currentStep: this.currentStep,\n        linear: this.linear,\n        originalEvent: e\n      };\n      this.listClick.emit(eventArgs);\n    }\n\n    getStepIndex(target) {\n      const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);\n\n      if (step) {\n        return itemIndex(step, STEPPER_STEP_INDEX);\n      }\n    }\n\n  }\n\n  StepperListComponent.ɵfac = function StepperListComponent_Factory(t) {\n    return new (t || StepperListComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  StepperListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StepperListComponent,\n    selectors: [[\"\", \"kendoStepperList\", \"\"]],\n    inputs: {\n      linear: \"linear\",\n      stepType: \"stepType\",\n      orientation: \"orientation\",\n      currentStep: \"currentStep\",\n      steps: \"steps\",\n      successIcon: \"successIcon\",\n      errorIcon: \"errorIcon\",\n      indicatorTemplate: \"indicatorTemplate\",\n      labelTemplate: \"labelTemplate\",\n      stepTemplate: \"stepTemplate\"\n    },\n    outputs: {\n      listKeydown: \"listKeydown\",\n      listClick: \"listClick\"\n    },\n    attrs: _c26,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"kendoStepperStep\", \"\", 1, \"k-step\", 3, \"type\", \"step\", \"index\", \"current\", \"successIcon\", \"errorIcon\", \"indicatorTemplate\", \"labelTemplate\", \"stepTemplate\", \"ngClass\", \"ngStyle\"]],\n    template: function StepperListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, StepperListComponent_ng_container_0_Template, 2, 28, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.steps);\n      }\n    },\n    directives: [StepperStepComponent, i2.NgForOf, i2.NgClass, i2.NgStyle],\n    encapsulation: 2\n  });\n  return StepperListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet StepperMessages = /*#__PURE__*/(() => {\n  class StepperMessages extends ComponentMessages {}\n\n  StepperMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵStepperMessages_BaseFactory;\n    return function StepperMessages_Factory(t) {\n      return (ɵStepperMessages_BaseFactory || (ɵStepperMessages_BaseFactory = i0.ɵɵgetInheritedFactory(StepperMessages)))(t || StepperMessages);\n    };\n  }();\n\n  StepperMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StepperMessages,\n    selectors: [[\"kendo-stepper-messages-base\"]],\n    inputs: {\n      optional: \"optional\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return StepperMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedStepperMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedStepperMessagesDirective extends StepperMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedStepperMessagesDirective.ɵfac = function LocalizedStepperMessagesDirective_Factory(t) {\n    return new (t || LocalizedStepperMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedStepperMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedStepperMessagesDirective,\n    selectors: [[\"\", \"kendoStepperLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: StepperMessages,\n      useExisting: forwardRef(() => LocalizedStepperMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedStepperMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_ANIMATION_DURATION = 400;\n/**\n * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-stepper [steps]=\"steps\">\n *        </kendo-stepper>\n *    `\n * })\n * class AppComponent {\n *    public steps: Array<StepperStep> = [\n *      { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }\n *    ];\n * }\n * ```\n */\n\nlet StepperComponent = /*#__PURE__*/(() => {\n  class StepperComponent {\n    constructor(renderer, elem, localization, stepperService) {\n      this.renderer = renderer;\n      this.elem = elem;\n      this.localization = localization;\n      this.stepperService = stepperService;\n      this.hostClasses = true;\n      this.ariaRole = 'navigation';\n      this.displayStyle = 'grid';\n      /**\n       * Specifies the type of the steps in the Stepper.\n       *\n       * The possible values are:\n       * * (Default) `indicator`\n       * * `label`\n       * * `full`\n       */\n\n      this.stepType = 'indicator';\n      /**\n       * Specifies the linear flow of the Stepper.\n       *\n       * @default true\n       */\n\n      this.linear = true;\n      /**\n       * Specifies the orientation of the Stepper\n       * ([see example]({% slug orientation_stepper %})).\n       *\n       * The possible values are:\n       * * (Default) `horizontal`\n       * * `vertical`\n       */\n\n      this.orientation = 'horizontal';\n      /**\n       * Specifies the duration of the progress indicator animation in milliseconds. Defaults to `400ms`.\n       *\n       * The possible values are:\n       *  * Boolean\n       *    * (Default) `true`\n       *    * false\n       *  * Number\n       */\n\n      this.animation = true;\n      /**\n       * Fires when a step is about to be activated. This event is preventable.\n       */\n\n      this.activate = new EventEmitter();\n      /**\n       * Fires when the `currentStep` property of the component was updated.\n       * Used to provide a two-way binding for the `currentStep` property.\n       */\n\n      this.currentStepChange = new EventEmitter();\n      this._steps = [];\n      this.dynamicRTLSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n      this.stepperService.owner = this;\n    }\n\n    get linearClass() {\n      return this.linear;\n    }\n    /**\n     * The index of the current step.\n     */\n\n\n    set currentStep(value) {\n      this.stepperService.currentStep = value;\n    }\n\n    get currentStep() {\n      return this.stepperService.currentStep;\n    }\n    /**\n     * The collection of steps that will be rendered in the Stepper.\n     * ([see example]({% slug step_appearance_stepper %}))\n     */\n\n\n    set steps(steps) {\n      if (isPresent(steps) && steps.length > 0) {\n        this._steps = steps;\n      }\n    }\n\n    get steps() {\n      return this._steps;\n    }\n\n    ngOnInit() {\n      this.applyHostStyling();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.steps && !changes.steps.firstChange) {\n        this.applyHostStyling();\n      }\n\n      if (changes.orientation) {\n        this.resetHostStyling();\n        this.applyHostStyling();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps ([see example]({% slug step_validation_stepper %}#toc-triggering-the-validation)).\n     *\n     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.\n     */\n\n\n    validateSteps() {\n      this.stepperService.validateSteps();\n    }\n\n    applyHostStyling() {\n      const stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';\n      const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;\n      this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);\n    }\n\n    resetHostStyling() {\n      this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-columns');\n      this.renderer.removeStyle(this.elem.nativeElement, 'grid-template-rows');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get progressAnimation() {\n      return {\n        duration: this.animationDuration\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get animationDuration() {\n      if (typeof this.animation === 'number') {\n        return this.animation;\n      }\n\n      if (typeof this.animation === 'boolean' && this.animation) {\n        return DEFAULT_ANIMATION_DURATION;\n      }\n\n      return 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get stepsListStyling() {\n      if (this.orientation === 'horizontal') {\n        return {\n          'grid-column-start': 1,\n          'grid-column-end': -1\n        };\n      }\n\n      return {\n        'grid-row-start': 1,\n        'grid-row-end': -1\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get progressBarStyling() {\n      if (this.orientation === 'horizontal') {\n        return {\n          'grid-column-start': 2,\n          'grid-column-end': this.steps.length * 2\n        };\n      }\n\n      return {\n        'grid-row-start': 2,\n        'grid-row-end': this.steps.length * 2\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    onListKeydown(e) {\n      this.stepperService.keydown(e);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onListClick(e) {\n      if (e.stepIdx === e.currentStep) {\n        this.stepperService.focus(e.stepIdx);\n        return;\n      }\n\n      if (e.linear && this.stepperService.isPrevOrNextStep(e.stepIdx) === false) {\n        return;\n      }\n\n      this.stepperService.onActivate(e.stepIdx, e.originalEvent);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isHorizontal() {\n      return this.orientation === 'horizontal';\n    }\n\n  }\n\n  StepperComponent.ɵfac = function StepperComponent_Factory(t) {\n    return new (t || StepperComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(StepperService));\n  };\n\n  StepperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StepperComponent,\n    selectors: [[\"kendo-stepper\"]],\n    contentQueries: function StepperComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, StepperStepTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, StepperLabelTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, StepperIndicatorTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.stepTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function StepperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.ariaRole)(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n        i0.ɵɵclassProp(\"k-widget\", ctx.hostClasses)(\"k-stepper\", ctx.hostClasses)(\"k-stepper-linear\", ctx.linearClass);\n      }\n    },\n    inputs: {\n      stepType: \"stepType\",\n      linear: \"linear\",\n      orientation: \"orientation\",\n      currentStep: \"currentStep\",\n      steps: \"steps\",\n      successIcon: \"successIcon\",\n      errorIcon: \"errorIcon\",\n      animation: \"animation\"\n    },\n    outputs: {\n      activate: \"activate\",\n      currentStepChange: \"currentStepChange\"\n    },\n    exportAs: [\"kendoStepper\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, StepperService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.stepper'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 16,\n    consts: function () {\n      let i18n_27;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text for the optional segment of the step label\n         * @meaning kendo.stepper.optional\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2015_KENDO_ANGULAR_LAYOUT_JS_28 = goog.getMsg(\"Optional\");\n        i18n_27 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_LAYOUT_FESM2015_KENDO_ANGULAR_LAYOUT_JS_28;\n      } else {\n        i18n_27 = $localize`:kendo.stepper.optional|The text for the optional segment of the step label:Optional`;\n      }\n\n      return [[\"kendoStepperLocalizedMessages\", \"\", \"optional\", i18n_27], [\"kendoStepperList\", \"\", 1, \"k-step-list\", 3, \"stepType\", \"linear\", \"orientation\", \"steps\", \"currentStep\", \"successIcon\", \"errorIcon\", \"indicatorTemplate\", \"labelTemplate\", \"stepTemplate\", \"ngStyle\", \"listKeydown\", \"listClick\"], [3, \"animation\", \"max\", \"label\", \"orientation\", \"reverse\", \"value\", \"ngStyle\", 4, \"ngIf\"], [3, \"animation\", \"max\", \"label\", \"orientation\", \"reverse\", \"value\", \"ngStyle\"]];\n    },\n    template: function StepperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"ol\", 1);\n        i0.ɵɵlistener(\"listKeydown\", function StepperComponent_Template_ol_listKeydown_1_listener($event) {\n          return ctx.onListKeydown($event);\n        })(\"listClick\", function StepperComponent_Template_ol_listClick_1_listener($event) {\n          return ctx.onListClick($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, StepperComponent_kendo_progressbar_2_Template, 1, 8, \"kendo-progressbar\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-step-list-horizontal\", ctx.isHorizontal)(\"k-step-list-vertical\", !ctx.isHorizontal);\n        i0.ɵɵproperty(\"stepType\", ctx.stepType)(\"linear\", ctx.linear)(\"orientation\", ctx.orientation)(\"steps\", ctx.steps)(\"currentStep\", ctx.currentStep)(\"successIcon\", ctx.successIcon)(\"errorIcon\", ctx.errorIcon)(\"indicatorTemplate\", ctx.indicatorTemplate == null ? null : ctx.indicatorTemplate.templateRef)(\"labelTemplate\", ctx.labelTemplate == null ? null : ctx.labelTemplate.templateRef)(\"stepTemplate\", ctx.stepTemplate == null ? null : ctx.stepTemplate.templateRef)(\"ngStyle\", ctx.stepsListStyling);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.steps.length > 0);\n      }\n    },\n    directives: [StepperListComponent, i4.ProgressBarComponent, LocalizedStepperMessagesDirective, i2.NgStyle, i2.NgIf],\n    encapsulation: 2\n  });\n  return StepperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `activate` event of the Stepper.\n */\n\n\nclass StepperActivateEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_layout %})).\n */\n\n\nlet StepperCustomMessagesComponent = /*#__PURE__*/(() => {\n  class StepperCustomMessagesComponent extends StepperMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  StepperCustomMessagesComponent.ɵfac = function StepperCustomMessagesComponent_Factory(t) {\n    return new (t || StepperCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StepperCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StepperCustomMessagesComponent,\n    selectors: [[\"kendo-stepper-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: StepperMessages,\n      useExisting: forwardRef(() => StepperCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function StepperCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return StepperCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_ROUNDED = 'full';\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_THEME_COLOR = 'primary';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Displays images, icons or initials representing people or other entities.\n */\n\nlet AvatarComponent = /*#__PURE__*/(() => {\n  class AvatarComponent {\n    constructor(renderer, element) {\n      this.renderer = renderer;\n      this.element = element;\n      this.hostClass = true;\n      /**\n       * Sets a border to the avatar.\n       */\n\n      this.border = false;\n      this._themeColor = DEFAULT_THEME_COLOR;\n      this._size = DEFAULT_SIZE;\n      this._fillMode = DEFAULT_FILL_MODE;\n      this._rounded = DEFAULT_ROUNDED;\n      validatePackage(packageMetadata);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get borderClass() {\n      return this.border;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get flexBasis() {\n      return this.width;\n    }\n    /**\n     * Sets the shape for the avatar.\n     * @hidden\n     */\n\n\n    set shape(shape) {\n      this.rounded = mapShapeToRounded(shape);\n    }\n    /**\n     * Specifies the size of the avatar\n     * ([see example]({% slug appearance_avatar %}#toc-size)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      if (size !== this._size) {\n        const newSize = size ? size : DEFAULT_SIZE;\n        this.handleClasses('size', newSize);\n        this._size = newSize;\n      }\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Specifies the rounded styling of the avatar\n     * ([see example]({% slug appearance_avatar %}#toc-rounded-corners)).\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium`\n     * * `large`\n     * * `full` (Default)\n     * * `none`\n     */\n\n\n    set rounded(rounded) {\n      if (rounded !== this._rounded) {\n        const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n        this.handleClasses('rounded', newRounded);\n        this._rounded = newRounded;\n      }\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Specifies the theme color of the avatar.\n     * The theme color will be applied as background and border color, while also amending the text color accordingly.\n     *\n     * The possible values are:\n     * * `base`&mdash; Applies the base coloring value.\n     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.\n     * * `secondary`&mdash;Applies coloring based on secondary theme color.\n     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.\n     * * `info`&mdash;Applies coloring based on info theme color.\n     * * `success`&mdash; Applies coloring based on success theme color.\n     * * `warning`&mdash; Applies coloring based on warning theme color.\n     * * `error`&mdash; Applies coloring based on error theme color.\n     * * `dark`&mdash; Applies coloring based on dark theme color.\n     * * `light`&mdash; Applies coloring based on light theme color.\n     * * `inverse`&mdash; Applies coloring based on inverted theme color.\n     * * `none`&mdash; Removes the styling associated with the theme color.\n     */\n\n\n    set themeColor(themeColor) {\n      if (themeColor !== this._themeColor) {\n        const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;\n        this._themeColor = newThemeColor;\n        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n      }\n    }\n\n    get themeColor() {\n      return this._themeColor;\n    }\n    /**\n     * Specifies the appearance fill style of the avatar.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `outline`\n     * * `none`\n     */\n\n\n    set fillMode(fillMode) {\n      if (fillMode !== this.fillMode) {\n        const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n        this._fillMode = newFillMode;\n        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n      }\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Specifies the appearance fill style of the avatar.\n     * Deprecated, left for backward compatibility.\n     *\n     * @hidden\n     */\n\n\n    set fill(fillMode) {\n      this.fillMode = fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get avatarWidth() {\n      return this.width;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get avatarHeight() {\n      return this.height;\n    }\n\n    ngOnInit() {\n      this.verifyProperties();\n    }\n\n    ngAfterViewInit() {\n      const stylingInputs = ['size', 'rounded'];\n      stylingInputs.forEach(input => {\n        this.handleClasses(input, this[input]);\n      });\n      this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);\n    }\n    /**\n     * @hidden\n     */\n\n\n    iconClasses() {\n      if (this.icon) {\n        return `k-icon k-i-${this.icon}`;\n      }\n\n      if (this.iconClass) {\n        return `${this.iconClass}`;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get customAvatar() {\n      return !(this.imageSrc || this.initials || this.icon || this.iconClass);\n    }\n\n    verifyProperties() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];\n      const inputsLength = inputs.filter(value => value).length;\n\n      if (inputsLength > 1) {\n        throw new Error(`\n                Invalid property configuration given.\n                The kendo-avatar component can accept only one of:\n                icon, imageSrc or initials properties.\n            `);\n      }\n    }\n\n    handleClasses(styleType, value) {\n      const elem = this.element.nativeElement;\n      const classes = getStylingClasses('avatar', styleType, this[styleType], value);\n\n      if (classes.toRemove) {\n        this.renderer.removeClass(elem, classes.toRemove);\n      }\n\n      if (classes.toAdd) {\n        this.renderer.addClass(elem, classes.toAdd);\n      }\n    }\n\n    handleFillModeAndThemeColorClasses(fill, themeColor) {\n      const wrapperElement = this.element.nativeElement; // remove existing fill and theme color classes\n\n      const currentClasses = Array.from(wrapperElement.classList);\n      const classesToRemove = currentClasses.filter(cl => {\n        return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');\n      });\n      classesToRemove.forEach(cl => this.renderer.removeClass(wrapperElement, cl)); // add fill if needed\n\n      if (fill !== 'none') {\n        this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);\n      } // add theme color class if fill and theme color\n\n\n      if (fill !== 'none' && themeColor !== 'none') {\n        this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);\n      }\n    }\n\n  }\n\n  AvatarComponent.ɵfac = function AvatarComponent_Factory(t) {\n    return new (t || AvatarComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  AvatarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AvatarComponent,\n    selectors: [[\"kendo-avatar\"]],\n    hostVars: 10,\n    hostBindings: function AvatarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"flex-basis\", ctx.flexBasis)(\"width\", ctx.avatarWidth)(\"height\", ctx.avatarHeight);\n        i0.ɵɵclassProp(\"k-avatar\", ctx.hostClass)(\"k-avatar-bordered\", ctx.borderClass);\n      }\n    },\n    inputs: {\n      shape: \"shape\",\n      size: \"size\",\n      rounded: \"rounded\",\n      themeColor: \"themeColor\",\n      fillMode: \"fillMode\",\n      fill: \"fill\",\n      border: \"border\",\n      iconClass: \"iconClass\",\n      width: \"width\",\n      height: \"height\",\n      cssStyle: \"cssStyle\",\n      initials: \"initials\",\n      icon: \"icon\",\n      imageSrc: \"imageSrc\"\n    },\n    ngContentSelectors: _c9,\n    decls: 4,\n    vars: 4,\n    consts: [[4, \"ngIf\"], [1, \"k-avatar-image\"], [3, \"src\", \"ngStyle\"], [1, \"k-avatar-text\", 3, \"ngStyle\"], [1, \"k-avatar-icon\", 3, \"ngStyle\", \"ngClass\"]],\n    template: function AvatarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, AvatarComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, AvatarComponent_ng_container_1_Template, 3, 2, \"ng-container\", 0);\n        i0.ɵɵtemplate(2, AvatarComponent_ng_container_2_Template, 3, 2, \"ng-container\", 0);\n        i0.ɵɵtemplate(3, AvatarComponent_ng_container_3_Template, 2, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.customAvatar);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.imageSrc);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.initials);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon || ctx.iconClass);\n      }\n    },\n    directives: [i2.NgIf, i2.NgStyle, i2.NgClass],\n    encapsulation: 2\n  });\n  return AvatarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})\n */\n\n\nlet CardComponent = /*#__PURE__*/(() => {\n  class CardComponent {\n    constructor(localizationService) {\n      this.localizationService = localizationService;\n      this.hostClass = true;\n      /**\n       * Specifies the layout of the Card content.\n       *\n       * The possible values are:\n       * * (Default) `vertical`\n       * * `horizontal`\n       *\n       */\n\n      this.orientation = 'vertical';\n      /**\n       * Defines the width of the Card.\n       * Defaults to `285px`.\n       */\n\n      this.width = '285px';\n      this.rtl = false;\n      validatePackage(packageMetadata);\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n        this.direction = this.rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get widthStyle() {\n      return this.width;\n    }\n\n    get vertical() {\n      return this.orientation === 'vertical';\n    }\n\n    get horizontal() {\n      return this.orientation === 'horizontal';\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  CardComponent.ɵfac = function CardComponent_Factory(t) {\n    return new (t || CardComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  CardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardComponent,\n    selectors: [[\"kendo-card\"]],\n    hostVars: 11,\n    hostBindings: function CardComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"width\", ctx.widthStyle);\n        i0.ɵɵclassProp(\"k-widget\", ctx.hostClass)(\"k-card\", ctx.hostClass)(\"k-card-vertical\", ctx.vertical)(\"k-card-horizontal\", ctx.horizontal);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      width: \"width\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.card.component'\n    }])],\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function CardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the content in the Card header.\n */\n\n\nlet CardHeaderComponent = /*#__PURE__*/(() => {\n  class CardHeaderComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) {\n    return new (t || CardHeaderComponent)();\n  };\n\n  CardHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardHeaderComponent,\n    selectors: [[\"kendo-card-header\"]],\n    hostVars: 2,\n    hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-header\", ctx.hostClass);\n      }\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function CardHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the content in the Card body.\n */\n\n\nlet CardBodyComponent = /*#__PURE__*/(() => {\n  class CardBodyComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) {\n    return new (t || CardBodyComponent)();\n  };\n\n  CardBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardBodyComponent,\n    selectors: [[\"kendo-card-body\"]],\n    hostVars: 2,\n    hostBindings: function CardBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-body\", ctx.hostClass);\n      }\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function CardBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardBodyComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the content in the Card footer.\n */\n\n\nlet CardFooterComponent = /*#__PURE__*/(() => {\n  class CardFooterComponent {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) {\n    return new (t || CardFooterComponent)();\n  };\n\n  CardFooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardFooterComponent,\n    selectors: [[\"kendo-card-footer\"]],\n    hostVars: 2,\n    hostBindings: function CardFooterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-footer\", ctx.hostClass);\n      }\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function CardFooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return CardFooterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the action buttons of the Card.\n * * ([see example]({% slug actions_card %})).\n */\n\n\nlet CardActionsComponent = /*#__PURE__*/(() => {\n  class CardActionsComponent {\n    constructor() {\n      this.hostClass = true;\n      /**\n       * Specifies the layout of the Card action buttons.\n       *\n       * * The possible values are:\n       * * (Default) `horizontal`\n       * * `vertical`\n       *\n       */\n\n      this.orientation = 'horizontal';\n      /**\n       * Specifies the layout of the Card action buttons.\n       *\n       * The possible values are:\n       * * (Default) `start`\n       * * `center`\n       * * `end`\n       * * `stretched`\n       *\n       */\n\n      this.layout = 'start';\n      /**\n       * Fires when the user clicks an action button.\n       */\n\n      this.action = new EventEmitter();\n    }\n\n    get stretchedClass() {\n      return this.layout === 'stretched';\n    }\n\n    get startClass() {\n      return this.layout === 'start';\n    }\n\n    get endClass() {\n      return this.layout === 'end';\n    }\n\n    get centerClass() {\n      return this.layout === 'center';\n    }\n\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n    /**\n     * Allows the declarative specification of the Card actions.\n     */\n\n\n    set actions(value) {\n      if (Array.isArray(value)) {\n        this.actionsArray = value;\n      } else if (value instanceof TemplateRef) {\n        this.actionsTemplate = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(action) {\n      this.action.emit(action);\n    }\n\n  }\n\n  CardActionsComponent.ɵfac = function CardActionsComponent_Factory(t) {\n    return new (t || CardActionsComponent)();\n  };\n\n  CardActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CardActionsComponent,\n    selectors: [[\"kendo-card-actions\"]],\n    hostVars: 14,\n    hostBindings: function CardActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-actions\", ctx.hostClass)(\"k-card-actions-stretched\", ctx.stretchedClass)(\"k-card-actions-start\", ctx.startClass)(\"k-card-actions-end\", ctx.endClass)(\"k-card-actions-center\", ctx.centerClass)(\"k-card-actions-vertical\", ctx.verticalClass)(\"k-card-actions-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      layout: \"layout\",\n      actions: \"actions\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    ngContentSelectors: _c9,\n    decls: 3,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"type\", \"button\", \"class\", \"k-button\", 3, \"k-primary\", \"k-flat\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 1, \"k-button\", 3, \"click\"], [3, \"ngTemplateOutlet\"]],\n    template: function CardActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, CardActionsComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n        i0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(2, CardActionsComponent_2_Template, 1, 1, null, 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.actionsArray && !ctx.actionsTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsArray);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionsTemplate);\n      }\n    },\n    directives: [i2.NgIf, i2.NgForOf, i2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return CardActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies a separator in the content of the Card.\n */\n\n\nlet CardSeparatorDirective = /*#__PURE__*/(() => {\n  class CardSeparatorDirective {\n    constructor() {\n      this.hostClass = true;\n      /**\n       * Specifies the orientation of the Card separator.\n       *\n       * The possible values are:\n       * (Default) `horizontal`\n       * `vertical`\n       */\n\n      this.orientation = 'horizontal';\n    }\n\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n\n  }\n\n  CardSeparatorDirective.ɵfac = function CardSeparatorDirective_Factory(t) {\n    return new (t || CardSeparatorDirective)();\n  };\n\n  CardSeparatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardSeparatorDirective,\n    selectors: [[\"\", \"kendoCardSeparator\", \"\"]],\n    hostVars: 8,\n    hostBindings: function CardSeparatorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"color\", ctx.color);\n        i0.ɵɵclassProp(\"k-card-separator\", ctx.hostClass)(\"k-separator-vertical\", ctx.verticalClass)(\"k-separator-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      orientation: \"orientation\"\n    }\n  });\n  return CardSeparatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the text and styles for the title of the Card.\n */\n\n\nlet CardTitleDirective = /*#__PURE__*/(() => {\n  class CardTitleDirective {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardTitleDirective.ɵfac = function CardTitleDirective_Factory(t) {\n    return new (t || CardTitleDirective)();\n  };\n\n  CardTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardTitleDirective,\n    selectors: [[\"\", \"kendoCardTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-title\", ctx.hostClass);\n      }\n    }\n  });\n  return CardTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies the text and styles for the subtitle of the Card.\n */\n\n\nlet CardSubtitleDirective = /*#__PURE__*/(() => {\n  class CardSubtitleDirective {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardSubtitleDirective.ɵfac = function CardSubtitleDirective_Factory(t) {\n    return new (t || CardSubtitleDirective)();\n  };\n\n  CardSubtitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardSubtitleDirective,\n    selectors: [[\"\", \"kendoCardSubtitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-subtitle\", ctx.hostClass);\n      }\n    }\n  });\n  return CardSubtitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specifies any media that will be displayed and aligned in the Card.\n */\n\n\nlet CardMediaDirective = /*#__PURE__*/(() => {\n  class CardMediaDirective {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  CardMediaDirective.ɵfac = function CardMediaDirective_Factory(t) {\n    return new (t || CardMediaDirective)();\n  };\n\n  CardMediaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CardMediaDirective,\n    selectors: [[\"\", \"kendoCardMedia\", \"\"]],\n    hostVars: 2,\n    hostBindings: function CardMediaDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-card-media\", ctx.hostClass);\n      }\n    }\n  });\n  return CardMediaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The settings of the Card action buttons.\n */\n\n\nclass CardAction {}\n/**\n * Represents a template that defines the content of the ExpansionPanel title.\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoExpansionPanelTitleDirective` directive inside the `<kendo-expansionpanel>` tag.\n * ([see example]({% slug title_expansionpanel %}#toc-title-template)).\n */\n\n\nlet ExpansionPanelTitleDirective = /*#__PURE__*/(() => {\n  class ExpansionPanelTitleDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ExpansionPanelTitleDirective.ɵfac = function ExpansionPanelTitleDirective_Factory(t) {\n    return new (t || ExpansionPanelTitleDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  ExpansionPanelTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExpansionPanelTitleDirective,\n    selectors: [[\"\", \"kendoExpansionPanelTitleDirective\", \"\"]]\n  });\n  return ExpansionPanelTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction expand(duration, height) {\n  return [style({\n    overflow: 'hidden',\n    display: 'block',\n    height: 0\n  }), animate(`${duration}ms ease-in`, style({\n    height: `${height}`\n  }))];\n}\n/**\n * @hidden\n */\n\n\nfunction collapse(duration, height) {\n  return [style({\n    overflow: 'hidden',\n    height: `${height}`\n  }), animate(`${duration}ms ease-in`, style({\n    overflow: 'hidden',\n    height: 0\n  }))];\n}\n/**\n * Arguments for the `action` event of the ExpansionPanel.\n */\n\n\nclass ExpansionPanelActionEvent extends PreventableEvent$1 {\n  /**\n   * @hidden\n   */\n  constructor(args) {\n    super();\n    Object.assign(this, args);\n  }\n\n}\n\nconst DEFAULT_DURATION = 200;\nconst CONTENT_HIDDEN_CLASS = 'k-hidden';\n/**\n * Represents the [Kendo UI ExpansionPanel component for Angular]({% slug overview_expansionpanel %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-expansionpanel title=\"Chile\" subtitle=\"South America\">\n *              There are various theories about the origin of the word Chile.\n *        </kendo-expansionpanel>\n *    `\n * })\n * class AppComponent {}\n * ```\n */\n\nlet ExpansionPanelComponent = /*#__PURE__*/(() => {\n  class ExpansionPanelComponent {\n    constructor(renderer, hostElement, ngZone, localizationService, builder) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.ngZone = ngZone;\n      this.localizationService = localizationService;\n      this.builder = builder;\n      /**\n       * Specifies the primary text in the header of the ExpansionPanel\n       * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).\n       */\n\n      this.title = '';\n      /**\n       * Specifies the secondary text in the header of the ExpansionPanel, which is rendered next to the collapse/expand icon\n       * ([see example]({% slug title_expansionpanel %}#toc-title-and-subtitle)).\n       */\n\n      this.subtitle = '';\n      /**\n       * Specifies whether the ExpansionPanel is disabled. If disabled, the ExpansionPanel can be neither expanded nor collapsed\n       * ([see example]({% slug disabled_expansionpanel %})).\n       *\n       * @default false\n       */\n\n      this.disabled = false;\n      /**\n       * Specifies the animation settings of the ExpansionPanel\n       * ([see example]({% slug animations_expansionpanel %})).\n       *\n       * The possible values are:\n       * * Boolean\n       *    * (Default) `true` Numeric values represent duration. Default duration is 200ms.\n       *    * false\n       * * Number\n       */\n\n      this.animation = true;\n      /**\n       * Fires when the `expanded` property of the component is updated.\n       * Used to provide a two-way binding for the `expanded` property\n       * ([see example]({% slug overview_expansionpanel %}#toc-events)).\n       */\n\n      this.expandedChange = new EventEmitter();\n      /**\n       * Fires when the expanded state of the ExpansionPanel is about to change. This event is preventable\n       * ([see example]({% slug overview_expansionpanel %}#toc-events)).\n       */\n\n      this.action = new EventEmitter();\n      /**\n       * Fires when the ExpansionPanel is expanded. If there is animation it will fire when the animation is complete\n       * ([see example]({% slug overview_expansionpanel %}#toc-events)).\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the ExpansionPanel is collapsed. If there is animation it will fire when the animation is complete\n       * ([see example]({% slug overview_expansionpanel %}#toc-events)).\n       */\n\n      this.collapse = new EventEmitter();\n      this.hostClass = true;\n      this.tabindex = 0;\n      /**\n       * @hidden\n       */\n\n      this.focused = false;\n      this.animationEnd = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this._expanded = false;\n      validatePackage(packageMetadata);\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Specifies whether the ExpansionPanel is expanded. The property supports two-way binding.\n     * ([see example]({% slug interaction_expansionpanel %}#toc-setting-the-initial-state)).\n     *\n     * @default false\n     */\n\n\n    set expanded(value) {\n      if (value === this.expanded) {\n        return;\n      }\n\n      this._expanded = value;\n\n      if (this.expanded) {\n        this.removeContentHiddenClass();\n      } else {\n        this.addContentHiddenClass();\n      }\n    }\n\n    get expanded() {\n      return this._expanded;\n    }\n\n    get expandedClass() {\n      return this.expanded && !this.disabled;\n    }\n\n    get focusClass() {\n      return this.focused;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentBlur() {\n      if (this.focused) {\n        this.focused = false;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onComponentFocus() {\n      if (!this.focused) {\n        this.focused = true;\n      }\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.hostElement.nativeElement, 'title');\n      this.subscriptions = this.localizationService.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    ngAfterViewInit() {\n      this.initDomEvents();\n\n      if (!this.expanded) {\n        this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    initDomEvents() {\n      if (!this.hostElement) {\n        return;\n      }\n\n      if (!this.disabled) {\n        this.ngZone.runOutsideAngular(() => {\n          const nativeElement = this.hostElement.nativeElement;\n          this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', this.keyDownHandler.bind(this)));\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    keyDownHandler(ev) {\n      const isEnterOrSpace = ev.keyCode === Keys.Enter || ev.keyCode === Keys.Space;\n\n      if (!isEnterOrSpace) {\n        return;\n      }\n\n      if (hasClass(ev.target, 'k-expander')) {\n        ev.preventDefault();\n        this.ngZone.run(() => {\n          this.onHeaderAction();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHeaderClick(ev) {\n      if (!isFocusable(ev.target) && !this.disabled) {\n        this.onHeaderAction();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHeaderAction() {\n      this.focused = true;\n      const eventArgs = new ExpansionPanelActionEvent();\n      eventArgs.action = this.expanded ? 'collapse' : 'expand';\n      this.action.emit(eventArgs);\n\n      if (!eventArgs.isDefaultPrevented()) {\n        this.setExpanded(!this.expanded);\n\n        if (this.expanded) {\n          this.removeContentHiddenClass();\n        }\n\n        if (this.animation) {\n          this.animateContent();\n          return;\n        }\n\n        if (!this.expanded) {\n          this.addContentHiddenClass();\n        }\n\n        this.emitExpandCollapseEvent();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get indicatorClasses() {\n      if (this.expanded) {\n        return this.collapseIcon ? this.collapseIcon : `k-icon k-i-arrow-chevron-up`;\n      } else {\n        return this.expandIcon ? this.expandIcon : `k-icon k-i-arrow-chevron-down`;\n      }\n    }\n    /**\n     * Toggles the visibility of the ExpansionPanel\n     * ([see example]({% slug interaction_expansionpanel %}#toc-toggling-the-content)).\n     *\n     * @param expanded? - Boolean. Specifies, whether the ExpansionPanel will be expanded or collapsed.\n     */\n\n\n    toggle(expanded) {\n      const previous = this.expanded;\n      const current = isPresent(expanded) ? expanded : !previous;\n\n      if (current === previous) {\n        return;\n      }\n\n      this.setExpanded(current);\n\n      if (this.expanded) {\n        this.removeContentHiddenClass();\n      }\n\n      if (this.animation) {\n        this.animateContent();\n        return;\n      }\n\n      if (!this.expanded) {\n        this.addContentHiddenClass();\n      }\n\n      this.emitExpandCollapseEvent();\n    }\n\n    setExpanded(value) {\n      this._expanded = value;\n      this.expandedChange.emit(value);\n    }\n\n    animateContent() {\n      const duration = typeof this.animation === 'boolean' ? DEFAULT_DURATION : this.animation;\n      const contentHeight = getComputedStyle(this.content.nativeElement).height;\n      const animation = this.expanded ? expand(duration, contentHeight) : collapse(duration, contentHeight);\n      const player = this.createPlayer(animation, this.content.nativeElement);\n      this.animationEnd.pipe(take(1)).subscribe(() => {\n        if (!this.expanded) {\n          this.addContentHiddenClass();\n        }\n\n        this.emitExpandCollapseEvent();\n      });\n      player.play();\n    }\n\n    createPlayer(animation, animatedElement) {\n      const factory = this.builder.build(animation);\n      let player = factory.create(animatedElement);\n      player.onDone(() => {\n        if (player) {\n          this.animationEnd.emit();\n          player.destroy();\n          player = null;\n        }\n      });\n      return player;\n    }\n\n    emitExpandCollapseEvent() {\n      this[this.expanded ? 'expand' : 'collapse'].emit();\n    }\n\n    addContentHiddenClass() {\n      this.renderer.addClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n    }\n\n    removeContentHiddenClass() {\n      this.renderer.removeClass(this.content.nativeElement, CONTENT_HIDDEN_CLASS);\n    }\n\n  }\n\n  ExpansionPanelComponent.ɵfac = function ExpansionPanelComponent_Factory(t) {\n    return new (t || ExpansionPanelComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i1$2.AnimationBuilder));\n  };\n\n  ExpansionPanelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ExpansionPanelComponent,\n    selectors: [[\"kendo-expansionpanel\"]],\n    contentQueries: function ExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ExpansionPanelTitleDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);\n      }\n    },\n    viewQuery: function ExpansionPanelComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c29, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function ExpansionPanelComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function ExpansionPanelComponent_blur_HostBindingHandler() {\n          return ctx.onComponentBlur();\n        })(\"focus\", function ExpansionPanelComponent_focus_HostBindingHandler() {\n          return ctx.onComponentFocus();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.disabledClass)(\"dir\", ctx.direction)(\"tabindex\", ctx.tabindex);\n        i0.ɵɵclassProp(\"k-expander\", ctx.hostClass)(\"k-expanded\", ctx.expandedClass)(\"k-state-focus\", ctx.focusClass)(\"k-state-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      subtitle: \"subtitle\",\n      disabled: \"disabled\",\n      expanded: \"expanded\",\n      expandIcon: \"expandIcon\",\n      collapseIcon: \"collapseIcon\",\n      animation: \"animation\"\n    },\n    outputs: {\n      expandedChange: \"expandedChange\",\n      action: \"action\",\n      expand: \"expand\",\n      collapse: \"collapse\"\n    },\n    exportAs: [\"kendoExpansionPanel\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.expansionpanel'\n    }])],\n    ngContentSelectors: _c9,\n    decls: 9,\n    vars: 7,\n    consts: [[\"role\", \"button\", 3, \"click\"], [4, \"ngIf\"], [1, \"k-expander-indicator\"], [3, \"ngClass\"], [1, \"k-expander-content-wrapper\"], [\"content\", \"\"], [1, \"k-expander-content\"], [\"class\", \"k-expander-title\", 4, \"ngIf\"], [1, \"k-spacer\"], [\"class\", \"k-expander-sub-title\", 4, \"ngIf\"], [1, \"k-expander-title\"], [1, \"k-expander-sub-title\"], [3, \"ngTemplateOutlet\"]],\n    template: function ExpansionPanelComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"click\", function ExpansionPanelComponent_Template_div_click_0_listener($event) {\n          return ctx.onHeaderClick($event);\n        });\n        i0.ɵɵtemplate(1, ExpansionPanelComponent_ng_container_1_Template, 4, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, ExpansionPanelComponent_2_Template, 1, 1, null, 1);\n        i0.ɵɵelementStart(3, \"span\", 2);\n        i0.ɵɵelement(4, \"span\", 3);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(5, \"div\", 4, 5)(7, \"div\", 6);\n        i0.ɵɵprojection(8);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-expander-header\", true);\n        i0.ɵɵattribute(\"aria-expanded\", ctx.expanded && !ctx.disabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.titleTemplate);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", ctx.indicatorClasses);\n        i0.ɵɵadvance(3);\n        i0.ɵɵattribute(\"aria-hidden\", !ctx.expanded);\n      }\n    },\n    directives: [i2.NgIf, i2.NgTemplateOutlet, i2.NgClass],\n    encapsulation: 2\n  });\n  return ExpansionPanelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst normalizeValue = value => {\n  return value ? +value : undefined;\n};\n/**\n * @hidden\n */\n\n\nconst isRowItemPresent = items => {\n  return items.some(item => isPresent(item.row));\n};\n/**\n * @hidden\n */\n\n\nconst propsChanged = (initialProps, newProps) => {\n  for (let i = 0; i < initialProps.length; i++) {\n    if (initialProps[i] !== newProps[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @hidden\n *\n * Extracts the event target from the viewport coords. Required for touch devices\n * where the `event.target` of a `pointermove` event is always the initially dragged item.\n */\n\n\nconst getDropTarget = event => {\n  if (!(isDocumentAvailable() && isPresent(document.elementsFromPoint))) {\n    return [event.target];\n  }\n\n  return document.elementsFromPoint(event.clientX, event.clientY).filter(item => item.classList && (item.classList.contains('k-tilelayout-item') || item.classList.contains('k-layout-item-hint')));\n};\n/**\n * @hidden\n */\n\n\nconst setElementStyles = (renderer, elem, styles) => {\n  const props = Object.keys(styles);\n  props.forEach(p => {\n    renderer.setStyle(elem, p, styles[p]);\n  });\n};\n/**\n * @hidden\n */\n\n\nconst calculateCellFromPosition = (coordinates, tileLayoutElement, gap, cellSize, columns, rtl = false) => {\n  const tileLayoutRect = tileLayoutElement.getBoundingClientRect();\n  const totalRows = (tileLayoutRect.height - gap.rows) / (cellSize.height + gap.rows);\n  const distanceFromTop = coordinates.y - tileLayoutRect.y;\n  const distanceFromLeft = coordinates.x - tileLayoutRect.x;\n  const distanceFromRight = tileLayoutRect.right - coordinates.x;\n  const distanceToCellWidthRatio = Math.floor((rtl ? distanceFromRight : distanceFromLeft) / (gap.columns + cellSize.width));\n  const cappedColumnPosition = Math.min(distanceToCellWidthRatio + 1, columns);\n  const distanceToCellHeightRatio = Math.floor(distanceFromTop / (gap.rows + cellSize.height));\n  const cappedRowPosition = Math.min(distanceToCellHeightRatio + 1, totalRows);\n  const col = Math.max(cappedColumnPosition, 0);\n  const row = Math.max(cappedRowPosition, 0);\n  return {\n    row,\n    col\n  };\n};\n/**\n * @hidden\n */\n\n\nconst calculateOrderFromCell = (row, col, items, draggedItem, tileLayoutElement, gap, cellSize, columns) => {\n  let order = 0;\n  items.forEach(item => {\n    const rect = item.elem.nativeElement.getBoundingClientRect();\n    const start = calculateCellFromPosition({\n      x: rect.x,\n      y: rect.y\n    }, tileLayoutElement, gap, cellSize, columns);\n\n    if (item !== draggedItem && (start.row === row && start.col < col || start.row < row)) {\n      order++;\n    }\n  });\n  return order;\n};\n/**\n * @hidden\n */\n\n\nconst RESIZE_HANDLE_UNIDIRECTIONAL_SIZE = 9;\n/**\n * @hidden\n */\n\nconst RESIZE_HANDLE_BIDIRECTIONAL_SIZE = 25;\n/**\n * @hidden\n */\n\nconst RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP = 5;\n/**\n * @hidden\n */\n\nconst RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP = 18;\n/**\n * @hidden\n */\n\nconst DRAGGED_ZINDEX = 10;\n/**\n * @hidden\n */\n\nconst RESIZE_DIRECTIONS = ['ew', 'ns', 'nwse'];\n/**\n * @hidden\n */\n\nconst RTL_RESIZE_DIRECTIONS = ['ew', 'ns', 'nesw'];\n/**\n * @hidden\n */\n\nconst RESIZE_HANDLE_DIMENSIONS = {\n  // numeric values represent pixels\n  ew: {\n    width: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP\n  },\n  ns: {\n    height: RESIZE_HANDLE_UNIDIRECTIONAL_SIZE,\n    overlapY: RESIZE_HANDLE_UNIDIRECTIONAL_OVERLAP\n  },\n  nwse: {\n    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,\n    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP\n  },\n  nesw: {\n    width: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    height: RESIZE_HANDLE_BIDIRECTIONAL_SIZE,\n    overlapX: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP,\n    overlapY: RESIZE_HANDLE_BIDIRECTIONAL_OVERLAP\n  }\n};\n/**\n * @hidden\n */\n\nconst OVERLAP_THRESHOLD = 0.3;\n/**\n * @hidden\n */\n\nconst REVERSE_OVERLAP_THRESHOLD = -0.7;\n/**\n * @hidden\n */\n\nconst HINT_BORDERS_HEIGHT = 2;\n/**\n * Arguments for the `reorder` event. The event fires when the order or starting\n * positions of the items is changed via the UI. If you prevent the event, the change is canceled ([see example]({% slug reordering_tilelayout %}#toc-handling-the-reorder-event)).\n */\n\nclass TileLayoutReorderEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `reorder` event.\n   * @param item - The TileLayoutItem being reordered.\n   * @param items - The TileLayoutItem collection that holds the currently rendered items and their internal state.\n   * @param newIndex - The new order index of the reordered item used to determine its positioning relative to the other items.\n   * @param oldIndex - The initial order index of the reordered item used to determine its positioning relative to the other items.\n   * @param newCol - The new start column of the reordered item.\n   * @param oldCol - The initial start column of the reordered item.\n   * @param newRow - The new start row of the reordered item.\n   * @param oldRow - The initial start row of the reordered item.\n   * @hidden\n   */\n  constructor(item, items, newIndex, oldIndex, newCol, oldCol, newRow, oldRow) {\n    super();\n    this.item = item;\n    this.items = items;\n    this.newIndex = newIndex;\n    this.oldIndex = oldIndex;\n    this.newCol = newCol;\n    this.oldCol = oldCol;\n    this.newRow = newRow;\n    this.oldRow = oldRow;\n  }\n\n}\n/**\n * Arguments for the `resize` event. The `resize` event fires when any item size\n * is changed from the UI. If you cancel the event, the change is prevented ([see example]({% slug resizing_tilelayout %}#toc-handling-the-resize-event)).\n */\n\n\nclass TileLayoutResizeEvent extends PreventableEvent$1 {\n  /**\n   * Constructs the event arguments for the `resize` event.\n   * @param item - The TileLayoutItem being resized\n   * @param items - The TileLayoutItem collection\n   * @param newRowSpan - The new rowSpan of the resized item\n   * @param oldRowSpan - The initial rowSpan of the resized item\n   * @param newColSpan - The new colSpan of the resized item\n   * @param oldColSpan - The initial colSpan of the resized item\n   * @hidden\n   */\n  constructor(item, items, newRowSpan, oldRowSpan, newColSpan, oldColSpan) {\n    super();\n    this.item = item;\n    this.items = items;\n    this.newRowSpan = newRowSpan;\n    this.oldRowSpan = oldRowSpan;\n    this.newColSpan = newColSpan;\n    this.oldColSpan = oldColSpan;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet TileLayoutDraggingService = /*#__PURE__*/(() => {\n  class TileLayoutDraggingService {\n    constructor(zone, renderer, localization) {\n      this.zone = zone;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.reorderable = new BehaviorSubject(null);\n      this.resizable = new BehaviorSubject(null);\n      this.reorder = new Subject();\n      this.resize = new Subject();\n      this.lastDragCursorOffset = {\n        x: 0,\n        y: 0\n      };\n      this.localizationSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.rtl = rtl);\n    }\n\n    get colStart() {\n      return this.currentColStart;\n    }\n\n    get rowStart() {\n      return this.currentRowStart;\n    }\n\n    get itemWrapper() {\n      return this.draggedItemWrapper;\n    }\n\n    get order() {\n      return this.targetOrder;\n    }\n\n    ngOnDestroy() {\n      this.localizationSubscription.unsubscribe();\n    }\n\n    handlePress(originalEvent) {\n      const resizing = !!originalEvent.target.classList.contains('k-resize-handle');\n      const closestTile = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item'), this.tileLayoutSettings.tileLayoutElement);\n      const closestHeader = closestInScope(originalEvent.target, el => el.classList.contains('k-tilelayout-item-header'), this.tileLayoutSettings.tileLayoutElement);\n\n      if (!closestTile) {\n        return;\n      }\n\n      this.zone.run(() => {\n        this.draggedItemWrapper = closestTile;\n        this.draggedItem = this.tileLayoutSettings.items.find(item => item.order === +closestTile.style.order);\n      });\n      const reordering = !resizing && this.reorderable.getValue() && this.draggedItem.reorderable && closestHeader;\n      const focusableTarget = isFocusable(originalEvent.target);\n\n      if (!(reordering || resizing) || focusableTarget) {\n        return;\n      } else {\n        originalEvent.preventDefault();\n      }\n\n      this.zone.run(() => {\n        this.reordering = reordering;\n        this.resizing = resizing;\n      });\n      const tileRect = this.draggedItemWrapper.getBoundingClientRect();\n      this.zone.run(() => {\n        this.offset = {\n          top: originalEvent.clientY - tileRect.top,\n          left: originalEvent.clientX - tileRect.left,\n          x: tileRect.x,\n          y: tileRect.y,\n          width: tileRect.width,\n          height: tileRect.height\n        };\n        this.targetSize = {\n          rowSpan: this.draggedItem.rowSpan,\n          colSpan: this.draggedItem.colSpan\n        };\n        this.cellSize = {\n          width: (tileRect.width - (this.targetSize.colSpan - 1) * this.tileLayoutSettings.gap.columns) / this.targetSize.colSpan,\n          height: (tileRect.height - (this.targetSize.rowSpan - 1) * this.tileLayoutSettings.gap.rows) / this.targetSize.rowSpan\n        };\n        this.lastDragCursorOffset = {\n          x: originalEvent.clientX,\n          y: originalEvent.clientY\n        };\n      });\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        left: tileRect.left + window.pageXOffset + 'px',\n        top: tileRect.top + window.pageYOffset + 'px',\n        width: tileRect.width + 'px',\n        height: tileRect.height + 'px',\n        zIndex: DRAGGED_ZINDEX\n      });\n      setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n        display: 'flex',\n        height: tileRect.height - HINT_BORDERS_HEIGHT + 'px'\n      });\n      this.zone.run(() => this.targetOrder = this.draggedItem.order);\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        position: 'absolute'\n      });\n\n      if (this.reorderable.getValue() && !resizing) {\n        this.zone.run(() => {\n          this.currentColStart = this.draggedItem.colStart;\n          this.currentRowStart = this.draggedItem.rowStart;\n        });\n        const headerEl = this.draggedItem.elem.nativeElement.querySelector('.k-tilelayout-item-header');\n        this.renderer.addClass(headerEl, 'k-cursor-grabbing');\n      } else if (this.resizable && resizing) {\n        this.zone.run(() => {\n          this.startingPoint = {\n            top: originalEvent.clientY,\n            left: originalEvent.clientX\n          };\n          this.currentResizingColSpan = this.draggedItem.colSpan;\n          this.currentResizingRowSpan = this.draggedItem.rowSpan;\n\n          if (this.draggedItem.col) {\n            this.currentColStart = this.draggedItem.col.toString();\n          }\n\n          if (this.draggedItem.row) {\n            this.currentRowStart = this.draggedItem.row.toString();\n          }\n\n          this.direction = originalEvent.target.classList[1];\n        });\n      }\n    }\n\n    handleDrag(originalEvent) {\n      if (this.draggedItemWrapper) {\n        if (this.reordering) {\n          this.reorderItems(originalEvent);\n        } else if (this.resizing) {\n          this.resizeItem(originalEvent);\n        }\n\n        this.lastDragCursorOffset = {\n          x: originalEvent.clientX,\n          y: originalEvent.clientY\n        };\n      }\n    }\n\n    handleRelease(originalEvent) {\n      originalEvent.preventDefault();\n\n      if (this.reordering) {\n        const initialOrder = this.draggedItem.order;\n        const initialCol = this.draggedItem.col;\n        const initialRow = this.draggedItem.row;\n        const targetCol = normalizeValue(this.currentColStart);\n        const targetRow = normalizeValue(this.currentRowStart);\n\n        if (propsChanged([this.targetOrder, targetCol, targetRow], [initialOrder, initialCol, initialRow])) {\n          const reorderEvent = new TileLayoutReorderEvent(this.draggedItem, this.tileLayoutSettings.items, this.targetOrder, initialOrder, normalizeValue(this.currentColStart), initialCol, targetRow, initialRow);\n          this.reorder.next(reorderEvent);\n\n          if (!reorderEvent.isDefaultPrevented()) {\n            if (this.targetOrder > initialOrder) {\n              this.zone.run(() => {\n                for (let i = initialOrder + 1; i <= this.targetOrder; i++) {\n                  this.tileLayoutSettings.items.find(item => item.order === i).order = i - 1;\n                }\n              });\n            } else {\n              this.zone.run(() => {\n                for (let i = this.targetOrder; i < initialOrder; i++) {\n                  this.tileLayoutSettings.items.find(item => item.order === i).order = i + 1;\n                }\n              });\n            }\n\n            this.draggedItem.order = this.targetOrder;\n\n            if (this.draggedItem.col) {\n              this.draggedItem.col = +this.currentColStart;\n            }\n\n            if (this.draggedItem.row) {\n              this.draggedItem.row = +this.currentRowStart;\n            }\n          }\n        }\n\n        this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);\n        this.zone.run(() => this.cleanUp());\n      } else if (!this.reordering && this.resizing) {\n        const initialRowSpan = this.draggedItem.rowSpan;\n        const initialColSpan = this.draggedItem.colSpan;\n        const {\n          targetColSpan,\n          targetRowSpan\n        } = isRowItemPresent(this.tileLayoutSettings.items) ? this.targetSpan() : {\n          targetColSpan: this.currentResizingColSpan,\n          targetRowSpan: this.currentResizingRowSpan\n        };\n\n        if (propsChanged([initialRowSpan, initialColSpan], [targetRowSpan, targetColSpan])) {\n          const resizeEvent = new TileLayoutResizeEvent(this.draggedItem, this.tileLayoutSettings.items, targetRowSpan, initialRowSpan, targetColSpan, initialColSpan);\n          this.resize.next(resizeEvent);\n\n          if (!resizeEvent.isDefaultPrevented()) {\n            this.draggedItem.colSpan = this.currentResizingColSpan;\n            this.draggedItem.rowSpan = this.currentResizingRowSpan;\n          }\n        }\n\n        this.zone.run(() => this.cleanUp());\n      }\n    }\n\n    reorderItems(event) {\n      const targets = getDropTarget(event);\n      const closestTile = targets.find(t => t !== this.draggedItemWrapper);\n      let tileOrder = closestTile ? +closestTile.style.order : +this.draggedItemWrapper.style.order;\n\n      if (this.tileLayoutSettings.autoFlow !== 'none') {\n        const deltaX = event.clientX - this.lastDragCursorOffset.x;\n        const deltaY = event.clientY - this.lastDragCursorOffset.y;\n        const directionX = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : undefined;\n        const directionY = deltaY > 0 ? 'down' : deltaX < 0 ? 'up' : undefined;\n        const rect = this.draggedItemWrapper.getBoundingClientRect();\n        const horizontalGap = this.tileLayoutSettings.gap.columns;\n        const verticalGap = this.tileLayoutSettings.gap.rows;\n\n        if (directionX && this.draggedItem.col) {\n          const {\n            col\n          } = calculateCellFromPosition({\n            x: directionX === 'right' ? rect.right - horizontalGap : rect.left + horizontalGap,\n            y: event.clientY\n          }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n          const targetStartCol = this.getTargetCol(col, directionX);\n          this.currentColStart = targetStartCol.toString();\n        }\n\n        if (directionY && this.draggedItem.row) {\n          const {\n            row\n          } = calculateCellFromPosition({\n            x: event.clientX,\n            y: directionY === 'down' ? rect.bottom - verticalGap : rect.top + verticalGap\n          }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n          const targetStartRow = this.getTargetRow(row, directionY);\n          this.currentRowStart = targetStartRow.toString();\n        }\n      }\n\n      const hintBefore = tileOrder < this.targetOrder;\n      const hintAfter = tileOrder > this.targetOrder;\n      this.zone.run(() => this.targetOrder = tileOrder);\n\n      if (hintBefore) {\n        this.tileLayoutSettings.tileLayoutElement.insertBefore(this.tileLayoutSettings.hintElement, this.tileLayoutSettings.tileLayoutElement.firstChild);\n      } else if (hintAfter) {\n        this.tileLayoutSettings.tileLayoutElement.appendChild(this.tileLayoutSettings.hintElement);\n      }\n\n      setElementStyles(this.renderer, this.draggedItemWrapper, {\n        top: event.pageY - this.offset.top + 'px',\n        left: event.pageX - this.offset.left + 'px'\n      });\n    }\n\n    resizeItem(event) {\n      setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {\n        cursor: this.direction.split('k-cursor-')[1]\n      });\n      const currentWidth = this.rtl ? this.offset.width + (this.offset.x - event.clientX) : this.offset.width + (event.clientX - this.startingPoint.left);\n      const currentHeight = this.offset.height + (event.clientY - this.startingPoint.top);\n      const hintRect = this.tileLayoutSettings.hintElement.getBoundingClientRect();\n      const hintWidth = hintRect.width;\n      const hintHeight = hintRect.height;\n      const horizontalDragDirection = event.clientX - this.lastDragCursorOffset.x;\n      const verticalDragDirection = event.clientY - this.lastDragCursorOffset.y;\n      const startCol = this.draggedItem.col ? this.draggedItem.col : calculateCellFromPosition({\n        x: this.rtl ? hintRect.right : hintRect.x,\n        y: hintRect.y\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl).col;\n      const maxWidth = (this.tileLayoutSettings.columns - startCol) * (this.cellSize.width + this.tileLayoutSettings.gap.columns) + this.cellSize.width;\n\n      const resizeHorizontally = () => {\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          width: Math.min(Math.max(currentWidth, this.cellSize.width), maxWidth) + 'px'\n        });\n\n        if (this.rtl && currentWidth > this.cellSize.width) {\n          const totalWidth = this.tileLayoutSettings.columns * (this.cellSize.width + this.tileLayoutSettings.gap.columns);\n          const leftBoundary = this.tileLayoutSettings.tileLayoutElement.getBoundingClientRect().right - totalWidth;\n          setElementStyles(this.renderer, this.draggedItemWrapper, {\n            left: Math.max(event.clientX, leftBoundary) + 'px'\n          });\n        }\n\n        const deltaX = currentWidth - hintWidth;\n        const {\n          x,\n          y,\n          right\n        } = this.draggedItem.elem.nativeElement.getBoundingClientRect();\n        const {\n          col\n        } = calculateCellFromPosition({\n          x: this.rtl ? right : x,\n          y: y\n        }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n        const resizedColSpan = col + this.currentResizingColSpan;\n        const expandingCondition = this.rtl ? horizontalDragDirection < 0 : horizontalDragDirection > 0;\n        const shrinkingCondition = this.rtl ? horizontalDragDirection > 0 : horizontalDragDirection < 0;\n\n        if (deltaX > OVERLAP_THRESHOLD * this.cellSize.width && expandingCondition && resizedColSpan <= this.tileLayoutSettings.columns) {\n          this.currentResizingColSpan++;\n        } else if (this.currentResizingColSpan > 1 && shrinkingCondition && deltaX < REVERSE_OVERLAP_THRESHOLD * this.cellSize.width) {\n          this.currentResizingColSpan--;\n        }\n\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          gridColumnEnd: `span ${this.currentResizingColSpan}`\n        });\n      };\n\n      const resizeVertically = () => {\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          height: Math.max(currentHeight, this.cellSize.height) + 'px'\n        });\n        const deltaY = currentHeight - hintHeight;\n\n        if (deltaY > OVERLAP_THRESHOLD * this.cellSize.height && verticalDragDirection > 0) {\n          this.currentResizingRowSpan++;\n        } else if (this.currentResizingRowSpan > 1 && verticalDragDirection < 0 && deltaY < REVERSE_OVERLAP_THRESHOLD * this.cellSize.height) {\n          this.currentResizingRowSpan--;\n        }\n\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          gridRowEnd: `span ${this.currentResizingRowSpan}`\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          height: `${this.calculateHintHeight()}px`\n        });\n      };\n\n      if (this.direction.indexOf('ew') > -1) {\n        resizeHorizontally();\n      } else if (this.direction.indexOf('ns') > -1) {\n        resizeVertically();\n      } else {\n        resizeHorizontally();\n        resizeVertically();\n      }\n    }\n\n    cleanUp() {\n      this.targetOrder = this.currentResizingColSpan = this.currentColStart = this.currentResizingRowSpan = this.currentRowStart = undefined;\n      this.resizing = this.reordering = false;\n      this.direction = null;\n\n      if (this.draggedItemWrapper) {\n        const grabHandle = this.draggedItemWrapper.querySelector('.k-cursor-grab');\n\n        if (grabHandle) {\n          this.renderer.removeClass(grabHandle, 'k-cursor-grabbing');\n        }\n\n        setElementStyles(this.renderer, this.draggedItemWrapper, {\n          top: '',\n          left: '',\n          display: '',\n          width: '',\n          height: '',\n          zIndex: '',\n          position: ''\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.hintElement, {\n          display: 'none',\n          height: 'auto'\n        });\n        setElementStyles(this.renderer, this.tileLayoutSettings.tileLayoutElement, {\n          cursor: 'default'\n        });\n        this.draggedItemWrapper = this.offset = this.draggedItem = this.resizing = this.reordering = this.currentResizingColSpan = this.currentResizingRowSpan = this.startingPoint = undefined;\n        this.lastDragCursorOffset = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n\n    targetSpan() {\n      const itemRect = this.draggedItem.elem.nativeElement.getBoundingClientRect();\n      const startingCell = calculateCellFromPosition({\n        x: this.rtl ? itemRect.right : itemRect.x,\n        y: itemRect.y\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n      const targetEndCell = calculateCellFromPosition({\n        x: this.rtl ? itemRect.x + OVERLAP_THRESHOLD * this.cellSize.width : itemRect.right - OVERLAP_THRESHOLD * this.cellSize.width,\n        y: itemRect.bottom - OVERLAP_THRESHOLD * this.cellSize.height\n      }, this.tileLayoutSettings.tileLayoutElement, this.tileLayoutSettings.gap, this.cellSize, this.tileLayoutSettings.columns, this.rtl);\n      return {\n        targetColSpan: targetEndCell.col - startingCell.col + 1,\n        targetRowSpan: targetEndCell.row - startingCell.row + 1\n      };\n    }\n\n    getTargetCol(col, direction) {\n      if (this.rtl) {\n        return direction === 'left' ? col - this.draggedItem.colSpan + 1 : col;\n      }\n\n      return direction === 'right' ? col - this.draggedItem.colSpan + 1 : col;\n    }\n\n    getTargetRow(row, direction) {\n      return direction === 'down' ? row - this.draggedItem.rowSpan + 1 : row;\n    }\n\n    calculateHintHeight() {\n      const totalHintCellsHeight = this.currentResizingRowSpan * this.cellSize.height;\n      const totalHintGapsHeight = (this.currentResizingRowSpan - 1) * this.tileLayoutSettings.gap.rows;\n      const hintHeight = totalHintCellsHeight + totalHintGapsHeight - HINT_BORDERS_HEIGHT;\n      return hintHeight;\n    }\n\n  }\n\n  TileLayoutDraggingService.ɵfac = function TileLayoutDraggingService_Factory(t) {\n    return new (t || TileLayoutDraggingService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i1.LocalizationService));\n  };\n\n  TileLayoutDraggingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TileLayoutDraggingService,\n    factory: TileLayoutDraggingService.ɵfac\n  });\n  return TileLayoutDraggingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Holds the content of the header section of the TileLayoutItem component.\n * This is the area which can be dragged to reorder the items if reordering is enabled for this item.\n */\n\n\nlet TileLayoutItemHeaderComponent = /*#__PURE__*/(() => {\n  class TileLayoutItemHeaderComponent {\n    constructor(hostEl, renderer) {\n      this.hostEl = hostEl;\n      this.renderer = renderer;\n      this.hostClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set reorderable(value) {\n      const hostElement = this.hostEl.nativeElement;\n\n      if (value) {\n        this.renderer.addClass(hostElement, 'k-touch-action-none');\n        this.renderer.removeClass(hostElement, 'k-touch-action-auto');\n      } else {\n        this.renderer.addClass(hostElement, 'k-touch-action-auto');\n        this.renderer.removeClass(hostElement, 'k-touch-action-none');\n      }\n    }\n\n  }\n\n  TileLayoutItemHeaderComponent.ɵfac = function TileLayoutItemHeaderComponent_Factory(t) {\n    return new (t || TileLayoutItemHeaderComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  TileLayoutItemHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TileLayoutItemHeaderComponent,\n    selectors: [[\"kendo-tilelayout-item-header\"]],\n    hostVars: 4,\n    hostBindings: function TileLayoutItemHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-tilelayout-item-header\", ctx.hostClass)(\"k-card-header\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      reorderable: \"reorderable\"\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function TileLayoutItemHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TileLayoutItemHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TileLayoutResizeHandleDirective = /*#__PURE__*/(() => {\n  class TileLayoutResizeHandleDirective {\n    constructor(el, renderer) {\n      this.el = el;\n      this.renderer = renderer;\n    }\n\n    ngOnInit() {\n      this.sizeHandle();\n    }\n\n    setHorizontalPosition(element) {\n      this.renderer.setStyle(element, this.rtl ? 'left' : 'right', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapX + 'px');\n    }\n\n    setBottom(element) {\n      this.renderer.setStyle(element, 'bottom', -RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].overlapY + 'px');\n    }\n\n    sizeHandle() {\n      const element = this.el.nativeElement;\n      const handleWidth = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].width}px` : '100%';\n      const handleHeight = RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height ? `${RESIZE_HANDLE_DIMENSIONS[this.resizeDirection].height}px` : '100%';\n      this.renderer.setStyle(element, 'width', handleWidth);\n      this.renderer.setStyle(element, 'height', handleHeight);\n\n      if (this.resizeDirection === 'ew') {\n        this.setHorizontalPosition(element);\n      } else if (this.resizeDirection === 'ns') {\n        this.setBottom(element);\n      } else {\n        this.setHorizontalPosition(element);\n        this.setBottom(element);\n      }\n    }\n\n  }\n\n  TileLayoutResizeHandleDirective.ɵfac = function TileLayoutResizeHandleDirective_Factory(t) {\n    return new (t || TileLayoutResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  TileLayoutResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TileLayoutResizeHandleDirective,\n    selectors: [[\"\", \"kendoTileLayoutResizeHandle\", \"\"]],\n    inputs: {\n      resizeDirection: \"resizeDirection\",\n      rtl: \"rtl\"\n    }\n  });\n  return TileLayoutResizeHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a tile item within the TileLayoutComponent.\n */\n\n\nlet TileLayoutItemComponent = /*#__PURE__*/(() => {\n  class TileLayoutItemComponent {\n    constructor(elem, renderer, localization, draggingService) {\n      this.elem = elem;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.draggingService = draggingService;\n      /**\n       * Determines how many rows will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).\n       * @default 1\n       */\n\n      this.rowSpan = 1;\n      /**\n       * Determines how many columns will the tile item span ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).\n       * @default 1\n       */\n\n      this.colSpan = 1;\n      /**\n       * Determines whether the item can be reordered. By default all items are reorderable when the [reorderable]({% slug api_layout_tilelayoutcomponent %}#toc-reorderable) property of the TileLayoutComponent is set to `true` ([see example]({% slug reordering_tilelayout %}#toc-disable-reordering)).\n       *\n       * @default true\n       */\n\n      this.reorderable = true;\n      /**\n       * Determines whether the item can be resized. By default all items are resizable when the [resizable]({% slug api_layout_tilelayoutcomponent %}#resizable) property of the TileLayoutComponent is set to `true` ([see example]({% slug resizing_tilelayout %}#toc-disable-resizing)).\n       * @default true\n       */\n\n      this.resizable = true;\n      this.itemClass = true;\n      this.subs = new Subscription();\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.rtl = rtl;\n      }));\n      this.subs.add(this.draggingService.resizable.subscribe(resizable => {\n        this.resizeDirections = resizable && this.resizable ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;\n      }));\n    }\n    /**\n     * Determines the order of the tile items within the TileLayout.\n     * If not set, the items will receive increasing sequential order in accordance with\n     * their position in the DOM when initially rendered.\n     */\n\n\n    set order(value) {\n      this._order = value;\n      this.renderer.setStyle(this.elem.nativeElement, 'order', `${this._order}`);\n    }\n\n    get order() {\n      return this._order;\n    }\n\n    get colEnd() {\n      return `span ${this.colSpan}`;\n    }\n\n    get rowEnd() {\n      return `span ${this.rowSpan}`;\n    }\n\n    get colStart() {\n      return isPresent(this.col) ? this.col.toString() : undefined;\n    }\n\n    get rowStart() {\n      return isPresent(this.row) ? this.row.toString() : undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get reorderableHeader() {\n      return this.reorderable && this.draggingService.reorderable.getValue();\n    }\n\n    ngAfterViewInit() {\n      this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {\n        var _a;\n\n        this.toggleCursorClass(reorderable && this.reorderable);\n\n        if ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.first) {\n          this.headers.first.reorderable = reorderable && this.reorderable;\n        }\n      }));\n    }\n\n    ngOnChanges(changes) {\n      if (changes.reorderable && !changes.reorderable.firstChange) {\n        this.toggleCursorClass(changes.reorderable.currentValue && this.draggingService.reorderable.getValue());\n      }\n\n      if (changes.resizable) {\n        this.resizeDirections = this.resizable && this.draggingService.resizable.getValue() ? this.rtl ? RTL_RESIZE_DIRECTIONS : RESIZE_DIRECTIONS : undefined;\n      }\n    }\n\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n\n    toggleCursorClass(isReorderable) {\n      const headerEl = this.elem.nativeElement.querySelector('.k-tilelayout-item-header');\n\n      if (!headerEl) {\n        return;\n      }\n\n      if (isReorderable) {\n        this.renderer.addClass(headerEl, 'k-cursor-grab');\n      } else {\n        this.renderer.removeClass(headerEl, 'k-cursor-grab');\n      }\n    }\n\n  }\n\n  TileLayoutItemComponent.ɵfac = function TileLayoutItemComponent_Factory(t) {\n    return new (t || TileLayoutItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(TileLayoutDraggingService));\n  };\n\n  TileLayoutItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TileLayoutItemComponent,\n    selectors: [[\"kendo-tilelayout-item\"]],\n    contentQueries: function TileLayoutItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TileLayoutItemHeaderComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headers = _t);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function TileLayoutItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"grid-column-end\", ctx.colEnd)(\"grid-row-end\", ctx.rowEnd)(\"grid-column-start\", ctx.colStart)(\"grid-row-start\", ctx.rowStart);\n        i0.ɵɵclassProp(\"k-tilelayout-item\", ctx.itemClass)(\"k-card\", ctx.itemClass);\n      }\n    },\n    inputs: {\n      title: \"title\",\n      rowSpan: \"rowSpan\",\n      colSpan: \"colSpan\",\n      order: \"order\",\n      col: \"col\",\n      row: \"row\",\n      reorderable: \"reorderable\",\n      resizable: \"resizable\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"reorderable\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"reorderable\"], [1, \"k-card-title\"], [\"kendoTileLayoutResizeHandle\", \"\", 3, \"class\", \"rtl\", \"resizeDirection\", 4, \"ngFor\", \"ngForOf\"], [\"kendoTileLayoutResizeHandle\", \"\", 3, \"rtl\", \"resizeDirection\"]],\n    template: function TileLayoutItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, TileLayoutItemComponent_kendo_tilelayout_item_header_0_Template, 3, 2, \"kendo-tilelayout-item-header\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵtemplate(2, TileLayoutItemComponent_ng_container_2_Template, 2, 1, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.resizable);\n      }\n    },\n    directives: [TileLayoutItemHeaderComponent, i2.NgIf, i2.NgForOf, TileLayoutResizeHandleDirective],\n    encapsulation: 2\n  });\n  return TileLayoutItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst autoFlowClasses = {\n  column: 'k-grid-flow-col',\n  row: 'k-grid-flow-row',\n  'column-dense': 'k-grid-flow-col-dense',\n  'row-dense': 'k-grid-flow-row-dense'\n};\n/**\n * Represents the [Kendo UI TileLayout component for Angular]({% slug overview_tilelayout %})\n */\n\nlet TileLayoutComponent = /*#__PURE__*/(() => {\n  class TileLayoutComponent {\n    constructor(elem, renderer, localization, draggingService, zone) {\n      this.elem = elem;\n      this.renderer = renderer;\n      this.localization = localization;\n      this.draggingService = draggingService;\n      this.zone = zone;\n      /**\n       * Defines the number of columns ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).\n       * @default 1\n       */\n\n      this.columns = 1;\n      /**\n       * Determines the width of the columns. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).\n       * @default '1fr'\n       */\n\n      this.columnWidth = '1fr';\n      /**\n       * Determines whether the reordering functionality will be enabled ([see example]({% slug reordering_tilelayout %})).\n       * @default false\n       */\n\n      this.reorderable = false;\n      /**\n       * Determines whether the resizing functionality will be enabled ([see example]({% slug resizing_tilelayout %})).\n       * @default false\n       */\n\n      this.resizable = false;\n      /**\n       * Determines the height of the rows. Numeric values are treated as pixels ([see example]({% slug tiles_tilelayout %}#toc-tile-size-and-position)).\n       * @default '1fr'\n       */\n\n      this.rowHeight = '1fr';\n      /**\n       * Controls how the auto-placement algorithm works, specifying exactly how auto-placed items are flowed in the TileLayout ([see example]({% slug tiles_autoflow_tilelayout %})).\n       * For further reference, check the [grid-auto-flow CSS article](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow).\n       *\n       * The possible values are:\n       * * (Default) `column`\n       * * `row`\n       * * `row dense`\n       * * `column dense`\n       * * `none`\n       *\n       */\n\n      this.autoFlow = 'column';\n      /**\n       * Fires when the user completes the reordering of the item ([see example]({% slug overview_tilelayout %}#toc-events)).\n       * This event is preventable. If you cancel it, the item will not be reordered.\n       */\n\n      this.reorder = new EventEmitter();\n      /**\n       * Fires when the user completes the resizing of the item ([see example]({% slug overview_tilelayout %}#toc-events)).\n       * This event is preventable. If you cancel it, the item will not be resized.\n       */\n\n      this.resize = new EventEmitter();\n      this.hostClass = true;\n      this.subs = new Subscription();\n      this._gap = {\n        rows: 16,\n        columns: 16\n      };\n      validatePackage(packageMetadata);\n    }\n    /**\n     * The numeric values which determine the spacing in pixels between the layout items horizontally and vertically.\n     * Properties:\n     * * rows - the vertical spacing. Numeric values are treated as pixels. Defaults to `16`.\n     * * columns - the horizontal spacing. Numeric values are treated as pixels. Defaults to `16`.\n     *\n     * When bound to a single numeric value, it will be set to both `rows` and `columns` properties.\n     */\n\n\n    set gap(value) {\n      this._gap = typeof value === 'number' ? {\n        rows: value,\n        columns: value\n      } : Object.assign(this._gap, value);\n    }\n\n    get gap() {\n      return this._gap;\n    }\n\n    get gapStyle() {\n      return `${this.gap.rows}px ${this.gap.columns}px`;\n    }\n\n    get currentColStart() {\n      return this.draggingService.colStart;\n    }\n\n    get currentRowStart() {\n      return this.draggingService.rowStart;\n    }\n\n    get draggedItemWrapper() {\n      return this.draggingService.itemWrapper;\n    }\n\n    get targetOrder() {\n      return this.draggingService.order;\n    }\n\n    ngOnInit() {\n      this.applyColStyling();\n      this.applyRowStyling();\n      this.draggingService.reorderable.next(this.reorderable);\n      this.draggingService.resizable.next(this.resizable);\n\n      if (hasObservers(this.reorder)) {\n        this.subs.add(this.draggingService.reorder.subscribe(e => this.reorder.emit(e)));\n      }\n\n      if (hasObservers(this.resize)) {\n        this.subs.add(this.draggingService.resize.subscribe(e => this.resize.emit(e)));\n      }\n\n      this.subs.add(this.draggingService.reorderable.subscribe(reorderable => {\n        if (reorderable && !this.draggable) {\n          this.initializeDraggable();\n        }\n      }));\n      this.subs.add(this.draggingService.resizable.subscribe(resizable => {\n        if (resizable && !this.draggable) {\n          this.initializeDraggable();\n        }\n      }));\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      }));\n    }\n\n    ngAfterViewInit() {\n      this.draggingService.tileLayoutSettings = this.draggingServiceConfig();\n      this.applyAutoFlow(null, autoFlowClasses[this.autoFlow]);\n      this.items.changes.subscribe(() => {\n        this.setItemsOrder();\n        this.draggingService.tileLayoutSettings.items = this.items.toArray();\n      });\n    }\n\n    ngAfterContentInit() {\n      this.setItemsOrder();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.columns || changes.columnWidth) {\n        this.applyColStyling();\n      }\n\n      if (changes.rowHeight) {\n        this.applyRowStyling();\n      }\n\n      if (changes.reorderable) {\n        this.draggingService.reorderable.next(changes.reorderable.currentValue);\n      }\n\n      if (changes.resizable) {\n        this.draggingService.resizable.next(changes.resizable.currentValue);\n      }\n\n      if (changes.gap || changes.autoFlow || changes.columns) {\n        this.draggingService.tileLayoutSettings = this.draggingServiceConfig();\n\n        if (changes.autoFlow) {\n          this.applyAutoFlow(autoFlowClasses[changes.autoFlow.previousValue] || '', autoFlowClasses[changes.autoFlow.currentValue]);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.draggable) {\n        this.draggable.destroy();\n      }\n\n      this.subs.unsubscribe();\n    }\n\n    handlePress({\n      originalEvent\n    }) {\n      this.draggingService.handlePress(originalEvent);\n    }\n\n    handleDrag({\n      originalEvent\n    }) {\n      this.draggingService.handleDrag(originalEvent);\n    }\n\n    handleRelease({\n      originalEvent\n    }) {\n      this.draggingService.handleRelease(originalEvent);\n    }\n\n    applyColStyling() {\n      const colWidth = typeof this.columnWidth === 'number' ? `${this.columnWidth}px` : this.columnWidth;\n      const gridTemplateColumnsStyle = `repeat(${this.columns}, ${colWidth})`;\n      this.renderer.setStyle(this.elem.nativeElement, 'grid-template-columns', gridTemplateColumnsStyle);\n    }\n\n    applyRowStyling() {\n      const rowHeight = typeof this.rowHeight === 'number' ? `${this.rowHeight}px` : this.rowHeight;\n      const gridAutoRowsStyle = `${rowHeight}`;\n      this.renderer.setStyle(this.elem.nativeElement, 'grid-auto-rows', gridAutoRowsStyle);\n    }\n\n    draggingServiceConfig() {\n      return {\n        tileLayoutElement: this.elem ? this.elem.nativeElement : undefined,\n        hintElement: this.hint ? this.hint.nativeElement : undefined,\n        gap: this.gap,\n        columns: this.columns,\n        autoFlow: this.autoFlow,\n        items: this.items ? this.items.toArray() : []\n      };\n    }\n\n    initializeDraggable() {\n      this.draggable = new Draggable({\n        press: this.handlePress.bind(this),\n        drag: this.handleDrag.bind(this),\n        release: this.handleRelease.bind(this)\n      });\n      this.zone.runOutsideAngular(() => this.draggable.bindTo(this.elem.nativeElement));\n    }\n\n    applyAutoFlow(classToRemove, classToAdd) {\n      const element = this.elem.nativeElement;\n\n      if (classToRemove) {\n        this.renderer.removeClass(element, classToRemove);\n      }\n\n      if (this.autoFlow !== 'none' && isPresent(classToAdd)) {\n        this.renderer.addClass(element, classToAdd);\n      }\n    }\n\n    setItemsOrder() {\n      this.items.forEach((item, index) => {\n        if (!isPresent(item.order)) {\n          item.order = index;\n        }\n      });\n    }\n\n  }\n\n  TileLayoutComponent.ɵfac = function TileLayoutComponent_Factory(t) {\n    return new (t || TileLayoutComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(TileLayoutDraggingService), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  TileLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TileLayoutComponent,\n    selectors: [[\"kendo-tilelayout\"]],\n    contentQueries: function TileLayoutComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TileLayoutItemComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    viewQuery: function TileLayoutComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c30, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hint = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function TileLayoutComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵstyleProp(\"gap\", ctx.gapStyle)(\"padding\", ctx.gapStyle);\n        i0.ɵɵclassProp(\"k-widget\", ctx.hostClass)(\"k-tilelayout\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      columns: \"columns\",\n      columnWidth: \"columnWidth\",\n      gap: \"gap\",\n      reorderable: \"reorderable\",\n      resizable: \"resizable\",\n      rowHeight: \"rowHeight\",\n      autoFlow: \"autoFlow\"\n    },\n    outputs: {\n      reorder: \"reorder\",\n      resize: \"resize\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, TileLayoutDraggingService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.tilelayout.component'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 3,\n    vars: 14,\n    consts: [[1, \"k-layout-item-hint\", \"k-layout-item-hint-reorder\"], [\"hint\", \"\"]],\n    template: function TileLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelement(1, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"display\", \"none\")(\"order\", ctx.targetOrder)(\"grid-column-end\", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridColumnEnd)(\"grid-row-end\", ctx.draggedItemWrapper == null ? null : ctx.draggedItemWrapper.style.gridRowEnd)(\"grid-column-start\", ctx.currentColStart)(\"grid-row-start\", ctx.currentRowStart)(\"z-index\", \"1\");\n      }\n    },\n    encapsulation: 2\n  });\n  return TileLayoutComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Holds the main content of the TileLayoutItem component.\n */\n\n\nlet TileLayoutItemBodyComponent = /*#__PURE__*/(() => {\n  class TileLayoutItemBodyComponent {\n    constructor() {\n      this.hostClass = true;\n      this.minHeight = 0;\n    }\n\n  }\n\n  TileLayoutItemBodyComponent.ɵfac = function TileLayoutItemBodyComponent_Factory(t) {\n    return new (t || TileLayoutItemBodyComponent)();\n  };\n\n  TileLayoutItemBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TileLayoutItemBodyComponent,\n    selectors: [[\"kendo-tilelayout-item-body\"]],\n    hostVars: 6,\n    hostBindings: function TileLayoutItemBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"min-height\", ctx.minHeight);\n        i0.ɵɵclassProp(\"k-tilelayout-item-body\", ctx.hostClass)(\"k-card-body\", ctx.hostClass);\n      }\n    },\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function TileLayoutItemBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TileLayoutItemBodyComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$a = [AvatarComponent];\nconst declarations$a = [...exportedModules$a];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Avatar component.\n */\n\nlet AvatarModule = /*#__PURE__*/(() => {\n  class AvatarModule {}\n\n  AvatarModule.ɵfac = function AvatarModule_Factory(t) {\n    return new (t || AvatarModule)();\n  };\n\n  AvatarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AvatarModule\n  });\n  AvatarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return AvatarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst cardDirectives = [CardTitleDirective, CardSubtitleDirective, CardSeparatorDirective, CardMediaDirective];\nconst exportedModules$9 = [CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, ...cardDirectives];\nconst declarations$9 = [...exportedModules$9];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Card component.\n */\n\nlet CardModule = /*#__PURE__*/(() => {\n  class CardModule {}\n\n  CardModule.ɵfac = function CardModule_Factory(t) {\n    return new (t || CardModule)();\n  };\n\n  CardModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CardModule\n  });\n  CardModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return CardModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst templateDirectives$1 = [DrawerTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, DrawerItemTemplateDirective];\nconst exportedModules$8 = [DrawerComponent, DrawerContainerComponent, DrawerContentComponent, ...templateDirectives$1];\nconst declarations$8 = [DrawerItemComponent, DrawerListComponent, ...exportedModules$8];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Drawer component.\n */\n\nlet DrawerModule = /*#__PURE__*/(() => {\n  class DrawerModule {}\n\n  DrawerModule.ɵfac = function DrawerModule_Factory(t) {\n    return new (t || DrawerModule)();\n  };\n\n  DrawerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DrawerModule\n  });\n  DrawerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return DrawerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$7 = [ExpansionPanelComponent, ExpansionPanelTitleDirective];\nconst declarations$7 = [...exportedModules$7];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the ExpansionPanel component.\n */\n\nlet ExpansionPanelModule = /*#__PURE__*/(() => {\n  class ExpansionPanelModule {}\n\n  ExpansionPanelModule.ɵfac = function ExpansionPanelModule_Factory(t) {\n    return new (t || ExpansionPanelModule)();\n  };\n\n  ExpansionPanelModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ExpansionPanelModule\n  });\n  ExpansionPanelModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule]]\n  });\n  return ExpansionPanelModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$6 = [PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective];\nconst declarations$6 = [...exportedModules$6];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the PanelBar component.\n *\n * The module registers:\n * - `PanelBarComponent`&mdash;The `PanelBar` component class.\n * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.\n * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.\n * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.\n * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.\n */\n\nlet PanelBarModule = /*#__PURE__*/(() => {\n  class PanelBarModule {}\n\n  PanelBarModule.ɵfac = function PanelBarModule_Factory(t) {\n    return new (t || PanelBarModule)();\n  };\n\n  PanelBarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PanelBarModule\n  });\n  PanelBarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return PanelBarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$5 = [SplitterComponent, SplitterPaneComponent];\nconst declarations$5 = [SplitterBarComponent, ...exportedModules$5];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Splitter component.\n *\n * The module registers:\n * - `SplitterComponent`&mdash;The `Splitter` component class.\n * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.\n */\n\nlet SplitterModule = /*#__PURE__*/(() => {\n  class SplitterModule {}\n\n  SplitterModule.ɵfac = function SplitterModule_Factory(t) {\n    return new (t || SplitterModule)();\n  };\n\n  SplitterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SplitterModule\n  });\n  SplitterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, DraggableModule]]\n  });\n  return SplitterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst templateDirectives = [StepperStepTemplateDirective, StepperLabelTemplateDirective, StepperIndicatorTemplateDirective];\nconst exportedModules$4 = [StepperComponent, StepperCustomMessagesComponent, ...templateDirectives];\nconst declarations$4 = [StepperStepComponent, StepperListComponent, LocalizedStepperMessagesDirective, ...exportedModules$4];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Stepper component.\n */\n\nlet StepperModule = /*#__PURE__*/(() => {\n  class StepperModule {}\n\n  StepperModule.ɵfac = function StepperModule_Factory(t) {\n    return new (t || StepperModule)();\n  };\n\n  StepperModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StepperModule\n  });\n  StepperModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ProgressBarModule]]\n  });\n  return StepperModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$3 = [TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, TabComponent, TabStripCustomMessagesComponent, LocalizedTabStripMessagesDirective];\nconst declarations$3 = [...exportedModules$3, TabStripScrollableButtonComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TabStrip component.\n *\n * The module registers:\n * - `TabStripComponent`&mdash;The `TabStrip` component class.\n * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.\n * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.\n * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.\n */\n\nlet TabStripModule = /*#__PURE__*/(() => {\n  class TabStripModule {}\n\n  TabStripModule.ɵfac = function TabStripModule_Factory(t) {\n    return new (t || TabStripModule)();\n  };\n\n  TabStripModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TabStripModule\n  });\n  TabStripModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ResizeSensorModule]]\n  });\n  return TabStripModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$2 = [TileLayoutComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutItemBodyComponent, TileLayoutResizeHandleDirective];\nconst declarations$2 = [...exportedModules$2];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TileLayout component.\n *\n * The module registers:\n * - `TileLayoutComponent`&mdash;The `TileLayoutComponent` component class.\n * - `TileLayoutItemComponent`&mdash;The `TileLayoutItemComponent` component class.\n * - `TileLayoutItemHeaderComponent`&mdash;The `TileLayoutItemHeaderComponent` component class.\n * - `TileLayoutItemBodyComponent`&mdash;The `TileLayoutItemBodyComponent` component class.\n */\n\nlet TileLayoutModule = /*#__PURE__*/(() => {\n  class TileLayoutModule {}\n\n  TileLayoutModule.ɵfac = function TileLayoutModule_Factory(t) {\n    return new (t || TileLayoutModule)();\n  };\n\n  TileLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TileLayoutModule\n  });\n  TileLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return TileLayoutModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst VERTICAL_SUFFIX = {\n  top: 'start',\n  middle: 'center',\n  bottom: 'end',\n  stretch: 'stretch'\n};\n/**\n * @hidden\n */\n\nconst JUSTIFY_PREFIX = `k-justify-content`;\n/**\n * @hidden\n */\n\nconst GRID_JUSTIFY_PREFIX = `k-justify-items`;\n/**\n * @hidden\n */\n\nconst ALIGN_PREFIX = `k-align-items`;\n/**\n * @hidden\n */\n\nconst normalizeGap = gap => {\n  if (typeof gap === 'number' || typeof gap === 'string') {\n    return {\n      cols: gap,\n      rows: gap\n    };\n  } else {\n    let parsedGap = {};\n    parsedGap.rows = gap.rows ? gap.rows : 0;\n    parsedGap.cols = gap.cols ? gap.cols : 0;\n    return parsedGap;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst generateGapStyle = gap => {\n  if (gap.rows === gap.cols) {\n    return typeof gap.rows === 'number' ? `${gap.rows}px` : gap.rows;\n  } else {\n    let rowStyle = `${typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows}`;\n    let colStyle = `${typeof gap.cols === 'number' ? gap.cols + 'px' : gap.cols}`;\n    return `${rowStyle} ${colStyle}`;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst generateGridStyle = (items, itemType) => {\n  let styling = [];\n  items.forEach(item => {\n    if (typeof item === 'number') {\n      styling.push(`${item}px`);\n    } else if (typeof item === 'string') {\n      styling.push(item);\n    } else {\n      if (itemType === 'rows') {\n        const rowHeight = item.height;\n\n        if (rowHeight) {\n          styling.push(typeof rowHeight === 'number' ? `${rowHeight}px` : rowHeight);\n        } else {\n          styling.push('0px');\n        }\n      } else {\n        const colWidth = item.width;\n\n        if (colWidth) {\n          styling.push(typeof colWidth === 'number' ? `${colWidth}px` : colWidth);\n        } else {\n          styling.push('0px');\n        }\n      }\n    }\n  });\n  return styling;\n};\n/**\n * @hidden\n */\n\n\nconst validateGridLayoutRowsCols = arr => {\n  for (const el of arr) {\n    const isNum = typeof el === 'number';\n    const isStr = typeof el === 'string';\n    const isObject = typeof el === 'object' && el !== null;\n\n    if (!isNum && !isStr && !isObject) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Represents the [Kendo UI StackLayout component for Angular]({% slug overview_stacklayout %}).\n */\n\n\nlet StackLayoutComponent = /*#__PURE__*/(() => {\n  class StackLayoutComponent {\n    constructor(renderer, element, localization) {\n      this.renderer = renderer;\n      this.element = element;\n      this.localization = localization;\n      this.hostClass = true;\n      /**\n       * Specifies the gap between the inner StackLayout elements. The default value is `0`\n       * ([see example]({% slug layout_stacklayout %}#toc-gaps)).\n       */\n\n      this.gap = 0;\n      /**\n       * Specifies the orientation of the StackLayout\n       * ([see example]({% slug layout_stacklayout %}#toc-orientation)).\n       *\n       * The possible values are:\n       * (Default) `horizontal`\n       * `vertical`\n       */\n\n      this.orientation = 'horizontal';\n      this._align = {\n        horizontal: 'stretch',\n        vertical: 'stretch'\n      };\n      validatePackage(packageMetadata);\n    }\n\n    get horizontalClass() {\n      return this.orientation === 'horizontal';\n    }\n\n    get verticalClass() {\n      return this.orientation === 'vertical';\n    }\n\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * Specifies the horizontal and vertical alignment of the inner StackLayout elements\n     * ([see example]({% slug layout_stacklayout %}#toc-alignment)).\n     */\n\n\n    set align(align) {\n      this._align = Object.assign({}, this._align, align);\n      this.handleAlignClasses();\n    }\n\n    get align() {\n      return this._align;\n    }\n\n    ngAfterViewInit() {\n      this.handleAlignClasses();\n      this.setGap();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('gap', changes)) {\n        this.setGap();\n      }\n\n      if (isChanged('orientation', changes)) {\n        this.handleAlignClasses();\n      }\n    }\n\n    handleAlignClasses() {\n      const elem = this.element.nativeElement;\n\n      if (isPresent(this.justifyClass)) {\n        this.renderer.removeClass(elem, this.justifyClass);\n      }\n\n      if (isPresent(this.alignClass)) {\n        this.renderer.removeClass(elem, this.alignClass);\n      }\n\n      if (this.orientation === 'horizontal') {\n        this.justifyClass = `${JUSTIFY_PREFIX}-${this.align.horizontal}`;\n        this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n      } else {\n        this.justifyClass = `${JUSTIFY_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n        this.alignClass = `${ALIGN_PREFIX}-${this.align.horizontal}`;\n      }\n\n      this.renderer.addClass(elem, this.justifyClass);\n      this.renderer.addClass(elem, this.alignClass);\n    }\n\n    setGap() {\n      const parsedGap = isNumber(this.gap) ? `${this.gap}px` : this.gap;\n      this.renderer.setStyle(this.element.nativeElement, 'gap', parsedGap);\n    }\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n\n  }\n\n  StackLayoutComponent.ɵfac = function StackLayoutComponent_Factory(t) {\n    return new (t || StackLayoutComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  StackLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: StackLayoutComponent,\n    selectors: [[\"kendo-stacklayout\"]],\n    hostVars: 7,\n    hostBindings: function StackLayoutComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-stack-layout\", ctx.hostClass)(\"k-hstack\", ctx.horizontalClass)(\"k-vstack\", ctx.verticalClass);\n      }\n    },\n    inputs: {\n      align: \"align\",\n      gap: \"gap\",\n      orientation: \"orientation\"\n    },\n    exportAs: [\"kendoStackLayout\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.stacklayout'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function StackLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return StackLayoutComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules$1 = [StackLayoutComponent];\nconst declarations$1 = [...exportedModules$1];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the StackLayout component.\n */\n\nlet StackLayoutModule = /*#__PURE__*/(() => {\n  class StackLayoutModule {}\n\n  StackLayoutModule.ɵfac = function StackLayoutModule_Factory(t) {\n    return new (t || StackLayoutModule)();\n  };\n\n  StackLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StackLayoutModule\n  });\n  StackLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return StackLayoutModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI GridLayout component for Angular]({% slug overview_gridlayout %}).\n */\n\n\nlet GridLayoutComponent = /*#__PURE__*/(() => {\n  class GridLayoutComponent {\n    constructor(renderer, element, localization) {\n      this.renderer = renderer;\n      this.element = element;\n      this.localization = localization;\n      this.hostClass = true;\n      /**\n       * Specifies the gaps between the elements. The default value is `0`\n       * ([see example]({% slug layout_gridlayout %}#toc-gaps)).\n       */\n\n      this.gap = 0;\n      this._align = {\n        horizontal: 'stretch',\n        vertical: 'stretch'\n      };\n      validatePackage(packageMetadata);\n    }\n\n    get dir() {\n      return this.direction;\n    }\n    /**\n     * Specifies the horizontal and vertical alignment of the inner GridLayout elements\n     * ([see example]({% slug layout_gridlayout %}#toc-alignment)).\n     */\n\n\n    set align(align) {\n      this._align = Object.assign({}, this._align, align);\n      this.handleAlignClasses();\n    }\n\n    get align() {\n      return this._align;\n    }\n\n    ngAfterViewInit() {\n      this.handleAlignClasses();\n      this.handleGridTemplateStyling('rows');\n      this.handleGridTemplateStyling('cols');\n      this.setGap();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('gap', changes)) {\n        this.setGap();\n      }\n\n      if (isChanged('rows', changes)) {\n        this.handleGridTemplateStyling('rows');\n      }\n\n      if (isChanged('cols', changes)) {\n        this.handleGridTemplateStyling('cols');\n      }\n    }\n\n    handleAlignClasses() {\n      const elem = this.element.nativeElement;\n\n      if (isPresent(this.justifyClass)) {\n        this.renderer.removeClass(elem, this.justifyClass);\n      }\n\n      if (isPresent(this.alignClass)) {\n        this.renderer.removeClass(elem, this.alignClass);\n      }\n\n      this.justifyClass = `${GRID_JUSTIFY_PREFIX}-${this.align.horizontal}`;\n      this.alignClass = `${ALIGN_PREFIX}-${VERTICAL_SUFFIX[this.align.vertical]}`;\n      this.renderer.addClass(elem, this.justifyClass);\n      this.renderer.addClass(elem, this.alignClass);\n    }\n\n    setGap() {\n      let parsedGap = normalizeGap(this.gap);\n      let gapStyle = generateGapStyle(parsedGap);\n      this.renderer.setStyle(this.element.nativeElement, 'gap', gapStyle);\n    }\n\n    handleGridTemplateStyling(type) {\n      if (!isPresent(this[type])) {\n        return;\n      }\n\n      const isValid = validateGridLayoutRowsCols(this[type]);\n\n      if (!isValid && isDevMode()) {\n        const valueType = type === 'rows' ? 'GridLayoutRowSize' : 'GridLayoutColSize';\n        throw new Error(`The provided ${type} value contains invalid elements. The array supports values of type number, string or ${valueType}.`);\n      }\n\n      const gridTemplateStyle = type === 'rows' ? 'grid-template-rows' : 'grid-template-columns';\n      const gridStyle = generateGridStyle(this[type], type);\n      this.renderer.setStyle(this.element.nativeElement, gridTemplateStyle, gridStyle.join(' '));\n    }\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n\n  }\n\n  GridLayoutComponent.ɵfac = function GridLayoutComponent_Factory(t) {\n    return new (t || GridLayoutComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  GridLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GridLayoutComponent,\n    selectors: [[\"kendo-gridlayout\"]],\n    hostVars: 3,\n    hostBindings: function GridLayoutComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-grid-layout\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      rows: \"rows\",\n      cols: \"cols\",\n      gap: \"gap\",\n      align: \"align\"\n    },\n    exportAs: [\"kendoGridLayout\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.gridlayout'\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function GridLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return GridLayoutComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GridLayoutItemComponent = /*#__PURE__*/(() => {\n  class GridLayoutItemComponent {\n    constructor(renderer, element) {\n      this.renderer = renderer;\n      this.element = element;\n    }\n\n    ngOnInit() {\n      this.setItemStyle();\n    }\n\n    ngOnChanges() {\n      this.setItemStyle();\n    }\n\n    setItemStyle() {\n      const row = this.row || 'auto';\n      const col = this.col || 'auto';\n      const rowSpan = this.rowSpan ? `span ${this.rowSpan}` : 'auto';\n      const colSpan = this.colSpan ? `span ${this.colSpan}` : 'auto';\n      const gridAreaStyle = `${row} / ${col} / ${rowSpan} / ${colSpan}`;\n      this.renderer.setStyle(this.element.nativeElement, 'grid-area', gridAreaStyle);\n    }\n\n  }\n\n  GridLayoutItemComponent.ɵfac = function GridLayoutItemComponent_Factory(t) {\n    return new (t || GridLayoutItemComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  GridLayoutItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GridLayoutItemComponent,\n    selectors: [[\"kendo-gridlayout-item\"]],\n    inputs: {\n      row: \"row\",\n      col: \"col\",\n      rowSpan: \"rowSpan\",\n      colSpan: \"colSpan\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 1,\n    vars: 0,\n    template: function GridLayoutItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return GridLayoutItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst exportedModules = [GridLayoutComponent, GridLayoutItemComponent];\nconst declarations = [...exportedModules];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the GridLayout component.\n */\n\nlet GridLayoutModule = /*#__PURE__*/(() => {\n  class GridLayoutModule {}\n\n  GridLayoutModule.ɵfac = function GridLayoutModule_Factory(t) {\n    return new (t || GridLayoutModule)();\n  };\n\n  GridLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GridLayoutModule\n  });\n  GridLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return GridLayoutModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Layout components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Layout module\n * import { LayoutModule } from '@progress/kendo-angular-layout';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, LayoutModule], // import Layout module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet LayoutModule = /*#__PURE__*/(() => {\n  class LayoutModule {}\n\n  LayoutModule.ɵfac = function LayoutModule_Factory(t) {\n    return new (t || LayoutModule)();\n  };\n\n  LayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LayoutModule\n  });\n  LayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [AvatarModule, CardModule, DrawerModule, PanelBarModule, ExpansionPanelModule, SplitterModule, StepperModule, TabStripModule, TileLayoutModule, StackLayoutModule, GridLayoutModule]\n  });\n  return LayoutModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AvatarComponent, AvatarModule, CardAction, CardActionsComponent, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardMediaDirective, CardModule, CardSeparatorDirective, CardSubtitleDirective, CardTitleDirective, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerFooterTemplateDirective, DrawerHeaderTemplateDirective, DrawerItemTemplateDirective, DrawerModule, DrawerSelectEvent, DrawerTemplateDirective, ExpansionPanelActionEvent, ExpansionPanelComponent, ExpansionPanelModule, ExpansionPanelTitleDirective, GridLayoutComponent, GridLayoutItemComponent, GridLayoutModule, LayoutModule, LocalizedStepperMessagesDirective, LocalizedTabStripMessagesDirective, PanelBarCollapseEvent, PanelBarComponent, PanelBarContentDirective, PanelBarExpandEvent, PanelBarExpandMode, PanelBarItemComponent, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarModule, PanelBarSelectEvent, PanelBarStateChangeEvent, SelectEvent, SplitterComponent, SplitterModule, SplitterPaneComponent, StackLayoutComponent, StackLayoutModule, StepperActivateEvent, StepperComponent, StepperCustomMessagesComponent, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperModule, StepperStepTemplateDirective, TabCloseEvent, TabComponent, TabContentDirective, TabStripComponent, TabStripCustomMessagesComponent, TabStripModule, TabStripTabComponent, TabTitleDirective, TileLayoutComponent, TileLayoutItemBodyComponent, TileLayoutItemComponent, TileLayoutItemHeaderComponent, TileLayoutModule, TileLayoutReorderEvent, TileLayoutResizeEvent, TileLayoutResizeHandleDirective };","map":null,"metadata":{},"sourceType":"module"}