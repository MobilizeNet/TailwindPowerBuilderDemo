{"ast":null,"code":"import { geometry as g, throttle } from '@progress/kendo-drawing';\nimport { addClass, setDefaultOptions, valueOrDefault, defined, mousewheelDelta, limitValue, deepExtend, elementOffset, isArray, round } from '../common';\nimport { EPSG3857 } from './crs';\nimport { Attribution } from './attribution';\nimport { Navigator } from './navigator';\nimport { ZoomControl } from './zoom';\nimport { Location } from './location';\nimport { Extent } from './extent';\nimport { Tooltip } from './tooltip/tooltip';\nimport { TileLayer } from './layers/tile';\nimport { BubbleLayer } from './layers/bubble';\nimport { ShapeLayer } from './layers/shape';\nimport { MarkerLayer } from './layers/marker';\nimport { removeChildren, setDefaultEvents, proxy, now, on, off, getSupportedFeatures, convertToHtml, renderPos } from './utils';\nimport { Scroller } from './scroller/scroller';\nimport { Observable } from './scroller/observable';\nimport MapService from './../services/map-service';\nimport { CENTER_CHANGE, INIT, ZOOM_CHANGE } from './constants';\nlet math = Math,\n    min = math.min,\n    pow = math.pow,\n    Point = g.Point,\n    MARKER = \"marker\",\n    LOCATION = \"location\",\n    FRICTION = 0.9,\n    FRICTION_MOBILE = 0.93,\n    MOUSEWHEEL = 'wheel',\n    MOUSEWHEEL_THROTTLE = 50,\n    VELOCITY_MULTIPLIER = 5,\n    DEFAULT_ZOOM_RATE = 1;\nconst layersMap = {\n  bubble: BubbleLayer,\n  shape: ShapeLayer,\n  tile: TileLayer,\n  [MARKER]: MarkerLayer\n};\n\nclass Map extends Observable {\n  constructor(element, options = {}, themeOptions = {}, context = {}) {\n    super();\n\n    this._init(element, options, themeOptions, context);\n  }\n\n  destroy() {\n    this.scroller.destroy();\n\n    if (this._tooltip) {\n      this._tooltip.destroy();\n    }\n\n    if (this.navigator) {\n      this.navigator.destroy();\n    }\n\n    if (this.attribution) {\n      this.attribution.destroy();\n    }\n\n    if (this.zoomControl) {\n      this.zoomControl.destroy();\n    }\n\n    if (isArray(this.markers)) {\n      this.markers.forEach(markerLayer => {\n        markerLayer.destroy();\n      });\n    } else {\n      this.markers.destroy();\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      this.layers[i].destroy();\n    }\n\n    off(this.element, MOUSEWHEEL, this._mousewheelHandler);\n    super.destroy();\n  }\n\n  _init(element, options = {}, themeOptions = {}, context = {}) {\n    this.support = getSupportedFeatures();\n    this.context = context;\n    this.initObserver(context);\n    this.initServices(context);\n\n    this._notifyObserver(INIT);\n\n    this._initOptions(options);\n\n    this._setEvents(options);\n\n    this.crs = new EPSG3857();\n\n    this._initElement(element);\n\n    this._viewOrigin = this._getOrigin();\n    this._tooltip = this._createTooltip();\n\n    this._initScroller();\n\n    this._initMarkers();\n\n    this._initControls();\n\n    this._initLayers();\n\n    this._reset();\n\n    const mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);\n\n    this._mousewheelHandler = e => {\n      e.preventDefault();\n      mousewheelThrottled(e);\n    };\n\n    on(this.element, MOUSEWHEEL, this._mousewheelHandler);\n  }\n\n  _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  }\n\n  _initElement(element) {\n    this.element = element;\n    addClass(element, \"k-map\");\n    element.style.position = \"relative\";\n    element.setAttribute(\"data-role\", \"map\");\n    removeChildren(element);\n    const div = convertToHtml(\"<div />\");\n    this.element.appendChild(div);\n  }\n\n  initServices(context = {}) {\n    this.widgetService = new MapService(this, context);\n  }\n\n  initObserver(context = {}) {\n    this.observers = [];\n    this.addObserver(context.observer);\n  }\n\n  addObserver(observer) {\n    if (observer) {\n      this.observers.push(observer);\n    }\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  requiresHandlers(eventNames) {\n    const observers = this.observers;\n\n    for (let idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].requiresHandlers(eventNames)) {\n        return true;\n      }\n    }\n  }\n\n  trigger(name, args = {}) {\n    args.sender = this;\n    const observers = this.observers;\n    let isDefaultPrevented = false;\n\n    for (let idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n\n    if (!isDefaultPrevented) {\n      super.trigger(name, args);\n    }\n\n    return isDefaultPrevented;\n  }\n\n  _notifyObserver(name, args = {}) {\n    args.sender = this;\n    const observers = this.observers;\n    let isDefaultPrevented = false;\n\n    for (let idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n\n    return isDefaultPrevented;\n  }\n\n  zoom(level) {\n    let options = this.options;\n    let result;\n\n    if (defined(level)) {\n      const zoomLevel = math.round(limitValue(level, options.minZoom, options.maxZoom));\n\n      if (options.zoom !== zoomLevel) {\n        options.zoom = zoomLevel;\n        this.widgetService.notify(ZOOM_CHANGE, {\n          zoom: options.zoom\n        });\n\n        this._reset();\n      }\n\n      result = this;\n    } else {\n      result = options.zoom;\n    }\n\n    return result;\n  }\n\n  center(center) {\n    let result;\n\n    if (center) {\n      const current = Location.create(center);\n      const previous = Location.create(this.options.center);\n\n      if (!current.equals(previous)) {\n        this.options.center = current.toArray();\n        this.widgetService.notify(CENTER_CHANGE, {\n          center: this.options.center\n        });\n\n        this._reset();\n      }\n\n      result = this;\n    } else {\n      result = Location.create(this.options.center);\n    }\n\n    return result;\n  }\n\n  extent(extent) {\n    let result;\n\n    if (extent) {\n      this._setExtent(extent);\n\n      result = this;\n    } else {\n      result = this._getExtent();\n    }\n\n    return result;\n  }\n\n  setOptions(options = {}) {\n    const element = this.element;\n    this.destroy();\n    removeChildren(element);\n\n    this._init(element, options, {}, this.context);\n\n    this._reset();\n  }\n\n  locationToLayer(location, zoom) {\n    let clamp = !this.options.wraparound;\n    const locationObject = Location.create(location);\n    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);\n  }\n\n  layerToLocation(point, zoom) {\n    let clamp = !this.options.wraparound;\n    const pointObject = Point.create(point);\n    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);\n  }\n\n  locationToView(location) {\n    const locationObject = Location.create(location);\n    let origin = this.locationToLayer(this._viewOrigin);\n    let point = this.locationToLayer(locationObject);\n    return point.translateWith(origin.scale(-1));\n  }\n\n  viewToLocation(point, zoom) {\n    const origin = this.locationToLayer(this._getOrigin(), zoom);\n    const pointObject = Point.create(point);\n    const pointResult = pointObject.clone().translateWith(origin);\n    return this.layerToLocation(pointResult, zoom);\n  }\n\n  eventOffset(e) {\n    let x;\n    let y;\n    let offset = elementOffset(this.element);\n\n    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {\n      x = e.x[LOCATION] - offset.left;\n      y = e.y[LOCATION] - offset.top;\n    } else {\n      let event = e.originalEvent || e;\n      x = valueOrDefault(event.pageX, event.clientX) - offset.left;\n      y = valueOrDefault(event.pageY, event.clientY) - offset.top;\n    }\n\n    const point = new g.Point(x, y);\n    return point;\n  }\n\n  eventToView(e) {\n    let cursor = this.eventOffset(e);\n    return this.locationToView(this.viewToLocation(cursor));\n  }\n\n  eventToLayer(e) {\n    return this.locationToLayer(this.eventToLocation(e));\n  }\n\n  eventToLocation(e) {\n    let cursor = this.eventOffset(e);\n    return this.viewToLocation(cursor);\n  }\n\n  viewSize() {\n    let element = this.element;\n\n    let scale = this._layerSize();\n\n    let width = element.clientWidth;\n\n    if (!this.options.wraparound) {\n      width = min(scale, width);\n    }\n\n    return {\n      width: width,\n      height: min(scale, element.clientHeight)\n    };\n  }\n\n  exportVisual() {\n    this._reset();\n\n    return false;\n  }\n\n  hideTooltip() {\n    if (this._tooltip) {\n      this._tooltip.hide();\n    }\n  }\n\n  _setOrigin(origin, zoom) {\n    let size = this.viewSize(),\n        topLeft;\n    const originLocation = this._origin = Location.create(origin);\n    topLeft = this.locationToLayer(originLocation, zoom);\n    topLeft.x += size.width / 2;\n    topLeft.y += size.height / 2;\n    this.options.center = this.layerToLocation(topLeft, zoom).toArray();\n    this.widgetService.notify(CENTER_CHANGE, {\n      center: this.options.center\n    });\n    return this;\n  }\n\n  _getOrigin(invalidate) {\n    let size = this.viewSize(),\n        topLeft;\n\n    if (invalidate || !this._origin) {\n      topLeft = this.locationToLayer(this.center());\n      topLeft.x -= size.width / 2;\n      topLeft.y -= size.height / 2;\n      this._origin = this.layerToLocation(topLeft);\n    }\n\n    return this._origin;\n  }\n\n  _setExtent(newExtent) {\n    let raw = Extent.create(newExtent);\n    let se = raw.se.clone();\n\n    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {\n      se.lng = 180 + (180 + se.lng);\n    }\n\n    const extent = new Extent(raw.nw, se);\n    this.center(extent.center());\n    let width = this.element.clientWidth;\n    let height = this.element.clientHeight;\n    let zoom;\n\n    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {\n      let topLeft = this.locationToLayer(extent.nw, zoom);\n      let bottomRight = this.locationToLayer(extent.se, zoom);\n      let layerWidth = math.abs(bottomRight.x - topLeft.x);\n      let layerHeight = math.abs(bottomRight.y - topLeft.y);\n\n      if (layerWidth <= width && layerHeight <= height) {\n        break;\n      }\n    }\n\n    this.zoom(zoom);\n  }\n\n  _getExtent() {\n    let nw = this._getOrigin();\n\n    let bottomRight = this.locationToLayer(nw);\n    let size = this.viewSize();\n    bottomRight.x += size.width;\n    bottomRight.y += size.height;\n    let se = this.layerToLocation(bottomRight);\n    return new Extent(nw, se);\n  }\n\n  _zoomAround(pivot, level) {\n    this._setOrigin(this.layerToLocation(pivot, level), level);\n\n    this.zoom(level);\n  }\n\n  _initControls() {\n    let controls = this.options.controls;\n\n    if (controls.attribution) {\n      this._createAttribution(controls.attribution);\n    }\n\n    if (!this.support.mobileOS) {\n      if (controls.navigator) {\n        this._createNavigator(controls.navigator);\n      }\n\n      if (controls.zoom) {\n        this._createZoomControl(controls.zoom);\n      }\n    }\n  }\n\n  _createControlElement(options, defaultPosition) {\n    let pos = options.position || defaultPosition;\n    let posSelector = '.' + renderPos(pos).replace(' ', '.');\n    let wrap = this.element.querySelector('.k-map-controls' + posSelector) || [];\n\n    if (wrap.length === 0) {\n      let div = document.createElement(\"div\");\n      addClass(div, 'k-map-controls ' + renderPos(pos));\n      wrap = div;\n      this.element.appendChild(wrap);\n    }\n\n    let div = document.createElement(\"div\");\n    wrap.appendChild(div);\n    return div;\n  }\n\n  _createAttribution(options) {\n    let element = this._createControlElement(options, 'bottomRight');\n\n    this.attribution = new Attribution(element, options);\n  }\n\n  _createNavigator(options) {\n    let element = this._createControlElement(options, 'topLeft');\n\n    let navigator = this.navigator = new Navigator(element, options);\n    this._navigatorPan = this._navigatorPan.bind(this);\n    navigator.bind('pan', this._navigatorPan);\n    this._navigatorCenter = this._navigatorCenter.bind(this);\n    navigator.bind('center', this._navigatorCenter);\n  }\n\n  _navigatorPan(e) {\n    let scroller = this.scroller;\n    let x = scroller.scrollLeft + e.x;\n    let y = scroller.scrollTop - e.y;\n    let bounds = this._virtualSize;\n    let width = this.element.clientWidth;\n    let height = this.element.clientHeight; // TODO: Move limits to scroller\n\n    x = limitValue(x, bounds.x.min, bounds.x.max - width);\n    y = limitValue(y, bounds.y.min, bounds.y.max - height);\n    this.scroller.one('scroll', proxy(this._scrollEnd, this));\n    this.scroller.scrollTo(-x, -y);\n  }\n\n  _navigatorCenter() {\n    this.center(this.options.center);\n  }\n\n  _createZoomControl(options) {\n    let element = this._createControlElement(options, 'topLeft');\n\n    let zoomControl = this.zoomControl = new ZoomControl(element, options);\n    this._zoomControlChange = this._zoomControlChange.bind(this);\n    zoomControl.bind('change', this._zoomControlChange);\n  }\n\n  _zoomControlChange(e) {\n    if (!this.trigger('zoomStart', {\n      originalEvent: e\n    })) {\n      this.zoom(this.zoom() + e.delta);\n      this.trigger('zoomEnd', {\n        originalEvent: e\n      });\n    }\n  }\n\n  _initScroller() {\n    let friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n    let zoomable = this.options.zoomable !== false;\n    let scroller = this.scroller = new Scroller(this.element.children[0], {\n      friction: friction,\n      velocityMultiplier: VELOCITY_MULTIPLIER,\n      zoom: zoomable,\n      mousewheelScrolling: false,\n      supportDoubleTap: true\n    });\n    scroller.bind('scroll', proxy(this._scroll, this));\n    scroller.bind('scrollEnd', proxy(this._scrollEnd, this));\n    scroller.userEvents.bind('gesturestart', proxy(this._scaleStart, this));\n    scroller.userEvents.bind('gestureend', proxy(this._scale, this));\n    scroller.userEvents.bind('doubleTap', proxy(this._doubleTap, this));\n    scroller.userEvents.bind('tap', proxy(this._tap, this));\n    this.scrollElement = scroller.scrollElement;\n  }\n\n  _initLayers() {\n    let defs = this.options.layers,\n        layers = this.layers = [];\n\n    for (let i = 0; i < defs.length; i++) {\n      let options = defs[i];\n\n      const layer = this._createLayer(options);\n\n      layers.push(layer);\n    }\n  }\n\n  _createLayer(options) {\n    let type = options.type || 'shape';\n    let layerDefaults = this.options.layerDefaults[type];\n    let layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options) : deepExtend({}, layerDefaults, options);\n    let layerConstructor = layersMap[type];\n    let layer = new layerConstructor(this, layerOptions);\n\n    if (type === MARKER) {\n      this.markers = layer;\n    }\n\n    return layer;\n  }\n\n  _createTooltip() {\n    return new Tooltip(this.widgetService, this.options.tooltip);\n  }\n  /* eslint-disable arrow-body-style */\n\n\n  _initMarkers() {\n    const markerLayers = (this.options.layers || []).filter(x => {\n      return x && x.type === MARKER;\n    });\n\n    if (markerLayers.length > 0) {\n      // render the markers from options.layers\n      // instead of options.markers\n      return;\n    }\n\n    this.markers = new MarkerLayer(this, this.options.markerDefaults);\n    this.markers.add(this.options.markers);\n  }\n  /* eslint-enable arrow-body-style */\n\n\n  _scroll(e) {\n    let origin = this.locationToLayer(this._viewOrigin).round();\n    let movable = e.sender.movable;\n    let offset = new g.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);\n    origin.x += offset.x;\n    origin.y += offset.y;\n    this._scrollOffset = offset;\n    this._tooltip.offset = offset;\n    this.hideTooltip();\n\n    this._setOrigin(this.layerToLocation(origin));\n\n    this.trigger('pan', {\n      originalEvent: e,\n      origin: this._getOrigin(),\n      center: this.center()\n    });\n  }\n\n  _scrollEnd(e) {\n    if (!this._scrollOffset || !this._panComplete()) {\n      return;\n    }\n\n    this._scrollOffset = null;\n    this._panEndTimestamp = now();\n    this.trigger('panEnd', {\n      originalEvent: e,\n      origin: this._getOrigin(),\n      center: this.center()\n    });\n  }\n\n  _panComplete() {\n    return now() - (this._panEndTimestamp || 0) > 50;\n  }\n\n  _scaleStart(e) {\n    if (this.trigger('zoomStart', {\n      originalEvent: e\n    })) {\n      let touch = e.touches[1];\n\n      if (touch) {\n        touch.cancel();\n      }\n    }\n  }\n\n  _scale(e) {\n    let scale = this.scroller.movable.scale;\n\n    let zoom = this._scaleToZoom(scale);\n\n    let gestureCenter = new g.Point(e.center.x, e.center.y);\n    let centerLocation = this.viewToLocation(gestureCenter, zoom);\n    let centerPoint = this.locationToLayer(centerLocation, zoom);\n    let originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);\n\n    this._zoomAround(originPoint, zoom);\n\n    this.trigger('zoomEnd', {\n      originalEvent: e\n    });\n  }\n\n  _scaleToZoom(scaleDelta) {\n    let scale = this._layerSize() * scaleDelta;\n    let tiles = scale / this.options.minSize;\n    let zoom = math.log(tiles) / math.log(2);\n    return math.round(zoom);\n  }\n\n  _reset() {\n    if (this.attribution) {\n      this.attribution.filter(this.center(), this.zoom());\n    }\n\n    this._viewOrigin = this._getOrigin(true);\n\n    this._resetScroller();\n\n    this.hideTooltip();\n    this.trigger('beforeReset');\n    this.trigger('reset');\n  }\n\n  _resetScroller() {\n    let scroller = this.scroller;\n    let x = scroller.dimensions.x;\n    let y = scroller.dimensions.y;\n\n    let scale = this._layerSize();\n\n    let nw = this.extent().nw;\n    let topLeft = this.locationToLayer(nw).round();\n    scroller.movable.round = true;\n    scroller.reset();\n    scroller.userEvents.cancel();\n    let zoom = this.zoom();\n    scroller.dimensions.forcedMinScale = pow(2, this.options.minZoom - zoom);\n    scroller.dimensions.maxScale = pow(2, this.options.maxZoom - zoom);\n    let xBounds = {\n      min: -topLeft.x,\n      max: scale - topLeft.x\n    };\n    let yBounds = {\n      min: -topLeft.y,\n      max: scale - topLeft.y\n    };\n\n    if (this.options.wraparound) {\n      xBounds.max = 20 * scale;\n      xBounds.min = -xBounds.max;\n    }\n\n    if (this.options.pannable === false) {\n      let viewSize = this.viewSize();\n      xBounds.min = yBounds.min = 0;\n      xBounds.max = viewSize.width;\n      yBounds.max = viewSize.height;\n    }\n\n    x.makeVirtual();\n    y.makeVirtual();\n    x.virtualSize(xBounds.min, xBounds.max);\n    y.virtualSize(yBounds.min, yBounds.max);\n    this._virtualSize = {\n      x: xBounds,\n      y: yBounds\n    };\n  } // kept for API compatibility, not used\n\n\n  _renderLayers() {}\n\n  _layerSize(zoom) {\n    const newZoom = valueOrDefault(zoom, this.options.zoom);\n    return this.options.minSize * pow(2, newZoom);\n  }\n\n  _tap(e) {\n    if (!this._panComplete()) {\n      return;\n    }\n\n    let cursor = this.eventOffset(e);\n    this.hideTooltip();\n    this.trigger('click', {\n      originalEvent: e,\n      location: this.viewToLocation(cursor)\n    });\n  }\n\n  _doubleTap(e) {\n    let options = this.options;\n\n    if (options.zoomable !== false) {\n      if (!this.trigger('zoomStart', {\n        originalEvent: e\n      })) {\n        let toZoom = this.zoom() + DEFAULT_ZOOM_RATE;\n        let cursor = this.eventOffset(e);\n        let location = this.viewToLocation(cursor);\n        let postZoom = this.locationToLayer(location, toZoom);\n        let origin = postZoom.translate(-cursor.x, -cursor.y);\n\n        this._zoomAround(origin, toZoom);\n\n        this.trigger('zoomEnd', {\n          originalEvent: e\n        });\n      }\n    }\n  }\n\n  _mousewheel(e) {\n    let delta = mousewheelDelta(e) > 0 ? -1 : 1;\n    let options = this.options;\n    let fromZoom = this.zoom();\n    let toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);\n\n    if (options.zoomable !== false && toZoom !== fromZoom) {\n      if (!this.trigger('zoomStart', {\n        originalEvent: e\n      })) {\n        let cursor = this.eventOffset(e);\n        let location = this.viewToLocation(cursor);\n        let postZoom = this.locationToLayer(location, toZoom);\n        let origin = postZoom.translate(-cursor.x, -cursor.y);\n\n        this._zoomAround(origin, toZoom);\n\n        this.trigger('zoomEnd', {\n          originalEvent: e\n        });\n      }\n    }\n  }\n\n  _toDocumentCoordinates(point) {\n    const offset = elementOffset(this.element);\n    return {\n      left: round(point.x + offset.left),\n      top: round(point.y + offset.top)\n    };\n  }\n\n}\n\nsetDefaultOptions(Map, {\n  name: 'Map',\n  controls: {\n    attribution: true,\n    navigator: {\n      panStep: 100\n    },\n    zoom: true\n  },\n  layers: [],\n  layerDefaults: {\n    shape: {\n      style: {\n        fill: {\n          color: '#fff'\n        },\n        stroke: {\n          color: '#aaa',\n          width: 0.5\n        }\n      }\n    },\n    bubble: {\n      style: {\n        fill: {\n          color: '#fff',\n          opacity: 0.5\n        },\n        stroke: {\n          color: '#aaa',\n          width: 0.5\n        }\n      }\n    },\n    marker: {\n      shape: 'pinTarget',\n      tooltip: {\n        position: 'top'\n      }\n    }\n  },\n  center: [0, 0],\n  zoom: 3,\n  minSize: 256,\n  minZoom: 1,\n  maxZoom: 19,\n  markers: [],\n  markerDefaults: {\n    shape: 'pinTarget',\n    tooltip: {\n      position: 'top'\n    }\n  },\n  wraparound: true,\n  // If set to true, GeoJSON layer \"Point\" features will be rendered as markers.\n  // Otherwise, the points will be rendered as circles.\n  // Defaults to `true` for KUI/jQuery, `false` everywhere else.\n  renderPointsAsMarkers: false\n});\nsetDefaultEvents(Map, ['beforeReset', 'click', 'markerActivate', 'markerClick', 'markerCreated', // Events for implementing custom tooltips.\n'markerMouseEnter', 'markerMouseLeave', 'pan', 'panEnd', 'reset', 'shapeClick', 'shapeCreated', 'shapeFeatureCreated', 'shapeMouseEnter', 'shapeMouseLeave', 'zoomEnd', 'zoomStart']);\nexport default Map;","map":null,"metadata":{},"sourceType":"module"}