{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1734);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  },\n\n  /***/\n  1706:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./references\");\n    /***/\n  },\n\n  /***/\n  1734:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(1678), __webpack_require__(1706), __webpack_require__(1735)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        // jshint latedef: nofunc\n        // jshint eqnull: true, laxbreak: true\n        var $ = kendo.jQuery;\n        var Formula = kendo.spreadsheet.calc.runtime.Formula;\n        var Ref = kendo.spreadsheet.Ref;\n        var CalcError = kendo.spreadsheet.CalcError;\n        kendo.spreadsheet.messages.workbook = {\n          defaultSheetName: \"Sheet\"\n        };\n\n        function loadBinary(url, callback) {\n          var xhr = new XMLHttpRequest();\n\n          xhr.onload = function () {\n            callback(xhr.response, xhr.getResponseHeader(\"Content-Type\"));\n          };\n\n          xhr.onerror = function () {\n            callback(null);\n          };\n\n          xhr.open(\"GET\", url);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send();\n        }\n\n        var Workbook = kendo.Observable.extend({\n          options: {},\n          init: function (options, view) {\n            kendo.Observable.fn.init.call(this);\n            this.options = options;\n            this._view = view;\n            this._sheets = [];\n            this._images = {};\n            this._imgID = 0;\n            this._sheetsSearchCache = {};\n            this._sheet = this.insertSheet({\n              rows: this.options.rows,\n              columns: this.options.columns,\n              rowHeight: this.options.rowHeight,\n              columnWidth: this.options.columnWidth,\n              headerHeight: this.options.headerHeight,\n              headerWidth: this.options.headerWidth,\n              dataSource: this.options.dataSource\n            });\n            this.undoRedoStack = new kendo.util.UndoRedoStack();\n            this.undoRedoStack.bind([\"undo\", \"redo\"], this._onUndoRedo.bind(this));\n            this._context = new kendo.spreadsheet.FormulaContext(this);\n            this._validationContext = new kendo.spreadsheet.ValidationFormulaContext(this);\n            this._names = Object.create(null);\n            this.fromJSON(this.options);\n          },\n          clipboard: function () {\n            if (!this._clipboard) {\n              this._clipboard = new kendo.spreadsheet.Clipboard(this);\n            }\n\n            return this._clipboard;\n          },\n          destroy: function () {\n            this.unbind();\n\n            if (this._clipboard) {\n              this._clipboard.destroy();\n            }\n          },\n          events: [\"cut\", \"copy\", \"paste\", \"changing\", \"change\", \"excelImport\", \"excelExport\", \"insertSheet\", \"removeSheet\", \"selectSheet\", \"renameSheet\", \"insertRow\", \"insertColumn\", \"deleteRow\", \"deleteColumn\", \"hideRow\", \"hideColumn\", \"unhideRow\", \"unhideColumn\", \"select\", \"changeFormat\", \"dataBinding\", \"dataBound\", \"progress\"],\n          _sheetChanging: function (e) {\n            if (this.trigger(\"changing\", e)) {\n              e.preventDefault();\n            }\n          },\n          _sheetChange: function (e) {\n            this.trigger(\"change\", e);\n          },\n          _sheetInsertRow: function (e) {\n            if (this.trigger(\"insertRow\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetInsertColumn: function (e) {\n            if (this.trigger(\"insertColumn\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetDeleteRow: function (e) {\n            if (this.trigger(\"deleteRow\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetDeleteColumn: function (e) {\n            if (this.trigger(\"deleteColumn\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetHideRow: function (e) {\n            if (this.trigger(\"hideRow\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetHideColumn: function (e) {\n            if (this.trigger(\"hideColumn\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetUnhideRow: function (e) {\n            if (this.trigger(\"unhideRow\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetUnhideColumn: function (e) {\n            if (this.trigger(\"unhideColumn\", {\n              sheet: e.sender,\n              index: e.index\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetSelect: function (e) {\n            this.trigger(\"select\", e);\n          },\n          _sheetDataBinding: function (e) {\n            if (this.trigger(\"dataBinding\", {\n              sheet: e.sender\n            })) {\n              e.preventDefault();\n            }\n          },\n          _sheetDataBound: function (e) {\n            this.trigger(\"dataBound\", {\n              sheet: e.sender\n            });\n          },\n          _sheetProgress: function (e) {\n            var that = this;\n            setTimeout(function () {\n              that.trigger(\"progress\", {\n                toggle: e.toggle\n              });\n            });\n          },\n          _sheetCommandRequest: function (e) {\n            this.trigger(\"commandRequest\", e);\n          },\n          _inputForRef: function (ref) {\n            var self = this;\n            return self._sheet.withCultureDecimals(function () {\n              return new kendo.spreadsheet.Range(ref, self._sheet).input();\n            });\n          },\n          _onUndoRedo: function (e) {\n            e.command.range().select();\n          },\n          execute: function (options) {\n            var commandOptions = $.extend({\n              workbook: this\n            }, options.options);\n            var command = new kendo.spreadsheet[options.command](commandOptions);\n            var sheet = this.activeSheet();\n\n            if (commandOptions.origin) {\n              command.origin(commandOptions.origin);\n            }\n\n            if (commandOptions.operatingRange) {\n              command.range(commandOptions.operatingRange);\n            } else {\n              command.range(sheet.selection());\n            }\n\n            if (commandOptions.editRange) {\n              command._editRange = commandOptions.editRange;\n            }\n\n            var result = command.exec();\n\n            if (!result || result.reason !== \"error\") {\n              if (!command.cannotUndo) {\n                this.undoRedoStack.push(command);\n              }\n            } // when the undo/redo stack is truncated (by e.g. adding a\n            // non-redo command after undoing) it's possible to\n            // discard images from the dropped commands.\n\n\n            this.cleanupImages();\n            return result;\n          },\n          resetFormulas: function () {\n            this._sheets.forEach(function (sheet) {\n              sheet.resetFormulas();\n            });\n          },\n          resetValidations: function () {\n            this._sheets.forEach(function (sheet) {\n              sheet.resetValidations();\n            });\n          },\n          refresh: function (reason) {\n            if (reason.recalc) {\n              this.resetFormulas();\n              this.resetValidations();\n\n              this._sheet.recalc(this._context);\n\n              this._sheet.revalidate(this._validationContext);\n            }\n          },\n          activeSheet: function (sheet) {\n            if (sheet === undefined) {\n              return this._sheet;\n            }\n\n            if (!this.sheetByName(sheet.name())) {\n              return;\n            }\n\n            this._sheet = sheet; //TODO: better way to get all reasons?\n\n            sheet.triggerChange(kendo.spreadsheet.ALL_REASONS);\n          },\n          moveSheetToIndex: function (sheet, toIndex) {\n            var fromIndex = this.sheetIndex(sheet);\n            var sheets = this._sheets;\n\n            if (fromIndex === -1) {\n              return;\n            }\n\n            this._sheetsSearchCache = {};\n            sheets.splice(toIndex, 0, sheets.splice(fromIndex, 1)[0]);\n            this.trigger(\"change\", {\n              sheetSelection: true\n            });\n          },\n          insertSheet: function (options) {\n            options = options || {};\n            var that = this;\n            var insertIndex = typeof options.index === \"number\" ? options.index : that._sheets.length;\n            var sheetName;\n            var sheets = that._sheets;\n\n            var getUniqueSheetName = function (sheetNameSuffix) {\n              sheetNameSuffix = sheetNameSuffix ? sheetNameSuffix : 1;\n              var name = kendo.spreadsheet.messages.workbook.defaultSheetName + sheetNameSuffix;\n\n              if (!that.sheetByName(name)) {\n                return name;\n              }\n\n              return getUniqueSheetName(sheetNameSuffix + 1);\n            };\n\n            if (options.name && that.sheetByName(options.name)) {\n              return;\n            }\n\n            this._sheetsSearchCache = {};\n            sheetName = options.name || getUniqueSheetName();\n            var sheet = new kendo.spreadsheet.Sheet(options.rows || this.options.rows, options.columns || this.options.columns, options.rowHeight || this.options.rowHeight, options.columnWidth || this.options.columnWidth, options.headerHeight || this.options.headerHeight, options.headerWidth || this.options.headerWidth, options.defaultCellStyle || this.options.defaultCellStyle);\n            sheet._workbook = this;\n\n            sheet._name(sheetName);\n\n            this._bindSheetEvents(sheet);\n\n            sheets.splice(insertIndex, 0, sheet);\n\n            if (options.data) {\n              sheet.fromJSON(options.data);\n            }\n\n            if (options.dataSource) {\n              sheet.setDataSource(options.dataSource);\n            }\n\n            this.trigger(\"change\", {\n              sheetSelection: true\n            });\n            return sheet;\n          },\n          _bindSheetEvents: function (sheet) {\n            sheet.bind(\"changing\", this._sheetChanging.bind(this));\n            sheet.bind(\"change\", this._sheetChange.bind(this));\n            sheet.bind(\"insertRow\", this._sheetInsertRow.bind(this));\n            sheet.bind(\"insertColumn\", this._sheetInsertColumn.bind(this));\n            sheet.bind(\"deleteRow\", this._sheetDeleteRow.bind(this));\n            sheet.bind(\"deleteColumn\", this._sheetDeleteColumn.bind(this));\n            sheet.bind(\"hideRow\", this._sheetHideRow.bind(this));\n            sheet.bind(\"hideColumn\", this._sheetHideColumn.bind(this));\n            sheet.bind(\"unhideRow\", this._sheetUnhideRow.bind(this));\n            sheet.bind(\"unhideColumn\", this._sheetUnhideColumn.bind(this));\n            sheet.bind(\"select\", this._sheetSelect.bind(this));\n            sheet.bind(\"commandRequest\", this._sheetCommandRequest.bind(this));\n            sheet.bind(\"dataBinding\", this._sheetDataBinding.bind(this));\n            sheet.bind(\"dataBound\", this._sheetDataBound.bind(this));\n            sheet.bind(\"progress\", this._sheetProgress.bind(this));\n          },\n          sheets: function () {\n            return this._sheets.slice();\n          },\n          sheetByName: function (sheetName) {\n            return this._sheets[this.sheetIndex(sheetName)];\n          },\n          sheetByIndex: function (index) {\n            return this._sheets[index];\n          },\n          sheetIndex: function (sheet) {\n            var sheets = this._sheets;\n            var sheetName = (typeof sheet == \"string\" ? sheet : sheet.name()).toLowerCase();\n            var idx = this._sheetsSearchCache[sheetName];\n\n            if (idx >= 0) {\n              return idx;\n            }\n\n            for (idx = 0; idx < sheets.length; idx++) {\n              var name = sheets[idx].name().toLowerCase();\n              this._sheetsSearchCache[name] = idx;\n\n              if (name === sheetName) {\n                return idx;\n              }\n            }\n\n            return -1;\n          },\n          renameSheet: function (sheet, newSheetName) {\n            var oldSheetName = sheet.name().toLowerCase();\n\n            if (!newSheetName || oldSheetName === newSheetName.toLowerCase() || this.sheetByName(newSheetName)) {\n              return;\n            }\n\n            sheet = this.sheetByName(oldSheetName);\n\n            if (!sheet) {\n              return;\n            }\n\n            this._sheetsSearchCache = {};\n\n            if (this.trigger(\"renameSheet\", {\n              sheet: sheet,\n              newSheetName: newSheetName\n            })) {\n              return;\n            } // update references\n\n\n            this._sheets.forEach(function (sheet) {\n              sheet._forFormulas(function (formula) {\n                formula.renameSheet(oldSheetName, newSheetName);\n              });\n            });\n\n            this.forEachName(function (def, name) {\n              // 1. redefine sheet-local names\n              if (def.nameref.renameSheet(oldSheetName, newSheetName)) {\n                this.undefineName(name);\n                def.name = def.nameref.print();\n                this.nameDefinition(def.name, def);\n              } // 2. if the value is reference or formula, update it\n\n\n              if (def.value instanceof Ref || def.value instanceof Formula) {\n                def.value.renameSheet(oldSheetName, newSheetName);\n              }\n            }.bind(this));\n\n            sheet._name(newSheetName);\n\n            this.trigger(\"change\", {\n              sheetSelection: true\n            });\n            return sheet;\n          },\n          removeSheet: function (sheet) {\n            var that = this;\n            var sheets = that._sheets;\n            var name = sheet.name();\n            var index = that.sheetIndex(sheet);\n\n            if (sheets.length === 1) {\n              return;\n            }\n\n            if (this.trigger(\"removeSheet\", {\n              sheet: sheet\n            })) {\n              return;\n            }\n\n            this._sheetsSearchCache = {};\n\n            if (index > -1) {\n              sheet.unbind();\n              sheets.splice(index, 1);\n\n              if (that.activeSheet().name() === name) {\n                var newSheet = sheets[index === sheets.length ? index - 1 : index];\n                that.activeSheet(newSheet);\n              } else {\n                this.trigger(\"change\", {\n                  recalc: true,\n                  sheetSelection: true\n                });\n              }\n            }\n          },\n          _clearSheets: function () {\n            for (var i = 0; i < this._sheets.length; i++) {\n              this._sheets[i]._activeDrawing = [];\n              this._sheets[i]._drawings = [];\n\n              this._sheets[i].unbind();\n            }\n\n            this._sheets = [];\n            this._sheetsSearchCache = {};\n            this._names = {};\n            this._images = {};\n            this._imgID = 0;\n          },\n          // _loadImages: function() {\n          //     var self = this;\n          //     var ids = Object.keys(self._images);\n          //     var count = ids.length;\n          //     if (count) {\n          //         ids.forEach(function(id){\n          //             var img = self._images[id];\n          //             if (!img.blob) {\n          //                 loadBinary(img.url, function(data, type) {\n          //                     // XXX: can we do something better in case of error?\n          //                     if (data != null) {\n          //                         img.blob = new Blob([ data ], { type: type });\n          //                         delete img.url;\n          //                     }\n          //                     next();\n          //                 });\n          //             }\n          //         });\n          //     } else {\n          //         next();\n          //     }\n          //     function next() {\n          //         if (--count <= 0) {\n          //             self.activeSheet().triggerChange({ layout: true });\n          //         }\n          //     }\n          // },\n          fromJSON: function (json) {\n            if (json.sheets) {\n              this._clearSheets();\n\n              if (json.images) {\n                this._imgID = 0;\n                this._images = {};\n                Object.keys(json.images).forEach(function (id) {\n                  if (!isNaN(id)) {\n                    var num = parseFloat(id);\n\n                    if (isFinite(num)) {\n                      this._imgID = Math.max(this._imgID, num);\n                    }\n                  }\n\n                  this._images[id] = {\n                    url: json.images[id]\n                  };\n                }, this); // this._loadImages();\n              }\n\n              for (var idx = 0; idx < json.sheets.length; idx++) {\n                var data = json.sheets[idx];\n                var args = sheetParamsFromJSON(data, this.options);\n                var sheet = this.insertSheet({\n                  rows: args.rowCount,\n                  columns: args.columnCount,\n                  rowHeight: args.rowHeight,\n                  columnWidth: args.columnWidth,\n                  headerHeight: args.headerHeight,\n                  headerWidth: args.headerWidth,\n                  data: data\n                });\n\n                if (data.dataSource) {\n                  sheet.setDataSource(data.dataSource);\n                }\n              }\n            }\n\n            if (json.activeSheet) {\n              this.activeSheet(this.sheetByName(json.activeSheet));\n            } else {\n              this.activeSheet(this._sheets[0]);\n            }\n\n            if (json.names) {\n              json.names.forEach(function (def) {\n                this.defineName(def.name, def.value, def.hidden);\n              }, this);\n            }\n          },\n          toJSON: function () {\n            this.resetFormulas();\n            this.resetValidations();\n            var names = Object.keys(this._names).map(function (name) {\n              var def = this._names[name];\n              var val = def.value;\n\n              if (val instanceof Ref || val instanceof Formula) {\n                val = val.print(0, 0, true);\n              } else if (val instanceof CalcError) {\n                val = val + \"\";\n              } else {\n                val = JSON.stringify(val);\n              }\n\n              return {\n                value: val,\n                hidden: def.hidden,\n                name: def.name,\n                // these two are not really useful in\n                // deserialization, but are handy in OOXML export.\n                sheet: def.nameref.sheet,\n                localName: def.nameref.name\n              };\n            }, this);\n            return {\n              activeSheet: this.activeSheet().name(),\n              sheets: this._sheets.map(function (sheet) {\n                sheet.recalc(this._context);\n                sheet.revalidate(this._validationContext);\n                return sheet.toJSON();\n              }, this),\n              names: names,\n              columnWidth: this.options.columnWidth,\n              rowHeight: this.options.rowHeight\n            };\n          },\n          saveJSON: function () {\n            var self = this;\n            var deferred = new $.Deferred();\n            var data = self.toJSON();\n            var ids = Object.keys(self._images).filter(function (id) {\n              return self.usesImage(id) === 1;\n            });\n            var count = ids.length;\n            data.images = {};\n\n            if (count) {\n              ids.forEach(function (id) {\n                var img = self._images[id];\n\n                if (img.blob) {\n                  var reader = new FileReader();\n\n                  reader.onload = function () {\n                    data.images[id] = reader.result;\n                    next();\n                  };\n\n                  reader.readAsDataURL(img.blob);\n                } else {\n                  data.images[id] = img.url;\n                  next();\n                }\n              });\n            } else {\n              next();\n            }\n\n            return deferred.promise();\n\n            function next() {\n              if (--count <= 0) {\n                deferred.resolve(data);\n              }\n            }\n          },\n          fromFile: function (file) {\n            var deferred = new $.Deferred();\n            var promise = deferred.promise();\n            var args = {\n              file: file,\n              promise: promise\n            };\n\n            if (file && !this.trigger(\"excelImport\", args)) {\n              this._clearSheets();\n\n              kendo.spreadsheet.readExcel(file, this, deferred);\n            } else {\n              deferred.reject();\n            }\n\n            return promise;\n          },\n          saveAsExcel: function (options) {\n            var self = this;\n            options = $.extend({}, self.options.excel, options);\n            var data = self.toJSON();\n\n            if (self.trigger(\"excelExport\", {\n              workbook: data\n            })) {\n              return;\n            }\n\n            var ids = Object.keys(self._images).filter(function (id) {\n              return self.usesImage(id) === 1;\n            });\n            var count = ids.length;\n            var images = count ? {} : null;\n\n            if (count) {\n              ids.forEach(function (id) {\n                var img = self._images[id];\n\n                if (img.blob) {\n                  var reader = new FileReader();\n\n                  reader.onload = function () {\n                    images[id] = {\n                      type: img.blob.type,\n                      name: img.blob.name,\n                      data: reader.result\n                    };\n                    next();\n                  };\n\n                  reader.readAsArrayBuffer(img.blob);\n                } else {\n                  loadBinary(img.url, function (data, type) {\n                    images[id] = {\n                      type: type,\n                      data: data\n                    };\n                    next();\n                  });\n                }\n              });\n            } else {\n              next();\n            }\n\n            function next() {\n              if (--count <= 0) {\n                data.images = images;\n                var workbook = new kendo.ooxml.Workbook(data);\n                kendo.saveAs({\n                  dataURI: options.forceProxy ? workbook.toDataURL() : workbook.toBlob(),\n                  fileName: data.fileName || options.fileName,\n                  proxyURL: options.proxyURL,\n                  forceProxy: options.forceProxy\n                });\n              }\n            }\n          },\n          draw: function (options, callback) {\n            if (typeof options == \"function\" && !callback) {\n              callback = options;\n              options = {};\n            }\n\n            var parts = [],\n                sheets = this._sheets;\n\n            (function loop(i) {\n              if (i < sheets.length) {\n                sheets[i].draw(kendo.spreadsheet.SHEETREF, options, function (group) {\n                  parts.push(group);\n                  loop(i + 1);\n                });\n              } else {\n                var group = parts[0];\n\n                for (i = 1; i < parts.length; ++i) {\n                  group.children = group.children.concat(parts[i].children);\n                }\n\n                callback(group);\n              }\n            })(0);\n          },\n          nameForRef: function (ref, sheet) {\n            if (sheet === undefined) {\n              sheet = ref.sheet;\n            }\n\n            sheet = sheet.toLowerCase();\n            var str = ref + \"\";\n\n            for (var name in this._names) {\n              var def = this._names[name];\n              var val = def.value;\n\n              if (val instanceof Ref) {\n                if (!val.sheet || val.sheet && sheet == val.sheet.toLowerCase()) {\n                  if (val + \"\" == str) {\n                    return def;\n                  }\n                }\n              }\n            }\n\n            return {\n              name: str\n            };\n          },\n          defineName: function (name, value, hidden) {\n            var x = kendo.spreadsheet.calc.parseNameDefinition(name, value);\n            name = x.name.print();\n            this._names[name.toLowerCase()] = {\n              value: x.value,\n              hidden: hidden,\n              name: name,\n              nameref: x.name\n            };\n          },\n          undefineName: function (name) {\n            delete this._names[name.toLowerCase()];\n          },\n          nameValue: function (name) {\n            name = name.toLowerCase();\n\n            if (name in this._names) {\n              return this._names[name].value;\n            }\n\n            return null;\n          },\n          nameDefinition: function (name, def) {\n            name = name.toLowerCase();\n\n            if (arguments.length > 1) {\n              if (def === undefined) {\n                delete this._names[name];\n              } else {\n                this._names[name] = def;\n              }\n            }\n\n            return this._names[name];\n          },\n          forEachName: function (func) {\n            Object.keys(this._names).forEach(function (name) {\n              func(this._names[name], name);\n            }, this);\n          },\n          adjustNames: function (affectedSheet, forRow, start, delta) {\n            affectedSheet = affectedSheet.toLowerCase();\n            Object.keys(this._names).forEach(function (name) {\n              var def = this._names[name];\n              var x = def.value;\n\n              if (x instanceof Ref && x.sheet.toLowerCase() == affectedSheet) {\n                def.value = x.adjust(null, null, null, null, forRow, start, delta);\n              } else if (x instanceof Formula) {\n                x.adjust(affectedSheet, forRow ? \"row\" : \"col\", start, delta);\n              }\n            }, this);\n          },\n          addImage: function (image) {\n            var id = String(++this._imgID);\n\n            if (typeof image == \"string\") {\n              this._images[id] = {\n                url: image\n              };\n            } else {\n              this._images[id] = {\n                blob: image\n              };\n            }\n\n            return id;\n          },\n          imageUrl: function (id) {\n            var img = this._images[id];\n            var url = img.url;\n\n            if (!url) {\n              url = img.url = window.URL.createObjectURL(img.blob);\n            }\n\n            return url;\n          },\n          cleanupImages: function () {\n            Object.keys(this._images).forEach(function (id) {\n              if (!this.usesImage(id)) {\n                var url = this._images[id].url;\n\n                if (url) {\n                  window.URL.revokeObjectURL(url);\n                }\n\n                delete this._images[id];\n              }\n            }, this);\n          },\n          usesImage: function (img) {\n            var i;\n            var sheets = this._sheets;\n\n            for (i = sheets.length; --i >= 0;) {\n              if (sheets[i].usesImage(img)) {\n                return 1;\n              }\n            }\n\n            var stack = this.undoRedoStack.stack;\n\n            for (i = stack.length; --i >= 0;) {\n              if (stack[i].usesImage(img)) {\n                return 2; // signal that it's only in the undo stack\n              }\n            }\n\n            return false;\n          }\n        });\n\n        function sheetParamsFromJSON(data, options) {\n          function or(a, b, c) {\n            return a !== undefined ? a : b !== undefined ? b : c;\n          }\n\n          var rowCount = or(data.rowCount, options.rows, 200),\n              columnCount = or(data.columnCount, options.columns, 50),\n              rowHeight = or(data.rowHeight, options.rowHeight, 20),\n              columnWidth = or(data.columnWidth, options.columnWidth, 64),\n              headerHeight = or(data.headerHeight, options.headerHeight, 20),\n              headerWidth = or(data.headerWidth, options.headerWidth, 32);\n\n          if (data.rows !== undefined) {\n            for (var i = 0; i < data.rows.length; ++i) {\n              var row = data.rows[i];\n              var ri = or(row.index, i);\n\n              if (ri >= rowCount) {\n                rowCount = ri + 1;\n              }\n\n              if (row.cells) {\n                for (var j = 0; j < row.cells.length; ++j) {\n                  var cell = row.cells[j];\n                  var ci = or(cell.index, j);\n\n                  if (ci >= columnCount) {\n                    columnCount = ci + 1;\n                  }\n                }\n              }\n            }\n          }\n\n          return {\n            rowCount: rowCount,\n            columnCount: columnCount,\n            rowHeight: rowHeight,\n            columnWidth: columnWidth,\n            headerHeight: headerHeight,\n            headerWidth: headerWidth\n          };\n        }\n\n        kendo.spreadsheet.Workbook = Workbook;\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(Workbook.prototype);\n\n          Workbook.prototype.saveAsPDF = function (options) {\n            var progress = new $.Deferred();\n            var promise = progress.promise();\n            var args = {\n              promise: promise\n            };\n\n            if (this.trigger(\"pdfExport\", args)) {\n              return;\n            }\n\n            this._drawPDF(options, progress).then(function (root) {\n              return options.forceProxy ? kendo.pdf.exportPDF(root) // produce data URI for proxy\n              : kendo.pdf.exportPDFToBlob(root);\n            }).done(function (dataURI) {\n              kendo.saveAs({\n                dataURI: dataURI,\n                fileName: options.fileName,\n                proxyURL: options.proxyURL,\n                forceProxy: options.forceProxy,\n                proxyTarget: options.proxyTarget\n              });\n              progress.resolve();\n            }).fail(function (err) {\n              progress.reject(err);\n            });\n\n            return promise;\n          };\n\n          Workbook.prototype._drawPDF = function (options) {\n            var result = new $.Deferred();\n\n            var callback = function (group) {\n              result.resolve(group);\n            };\n\n            switch (options.area) {\n              case \"workbook\":\n                options.workbook.draw(options, callback);\n                break;\n\n              case \"sheet\":\n                options.workbook.activeSheet().draw(options, callback);\n                break;\n\n              case \"selection\":\n                options.workbook.activeSheet().selection().draw(options, callback);\n                break;\n            }\n\n            return result.promise();\n          };\n        }\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1735:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./excel-reader\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}