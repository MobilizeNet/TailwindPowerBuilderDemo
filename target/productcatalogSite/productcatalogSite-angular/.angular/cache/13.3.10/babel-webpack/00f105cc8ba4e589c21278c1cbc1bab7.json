{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport TextBox from './text-box';\nimport Box from './box';\nimport rectToBox from './utils/rect-to-box';\nimport { AXIS_LABEL_CLICK, CENTER, TOP, BOTTOM, LEFT, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { eventElement, round, setDefaultOptions } from '../common';\n\nclass AxisLabel extends TextBox {\n  constructor(value, text, index, dataItem, options) {\n    super(text, options);\n    this.text = text;\n    this.value = value;\n    this.index = index;\n    this.dataItem = dataItem;\n    this.reflow(new Box());\n  }\n\n  visualContext(targetBox) {\n    const context = super.visualContext(targetBox);\n    context.value = this.value;\n    context.dataItem = this.dataItem;\n    context.format = this.options.format;\n    context.culture = this.options.culture;\n    return context;\n  }\n\n  click(widget, e) {\n    widget.trigger(AXIS_LABEL_CLICK, {\n      element: eventElement(e),\n      value: this.value,\n      text: this.text,\n      index: this.index,\n      dataItem: this.dataItem,\n      axis: this.parent.options\n    });\n  }\n\n  rotate() {\n    if (this.options.alignRotation !== CENTER) {\n      const box = this.normalBox.toRect();\n      const transform = this.rotationTransform();\n      this.box = rectToBox(box.bbox(transform.matrix()));\n    } else {\n      super.rotate();\n    }\n\n    return this.box;\n  }\n\n  rotationTransform() {\n    const options = this.options;\n    const rotation = options.rotation;\n\n    if (!rotation) {\n      return null;\n    }\n\n    if (options.alignRotation === CENTER) {\n      return super.rotationTransform();\n    }\n\n    const rotationMatrix = geom.transform().rotate(rotation).matrix();\n    const box = this.normalBox.toRect();\n    const rect = this.targetBox.toRect();\n    const rotationOrigin = options.rotationOrigin || TOP;\n    const alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n    const distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n    const axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n    const topLeft = box.topLeft().transformCopy(rotationMatrix);\n    const topRight = box.topRight().transformCopy(rotationMatrix);\n    const bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n    const bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n    const rotatedBox = geom.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n    const translate = {\n      [distanceAxis]: rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis]\n    };\n    const distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n    const distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n    let alignStart, alignEnd;\n\n    if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n      alignStart = topLeft;\n      alignEnd = topRight;\n    } else if (distanceRight < distanceLeft) {\n      alignStart = topRight;\n      alignEnd = bottomRight;\n    } else {\n      alignStart = topLeft;\n      alignEnd = bottomLeft;\n    }\n\n    const alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n    translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n    return geom.transform().translate(translate.x, translate.y).rotate(rotation);\n  }\n\n}\n\nsetDefaultOptions(AxisLabel, {\n  _autoReflow: false\n});\nexport default AxisLabel;","map":null,"metadata":{},"sourceType":"module"}