{"ast":null,"code":"import { Class, elementOffset } from '../../common';\nimport { Observable } from './observable';\nimport { getEventMap, proxy, getSupportedFeatures } from '../utils';\nconst extend = Object.assign;\nconst CHANGE = 'change';\nexport class TapCapture extends Observable {\n  constructor(element, options) {\n    super();\n    let that = this,\n        domElement = element[0] || element;\n    that.capture = false;\n    const eventMap = getEventMap(navigator.userAgent);\n\n    if (domElement.addEventListener) {\n      eventMap.down.split(' ').forEach(function (event) {\n        domElement.addEventListener(event, proxy(that._press, that), true);\n      });\n      eventMap.up.split(' ').forEach(function (event) {\n        domElement.addEventListener(event, proxy(that._release, that), true);\n      });\n    } else {\n      eventMap.down.split(' ').forEach(function (event) {\n        domElement.attachEvent(event, proxy(that._press, that));\n      });\n      eventMap.up.split(' ').forEach(function (event) {\n        domElement.attachEvent(event, proxy(that._release, that));\n      });\n    }\n\n    that.bind(['press', 'release'], options || {});\n  }\n\n  captureNext() {\n    this.capture = true;\n  }\n\n  cancelCapture() {\n    this.capture = false;\n  }\n\n  _press(e) {\n    let that = this;\n    that.trigger('press');\n\n    if (that.capture) {\n      e.preventDefault();\n    }\n  }\n\n  _release(e) {\n    let that = this;\n    that.trigger('release');\n\n    if (that.capture) {\n      e.preventDefault();\n      that.cancelCapture();\n    }\n  }\n\n}\nexport class PaneDimension extends Observable {\n  constructor(options) {\n    super();\n    let that = this;\n    that.forcedEnabled = false;\n    extend(that, options);\n    that.scale = 1;\n\n    if (that.horizontal) {\n      that.measure = 'offsetWidth';\n      that.scrollSize = 'scrollWidth';\n      that.axis = 'x';\n    } else {\n      that.measure = 'offsetHeight';\n      that.scrollSize = 'scrollHeight';\n      that.axis = 'y';\n    }\n  }\n\n  makeVirtual() {\n    extend(this, {\n      virtual: true,\n      forcedEnabled: true,\n      _virtualMin: 0,\n      _virtualMax: 0\n    });\n  }\n\n  virtualSize(min, max) {\n    if (this._virtualMin !== min || this._virtualMax !== max) {\n      this._virtualMin = min;\n      this._virtualMax = max;\n      this.update();\n    }\n  }\n\n  outOfBounds(offset) {\n    return offset > this.max || offset < this.min;\n  }\n\n  forceEnabled() {\n    this.forcedEnabled = true;\n  }\n\n  getSize() {\n    return this.container[this.measure];\n  }\n\n  getTotal() {\n    return this.element[this.scrollSize];\n  }\n\n  rescale(scale) {\n    this.scale = scale;\n  }\n\n  update(silent) {\n    let that = this,\n        total = that.virtual ? that._virtualMax : that.getTotal(),\n        scaledTotal = total * that.scale,\n        size = that.getSize();\n\n    if (total === 0 && !that.forcedEnabled) {\n      return;\n    }\n\n    that.max = that.virtual ? -that._virtualMin : 0;\n    that.size = size;\n    that.total = scaledTotal;\n    that.min = Math.min(that.max, size - scaledTotal);\n    that.minScale = size / total;\n    that.centerOffset = (scaledTotal - size) / 2;\n    that.enabled = that.forcedEnabled || scaledTotal > size;\n\n    if (!silent) {\n      that.trigger(CHANGE, that);\n    }\n  }\n\n}\nexport class PaneDimensions extends Observable {\n  constructor(options) {\n    super();\n    let that = this;\n    that.x = new PaneDimension(extend({\n      horizontal: true\n    }, options));\n    that.y = new PaneDimension(extend({\n      horizontal: false\n    }, options));\n    that.container = options.container;\n    that.forcedMinScale = options.minScale;\n    that.maxScale = options.maxScale || 100;\n    that.bind(CHANGE, options);\n  }\n\n  rescale(newScale) {\n    this.x.rescale(newScale);\n    this.y.rescale(newScale);\n    this.refresh();\n  }\n\n  centerCoordinates() {\n    return {\n      x: Math.min(0, -this.x.centerOffset),\n      y: Math.min(0, -this.y.centerOffset)\n    };\n  }\n\n  refresh() {\n    let that = this;\n    that.x.update();\n    that.y.update();\n    that.enabled = that.x.enabled || that.y.enabled;\n    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);\n    that.fitScale = Math.max(that.x.minScale, that.y.minScale);\n    that.trigger(CHANGE);\n  }\n\n}\nexport class PaneAxis extends Observable {\n  constructor(options) {\n    super();\n    extend(this, options);\n  }\n\n  outOfBounds() {\n    return this.dimension.outOfBounds(this.movable[this.axis]);\n  }\n\n  dragMove(delta) {\n    let that = this,\n        dimension = that.dimension,\n        axis = that.axis,\n        movable = that.movable,\n        position = movable[axis] + delta;\n\n    if (!dimension.enabled) {\n      return;\n    }\n\n    let dragDelta = delta;\n\n    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n      dragDelta *= that.resistance;\n    }\n\n    movable.translateAxis(axis, dragDelta);\n    that.trigger(CHANGE, that);\n  }\n\n}\nexport class Pane extends Class {\n  constructor(options) {\n    super();\n    let that = this,\n        x,\n        y,\n        resistance,\n        movable;\n    extend(that, {\n      elastic: true\n    }, options);\n    resistance = that.elastic ? 0.5 : 0;\n    movable = that.movable;\n    that.x = x = new PaneAxis({\n      axis: 'x',\n      dimension: that.dimensions.x,\n      resistance: resistance,\n      movable: movable\n    });\n    that.y = y = new PaneAxis({\n      axis: 'y',\n      dimension: that.dimensions.y,\n      resistance: resistance,\n      movable: movable\n    });\n    that.userEvents.bind(['press', 'move', 'end', 'gesturestart', 'gesturechange'], {\n      gesturestart(e) {\n        that.gesture = e;\n        that.offset = elementOffset(that.dimensions.container);\n      },\n\n      press(e) {\n        const closestAnchor = e.event.target.closest('a');\n\n        if (closestAnchor && closestAnchor.matches('[data-navigate-on-press=true]')) {\n          e.sender.cancel();\n        }\n      },\n\n      gesturechange(e) {\n        let previousGesture = that.gesture,\n            previousCenter = previousGesture.center,\n            center = e.center,\n            scaleDelta = e.distance / previousGesture.distance,\n            minScale = that.dimensions.minScale,\n            maxScale = that.dimensions.maxScale,\n            coordinates;\n\n        if (movable.scale <= minScale && scaleDelta < 1) {\n          scaleDelta += (1 - scaleDelta) * 0.8;\n        }\n\n        if (movable.scale * scaleDelta >= maxScale) {\n          scaleDelta = maxScale / movable.scale;\n        }\n\n        let offsetX = movable.x + that.offset.left,\n            offsetY = movable.y + that.offset.top;\n        coordinates = {\n          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n        };\n        movable.scaleWith(scaleDelta);\n        x.dragMove(coordinates.x);\n        y.dragMove(coordinates.y);\n        that.dimensions.rescale(movable.scale);\n        that.gesture = e;\n        e.preventDefault();\n      },\n\n      move(e) {\n        if (e.event.target.tagName.match(/textarea|input/i)) {\n          return;\n        }\n\n        if (x.dimension.enabled || y.dimension.enabled) {\n          x.dragMove(e.x.delta);\n          y.dragMove(e.y.delta);\n          e.preventDefault();\n        } else {\n          e.touch.skip();\n        }\n      },\n\n      end(e) {\n        e.preventDefault();\n      }\n\n    });\n  }\n\n}\n\nlet translate = function (x, y, scale) {\n  return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';\n};\n\nexport class Movable extends Observable {\n  constructor(element) {\n    super();\n    let that = this;\n    that.support = getSupportedFeatures();\n    this.transformStyle = this.support.transitions.prefix + 'Transform';\n    that.element = element;\n    that.element.style.webkitTransformOrigin = 'left top';\n    that.x = 0;\n    that.y = 0;\n    that.scale = 1;\n    const coordinates = translate(that.x, that.y, that.scale);\n    that.element.style[this.transformStyle] = coordinates;\n\n    that._saveCoordinates(coordinates);\n  }\n\n  translateAxis(axis, by) {\n    this[axis] += by;\n    this.refresh();\n  }\n\n  scaleTo(scale) {\n    this.scale = scale;\n    this.refresh();\n  }\n\n  scaleWith(scaleDelta) {\n    this.scale *= scaleDelta;\n    this.refresh();\n  }\n\n  translate(coordinates) {\n    this.x += coordinates.x;\n    this.y += coordinates.y;\n    this.refresh();\n  }\n\n  moveAxis(axis, value) {\n    this[axis] = value;\n    this.refresh();\n  }\n\n  moveTo(coordinates) {\n    extend(this, coordinates);\n    this.refresh();\n  }\n\n  refresh() {\n    let that = this,\n        x = that.x,\n        y = that.y,\n        newCoordinates;\n\n    if (that.round) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    newCoordinates = translate(x, y, that.scale);\n\n    if (newCoordinates !== that.coordinates) {\n      that.element.style[this.transformStyle] = newCoordinates;\n\n      that._saveCoordinates(newCoordinates);\n\n      that.trigger(CHANGE);\n    }\n  }\n\n  _saveCoordinates(coordinates) {\n    this.coordinates = coordinates;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}