{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1002);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  992:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./inlineformat\");\n    /***/\n  },\n\n  /***/\n  1002:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(992)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            dom = Editor.Dom,\n            RangeUtils = Editor.RangeUtils,\n            EditorUtils = Editor.EditorUtils,\n            Command = Editor.Command,\n            Tool = Editor.Tool,\n            ToolTemplate = Editor.ToolTemplate,\n            InlineFormatter = Editor.InlineFormatter,\n            InlineFormatFinder = Editor.InlineFormatFinder,\n            textNodes = RangeUtils.textNodes,\n            editableTextNodes = RangeUtils.editableTextNodes,\n            registerTool = Editor.EditorUtils.registerTool,\n            keys = kendo.keys;\n        var HTTP_PROTOCOL = \"http://\";\n        var protocolRegExp = /^\\w*:\\/\\//;\n        var endLinkCharsRegExp = /[\\w\\/\\$\\-_\\*\\?]/i;\n        var LinkFormatFinder = Class.extend({\n          findSuitable: function (sourceNode) {\n            return dom.parentOfType(sourceNode, [\"a\"]);\n          }\n        });\n        var LinkFormatter = Class.extend({\n          init: function () {\n            this.finder = new LinkFormatFinder();\n          },\n          apply: function (range, attributes) {\n            var nodes = this.immutables ? editableTextNodes(range) : textNodes(range);\n            var markers, doc, formatter, a, parent;\n\n            if (attributes.innerText) {\n              doc = RangeUtils.documentFromRange(range);\n              markers = RangeUtils.getMarkers(range);\n              range.deleteContents();\n              a = dom.create(doc, \"a\", attributes);\n              range.insertNode(a);\n              parent = a.parentNode;\n\n              if (dom.name(parent) == \"a\") {\n                dom.insertAfter(a, parent);\n              }\n\n              if (dom.emptyNode(parent)) {\n                dom.remove(parent);\n              } // move range and markers after inserted link\n\n\n              var ref = a;\n\n              for (var i = 0; i < markers.length; i++) {\n                dom.insertAfter(markers[i], ref);\n                ref = markers[i];\n              }\n\n              if (markers.length) {\n                dom.insertBefore(doc.createTextNode(\"\\ufeff\"), markers[1] || markers[0]);\n                dom.insertAfter(doc.createTextNode(\"\\ufeff\"), markers[1] || markers[0]);\n                range.setStartBefore(markers[0]);\n                range.setEndAfter(markers[markers.length - 1]);\n              }\n            } else {\n              formatter = new InlineFormatter([{\n                tags: [\"a\"]\n              }], attributes);\n              formatter.finder = this.finder;\n              formatter.apply(nodes);\n            }\n          }\n        });\n        var UnlinkCommand = Command.extend({\n          init: function (options) {\n            var that = this;\n            options.formatter =\n            /** @ignore */\n            {\n              toggle: function (range) {\n                var nodes = that.immutables() ? editableTextNodes(range) : textNodes(range);\n                new InlineFormatter([{\n                  tags: [\"a\"]\n                }]).remove(nodes);\n              }\n            };\n            this.options = options;\n            Command.fn.init.call(this, options);\n          }\n        });\n        var LinkCommand = Command.extend({\n          init: function (options) {\n            var that;\n            this.options = options;\n            Command.fn.init.call(this, options);\n            this.formatter = new LinkFormatter();\n\n            if (!options.url) {\n              this.attributes = null;\n              this.async = true;\n            } else {\n              this.exec = function () {\n                this.formatter.immutables = that && that.immutables();\n                this.formatter.apply(options.range, {\n                  href: options.url,\n                  innerText: options.text || options.url,\n                  target: options.target\n                });\n              };\n            }\n          },\n          _dialogTemplate: function () {\n            return kendo.template('<div class=\"k-editor-dialog k-popup-edit-form\">' + '<div class=\"k-edit-form-container\">' + \"<div class='k-edit-label'>\" + \"<label for='k-editor-link-url'>#: messages.linkWebAddress #</label>\" + \"</div>\" + \"<div class='k-edit-field'>\" + \"<span class=\\\"k-textbox k-input k-input-md k-rounded-md k-input-solid\\\"><input type='text' class='k-input-inner' id='k-editor-link-url'></span>\" + \"</div>\" + \"<div class='k-edit-label k-editor-link-text-row'>\" + \"<label for='k-editor-link-text'>#: messages.linkText #</label>\" + \"</div>\" + \"<div class='k-edit-field k-editor-link-text-row'>\" + \"<span class=\\\"k-textbox k-input k-input-md k-rounded-md k-input-solid\\\"><input type='text' class='k-input-inner' id='k-editor-link-text'></span>\" + \"</div>\" + \"<div class='k-edit-label'>\" + \"<label for='k-editor-link-title'>#: messages.linkToolTip #</label>\" + \"</div>\" + \"<div class='k-edit-field'>\" + \"<span class=\\\"k-textbox k-input k-input-md k-rounded-md k-input-solid\\\"><input type='text' class='k-input-inner' id='k-editor-link-title'></span>\" + \"</div>\" + \"<div class='k-edit-label'></div>\" + \"<div class='k-edit-field'>\" + \"<input type='checkbox' class='k-checkbox k-checkbox-md k-rounded-md' id='k-editor-link-target'>\" + \"<label for='k-editor-link-target' class='k-checkbox-label'>#: messages.linkOpenInNewWindow #</label>\" + \"</div>\" + \"<div class='k-edit-buttons'>\" + '<button class=\"k-dialog-insert k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary\"><span class=\"k-button-text\">#: messages.dialogInsert #</span></button>' + '<button class=\"k-dialog-close k-button k-button-md k-rounded-md k-button-solid k-button-solid-base\"><span class=\"k-button-text\">#: messages.dialogCancel #</span></button>' + \"</div>\" + \"</div>\" + \"</div>\")({\n              messages: this.editor.options.messages\n            });\n          },\n          exec: function () {\n            var messages = this.editor.options.messages;\n            this._initialText = \"\";\n            this._range = this.lockRange(true);\n            this.formatter.immutables = this.immutables();\n            var nodes = textNodes(this._range);\n            var a = nodes.length ? this.formatter.finder.findSuitable(nodes[0]) : null;\n            var img = nodes.length && dom.name(nodes[0]) == \"img\";\n            var dialog = this.createDialog(this._dialogTemplate(), {\n              title: messages.createLink,\n              close: this._close.bind(this),\n              visible: false\n            });\n\n            if (a) {\n              this._range.selectNodeContents(a);\n\n              nodes = textNodes(this._range);\n            }\n\n            this._initialText = this.linkText(nodes);\n            dialog.find(\".k-dialog-insert\").on(\"click\", this._apply.bind(this)).end().find(\".k-dialog-close\").on(\"click\", this._close.bind(this)).end().find(\".k-edit-field input\").on(\"keydown\", this._keydown.bind(this)).end().find(\"#k-editor-link-url\").val(this.linkUrl(a)).end().find(\"#k-editor-link-text\").val(this._initialText).end().find(\"#k-editor-link-title\").val(a ? a.title : \"\").end().find(\"#k-editor-link-target\").attr(\"checked\", a ? a.target == \"_blank\" : false).end().find(\".k-editor-link-text-row\").toggle(!img);\n            this._dialog = dialog.data(\"kendoWindow\").center().open();\n            $(\"#k-editor-link-url\", dialog).trigger(\"focus\").select();\n          },\n          _keydown: function (e) {\n            var keys = kendo.keys;\n\n            if (e.keyCode == keys.ENTER) {\n              this._apply(e);\n            } else if (e.keyCode == keys.ESC) {\n              this._close(e);\n            }\n          },\n          _apply: function (e) {\n            var element = this._dialog.element;\n            var href = $(\"#k-editor-link-url\", element).val();\n            var title, text, target;\n            var textInput = $(\"#k-editor-link-text\", element);\n\n            if (href && href != HTTP_PROTOCOL) {\n              if (href.indexOf(\"@\") > 0 && !/^(\\w+:)|(\\/\\/)/i.test(href)) {\n                href = \"mailto:\" + href;\n              }\n\n              this.attributes = {\n                href: href\n              };\n              title = $(\"#k-editor-link-title\", element).val();\n\n              if (title) {\n                this.attributes.title = title;\n              }\n\n              if (textInput.is(\":visible\")) {\n                text = kendo.trim(textInput.val());\n\n                if (!text && !this._initialText) {\n                  this.attributes.innerText = href;\n                } else if (text && text !== this._initialText) {\n                  this.attributes.innerText = dom.stripBom(text);\n                }\n              }\n\n              target = $(\"#k-editor-link-target\", element).is(\":checked\");\n              this.attributes.target = target ? \"_blank\" : null;\n              this.formatter.apply(this._range, this.attributes);\n            }\n\n            this._close(e);\n\n            if (this.change) {\n              this.change();\n            }\n          },\n          _close: function (e) {\n            e.preventDefault();\n\n            this._dialog.destroy();\n\n            dom.windowFromDocument(RangeUtils.documentFromRange(this._range)).focus();\n            this.releaseRange(this._range);\n          },\n          linkUrl: function (anchor) {\n            if (anchor) {\n              // IE < 8 returns absolute url if getAttribute is not used\n              return anchor.getAttribute(\"href\", 2);\n            }\n\n            return HTTP_PROTOCOL;\n          },\n          linkText: function (nodes) {\n            var text = \"\";\n            var i;\n\n            for (i = 0; i < nodes.length; i++) {\n              text += nodes[i].nodeValue;\n            }\n\n            return dom.stripBom(text || \"\");\n          },\n          redo: function () {\n            var range = this.lockRange(true);\n            this.formatter.apply(range, this.attributes);\n            this.releaseRange(range);\n          }\n        });\n        var AutoLinkCommand = Command.extend({\n          init: function (options) {\n            Command.fn.init.call(this, options);\n            this.formatter = new LinkFormatter();\n          },\n          exec: function () {\n            var detectedLink = this.detectLink();\n\n            if (!detectedLink) {\n              return;\n            }\n\n            var range = this.getRange();\n            var linkMarker = new kendo.ui.editor.Marker();\n            var linkRange = range.cloneRange();\n            linkRange.setStart(detectedLink.start.node, detectedLink.start.offset);\n            linkRange.setEnd(detectedLink.end.node, detectedLink.end.offset);\n            range = this.lockRange();\n            linkMarker.add(linkRange);\n            this.formatter.apply(linkRange, {\n              href: this._ensureWebProtocol(detectedLink.text)\n            });\n            linkMarker.remove(linkRange);\n            this.releaseRange(range);\n          },\n          detectLink: function () {\n            var range = this.getRange();\n            var startNode = range.startContainer;\n            var startOffset = range.startOffset;\n            var prev = startNode.previousSibling;\n\n            if (!prev && (dom.isBom(startNode) && !startNode.nextSibling || !startOffset && dom.isDataNode(startNode))) {\n              startNode = startNode.parentNode;\n              startOffset = 0;\n            }\n\n            var traverser = new LeftDomTextTraverser({\n              node: startNode,\n              offset: startOffset,\n              cancelAtNode: function (node) {\n                return node && dom.name(node) === \"a\";\n              }\n            });\n            var detection = new DomTextLinkDetection(traverser);\n            return detection.detectLink();\n          },\n          changesContent: function () {\n            return !!this.detectLink();\n          },\n          _ensureWebProtocol: function (linkText) {\n            var hasProtocol = this._hasProtocolPrefix(linkText);\n\n            return hasProtocol ? linkText : this._prefixWithWebProtocol(linkText);\n          },\n          _hasProtocolPrefix: function (linkText) {\n            return protocolRegExp.test(linkText);\n          },\n          _prefixWithWebProtocol: function (linkText) {\n            return HTTP_PROTOCOL + linkText;\n          }\n        });\n        var UnlinkTool = Tool.extend({\n          init: function (options) {\n            this.options = options;\n            this.finder = new InlineFormatFinder([{\n              tags: [\"a\"]\n            }]);\n            Tool.fn.init.call(this, $.extend(options, {\n              command: UnlinkCommand\n            }));\n          },\n          initialize: function (ui, options) {\n            Tool.fn.initialize.call(this, ui, options);\n            ui.addClass(\"k-disabled\");\n          },\n          update: function (ui, nodes) {\n            ui.toggleClass(\"k-disabled\", !this.finder.isFormatted(nodes)).removeClass(\"k-hover\");\n          }\n        });\n        var DomTextLinkDetection = Class.extend({\n          init: function (traverser) {\n            this.traverser = traverser;\n            this.start = DomPos();\n            this.end = DomPos();\n            this.text = \"\";\n          },\n          detectLink: function () {\n            var node = this.traverser.node;\n            var offset = this.traverser.offset;\n\n            if (dom.isDataNode(node)) {\n              var text = node.data.substring(0, offset);\n\n              if (/\\s{2}$/.test(dom.stripBom(text))) {\n                return;\n              }\n            } else if (offset === 0) {\n              //heuristic for new line\n              var p = dom.closestEditableOfType(node, dom.blockElements);\n\n              if (p && p.previousSibling) {\n                this.traverser.init({\n                  node: p.previousSibling\n                });\n              }\n            }\n\n            this.traverser.traverse(this._detectEnd.bind(this));\n\n            if (!this.end.blank()) {\n              this.traverser = this.traverser.clone(this.end);\n              this.traverser.traverse(this._detectStart.bind(this));\n\n              if (!this._isLinkDetected()) {\n                var puntuationOptions = this.traverser.extendOptions(this.start);\n                var puntuationTraverser = new RightDomTextTraverser(puntuationOptions);\n                puntuationTraverser.traverse(this._skipStartPuntuation.bind(this));\n\n                if (!this._isLinkDetected()) {\n                  this.start = DomPos();\n                }\n              }\n            }\n\n            if (this.start.blank()) {\n              return null;\n            } else {\n              return {\n                start: this.start,\n                end: this.end,\n                text: this.text\n              };\n            }\n          },\n          _isLinkDetected: function () {\n            return protocolRegExp.test(this.text) || /^w{3}\\./i.test(this.text);\n          },\n          _detectEnd: function (text, node) {\n            var i = lastIndexOfRegExp(text, endLinkCharsRegExp);\n\n            if (i > -1) {\n              this.end.node = node;\n              this.end.offset = i + 1;\n              return false;\n            }\n          },\n          _detectStart: function (text, node) {\n            var i = lastIndexOfRegExp(text, /\\s/);\n            var ii = i + 1;\n            this.text = text.substring(ii) + this.text;\n            this.start.node = node;\n            this.start.offset = ii;\n\n            if (i > -1) {\n              return false;\n            }\n          },\n          _skipStartPuntuation: function (text, node, offset) {\n            var i = indexOfRegExp(text, /\\w/);\n            var ii = i;\n\n            if (i === -1) {\n              ii = text.length;\n            }\n\n            this.text = this.text.substring(ii);\n            this.start.node = node;\n            this.start.offset = ii + (offset | 0);\n\n            if (i > -1) {\n              return false;\n            }\n          }\n        });\n\n        function lastIndexOfRegExp(str, search) {\n          var i = str.length;\n\n          while (i-- && !search.test(str[i])) {}\n\n          return i;\n        }\n\n        function indexOfRegExp(str, search) {\n          var r = search.exec(str);\n          return r ? r.index : -1;\n        }\n\n        var DomPos = function () {\n          return {\n            node: null,\n            offset: null,\n            blank: function () {\n              return this.node === null && this.offset === null;\n            }\n          };\n        };\n\n        var DomTextTraverser = Class.extend({\n          init: function (options) {\n            this.node = options.node;\n            this.offset = options.offset === undefined ? dom.isDataNode(this.node) && this.node.length || 0 : options.offset;\n            this.cancelAtNode = options.cancelAtNode || this.cancelAtNode || $.noop;\n          },\n          traverse: function (callback) {\n            if (!callback) {\n              return;\n            }\n\n            this.cancel = false;\n\n            this._traverse(callback, this.node, this.offset);\n          },\n          _traverse: function (callback, node, offset) {\n            if (!node || this.cancel) {\n              return;\n            }\n\n            if (node.nodeType === 3) {\n              var text = node.data;\n\n              if (offset !== undefined) {\n                text = this.subText(text, offset);\n              }\n\n              this.cancel = callback(text, node, offset) === false;\n            } else {\n              var edgeNode = this.edgeNode(node);\n              this.cancel = this.cancel || this.cancelAtNode(edgeNode);\n              return this._traverse(callback, edgeNode);\n            }\n\n            var next = this.next(node);\n\n            if (!next) {\n              var parent = node.parentNode;\n\n              while (!next && dom.isInline(parent)) {\n                next = this.next(parent);\n                parent = parent.parentNode;\n              }\n            }\n\n            this.cancel = this.cancel || this.cancelAtNode(next);\n\n            this._traverse(callback, next);\n          },\n          extendOptions: function (o) {\n            return $.extend({\n              node: this.node,\n              offset: this.offset,\n              cancelAtNode: this.cancelAtNode\n            }, o || {});\n          },\n          edgeNode: function (node) {},\n          //jshint ignore: line\n          next: function (node) {},\n          //jshint ignore: line\n          subText: function (text, offset) {} //jshint ignore: line\n\n        });\n        var LeftDomTextTraverser = DomTextTraverser.extend({\n          subText: function (text, splitIndex) {\n            return text.substring(0, splitIndex);\n          },\n          next: function (node) {\n            return node.previousSibling;\n          },\n          edgeNode: function (node) {\n            return node.lastChild;\n          },\n          clone: function (options) {\n            var o = this.extendOptions(options);\n            return new LeftDomTextTraverser(o);\n          }\n        });\n        var RightDomTextTraverser = DomTextTraverser.extend({\n          subText: function (text, splitIndex) {\n            return text.substring(splitIndex);\n          },\n          next: function (node) {\n            return node.nextSibling;\n          },\n          edgeNode: function (node) {\n            return node.firstChild;\n          },\n          clone: function (options) {\n            var o = this.extendOptions(options);\n            return new RightDomTextTraverser(o);\n          }\n        });\n        extend(kendo.ui.editor, {\n          LinkFormatFinder: LinkFormatFinder,\n          LinkFormatter: LinkFormatter,\n          UnlinkCommand: UnlinkCommand,\n          LinkCommand: LinkCommand,\n          AutoLinkCommand: AutoLinkCommand,\n          UnlinkTool: UnlinkTool,\n          DomTextLinkDetection: DomTextLinkDetection,\n          LeftDomTextTraverser: LeftDomTextTraverser,\n          RightDomTextTraverser: RightDomTextTraverser\n        });\n        registerTool(\"createLink\", new Tool({\n          key: \"K\",\n          ctrl: true,\n          command: LinkCommand,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Create Link\"\n          })\n        }));\n        registerTool(\"unlink\", new UnlinkTool({\n          key: \"K\",\n          ctrl: true,\n          shift: true,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Remove Link\"\n          })\n        }));\n        registerTool(\"autoLink\", new Tool({\n          key: [keys.ENTER, keys.SPACEBAR],\n          keyPressCommand: true,\n          command: AutoLinkCommand\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}