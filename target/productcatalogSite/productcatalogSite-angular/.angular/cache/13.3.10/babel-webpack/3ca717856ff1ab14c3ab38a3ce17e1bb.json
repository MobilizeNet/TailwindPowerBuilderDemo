{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1497);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1060:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"jquery\");\n    /***/\n  },\n\n  /***/\n  1063:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data\");\n    /***/\n  },\n\n  /***/\n  1103:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.html.input\");\n    /***/\n  },\n\n  /***/\n  1294:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.treeview.draganddrop\");\n    /***/\n  },\n\n  /***/\n  1497:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /* WEBPACK VAR INJECTION */\n\n\n    (function (jQuery) {\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1063), __webpack_require__(1294), __webpack_require__(1103)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        var __meta__ = {\n          // jshint ignore:line\n          id: \"treeview\",\n          name: \"TreeView\",\n          category: \"web\",\n          description: \"The TreeView widget displays hierarchical data in a traditional tree structure,with support for interactive drag-and-drop operations.\",\n          depends: [\"data\", \"html.input\"],\n          features: [{\n            id: \"treeview-dragging\",\n            name: \"Drag & Drop\",\n            description: \"Support for drag & drop\",\n            depends: [\"treeview.draganddrop\"]\n          }]\n        };\n        /*jshint eqnull: true */\n\n        (function ($, undefined) {\n          var kendo = window.kendo,\n              ui = kendo.ui,\n              data = kendo.data,\n              extend = $.extend,\n              template = kendo.template,\n              isArray = Array.isArray,\n              Widget = ui.Widget,\n              HierarchicalDataSource = data.HierarchicalDataSource,\n              keys = kendo.keys,\n              NS = \".kendoTreeView\",\n              TEMP_NS = \".kendoTreeViewTemp\",\n              SELECT = \"select\",\n              CHECK = \"check\",\n              NAVIGATE = \"navigate\",\n              EXPAND = \"expand\",\n              CHANGE = \"change\",\n              ERROR = \"error\",\n              CHECKED = \"checked\",\n              INDETERMINATE = \"indeterminate\",\n              COLLAPSE = \"collapse\",\n              DRAGSTART = \"dragstart\",\n              DRAG = \"drag\",\n              DROP = \"drop\",\n              DRAGEND = \"dragend\",\n              DATABOUND = \"dataBound\",\n              ITEMSLOADED = \"itemsLoaded\",\n              LOADCOMPLETED = \"loadCompleted\",\n              CLICK = \"click\",\n              KENDOKEYDOWN = \"kendoKeydown\",\n              UNDEFINED = \"undefined\",\n              KSTATEHOVER = \"k-hover\",\n              KTREEVIEW = \"k-treeview\",\n              VISIBLE = \":visible\",\n              NODE = \".k-item\",\n              STRING = \"string\",\n              ARIACHECKED = \"aria-checked\",\n              ARIASELECTED = \"aria-selected\",\n              ARIADISABLED = \"aria-disabled\",\n              ARIAEXPANDED = \"aria-expanded\",\n              DISABLED = \"k-disabled\",\n              TreeView,\n              subGroup,\n              nodeContents,\n              nodeIcon,\n              spriteRe,\n              bindings = {\n            text: \"dataTextField\",\n            url: \"dataUrlField\",\n            spriteCssClass: \"dataSpriteCssClassField\",\n            imageUrl: \"dataImageUrlField\"\n          },\n              isJQueryInstance = function (obj) {\n            return obj instanceof kendo.jQuery || window.jQuery && obj instanceof window.jQuery;\n          },\n              isDomElement = function (o) {\n            return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n            o && typeof o === \"object\" && o.nodeType === 1 && typeof o.nodeName === STRING;\n          };\n\n          function contentChild(filter) {\n            return function (node) {\n              var result = node.children(\".k-animation-container\");\n\n              if (!result.length) {\n                result = node;\n              }\n\n              return result.children(filter);\n            };\n          }\n\n          function templateNoWith(code) {\n            return kendo.template(code, {\n              useWithBlock: false\n            });\n          }\n\n          subGroup = contentChild(\".k-group\");\n          nodeContents = contentChild(\".k-group,.k-content\");\n\n          nodeIcon = function (node) {\n            return node.children(\"div\").find(\".k-treeview-toggle > .k-icon\");\n          };\n\n          function checkboxes(node) {\n            return node.find(\".k-checkbox-wrapper:first input[type=checkbox]\");\n          }\n\n          function insertAction(indexOffset) {\n            return function (nodeData, referenceNode) {\n              referenceNode = referenceNode.closest(NODE);\n              var group = referenceNode.parent(),\n                  parentNode;\n\n              if (group.parent().is(\"li\")) {\n                parentNode = group.parent();\n              }\n\n              return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model) {\n                var referenceItem = this.dataItem(referenceNode);\n                var referenceNodeIndex = referenceItem ? referenceItem.parent().indexOf(referenceItem) : referenceNode.index();\n                return this._insert(dataSource.data(), model, referenceNodeIndex + indexOffset);\n              });\n            };\n          }\n\n          spriteRe = /k-sprite/;\n\n          function moveContents(node, container) {\n            var tmp;\n\n            while (node && node.nodeName.toLowerCase() != \"ul\") {\n              tmp = node;\n              node = node.nextSibling;\n\n              if (tmp.nodeType == 3) {\n                tmp.nodeValue = kendo.trim(tmp.nodeValue);\n              }\n\n              if (spriteRe.test(tmp.className)) {\n                container.insertBefore(tmp, container.firstChild);\n              } else {\n                container.appendChild(tmp);\n              }\n            }\n          }\n\n          function updateNodeHtml(node) {\n            var wrapper = node.children(\"div\"),\n                group = node.children(\"ul\"),\n                toggleButton = wrapper.find(\".k-treeview-toggle > .k-icon\"),\n                checkbox = node.children(\"input[type=checkbox]\"),\n                innerWrapper = wrapper.children(\".k-in\");\n\n            if (node.hasClass(\"k-treeview\")) {\n              return;\n            }\n\n            if (!wrapper.length) {\n              wrapper = $(\"<div />\").prependTo(node);\n            }\n\n            if (!toggleButton.length && group.length) {\n              toggleButton = $(\"<span class='k-treeview-toggle'><span class='k-icon' /></span>\").prependTo(wrapper);\n            } else if (!group.length || !group.children().length) {\n              toggleButton.parent().remove();\n              group.remove();\n            }\n\n            if (checkbox.length) {\n              $(\"<span class='k-checkbox-wrapper' />\").appendTo(wrapper).append(checkbox);\n            }\n\n            if (!innerWrapper.length) {\n              innerWrapper = node.children(\"a\").eq(0).addClass(\"k-in k-link\");\n\n              if (!innerWrapper.length) {\n                innerWrapper = $(\"<span class='k-treeview-leaf k-in' />\");\n              }\n\n              innerWrapper.appendTo(wrapper);\n\n              if (wrapper.length) {\n                moveContents(wrapper[0].nextSibling, innerWrapper[0]);\n              }\n            }\n          }\n\n          TreeView = kendo.ui.DataBoundWidget.extend({\n            init: function (element, options) {\n              var that = this,\n                  inferred = false,\n                  hasDataSource = options && !!options.dataSource,\n                  list;\n\n              if (isArray(options)) {\n                options = {\n                  dataSource: options\n                };\n              }\n\n              if (options && typeof options.loadOnDemand == UNDEFINED && isArray(options.dataSource)) {\n                options.loadOnDemand = false;\n              }\n\n              Widget.prototype.init.call(that, element, options);\n              element = that.element;\n              options = that.options;\n              that._dataSourceUids = {};\n              list = element.is(\"ul\") && element || element.hasClass(KTREEVIEW) && element.children(\"ul\");\n              inferred = !hasDataSource && list.length;\n\n              if (inferred) {\n                options.dataSource.list = list;\n              }\n\n              that._animation();\n\n              that._accessors();\n\n              that._templates(); // render treeview if it's not already rendered\n\n\n              if (!element.hasClass(KTREEVIEW)) {\n                that._wrapper();\n\n                if (list) {\n                  that.root = element;\n\n                  that._group(that.wrapper);\n                }\n              } else {\n                // otherwise just initialize properties\n                that.wrapper = element;\n                that.root = element.children(\"ul\").eq(0);\n              }\n\n              that._applyCssClasses();\n\n              that._tabindex();\n\n              that.wrapper.attr(\"role\", \"tree\");\n              that.wrapper.find(\">ul\").attr(\"role\", \"none\");\n\n              that._dataSource(inferred);\n\n              that._attachEvents();\n\n              that._dragging();\n\n              if (!inferred) {\n                if (options.autoBind) {\n                  that._progress(true);\n\n                  that.dataSource.fetch(this._attemptLoadCompleted.bind(this));\n                }\n              } else {\n                that._syncHtmlAndDataSource();\n              }\n\n              if (options.checkboxes && options.checkboxes.checkChildren) {\n                that.updateIndeterminate();\n              }\n\n              if (that.element[0].id) {\n                that._ariaId = kendo.format(\"{0}_tv_active\", that.element[0].id);\n              } else {\n                that._ariaId = kendo.guid() + \"_tv_active\";\n              }\n\n              kendo.notify(that);\n            },\n            _attachEvents: function () {\n              var that = this,\n                  clickableItems = \".k-in:not(.k-selected,.k-disabled)\",\n                  MOUSEENTER = \"mouseenter\";\n              that._clickHandler = that._click.bind(that);\n              that.wrapper.on(MOUSEENTER + NS, \".k-in.k-selected\", function (e) {\n                e.preventDefault();\n              }).on(MOUSEENTER + NS, clickableItems, function () {\n                $(this).addClass(KSTATEHOVER);\n              }).on(\"mouseleave\" + NS, clickableItems, function () {\n                $(this).removeClass(KSTATEHOVER);\n              }).on(CLICK + NS, clickableItems, that._clickHandler).on(\"dblclick\" + NS, \".k-in:not(.k-disabled)\", that._toggleButtonClick.bind(that)).on(CLICK + NS, \".k-i-expand,.k-i-collapse\", that._toggleButtonClick.bind(that)).on(\"keydown\" + NS, that, that._keydown.bind(that)).on(\"keypress\" + NS, that._keypress.bind(that)).on(\"focus\" + NS, that._focus.bind(that)).on(\"blur\" + NS, that._blur.bind(that)).on(\"mousedown\" + NS, \".k-in,.k-checkbox-wrapper :checkbox,.k-i-expand,.k-i-collapse\", that._mousedown.bind(that)).on(\"change\" + NS, \".k-checkbox-wrapper :checkbox\", that._checkboxChange.bind(that)).on(\"click\" + NS, \".k-request-retry\", that._retryRequest.bind(that)).on(\"click\" + NS, \".k-link.k-disabled\", function (e) {\n                e.preventDefault();\n              }).on(\"click\" + NS, function (e) {\n                var target = $(e.target);\n\n                if (!target.is(\":kendoFocusable\") && !target.find(\"input,select,textarea,button,object\").is(\":kendoFocusable\")) {\n                  that.focus();\n                }\n              });\n            },\n            _syncHtmlAndDataSource: function (root, dataSource) {\n              root = root || this.root;\n              dataSource = dataSource || this.dataSource;\n              var data = dataSource.view(),\n                  uidAttr = kendo.attr(\"uid\"),\n                  expandedAttr = kendo.attr(\"expanded\"),\n                  checkboxesEnabled = this.options.checkboxes,\n                  items = root.children(\"li\"),\n                  i,\n                  item,\n                  dataItem,\n                  uid,\n                  itemCheckbox;\n\n              for (i = 0; i < items.length; i++) {\n                dataItem = data[i];\n                uid = dataItem.uid;\n                item = items.eq(i);\n                item.attr(\"role\", \"treeitem\").attr(uidAttr, uid).attr(ARIASELECTED, item.hasClass(\"k-selected\"));\n                dataItem.expanded = item.attr(expandedAttr) === \"true\";\n\n                if (checkboxesEnabled) {\n                  itemCheckbox = checkboxes(item);\n                  dataItem.checked = itemCheckbox.prop(CHECKED);\n                  itemCheckbox.attr(\"id\", \"_\" + uid);\n                  itemCheckbox.next(\".k-checkbox-label\").attr(\"for\", \"_\" + uid);\n                }\n\n                this._syncHtmlAndDataSource(item.children(\"ul\"), dataItem.children);\n              }\n            },\n            _animation: function () {\n              var options = this.options,\n                  animationOptions = options.animation,\n                  hasCollapseAnimation = animationOptions.collapse && \"effects\" in animationOptions.collapse,\n                  collapse = extend({}, animationOptions.expand, animationOptions.collapse);\n\n              if (!hasCollapseAnimation) {\n                collapse = extend(collapse, {\n                  reverse: true\n                });\n              }\n\n              if (animationOptions === false) {\n                animationOptions = {\n                  expand: {\n                    effects: {}\n                  },\n                  collapse: {\n                    hide: true,\n                    effects: {}\n                  }\n                };\n              }\n\n              animationOptions.collapse = extend(collapse, {\n                hide: true\n              });\n              options.animation = animationOptions;\n            },\n            _dragging: function () {\n              var enabled = this.options.dragAndDrop;\n              var dragging = this.dragging;\n\n              if (enabled && !dragging) {\n                var widget = this;\n                this.dragging = new ui.HierarchicalDragAndDrop(this.element, {\n                  reorderable: true,\n                  $angular: this.options.$angular,\n                  autoScroll: this.options.autoScroll,\n                  filter: \"div:not(.k-disabled) .k-in\",\n                  allowedContainers: \".k-treeview\",\n                  itemSelector: \".k-treeview .k-item\",\n                  hintText: this._hintText.bind(this),\n                  contains: function (source, destination) {\n                    return $.contains(source, destination);\n                  },\n                  dropHintContainer: function (item) {\n                    return item;\n                  },\n                  itemFromTarget: function (target) {\n                    var item = target.closest(\".k-treeview-top,.k-treeview-mid,.k-treeview-bot\");\n                    return {\n                      item: item,\n                      content: target.closest(\".k-in\"),\n                      first: item.hasClass(\"k-treeview-top\"),\n                      last: item.hasClass(\"k-treeview-bot\")\n                    };\n                  },\n                  dropPositionFrom: function (dropHint) {\n                    return dropHint.prevAll(\".k-in\").length > 0 ? \"after\" : \"before\";\n                  },\n                  dragstart: function (source) {\n                    return widget.trigger(DRAGSTART, {\n                      sourceNode: source[0]\n                    });\n                  },\n                  drag: function (options) {\n                    widget.trigger(DRAG, {\n                      originalEvent: options.originalEvent,\n                      sourceNode: options.source[0],\n                      dropTarget: options.target[0],\n                      pageY: options.pageY,\n                      pageX: options.pageX,\n                      statusClass: options.status,\n                      setStatusClass: options.setStatus\n                    });\n                  },\n                  drop: function (options) {\n                    var dropTarget = $(options.dropTarget);\n                    var navigationTarget = dropTarget.closest(\"a\");\n\n                    if (navigationTarget && navigationTarget.attr(\"href\")) {\n                      widget._tempPreventNavigation(navigationTarget);\n                    }\n\n                    return widget.trigger(DROP, {\n                      originalEvent: options.originalEvent,\n                      sourceNode: options.source,\n                      destinationNode: options.destination,\n                      valid: options.valid,\n                      setValid: function (state) {\n                        this.valid = state;\n                        options.setValid(state);\n                      },\n                      dropTarget: options.dropTarget,\n                      dropPosition: options.position\n                    });\n                  },\n                  dragend: function (options) {\n                    var source = options.source;\n                    var destination = options.destination;\n                    var position = options.position;\n\n                    function triggerDragEnd(source) {\n                      if (widget.options.checkboxes && widget.options.checkboxes.checkChildren) {\n                        widget.updateIndeterminate();\n                      }\n\n                      widget.current(source);\n                      widget.element.focus();\n                      widget.trigger(DRAGEND, {\n                        originalEvent: options.originalEvent,\n                        sourceNode: source && source[0],\n                        destinationNode: destination[0],\n                        dropPosition: position\n                      });\n                    } // perform reorder / move\n                    // different handling is necessary because append might be async in remote bound tree\n\n\n                    if (position == \"over\") {\n                      widget.append(source, destination, triggerDragEnd);\n                    } else {\n                      if (position == \"before\") {\n                        source = widget.insertBefore(source, destination);\n                      } else if (position == \"after\") {\n                        source = widget.insertAfter(source, destination);\n                      }\n\n                      triggerDragEnd(source);\n                    }\n                  }\n                });\n              } else if (!enabled && dragging) {\n                dragging.destroy();\n                this.dragging = null;\n              }\n            },\n            _tempPreventNavigation: function (node) {\n              node.on(CLICK + NS + TEMP_NS, function (ev) {\n                ev.preventDefault();\n                node.off(CLICK + NS + TEMP_NS);\n              });\n            },\n            _hintText: function (node) {\n              return this.templates.dragClue({\n                item: this.dataItem(node),\n                treeview: this.options\n              });\n            },\n            _templates: function () {\n              var that = this,\n                  options = that.options,\n                  fieldAccessor = that._fieldAccessor.bind(that);\n\n              if (options.template && typeof options.template == STRING) {\n                options.template = template(options.template);\n              } else if (!options.template) {\n                options.template = templateNoWith(\"# var text = \" + fieldAccessor(\"text\") + \"(data.item); #\" + \"# if (typeof data.item.encoded != 'undefined' && data.item.encoded === false) {#\" + \"<span class='k-treeview-leaf-text'>#= text #</span>\" + \"# } else { #\" + \"<span class='k-treeview-leaf-text'>#: text #</span>\" + \"# } #\");\n              }\n\n              that._checkboxes();\n\n              that.templates = {\n                setAttributes: function (item) {\n                  var result = \"\";\n                  var attributes = item.attr || {};\n\n                  for (var attr in attributes) {\n                    if (attributes.hasOwnProperty(attr) && attr !== \"class\") {\n                      result += attr + \"=\\\"\" + attributes[attr] + \"\\\" \";\n                    }\n                  }\n\n                  return result;\n                },\n                wrapperCssClass: function (group, item) {\n                  var result = \"k-item k-treeview-item\",\n                      index = item.index;\n\n                  if (group.firstLevel && index === 0) {\n                    result += \" k-first\";\n                  }\n\n                  if (index == group.length - 1) {\n                    result += \" k-last\";\n                  }\n\n                  return result;\n                },\n                cssClass: function (group, item) {\n                  var result = \"\",\n                      index = item.index,\n                      groupLength = group.length - 1;\n\n                  if (group.firstLevel && index === 0) {\n                    result += \"k-treeview-top \";\n                  }\n\n                  if (index === 0 && index != groupLength) {\n                    result += \"k-treeview-top\";\n                  } else if (index == groupLength) {\n                    result += \"k-treeview-bot\";\n                  } else {\n                    result += \"k-treeview-mid\";\n                  }\n\n                  return result;\n                },\n                textClass: function (item, isLink) {\n                  var result = \"k-treeview-leaf k-in\";\n\n                  if (isLink) {\n                    result += \" k-link\";\n                  }\n\n                  if (item.enabled === false) {\n                    result += \" k-disabled\";\n                  }\n\n                  if (item.selected === true) {\n                    result += \" k-selected\";\n                  }\n\n                  return result;\n                },\n                toggleButtonClass: function (item) {\n                  var result = \"k-icon\";\n\n                  if (item.expanded !== true) {\n                    result += \" k-i-expand\";\n                  } else {\n                    result += \" k-i-collapse\";\n                  }\n\n                  return result;\n                },\n                groupAttributes: function (group) {\n                  var attributes = \"\";\n\n                  if (!group.firstLevel) {\n                    attributes = \"role='group'\";\n                  }\n\n                  return attributes + (group.expanded !== true ? \" style='display:none'\" : \"\");\n                },\n                groupCssClass: function (group) {\n                  var cssClass = \"k-group k-treeview-group\";\n\n                  if (group.firstLevel) {\n                    cssClass += \" k-treeview-lines\";\n                  }\n\n                  return cssClass;\n                },\n                dragClue: templateNoWith(\"#= data.treeview.template(data) #\"),\n                group: templateNoWith(\"<ul class='#= data.r.groupCssClass(data.group) #'#= data.r.groupAttributes(data.group) #>\" + \"#= data.renderItems(data) #\" + \"</ul>\"),\n                itemContent: templateNoWith(\"# var imageUrl = \" + fieldAccessor(\"imageUrl\") + \"(data.item); #\" + \"# var spriteCssClass = \" + fieldAccessor(\"spriteCssClass\") + \"(data.item); #\" + \"# if (imageUrl) { #\" + \"<img class='k-image' alt='' src='#= imageUrl #'>\" + \"# } #\" + \"# if (spriteCssClass) { #\" + \"<span class='k-sprite #= spriteCssClass #'></span>\" + \"# } #\" + \"#= data.treeview.template(data) #\"),\n                itemElement: templateNoWith(\"# var item = data.item, r = data.r; #\" + \"# var url = \" + fieldAccessor(\"url\") + \"(item); #\" + \"<div class='#= r.cssClass(data.group, item) #'>\" + \"# if (item.hasChildren) { #\" + \"<span class='k-treeview-toggle'>\" + \"<span class='#= r.toggleButtonClass(item) #'></span>\" + \"</span>\" + \"# } #\" + \"# if (data.treeview.checkboxes) { #\" + \"<span class='k-checkbox-wrapper' role='presentation'>\" + \"#= data.treeview.checkboxes.template(data) #\" + \"</span>\" + \"# } #\" + \"# var tag = url ? 'a' : 'span'; #\" + \"# var textAttr = url ? ' href=\\\\'' + url + '\\\\'' : ''; #\" + \"<#=tag# class='#= r.textClass(item, !!url) #'#= textAttr #>\" + \"#= r.itemContent(data) #\" + \"</#=tag#>\" + \"</div>\"),\n                item: templateNoWith(\"# var item = data.item, r = data.r; #\" + \"<li role='treeitem' class='#= r.wrapperCssClass(data.group, item) #'\" + kendo.attr(\"uid\") + \"='#= item.uid #' \" + \"#= r.setAttributes(item.toJSON ? item.toJSON() : item) # \" + \"# if (data.treeview.checkboxes) { #\" + \"aria-checked='#= item.checked ? \\\"true\\\" : \\\"false\\\" #' \" + \"# } #\" + \"aria-selected='#= item.selected ? \\\"true\\\" : \\\"false\\\" #' \" + \"#=item.enabled === false ? \\\"aria-disabled='true'\\\" : ''#\" + \"aria-expanded='#= item.expanded ? \\\"true\\\" : \\\"false\\\" #' \" + \"data-expanded='#= item.expanded ? \\\"true\\\" : \\\"false\\\" #' \" + \">\" + \"#= r.itemElement(data) #\" + \"</li>\"),\n                loading: templateNoWith(\"<div class='k-icon k-i-loading'></div> #: data.messages.loading #\"),\n                retry: templateNoWith(\"#: data.messages.requestFailed # \" + \"<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-request-retry'><span class='k-button-text'>#: data.messages.retry #</span></button>\")\n              };\n            },\n            items: function () {\n              return this.element.find(\".k-item > div:first-child\");\n            },\n            setDataSource: function (dataSource) {\n              var options = this.options;\n              options.dataSource = dataSource;\n              this._dataSourceUids = {};\n\n              this._dataSource();\n\n              if (options.checkboxes && options.checkboxes.checkChildren) {\n                this.dataSource.one(\"change\", this.updateIndeterminate.bind(this, null));\n              }\n\n              if (this.options.autoBind) {\n                this.dataSource.fetch(this._attemptLoadCompleted.bind(this));\n              }\n            },\n            _bindDataSource: function () {\n              var that = this;\n              that._refreshHandler = that.refresh.bind(that);\n              that._errorHandler = that._error.bind(that);\n              that._loadCompletedHandler = that._loadCompleted.bind(that);\n              that._loadedNodes = [];\n              that.dataSource.bind(CHANGE, that._refreshHandler);\n              that.dataSource.bind(ERROR, that._errorHandler);\n              that.dataSource.bind(ITEMSLOADED, that._loadCompletedHandler);\n            },\n            _loadCompleted: function (e) {\n              var that = this;\n              that._loadedNodes = that._loadedNodes.concat(e.nodes);\n\n              if (!that.dataSource.loading() && that.options.loadOnDemand === false) {\n                that.trigger(LOADCOMPLETED, {\n                  nodes: that._loadedNodes\n                });\n                that._loadedNodes = [];\n              }\n            },\n            _attemptLoadCompleted: function () {\n              // If there are no items to be loaded ensure event is triggered on dataBound\n              var that = this,\n                  items = that.dataSource.view();\n\n              if (that.options.loadOnDemand === false) {\n                for (var i = 0; i < items.length; i++) {\n                  if (items[i].hasChildren) {\n                    return;\n                  }\n                }\n\n                that.trigger(LOADCOMPLETED, {\n                  nodes: []\n                });\n              }\n            },\n            _unbindDataSource: function () {\n              var dataSource = this.dataSource;\n\n              if (dataSource) {\n                dataSource.unbind(CHANGE, this._refreshHandler);\n                dataSource.unbind(ERROR, this._errorHandler);\n                dataSource.unbind(ITEMSLOADED, this._loadCompletedHandler);\n              }\n            },\n            _dataSource: function (silentRead) {\n              var that = this,\n                  options = that.options,\n                  dataSource = options.dataSource;\n\n              function recursiveRead(data) {\n                for (var i = 0; i < data.length; i++) {\n                  data[i]._initChildren();\n\n                  data[i].children.fetch();\n                  recursiveRead(data[i].children.view());\n                }\n              }\n\n              dataSource = isArray(dataSource) ? {\n                data: dataSource\n              } : dataSource;\n\n              that._unbindDataSource();\n\n              if (!dataSource.fields) {\n                dataSource.fields = [{\n                  field: \"text\"\n                }, {\n                  field: \"url\"\n                }, {\n                  field: \"spriteCssClass\"\n                }, {\n                  field: \"imageUrl\"\n                }];\n              }\n\n              that.dataSource = dataSource = HierarchicalDataSource.create(dataSource);\n\n              if (silentRead) {\n                dataSource.fetch();\n                recursiveRead(dataSource.view());\n              }\n\n              that._bindDataSource();\n            },\n            events: [DRAGSTART, DRAG, DROP, DRAGEND, DATABOUND, LOADCOMPLETED, EXPAND, COLLAPSE, SELECT, CHANGE, NAVIGATE, CHECK, KENDOKEYDOWN],\n            options: {\n              name: \"TreeView\",\n              dataSource: {},\n              animation: {\n                expand: {\n                  effects: \"expand:vertical\",\n                  duration: 200\n                },\n                collapse: {\n                  duration: 100\n                }\n              },\n              messages: {\n                loading: \"Loading...\",\n                requestFailed: \"Request failed.\",\n                retry: \"Retry\"\n              },\n              dragAndDrop: false,\n              checkboxes: false,\n              autoBind: true,\n              autoScroll: false,\n              loadOnDemand: true,\n              template: \"\",\n              dataTextField: null,\n              size: \"medium\"\n            },\n            _accessors: function () {\n              var that = this,\n                  options = that.options,\n                  i,\n                  field,\n                  textField,\n                  element = that.element;\n\n              for (i in bindings) {\n                field = options[bindings[i]];\n                textField = element.attr(kendo.attr(i + \"-field\"));\n\n                if (!field && textField) {\n                  field = textField;\n                }\n\n                if (!field) {\n                  field = i;\n                }\n\n                if (!isArray(field)) {\n                  field = [field];\n                }\n\n                options[bindings[i]] = field;\n              }\n            },\n            // generates accessor function for a given field name, honoring the data*Field arrays\n            _fieldAccessor: function (fieldName) {\n              var fieldBindings = this.options[bindings[fieldName]],\n                  count = fieldBindings.length,\n                  result = \"(function(item) {\";\n\n              if (count === 0) {\n                result += \"return item['\" + fieldName + \"'];\";\n              } else {\n                result += \"var levels = [\" + $.map(fieldBindings, function (x) {\n                  return \"function(d){ return \" + kendo.expr(x) + \"}\";\n                }).join(\",\") + \"];\";\n                result += \"return levels[Math.min(item.level(), \" + count + \"-1)](item)\";\n              }\n\n              result += \"})\";\n              return result;\n            },\n            setOptions: function (options) {\n              Widget.fn.setOptions.call(this, options);\n\n              this._animation();\n\n              this._dragging();\n\n              this._templates();\n            },\n            _trigger: function (eventName, node) {\n              return this.trigger(eventName, {\n                node: node.closest(NODE)[0]\n              });\n            },\n            _setChecked: function (datasource, value) {\n              if (!datasource || !kendo.isFunction(datasource.view)) {\n                return;\n              }\n\n              for (var i = 0, nodes = datasource.view(); i < nodes.length; i++) {\n                if (nodes[i].enabled !== false) {\n                  this._setCheckedValue(nodes[i], value);\n                }\n\n                if (nodes[i].children) {\n                  this._setChecked(nodes[i].children, value);\n                }\n              }\n            },\n            _setCheckedValue: function (node, value) {\n              node[CHECKED] = value;\n            },\n            _setIndeterminate: function (node) {\n              var group = subGroup(node),\n                  siblings,\n                  length,\n                  all = true,\n                  i;\n\n              if (!group.length) {\n                return;\n              }\n\n              siblings = checkboxes(group.children());\n              length = siblings.length;\n\n              if (!length) {\n                return;\n              } else if (length > 1) {\n                for (i = 1; i < length; i++) {\n                  if (siblings[i].checked != siblings[i - 1].checked || siblings[i].indeterminate || siblings[i - 1].indeterminate) {\n                    all = false;\n                    break;\n                  }\n                }\n              } else {\n                all = !siblings[0].indeterminate;\n              }\n\n              node.attr(ARIACHECKED, all ? siblings[0].checked : \"mixed\");\n              return checkboxes(node).data(INDETERMINATE, !all).prop(INDETERMINATE, !all).prop(CHECKED, all && siblings[0].checked);\n            },\n            updateIndeterminate: function (node) {\n              // top-down update of inital indeterminate state for all nodes\n              node = node || this.wrapper;\n              var subnodes = subGroup(node).children();\n              var i;\n              var checkbox;\n              var dataItem;\n\n              if (subnodes.length) {\n                for (i = 0; i < subnodes.length; i++) {\n                  this.updateIndeterminate(subnodes.eq(i));\n                }\n\n                if (node.is(\".k-treeview\")) {\n                  return;\n                }\n\n                checkbox = this._setIndeterminate(node);\n                dataItem = this.dataItem(node);\n\n                if (checkbox && checkbox.prop(CHECKED)) {\n                  dataItem.checked = true;\n                } else {\n                  if (dataItem) {\n                    delete dataItem.checked;\n                  }\n                }\n              }\n            },\n            _bubbleIndeterminate: function (node, skipDownward) {\n              // bottom-up setting of indeterminate state of parent nodes\n              if (!node.length) {\n                return;\n              }\n\n              if (!skipDownward) {\n                //update the indeterminate state of the node itself\n                this.updateIndeterminate(node);\n              }\n\n              var parentNode = this.parent(node),\n                  checkbox;\n\n              if (parentNode.length) {\n                this._setIndeterminate(parentNode);\n\n                checkbox = parentNode.children(\"div\").find(\".k-checkbox-wrapper input[type=checkbox]\");\n                this._skip = true;\n\n                if (checkbox.prop(INDETERMINATE) === false) {\n                  this.dataItem(parentNode).set(CHECKED, checkbox.prop(CHECKED));\n                } else {\n                  // delete this.dataItem(parentNode).checked;\n                  this.dataItem(parentNode).set(CHECKED, false);\n                }\n\n                this._skip = false;\n\n                this._bubbleIndeterminate(parentNode, true);\n              }\n            },\n            _checkboxChange: function (e) {\n              var that = this;\n              var checkbox = $(e.target);\n              var isChecked = checkbox.prop(CHECKED);\n              var node = checkbox.closest(NODE);\n              var dataItem = this.dataItem(node);\n\n              if (this._preventChange) {\n                return;\n              }\n\n              if (dataItem.checked != isChecked) {\n                dataItem.set(CHECKED, isChecked);\n                node.attr(ARIACHECKED, isChecked);\n\n                this._trigger(CHECK, node);\n              }\n\n              if (checkbox.is(\":focus\")) {\n                that._trigger(NAVIGATE, node);\n\n                that.focus();\n              }\n            },\n            _toggleButtonClick: function (e) {\n              var node = $(e.currentTarget).closest(NODE);\n\n              if (node.is(\"[aria-disabled='true']\")) {\n                return;\n              }\n\n              this.toggle(node);\n            },\n            _mousedown: function (e) {\n              var that = this;\n              var currentTarget = $(e.currentTarget);\n              var node = $(e.currentTarget).closest(NODE);\n              var browser = kendo.support.browser;\n\n              if (node.is(\"[aria-disabled='true']\")) {\n                return;\n              } //IE does not trigger change for indeterminate checkboxes\n\n\n              if ((browser.msie || browser.edge) && currentTarget.is(\":checkbox\")) {\n                if (currentTarget.prop(INDETERMINATE)) {\n                  that._preventChange = false;\n                  currentTarget.prop(CHECKED, !currentTarget.prop(CHECKED));\n                  currentTarget.trigger(CHANGE);\n                  currentTarget.on(CLICK + NS, function (e) {\n                    e.preventDefault();\n                  });\n                  that._preventChange = true;\n                } else {\n                  currentTarget.off(CLICK + NS);\n                  that._preventChange = false;\n                }\n              }\n\n              that._clickTarget = node;\n              that.current(node);\n            },\n            _focusable: function (node) {\n              return node && node.length && node.is(\":visible\") && !node.find(\".k-in\").first().hasClass(DISABLED);\n            },\n            _focus: function () {\n              var current = this.select(),\n                  clickTarget = this._clickTarget; // suppress initial focus state on touch devices (until keyboard is used)\n\n              if (kendo.support.touch) {\n                return;\n              }\n\n              if (clickTarget && clickTarget.length) {\n                current = clickTarget;\n              }\n\n              if (!this._focusable(current)) {\n                current = this.current();\n              }\n\n              if (!this._focusable(current)) {\n                current = this._nextVisible($());\n              }\n\n              this.current(current);\n            },\n            focus: function () {\n              var wrapper = this.wrapper,\n                  scrollContainer = wrapper[0],\n                  containers = [],\n                  offsets = [],\n                  documentElement = document.documentElement,\n                  i;\n\n              do {\n                scrollContainer = scrollContainer.parentNode;\n\n                if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                  containers.push(scrollContainer);\n                  offsets.push(scrollContainer.scrollTop);\n                }\n              } while (scrollContainer != documentElement);\n\n              kendo.focusElement(wrapper);\n\n              for (i = 0; i < containers.length; i++) {\n                containers[i].scrollTop = offsets[i];\n              }\n            },\n            _blur: function () {\n              this.current().find(\".k-in\").first().removeClass(\"k-focus\");\n            },\n            _enabled: function (node) {\n              return !node.children(\"div\").children(\".k-in\").hasClass(DISABLED);\n            },\n            parent: function (node) {\n              var wrapperRe = /\\bk-treeview\\b(?!-)/,\n                  itemRe = /\\bk-item\\b/,\n                  result,\n                  skipSelf;\n\n              if (typeof node == STRING) {\n                node = this.element.find(node);\n              }\n\n              if (!isDomElement(node)) {\n                node = node[0];\n              }\n\n              skipSelf = itemRe.test(node.className);\n\n              do {\n                node = node.parentNode;\n\n                if (itemRe.test(node.className)) {\n                  if (skipSelf) {\n                    result = node;\n                  } else {\n                    skipSelf = true;\n                  }\n                }\n              } while (!wrapperRe.test(node.className) && !result);\n\n              return $(result);\n            },\n            _nextVisible: function (node) {\n              var that = this,\n                  expanded = that._expanded(node),\n                  result;\n\n              function nextParent(node) {\n                while (node.length && !node.next().length) {\n                  node = that.parent(node);\n                }\n\n                if (node.next().length) {\n                  return node.next();\n                } else {\n                  return node;\n                }\n              }\n\n              if (!node.length || !node.is(\":visible\")) {\n                result = that.root.children().eq(0);\n              } else if (expanded) {\n                result = subGroup(node).children().first(); // expanded node with no children\n\n                if (!result.length) {\n                  result = nextParent(node);\n                }\n              } else {\n                result = nextParent(node);\n              }\n\n              return result;\n            },\n            _previousVisible: function (node) {\n              var that = this,\n                  lastChild,\n                  result;\n\n              if (!node.length || node.prev().length) {\n                if (node.length) {\n                  result = node.prev();\n                } else {\n                  result = that.root.children().last();\n                }\n\n                while (that._expanded(result)) {\n                  lastChild = subGroup(result).children().last();\n\n                  if (!lastChild.length) {\n                    break;\n                  }\n\n                  result = lastChild;\n                }\n              } else {\n                result = that.parent(node) || node;\n              }\n\n              return result;\n            },\n            _keydown: function (e) {\n              var that = this,\n                  key = e.keyCode,\n                  target,\n                  focused = that.current(),\n                  expanded = that._expanded(focused),\n                  checkbox = focused.find(\".k-checkbox-wrapper\").first().find(\":checkbox\"),\n                  rtl = kendo.support.isRtl(that.element);\n\n              if (e.target != e.currentTarget) {\n                return;\n              }\n\n              if (!rtl && key == keys.RIGHT || rtl && key == keys.LEFT) {\n                if (expanded) {\n                  target = that._nextVisible(focused);\n                } else if (!focused.find(\".k-in\").first().hasClass(DISABLED)) {\n                  that.expand(focused);\n                }\n              } else if (!rtl && key == keys.LEFT || rtl && key == keys.RIGHT) {\n                if (expanded && !focused.find(\".k-in\").first().hasClass(DISABLED)) {\n                  that.collapse(focused);\n                } else {\n                  target = that.parent(focused);\n\n                  if (!that._enabled(target)) {\n                    target = undefined;\n                  }\n                }\n              } else if (key == keys.DOWN) {\n                target = that._nextVisible(focused);\n              } else if (key == keys.UP) {\n                target = that._previousVisible(focused);\n              } else if (key == keys.HOME) {\n                target = that._nextVisible($());\n              } else if (key == keys.END) {\n                target = that._previousVisible($());\n              } else if (key == keys.ENTER && !focused.find(\".k-in\").first().hasClass(DISABLED)) {\n                if (!focused.find(\".k-in\").first().hasClass(\"k-selected\")) {\n                  if (!that._trigger(SELECT, focused)) {\n                    that.select(focused);\n                  }\n                }\n              } else if (key == keys.SPACEBAR && checkbox.length) {\n                if (!focused.find(\".k-in\").first().hasClass(DISABLED)) {\n                  checkbox.prop(CHECKED, !checkbox.prop(CHECKED)).data(INDETERMINATE, false).prop(INDETERMINATE, false);\n\n                  that._checkboxChange({\n                    target: checkbox\n                  });\n                }\n\n                target = focused;\n              }\n\n              if (target) {\n                e.preventDefault();\n\n                if (focused[0] != target[0]) {\n                  that._trigger(NAVIGATE, target);\n\n                  that.current(target);\n                }\n              }\n            },\n            _keypress: function (e) {\n              var that = this;\n              var delay = 300;\n              var focusedNode = that.current().get(0);\n              var matchToFocus;\n              var key = e.key;\n              var isPrintable = key.length === 1;\n\n              if (!isPrintable) {\n                return;\n              }\n\n              if (!that._match) {\n                that._match = \"\";\n              }\n\n              that._match += key;\n              clearTimeout(that._matchTimer);\n              that._matchTimer = setTimeout(function () {\n                that._match = \"\";\n              }, delay);\n              matchToFocus = focusedNode && that._matchNextByText(Array.prototype.indexOf.call(that.element.find(\".k-item\"), focusedNode), that._match);\n\n              if (!matchToFocus.length) {\n                matchToFocus = that._matchNextByText(-1, that._match);\n              }\n\n              if (matchToFocus.get(0) && matchToFocus.get(0) !== focusedNode) {\n                that._trigger(NAVIGATE, matchToFocus);\n\n                that.current(matchToFocus);\n              }\n            },\n            _matchNextByText: function (startIndex, text) {\n              var element = this.element;\n              var textNodes = element.find(\".k-in\").filter(function (i, element) {\n                return i > startIndex && $(element).is(\":visible\") && $(element).text().toLowerCase().indexOf(text) === 0;\n              });\n              return textNodes.eq(0).closest(NODE);\n            },\n            _click: function (e) {\n              var that = this,\n                  node = $(e.currentTarget),\n                  contents = nodeContents(node.closest(NODE)),\n                  href = node.attr(\"href\"),\n                  shouldNavigate;\n\n              if (href) {\n                shouldNavigate = href == \"#\" || href.indexOf(\"#\" + this.element.id + \"-\") >= 0;\n              } else {\n                shouldNavigate = contents.length && !contents.children().length;\n              }\n\n              if (shouldNavigate) {\n                e.preventDefault();\n              }\n\n              if (!node.hasClass(\".k-selected\") && !that._trigger(SELECT, node)) {\n                that.select(node);\n              }\n            },\n            _wrapper: function () {\n              var that = this,\n                  element = that.element,\n                  wrapper,\n                  root,\n                  wrapperClasses = \"k-treeview\";\n\n              if (element.is(\"ul\")) {\n                wrapper = element.wrap('<div />').parent();\n                root = element;\n              } else {\n                wrapper = element;\n                root = wrapper.children(\"ul\").eq(0);\n              }\n\n              that.wrapper = wrapper.addClass(wrapperClasses);\n              that.root = root;\n            },\n            _getSelectedNode: function () {\n              return this.element.find(\".k-selected\").closest(NODE);\n            },\n            _group: function (item) {\n              var that = this,\n                  firstLevel = item.hasClass(KTREEVIEW),\n                  group = {\n                firstLevel: firstLevel,\n                expanded: firstLevel || that._expanded(item)\n              },\n                  groupElement = item.children(\"ul\");\n              groupElement.addClass(that.templates.groupCssClass(group)).css(\"display\", group.expanded ? \"\" : \"none\");\n\n              if (!firstLevel) {\n                groupElement.attr(\"role\", \"group\");\n              }\n\n              that._nodes(groupElement, group);\n            },\n            _nodes: function (groupElement, groupData) {\n              var that = this,\n                  nodes = groupElement.children(\"li\"),\n                  nodeData;\n              groupData = extend({\n                length: nodes.length\n              }, groupData);\n              nodes.each(function (i, node) {\n                node = $(node);\n                nodeData = {\n                  index: i,\n                  expanded: that._expanded(node)\n                };\n                updateNodeHtml(node);\n\n                that._updateNodeClasses(node, groupData, nodeData); // iterate over child nodes\n\n\n                that._group(node);\n              });\n            },\n            _checkboxes: function () {\n              var options = this.options;\n              var checkboxes = options.checkboxes;\n              var defaultTemplate, checkbox;\n\n              if (checkboxes) {\n                checkbox = \"<input id='_#= item.uid #' aria-hidden='true' type='checkbox' tabindex='-1'\";\n\n                if (checkboxes.name) {\n                  checkbox += \" name='\" + checkboxes.name + \"'\";\n                }\n\n                checkbox += \" />\";\n                defaultTemplate = kendo.html.renderCheckBox($(checkbox), $.extend({}, options, {\n                  rounded: \"medium\"\n                }));\n                defaultTemplate = defaultTemplate.replace(/(<input[^/>]*)/, \"$1 #= (item.enabled === false) ? 'disabled' : '' # #= item.checked ? 'checked' : '' #\");\n                checkboxes = extend({\n                  template: defaultTemplate\n                }, options.checkboxes);\n\n                if (typeof checkboxes.template == STRING) {\n                  checkboxes.template = template(checkboxes.template);\n                }\n\n                options.checkboxes = checkboxes;\n              }\n            },\n            _updateNodeClasses: function (node, groupData, nodeData) {\n              var wrapper = node.children(\"div\"),\n                  group = node.children(\"ul\"),\n                  templates = this.templates;\n\n              if (node.hasClass(\"k-treeview\")) {\n                return;\n              }\n\n              nodeData = nodeData || {};\n              nodeData.expanded = typeof nodeData.expanded != UNDEFINED ? nodeData.expanded : this._expanded(node);\n              nodeData.index = typeof nodeData.index != UNDEFINED ? nodeData.index : node.index();\n              nodeData.enabled = typeof nodeData.enabled != UNDEFINED ? nodeData.enabled : !wrapper.children(\".k-in\").hasClass(\"k-disabled\");\n              groupData = groupData || {};\n              groupData.firstLevel = typeof groupData.firstLevel != UNDEFINED ? groupData.firstLevel : node.parent().parent().hasClass(KTREEVIEW);\n              groupData.length = typeof groupData.length != UNDEFINED ? groupData.length : node.parent().children().length; // li\n\n              node.removeClass(\"k-first k-last\").addClass(templates.wrapperCssClass(groupData, nodeData)); // div\n\n              wrapper.removeClass(\"k-treeview-top k-treeview-mid k-treeview-bot\").addClass(templates.cssClass(groupData, nodeData)); // span / a\n\n              var textWrap = wrapper.children(\".k-in\");\n              var isLink = textWrap[0] && textWrap[0].nodeName.toLowerCase() == \"a\";\n              textWrap.removeClass(\"k-in k-link k-disabled\").addClass(templates.textClass(nodeData, isLink)); // toggle button\n\n              if (group.length || node.attr(\"data-hasChildren\") == \"true\") {\n                wrapper.find(\".k-treeview-toggle > .k-icon\").removeClass(\"k-i-expand k-i-collapse\").addClass(templates.toggleButtonClass(nodeData));\n                group.addClass(\"k-group k-treeview-group\");\n              }\n            },\n            _processNodes: function (nodes, callback) {\n              var that = this;\n              var items = that.element.find(nodes);\n\n              for (var i = 0; i < items.length; i++) {\n                callback.call(that, i, $(items[i]).closest(NODE));\n              }\n            },\n            dataItem: function (node) {\n              var uid = $(node).closest(NODE).attr(kendo.attr(\"uid\")),\n                  dataSource = this.dataSource;\n              return dataSource && dataSource.getByUid(uid);\n            },\n            _dataItem: function (node) {\n              var uid = $(node).closest(NODE).attr(kendo.attr(\"uid\")),\n                  dataSource = this.dataSource;\n              return dataSource && this._dataSourceUids[uid];\n            },\n            _insertNode: function (nodeData, index, parentNode, insertCallback, collapsed) {\n              var that = this,\n                  group = subGroup(parentNode),\n                  updatedGroupLength = group.children().length + 1,\n                  childrenData,\n                  groupData = {\n                firstLevel: parentNode.hasClass(KTREEVIEW),\n                expanded: !collapsed,\n                length: updatedGroupLength\n              },\n                  node,\n                  i,\n                  item,\n                  nodeHtml = \"\",\n                  firstChild,\n                  lastChild,\n                  append = function (item, group) {\n                item.appendTo(group);\n              };\n\n              for (i = 0; i < nodeData.length; i++) {\n                item = nodeData[i];\n                item.index = index + i;\n                nodeHtml += that._renderItem({\n                  group: groupData,\n                  item: item\n                });\n              }\n\n              node = $(nodeHtml);\n\n              if (!node.length) {\n                return;\n              }\n\n              that.angular(\"compile\", function () {\n                return {\n                  elements: node.get(),\n                  data: nodeData.map(function (item) {\n                    return {\n                      dataItem: item\n                    };\n                  })\n                };\n              });\n\n              if (!group.length) {\n                group = $(that._renderGroup({\n                  group: groupData\n                })).appendTo(parentNode);\n              }\n\n              insertCallback(node, group);\n\n              if (parentNode.hasClass(\"k-item\")) {\n                updateNodeHtml(parentNode);\n\n                that._updateNodeClasses(parentNode, groupData, {\n                  expanded: !collapsed\n                });\n              }\n\n              firstChild = node.prev().first();\n              lastChild = node.next().last();\n\n              that._updateNodeClasses(firstChild, {}, {\n                expanded: firstChild.attr(kendo.attr(\"expanded\")) == \"true\"\n              });\n\n              that._updateNodeClasses(lastChild, {}, {\n                expanded: lastChild.attr(kendo.attr(\"expanded\")) == \"true\"\n              }); // render sub-nodes\n\n\n              for (i = 0; i < nodeData.length; i++) {\n                item = nodeData[i];\n\n                if (item.hasChildren) {\n                  childrenData = item.children.data();\n\n                  if (childrenData.length) {\n                    that._insertNode(childrenData, item.index, node.eq(i), append, !item.expanded);\n                  }\n                }\n              }\n\n              return node;\n            },\n            _updateNodes: function (items, field) {\n              var that = this;\n              var i, node, nodeWrapper, item, isChecked, isCollapsed;\n              var context = {\n                treeview: that.options,\n                item: item\n              };\n              var render = field != \"expanded\" && field != \"checked\";\n\n              function setCheckedState(root, state) {\n                if (root.is(\".k-group\")) {\n                  root.find(\".k-item:not([aria-disabled])\").attr(ARIACHECKED, state);\n                }\n\n                root.find(\".k-checkbox-wrapper input[type=checkbox]:not([disabled])\").prop(CHECKED, state).data(INDETERMINATE, false).prop(INDETERMINATE, false);\n              }\n\n              if (field == \"selected\") {\n                item = items[0];\n                node = that.findByUid(item.uid).find(\".k-in\").first();\n                node.removeClass(\"k-hover\").toggleClass(\"k-selected\", item[field]).end();\n\n                if (item[field]) {\n                  that.current(node);\n                }\n\n                node.attr(ARIASELECTED, !!item[field]);\n              } else {\n                var elements = $.map(items, function (item) {\n                  return that.findByUid(item.uid).children(\"div\");\n                });\n\n                if (render) {\n                  that.angular(\"cleanup\", function () {\n                    return {\n                      elements: elements\n                    };\n                  });\n                }\n\n                for (i = 0; i < items.length; i++) {\n                  context.item = item = items[i];\n                  nodeWrapper = elements[i];\n                  node = nodeWrapper.parent();\n\n                  if (render) {\n                    if (kendo.unbind) {\n                      kendo.unbind(nodeWrapper);\n                    }\n\n                    nodeWrapper.children(\".k-in\").html(that.templates.itemContent(context));\n                  }\n\n                  if (field == CHECKED) {\n                    isChecked = item[field];\n                    setCheckedState(nodeWrapper, isChecked);\n                    node.attr(ARIACHECKED, isChecked);\n\n                    if (that.options.checkboxes.checkChildren) {\n                      setCheckedState(node.children(\".k-group\"), isChecked);\n\n                      that._setChecked(item.children, isChecked);\n\n                      that._bubbleIndeterminate(node);\n                    }\n                  } else if (field == \"expanded\") {\n                    that._toggle(node, item, item[field]);\n                  } else if (field == \"enabled\") {\n                    node.find(\".k-checkbox-wrapper input[type=checkbox]\").prop(\"disabled\", !item[field]);\n                    isCollapsed = !nodeContents(node).is(VISIBLE);\n                    node.removeAttr(ARIADISABLED);\n\n                    if (!item[field]) {\n                      if (item.selected) {\n                        item.set(\"selected\", false);\n                      }\n\n                      if (item.expanded) {\n                        item.set(\"expanded\", false);\n                      }\n\n                      isCollapsed = true;\n                      node.attr(ARIASELECTED, false).attr(ARIADISABLED, true);\n                    }\n\n                    that._updateNodeClasses(node, {}, {\n                      enabled: item[field],\n                      expanded: !isCollapsed\n                    });\n                  }\n\n                  if (nodeWrapper.length) {\n                    this.trigger(\"itemChange\", {\n                      item: nodeWrapper,\n                      data: item,\n                      ns: ui\n                    });\n                  }\n                }\n\n                if (render) {\n                  that.angular(\"compile\", function () {\n                    return {\n                      elements: elements,\n                      data: $.map(items, function (item) {\n                        return [{\n                          dataItem: item\n                        }];\n                      })\n                    };\n                  });\n                }\n              }\n            },\n            _appendItems: function (index, items, parentNode) {\n              var group = subGroup(parentNode);\n              var children = group.children();\n              var collapsed = !this._expanded(parentNode);\n\n              if (this.element === parentNode) {\n                var dataItems = this.dataSource.data();\n                var viewItems = this.dataSource.view();\n                var rootItems = viewItems.length < dataItems.length ? viewItems : dataItems;\n                index = rootItems.indexOf(items[0]);\n              } else if (items.length) {\n                index = items[0].parent().indexOf(items[0]);\n              }\n\n              if (typeof index == UNDEFINED) {\n                index = children.length;\n              }\n\n              this._insertNode(items, index, parentNode, function (item, group) {\n                // insert node into DOM\n                if (index >= children.length) {\n                  item.appendTo(group);\n                } else {\n                  item.insertBefore(children.eq(index));\n                }\n              }, collapsed);\n\n              if (!collapsed) {\n                this._updateNodeClasses(parentNode, {}, {\n                  expanded: !collapsed\n                });\n\n                subGroup(parentNode).css(\"display\", \"block\");\n              }\n            },\n            _refreshChildren: function (parentNode, items, index) {\n              var i, children, child;\n              var options = this.options;\n              var loadOnDemand = options.loadOnDemand;\n              var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n              subGroup(parentNode).empty();\n\n              if (!items.length) {\n                updateNodeHtml(parentNode);\n              } else {\n                this._appendItems(index, items, parentNode);\n\n                children = subGroup(parentNode).children();\n\n                if (loadOnDemand && checkChildren) {\n                  this._bubbleIndeterminate(children.last());\n                }\n\n                for (i = 0; i < children.length; i++) {\n                  child = children.eq(i);\n                  this.trigger(\"itemChange\", {\n                    item: child.children(\"div\"),\n                    data: items[i],\n                    ns: ui\n                  });\n                }\n              }\n            },\n            _refreshRoot: function (items) {\n              var groupHtml = this._renderGroup({\n                items: items,\n                group: {\n                  firstLevel: true,\n                  expanded: true\n                }\n              });\n\n              if (this.root.length && this.root[0].parentElement) {\n                this._angularItems(\"cleanup\");\n\n                var group = $(groupHtml);\n                this.root.attr(\"class\", group.attr(\"class\")).html(group.html());\n              } else {\n                this.root = this.wrapper.html(groupHtml).children(\"ul\");\n              }\n\n              var elements = this.root.children(\".k-item\");\n\n              for (var i = 0; i < items.length; i++) {\n                this.trigger(\"itemChange\", {\n                  item: elements.eq(i),\n                  data: items[i],\n                  ns: ui\n                });\n              }\n\n              this._angularItems(\"compile\");\n            },\n            refresh: function (e) {\n              var node = e.node;\n              var action = e.action;\n              var items = e.items;\n              var parentNode = this.wrapper;\n              var options = this.options;\n              var loadOnDemand = options.loadOnDemand;\n              var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n              var i;\n\n              if (this._skip) {\n                return;\n              }\n\n              for (i = 0; i < items.length; i++) {\n                this._dataSourceUids[items[i].uid] = items[i];\n              }\n\n              if (e.field) {\n                if (!items[0] || !items[0].level) {\n                  return;\n                }\n\n                return this._updateNodes(items, e.field);\n              }\n\n              if (node) {\n                parentNode = this.findByUid(node.uid);\n\n                this._progress(parentNode, false);\n              }\n\n              if (checkChildren && action != \"remove\") {\n                var bubble = false;\n\n                for (i = 0; i < items.length; i++) {\n                  if (\"checked\" in items[i]) {\n                    bubble = true;\n                    break;\n                  }\n                }\n\n                if (!bubble && node && node.checked) {\n                  for (i = 0; i < items.length; i++) {\n                    items[i].checked = true;\n                  }\n                }\n              }\n\n              if (action == \"add\") {\n                this._appendItems(e.index, items, parentNode);\n              } else if (action == \"remove\") {\n                this._remove(this.findByUid(items[0].uid), false);\n              } else if (action == \"itemchange\") {\n                this._updateNodes(items);\n              } else if (action == \"itemloaded\") {\n                this._refreshChildren(parentNode, items, e.index);\n              } else {\n                this._refreshRoot(items);\n\n                this.element.attr(\"aria-busy\", false);\n              }\n\n              if (action != \"remove\") {\n                for (i = 0; i < items.length; i++) {\n                  if (!loadOnDemand || items[i].expanded || items[i]._loaded) {\n                    items[i].load();\n                  }\n                }\n              }\n\n              this.wrapper.find(\">ul\").attr(\"role\", \"none\");\n              this.trigger(DATABOUND, {\n                node: node ? parentNode : undefined\n              });\n\n              if (this.dataSource.filter() && this.options.checkboxes.checkChildren) {\n                this.updateIndeterminate(parentNode);\n              }\n            },\n            _error: function (e) {\n              var node = e.node && this.findByUid(e.node.uid);\n              var retryHtml = this.templates.retry({\n                messages: this.options.messages\n              });\n\n              if (node) {\n                this._progress(node, false);\n\n                this._expanded(node, false);\n\n                nodeIcon(node).addClass(\"k-i-reload\");\n                e.node.loaded(false);\n              } else {\n                this._progress(false);\n\n                this.dataSource.data([]);\n                this.element.html(retryHtml);\n              }\n            },\n            _retryRequest: function (e) {\n              e.preventDefault();\n              this.dataSource.fetch(this._attemptLoadCompleted.bind(this));\n            },\n            expand: function (nodes) {\n              this._processNodes(nodes, function (index, item) {\n                this.toggle(item, true);\n              });\n            },\n            collapse: function (nodes) {\n              this._processNodes(nodes, function (index, item) {\n                this.toggle(item, false);\n              });\n            },\n            enable: function (nodes, enable) {\n              if (typeof nodes === \"boolean\") {\n                enable = nodes;\n                nodes = this.items();\n              } else {\n                enable = arguments.length == 2 ? !!enable : true;\n              }\n\n              this._processNodes(nodes, function (index, item) {\n                this.dataItem(item).set(\"enabled\", enable);\n              });\n            },\n            current: function (node) {\n              var that = this,\n                  current = that._current,\n                  element = that.element;\n\n              if (arguments.length > 0 && node && node.length) {\n                if (current) {\n                  current.find(\".k-in\").first().removeClass(\"k-focus\");\n                }\n\n                current = that._current = $(node, element).closest(NODE);\n                current.find(\".k-in\").first().addClass(\"k-focus\");\n\n                that._updateActiveDescendant();\n\n                return;\n              }\n\n              if (!current) {\n                current = that._nextVisible($());\n              }\n\n              return current;\n            },\n            _updateActiveDescendant: function () {\n              var current = this._current,\n                  id = current[0].id || this._ariaId,\n                  prev = this.element.find(\"#\" + this._ariaId);\n\n              if (prev.length > 0) {\n                prev.removeAttr(\"id\");\n              }\n\n              this.wrapper.removeAttr(\"aria-activedescendant\");\n              current.attr(\"id\", id);\n              this.wrapper.attr(\"aria-activedescendant\", id);\n            },\n            select: function (node) {\n              var that = this,\n                  element = that.element;\n\n              if (!arguments.length) {\n                return element.find(\".k-selected\").closest(NODE);\n              }\n\n              node = $(node, element).closest(NODE);\n              element.find(\".k-selected\").each(function () {\n                var dataItem = that.dataItem(this);\n\n                if (dataItem) {\n                  dataItem.set(\"selected\", false);\n                  delete dataItem.selected;\n                } else {\n                  $(this).removeClass(\"k-selected\");\n                }\n              });\n\n              if (node.length) {\n                that.dataItem(node).set(\"selected\", true);\n                that._clickTarget = node;\n              }\n\n              that.trigger(CHANGE);\n            },\n            _toggle: function (node, dataItem, expand) {\n              var options = this.options;\n              var contents = nodeContents(node);\n              var direction = expand ? \"expand\" : \"collapse\";\n              var loaded;\n\n              if (contents.data(\"animating\")) {\n                return;\n              }\n\n              loaded = dataItem && dataItem.loaded();\n\n              if (expand && !loaded) {\n                if (options.loadOnDemand) {\n                  this._progress(node, true);\n                }\n\n                contents.remove();\n                dataItem.load();\n              } else {\n                this._updateNodeClasses(node, {}, {\n                  expanded: expand\n                });\n\n                if (!expand) {\n                  contents.css(\"height\", contents.height()).css(\"height\");\n                }\n\n                contents.kendoStop(true, true).kendoAnimate(extend({\n                  reset: true\n                }, options.animation[direction], {\n                  complete: function () {\n                    if (expand) {\n                      contents.css(\"height\", \"\");\n                    }\n                  }\n                }));\n              }\n            },\n            toggle: function (node, expand) {\n              node = $(node);\n\n              if (!nodeIcon(node).is(\".k-i-expand, .k-i-collapse\")) {\n                return;\n              }\n\n              if (arguments.length == 1) {\n                expand = !this._expanded(node);\n              }\n\n              this._expanded(node, expand);\n            },\n            destroy: function () {\n              var that = this;\n              Widget.fn.destroy.call(that);\n              that.wrapper.off(NS);\n              that.wrapper.find(\".k-checkbox-wrapper :checkbox\").off(NS);\n              that._clickHandler = null;\n\n              that._unbindDataSource();\n\n              if (that.dragging) {\n                that.dragging.destroy();\n              }\n\n              that._dataSourceUids = {};\n              kendo.destroy(that.element);\n              that.root = that.wrapper = that.element = null;\n            },\n            _expanded: function (node, value, force) {\n              var expandedAttr = kendo.attr(\"expanded\");\n              var dataItem;\n              var expanded = value;\n              var direction = expanded ? \"expand\" : \"collapse\";\n\n              if (arguments.length == 1) {\n                dataItem = this._dataItem(node);\n                return node.attr(expandedAttr) === \"true\" || dataItem && dataItem.expanded;\n              }\n\n              dataItem = this.dataItem(node);\n\n              if (nodeContents(node).data(\"animating\")) {\n                return;\n              }\n\n              if (force || !this._trigger(direction, node)) {\n                if (expanded) {\n                  node.attr(expandedAttr, \"true\");\n                  node.attr(ARIAEXPANDED, \"true\");\n                } else {\n                  node.removeAttr(expandedAttr);\n                  node.attr(ARIAEXPANDED, \"false\");\n                }\n\n                if (dataItem) {\n                  dataItem.set(\"expanded\", expanded); // necessary when expanding an item yields an error and the item is not expanded as a result\n\n                  expanded = dataItem.expanded;\n                }\n              }\n            },\n            _progress: function (node, showProgress) {\n              var element = this.element;\n              var loadingText = this.templates.loading({\n                messages: this.options.messages\n              });\n\n              if (arguments.length == 1) {\n                showProgress = node;\n\n                if (showProgress) {\n                  element.html(loadingText);\n                } else {\n                  element.empty();\n                }\n\n                element.attr(\"aria-busy\", showProgress);\n              } else {\n                nodeIcon(node).toggleClass(\"k-i-loading\", showProgress).removeClass(\"k-i-reload\");\n                node.attr(\"aria-busy\", showProgress);\n              }\n            },\n            text: function (node, text) {\n              var dataItem = this.dataItem(node),\n                  fieldBindings = this.options[bindings.text],\n                  level = dataItem.level(),\n                  length = fieldBindings.length,\n                  field = fieldBindings[Math.min(level, length - 1)];\n\n              if (text) {\n                dataItem.set(field, text);\n              } else {\n                return dataItem[field];\n              }\n            },\n            _objectOrSelf: function (node) {\n              return $(node).closest(\"[data-role=treeview]\").data(\"kendoTreeView\") || this;\n            },\n            _dataSourceMove: function (nodeData, group, parentNode, callback) {\n              var referenceDataItem,\n                  destTreeview = this._objectOrSelf(parentNode || group),\n                  destDataSource = destTreeview.dataSource;\n\n              var loadPromise = $.Deferred().resolve().promise();\n\n              if (parentNode && parentNode[0] != destTreeview.element[0]) {\n                referenceDataItem = destTreeview.dataItem(parentNode);\n\n                if (!referenceDataItem.loaded()) {\n                  destTreeview._progress(parentNode, true);\n\n                  loadPromise = referenceDataItem.load();\n                }\n\n                if (parentNode != this.root) {\n                  destDataSource = referenceDataItem.children;\n\n                  if (!destDataSource || !(destDataSource instanceof HierarchicalDataSource)) {\n                    referenceDataItem._initChildren();\n\n                    referenceDataItem.loaded(true);\n                    destDataSource = referenceDataItem.children;\n                  }\n                }\n              }\n\n              nodeData = this._toObservableData(nodeData);\n              return callback.call(destTreeview, destDataSource, nodeData, loadPromise);\n            },\n            _toObservableData: function (node) {\n              var dataItem = node,\n                  dataSource,\n                  uid;\n\n              if (isJQueryInstance(node) || isDomElement(node)) {\n                dataSource = this._objectOrSelf(node).dataSource;\n                uid = $(node).attr(kendo.attr(\"uid\"));\n                dataItem = dataSource.getByUid(uid);\n\n                if (dataItem) {\n                  dataItem = dataSource.remove(dataItem);\n                }\n              }\n\n              return dataItem;\n            },\n            _insert: function (data, model, index) {\n              if (!(model instanceof kendo.data.ObservableArray)) {\n                if (!isArray(model)) {\n                  model = [model];\n                }\n              } else {\n                // items will be converted to new Node instances\n                model = model.toJSON();\n              }\n\n              var parentNode = data.parent();\n\n              if (parentNode && parentNode._initChildren) {\n                parentNode.hasChildren = true;\n\n                parentNode._initChildren();\n              }\n\n              data.splice.apply(data, [index, 0].concat(model));\n              return this.findByUid(data[index].uid);\n            },\n            insertAfter: insertAction(1),\n            insertBefore: insertAction(0),\n            append: function (nodeData, parentNode, success) {\n              var group = this.root;\n\n              if (parentNode && nodeData instanceof jQuery && parentNode[0] === nodeData[0]) {\n                return;\n              }\n\n              parentNode = parentNode && parentNode.length ? parentNode : null;\n\n              if (parentNode) {\n                group = subGroup(parentNode);\n              }\n\n              return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model, loadModel) {\n                var inserted;\n                var that = this;\n\n                function add() {\n                  if (parentNode) {\n                    that._expanded(parentNode, true, true);\n                  }\n\n                  var data = dataSource.data(),\n                      index = Math.max(data.length, 0);\n                  return that._insert(data, model, index);\n                }\n\n                loadModel.done(function () {\n                  inserted = add();\n                  success = success || $.noop;\n                  success(inserted);\n                });\n                return inserted || null;\n              });\n            },\n            _remove: function (node, keepData) {\n              var that = this,\n                  parentNode,\n                  prevSibling,\n                  nextSibling;\n              node = $(node, that.element);\n\n              if (node.attr(\"id\") === that.element.attr(\"aria-activedescendant\")) {\n                that.element.removeAttr(\"aria-activedescendant\");\n              }\n\n              this.angular(\"cleanup\", function () {\n                return {\n                  elements: node.get()\n                };\n              });\n              parentNode = node.parent().parent();\n              prevSibling = node.prev();\n              nextSibling = node.next();\n              node[keepData ? \"detach\" : \"remove\"]();\n\n              if (parentNode.hasClass(\"k-item\")) {\n                updateNodeHtml(parentNode);\n\n                that._updateNodeClasses(parentNode);\n              }\n\n              that._updateNodeClasses(prevSibling);\n\n              that._updateNodeClasses(nextSibling);\n\n              return node;\n            },\n            remove: function (node) {\n              var dataItem = this.dataItem(node);\n\n              if (dataItem) {\n                this.dataSource.remove(dataItem);\n              }\n            },\n            detach: function (node) {\n              return this._remove(node, true);\n            },\n            findByText: function (text) {\n              return $(this.element).find(\".k-in\").filter(function (i, element) {\n                return $(element).text() == text;\n              }).closest(NODE);\n            },\n            findByUid: function (uid) {\n              var items = this.element.find(\".k-item\");\n              var uidAttr = kendo.attr(\"uid\");\n              var result;\n\n              for (var i = 0; i < items.length; i++) {\n                if (items[i].getAttribute(uidAttr) == uid) {\n                  result = items[i];\n                  break;\n                }\n              }\n\n              return $(result);\n            },\n            expandPath: function (path, complete) {\n              var treeview = this;\n              var nodeIds = path.slice(0);\n              var callback = complete || $.noop;\n\n              function proceed() {\n                nodeIds.shift();\n\n                if (nodeIds.length) {\n                  expand(nodeIds[0]).then(proceed);\n                } else {\n                  callback.call(treeview);\n                }\n              }\n\n              function expand(id) {\n                var result = $.Deferred();\n                var node = treeview.dataSource.get(id);\n                var expandedAttr = kendo.attr(\"expanded\");\n                var nodeElement;\n\n                if (node) {\n                  nodeElement = treeview.findByUid(node.uid);\n\n                  if (node.loaded()) {\n                    node.set(\"expanded\", true);\n                    nodeElement.attr(expandedAttr, true);\n                    nodeElement.attr(ARIAEXPANDED, true);\n                    result.resolve();\n                  } else {\n                    // manually show progress of the node\n                    // should be moved to `refresh`\n                    // if the datasource starts triggering a `requestStart` event for nodes\n                    treeview._progress(nodeElement, true);\n\n                    node.load().then(function () {\n                      node.set(\"expanded\", true);\n                      nodeElement.attr(expandedAttr, true);\n                      nodeElement.attr(ARIAEXPANDED, true);\n                      result.resolve();\n                    });\n                  }\n                } else {\n                  result.resolve();\n                }\n\n                return result.promise();\n              } // expand async nodes\n\n\n              expand(nodeIds[0]).then(proceed);\n            },\n            _parentIds: function (node) {\n              var parent = node && node.parentNode();\n              var parents = [];\n\n              while (parent && parent.parentNode) {\n                parents.unshift(parent.id);\n                parent = parent.parentNode();\n              }\n\n              return parents;\n            },\n            expandTo: function (node) {\n              if (!(node instanceof kendo.data.Node)) {\n                node = this.dataSource.get(node);\n              }\n\n              var parents = this._parentIds(node);\n\n              this.expandPath(parents);\n            },\n            _renderItem: function (options) {\n              if (!options.group) {\n                options.group = {};\n              }\n\n              options.treeview = this.options;\n              options.r = this.templates;\n              return this.templates.item(options);\n            },\n            _renderGroup: function (options) {\n              var that = this;\n\n              options.renderItems = function (options) {\n                var html = \"\",\n                    i = 0,\n                    items = options.items,\n                    len = items ? items.length : 0,\n                    group = options.group;\n                group.length = len;\n\n                for (; i < len; i++) {\n                  options.group = group;\n                  options.item = items[i];\n                  options.item.index = i;\n                  html += that._renderItem(options);\n                }\n\n                return html;\n              };\n\n              options.r = that.templates;\n              return that.templates.group(options);\n            }\n          });\n          kendo.cssProperties.registerPrefix(\"TreeView\", \"k-treeview-\");\n          ui.plugin(TreeView);\n        })(window.kendo.jQuery);\n\n        return window.kendo;\n      }, __webpack_require__(3));\n      /* WEBPACK VAR INJECTION */\n\n    }).call(exports, __webpack_require__(1060));\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}