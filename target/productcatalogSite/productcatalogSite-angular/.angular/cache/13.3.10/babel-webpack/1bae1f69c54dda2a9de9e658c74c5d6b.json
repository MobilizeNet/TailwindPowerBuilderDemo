{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1280);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1280:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"fx\",\n        name: \"Effects\",\n        category: \"framework\",\n        description: \"Required for animation effects in all Kendo UI widgets.\",\n        depends: [\"core\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            fx = kendo.effects,\n            each = $.each,\n            extend = $.extend,\n            support = kendo.support,\n            browser = support.browser,\n            transforms = support.transforms,\n            transitions = support.transitions,\n            scaleProperties = {\n          scale: 0,\n          scalex: 0,\n          scaley: 0,\n          scale3d: 0\n        },\n            translateProperties = {\n          translate: 0,\n          translatex: 0,\n          translatey: 0,\n          translate3d: 0\n        },\n            hasZoom = typeof document.documentElement.style.zoom !== \"undefined\" && !transforms,\n            matrix3dRegExp = /matrix3?d?\\s*\\(.*,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?,\\s*([\\d\\.\\-]+)\\w*?/i,\n            cssParamsRegExp = /^(-?[\\d\\.\\-]+)?[\\w\\s]*,?\\s*(-?[\\d\\.\\-]+)?[\\w\\s]*/i,\n            translateXRegExp = /translatex?$/i,\n            oldEffectsRegExp = /(zoom|fade|expand)(\\w+)/,\n            singleEffectRegExp = /(zoom|fade|expand)/,\n            unitRegExp = /[xy]$/i,\n            transformProps = [\"perspective\", \"rotate\", \"rotatex\", \"rotatey\", \"rotatez\", \"rotate3d\", \"scale\", \"scalex\", \"scaley\", \"scalez\", \"scale3d\", \"skew\", \"skewx\", \"skewy\", \"translate\", \"translatex\", \"translatey\", \"translatez\", \"translate3d\", \"matrix\", \"matrix3d\"],\n            transform2d = [\"rotate\", \"scale\", \"scalex\", \"scaley\", \"skew\", \"skewx\", \"skewy\", \"translate\", \"translatex\", \"translatey\", \"matrix\"],\n            transform2units = {\n          \"rotate\": \"deg\",\n          scale: \"\",\n          skew: \"px\",\n          translate: \"px\"\n        },\n            cssPrefix = transforms.css,\n            round = Math.round,\n            BLANK = \"\",\n            PX = \"px\",\n            NONE = \"none\",\n            AUTO = \"auto\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            HIDDEN = \"hidden\",\n            ORIGIN = \"origin\",\n            ABORT_ID = \"abortId\",\n            OVERFLOW = \"overflow\",\n            TRANSLATE = \"translate\",\n            POSITION = \"position\",\n            COMPLETE_CALLBACK = \"completeCallback\",\n            TRANSITION = cssPrefix + \"transition\",\n            TRANSFORM = cssPrefix + \"transform\",\n            BACKFACE = cssPrefix + \"backface-visibility\",\n            PERSPECTIVE = cssPrefix + \"perspective\",\n            DEFAULT_PERSPECTIVE = \"1500px\",\n            TRANSFORM_PERSPECTIVE = \"perspective(\" + DEFAULT_PERSPECTIVE + \")\",\n            directions = {\n          left: {\n            reverse: \"right\",\n            property: \"left\",\n            transition: \"translatex\",\n            vertical: false,\n            modifier: -1\n          },\n          right: {\n            reverse: \"left\",\n            property: \"left\",\n            transition: \"translatex\",\n            vertical: false,\n            modifier: 1\n          },\n          down: {\n            reverse: \"up\",\n            property: \"top\",\n            transition: \"translatey\",\n            vertical: true,\n            modifier: 1\n          },\n          up: {\n            reverse: \"down\",\n            property: \"top\",\n            transition: \"translatey\",\n            vertical: true,\n            modifier: -1\n          },\n          top: {\n            reverse: \"bottom\"\n          },\n          bottom: {\n            reverse: \"top\"\n          },\n          \"in\": {\n            reverse: \"out\",\n            modifier: -1\n          },\n          out: {\n            reverse: \"in\",\n            modifier: 1\n          },\n          vertical: {\n            reverse: \"vertical\"\n          },\n          horizontal: {\n            reverse: \"horizontal\"\n          }\n        };\n        kendo.directions = directions;\n        extend($.fn, {\n          kendoStop: function (clearQueue, gotoEnd) {\n            if (transitions) {\n              return fx.stopQueue(this, clearQueue || false, gotoEnd || false);\n            } else {\n              return this.stop(clearQueue, gotoEnd);\n            }\n          }\n        });\n        /* jQuery support for all transform animations (FF 3.5/3.6, Opera 10.x, IE9 */\n\n        if (transforms && !transitions) {\n          each(transform2d, function (idx, value) {\n            $.fn[value] = function (val) {\n              if (typeof val == \"undefined\") {\n                return animationProperty(this, value);\n              } else {\n                var that = $(this)[0],\n                    transformValue = value + \"(\" + val + transform2units[value.replace(unitRegExp, \"\")] + \")\";\n\n                if (that.style.cssText.indexOf(TRANSFORM) == -1) {\n                  $(this).css(TRANSFORM, transformValue);\n                } else {\n                  that.style.cssText = that.style.cssText.replace(new RegExp(value + \"\\\\(.*?\\\\)\", \"i\"), transformValue);\n                }\n              }\n\n              return this;\n            };\n\n            $.fx.step[value] = function (fx) {\n              $(fx.elem)[value](fx.now);\n            };\n          });\n          var curProxy = $.fx.prototype.cur;\n\n          $.fx.prototype.cur = function () {\n            if (transform2d.indexOf(this.prop) != -1) {\n              return parseFloat($(this.elem)[this.prop]());\n            }\n\n            return curProxy.apply(this, arguments);\n          };\n        }\n\n        kendo.toggleClass = function (element, classes, options, add) {\n          if (classes) {\n            classes = classes.split(\" \");\n\n            if (transitions) {\n              options = extend({\n                exclusive: \"all\",\n                duration: 400,\n                ease: \"ease-out\"\n              }, options);\n              element.css(TRANSITION, options.exclusive + \" \" + options.duration + \"ms \" + options.ease);\n              setTimeout(function () {\n                element.css(TRANSITION, \"\").css(HEIGHT);\n              }, options.duration); // TODO: this should fire a kendoAnimate session instead.\n            }\n\n            each(classes, function (idx, value) {\n              element.toggleClass(value, add);\n            });\n          }\n\n          return element;\n        };\n\n        kendo.parseEffects = function (input, mirror) {\n          var effects = {};\n\n          if (typeof input === \"string\") {\n            each(input.split(\" \"), function (idx, value) {\n              var redirectedEffect = !singleEffectRegExp.test(value),\n                  resolved = value.replace(oldEffectsRegExp, function (match, $1, $2) {\n                return $1 + \":\" + $2.toLowerCase();\n              }),\n                  // Support for old zoomIn/fadeOut style, now deprecated.\n              effect = resolved.split(\":\"),\n                  direction = effect[1],\n                  effectBody = {};\n\n              if (effect.length > 1) {\n                effectBody.direction = mirror && redirectedEffect ? directions[direction].reverse : direction;\n              }\n\n              effects[effect[0]] = effectBody;\n            });\n          } else {\n            each(input, function (idx) {\n              var direction = this.direction;\n\n              if (direction && mirror && !singleEffectRegExp.test(idx)) {\n                this.direction = directions[direction].reverse;\n              }\n\n              effects[idx] = this;\n            });\n          }\n\n          return effects;\n        };\n\n        function parseInteger(value) {\n          return parseInt(value, 10);\n        }\n\n        function parseCSS(element, property) {\n          return parseInteger(element.css(property));\n        }\n\n        function keys(obj) {\n          var acc = [];\n\n          for (var propertyName in obj) {\n            acc.push(propertyName);\n          }\n\n          return acc;\n        }\n\n        function strip3DTransforms(properties) {\n          for (var key in properties) {\n            if (transformProps.indexOf(key) != -1 && transform2d.indexOf(key) == -1) {\n              delete properties[key];\n            }\n          }\n\n          return properties;\n        }\n\n        function normalizeCSS(element, properties) {\n          var transformation = [],\n              cssValues = {},\n              lowerKey,\n              key,\n              value,\n              isTransformed;\n\n          for (key in properties) {\n            lowerKey = key.toLowerCase();\n            isTransformed = transforms && transformProps.indexOf(lowerKey) != -1;\n\n            if (!support.hasHW3D && isTransformed && transform2d.indexOf(lowerKey) == -1) {\n              delete properties[key];\n            } else {\n              value = properties[key];\n\n              if (isTransformed) {\n                transformation.push(key + \"(\" + value + \")\");\n              } else {\n                cssValues[key] = value;\n              }\n            }\n          }\n\n          if (transformation.length) {\n            cssValues[TRANSFORM] = transformation.join(\" \");\n          }\n\n          return cssValues;\n        }\n\n        if (transitions) {\n          extend(fx, {\n            transition: function (element, properties, options) {\n              var css,\n                  delay = 0,\n                  oldKeys = element.data(\"keys\") || [],\n                  timeoutID;\n              options = extend({\n                duration: 200,\n                ease: \"ease-out\",\n                complete: null,\n                exclusive: \"all\"\n              }, options);\n              var stopTransitionCalled = false;\n\n              var stopTransition = function () {\n                if (!stopTransitionCalled) {\n                  stopTransitionCalled = true;\n\n                  if (timeoutID) {\n                    clearTimeout(timeoutID);\n                    timeoutID = null;\n                  }\n\n                  element.removeData(ABORT_ID).dequeue().css(TRANSITION, \"\").css(TRANSITION);\n                  options.complete.call(element);\n                }\n              };\n\n              options.duration = $.fx ? $.fx.speeds[options.duration] || options.duration : options.duration;\n              css = normalizeCSS(element, properties);\n              $.merge(oldKeys, keys(css));\n\n              if ($.hasOwnProperty(\"uniqueSort\")) {\n                element.data(\"keys\", $.uniqueSort(oldKeys)).height();\n              } else {\n                element.data(\"keys\", $.unique(oldKeys)).height();\n              }\n\n              element.css(TRANSITION, options.exclusive + \" \" + options.duration + \"ms \" + options.ease).css(TRANSITION);\n              element.css(css).css(TRANSFORM);\n              /**\n               * Use transitionEnd event for browsers who support it - but duplicate it with setTimeout, as the transitionEnd event will not be triggered if no CSS properties change.\n               * This should be cleaned up at some point (widget by widget), and refactored to widgets not relying on the complete callback if no transition occurs.\n               *\n               * For IE9 and below, resort to setTimeout.\n               */\n\n              if (transitions.event) {\n                element.one(transitions.event, stopTransition);\n\n                if (options.duration !== 0) {\n                  delay = 500;\n                }\n              }\n\n              timeoutID = setTimeout(stopTransition, options.duration + delay);\n              element.data(ABORT_ID, timeoutID);\n              element.data(COMPLETE_CALLBACK, stopTransition);\n            },\n            stopQueue: function (element, clearQueue, gotoEnd) {\n              var cssValues,\n                  taskKeys = element.data(\"keys\"),\n                  retainPosition = !gotoEnd && taskKeys,\n                  completeCallback = element.data(COMPLETE_CALLBACK);\n\n              if (retainPosition) {\n                cssValues = kendo.getComputedStyles(element[0], taskKeys);\n              }\n\n              if (completeCallback) {\n                completeCallback();\n              }\n\n              if (retainPosition) {\n                element.css(cssValues);\n              }\n\n              return element.removeData(\"keys\").stop(clearQueue);\n            }\n          });\n        }\n\n        function animationProperty(element, property) {\n          if (transforms) {\n            var transform = element.css(TRANSFORM);\n\n            if (transform == NONE) {\n              return property == \"scale\" ? 1 : 0;\n            }\n\n            var match = transform.match(new RegExp(property + \"\\\\s*\\\\(([\\\\d\\\\w\\\\.]+)\")),\n                computed = 0;\n\n            if (match) {\n              computed = parseInteger(match[1]);\n            } else {\n              match = transform.match(matrix3dRegExp) || [0, 0, 0, 0, 0];\n              property = property.toLowerCase();\n\n              if (translateXRegExp.test(property)) {\n                computed = parseFloat(match[3] / match[2]);\n              } else if (property == \"translatey\") {\n                computed = parseFloat(match[4] / match[2]);\n              } else if (property == \"scale\") {\n                computed = parseFloat(match[2]);\n              } else if (property == \"rotate\") {\n                computed = parseFloat(Math.atan2(match[2], match[1]));\n              }\n            }\n\n            return computed;\n          } else {\n            return parseFloat(element.css(property));\n          }\n        }\n\n        var EffectSet = kendo.Class.extend({\n          init: function (element, options) {\n            var that = this;\n            that.element = element;\n            that.effects = [];\n            that.options = options;\n            that.restore = [];\n          },\n          run: function (effects) {\n            var that = this,\n                effect,\n                idx,\n                jdx,\n                length = effects.length,\n                element = that.element,\n                options = that.options,\n                deferred = $.Deferred(),\n                start = {},\n                end = {},\n                target,\n                children,\n                childrenLength;\n            that.effects = effects;\n            deferred.done(that.complete.bind(that));\n            element.data(\"animating\", true);\n\n            for (idx = 0; idx < length; idx++) {\n              effect = effects[idx];\n              effect.setReverse(options.reverse);\n              effect.setOptions(options);\n              that.addRestoreProperties(effect.restore);\n              effect.prepare(start, end);\n              children = effect.children();\n\n              for (jdx = 0, childrenLength = children.length; jdx < childrenLength; jdx++) {\n                children[jdx].duration(options.duration).run();\n              }\n            } // legacy support for options.properties\n\n\n            for (var effectName in options.effects) {\n              extend(end, options.effects[effectName].properties);\n            } // Show the element initially\n\n\n            if (!element.is(\":visible\")) {\n              extend(start, {\n                display: element.data(\"olddisplay\") || \"block\"\n              });\n            }\n\n            if (transforms && !options.reset) {\n              target = element.data(\"targetTransform\");\n\n              if (target) {\n                start = extend(target, start);\n              }\n            }\n\n            start = normalizeCSS(element, start);\n\n            if (transforms && !transitions) {\n              start = strip3DTransforms(start);\n            }\n\n            element.css(start).css(TRANSFORM); // Nudge\n\n            for (idx = 0; idx < length; idx++) {\n              effects[idx].setup();\n            }\n\n            if (options.init) {\n              options.init();\n            }\n\n            element.data(\"targetTransform\", end);\n            fx.animate(element, end, extend({}, options, {\n              complete: deferred.resolve\n            }));\n            return deferred.promise();\n          },\n          stop: function () {\n            $(this.element).kendoStop(true, true);\n          },\n          addRestoreProperties: function (restore) {\n            var element = this.element,\n                value,\n                i = 0,\n                length = restore.length;\n\n            for (; i < length; i++) {\n              value = restore[i];\n              this.restore.push(value);\n\n              if (!element.data(value)) {\n                element.data(value, element.css(value));\n              }\n            }\n          },\n          restoreCallback: function () {\n            var element = this.element;\n\n            for (var i = 0, length = this.restore.length; i < length; i++) {\n              var value = this.restore[i];\n              element.css(value, element.data(value));\n            }\n          },\n          complete: function () {\n            var that = this,\n                idx = 0,\n                element = that.element,\n                options = that.options,\n                effects = that.effects,\n                length = effects.length;\n            element.removeData(\"animating\").dequeue(); // call next animation from the queue\n\n            if (options.hide) {\n              element.data(\"olddisplay\", element.css(\"display\")).hide();\n            }\n\n            this.restoreCallback();\n\n            if (hasZoom && !transforms) {\n              setTimeout(this.restoreCallback.bind(this), 0); // Again jQuery callback in IE8-\n            }\n\n            for (; idx < length; idx++) {\n              effects[idx].teardown();\n            }\n\n            if (options.completeCallback) {\n              options.completeCallback(element);\n            }\n          }\n        });\n\n        fx.promise = function (element, options) {\n          var effects = [],\n              effectClass,\n              effectSet = new EffectSet(element, options),\n              parsedEffects = kendo.parseEffects(options.effects),\n              effect;\n          options.effects = parsedEffects;\n\n          for (var effectName in parsedEffects) {\n            effectClass = fx[capitalize(effectName)];\n\n            if (effectClass) {\n              effect = new effectClass(element, parsedEffects[effectName].direction);\n              effects.push(effect);\n            }\n          }\n\n          if (effects[0]) {\n            effectSet.run(effects);\n          } else {\n            // Not sure how would an fx promise reach this state - means that you call kendoAnimate with no valid effects? Why?\n            if (!element.is(\":visible\")) {\n              element.css({\n                display: element.data(\"olddisplay\") || \"block\"\n              }).css(\"display\");\n            }\n\n            if (options.init) {\n              options.init();\n            }\n\n            element.dequeue();\n            effectSet.complete();\n          }\n        };\n\n        extend(fx, {\n          animate: function (elements, properties, options) {\n            var useTransition = options.transition !== false;\n            delete options.transition;\n\n            if (transitions && \"transition\" in fx && useTransition) {\n              fx.transition(elements, properties, options);\n            } else {\n              if (transforms) {\n                elements.animate(strip3DTransforms(properties), {\n                  queue: false,\n                  show: false,\n                  hide: false,\n                  duration: options.duration,\n                  complete: options.complete\n                }); // Stop animate from showing/hiding the element to be able to hide it later on.\n              } else {\n                elements.each(function () {\n                  var element = $(this),\n                      multiple = {};\n                  each(transformProps, function (idx, value) {\n                    // remove transforms to avoid IE and older browsers confusion\n                    var params,\n                        currentValue = properties ? properties[value] + \" \" : null; // We need to match\n\n                    if (currentValue) {\n                      var single = properties;\n\n                      if (value in scaleProperties && properties[value] !== undefined) {\n                        params = currentValue.match(cssParamsRegExp);\n\n                        if (transforms) {\n                          extend(single, {\n                            scale: +params[0]\n                          });\n                        }\n                      } else {\n                        if (value in translateProperties && properties[value] !== undefined) {\n                          var position = element.css(POSITION),\n                              isFixed = position == \"absolute\" || position == \"fixed\";\n\n                          if (!element.data(TRANSLATE)) {\n                            if (isFixed) {\n                              element.data(TRANSLATE, {\n                                top: parseCSS(element, \"top\") || 0,\n                                left: parseCSS(element, \"left\") || 0,\n                                bottom: parseCSS(element, \"bottom\"),\n                                right: parseCSS(element, \"right\")\n                              });\n                            } else {\n                              element.data(TRANSLATE, {\n                                top: parseCSS(element, \"marginTop\") || 0,\n                                left: parseCSS(element, \"marginLeft\") || 0\n                              });\n                            }\n                          }\n\n                          var originalPosition = element.data(TRANSLATE);\n                          params = currentValue.match(cssParamsRegExp);\n\n                          if (params) {\n                            var dX = value == TRANSLATE + \"y\" ? +null : +params[1],\n                                dY = value == TRANSLATE + \"y\" ? +params[1] : +params[2];\n\n                            if (isFixed) {\n                              if (!isNaN(originalPosition.right)) {\n                                if (!isNaN(dX)) {\n                                  extend(single, {\n                                    right: originalPosition.right - dX\n                                  });\n                                }\n                              } else {\n                                if (!isNaN(dX)) {\n                                  extend(single, {\n                                    left: originalPosition.left + dX\n                                  });\n                                }\n                              }\n\n                              if (!isNaN(originalPosition.bottom)) {\n                                if (!isNaN(dY)) {\n                                  extend(single, {\n                                    bottom: originalPosition.bottom - dY\n                                  });\n                                }\n                              } else {\n                                if (!isNaN(dY)) {\n                                  extend(single, {\n                                    top: originalPosition.top + dY\n                                  });\n                                }\n                              }\n                            } else {\n                              if (!isNaN(dX)) {\n                                extend(single, {\n                                  marginLeft: originalPosition.left + dX\n                                });\n                              }\n\n                              if (!isNaN(dY)) {\n                                extend(single, {\n                                  marginTop: originalPosition.top + dY\n                                });\n                              }\n                            }\n                          }\n                        }\n                      }\n\n                      if (!transforms && value != \"scale\" && value in single) {\n                        delete single[value];\n                      }\n\n                      if (single) {\n                        extend(multiple, single);\n                      }\n                    }\n                  });\n\n                  if (browser.msie) {\n                    delete multiple.scale;\n                  }\n\n                  element.animate(multiple, {\n                    queue: false,\n                    show: false,\n                    hide: false,\n                    duration: options.duration,\n                    complete: options.complete\n                  }); // Stop animate from showing/hiding the element to be able to hide it later on.\n                });\n              }\n            }\n          }\n        });\n        fx.animatedPromise = fx.promise;\n        var Effect = kendo.Class.extend({\n          init: function (element, direction) {\n            var that = this;\n            that.element = element;\n            that._direction = direction;\n            that.options = {};\n            that._additionalEffects = [];\n\n            if (!that.restore) {\n              that.restore = [];\n            }\n          },\n          // Public API\n          reverse: function () {\n            this._reverse = true;\n            return this.run();\n          },\n          play: function () {\n            this._reverse = false;\n            return this.run();\n          },\n          add: function (additional) {\n            this._additionalEffects.push(additional);\n\n            return this;\n          },\n          direction: function (value) {\n            this._direction = value;\n            return this;\n          },\n          duration: function (duration) {\n            this._duration = duration;\n            return this;\n          },\n          compositeRun: function () {\n            var that = this,\n                effectSet = new EffectSet(that.element, {\n              reverse: that._reverse,\n              duration: that._duration\n            }),\n                effects = that._additionalEffects.concat([that]);\n\n            return effectSet.run(effects);\n          },\n          run: function () {\n            if (this._additionalEffects && this._additionalEffects[0]) {\n              return this.compositeRun();\n            }\n\n            var that = this,\n                element = that.element,\n                idx = 0,\n                restore = that.restore,\n                length = restore.length,\n                value,\n                deferred = $.Deferred(),\n                start = {},\n                end = {},\n                target,\n                children = that.children(),\n                childrenLength = children.length;\n            deferred.done(that._complete.bind(that));\n            element.data(\"animating\", true);\n\n            for (idx = 0; idx < length; idx++) {\n              value = restore[idx];\n\n              if (!element.data(value)) {\n                element.data(value, element.css(value));\n              }\n            }\n\n            for (idx = 0; idx < childrenLength; idx++) {\n              children[idx].duration(that._duration).run();\n            }\n\n            that.prepare(start, end);\n\n            if (!element.is(\":visible\")) {\n              extend(start, {\n                display: element.data(\"olddisplay\") || \"block\"\n              });\n            }\n\n            if (transforms) {\n              target = element.data(\"targetTransform\");\n\n              if (target) {\n                start = extend(target, start);\n              }\n            }\n\n            start = normalizeCSS(element, start);\n\n            if (transforms && !transitions) {\n              start = strip3DTransforms(start);\n            }\n\n            element.css(start).css(TRANSFORM); // Trick webkit into re-rendering\n\n            that.setup();\n            element.data(\"targetTransform\", end);\n            fx.animate(element, end, {\n              duration: that._duration,\n              complete: deferred.resolve\n            });\n            return deferred.promise();\n          },\n          stop: function () {\n            var idx = 0,\n                children = this.children(),\n                childrenLength = children.length;\n\n            for (idx = 0; idx < childrenLength; idx++) {\n              children[idx].stop();\n            }\n\n            $(this.element).kendoStop(true, true);\n            return this;\n          },\n          restoreCallback: function () {\n            var element = this.element;\n\n            for (var i = 0, length = this.restore.length; i < length; i++) {\n              var value = this.restore[i];\n              element.css(value, element.data(value));\n            }\n          },\n          _complete: function () {\n            var that = this,\n                element = that.element;\n            element.removeData(\"animating\").dequeue(); // call next animation from the queue\n\n            that.restoreCallback();\n\n            if (that.shouldHide()) {\n              element.data(\"olddisplay\", element.css(\"display\")).hide();\n            }\n\n            if (hasZoom && !transforms) {\n              setTimeout(that.restoreCallback.bind(that), 0); // Again jQuery callback in IE8-\n            }\n\n            that.teardown();\n          },\n          /////////////////////////// Support for kendo.animate;\n          setOptions: function (options) {\n            extend(true, this.options, options);\n          },\n          children: function () {\n            return [];\n          },\n          shouldHide: $.noop,\n          setup: $.noop,\n          prepare: $.noop,\n          teardown: $.noop,\n          directions: [],\n          setReverse: function (reverse) {\n            this._reverse = reverse;\n            return this;\n          }\n        });\n\n        function capitalize(word) {\n          return word.charAt(0).toUpperCase() + word.substring(1);\n        }\n\n        function createEffect(name, definition) {\n          var effectClass = Effect.extend(definition),\n              directions = effectClass.prototype.directions;\n          fx[capitalize(name)] = effectClass;\n\n          fx.Element.prototype[name] = function (direction, opt1, opt2, opt3) {\n            return new effectClass(this.element, direction, opt1, opt2, opt3);\n          };\n\n          each(directions, function (idx, theDirection) {\n            fx.Element.prototype[name + capitalize(theDirection)] = function (opt1, opt2, opt3) {\n              return new effectClass(this.element, theDirection, opt1, opt2, opt3);\n            };\n          });\n        }\n\n        var FOUR_DIRECTIONS = [\"left\", \"right\", \"up\", \"down\"],\n            IN_OUT = [\"in\", \"out\"];\n        createEffect(\"slideIn\", {\n          directions: FOUR_DIRECTIONS,\n          divisor: function (value) {\n            this.options.divisor = value;\n            return this;\n          },\n          prepare: function (start, end) {\n            var that = this,\n                tmp,\n                element = that.element,\n                outerWidth = kendo._outerWidth,\n                outerHeight = kendo._outerHeight,\n                direction = directions[that._direction],\n                offset = -direction.modifier * (direction.vertical ? outerHeight(element) : outerWidth(element)),\n                startValue = offset / (that.options && that.options.divisor || 1) + PX,\n                endValue = \"0px\";\n\n            if (that._reverse) {\n              tmp = start;\n              start = end;\n              end = tmp;\n            }\n\n            if (transforms) {\n              start[direction.transition] = startValue;\n              end[direction.transition] = endValue;\n            } else {\n              start[direction.property] = startValue;\n              end[direction.property] = endValue;\n            }\n          }\n        });\n        createEffect(\"tile\", {\n          directions: FOUR_DIRECTIONS,\n          init: function (element, direction, previous) {\n            Effect.prototype.init.call(this, element, direction);\n            this.options = {\n              previous: previous\n            };\n          },\n          previousDivisor: function (value) {\n            this.options.previousDivisor = value;\n            return this;\n          },\n          children: function () {\n            var that = this,\n                reverse = that._reverse,\n                previous = that.options.previous,\n                divisor = that.options.previousDivisor || 1,\n                dir = that._direction;\n            var children = [kendo.fx(that.element).slideIn(dir).setReverse(reverse)];\n\n            if (previous) {\n              children.push(kendo.fx(previous).slideIn(directions[dir].reverse).divisor(divisor).setReverse(!reverse));\n            }\n\n            return children;\n          }\n        });\n\n        function createToggleEffect(name, property, defaultStart, defaultEnd) {\n          createEffect(name, {\n            directions: IN_OUT,\n            startValue: function (value) {\n              this._startValue = value;\n              return this;\n            },\n            endValue: function (value) {\n              this._endValue = value;\n              return this;\n            },\n            shouldHide: function () {\n              return this._shouldHide;\n            },\n            prepare: function (start, end) {\n              var that = this,\n                  startValue,\n                  endValue,\n                  out = this._direction === \"out\",\n                  startDataValue = that.element.data(property),\n                  startDataValueIsSet = !(isNaN(startDataValue) || startDataValue == defaultStart);\n\n              if (startDataValueIsSet) {\n                startValue = startDataValue;\n              } else if (typeof this._startValue !== \"undefined\") {\n                startValue = this._startValue;\n              } else {\n                startValue = out ? defaultStart : defaultEnd;\n              }\n\n              if (typeof this._endValue !== \"undefined\") {\n                endValue = this._endValue;\n              } else {\n                endValue = out ? defaultEnd : defaultStart;\n              }\n\n              if (this._reverse) {\n                start[property] = endValue;\n                end[property] = startValue;\n              } else {\n                start[property] = startValue;\n                end[property] = endValue;\n              }\n\n              that._shouldHide = end[property] === defaultEnd;\n            }\n          });\n        }\n\n        createToggleEffect(\"fade\", \"opacity\", 1, 0);\n        createToggleEffect(\"zoom\", \"scale\", 1, 0.01);\n        createEffect(\"slideMargin\", {\n          prepare: function (start, end) {\n            var that = this,\n                element = that.element,\n                options = that.options,\n                origin = element.data(ORIGIN),\n                offset = options.offset,\n                margin,\n                reverse = that._reverse;\n\n            if (!reverse && origin === null) {\n              element.data(ORIGIN, parseFloat(element.css(\"margin-\" + options.axis)));\n            }\n\n            margin = element.data(ORIGIN) || 0;\n            end[\"margin-\" + options.axis] = !reverse ? margin + offset : margin;\n          }\n        });\n        createEffect(\"slideTo\", {\n          prepare: function (start, end) {\n            var that = this,\n                element = that.element,\n                options = that.options,\n                offset = options.offset.split(\",\"),\n                reverse = that._reverse;\n\n            if (transforms) {\n              end.translatex = !reverse ? offset[0] : 0;\n              end.translatey = !reverse ? offset[1] : 0;\n            } else {\n              end.left = !reverse ? offset[0] : 0;\n              end.top = !reverse ? offset[1] : 0;\n            }\n\n            element.css(\"left\");\n          }\n        });\n        createEffect(\"expand\", {\n          directions: [\"horizontal\", \"vertical\"],\n          restore: [OVERFLOW],\n          prepare: function (start, end) {\n            var that = this,\n                element = that.element,\n                options = that.options,\n                reverse = that._reverse,\n                property = that._direction === \"vertical\" ? HEIGHT : WIDTH,\n                setLength = element[0].style[property],\n                oldLength = element.data(property),\n                length = parseFloat(oldLength || setLength),\n                realLength = round(element.css(property, AUTO)[property]());\n            start.overflow = HIDDEN;\n            length = options && options.reset ? realLength || length : length || realLength;\n            end[property] = (reverse ? 0 : length) + PX;\n            start[property] = (reverse ? length : 0) + PX;\n\n            if (oldLength === undefined) {\n              element.data(property, setLength);\n            }\n          },\n          shouldHide: function () {\n            return this._reverse;\n          },\n          teardown: function () {\n            var that = this,\n                element = that.element,\n                property = that._direction === \"vertical\" ? HEIGHT : WIDTH,\n                length = element.data(property);\n\n            if (length == AUTO || length === BLANK) {\n              setTimeout(function () {\n                element.css(property, AUTO).css(property);\n              }, 0); // jQuery animate complete callback in IE is called before the last animation step!\n            }\n          }\n        });\n        var TRANSFER_START_STATE = {\n          position: \"absolute\",\n          marginLeft: 0,\n          marginTop: 0,\n          scale: 1\n        };\n        /**\n         * Intersection point formulas are taken from here - http://zonalandeducation.com/mmts/intersections/intersectionOfTwoLines1/intersectionOfTwoLines1.html\n         * Formula for a linear function from two points from here - http://demo.activemath.org/ActiveMath2/search/show.cmd?id=mbase://AC_UK_calculus/functions/ex_linear_equation_two_points\n         * The transform origin point is the intersection point of the two lines from the top left corners/top right corners of the element and target.\n         * The math and variables below MAY BE SIMPLIFIED (zeroes removed), but this would make the formula too cryptic.\n         */\n\n        createEffect(\"transfer\", {\n          init: function (element, target) {\n            this.element = element;\n            this.options = {\n              target: target\n            };\n            this.restore = [];\n          },\n          setup: function () {\n            this.element.appendTo(document.body);\n          },\n          prepare: function (start, end) {\n            var that = this,\n                element = that.element,\n                outerBox = fx.box(element),\n                innerBox = fx.box(that.options.target),\n                currentScale = animationProperty(element, \"scale\"),\n                scale = fx.fillScale(innerBox, outerBox),\n                transformOrigin = fx.transformOrigin(innerBox, outerBox);\n            extend(start, TRANSFER_START_STATE);\n            end.scale = 1;\n            element.css(TRANSFORM, \"scale(1)\").css(TRANSFORM);\n            element.css(TRANSFORM, \"scale(\" + currentScale + \")\");\n            start.top = outerBox.top;\n            start.left = outerBox.left;\n            start.transformOrigin = transformOrigin.x + PX + \" \" + transformOrigin.y + PX;\n\n            if (that._reverse) {\n              start.scale = scale;\n            } else {\n              end.scale = scale;\n            }\n          }\n        });\n        var CLIPS = {\n          top: \"rect(auto auto $size auto)\",\n          bottom: \"rect($size auto auto auto)\",\n          left: \"rect(auto $size auto auto)\",\n          right: \"rect(auto auto auto $size)\"\n        };\n        var ROTATIONS = {\n          top: {\n            start: \"rotatex(0deg)\",\n            end: \"rotatex(180deg)\"\n          },\n          bottom: {\n            start: \"rotatex(-180deg)\",\n            end: \"rotatex(0deg)\"\n          },\n          left: {\n            start: \"rotatey(0deg)\",\n            end: \"rotatey(-180deg)\"\n          },\n          right: {\n            start: \"rotatey(180deg)\",\n            end: \"rotatey(0deg)\"\n          }\n        };\n\n        function clipInHalf(container, direction) {\n          var vertical = kendo.directions[direction].vertical,\n              size = container[vertical ? HEIGHT : WIDTH]() / 2 + \"px\";\n          return CLIPS[direction].replace(\"$size\", size);\n        }\n\n        createEffect(\"turningPage\", {\n          directions: FOUR_DIRECTIONS,\n          init: function (element, direction, container) {\n            Effect.prototype.init.call(this, element, direction);\n            this._container = container;\n          },\n          prepare: function (start, end) {\n            var that = this,\n                reverse = that._reverse,\n                direction = reverse ? directions[that._direction].reverse : that._direction,\n                rotation = ROTATIONS[direction];\n            start.zIndex = 1;\n\n            if (that._clipInHalf) {\n              start.clip = clipInHalf(that._container, kendo.directions[direction].reverse);\n            }\n\n            start[BACKFACE] = HIDDEN;\n            end[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.start : rotation.end);\n            start[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.end : rotation.start);\n          },\n          setup: function () {\n            this._container.append(this.element);\n          },\n          face: function (value) {\n            this._face = value;\n            return this;\n          },\n          shouldHide: function () {\n            var that = this,\n                reverse = that._reverse,\n                face = that._face;\n            return reverse && !face || !reverse && face;\n          },\n          clipInHalf: function (value) {\n            this._clipInHalf = value;\n            return this;\n          },\n          temporary: function () {\n            this.element.addClass('temp-page');\n            return this;\n          }\n        });\n        createEffect(\"staticPage\", {\n          directions: FOUR_DIRECTIONS,\n          init: function (element, direction, container) {\n            Effect.prototype.init.call(this, element, direction);\n            this._container = container;\n          },\n          restore: [\"clip\"],\n          prepare: function (start, end) {\n            var that = this,\n                direction = that._reverse ? directions[that._direction].reverse : that._direction;\n            start.clip = clipInHalf(that._container, direction);\n            start.opacity = 0.999;\n            end.opacity = 1;\n          },\n          shouldHide: function () {\n            var that = this,\n                reverse = that._reverse,\n                face = that._face;\n            return reverse && !face || !reverse && face;\n          },\n          face: function (value) {\n            this._face = value;\n            return this;\n          }\n        });\n        createEffect(\"pageturn\", {\n          directions: [\"horizontal\", \"vertical\"],\n          init: function (element, direction, face, back) {\n            Effect.prototype.init.call(this, element, direction);\n            this.options = {};\n            this.options.face = face;\n            this.options.back = back;\n          },\n          children: function () {\n            var that = this,\n                options = that.options,\n                direction = that._direction === \"horizontal\" ? \"left\" : \"top\",\n                reverseDirection = kendo.directions[direction].reverse,\n                reverse = that._reverse,\n                temp,\n                faceClone = options.face.clone(true).removeAttr(\"id\"),\n                backClone = options.back.clone(true).removeAttr(\"id\"),\n                element = that.element;\n\n            if (reverse) {\n              temp = direction;\n              direction = reverseDirection;\n              reverseDirection = temp;\n            }\n\n            return [kendo.fx(options.face).staticPage(direction, element).face(true).setReverse(reverse), kendo.fx(options.back).staticPage(reverseDirection, element).setReverse(reverse), kendo.fx(faceClone).turningPage(direction, element).face(true).clipInHalf(true).temporary().setReverse(reverse), kendo.fx(backClone).turningPage(reverseDirection, element).clipInHalf(true).temporary().setReverse(reverse)];\n          },\n          prepare: function (start, end) {\n            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;\n            start.transformStyle = \"preserve-3d\"; // hack to trigger transition end.\n\n            start.opacity = 0.999;\n            end.opacity = 1;\n          },\n          teardown: function () {\n            this.element.find(\".temp-page\").remove();\n          }\n        });\n        createEffect(\"flip\", {\n          directions: [\"horizontal\", \"vertical\"],\n          init: function (element, direction, face, back) {\n            Effect.prototype.init.call(this, element, direction);\n            this.options = {};\n            this.options.face = face;\n            this.options.back = back;\n          },\n          children: function () {\n            var that = this,\n                options = that.options,\n                direction = that._direction === \"horizontal\" ? \"left\" : \"top\",\n                reverseDirection = kendo.directions[direction].reverse,\n                reverse = that._reverse,\n                temp,\n                element = that.element;\n\n            if (reverse) {\n              temp = direction;\n              direction = reverseDirection;\n              reverseDirection = temp;\n            }\n\n            return [kendo.fx(options.face).turningPage(direction, element).face(true).setReverse(reverse), kendo.fx(options.back).turningPage(reverseDirection, element).setReverse(reverse)];\n          },\n          prepare: function (start) {\n            start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;\n            start.transformStyle = \"preserve-3d\";\n          }\n        });\n        var RESTORE_OVERFLOW = !support.mobileOS.android;\n        var IGNORE_TRANSITION_EVENT_SELECTOR = \".km-touch-scrollbar, .km-actionsheet-wrapper\";\n        createEffect(\"replace\", {\n          _before: $.noop,\n          _after: $.noop,\n          init: function (element, previous, transitionClass) {\n            Effect.prototype.init.call(this, element);\n            this._previous = $(previous);\n            this._transitionClass = transitionClass;\n          },\n          duration: function () {\n            throw new Error(\"The replace effect does not support duration setting; the effect duration may be customized through the transition class rule\");\n          },\n          beforeTransition: function (callback) {\n            this._before = callback;\n            return this;\n          },\n          afterTransition: function (callback) {\n            this._after = callback;\n            return this;\n          },\n          _both: function () {\n            return $().add(this._element).add(this._previous);\n          },\n          _containerClass: function () {\n            var direction = this._direction,\n                containerClass = \"k-fx k-fx-start k-fx-\" + this._transitionClass;\n\n            if (direction) {\n              containerClass += \" k-fx-\" + direction;\n            }\n\n            if (this._reverse) {\n              containerClass += \" k-fx-reverse\";\n            }\n\n            return containerClass;\n          },\n          complete: function (e) {\n            if (!this.deferred || e && $(e.target).is(IGNORE_TRANSITION_EVENT_SELECTOR)) {\n              return;\n            }\n\n            var container = this.container;\n            container.removeClass(\"k-fx-end\").removeClass(this._containerClass()).off(transitions.event, this.completeProxy);\n\n            this._previous.hide().removeClass(\"k-fx-current\");\n\n            this.element.removeClass(\"k-fx-next\");\n\n            if (RESTORE_OVERFLOW) {\n              container.css(OVERFLOW, \"\");\n            }\n\n            if (!this.isAbsolute) {\n              this._both().css(POSITION, \"\");\n            }\n\n            this.deferred.resolve();\n            delete this.deferred;\n          },\n          run: function () {\n            if (this._additionalEffects && this._additionalEffects[0]) {\n              return this.compositeRun();\n            }\n\n            var that = this,\n                element = that.element,\n                previous = that._previous,\n                container = element.parents().filter(previous.parents()).first(),\n                both = that._both(),\n                deferred = $.Deferred(),\n                originalPosition = element.css(POSITION),\n                originalOverflow; // edge case for grid/scheduler, where the previous is already destroyed.\n\n\n            if (!container.length) {\n              container = element.parent();\n            }\n\n            this.container = container;\n            this.deferred = deferred;\n            this.isAbsolute = originalPosition == \"absolute\";\n\n            if (!this.isAbsolute) {\n              both.css(POSITION, \"absolute\");\n            }\n\n            if (RESTORE_OVERFLOW) {\n              originalOverflow = container.css(OVERFLOW);\n              container.css(OVERFLOW, \"hidden\");\n            }\n\n            if (!transitions) {\n              this.complete();\n            } else {\n              element.addClass(\"k-fx-hidden\");\n              container.addClass(this._containerClass());\n              this.completeProxy = this.complete.bind(this);\n              container.on(transitions.event, this.completeProxy);\n              kendo.animationFrame(function () {\n                element.removeClass(\"k-fx-hidden\").addClass(\"k-fx-next\");\n                previous.css(\"display\", \"\").addClass(\"k-fx-current\");\n\n                that._before(previous, element);\n\n                kendo.animationFrame(function () {\n                  container.removeClass(\"k-fx-start\").addClass(\"k-fx-end\");\n\n                  that._after(previous, element);\n                });\n              });\n            }\n\n            return deferred.promise();\n          },\n          stop: function () {\n            this.complete();\n          }\n        });\n        var Animation = kendo.Class.extend({\n          init: function () {\n            var that = this;\n            that._tickProxy = that._tick.bind(that);\n            that._started = false;\n          },\n          tick: $.noop,\n          done: $.noop,\n          onEnd: $.noop,\n          onCancel: $.noop,\n          start: function () {\n            if (!this.enabled()) {\n              return;\n            }\n\n            if (!this.done()) {\n              this._started = true;\n              kendo.animationFrame(this._tickProxy);\n            } else {\n              this.onEnd();\n            }\n          },\n          enabled: function () {\n            return true;\n          },\n          cancel: function () {\n            this._started = false;\n            this.onCancel();\n          },\n          _tick: function () {\n            var that = this;\n\n            if (!that._started) {\n              return;\n            }\n\n            that.tick();\n\n            if (!that.done()) {\n              kendo.animationFrame(that._tickProxy);\n            } else {\n              that._started = false;\n              that.onEnd();\n            }\n          }\n        });\n        var Transition = Animation.extend({\n          init: function (options) {\n            var that = this;\n            extend(that, options);\n            Animation.fn.init.call(that);\n          },\n          done: function () {\n            return this.timePassed() >= this.duration;\n          },\n          timePassed: function () {\n            return Math.min(this.duration, new Date() - this.startDate);\n          },\n          moveTo: function (options) {\n            var that = this,\n                movable = that.movable;\n            that.initial = movable[that.axis];\n            that.delta = options.location - that.initial;\n            that.duration = typeof options.duration == \"number\" ? options.duration : 300;\n            that.tick = that._easeProxy(options.ease);\n            that.startDate = new Date();\n            that.start();\n          },\n          _easeProxy: function (ease) {\n            var that = this;\n            return function () {\n              that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));\n            };\n          }\n        });\n        extend(Transition, {\n          easeOutExpo: function (t, b, c, d) {\n            return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n          },\n          easeOutBack: function (t, b, c, d, s) {\n            s = 1.70158;\n            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n          }\n        });\n        fx.Animation = Animation;\n        fx.Transition = Transition;\n        fx.createEffect = createEffect;\n\n        fx.box = function (element) {\n          element = $(element);\n          var result = element.offset();\n          result.width = kendo._outerWidth(element);\n          result.height = kendo._outerHeight(element);\n          return result;\n        };\n\n        fx.transformOrigin = function (inner, outer) {\n          var x = (inner.left - outer.left) * outer.width / (outer.width - inner.width),\n              y = (inner.top - outer.top) * outer.height / (outer.height - inner.height);\n          return {\n            x: isNaN(x) ? 0 : x,\n            y: isNaN(y) ? 0 : y\n          };\n        };\n\n        fx.fillScale = function (inner, outer) {\n          return Math.min(inner.width / outer.width, inner.height / outer.height);\n        };\n\n        fx.fitScale = function (inner, outer) {\n          return Math.max(inner.width / outer.width, inner.height / outer.height);\n        };\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}