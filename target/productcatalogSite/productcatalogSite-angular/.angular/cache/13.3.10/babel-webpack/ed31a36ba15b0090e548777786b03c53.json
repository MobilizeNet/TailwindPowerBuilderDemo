{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1708);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1708:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(1709)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        var RangeRef = kendo.spreadsheet.RangeRef;\n        var CellRef = kendo.spreadsheet.CellRef;\n        var EdgeNavigator = kendo.Class.extend({\n          init: function (field, axis, rangeGetter, union) {\n            this.rangeGetter = rangeGetter;\n\n            this.prevLeft = function (index) {\n              var current = union(this.range(index));\n              var range = this.range(axis.prevVisible(current.topLeft[field]));\n              return union(range).topLeft[field];\n            };\n\n            this.nextRight = function (index) {\n              var current = union(this.range(index));\n              var range = this.range(axis.nextVisible(current.bottomRight[field]));\n              return union(range).bottomRight[field];\n            }; // these two don't look like the other ones, as they \"shrink\"\n\n\n            this.nextLeft = function (index) {\n              var range = union(this.range(index));\n              return axis.nextVisible(range.bottomRight[field]);\n            };\n\n            this.prevRight = function (index) {\n              var range = union(this.range(index));\n              return axis.prevVisible(range.topLeft[field]);\n            };\n          },\n          boundary: function (top, bottom) {\n            this.top = top;\n            this.bottom = bottom;\n          },\n          range: function (index) {\n            return this.rangeGetter(index, this.top, this.bottom);\n          }\n        });\n        var SheetNavigator = kendo.Class.extend({\n          init: function (sheet) {\n            this._sheet = sheet;\n            this.autoFillCalculator = new kendo.spreadsheet.AutoFillCalculator(sheet._grid);\n            this.colEdge = new EdgeNavigator(\"col\", this._sheet._grid._columns, this.columnRange.bind(this), this.union.bind(this));\n            this.rowEdge = new EdgeNavigator(\"row\", this._sheet._grid._rows, this.rowRange.bind(this), this.union.bind(this));\n          },\n          height: function (height) {\n            this._viewPortHeight = height;\n          },\n          union: function (ref) {\n            return this._sheet.unionWithMerged(ref);\n          },\n          columnRange: function (col, topRow, bottomRow) {\n            return this._sheet._ref(topRow, col, bottomRow - topRow, 1);\n          },\n          rowRange: function (row, leftCol, rightCol) {\n            return this._sheet._ref(row, leftCol, 1, rightCol - leftCol);\n          },\n          selectionIncludesMergedCells: function () {\n            return this._sheet.select().contains(this._sheet._mergedCells);\n          },\n          setSelectionValue: function (value) {\n            var selection = this._sheet.selection();\n\n            setTimeout(function () {\n              selection.value(value());\n            });\n          },\n          selectAll: function () {\n            this._sheet.select(this._sheet._sheetRef);\n          },\n          select: function (ref, mode, addToExisting) {\n            ref = this.refForMode(ref, mode);\n\n            if (addToExisting) {\n              ref = this._sheet.select().concat(ref);\n            }\n\n            this._sheet.select(ref);\n          },\n          refForMode: function (ref, mode) {\n            var grid = this._sheet._grid;\n\n            switch (mode) {\n              case \"range\":\n                ref = grid.normalize(ref);\n                break;\n\n              case \"row\":\n                ref = grid.rowRef(ref.row);\n                break;\n\n              case \"column\":\n                ref = grid.colRef(ref.col);\n                break;\n\n              case \"sheet\":\n                ref = this._sheet._sheetRef;\n                break;\n            }\n\n            return ref;\n          },\n          startSelection: function (ref, mode, addToExisting, shiftKey, view) {\n            if (mode == \"autofill\") {\n              this._sheet.startAutoFill();\n            } else if (shiftKey && mode == \"range\") {\n              var range = new RangeRef(this._sheet.activeCell().first(), ref);\n\n              this._sheet.select(range, false, false);\n\n              this._sheet.startSelection(view);\n            } else {\n              this._sheet.startSelection(view);\n\n              this.select(ref, mode, addToExisting);\n            }\n          },\n          completeSelection: function () {\n            this._sheet.completeSelection();\n          },\n          selectForContextMenu: function (ref, mode) {\n            var sheet = this._sheet;\n            sheet._activeDrawing = null;\n\n            if (!sheet.select().contains(this.refForMode(ref, mode))) {\n              this.select(ref, mode);\n            }\n          },\n          selectDrawingForContextMenu: function (drawing) {\n            var sheet = this._sheet;\n            sheet._activeDrawing = drawing;\n            sheet.triggerChange({\n              selection: true\n            });\n          },\n          modifySelection: function (action) {\n            var direction = this.determineDirection(action);\n            var sheet = this._sheet;\n            var viewPortHeight = this._viewPortHeight;\n            var rows = sheet._grid._rows;\n            var columns = sheet._grid._columns;\n            var originalSelection = sheet.currentOriginalSelectionRange();\n            var selection = sheet.select().toRangeRef();\n            var activeCell = sheet.activeCell();\n            var topLeft = originalSelection.topLeft.clone();\n            var bottomRight = originalSelection.bottomRight.clone();\n            var bottomLeft = new CellRef(bottomRight.row, topLeft.col);\n            var scrollInto;\n            this.colEdge.boundary(selection.topLeft.row, selection.bottomRight.row);\n            this.rowEdge.boundary(selection.topLeft.col, selection.bottomRight.col);\n\n            switch (direction) {\n              case \"expand-left\":\n                // <| |\n                topLeft.col = this.colEdge.prevLeft(topLeft.col);\n                scrollInto = topLeft;\n                break;\n\n              case \"shrink-right\":\n                // |>|\n                topLeft.col = this.colEdge.nextLeft(topLeft.col);\n                scrollInto = topLeft;\n                break;\n\n              case \"expand-right\":\n                // | |>\n                bottomRight.col = this.colEdge.nextRight(bottomRight.col);\n                scrollInto = bottomRight;\n                break;\n\n              case \"shrink-left\":\n                // |<|\n                bottomRight.col = this.colEdge.prevRight(bottomRight.col);\n                scrollInto = bottomRight;\n                break;\n              // four actions below mirror the upper ones, on the vertical axis\n\n              case \"expand-up\":\n                topLeft.row = this.rowEdge.prevLeft(topLeft.row);\n                scrollInto = topLeft;\n                break;\n\n              case \"shrink-down\":\n                topLeft.row = this.rowEdge.nextLeft(topLeft.row);\n                scrollInto = topLeft;\n                break;\n\n              case \"expand-down\":\n                bottomRight.row = this.rowEdge.nextRight(bottomRight.row);\n                scrollInto = bottomRight;\n                break;\n\n              case \"shrink-up\":\n                bottomRight.row = this.rowEdge.prevRight(bottomRight.row);\n                scrollInto = bottomRight;\n                break;\n              // pageup/down - may need improvement\n\n              case \"expand-page-up\":\n                topLeft.row = rows.prevPage(topLeft.row, viewPortHeight);\n                break;\n\n              case \"shrink-page-up\":\n                bottomRight.row = rows.prevPage(bottomRight.row, viewPortHeight);\n                break;\n\n              case \"expand-page-down\":\n                bottomRight.row = rows.nextPage(bottomRight.row, viewPortHeight);\n                break;\n\n              case \"shrink-page-down\":\n                topLeft.row = rows.nextPage(topLeft.row, viewPortHeight);\n                break;\n\n              case \"first-col\":\n                topLeft.col = columns.firstVisible();\n                bottomRight.col = activeCell.bottomRight.col;\n                scrollInto = topLeft;\n                break;\n\n              case \"last-col\":\n                bottomRight.col = columns.lastVisible();\n                topLeft.col = activeCell.topLeft.col;\n                scrollInto = bottomRight;\n                break;\n\n              case \"first-row\":\n                topLeft.row = rows.firstVisible();\n                bottomRight.row = activeCell.bottomRight.row;\n                scrollInto = topLeft;\n                break;\n\n              case \"last-row\":\n                bottomRight.row = rows.lastVisible();\n                topLeft.row = activeCell.topLeft.row;\n                scrollInto = bottomRight;\n                break;\n\n              case \"last\":\n                bottomRight.row = rows.lastVisible();\n                bottomRight.col = columns.lastVisible();\n                topLeft = activeCell.topLeft;\n                scrollInto = bottomRight;\n                break;\n\n              case \"first\":\n                topLeft.row = rows.firstVisible();\n                topLeft.col = columns.firstVisible();\n                bottomRight = activeCell.bottomRight;\n                scrollInto = topLeft;\n                break;\n\n              case \"expand-word-right\":\n                bottomRight.col = columns.nextUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));\n                scrollInto = bottomRight;\n                break;\n\n              case \"shrink-word-right\":\n                topLeft.col = columns.nextUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));\n                scrollInto = topLeft;\n                break;\n\n              case \"expand-word-left\":\n                topLeft.col = columns.prevUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));\n                scrollInto = topLeft;\n                break;\n\n              case \"shrink-word-left\":\n                bottomRight.col = columns.prevUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));\n                scrollInto = bottomRight;\n                break;\n\n              case \"expand-word-up\":\n                topLeft.row = rows.prevUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));\n                scrollInto = topLeft;\n                break;\n\n              case \"shrink-word-up\":\n                bottomRight.row = rows.prevUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));\n                scrollInto = bottomRight;\n                break;\n\n              case \"expand-word-down\":\n                bottomRight.row = rows.nextUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));\n                scrollInto = bottomRight;\n                break;\n\n              case \"shrink-word-down\":\n                topLeft.row = rows.nextUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));\n                scrollInto = topLeft;\n                break;\n            }\n\n            var newSelection = new RangeRef(topLeft, bottomRight);\n\n            if (!this.union(newSelection).intersects(activeCell)) {\n              // throw new Error(newSelection.print() + \" does not contain \" + activeCell.print());\n              this.modifySelection(direction.replace(\"shrink\", \"expand\"));\n              return;\n            }\n\n            if (scrollInto) {\n              sheet.focus(scrollInto);\n            }\n\n            this.updateCurrentSelectionRange(newSelection);\n          },\n          moveActiveCell: function (direction) {\n            var sheet = this._sheet;\n            var activeCell = sheet.activeCell();\n            var topLeft = activeCell.topLeft;\n            var bottomRight = activeCell.bottomRight;\n            var cell = sheet.originalActiveCell();\n            var rows = sheet._grid._rows;\n            var columns = sheet._grid._columns;\n            var row = cell.row;\n            var column = cell.col;\n\n            switch (direction) {\n              case \"left\":\n                column = columns.prevVisible(topLeft.col);\n                break;\n\n              case \"up\":\n                row = rows.prevVisible(topLeft.row);\n                break;\n\n              case \"right\":\n                column = columns.nextVisible(bottomRight.col);\n                break;\n\n              case \"down\":\n                row = rows.nextVisible(bottomRight.row);\n                break;\n\n              case \"first-col\":\n                column = columns.firstVisible();\n                break;\n\n              case \"last-col\":\n                column = columns.lastVisible();\n                break;\n\n              case \"first-row\":\n                row = rows.firstVisible();\n                break;\n\n              case \"last-row\":\n                row = rows.lastVisible();\n                break;\n\n              case \"last\":\n                row = rows.lastVisible();\n                column = columns.lastVisible();\n                break;\n\n              case \"first\":\n                row = rows.firstVisible();\n                column = columns.firstVisible();\n                break;\n\n              case \"next-page\":\n                row = rows.nextPage(bottomRight.row, this._viewPortHeight);\n                break;\n\n              case \"prev-page\":\n                row = rows.prevPage(bottomRight.row, this._viewPortHeight);\n                break;\n\n              case \"word-right\":\n                column = columns.nextUntil(column, makeWordMovement(sheet, bottomRight, true));\n                break;\n\n              case \"word-left\":\n                column = columns.prevUntil(column, makeWordMovement(sheet, bottomRight, true));\n                break;\n\n              case \"word-up\":\n                row = rows.prevUntil(row, makeWordMovement(sheet, bottomRight, false));\n                break;\n\n              case \"word-down\":\n                row = rows.nextUntil(row, makeWordMovement(sheet, bottomRight, false));\n                break;\n            }\n\n            sheet.select(new CellRef(row, column));\n          },\n          navigateInSelection: function (direction) {\n            var sheet = this._sheet;\n            var activeCell = sheet.activeCell();\n            var topLeft = activeCell.topLeft;\n            var cell = sheet.originalActiveCell();\n            var rows = sheet._grid._rows;\n            var columns = sheet._grid._columns;\n            var row = cell.row;\n            var column = cell.col;\n            var isFirstCell = false;\n            var isLastCell = false;\n            var selTopLeft, selBottomRight;\n            var topLeftCol = topLeft.col;\n            var topLeftRow = topLeft.row;\n            var tmp;\n\n            function setSelection(sel) {\n              selTopLeft = sel.topLeft;\n              selBottomRight = sel.bottomRight;\n            }\n\n            setSelection(sheet.currentNavigationRange());\n            var done = false;\n            var navigatedAway = false;\n\n            while (!done && !navigatedAway) {\n              var current = new CellRef(row, column);\n              var isSingleCellSelected = sheet.singleCellSelection();\n\n              if (isSingleCellSelected) {\n                isFirstCell = selTopLeft.eq(current) && sheet._sheetRef.topLeft.eq(current);\n                isLastCell = selBottomRight.eq(current) && sheet._sheetRef.bottomRight.eq(current);\n\n                if (!isFirstCell) {\n                  isFirstCell = columns.firstVisible() === column && rows.firstVisible() === row;\n                }\n\n                if (!isLastCell) {\n                  isLastCell = columns.lastVisible() === column && rows.lastVisible() === row;\n                }\n              }\n\n              switch (direction) {\n                case \"next\":\n                  if (isLastCell) {\n                    navigatedAway = true;\n                    kendo.focusNextElement();\n                  } else if (selBottomRight.eq(current)) {\n                    setSelection(sheet.nextNavigationRange());\n                    row = selTopLeft.row;\n                    column = selTopLeft.col;\n                  } else {\n                    column = columns.nextVisible(topLeftCol);\n\n                    if (column == topLeftCol || column > selBottomRight.col) {\n                      column = selTopLeft.col;\n                      tmp = rows.nextVisible(row);\n\n                      if (tmp == row || tmp > selBottomRight.row) {\n                        row = selTopLeft.row;\n                      } else {\n                        row = tmp;\n                      }\n                    }\n                  }\n\n                  break;\n\n                case \"previous\":\n                  if (isFirstCell) {\n                    navigatedAway = true;\n\n                    this._sheet._workbook._view.element.find('.k-spreadsheet-name-editor .k-input').trigger(\"focus\");\n                  } else if (selTopLeft.eq(current)) {\n                    setSelection(sheet.previousNavigationRange());\n                    row = selBottomRight.row;\n                    column = selBottomRight.col;\n                  } else {\n                    column = columns.prevVisible(topLeftCol);\n\n                    if (column == topLeftCol || column < selTopLeft.col) {\n                      column = selBottomRight.col;\n                      tmp = rows.prevVisible(row);\n\n                      if (tmp == row || tmp < selTopLeft.row) {\n                        row = selBottomRight.row;\n                      } else {\n                        row = tmp;\n                      }\n                    }\n                  }\n\n                  break;\n\n                case \"lower\":\n                  if (selBottomRight.eq(current)) {\n                    setSelection(sheet.nextNavigationRange());\n                    row = selTopLeft.row;\n                    column = selTopLeft.col;\n                  } else {\n                    row = rows.nextVisible(topLeftRow);\n\n                    if (row == topLeftRow || row > selBottomRight.row) {\n                      row = selTopLeft.row;\n                      tmp = columns.nextVisible(column);\n\n                      if (tmp == column || tmp > selBottomRight.col) {\n                        column = selTopLeft.col;\n                      } else {\n                        column = tmp;\n                      }\n                    }\n                  }\n\n                  break;\n\n                case \"upper\":\n                  if (selTopLeft.eq(current)) {\n                    setSelection(sheet.previousNavigationRange());\n                    row = selBottomRight.row;\n                    column = selBottomRight.col;\n                  } else {\n                    row = rows.prevVisible(topLeftRow);\n\n                    if (row == topLeftRow || row < selTopLeft.row) {\n                      row = selBottomRight.row;\n                      tmp = columns.prevVisible(column);\n\n                      if (tmp == column || tmp < selTopLeft.col) {\n                        column = selBottomRight.col;\n                      } else {\n                        column = tmp;\n                      }\n                    }\n                  }\n\n                  break;\n\n                default:\n                  throw new Error(\"Unknown entry navigation: \" + direction);\n              }\n\n              done = !this.shouldSkip(row, column); // if (!done) { console.log(\"skipping\", row, column); }\n\n              topLeftCol = column;\n              topLeftRow = row;\n            }\n\n            if (done) {\n              if (sheet.singleCellSelection()) {\n                sheet.select(new CellRef(row, column));\n              } else {\n                sheet.activeCell(new CellRef(row, column));\n              }\n            }\n          },\n          extendSelection: function (ref, mode) {\n            var sheet = this._sheet;\n            var grid = sheet._grid;\n\n            if (mode === \"autofill\") {\n              this.resizeAutoFill(ref);\n              return;\n            }\n\n            if (mode === \"range\") {\n              ref = grid.normalize(ref);\n            } else if (mode === \"row\") {\n              ref = grid.rowRef(ref.row).bottomRight;\n            } else if (mode === \"column\") {\n              ref = grid.colRef(ref.col).bottomRight;\n            }\n\n            var activeCell = sheet.originalActiveCell().toRangeRef();\n            this.updateCurrentSelectionRange(new RangeRef(activeCell.topLeft, ref));\n          },\n          shouldSkip: function (row, col) {\n            if (this._sheet.isHiddenRow(row) || this._sheet.isHiddenColumn(col)) {\n              return true;\n            }\n\n            var ref = new CellRef(row, col);\n            var isMerged = false;\n\n            this._sheet.forEachMergedCell(function (merged) {\n              if (merged.intersects(ref) && !merged.collapse().eq(ref)) {\n                isMerged = true;\n              }\n            });\n\n            return isMerged;\n          },\n          resizeAutoFill: function (ref) {\n            var sheet = this._sheet;\n            var selection = sheet.select();\n            var origin = sheet._autoFillOrigin;\n            var dest = this.autoFillCalculator.autoFillDest(selection, ref);\n            var punch = this.punch(selection, dest);\n            var hint, direction;\n\n            if (!punch) {\n              var preview = sheet.range(dest)._previewFillFrom(sheet.range(origin));\n\n              if (preview) {\n                direction = preview.direction;\n                hint = preview.hint;\n              }\n            }\n\n            sheet.updateAutoFill(dest, punch, hint, direction);\n          },\n          determineDirection: function (action) {\n            var selection = this._sheet.currentSelectionRange();\n\n            var activeCell = this._sheet.activeCell(); // There may be a third, indeterminate state, caused by a merged cell.\n            // In this state, all key movements are treated as shrinks.\n            // The navigator will reverse them if it detects this it will cause the selection to exclude the active cell.\n\n\n            var leftMode = activeCell.topLeft.col == selection.topLeft.col;\n            var rightMode = activeCell.bottomRight.col == selection.bottomRight.col;\n            var topMode = activeCell.topLeft.row == selection.topLeft.row;\n            var bottomMode = activeCell.bottomRight.row == selection.bottomRight.row;\n\n            switch (action) {\n              case \"left\":\n                action = rightMode ? \"expand-left\" : \"shrink-left\";\n                break;\n\n              case \"right\":\n                action = leftMode ? \"expand-right\" : \"shrink-right\";\n                break;\n\n              case \"up\":\n                action = bottomMode ? \"expand-up\" : \"shrink-up\";\n                break;\n\n              case \"down\":\n                action = topMode ? \"expand-down\" : \"shrink-down\";\n                break;\n\n              case \"prev-page\":\n                action = bottomMode ? \"expand-page-up\" : \"shrink-page-up\";\n                break;\n\n              case \"next-page\":\n                action = topMode ? \"expand-page-down\" : \"shrink-page-down\";\n                break;\n\n              case \"word-left\":\n                action = rightMode ? \"expand-word-left\" : \"shrink-word-left\";\n                break;\n\n              case \"word-right\":\n                action = leftMode ? \"expand-word-right\" : \"shrink-word-right\";\n                break;\n\n              case \"word-up\":\n                action = bottomMode ? \"expand-word-up\" : \"shrink-word-up\";\n                break;\n\n              case \"word-down\":\n                action = topMode ? \"expand-word-down\" : \"shrink-word-down\";\n                break;\n            }\n\n            return action;\n          },\n          updateCurrentSelectionRange: function (ref) {\n            var sheet = this._sheet;\n            sheet.select(sheet.originalSelect().replaceAt(sheet.selectionRangeIndex(), ref), false);\n          },\n          punch: function (selection, subset) {\n            var punch;\n\n            if (subset.topLeft.eq(selection.topLeft)) {\n              if (subset.bottomRight.row < selection.bottomRight.row) {\n                var bottomRow = this.rowEdge.nextRight(subset.bottomRight.row);\n                punch = new RangeRef(new CellRef(bottomRow, selection.topLeft.col), selection.bottomRight);\n              } else if (subset.bottomRight.col < selection.bottomRight.col) {\n                var bottomCol = this.colEdge.nextRight(subset.bottomRight.col);\n                punch = new RangeRef(new CellRef(selection.topLeft.row, bottomCol), selection.bottomRight);\n              }\n            }\n\n            return punch;\n          }\n        });\n\n        function makeWordMovement(sheet, pivot, isCol) {\n          // the general idea is:\n          //\n          // - if we start on a non-empty cell, we should select the\n          //   range of non-empty cells that follow it.  If, however,\n          //   the second cell is empty, then we don't stop there; we\n          //   should skip all the empty cells and stop at the first\n          //   non-empty cell (and select it).\n          //\n          // - if we start on an empty cell, then skip all empty cells\n          //   and select the first non-empty one.\n          var firstVal = sheet.range(pivot).value();\n          return function (pos, advanced, hidden) {\n            if (hidden) {\n              return true;\n            } // skip hidden cells\n\n\n            var val = (isCol ? sheet.range(pivot.row, pos) : sheet.range(pos, pivot.col)).value();\n\n            if (firstVal === null) {\n              return val === null ? false : pos;\n            } else if (!advanced && val === null) {\n              firstVal = null; // switch to the other mode\n\n              return false;\n            } else {\n              return val === null;\n            }\n          };\n        }\n\n        kendo.spreadsheet.SheetNavigator = SheetNavigator;\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1709:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./autofillcalculator\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}