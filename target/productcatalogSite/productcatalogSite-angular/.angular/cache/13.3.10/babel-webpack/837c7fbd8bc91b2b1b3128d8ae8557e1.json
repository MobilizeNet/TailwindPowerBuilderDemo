{"ast":null,"code":"import { drawing as draw, Color } from '@progress/kendo-drawing';\nimport BarLabel from './bar-label';\nimport { BORDER_BRIGHTNESS, TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { ChartElement, Point } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport NoteMixin from '../mixins/note-mixin';\nimport { WHITE, LEFT, RIGHT, BOTTOM, TOP } from '../../common/constants';\nimport { alignPathToPixel, deepExtend, defined, getTemplate, valueOrDefault } from '../../common';\nconst BAR_ALIGN_MIN_WIDTH = 6;\n\nclass Bar extends ChartElement {\n  constructor(value, options) {\n    super();\n    this.options = options;\n    this.color = options.color || WHITE;\n    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n    this.value = value;\n  }\n\n  render() {\n    if (this._rendered) {\n      return;\n    }\n\n    this._rendered = true;\n    this.createLabel();\n    this.createNote();\n\n    if (this.errorBar) {\n      this.append(this.errorBar);\n    }\n  }\n\n  createLabel() {\n    const options = this.options;\n    const labels = options.labels;\n\n    if (labels.visible) {\n      const pointData = this.pointData();\n      let labelTemplate = getTemplate(labels);\n      let labelText;\n\n      if (labelTemplate) {\n        labelText = labelTemplate(pointData);\n      } else {\n        labelText = this.formatValue(labels.format);\n      }\n\n      this.label = new BarLabel(labelText, deepExtend({\n        vertical: options.vertical\n      }, labels), pointData);\n      this.append(this.label);\n    }\n  }\n\n  formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  }\n\n  reflow(targetBox) {\n    this.render();\n    const label = this.label;\n    this.box = targetBox;\n\n    if (label) {\n      label.options.aboveAxis = this.aboveAxis;\n      label.reflow(targetBox);\n    }\n\n    if (this.note) {\n      this.note.reflow(targetBox);\n    }\n\n    if (this.errorBars) {\n      for (let i = 0; i < this.errorBars.length; i++) {\n        this.errorBars[i].reflow(targetBox);\n      }\n    }\n  }\n\n  createVisual() {\n    const {\n      box,\n      options\n    } = this;\n    const customVisual = options.visual;\n\n    if (this.visible !== false) {\n      super.createVisual();\n\n      if (customVisual) {\n        const visual = this.rectVisual = customVisual({\n          category: this.category,\n          dataItem: this.dataItem,\n          value: this.value,\n          sender: this.getSender(),\n          series: this.series,\n          percentage: this.percentage,\n          stackValue: this.stackValue,\n          runningTotal: this.runningTotal,\n          total: this.total,\n          rect: box.toRect(),\n          createVisual: () => {\n            const group = new draw.Group();\n            this.createRect(group);\n            return group;\n          },\n          options: options\n        });\n\n        if (visual) {\n          this.visual.append(visual);\n        }\n      } else if (box.width() > 0 && box.height() > 0) {\n        this.createRect(this.visual);\n      }\n    }\n  }\n\n  createRect(visual) {\n    const options = this.options;\n    const border = options.border;\n    const strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n    const rect = this.box.toRect();\n    rect.size.width = Math.round(rect.size.width);\n    const path = this.rectVisual = draw.Path.fromRect(rect, {\n      fill: {\n        color: this.color,\n        opacity: options.opacity\n      },\n      stroke: {\n        color: this.getBorderColor(),\n        width: border.width,\n        opacity: strokeOpacity,\n        dashType: border.dashType\n      }\n    });\n    const width = this.box.width();\n    const height = this.box.height();\n    const size = options.vertical ? width : height;\n\n    if (size > BAR_ALIGN_MIN_WIDTH) {\n      alignPathToPixel(path); // Fixes lineJoin issue in firefox when the joined lines are parallel\n\n      if (width < 1 || height < 1) {\n        path.options.stroke.lineJoin = \"round\";\n      }\n    }\n\n    visual.append(path);\n\n    if (hasGradientOverlay(options)) {\n      const overlay = this.createGradientOverlay(path, {\n        baseColor: this.color\n      }, deepExtend({\n        end: !options.vertical ? [0, 1] : undefined\n      }, options.overlay));\n      visual.append(overlay);\n    }\n  }\n\n  createHighlight(style) {\n    const highlight = draw.Path.fromRect(this.box.toRect(), style);\n    return alignPathToPixel(highlight);\n  }\n\n  highlightVisual() {\n    return this.rectVisual;\n  }\n\n  highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this.rectVisual\n    };\n  }\n\n  getBorderColor() {\n    const color = this.color;\n    const border = this.options.border;\n    const brightness = border._brightness || BORDER_BRIGHTNESS;\n    let borderColor = border.color;\n\n    if (!defined(borderColor)) {\n      borderColor = new Color(color).brightness(brightness).toHex();\n    }\n\n    return borderColor;\n  }\n\n  tooltipAnchor() {\n    const {\n      options,\n      box,\n      aboveAxis\n    } = this;\n    const clipBox = this.owner.pane.clipBox() || box;\n    let horizontalAlign = LEFT;\n    let verticalAlign = TOP;\n    let x, y;\n\n    if (options.vertical) {\n      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n\n      if (aboveAxis) {\n        y = Math.max(box.y1, clipBox.y1);\n      } else {\n        y = Math.min(box.y2, clipBox.y2);\n        verticalAlign = BOTTOM;\n      }\n    } else {\n      const x1 = Math.max(box.x1, clipBox.x1);\n      const x2 = Math.min(box.x2, clipBox.x2);\n\n      if (options.isStacked) {\n        verticalAlign = BOTTOM;\n\n        if (aboveAxis) {\n          horizontalAlign = RIGHT;\n          x = x2;\n        } else {\n          x = x1;\n        }\n\n        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n      } else {\n        if (aboveAxis) {\n          x = x2 + TOOLTIP_OFFSET;\n        } else {\n          x = x1 - TOOLTIP_OFFSET;\n          horizontalAlign = RIGHT;\n        }\n\n        y = Math.max(box.y1, clipBox.y1);\n      }\n    }\n\n    return {\n      point: new Point(x, y),\n      align: {\n        horizontal: horizontalAlign,\n        vertical: verticalAlign\n      }\n    };\n  }\n\n  overlapsBox(box) {\n    return this.box.overlaps(box);\n  }\n\n  pointData() {\n    return {\n      dataItem: this.dataItem,\n      category: this.category,\n      value: this.value,\n      percentage: this.percentage,\n      stackValue: this.stackValue,\n      runningTotal: this.runningTotal,\n      total: this.total,\n      series: this.series\n    };\n  }\n\n}\n\ndeepExtend(Bar.prototype, PointEventsMixin);\ndeepExtend(Bar.prototype, NoteMixin);\nBar.prototype.defaults = {\n  border: {\n    width: 1\n  },\n  vertical: true,\n  overlay: {\n    gradient: \"glass\"\n  },\n  labels: {\n    visible: false,\n    format: \"{0}\"\n  },\n  opacity: 1,\n  notes: {\n    label: {}\n  }\n};\nexport default Bar;","map":null,"metadata":{},"sourceType":"module"}