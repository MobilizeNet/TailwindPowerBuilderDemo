{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(979);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  979:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(980)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            editorNS = kendo.ui.editor,\n            RangeUtils = editorNS.RangeUtils,\n            dom = editorNS.Dom,\n            RestorePoint = editorNS.RestorePoint,\n            Marker = editorNS.Marker,\n            browser = kendo.support.browser,\n            extend = $.extend;\n        var Clipboard = Class.extend({\n          init: function (editor) {\n            this.editor = editor;\n            var pasteCleanup = editor.options.pasteCleanup;\n            this.cleaners = [new ScriptCleaner(pasteCleanup), new TabCleaner(pasteCleanup), new MSWordFormatCleaner(pasteCleanup), new WebkitFormatCleaner(pasteCleanup), new HtmlTagsCleaner(pasteCleanup), new HtmlAttrCleaner(pasteCleanup), new HtmlContentCleaner(pasteCleanup), new CustomCleaner(pasteCleanup) //always keep at end\n            ];\n          },\n          htmlToFragment: function (html) {\n            var editor = this.editor,\n                doc = editor.document,\n                container = dom.create(doc, 'div'),\n                fragment = doc.createDocumentFragment();\n            container.innerHTML = html;\n\n            while (container.firstChild) {\n              fragment.appendChild(container.firstChild);\n            }\n\n            return fragment;\n          },\n          isBlock: function (html) {\n            return /<(div|p|ul|ol|table|h[1-6])/i.test(html);\n          },\n          _startModification: function () {\n            var range;\n            var restorePoint;\n            var editor = this.editor;\n\n            if (this._inProgress) {\n              return;\n            }\n\n            this._inProgress = true;\n            range = editor.getRange();\n            restorePoint = new RestorePoint(range, editor.body);\n            dom.persistScrollTop(editor.document);\n            return {\n              range: range,\n              restorePoint: restorePoint\n            };\n          },\n          _endModification: function (modificationInfo) {\n            editorNS._finishUpdate(this.editor, modificationInfo.restorePoint);\n\n            this.editor._selectionChange();\n\n            this._inProgress = false;\n          },\n          _contentModification: function (before, after) {\n            var that = this;\n            var editor = that.editor;\n\n            var modificationInfo = that._startModification();\n\n            if (!modificationInfo) {\n              return;\n            }\n\n            before.call(that, editor, modificationInfo.range);\n            setTimeout(function () {\n              after.call(that, editor, modificationInfo.range);\n\n              that._endModification(modificationInfo);\n            });\n          },\n          _removeBomNodes: function (range) {\n            var nodes = RangeUtils.textNodes(range);\n\n            for (var i = 0; i < nodes.length; i++) {\n              nodes[i].nodeValue = dom.stripBom(nodes[i].nodeValue) || nodes[i].nodeValue;\n            }\n          },\n          _onBeforeCopy: function (range) {\n            var marker = new Marker();\n            marker.add(range);\n\n            this._removeBomNodes(range);\n\n            marker.remove(range);\n            this.editor.selectRange(range);\n          },\n          oncopy: function () {\n            this._onBeforeCopy(this.editor.getRange());\n          },\n          oncut: function () {\n            this._onBeforeCopy(this.editor.getRange());\n\n            this._contentModification($.noop, $.noop);\n          },\n          _fileToDataURL: function (blob) {\n            var deferred = $.Deferred();\n            var reader = new FileReader();\n\n            if (!(blob instanceof window.File) && blob.getAsFile) {\n              blob = blob.getAsFile();\n            }\n\n            reader.onload = deferred.resolve.bind(deferred);\n            reader.readAsDataURL(blob);\n            return deferred.promise();\n          },\n          _triggerPaste: function (html, options) {\n            var args = {\n              html: html || \"\"\n            };\n            args.html = args.html.replace(/\\ufeff/g, \"\");\n            this.editor.trigger(\"paste\", args);\n            this.paste(args.html, options || {});\n          },\n          _handleImagePaste: function (e) {\n            if (!('FileReader' in window) || browser.msie && browser.version > 10) {\n              return;\n            }\n\n            var clipboardData = e.clipboardData || e.originalEvent.clipboardData || window.clipboardData || {};\n            var items = clipboardData.items || clipboardData.files;\n            return this._insertImages(items);\n          },\n          _insertImages: function (items) {\n            if (!items) {\n              return;\n            }\n\n            var images = $.grep(items, function (item) {\n              return /^image\\//i.test(item.type);\n            });\n            var html = $.grep(items, function (item) {\n              return /^text\\/html/i.test(item.type);\n            });\n\n            if (html.length || !images.length) {\n              return;\n            }\n\n            var modificationInfo = this._startModification();\n\n            if (!modificationInfo) {\n              return;\n            }\n\n            $.when.apply($, $.map(images, this._fileToDataURL)).done(function () {\n              var results = Array.prototype.slice.call(arguments);\n              var html = $.map(results, function (e) {\n                return '<img src=\"' + e.target.result + '\" />';\n              }).join(\"\");\n\n              this._triggerPaste(html);\n\n              this._endModification(modificationInfo);\n            }.bind(this));\n            return true;\n          },\n          onpaste: function (e) {\n            if (this.editor.body.contentEditable === \"false\") {\n              return;\n            }\n\n            if (this._handleImagePaste(e)) {\n              e.preventDefault();\n              return;\n            }\n\n            this.expandImmutablesIn();\n\n            this._contentModification(function beforePaste(editor, range) {\n              var clipboardNode = dom.create(editor.document, 'div', {\n                className: 'k-paste-container',\n                innerHTML: \"\\ufeff\"\n              });\n              var browser = kendo.support.browser;\n              var body = editor.body;\n\n              this._decoreateClipboardNode(clipboardNode, body);\n\n              body.appendChild(clipboardNode); //Browser scrolls to clipboardNode\n\n              if (browser.webkit) {\n                this._moveToCaretPosition(clipboardNode, range);\n              } // text ranges are slow in IE10-, DOM ranges are buggy in IE9-10\n\n\n              if (browser.msie && browser.version < 11) {\n                e.preventDefault();\n                var r = editor.createRange();\n                r.selectNodeContents(clipboardNode);\n                editor.selectRange(r);\n                var textRange = editor.document.body.createTextRange();\n                textRange.moveToElementText(clipboardNode);\n                $(body).off('paste');\n                textRange.execCommand('Paste');\n                $(body).on('paste', this.onpaste.bind(this));\n              } else {\n                var clipboardRange = editor.createRange();\n                clipboardRange.selectNodeContents(clipboardNode);\n                editor.selectRange(clipboardRange);\n              }\n\n              range.deleteContents();\n            }, function afterPaste(editor, range) {\n              var html = \"\",\n                  containers;\n              editor.selectRange(range);\n              containers = $(editor.body).children(\".k-paste-container\");\n              containers.each(function () {\n                var lastChild = this.lastChild;\n\n                if (lastChild && dom.is(lastChild, 'br')) {\n                  dom.remove(lastChild);\n                }\n\n                html += this.innerHTML;\n              });\n              containers.remove();\n\n              this._triggerPaste(html, {\n                clean: true\n              });\n            });\n          },\n          ondragover: function (e) {\n            if (browser.msie || browser.edge) {\n              e.stopPropagation();\n              e.preventDefault();\n            }\n          },\n          ondrop: function (e) {\n            if (!('FileReader' in window)) {\n              return;\n            }\n\n            var dataTransfer = (e.originalEvent || e).dataTransfer || {};\n            var items = dataTransfer.items || dataTransfer.files;\n\n            if (this._insertImages(items)) {\n              e.preventDefault();\n            }\n          },\n          _decoreateClipboardNode: function (node, body) {\n            if (!browser.msie && !browser.webkit) {\n              return;\n            }\n\n            node = $(node);\n            node.css({\n              borderWidth: \"0px\",\n              width: \"0px\",\n              height: \"0px\",\n              overflow: \"hidden\",\n              margin: \"0\",\n              padding: \"0\"\n            });\n\n            if (browser.msie) {\n              //node inherits BODY styles and this causes the browser to add additional\n              var documentElement = $(body.ownerDocument.documentElement);\n              node.css({\n                fontVariant: \"normal\",\n                fontWeight: \"normal\",\n                lineSpacing: \"normal\",\n                lineHeight: \"normal\",\n                textDecoration: \"none\"\n              });\n              var color = documentElement.css(\"color\");\n\n              if (color) {\n                node.css(\"color\", color);\n              }\n\n              var fontFamily = documentElement.css(\"fontFamily\");\n\n              if (fontFamily) {\n                node.css(\"fontFamily\", fontFamily);\n              }\n\n              var fontSize = documentElement.css(\"fontSize\");\n\n              if (fontSize) {\n                node.css(\"fontSize\", fontSize);\n              }\n            }\n          },\n          _moveToCaretPosition: function (node, range) {\n            var that = this;\n            var body = that.editor.body;\n            var nodeOffset = dom.offset(node, body);\n\n            var caretOffset = that._caretOffset(range, body);\n\n            var translateX = caretOffset.left - nodeOffset.left;\n            var translateY = caretOffset.top - nodeOffset.top;\n            var translate = \"translate(\" + translateX + \"px,\" + translateY + \"px)\";\n            $(node).css({\n              \"-webkit-transform\": translate,\n              \"transform\": translate\n            });\n          },\n          _caretOffset: function (range, body) {\n            var editor = this.editor;\n            var caret = dom.create(editor.document, 'span', {\n              innerHTML: \"\\ufeff\"\n            });\n            var startContainer = range.startContainer;\n            var rangeChanged;\n\n            if (range.collapsed) {\n              var isStartTextNode = dom.isDataNode(startContainer);\n\n              if (isStartTextNode && (dom.isBom(startContainer) || range.startOffset === 0)) {\n                dom.insertBefore(caret, startContainer);\n              } else if (isStartTextNode && range.startOffset === startContainer.length) {\n                dom.insertAfter(caret, startContainer);\n              } else {\n                range.insertNode(caret);\n                rangeChanged = true;\n              }\n            } else {\n              startContainer = startContainer === body ? startContainer.childNodes[range.startOffset] : startContainer;\n              dom.insertBefore(caret, startContainer);\n            }\n\n            var offset = dom.offset(caret, body);\n            var prev = caret.previousSibling;\n            var next = caret.nextSibling;\n            dom.remove(caret);\n\n            if (rangeChanged && dom.isDataNode(prev) && dom.isDataNode(next) && !dom.isBom(prev) && !dom.isBom(next)) {\n              var prevLength = prev.length;\n              next.data = prev.data + next.data;\n              range.setStart(next, prevLength);\n              dom.remove(prev);\n              range.collapse(true);\n              editor.selectRange(range);\n            }\n\n            return offset;\n          },\n          expandImmutablesIn: function (range) {\n            var editor = this.editor;\n\n            if (editor && editor.options.immutables) {\n              var body = editor.body;\n              range = range || editor.getRange();\n              kendo.ui.editor.Immutables.expandImmutablesIn(range);\n\n              if (range.startContainer === body && range.startOffset === 0) {\n                var doc = body.ownerDocument;\n                var bomNode = doc.createTextNode(\"\\ufeff\");\n                body.insertBefore(bomNode, body.childNodes[0]);\n                range.setStartBefore(bomNode);\n              }\n\n              editor.selectRange(range);\n            }\n          },\n          splittableParent: function (block, node) {\n            var parentNode, body;\n\n            if (block) {\n              return dom.closestEditableOfType(node, ['p', 'ul', 'ol']) || node.parentNode;\n            }\n\n            parentNode = node.parentNode;\n            body = node.ownerDocument.body;\n\n            if (dom.isInline(parentNode)) {\n              while (parentNode.parentNode != body && !dom.isBlock(parentNode.parentNode)) {\n                parentNode = parentNode.parentNode;\n              }\n            }\n\n            return parentNode;\n          },\n          paste: function (html, options) {\n            var editor = this.editor,\n                i,\n                l,\n                childNodes;\n            this.expandImmutablesIn();\n            options = extend({\n              clean: false,\n              split: true\n            }, options);\n\n            if (!options.skipCleaners) {\n              for (i = 0, l = this.cleaners.length; i < l; i++) {\n                if (this.cleaners[i].applicable(html)) {\n                  html = this.cleaners[i].clean(html);\n                }\n              }\n            }\n\n            if (options.clean) {\n              // remove br elements which immediately precede block elements\n              html = html.replace(/(<br>(\\s|&nbsp;)*)+(<\\/?(div|p|li|col|t))/ig, \"$3\"); // remove empty inline elements\n\n              html = html.replace(/<(a|span)[^>]*><\\/\\1>/ig, \"\");\n            }\n\n            html = html.replace(/<(a|span|font)([^>]*)> <\\/\\1>/ig, \"<$1$2>&nbsp;</$1>\"); // It is possible in IE to copy just <li> tags\n\n            html = html.replace(/^<li/i, '<ul><li').replace(/li>$/g, 'li></ul>');\n            var block = this.isBlock(html);\n            editor.focus();\n            var range = editor.getRange();\n            range.deleteContents();\n\n            if (range.startContainer == editor.document) {\n              range.selectNodeContents(editor.body);\n            }\n\n            var marker = new Marker();\n            var caret = marker.addCaret(range);\n            var parent = this.splittableParent(block, caret);\n            var unwrap = false;\n            var splittable = parent != editor.body && !dom.is(parent, \"td\");\n\n            if (options.split && splittable && (block || dom.isInline(parent))) {\n              range.selectNode(caret);\n              RangeUtils.split(range, parent, true);\n              unwrap = true;\n            }\n\n            var fragment = this.htmlToFragment(html);\n\n            if (fragment.firstChild && fragment.firstChild.className === \"k-paste-container\") {\n              var fragmentsHtml = [];\n\n              for (i = 0, l = fragment.childNodes.length; i < l; i++) {\n                fragmentsHtml.push(fragment.childNodes[i].innerHTML);\n              }\n\n              fragment = this.htmlToFragment(fragmentsHtml.join('<br />'));\n            }\n\n            childNodes = fragment.childNodes;\n            $(childNodes).filter(\"table\").addClass(\"k-table\").end().find(\"table\").addClass(\"k-table\");\n            $(childNodes).each(function (index, elm) {\n              if (dom.isBlock(elm) && !dom.isSelfClosing(elm) && elm.innerHTML === \"\") {\n                elm.appendChild(editor.document.createTextNode(\"\\ufeff\"));\n              }\n            });\n            range.insertNode(fragment);\n            parent = this.splittableParent(block, caret);\n\n            if (unwrap) {\n              while (caret.parentNode != parent) {\n                dom.unwrap(caret.parentNode);\n              }\n\n              dom.unwrap(caret.parentNode);\n            }\n\n            dom.normalize(range.commonAncestorContainer);\n            caret.style.display = 'inline';\n            dom.restoreScrollTop(editor.document);\n            dom.scrollTo(caret);\n            marker.removeCaret(range);\n            var rangeEnd = range.commonAncestorContainer.parentNode;\n\n            if (range.collapsed && dom.name(rangeEnd) == \"tbody\" || range.collapsed && dom.name(rangeEnd) == \"thead\") {\n              range.setStartAfter($(rangeEnd).closest(\"table\")[0]);\n              range.collapse(true);\n            }\n\n            var focusedTable = $(range.commonAncestorContainer.parentNode).closest(\"table\");\n\n            if (focusedTable.get(0)) {\n              var siblingNodes = focusedTable.parent().contents();\n              var lastSiblingIndex = siblingNodes.length - 1;\n              var lastSibling = siblingNodes.get(lastSiblingIndex);\n\n              while (lastSibling.nodeValue !== null && (lastSibling.nodeValue === \" \" || lastSibling.nodeValue === \"\")) {\n                lastSiblingIndex -= 1;\n                lastSibling = siblingNodes.get(lastSiblingIndex);\n              }\n\n              if (lastSibling === focusedTable.get(0) && !focusedTable.parents(\"table\").length) {\n                dom.insertAfter(dom.createEmptyNode(editor.document, \"p\"), focusedTable[0]);\n              }\n            }\n\n            editor.selectRange(range);\n          }\n        });\n        var Cleaner = Class.extend({\n          init: function (options) {\n            this.options = options || {};\n            this.replacements = [];\n          },\n          clean: function (html, customReplacements) {\n            var that = this,\n                replacements = customReplacements || that.replacements,\n                i,\n                l;\n\n            for (i = 0, l = replacements.length; i < l; i += 2) {\n              html = html.replace(replacements[i], replacements[i + 1]);\n            }\n\n            return html;\n          }\n        });\n        var ScriptCleaner = Cleaner.extend({\n          init: function (options) {\n            Cleaner.fn.init.call(this, options);\n            this.replacements = [/<(\\/?)script([^>]*)>/i, \"<$1telerik:script$2>\"];\n          },\n          applicable: function (html) {\n            return !this.options.none && /<script[^>]*>/i.test(html);\n          }\n        });\n        var TabCleaner = Cleaner.extend({\n          init: function (options) {\n            Cleaner.fn.init.call(this, options);\n            var replacement = ' ';\n            this.replacements = [/<span\\s+class=\"Apple-tab-span\"[^>]*>\\s*<\\/span>/gi, replacement, /\\t/gi, replacement, /&nbsp;&nbsp; &nbsp;/gi, replacement];\n          },\n          applicable: function (html) {\n            return /&nbsp;&nbsp; &nbsp;|class=\"?Apple-tab-span/i.test(html);\n          }\n        });\n        var MSWordFormatCleaner = Cleaner.extend({\n          init: function (options) {\n            Cleaner.fn.init.call(this, options);\n            this.junkReplacements = [/<\\?xml[^>]*>/gi, '', /<!--(.|\\n)*?-->/g, '',\n            /* comments */\n            /&quot;/g, \"'\",\n            /* encoded quotes (in attributes) */\n            /<o:p>&nbsp;<\\/o:p>/ig, '&nbsp;', /<\\/?(meta|link|style|o:|v:|x:)[^>]*>((?:.|\\n)*?<\\/(meta|link|style|o:|v:|x:)[^>]*>)?/ig, '',\n            /* external references and namespaced tags */\n            /<\\/o>/g, ''];\n            this.replacements = this.junkReplacements.concat([/(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(h[1-6]|hr|p|div|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|address|pre|form|blockquote|dl|dt|dd|dir|fieldset)[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*/g, '$1', /<br><br>/g, '<BR><BR>', /<br>\\n/g, '<br/>', /<br>(?!\\n)/g, ' ', /<table([^>]*)>(\\s|&nbsp;)+<t/gi, '<table$1><t', /<tr[^>]*>(\\s|&nbsp;)*<\\/tr>/gi, '', /<tbody[^>]*>(\\s|&nbsp;)*<\\/tbody>/gi, '', /<table[^>]*>(\\s|&nbsp;)*<\\/table>/gi, '', /<BR><BR>/g, '<br>', /^\\s*(&nbsp;)+/gi, '', /(&nbsp;|<br[^>]*>)+\\s*$/gi, '', /mso-[^;\"]*;?/ig, '',\n            /* office-related CSS attributes */\n            /<(\\/?)b(\\s[^>]*)?>/ig, '<$1strong$2>', /<(\\/?)font(\\s[^>]*)?>/ig, this.convertFontMatch, /<(\\/?)i(\\s[^>]*)?>/ig, '<$1em$2>', /style=([\"|'])\\s*\\1/g, '',\n            /* empty style attributes */\n            /(<br[^>]*>)?\\n/g, function ($0, $1) {\n              return $1 ? $0 : ' ';\n            }\n            /* phantom extra line feeds */\n            ]);\n          },\n          convertFontMatch: function (match, closing, args) {\n            var faceRe = /face=['\"]([^'\"]+)['\"]/i;\n            var face = faceRe.exec(args);\n            var family = args && face && face[1];\n\n            if (closing) {\n              return '</span>';\n            } else if (family) {\n              return '<span style=\"font-family:' + family + '\">';\n            } else {\n              return '<span>';\n            }\n          },\n          applicable: function (html) {\n            return /class=\"?Mso/i.test(html) || /style=\"[^\"]*mso-/i.test(html) || /urn:schemas-microsoft-com:office/.test(html);\n          },\n          stripEmptyAnchors: function (html) {\n            return html.replace(/<a([^>]*)>\\s*<\\/a>/ig, function (a, attributes) {\n              if (!attributes || attributes.indexOf(\"href\") < 0) {\n                return \"\";\n              }\n\n              return a;\n            });\n          },\n          listType: function (p, listData) {\n            var html = p.innerHTML;\n            var text = dom.innerText(p);\n            var startingSymbol;\n            var matchSymbol = html.match(/^(?:<span [^>]*texhtml[^>]*>)?<span [^>]*(?:Symbol|Wingdings)[^>]*>([^<]+)/i);\n            var symbol = matchSymbol && matchSymbol[1];\n            var isNumber = /^[a-z\\d]/i.test(symbol); //including alpha-numeric and roman numerals\n\n            var trimStartText = function (text) {\n              return text.replace(/^(?:&nbsp;|[\\u00a0\\n\\r\\s])+/, '');\n            };\n\n            if (matchSymbol) {\n              startingSymbol = true;\n            }\n\n            html = html.replace(/<\\/?\\w+[^>]*>/g, '').replace(/&nbsp;/g, '\\u00a0');\n\n            if (!startingSymbol && /^[\\u2022\\u00b7\\u00a7\\u00d8o]\\u00a0+/.test(html) || startingSymbol && /^.\\u00a0+/.test(html) || symbol && !isNumber && listData) {\n              return {\n                tag: 'ul',\n                style: this._guessUnorderedListStyle(trimStartText(text))\n              };\n            }\n\n            if (/^\\s*\\w+[\\.\\)][\\u00a0 ]{2,}/.test(html)) {\n              return {\n                tag: 'ol',\n                style: this._guessOrderedListStyle(trimStartText(text))\n              };\n            }\n          },\n          _convertToLi: function (p) {\n            var content;\n\n            if (p.childNodes.length == 1) {\n              content = p.firstChild.nodeType === dom.nodeTypes.TEXT_NODE ? dom.innerText(p) : p.firstChild.innerHTML.replace(/^\\w+[\\.\\)](&nbsp;)+ /, \"\");\n              content = this._checkForBullet(content);\n            } else {\n              content = this._getHtmlNoBullet(p);\n            }\n\n            dom.remove(p);\n            return dom.create(document, 'li', {\n              innerHTML: content\n            });\n          },\n          _checkForBullet: function (html) {\n            var p = dom.create(document, 'p', {\n              innerHTML: html\n            });\n            var bulletRgx = /^\\s*\\w+[\\.\\)]\\s+/;\n\n            if (bulletRgx.test(p.innerText)) {\n              return this._getHtmlNoBullet(p);\n            }\n\n            return html;\n          },\n          _getHtmlNoBullet: function (element) {\n            var content,\n                name = dom.name(element);\n            dom.remove(element.firstChild); // check for roman numerals\n\n            if (element.firstChild.nodeType == 3) {\n              if (/^[ivxlcdm]+\\.$/i.test(element.firstChild.nodeValue)) {\n                dom.remove(element.firstChild);\n              }\n            }\n\n            if (/^(&nbsp;|\\s)+$/i.test(element.firstChild.innerHTML)) {\n              dom.remove(element.firstChild);\n            }\n\n            if (name != \"p\") {\n              content = \"<\" + name + \">\" + element.innerHTML + \"</\" + name + \">\";\n            } else {\n              content = element.innerHTML;\n            }\n\n            return content;\n          },\n          _guessUnorderedListStyle: function (symbol) {\n            if (/^[\\u2022\\u00b7\\u00FC\\u00D8\\u002dv-]/.test(symbol)) {\n              return null; //return \"disc\"; //default CSS value\n            } else if (/^o/.test(symbol)) {\n              return \"circle\";\n            } else {\n              return \"square\";\n            }\n          },\n          _guessOrderedListStyle: function (symbol) {\n            var listType = null;\n\n            if (!/^\\d/.test(symbol)) {\n              listType = (/^[a-z]/.test(symbol) ? 'lower-' : 'upper-') + (/^[ivxlcdm]/i.test(symbol) ? 'roman' : 'alpha');\n            }\n\n            return listType;\n          },\n          extractListLevels: function (html) {\n            var msoListRegExp = /style=['\"]?[^'\"]*?mso-list:\\s?[a-zA-Z]+(\\d+)\\s[a-zA-Z]+(\\d+)\\s(\\w+)/gi;\n            html = html.replace(msoListRegExp, function (match, list, level) {\n              return kendo.format('data-list=\"{0}\" data-level=\"{1}\" {2}', list, level, match);\n            });\n            return html;\n          },\n          _createList: function (type, styleType) {\n            return dom.create(document, type, {\n              style: {\n                listStyleType: styleType\n              }\n            });\n          },\n          lists: function (placeholder) {\n            var blockChildren = $(placeholder).find(dom.blockElements.join(',')),\n                lastMargin = -1,\n                name,\n                levels = {},\n                li,\n                rootMargin,\n                rootIndex,\n                lastRootLi,\n                isLastRootLi,\n                rootList,\n                i,\n                p,\n                type,\n                margin,\n                list,\n                listData,\n                acceptedNameTags = [\"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n                isParentTable = false;\n\n            for (i = 0; i < blockChildren.length; i++) {\n              p = blockChildren[i];\n              listData = $(p).data();\n              var listIndex = listData.list;\n              name = dom.name(p);\n              isParentTable = !!$(p).parents(\"table\").length;\n\n              if (isParentTable) {\n                continue;\n              }\n\n              var listType = this.listType(p, listData);\n              type = listType && listType.tag;\n\n              if (!type || acceptedNameTags.indexOf(name) < 0) {\n                if (!p.innerHTML) {\n                  dom.remove(p);\n                } else if (li && !isLastRootLi) {\n                  li.appendChild(p);\n                }\n\n                continue;\n              } // not supported list levels in ie\n\n\n              if (browser.msie) {\n                continue;\n              }\n\n              margin = listData.level || parseFloat(p.style.marginLeft || 0);\n              var levelType = type + listIndex;\n\n              if (!levels[margin]) {\n                levels[margin] = {};\n              }\n\n              if (!rootMargin || rootMargin < 0) {\n                rootMargin = margin;\n                rootIndex = listIndex;\n                lastRootLi = $(placeholder).find(\"[data-list='\" + rootIndex + \"']\").last()[0];\n                rootList = this._createList(type, listType.style);\n                dom.insertBefore(rootList, p);\n                lastMargin = margin;\n                levels[margin][levelType] = rootList;\n              }\n\n              isLastRootLi = lastRootLi === p;\n              list = levels[margin][levelType];\n\n              if (margin > lastMargin || !list) {\n                list = this._createList(type, listType.style);\n                levels[margin][levelType] = list;\n                li.appendChild(list);\n              }\n\n              li = this._convertToLi(p);\n              list.appendChild(li);\n\n              if (isLastRootLi) {\n                rootMargin = lastMargin = -1;\n              } else {\n                lastMargin = margin;\n              }\n            }\n          },\n          removeAttributes: function (element) {\n            var attributes = element.attributes,\n                i = attributes.length,\n                borderStyles = [],\n                addBorderStyles = function (val) {\n              if (val.trim().indexOf(\"border\") === 0) {\n                borderStyles.push(val.trim());\n              }\n            },\n                attr,\n                attributeName,\n                attributeValues;\n\n            while (i--) {\n              if (dom.name(attributes[i]) != \"colspan\") {\n                attr = attributes[i];\n                attributeName = attr.name;\n\n                if (attributeName === \"style\" && (element.nodeName === \"TD\" || element.nodeName === \"TH\")) {\n                  attributeValues = attr.value.split(\";\");\n                  attributeValues.forEach(addBorderStyles);\n                }\n\n                element.removeAttributeNode(attributes[i]);\n              }\n            }\n\n            if (borderStyles.length > 0) {\n              element.setAttribute(\"style\", borderStyles.join(\";\"));\n            }\n          },\n          createColGroup: function (row) {\n            var cells = row.cells;\n            var table = $(row).closest(\"table\");\n            var colgroup = table.children(\"colgroup\");\n\n            if (cells.length < 2) {\n              return;\n            } else if (colgroup.length) {\n              cells = colgroup.children();\n              colgroup[0].parentNode.removeChild(colgroup[0]);\n            }\n\n            colgroup = $($.map(cells, function (cell) {\n              var width = cell.width;\n\n              if (width && parseInt(width, 10) !== 0) {\n                return kendo.format('<col style=\"width:{0}px;\"/>', width);\n              }\n\n              return \"<col />\";\n            }).join(\"\")); // jquery 1.9/2.0 discrepancy\n\n            if (!colgroup.is(\"colgroup\")) {\n              colgroup = $(\"<colgroup/>\").append(colgroup);\n            }\n\n            colgroup.prependTo(table);\n          },\n          convertHeaders: function (row) {\n            var cells = row.cells,\n                i,\n                boldedCells = $.map(cells, function (cell) {\n              var child = $(cell).children(\"p\").children(\"strong\")[0];\n\n              if (child && dom.name(child) == \"strong\") {\n                return child;\n              }\n            });\n\n            if (boldedCells.length == cells.length) {\n              for (i = 0; i < boldedCells.length; i++) {\n                dom.unwrap(boldedCells[i]);\n              }\n\n              $(row).closest(\"table\").find(\"colgroup\").after(\"<thead></thead>\").end().find(\"thead\").append(row);\n\n              for (i = 0; i < cells.length; i++) {\n                dom.changeTag(cells[i], \"th\");\n              }\n            }\n          },\n          removeParagraphs: function (cells) {\n            var i, j, len, cell, paragraphs;\n\n            for (i = 0; i < cells.length; i++) {\n              this.removeAttributes(cells[i]); // remove paragraphs and insert line breaks between them\n\n              cell = $(cells[i]);\n              paragraphs = cell.children(\"p\");\n\n              for (j = 0, len = paragraphs.length; j < len; j++) {\n                if (j < len - 1) {\n                  dom.insertAfter(dom.create(document, \"br\"), paragraphs[j]);\n                }\n\n                dom.unwrap(paragraphs[j]);\n              }\n            }\n          },\n          removeDefaultColors: function (spans) {\n            for (var i = 0; i < spans.length; i++) {\n              if (/^\\s*color:\\s*[^;]*;?$/i.test(spans[i].style.cssText)) {\n                dom.unwrap(spans[i]);\n              }\n            }\n          },\n          removeTextNodes: function (trs) {\n            var i, j, childNodes, currentNode, row;\n\n            for (i = 0; i < trs.length; i++) {\n              row = trs[i];\n              childNodes = row.childNodes;\n\n              for (j = 0; j < childNodes.length; j++) {\n                currentNode = childNodes[j];\n\n                if (currentNode.nodeType === dom.nodeTypes.TEXT_NODE) {\n                  row.removeChild(currentNode);\n                }\n              }\n            }\n          },\n          tables: function (placeholder) {\n            var tables = $(placeholder).find(\"table\"),\n                that = this,\n                rows,\n                firstRow,\n                longestRow,\n                i,\n                j;\n\n            for (i = 0; i < tables.length; i++) {\n              rows = tables[i].rows;\n              longestRow = firstRow = rows[0];\n\n              for (j = 1; j < rows.length; j++) {\n                if (rows[j].cells.length > longestRow.cells.length) {\n                  longestRow = rows[j];\n                }\n              }\n\n              that.createColGroup(longestRow);\n              that.convertHeaders(firstRow);\n              that.removeAttributes(tables[i]);\n              that.removeParagraphs(tables.eq(i).find(\"td,th\"));\n              that.removeDefaultColors(tables.eq(i).find(\"span\"));\n              that.removeTextNodes(tables.eq(i).find(\"tr\"));\n            }\n          },\n          headers: function (placeholder) {\n            var titles = $(placeholder).find(\"p.MsoTitle\");\n\n            for (var i = 0; i < titles.length; i++) {\n              dom.changeTag(titles[i], \"h1\");\n            }\n          },\n          removeFormatting: function (placeholder) {\n            $(placeholder).find(\"*\").each(function () {\n              $(this).css({\n                fontSize: \"\",\n                fontFamily: \"\"\n              });\n\n              if (!this.getAttribute(\"style\") && !this.style.cssText) {\n                this.removeAttribute(\"style\");\n              }\n            });\n          },\n          clean: function (html) {\n            var that = this,\n                placeholder;\n            var filters = this.options;\n\n            if (filters.none) {\n              html = Cleaner.fn.clean.call(that, html, this.junkReplacements);\n              html = that.stripEmptyAnchors(html);\n            } else {\n              html = filters.msConvertLists ? this.extractListLevels(html) : html;\n              html = Cleaner.fn.clean.call(that, html);\n              html = that.stripEmptyAnchors(html);\n              placeholder = dom.create(document, 'div', {\n                innerHTML: html\n              });\n              that.headers(placeholder);\n\n              if (filters.msConvertLists) {\n                that.lists(placeholder);\n              }\n\n              that.tables(placeholder);\n\n              if (filters.msAllFormatting) {\n                that.removeFormatting(placeholder);\n              }\n\n              html = placeholder.innerHTML.replace(/(<[^>]*)\\s+class=\"?[^\"\\s>]*\"?/ig, '$1');\n            }\n\n            return html;\n          }\n        });\n        var WebkitFormatCleaner = Cleaner.extend({\n          init: function (options) {\n            Cleaner.fn.init.call(this, options);\n            this.replacements = [/\\s+class=\"Apple-style-span[^\"]*\"/gi, '', /<(div|p|h[1-6])\\s+style=\"[^\"]*\"/gi, '<$1', /^<div>(.*)<\\/div>$/, '$1'];\n          },\n          applicable: function (html) {\n            return /class=\"?Apple-style-span|style=\"[^\"]*-webkit-nbsp-mode/i.test(html);\n          }\n        });\n        var DomCleaner = Cleaner.extend({\n          clean: function (html) {\n            var container = dom.create(document, 'div', {\n              innerHTML: html\n            });\n            container = this.cleanDom(container);\n            return container.innerHTML;\n          },\n          cleanDom: function (container) {\n            return container;\n          }\n        });\n        var HtmlTagsCleaner = DomCleaner.extend({\n          cleanDom: function (container) {\n            var tags = this.collectTags();\n            $(container).find(tags).each(function () {\n              dom.unwrap(this);\n            });\n            return container;\n          },\n          collectTags: function () {\n            if (this.options.span) {\n              return \"span\";\n            }\n          },\n          applicable: function () {\n            return this.options.span;\n          }\n        });\n        var HtmlAttrCleaner = DomCleaner.extend({\n          cleanDom: function (container) {\n            var attributes = this.collectAttr();\n            var nodes = $(container).find(\"[\" + attributes.join(\"],[\") + \"]\");\n            nodes.removeAttr(attributes.join(\" \"));\n            return container;\n          },\n          collectAttr: function () {\n            if (this.options.css) {\n              return [\"class\", \"style\"];\n            }\n\n            return [];\n          },\n          applicable: function () {\n            return this.options.css;\n          }\n        });\n\n        var TextContainer = function () {\n          this.text = \"\";\n\n          this.add = function (text) {\n            this.text += text;\n          };\n        };\n\n        var HtmlTextLines = Class.extend({\n          init: function (separators) {\n            this.separators = separators || {\n              text: \" \",\n              line: \"<br/>\"\n            };\n            this.lines = [];\n            this.inlineBlockText = [];\n            this.resetLine();\n          },\n          appendText: function (text) {\n            if (text.nodeType === 3) {\n              text = text.nodeValue;\n            }\n\n            this.textContainer.add(text);\n          },\n          appendInlineBlockText: function (text) {\n            this.inlineBlockText.push(text);\n          },\n          flashInlineBlockText: function () {\n            if (this.inlineBlockText.length) {\n              this.appendText(this.inlineBlockText.join(\" \"));\n              this.inlineBlockText = [];\n            }\n          },\n          endLine: function () {\n            this.flashInlineBlockText();\n            this.resetLine();\n          },\n          html: function () {\n            var separators = this.separators;\n            var result = \"\";\n            var lines = this.lines;\n            this.flashInlineBlockText();\n\n            for (var i = 0, il = lines.length, il1 = il - 1; i < il; i++) {\n              var line = lines[i];\n\n              for (var j = 0, jl = line.length, jl1 = jl - 1; j < jl; j++) {\n                var text = line[j].text;\n                result += text;\n\n                if (j !== jl1) {\n                  result += separators.text;\n                }\n              }\n\n              if (i !== il1) {\n                result += separators.line;\n              }\n            }\n\n            return result;\n          },\n          resetLine: function () {\n            this.textContainer = new TextContainer();\n            this.line = [];\n            this.line.push(this.textContainer);\n            this.lines.push(this.line);\n          }\n        });\n        var DomEnumerator = Class.extend({\n          init: function (callback) {\n            this.callback = callback;\n          },\n          enumerate: function (node) {\n            if (!node) {\n              return;\n            }\n\n            var preventDown = this.callback(node);\n            var child = node.firstChild;\n\n            if (!preventDown && child) {\n              this.enumerate(child);\n            }\n\n            this.enumerate(node.nextSibling);\n          }\n        });\n        var HtmlContentCleaner = Cleaner.extend({\n          init: function (options) {\n            Cleaner.fn.init.call(this, options);\n            this.hasText = false; //unpleasant flag to prevent an empty line at the beginning of the generated content.\n\n            this.enumerator = new DomEnumerator(this.buildText.bind(this));\n          },\n          clean: function (html) {\n            var container = dom.create(document, 'div', {\n              innerHTML: html\n            });\n            return this.cleanDom(container);\n          },\n          cleanDom: function (container) {\n            this.separators = this.getDefaultSeparators();\n            this.htmlLines = new HtmlTextLines(this.separators);\n            this.enumerator.enumerate(container.firstChild);\n            this.hasText = false;\n            return this.htmlLines.html();\n          },\n          buildText: function (node) {\n            if (dom.isDataNode(node)) {\n              if (dom.isEmptyspace(node)) {\n                return;\n              }\n\n              this.htmlLines.appendText(node.nodeValue.replace('\\n', this.separators.line));\n              this.hasText = true;\n            } else if (dom.isBlock(node) && this.hasText) {\n              var action = this.actions[dom.name(node)] || this.actions.block;\n              return action(this, node);\n            } else if (dom.isBr(node)) {\n              this.htmlLines.appendText(this.separators.line);\n            }\n          },\n          applicable: function () {\n            var o = this.options;\n            return o.all || o.keepNewLines;\n          },\n          getDefaultSeparators: function () {\n            if (this.options.all) {\n              return {\n                text: \" \",\n                line: \" \"\n              };\n            } else {\n              return {\n                text: \" \",\n                line: \"<br/>\"\n              };\n            }\n          },\n          actions: {\n            ul: $.noop,\n            ol: $.noop,\n            table: $.noop,\n            thead: $.noop,\n            tbody: $.noop,\n            td: function (cleaner, node) {\n              var tdCleaner = new HtmlContentCleaner({\n                all: true\n              });\n              var cellText = tdCleaner.cleanDom(node);\n              cleaner.htmlLines.appendInlineBlockText(cellText);\n              return true;\n            },\n            block: function (cleaner) {\n              cleaner.htmlLines.endLine();\n            }\n          }\n        });\n        var CustomCleaner = Cleaner.extend({\n          clean: function (html) {\n            return this.options.custom(html);\n          },\n          applicable: function () {\n            return typeof this.options.custom === \"function\";\n          }\n        });\n        extend(editorNS, {\n          Clipboard: Clipboard,\n          Cleaner: Cleaner,\n          ScriptCleaner: ScriptCleaner,\n          TabCleaner: TabCleaner,\n          MSWordFormatCleaner: MSWordFormatCleaner,\n          WebkitFormatCleaner: WebkitFormatCleaner,\n          HtmlTagsCleaner: HtmlTagsCleaner,\n          HtmlAttrCleaner: HtmlAttrCleaner,\n          HtmlContentCleaner: HtmlContentCleaner,\n          HtmlTextLines: HtmlTextLines,\n          CustomCleaner: CustomCleaner\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  980:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../command\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}