{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { isDevMode, Component, HostBinding, Input, EventEmitter, Output, ViewChild, NgModule } from '@angular/core';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { hasObservers } from '@progress/kendo-angular-common';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * @hidden\n */\n\nconst _c0 = [\"progressStatus\"];\nconst _c1 = [\"progressStatusWrap\"];\n\nfunction ProgressBarComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.formattedLabelValue);\n  }\n}\n\nfunction ProgressBarComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.formattedLabelValue);\n  }\n}\n\nfunction ChunkProgressBarComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"li\", 2);\n  }\n\n  if (rf & 2) {\n    const chunk_r1 = ctx.$implicit;\n    const i_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.orientationStyles.width)(\"height\", ctx_r0.orientationStyles.height);\n    i0.ɵɵclassProp(\"k-first\", i_r2 === 0)(\"k-last\", i_r2 === ctx_r0.chunkCount - 1)(\"k-state-selected\", chunk_r1);\n    i0.ɵɵproperty(\"ngClass\", chunk_r1 ? ctx_r0.progressCssClass : ctx_r0.emptyCssClass)(\"ngStyle\", chunk_r1 ? ctx_r0.progressCssStyle : ctx_r0.emptyCssStyle);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-progressbar',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1650441158,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nconst MIN_MAX_ERROR_MESSAGE = `The max value should be greater than the min.`;\n/**\n * @hidden\n */\n\nconst LABEL_DECIMALS = 3;\n/**\n * @hidden\n */\n\nconst MIN_RATIO = 0.0001;\n/**\n * @hidden\n */\n\nconst reverseChunks = (orientation, reverse) => orientation === 'vertical' && !reverse || orientation === 'horizontal' && reverse;\n/**\n * @hidden\n */\n\n\nconst formatValue = (value, min, max, label) => {\n  const defaultFormattedValue = truncateNumber(value);\n\n  if (typeof label !== 'boolean') {\n    if (typeof label.format === 'string') {\n      switch (label.format) {\n        case 'value':\n          return defaultFormattedValue;\n\n        case 'percent':\n          return `${Math.floor(calculatePercentage(value, min, max))}%`;\n\n        default:\n          return defaultFormattedValue;\n      }\n    } else if (typeof label.format === 'function') {\n      return label.format(value);\n    } else {\n      return defaultFormattedValue;\n    }\n  }\n\n  return defaultFormattedValue;\n};\n/**\n * @hidden\n */\n\n\nconst validateRange = (min, max) => {\n  if (isDevMode && min > max) {\n    throw new Error(MIN_MAX_ERROR_MESSAGE);\n  }\n};\n/**\n * @hidden\n */\n\n\nconst adjustValueToRange = (min, max, value) => Math.max(Math.min(value, max), min);\n/**\n * @hidden\n */\n\n\nconst calculatePercentage = (value, min, max) => {\n  const onePercent = Math.abs((max - min) / 100);\n  return Math.abs((value - min) / onePercent);\n};\n/**\n * @hidden\n */\n\n\nconst truncateNumber = value => {\n  const numberParts = value.toString().split('.');\n  return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;\n};\n/**\n * @hidden\n */\n\n\nconst calculateRatio = (min, max, value) => Math.max((value - min) / (max - min), MIN_RATIO);\n/**\n * @hidden\n */\n\n\nconst extractValueFromChanges = (changes, type, value) => changes[type] && changes[type].currentValue !== undefined ? changes[type].currentValue : value;\n/**\n * @hidden\n */\n\n\nconst runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== 'undefined' && changes.value && previousValue !== displayValue;\n/**\n * @hidden\n */\n\n\nconst stopCurrentAnimation = changes => {\n  const isAnimationChanged = Boolean(changes.animation);\n  const hasAnimation = isAnimationChanged && changes.animation.currentValue;\n  return isAnimationChanged && !hasAnimation;\n};\n/**\n * @hidden\n */\n\n\nlet ProgressBarBase = /*#__PURE__*/(() => {\n  class ProgressBarBase {\n    /**\n     * @hidden\n     */\n    constructor(localization) {\n      this.localization = localization;\n      this.widgetClasses = true;\n      this.roleAttribute = 'progressbar';\n      /**\n       * The maximum value of the ProgressBar.\n       * Defaults to `100`.\n       */\n\n      this.max = 100;\n      /**\n       * The minimum value of the ProgressBar.\n       * Defaults to `0`.\n       */\n\n      this.min = 0;\n      /**\n       * The value of the ProgressBar.\n       * Has to be between `min` and `max`.\n       * By default, the value is equal to the `min` value.\n       */\n\n      /**\n       * The value of the ProgressBar.\n       * Has to be between `min` and `max`.\n       * Defaults to `0`.\n       */\n\n      this.value = 0;\n      /**\n       * Defines the orientation of the ProgressBar\n       * ([see example]({% slug progressbar_orientation %})).\n       * Defaults to `horizontal`.\n       */\n\n      this.orientation = 'horizontal';\n      /**\n       * If set to `true`, the ProgressBar will be disabled\n       * ([see example]({% slug progressbar_disabled %})).\n       * It will still allow you to change its value.\n       * Defaults to `false`.\n       */\n\n      this.disabled = false;\n      /**\n       * If set to `true`, the ProgressBar will be reversed\n       * ([see example]({% slug progressbar_direction %})).\n       * Defaults to `false`.\n       */\n\n      this.reverse = false;\n      /**\n       * Sets the `indeterminate` state of the ProgressBar.\n       * Defaults to `false`.\n       */\n\n      this.indeterminate = false;\n      this.displayValue = 0;\n      this.previousValue = 0;\n      validatePackage(packageMetadata);\n      this.localizationChangeSubscription = localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      });\n    }\n\n    get isHorizontal() {\n      return this.orientation === 'horizontal';\n    }\n\n    get isVertical() {\n      return this.orientation === 'vertical';\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get reverseClass() {\n      return this.reverse;\n    }\n\n    get indeterminateClass() {\n      return this.indeterminate;\n    }\n\n    get dirAttribute() {\n      return this.direction;\n    }\n\n    get ariaMinAttribute() {\n      return String(this.min);\n    }\n\n    get ariaMaxAttribute() {\n      return String(this.max);\n    }\n\n    get ariaValueAttribute() {\n      return this.indeterminate ? undefined : String(this.displayValue);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isCompleted() {\n      return this.value === this.max;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get statusWidth() {\n      return this.orientation === 'horizontal' ? this._progressRatio * 100 : 100;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get statusHeight() {\n      return this.orientation === 'vertical' ? this._progressRatio * 100 : 100;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get statusWrapperWidth() {\n      return this.orientation === 'horizontal' ? 100 / this._progressRatio : 100;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get statusWrapperHeight() {\n      return this.orientation === 'vertical' ? 100 / this._progressRatio : 100;\n    }\n\n    get _progressRatio() {\n      return calculateRatio(this.min, this.max, this.displayValue);\n    }\n\n    ngOnChanges(changes) {\n      const min = extractValueFromChanges(changes, 'min', this.min);\n      const max = extractValueFromChanges(changes, 'max', this.max);\n      const value = extractValueFromChanges(changes, 'value', this.value);\n\n      if (changes.min || changes.max || changes.value) {\n        if (changes.min || changes.max) {\n          validateRange(min, max);\n        }\n\n        if (changes.value) {\n          if (value == null || Number.isNaN(value)) {\n            this.value = min;\n          }\n\n          const previousValue = this.displayValue;\n          this.displayValue = adjustValueToRange(this.min, this.max, value);\n          this.previousValue = previousValue;\n        }\n\n        this.min = min;\n        this.max = max;\n        this.displayValue = adjustValueToRange(this.min, this.max, value);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  ProgressBarBase.ɵfac = function ProgressBarBase_Factory(t) {\n    return new (t || ProgressBarBase)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ProgressBarBase.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ProgressBarBase,\n    selectors: [[\"ng-component\"]],\n    hostVars: 19,\n    hostBindings: function ProgressBarBase_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dirAttribute)(\"role\", ctx.roleAttribute)(\"aria-valuemin\", ctx.ariaMinAttribute)(\"aria-valuemax\", ctx.ariaMaxAttribute)(\"aria-valuenow\", ctx.ariaValueAttribute);\n        i0.ɵɵclassProp(\"k-widget\", ctx.widgetClasses)(\"k-progressbar\", ctx.widgetClasses)(\"k-progressbar-horizontal\", ctx.isHorizontal)(\"k-progressbar-vertical\", ctx.isVertical)(\"k-state-disabled\", ctx.disabledClass)(\"k-progressbar-reverse\", ctx.reverseClass)(\"k-progressbar-indeterminate\", ctx.indeterminateClass);\n      }\n    },\n    inputs: {\n      max: \"max\",\n      min: \"min\",\n      value: \"value\",\n      orientation: \"orientation\",\n      disabled: \"disabled\",\n      reverse: \"reverse\",\n      indeterminate: \"indeterminate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function ProgressBarBase_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ProgressBarBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ProgressBar component for Angular]({% slug overview_progressbar %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-progressbar [value]=\"value\">\n *        </kendo-progressbar>\n *    `\n * })\n * class AppComponent {\n *     public value = 50;\n * }\n * ```\n */\n\n\nlet ProgressBarComponent = /*#__PURE__*/(() => {\n  class ProgressBarComponent extends ProgressBarBase {\n    /**\n     * @hidden\n     */\n    constructor(localization, zone, renderer) {\n      super(localization);\n      this.localization = localization;\n      this.zone = zone;\n      this.renderer = renderer;\n      /**\n       * Determines whether the status label will be visible.\n       * Defaults to `true`&mdash;the label will be visible and displayed with the default\n       * `LabelSettings` having its position set to `end` and its format set to `value`.\n       */\n\n      this.label = true;\n      /**\n       * The animation configuration of the ProgressBar.\n       * Defaults to `false`.\n       */\n\n      this.animation = false;\n      /**\n       * Fires when the animation which indicates the latest value change is completed.\n       */\n\n      this.animationEnd = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showLabel() {\n      if (typeof this.label === 'boolean') {\n        return this.label;\n      } else {\n        if (this.label && !this.label.hasOwnProperty('visible')) {\n          this.label.visible = true;\n        }\n\n        return this.label.visible;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get labelPosition() {\n      if (typeof this.label === 'boolean') {\n        return 'end';\n      } else {\n        if (this.label && !this.label.hasOwnProperty('position')) {\n          this.label.position = 'end';\n        }\n\n        return this.label.position;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isPositionStart() {\n      return this.labelPosition === 'start';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isPositionCenter() {\n      return this.labelPosition === 'center';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isPositionEnd() {\n      return this.labelPosition === 'end';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get formattedLabelValue() {\n      return formatValue(this.displayValue, this.min, this.max, this.label);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      super.ngOnChanges(changes);\n\n      if (this.isAnimationInProgress && stopCurrentAnimation(changes)) {\n        this.cancelCurrentAnimation = true;\n      }\n\n      if (runAnimation(changes, this.animation, this.previousValue, this.displayValue) && !changes.value.firstChange) {\n        this.startAnimation(this.previousValue);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      if (this.animationFrame) {\n        cancelAnimationFrame(this.animationFrame);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    startAnimation(previousValue) {\n      this.isAnimationInProgress = true;\n      const element = this.progressStatusElement.nativeElement;\n      const wrapperElement = this.progressStatusWrapperElement.nativeElement;\n      const animationOptions = this.getAnimationOptions(previousValue);\n      this.zone.runOutsideAngular(() => {\n        if (this.animationFrame) {\n          cancelAnimationFrame(this.animationFrame);\n        }\n\n        const animate = () => {\n          const elapsed = new Date().getTime() - animationOptions.startTime;\n          const position = Math.min(elapsed / animationOptions.duration, 1);\n          const size = animationOptions.startSize + animationOptions.deltaSize * position;\n          const wrapperSize = 100 / size * 100;\n          this.renderValueChange(element, wrapperElement, animationOptions.property, size, wrapperSize);\n\n          if (position < 1) {\n            if (this.cancelCurrentAnimation) {\n              this.resetProgress(element, wrapperElement, animationOptions.property);\n              return;\n            }\n\n            this.animationFrame = requestAnimationFrame(animate);\n          } else {\n            this.stopAnimation(previousValue);\n          }\n        };\n\n        animate();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    get animationDuration() {\n      if (typeof this.animation === 'boolean') {\n        return 400;\n      } else {\n        if (this.animation && !this.animation.hasOwnProperty('duration')) {\n          this.animation.duration = 400;\n        }\n\n        return this.animation.duration;\n      }\n    }\n\n    stopAnimation(value) {\n      if (hasObservers(this.animationEnd)) {\n        this.zone.run(() => {\n          this.animationEnd.emit({\n            from: value,\n            to: this.displayValue\n          });\n        });\n      }\n\n      this.zone.run(() => {\n        this.isAnimationInProgress = false;\n      });\n    }\n\n    getAnimationOptions(value) {\n      const isHorizontal = this.orientation === 'horizontal';\n      const previousRatio = calculateRatio(this.min, this.max, value);\n      const previousStatusWidth = isHorizontal ? previousRatio * 100 : 100;\n      const previousStatusHeight = !isHorizontal ? previousRatio * 100 : 100;\n      const property = isHorizontal ? 'width' : 'height';\n      const startTime = new Date().getTime();\n      const startSize = isHorizontal ? previousStatusWidth : previousStatusHeight;\n      const deltaSize = isHorizontal ? this.statusWidth - previousStatusWidth : this.statusHeight - previousStatusHeight;\n      const duration = this.animationDuration * Math.abs(deltaSize / 100);\n      return {\n        property,\n        startTime,\n        startSize,\n        deltaSize,\n        duration\n      };\n    }\n\n    renderValueChange(element, wrapperElement, property, size, wrapperSize) {\n      this.renderer.setStyle(element, property, size + '%');\n      this.renderer.setStyle(wrapperElement, property, wrapperSize + '%');\n    }\n\n    resetProgress(element, wrapperElement, property) {\n      const size = calculateRatio(this.min, this.max, this.value);\n      const newSize = size * 100;\n      const newWrapperSize = 100 / size;\n      this.renderValueChange(element, wrapperElement, property, newSize, newWrapperSize);\n      this.zone.run(() => {\n        this.cancelCurrentAnimation = false;\n        this.isAnimationInProgress = false;\n      });\n    }\n\n  }\n\n  ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) {\n    return new (t || ProgressBarComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ProgressBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ProgressBarComponent,\n    selectors: [[\"kendo-progressbar\"]],\n    viewQuery: function ProgressBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.progressStatusElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.progressStatusWrapperElement = _t.first);\n      }\n    },\n    inputs: {\n      label: \"label\",\n      progressCssStyle: \"progressCssStyle\",\n      progressCssClass: \"progressCssClass\",\n      emptyCssStyle: \"emptyCssStyle\",\n      emptyCssClass: \"emptyCssClass\",\n      animation: \"animation\"\n    },\n    outputs: {\n      animationEnd: \"animationEnd\"\n    },\n    exportAs: [\"kendoProgressBar\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.progressbar'\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 7,\n    vars: 28,\n    consts: [[1, \"k-progress-status-wrap\", 3, \"ngStyle\", \"ngClass\"], [\"class\", \"k-progress-status\", 4, \"ngIf\"], [1, \"k-state-selected\", 3, \"ngStyle\", \"ngClass\"], [\"progressStatus\", \"\"], [1, \"k-progress-status-wrap\"], [\"progressStatusWrap\", \"\"], [1, \"k-progress-status\"]],\n    template: function ProgressBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtemplate(1, ProgressBarComponent_span_1_Template, 2, 1, \"span\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 2, 3)(4, \"span\", 4, 5);\n        i0.ɵɵtemplate(6, ProgressBarComponent_span_6_Template, 2, 1, \"span\", 1);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-progress-start\", ctx.isPositionStart)(\"k-progress-center\", ctx.isPositionCenter)(\"k-progress-end\", ctx.isPositionEnd);\n        i0.ɵɵproperty(\"ngStyle\", ctx.emptyCssStyle)(\"ngClass\", ctx.emptyCssClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLabel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.statusWidth, \"%\")(\"height\", ctx.statusHeight, \"%\");\n        i0.ɵɵclassProp(\"k-complete\", ctx.isCompleted);\n        i0.ɵɵproperty(\"ngStyle\", ctx.progressCssStyle)(\"ngClass\", ctx.progressCssClass);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.statusWrapperWidth, \"%\")(\"height\", ctx.statusWrapperHeight, \"%\");\n        i0.ɵɵclassProp(\"k-progress-start\", ctx.isPositionStart)(\"k-progress-center\", ctx.isPositionCenter)(\"k-progress-end\", ctx.isPositionEnd);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showLabel);\n      }\n    },\n    directives: [i2.NgStyle, i2.NgClass, i2.NgIf],\n    encapsulation: 2\n  });\n  return ProgressBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ChunkProgressBar component for Angular]({% slug overview_chunkprogressbar %}).\n *\n * @example\n * ```ts-preview\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *        <kendo-chunkprogressbar [value]=\"value\">\n *        </kendo-chunkprogressbar>\n *    `\n * })\n * class AppComponent {\n *     public value = 40;\n * }\n * ```\n */\n\n\nlet ChunkProgressBarComponent = /*#__PURE__*/(() => {\n  class ChunkProgressBarComponent extends ProgressBarBase {\n    /**\n     * @hidden\n     */\n    constructor(localization) {\n      super(localization);\n      this.localization = localization;\n      /**\n       * Sets the number of chunks into which the ChunkProgressBar will be split.\n       * Defaults to `5`.\n       */\n\n      this.chunkCount = 5;\n      this._orientationStyles = {\n        width: `${this.chunkSizePercentage}%`\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get chunks() {\n      const count = this.chunkCount;\n      const chunks = Array(count).fill(false);\n      const completedChunks = Math.floor(this._progressRatio * count);\n\n      for (let i = 0; i < completedChunks; i++) {\n        chunks[i] = true;\n      }\n\n      if (reverseChunks(this.orientation, this.reverse)) {\n        chunks.reverse();\n      }\n\n      return chunks;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get chunkSizePercentage() {\n      return 100 / this.chunkCount;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get orientationStyles() {\n      if (this.orientation === 'horizontal') {\n        this._orientationStyles.width = `${this.chunkSizePercentage}%`;\n        this._orientationStyles.height = undefined;\n      } else {\n        this._orientationStyles.height = `${this.chunkSizePercentage}%`;\n        this._orientationStyles.width = undefined;\n      }\n\n      return this._orientationStyles;\n    }\n\n  }\n\n  ChunkProgressBarComponent.ɵfac = function ChunkProgressBarComponent_Factory(t) {\n    return new (t || ChunkProgressBarComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ChunkProgressBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ChunkProgressBarComponent,\n    selectors: [[\"kendo-chunkprogressbar\"]],\n    inputs: {\n      chunkCount: \"chunkCount\",\n      progressCssStyle: \"progressCssStyle\",\n      progressCssClass: \"progressCssClass\",\n      emptyCssStyle: \"emptyCssStyle\",\n      emptyCssClass: \"emptyCssClass\"\n    },\n    exportAs: [\"kendoChunkProgressBar\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.chunkprogressbar'\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"k-reset\"], [\"class\", \"k-item\", 3, \"k-first\", \"k-last\", \"k-state-selected\", \"ngClass\", \"ngStyle\", \"width\", \"height\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-item\", 3, \"ngClass\", \"ngStyle\"]],\n    template: function ChunkProgressBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, ChunkProgressBarComponent_li_1_Template, 1, 12, \"li\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.chunks);\n      }\n    },\n    directives: [i2.NgForOf, i2.NgClass, i2.NgStyle],\n    encapsulation: 2\n  });\n  return ChunkProgressBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [ProgressBarComponent, ChunkProgressBarComponent];\nconst MODULES = [CommonModule];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})\n * definition for the ProgressBar components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the ProgressBar module\n * import { ProgressBarModule } from '@progress/kendo-angular-progressbar';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ProgressBarModule], // import ProgressBar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet ProgressBarModule = /*#__PURE__*/(() => {\n  class ProgressBarModule {}\n\n  ProgressBarModule.ɵfac = function ProgressBarModule_Factory(t) {\n    return new (t || ProgressBarModule)();\n  };\n\n  ProgressBarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProgressBarModule\n  });\n  ProgressBarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [MODULES]\n  });\n  return ProgressBarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ChunkProgressBarComponent, ProgressBarComponent, ProgressBarModule };","map":null,"metadata":{},"sourceType":"module"}