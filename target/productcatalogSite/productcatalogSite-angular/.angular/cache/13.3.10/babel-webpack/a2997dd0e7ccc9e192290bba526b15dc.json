{"ast":null,"code":"import LineChart from '../line-chart/line-chart';\nimport SplineSegment from '../line-chart/spline-segment';\nimport LineSegment from '../line-chart/line-segment';\nimport { Point, Box } from '../../core';\nimport { SMOOTH, INTERPOLATE } from '../constants';\nimport { setDefaultOptions, last } from '../../common';\n\nfunction groupBySeriesIx(segments) {\n  const seriesSegments = [];\n\n  for (let idx = 0; idx < segments.length; idx++) {\n    const segment = segments[idx];\n    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];\n    seriesSegments[segment.seriesIx].push(segment);\n  }\n\n  return seriesSegments;\n}\n\nclass RadarLineChart extends LineChart {\n  pointSlot(categorySlot, valueSlot) {\n    const valueRadius = categorySlot.center.y - valueSlot.y1;\n    const slot = Point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\n    return new Box(slot.x, slot.y, slot.x, slot.y);\n  }\n\n  renderSegments() {\n    super.renderSegments();\n\n    if (this._segments && this._segments.length > 1) {\n      const seriesSegments = groupBySeriesIx(this._segments);\n\n      for (let idx = 0; idx < seriesSegments.length; idx++) {\n        const segments = seriesSegments[idx];\n\n        if (segments && segments.length > 1) {\n          const firstPoint = segments[0].linePoints[0];\n          const lastSegment = last(segments);\n          const lastPoint = last(lastSegment.linePoints);\n          const isFirstDataPoint = firstPoint.categoryIx === 0;\n          const isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;\n\n          if (isFirstDataPoint && isLastDataPoint) {\n            last(segments).linePoints.push(firstPoint);\n          }\n        }\n      }\n    }\n  }\n\n  createSegment(linePoints, currentSeries, seriesIx) {\n    const style = currentSeries.style;\n    let pointType;\n\n    if (style === SMOOTH) {\n      pointType = SplineSegment;\n    } else {\n      pointType = LineSegment;\n    }\n\n    const segment = new pointType(linePoints, currentSeries, seriesIx);\n    const missingValues = this.seriesMissingValues(currentSeries);\n\n    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {\n      segment.options.closed = true;\n    }\n\n    return segment;\n  }\n\n}\n\nsetDefaultOptions(RadarLineChart, {\n  clip: false,\n  limitPoints: false\n});\nexport default RadarLineChart;","map":null,"metadata":{},"sourceType":"module"}