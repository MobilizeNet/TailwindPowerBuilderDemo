{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1424);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1417:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.scheduler.view\");\n    /***/\n  },\n\n  /***/\n  1424:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1417)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"scheduler.dayview\",\n        name: \"Scheduler Day View\",\n        category: \"web\",\n        description: \"The Scheduler Day View\",\n        depends: [\"scheduler.view\"],\n        hidden: true\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            ui = kendo.ui,\n            setTime = kendo.date.setTime,\n            SchedulerView = ui.SchedulerView,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            getDate = kendo.date.getDate,\n            MS_PER_MINUTE = kendo.date.MS_PER_MINUTE,\n            MS_PER_DAY = kendo.date.MS_PER_DAY,\n            CURRENT_TIME_MARKER_CLASS = \"k-current-time\",\n            CURRENT_TIME_MARKER_ARROW_CLASS = \"k-current-time-arrow\",\n            INVERSE_COLOR_CLASS = \"k-event-inverse\",\n            BORDER_SIZE_COEFF = 0.8666,\n            getMilliseconds = kendo.date.getMilliseconds,\n            NS = \".kendoMultiDayView\";\n        var DAY_VIEW_EVENT_TEMPLATE = kendo.template('<div title=\"(#=kendo.format(\"{0:t} - {1:t}\", start, end)#): #=title.replace(/\"/g,\"&\\\\#34;\")#\">' + '<div class=\"k-event-template k-event-time\">#:kendo.format(\"{0:t} - {1:t}\", start, end)#</div>' + '<div class=\"k-event-template\">${title}</div>' + '</div>'),\n            DAY_VIEW_ALL_DAY_EVENT_TEMPLATE = kendo.template('<div title=\"(#=kendo.format(\"{0:t}\", start)#): #=title.replace(/\"/g,\"&\\\\#34;\")#\">' + '<div class=\"k-event-template\">${title}</div>' + '</div>'),\n            DATA_HEADER_TEMPLATE = kendo.template(\"#var dateString = isMobile ? kendo.toString(date,'ddd')[0] : kendo.toString(date,'ddd M/dd'); #\" + \"<span class='k-link k-nav-day'>#=dateString#</span>\"),\n            ALLDAY_EVENT_WRAPPER_STRING = '<div role=\"button\" ' + 'aria-label=\"#: ariaLabel #\" ' + 'data-#=ns#uid=\"#=uid#\"' + '#if (resources[0]) { #' + 'style=\"background-color:#=resources[0].color#; border-color: #=resources[0].color#\"' + 'class=\"k-event\"' + '#} else {#' + 'class=\"k-event\"' + '#}#' + '>' + '<span class=\"k-event-actions\">' + '# if(data.tail || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-left\"></span>' + '#}#' + '# if(data.isException()) {#' + '<span class=\"k-icon k-i-non-recurrence\"></span>' + '# } else if(data.isRecurring()) {#' + '<span class=\"k-icon k-i-reload\"></span>' + '# } #' + '</span>' + '{0}' + '<span class=\"k-event-actions\">' + '#if (showDelete) {#' + '<a href=\"\\\\#\" class=\"k-link k-event-delete\" title=\"${data.messages.destroy}\" aria-label=\"${data.messages.destroy}\"><span class=\"k-icon k-i-close\"></span></a>' + '#}#' + '# if(data.head || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-right\"></span>' + '#}#' + '</span>' + '#if(resizable && !singleDay && !data.tail && !data.middle){#' + '<span class=\"k-resize-handle k-resize-w\"></span>' + '#}#' + '#if(resizable && !singleDay && !data.head && !data.middle){#' + '<span class=\"k-resize-handle k-resize-e\"></span>' + '#}#' + '</div>',\n            EVENT_WRAPPER_STRING = '<div role=\"button\" ' + 'aria-label=\"#: ariaLabel #\" ' + 'data-#=ns#uid=\"#=uid#\" ' + '#if (resources[0]) { #' + 'style=\"background-color:#=resources[0].color #; border-color: #=resources[0].color#\"' + 'class=\"k-event\"' + '#} else {#' + 'class=\"k-event\"' + '#}#' + '>' + '<span class=\"k-event-actions\">' + '# if(data.isException()) {#' + '<span class=\"k-icon k-i-non-recurrence\"></span>' + '# } else if(data.isRecurring()) {#' + '<span class=\"k-icon k-i-reload\"></span>' + '# } #' + '</span>' + '{0}' + '<span class=\"k-event-actions\">' + '#if (showDelete) {#' + '<a href=\"\\\\#\" class=\"k-link k-event-delete\" title=\"${data.messages.destroy}\" aria-label=\"${data.messages.destroy}\"><span class=\"k-icon k-i-close\"></span></a>' + '#}#' + '</span>' + '<span class=\"k-event-top-actions\">' + '# if(data.tail || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-up\"></span>' + '# } #' + '</span>' + '<span class=\"k-event-bottom-actions\">' + '# if(data.head || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-down\"></span>' + '# } #' + '</span>' + '# if(resizable && !data.tail && !data.middle) {#' + '<span class=\"k-resize-handle k-resize-n\"></span>' + '# } #' + '# if(resizable && !data.head && !data.middle) {#' + '<span class=\"k-resize-handle k-resize-s\"></span>' + '# } #' + '</div>';\n\n        function toInvariantTime(date) {\n          var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n          setTime(staticDate, getMilliseconds(date));\n          return staticDate;\n        }\n\n        function isInDateRange(value, min, max) {\n          return value >= min && value <= max;\n        }\n\n        function isInTimeRange(value, min, max, overlaps) {\n          overlaps = overlaps ? value <= max : value < max;\n          return value > min && overlaps;\n        }\n\n        function addContinuousEvent(group, range, element, isAllDay) {\n          var events = group._continuousEvents;\n          var lastEvent = events[events.length - 1];\n          var startDate = getDate(range.start.startDate()).getTime(); //this handles all day event which is over multiple slots but starts\n          //after one of the time events\n\n          if (isAllDay && lastEvent && getDate(lastEvent.start.startDate()).getTime() == startDate) {\n            var idx = events.length - 1;\n\n            for (; idx > -1; idx--) {\n              if (events[idx].isAllDay || getDate(events[idx].start.startDate()).getTime() < startDate) {\n                break;\n              }\n            }\n\n            events.splice(idx + 1, 0, {\n              element: element,\n              isAllDay: true,\n              uid: element.attr(kendo.attr(\"uid\")),\n              start: range.start,\n              end: range.end\n            });\n          } else {\n            events.push({\n              element: element,\n              isAllDay: isAllDay,\n              uid: element.attr(kendo.attr(\"uid\")),\n              start: range.start,\n              end: range.end\n            });\n          }\n        }\n\n        function getWorkDays(options) {\n          if (options.workDays && options.workDays.length) {\n            return options.workDays;\n          }\n\n          var workDays = [];\n          var dayIndex = options.workWeekStart % 7;\n          var workWeekEnd = Math.abs(options.workWeekEnd % 7);\n          workDays.push(dayIndex);\n\n          while (workWeekEnd != dayIndex) {\n            if (dayIndex > 6) {\n              dayIndex -= 7;\n            } else {\n              dayIndex++;\n            }\n\n            workDays.push(dayIndex);\n          }\n\n          return workDays;\n        }\n\n        var MultiDayView = SchedulerView.extend({\n          init: function (element, options) {\n            var that = this;\n            SchedulerView.fn.init.call(that, element, options);\n            that.title = that.options.title || that.options.name;\n            that._workDays = getWorkDays(that.options);\n\n            that._templates();\n\n            that._editable();\n\n            that.calculateDateRange();\n\n            that._groups();\n\n            that._currentTime(true);\n          },\n          _currentTimeMarkerUpdater: function () {\n            this._updateCurrentTimeMarker(new Date());\n          },\n          _updateCurrentTimeMarker: function (currentTime) {\n            var options = this.options,\n                currentTimeMarkers,\n                currentContentMarkers,\n                timesTableMarkerWidth,\n                position,\n                elementHtml = \"<div class='\" + CURRENT_TIME_MARKER_CLASS + \"'></div>\";\n\n            if (options.currentTimeMarker.useLocalTimezone === false) {\n              var timezone = options.dataSource.options.schema.timezone;\n\n              if (options.dataSource && timezone) {\n                var timezoneOffset = kendo.timezone.offset(currentTime, timezone);\n                currentTime = kendo.timezone.convert(currentTime, currentTime.getTimezoneOffset(), timezoneOffset);\n              }\n            }\n\n            currentTimeMarkers = this.times.find(\".\" + CURRENT_TIME_MARKER_CLASS);\n            currentContentMarkers = this.content.find(\".\" + CURRENT_TIME_MARKER_CLASS);\n            var groupsCount = !options.group || options.group.orientation == \"horizontal\" ? 1 : this.groups.length;\n            var firstTimesCell = this.times.find(\"tr\").first().find(\"th\").first();\n            var lastTimesCell = this.times.find(\"tr\").first().find(\"th\").last();\n\n            if (firstTimesCell.length > 0 && lastTimesCell.length > 0) {\n              if (this._isRtl) {\n                position = firstTimesCell.position().left + outerHeight(firstTimesCell) - outerHeight(lastTimesCell);\n              } else {\n                position = lastTimesCell.position().left;\n              }\n            }\n\n            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n              var currentGroup = this.groups[groupIndex];\n\n              if (!currentGroup) {\n                return;\n              }\n\n              var utcCurrentTime = kendo.date.toUtcTime(currentTime);\n              var ranges = currentGroup.timeSlotRanges(utcCurrentTime, utcCurrentTime + 1);\n\n              if (ranges.length === 0) {\n                return;\n              }\n\n              var collection = ranges[0].collection;\n              var slotElement = collection.slotByStartDate(currentTime);\n\n              if (slotElement) {\n                var timesTableMarker = currentTimeMarkers[groupIndex] ? currentTimeMarkers.eq(groupIndex) : $(elementHtml).prependTo(this.times);\n                var markerTopPosition = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).top);\n                var timesTableMarkerCss = {};\n\n                if (this._isRtl) {\n                  timesTableMarkerCss.right = position;\n                  timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-left\");\n                } else {\n                  timesTableMarkerCss.left = position;\n                  timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-right\");\n                }\n\n                if (!timesTableMarkerWidth) {\n                  timesTableMarkerWidth = outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2;\n                }\n\n                timesTableMarkerCss.top = markerTopPosition - timesTableMarkerWidth;\n                timesTableMarker.css(timesTableMarkerCss);\n                var contentMarker = currentContentMarkers[groupIndex] ? currentContentMarkers.eq(groupIndex) : $(elementHtml).prependTo(this.content);\n                contentMarker.css({\n                  top: markerTopPosition,\n                  height: \"1px\",\n                  right: 0,\n                  left: 0\n                });\n              }\n            }\n          },\n          _currentTime: function (setUpdateTimer) {\n            var that = this;\n            var markerOptions = that.options.currentTimeMarker;\n\n            if (markerOptions !== false && markerOptions.updateInterval !== undefined) {\n              that._currentTimeMarkerUpdater();\n\n              if (setUpdateTimer) {\n                that._currentTimeUpdateTimer = setInterval(this._currentTimeMarkerUpdater.bind(that), markerOptions.updateInterval);\n              }\n            }\n          },\n          _updateResizeHint: function (event, groupIndex, startTime, endTime) {\n            var multiday;\n\n            if (this.options.enforceAllDaySlot) {\n              multiday = event.isMultiDay();\n            } else {\n              multiday = event.isAllDay;\n            }\n\n            var group = this.groups[groupIndex];\n            var ranges = group.ranges(startTime, endTime, multiday, event.isAllDay);\n            var width, height, top, hint;\n\n            this._removeResizeHint();\n\n            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n              var range = ranges[rangeIndex];\n              var start = range.startSlot();\n\n              if (this._isGroupedByDate() && multiday) {\n                for (var slotIdx = start.index; slotIdx <= range.end.index; slotIdx++) {\n                  var slot = range.collection._slots[slotIdx];\n                  width = slot.offsetWidth;\n                  height = slot.clientHeight;\n                  top = slot.offsetTop;\n                  hint = SchedulerView.fn._createResizeHint.call(this, slot.offsetLeft, top, width, height);\n                  this._resizeHint = this._resizeHint.add(hint);\n                }\n              } else {\n                width = start.offsetWidth;\n                height = start.clientHeight;\n                top = start.offsetTop;\n\n                if (multiday) {\n                  width = range.innerWidth();\n                } else {\n                  var rect = range.outerRect(startTime, endTime, this.options.snap);\n                  top = rect.top;\n                  height = rect.bottom - rect.top;\n                }\n\n                hint = SchedulerView.fn._createResizeHint.call(this, start.offsetLeft, top, width, height);\n                this._resizeHint = this._resizeHint.add(hint);\n              }\n            }\n\n            var format = \"t\";\n            var container = this.content;\n\n            if (multiday) {\n              format = \"M/dd\";\n              container = this.element.find(\".k-scheduler-header-wrap:has(.k-scheduler-header-all-day) > div\");\n\n              if (!container.length) {\n                container = this.content;\n              }\n            }\n\n            this._resizeHint.appendTo(container);\n\n            this._resizeHint.find(\".k-label-top,.k-label-bottom\").text(\"\");\n\n            this._resizeHint.first().addClass(\"k-first\").find(\".k-label-top\").text(kendo.toString(kendo.timezone.toLocalDate(startTime), format));\n\n            this._resizeHint.last().addClass(\"k-last\").find(\".k-label-bottom\").text(kendo.toString(kendo.timezone.toLocalDate(endTime), format));\n          },\n          _updateMoveHint: function (event, groupIndex, distance) {\n            var multiday;\n\n            if (this.options.enforceAllDaySlot) {\n              multiday = event.isMultiDay();\n            } else {\n              multiday = event.isAllDay;\n            }\n\n            var group = this.groups[groupIndex];\n            var start = kendo.date.toUtcTime(event.start) + distance;\n            var end = start + event.duration();\n            var ranges = group.ranges(start, end, multiday, event.isAllDay);\n            start = kendo.timezone.toLocalDate(start);\n            end = kendo.timezone.toLocalDate(end);\n\n            this._removeMoveHint(event.uid);\n\n            if (!multiday && getMilliseconds(end) < getMilliseconds(this.startTime()) && end < this._end().getTime() && getMilliseconds(end) !== 0 && ranges.length > 1) {\n              ranges.pop();\n            }\n\n            var eventHint = $();\n\n            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n              var range = ranges[rangeIndex];\n              var startSlot = range.start;\n              var hint;\n              var css = {\n                left: startSlot.offsetLeft + 2,\n                top: startSlot.offsetTop\n              };\n\n              if (this._isGroupedByDate() && multiday) {\n                for (var slotIdx = startSlot.index; slotIdx <= range.end.index; slotIdx++) {\n                  var slot = range.collection._slots[slotIdx];\n                  css.left = this._isRtl ? slot.clientWidth * 0.1 + slot.offsetLeft + 2 : slot.offsetLeft + 2;\n                  css.height = slot.offsetHeight;\n                  css.width = slot.clientWidth * 0.9 - 2;\n                  hint = this._createEventElement(event.clone({\n                    start: start,\n                    end: end\n                  }), !multiday);\n\n                  if (event.inverseColor) {\n                    hint.addClass(INVERSE_COLOR_CLASS);\n                  }\n\n                  this._appendMoveHint(hint, css);\n\n                  eventHint = eventHint.add(hint);\n                }\n              } else {\n                if (this._isRtl) {\n                  css.left = startSlot.clientWidth * 0.1 + startSlot.offsetLeft + 2;\n                }\n\n                if (multiday) {\n                  css.width = range.innerWidth() - 2;\n                } else {\n                  var rect = range.outerRect(start, end, this.options.snap);\n                  css.top = rect.top;\n                  css.height = rect.bottom - rect.top;\n                  css.width = startSlot.clientWidth * 0.9 - 2;\n                }\n\n                hint = this._createEventElement(event.clone({\n                  start: start,\n                  end: end\n                }), !multiday);\n\n                if (event.inverseColor) {\n                  hint.addClass(INVERSE_COLOR_CLASS);\n                }\n\n                this._appendMoveHint(hint, css);\n\n                eventHint = eventHint.add(hint);\n              }\n            }\n\n            var content = this.content;\n\n            if (multiday) {\n              content = this.element.find(\".k-scheduler-header-wrap:has(.k-scheduler-header-all-day) > div\");\n\n              if (!content.length) {\n                content = this.content;\n              }\n            }\n\n            eventHint.appendTo(content);\n          },\n          _appendMoveHint: function (hint, css) {\n            hint.addClass(\"k-event-drag-hint\");\n            hint.css(css);\n            this._moveHint = this._moveHint.add(hint);\n          },\n          _slotByPosition: function (x, y) {\n            var slot, offset;\n\n            if (this._isVerticallyGrouped()) {\n              offset = this.content.offset();\n              y += this.content[0].scrollTop;\n              x += this.content[0].scrollLeft;\n            } else {\n              offset = this.element.find(\".k-scheduler-header-wrap:has(.k-scheduler-header-all-day)\").find(\">div\").offset();\n            }\n\n            if (offset) {\n              x -= offset.left;\n              y -= offset.top;\n            }\n\n            x = Math.ceil(x);\n            y = Math.ceil(y);\n            var group;\n            var groupIndex;\n\n            for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n              group = this.groups[groupIndex];\n              slot = group.daySlotByPosition(x, y, this._isGroupedByDate());\n\n              if (slot) {\n                return slot;\n              }\n            }\n\n            if (offset) {\n              x += offset.left;\n              y += offset.top;\n            }\n\n            offset = this.content.offset();\n            x -= offset.left;\n            y -= offset.top;\n\n            if (!this._isVerticallyGrouped()) {\n              y += this.content[0].scrollTop;\n              x += this.content[0].scrollLeft;\n            }\n\n            x = Math.ceil(x);\n            y = Math.ceil(y);\n\n            for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n              group = this.groups[groupIndex];\n              slot = group.timeSlotByPosition(x, y);\n\n              if (slot) {\n                return slot;\n              }\n            }\n\n            return null;\n          },\n          _groupCount: function () {\n            var resources = this.groupedResources;\n\n            var byDate = this._isGroupedByDate();\n\n            if (resources.length) {\n              if (this._groupOrientation() === \"vertical\") {\n                if (byDate) {\n                  return this._columnCountForLevel(resources.length - 1);\n                } else {\n                  return this._rowCountForLevel(resources.length - 1);\n                }\n              } else {\n                if (byDate) {\n                  return this._columnCountForLevel(resources.length) / this._columnCountForLevel(0);\n                } else {\n                  return this._columnCountForLevel(resources.length) / this._columnOffsetForResource(resources.length);\n                }\n              }\n            }\n\n            return 1;\n          },\n          _columnCountInResourceView: function () {\n            var resources = this.groupedResources;\n\n            var byDate = this._isGroupedByDate();\n\n            if (!resources.length || this._isVerticallyGrouped()) {\n              if (byDate) {\n                return this._rowCountForLevel(0);\n              } else {\n                return this._columnCountForLevel(0);\n              }\n            }\n\n            if (byDate) {\n              return this._columnCountForLevel(0);\n            } else {\n              return this._columnOffsetForResource(resources.length);\n            }\n          },\n          _timeSlotGroups: function (groupCount, columnCount) {\n            var interval = this._timeSlotInterval();\n\n            var verticalViews = groupCount;\n\n            var byDate = this._isGroupedByDate();\n\n            var tableRows = this.content.find(\"tr:not(.k-scheduler-header-all-day)\");\n            var group, time, rowIndex, cellIndex;\n            var rowCount = tableRows.length;\n\n            if (this._isVerticallyGrouped()) {\n              if (byDate) {\n                verticalViews = columnCount;\n              }\n\n              rowCount = Math.floor(rowCount / verticalViews);\n            }\n\n            for (var groupIndex = 0; groupIndex < verticalViews; groupIndex++) {\n              var rowMultiplier = 0;\n              var cellMultiplier = 0;\n\n              if (this._isVerticallyGrouped()) {\n                rowMultiplier = groupIndex;\n              } else {\n                cellMultiplier = groupIndex;\n              }\n\n              rowIndex = rowMultiplier * rowCount;\n\n              while (rowIndex < (rowMultiplier + 1) * rowCount) {\n                var cells = tableRows[rowIndex].children;\n\n                if (rowIndex % rowCount === 0) {\n                  time = getMilliseconds(new Date(+this.startTime()));\n                }\n\n                var timeIndex = 0;\n\n                if (byDate) {\n                  if (this._isVerticallyGrouped()) {\n                    for (cellIndex = 0; cellIndex < groupCount; cellIndex++) {\n                      group = this.groups[cellIndex];\n\n                      this._addTimeSlotGroup(group, cells, cellIndex, time, interval, groupIndex);\n                    }\n                  } else {\n                    group = this.groups[groupIndex];\n\n                    for (cellIndex = cellMultiplier; cellIndex < groupCount * columnCount; cellIndex = cellIndex + groupCount) {\n                      this._addTimeSlotGroup(group, cells, cellIndex, time, interval, timeIndex);\n\n                      timeIndex++;\n                    }\n                  }\n                } else {\n                  group = this.groups[groupIndex];\n\n                  for (cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n                    this._addTimeSlotGroup(group, cells, cellIndex, time, interval, timeIndex);\n\n                    timeIndex++;\n                  }\n                }\n\n                time += interval;\n                rowIndex++;\n              }\n            }\n          },\n          _addTimeSlotGroup: function (group, cells, cellIndex, time, interval, timeIndex) {\n            var cell = cells[cellIndex];\n            var collection = group.getTimeSlotCollection(timeIndex);\n            var currentDate = this._dates[timeIndex];\n\n            if (!currentDate || !cell) {\n              return;\n            }\n\n            var currentTime = Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());\n            var start = currentTime + time;\n            var end = start + interval;\n            collection.addTimeSlot(cell, start, end);\n          },\n          _addDaySlotGroup: function (collection, cells, cellIndex, columnCount, cellCount) {\n            var cell = cells[cellIndex];\n            var start = this._dates[cellCount];\n\n            if (!start) {\n              return;\n            }\n\n            var currentTime = Date.UTC(start.getFullYear(), start.getMonth(), start.getDate());\n            collection.addDaySlot(cell, currentTime, currentTime + kendo.date.MS_PER_DAY);\n          },\n          _daySlotGroups: function (groupCount, columnCount) {\n            var tableRows, cellIndex;\n            var verticalViews = groupCount;\n\n            var byDate = this._isGroupedByDate();\n\n            if (this._isVerticallyGrouped()) {\n              if (byDate) {\n                verticalViews = columnCount;\n              }\n\n              tableRows = this.element.find(\".k-scheduler-header-all-day\");\n            } else {\n              tableRows = this.element.find(\".k-scheduler-header-all-day tr\");\n            }\n\n            for (var groupIndex = 0; groupIndex < verticalViews; groupIndex++) {\n              var rowMultiplier = 0;\n              var group, collection;\n\n              if (this._isVerticallyGrouped()) {\n                rowMultiplier = groupIndex;\n              }\n\n              var cells = tableRows[rowMultiplier].children;\n              var cellMultiplier = 0;\n\n              if (!this._isVerticallyGrouped()) {\n                cellMultiplier = groupIndex;\n              }\n\n              var cellCount = 0;\n\n              if (byDate) {\n                if (this._isVerticallyGrouped()) {\n                  for (cellIndex = 0; cellIndex < groupCount; cellIndex++) {\n                    group = this.groups[cellIndex];\n                    collection = group.getDaySlotCollection(0);\n\n                    this._addDaySlotGroup(collection, cells, cellIndex, columnCount, groupIndex);\n                  }\n                } else {\n                  group = this.groups[groupIndex];\n                  collection = group.getDaySlotCollection(0);\n\n                  for (cellIndex = cellMultiplier; cellIndex < groupCount * columnCount; cellIndex = cellIndex + groupCount) {\n                    this._addDaySlotGroup(collection, cells, cellIndex, columnCount, cellCount);\n\n                    cellCount++;\n                  }\n                }\n              } else {\n                group = this.groups[groupIndex];\n                collection = group.getDaySlotCollection(0);\n\n                for (cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n                  this._addDaySlotGroup(collection, cells, cellIndex, columnCount, cellCount);\n\n                  cellCount++;\n                }\n              }\n            }\n          },\n          _groups: function () {\n            var groupCount = this._groupCount();\n\n            var columnCount = this._columnCountInResourceView();\n\n            this.groups = [];\n\n            for (var idx = 0; idx < groupCount; idx++) {\n              var view = this._addResourceView(idx);\n\n              for (var columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n                if (this._dates[columnIndex]) {\n                  view.addTimeSlotCollection(this._dates[columnIndex], kendo.date.addDays(this._dates[columnIndex], 1));\n                }\n              }\n\n              if (this.options.allDaySlot) {\n                view.addDaySlotCollection(this._dates[0], kendo.date.addDays(this._dates[this._dates.length - 1], 1));\n              }\n            }\n\n            this._timeSlotGroups(groupCount, columnCount);\n\n            if (this.options.allDaySlot) {\n              this._daySlotGroups(groupCount, columnCount);\n            }\n          },\n          options: {\n            name: \"MultiDayView\",\n            selectedDateFormat: \"{0:D}\",\n            selectedShortDateFormat: \"{0:d}\",\n            selectedMobileDateFormat: \"{0:MMM} {0:dd} - {1:dd}\",\n            allDaySlot: true,\n            showWorkHours: false,\n            title: \"\",\n            startTime: kendo.date.today(),\n            endTime: kendo.date.today(),\n            minorTickCount: 2,\n            majorTick: 60,\n            majorTimeHeaderTemplate: \"<span>#=kendo.toString(date, 't')#</span>\",\n            minorTimeHeaderTemplate: \"&\\\\#8203;\",\n            groupHeaderTemplate: \"#=text#\",\n            slotTemplate: \"&nbsp;\",\n            allDaySlotTemplate: \"&nbsp;\",\n            eventTemplate: DAY_VIEW_EVENT_TEMPLATE,\n            allDayEventTemplate: DAY_VIEW_ALL_DAY_EVENT_TEMPLATE,\n            dateHeaderTemplate: DATA_HEADER_TEMPLATE,\n            editable: true,\n            workDayStart: new Date(1980, 1, 1, 8, 0, 0),\n            workDayEnd: new Date(1980, 1, 1, 17, 0, 0),\n            workWeekStart: 1,\n            workWeekEnd: 5,\n            footer: {\n              command: \"workDay\"\n            },\n            messages: {\n              allDay: \"all day\",\n              showFullDay: \"Show full day\",\n              showWorkDay: \"Show business hours\"\n            },\n            currentTimeMarker: {\n              updateInterval: 10000,\n              useLocalTimezone: true\n            },\n            // a hidden option that provides us a fallback to the previous behaviour\n            // e.g. all events of 24 hours or more will be rendered in the allDaySlot\n            enforceAllDaySlot: false\n          },\n          events: [\"remove\", \"add\", \"edit\"],\n          _templates: function () {\n            var options = this.options,\n                settings = extend({}, kendo.Template, options.templateSettings);\n            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n            this.allDayEventTemplate = this._eventTmpl(options.allDayEventTemplate, ALLDAY_EVENT_WRAPPER_STRING);\n            this.majorTimeHeaderTemplate = kendo.template(options.majorTimeHeaderTemplate, settings);\n            this.minorTimeHeaderTemplate = kendo.template(options.minorTimeHeaderTemplate, settings);\n            this.dateHeaderTemplate = kendo.template(options.dateHeaderTemplate, settings);\n            this.slotTemplate = kendo.template(options.slotTemplate, settings);\n            this.allDaySlotTemplate = kendo.template(options.allDaySlotTemplate, settings);\n            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n          },\n          _editable: function () {\n            if (this.options.editable) {\n              if (this._isMobile()) {\n                this._touchEditable();\n              } else {\n                this._mouseEditable();\n              }\n            }\n          },\n          _mouseEditable: function () {\n            var that = this;\n            that.element.on(\"click\" + NS, \".k-event a:has(.k-i-close)\", function (e) {\n              that.trigger(\"remove\", {\n                uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n              });\n              e.preventDefault();\n            });\n\n            if (that.options.editable.create !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-scheduler-content > table td\", function (e) {\n                if (!$(this).parent().hasClass(\"k-scheduler-header-all-day\")) {\n                  var slot = that._slotByPosition(e.pageX, e.pageY);\n\n                  if (slot) {\n                    var resourceInfo = that._resourceBySlot(slot);\n\n                    that.trigger(\"add\", {\n                      eventInfo: extend({\n                        start: slot.startDate(),\n                        end: slot.endDate()\n                      }, resourceInfo)\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              }).on(\"dblclick\" + NS, \".k-scheduler-header-all-day td\", function (e) {\n                var slot = that._slotByPosition(e.pageX, e.pageY);\n\n                if (slot) {\n                  var resourceInfo = that._resourceBySlot(slot);\n\n                  that.trigger(\"add\", {\n                    eventInfo: extend({}, {\n                      isAllDay: true,\n                      start: kendo.date.getDate(slot.startDate()),\n                      end: kendo.date.getDate(slot.startDate())\n                    }, resourceInfo)\n                  });\n                }\n\n                e.preventDefault();\n              });\n            }\n\n            if (that.options.editable.update !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-event\", function (e) {\n                that.trigger(\"edit\", {\n                  uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n                });\n                e.preventDefault();\n              });\n            }\n          },\n          _touchEditable: function () {\n            var that = this;\n            var threshold = 0;\n\n            if (kendo.support.mobileOS.android) {\n              threshold = 5;\n            }\n\n            if (that.options.editable.create !== false) {\n              that._addUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                filter: \".k-scheduler-content td\",\n                useClickAsTap: !kendo.support.browser.edge,\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  if (!$(e.target).parent().hasClass(\"k-scheduler-header-all-day\")) {\n                    var x = e.x.location !== undefined ? e.x.location : e.x;\n                    var y = e.y.location !== undefined ? e.y.location : e.y;\n\n                    var slot = that._slotByPosition(x, y);\n\n                    if (slot) {\n                      var resourceInfo = that._resourceBySlot(slot);\n\n                      that.trigger(\"add\", {\n                        eventInfo: extend({\n                          start: slot.startDate(),\n                          end: slot.endDate()\n                        }, resourceInfo)\n                      });\n                    }\n\n                    e.preventDefault();\n                  }\n                }\n              });\n              that._allDayUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                useClickAsTap: !kendo.support.browser.edge,\n                filter: \".k-scheduler-header-all-day td\",\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  var x = e.x.location !== undefined ? e.x.location : e.x;\n                  var y = e.y.location !== undefined ? e.y.location : e.y;\n\n                  var slot = that._slotByPosition(x, y);\n\n                  if (slot) {\n                    var resourceInfo = that._resourceBySlot(slot);\n\n                    that.trigger(\"add\", {\n                      eventInfo: extend({}, {\n                        isAllDay: true,\n                        start: kendo.date.getDate(slot.startDate()),\n                        end: kendo.date.getDate(slot.startDate())\n                      }, resourceInfo)\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              });\n            }\n\n            if (that.options.editable.update !== false) {\n              that._editUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                useClickAsTap: !kendo.support.browser.edge,\n                filter: \".k-event\",\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  var eventElement = $(e.target).closest(\".k-event\");\n                  var touchElement = $(e.touch.initialTouch);\n\n                  if (touchElement.hasClass(\"k-i-close\")) {\n                    that.trigger(\"remove\", {\n                      uid: eventElement.attr(kendo.attr(\"uid\"))\n                    });\n                  } else if (!eventElement.hasClass(\"k-event-active\")) {\n                    that.trigger(\"edit\", {\n                      uid: eventElement.attr(kendo.attr(\"uid\"))\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              });\n            }\n          },\n          _layout: function (dates) {\n            var columns = [];\n            var rows = [];\n            var options = this.options;\n            var that = this;\n\n            var byDate = that._isGroupedByDate();\n\n            for (var idx = 0; idx < dates.length; idx++) {\n              var column = {};\n              column.text = that.dateHeaderTemplate({\n                date: dates[idx],\n                isMobile: that._isMobile()\n              });\n\n              if (kendo.date.isToday(dates[idx])) {\n                column.className = \"k-today\";\n              }\n\n              columns.push(column);\n            }\n\n            var resources = this.groupedResources;\n\n            if (options.allDaySlot) {\n              rows.push({\n                text: options.messages.allDay,\n                allDay: true,\n                cellContent: function (idx) {\n                  var groupIndex = idx;\n                  idx = resources.length && that._groupOrientation() !== \"vertical\" ? idx % dates.length : idx;\n                  return that.allDaySlotTemplate({\n                    date: dates[idx],\n                    resources: function () {\n                      return that._resourceBySlot({\n                        groupIndex: groupIndex\n                      });\n                    }\n                  });\n                }\n              });\n            }\n\n            this._forTimeRange(this.startTime(), this.endTime(), function (date, majorTick, middleRow, lastSlotRow) {\n              var template = majorTick ? that.majorTimeHeaderTemplate : that.minorTimeHeaderTemplate;\n              var row = {\n                text: template({\n                  date: date\n                }),\n                className: lastSlotRow ? \"k-slot-cell\" : \"\"\n              };\n              rows.push(row);\n            });\n\n            if (resources.length) {\n              if (this._groupOrientation() === \"vertical\") {\n                if (byDate) {\n                  rows = this._createDateLayout(columns, rows);\n                  columns = this._createColumnsLayout(resources, null, this.groupHeaderTemplate);\n                } else {\n                  rows = this._createRowsLayout(resources, rows, this.groupHeaderTemplate);\n                }\n              } else {\n                if (byDate) {\n                  columns = this._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n                } else {\n                  columns = this._createColumnsLayout(resources, columns, this.groupHeaderTemplate);\n                }\n              }\n            }\n\n            return {\n              columns: columns,\n              rows: rows\n            };\n          },\n          toggleFullDay: function () {\n            var options = this.options;\n            this.trigger(\"navigate\", {\n              view: this.name || options.name,\n              date: options.date,\n              isWorkDay: !options.showWorkHours\n            });\n          },\n          _footer: function () {\n            var options = this.options;\n\n            if (options.footer !== false) {\n              var html = '<div class=\"k-scheduler-footer k-toolbar\">';\n              var command = options.footer.command;\n\n              if (this._isMobile()) {\n                html += '<span class=\"k-scheduler-today\"><a href=\"#\" tabindex=\"-1\" class=\"k-link\">';\n                html += options.messages.today + '</a></span>';\n              }\n\n              if (command && command === \"workDay\") {\n                if (this._isMobile()) {\n                  html += '<span class=\"k-scheduler-fullday\"><a href=\"#\" tabindex=\"-1\" class=\"k-link\">';\n                  html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay) + '</a></span>';\n                } else {\n                  html += '<button type=\"button\" tabindex=\"-1\" class=\"k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-scheduler-fullday\">';\n                  html += '<span class=\"k-button-icon k-icon k-i-clock\"></span>';\n                  html += '<span class=\"k-button-text\">';\n                  html += options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay;\n                  html += '</span>';\n                  html += '</button>';\n                }\n              }\n\n              html += \"</div>\";\n              this.footer = $(html).appendTo(this.element);\n              var that = this;\n              this.footer.on(\"click\" + NS, \".k-scheduler-fullday\", function (e) {\n                e.preventDefault();\n                that.toggleFullDay();\n              });\n              this.footer.on(\"click\" + NS, \".k-scheduler-today\", function (e) {\n                e.preventDefault();\n                var timezone = that.options.timezone;\n                var action = \"today\";\n                var currentDate = new Date();\n                var date;\n\n                if (timezone) {\n                  var timezoneOffset = kendo.timezone.offset(currentDate, timezone);\n                  date = kendo.timezone.convert(currentDate, currentDate.getTimezoneOffset(), timezoneOffset);\n                } else {\n                  date = currentDate;\n                }\n\n                that.trigger(\"navigate\", {\n                  view: that.name || options.name,\n                  action: action,\n                  date: date\n                });\n              });\n            }\n          },\n          _forTimeRange: function (min, max, action, after) {\n            min = toInvariantTime(min); //convert the date to 1/2/1980 and sets the time\n\n            max = toInvariantTime(max);\n            var that = this,\n                msMin = getMilliseconds(min),\n                msMax = getMilliseconds(max),\n                minorTickCount = that.options.minorTickCount,\n                msMajorInterval = that.options.majorTick * MS_PER_MINUTE,\n                msInterval = msMajorInterval / minorTickCount || 1,\n                start = new Date(+min),\n                startDay = start.getDate(),\n                msStart,\n                idx = 0,\n                length,\n                html = \"\";\n            length = MS_PER_DAY / msInterval;\n\n            if (msMin != msMax) {\n              if (msMin > msMax) {\n                msMax += MS_PER_DAY;\n              }\n\n              length = (msMax - msMin) / msInterval;\n            }\n\n            length = Math.round(length);\n\n            for (; idx < length; idx++) {\n              var majorTickDivider = idx % (msMajorInterval / msInterval),\n                  isMajorTickRow = majorTickDivider === 0,\n                  isMiddleRow = majorTickDivider < minorTickCount - 1,\n                  isLastSlotRow = majorTickDivider === minorTickCount - 1;\n              html += action(start, isMajorTickRow, isMiddleRow, isLastSlotRow);\n              setTime(start, msInterval, false);\n            }\n\n            if (msMax) {\n              msStart = getMilliseconds(start);\n\n              if (startDay < start.getDate()) {\n                msStart += MS_PER_DAY;\n              }\n\n              if (msStart > msMax) {\n                start = new Date(+max);\n              }\n            }\n\n            if (after) {\n              html += after(start);\n            }\n\n            return html;\n          },\n          _content: function (dates) {\n            var that = this;\n            var html = '';\n            html += '<tbody>';\n            html += that._renderRows(dates, that.rowLevels, that.columnLevels);\n            html += '</tbody>';\n            this.content.find(\"table\").append(html);\n          },\n          _virtualContent: function (rowLevels, columnLevels) {\n            var that = this;\n            var html = '';\n            var dates = that._dates;\n            html += that._renderRows(dates, rowLevels, columnLevels);\n            that.content.find(\"table tbody\").append(html);\n          },\n          _renderRows: function (dates, rowLevels, columnLevels) {\n            var that = this;\n            var isVerticalGroupped = that._groupOrientation() === \"vertical\";\n\n            var byDate = that._isGroupedByDate();\n\n            var dateID = 0;\n            var columnCount = dates.length;\n            var options = that.options;\n            var start = that.startTime();\n            var end = this.endTime();\n            var groupsCount = 1;\n            var rowCount = 1;\n            var resources = this.groupedResources;\n            var html = '';\n\n            if (resources.length) {\n              var levels = that._recalculateLevels(rowLevels, columnLevels);\n\n              rowCount = levels.rowCount;\n              groupsCount = levels.groupsCount;\n            }\n\n            var appendRow = function (date, majorTick, middleRow) {\n              var content = \"\";\n              var groupIdx = 0;\n              var idx, length;\n              content = '<tr' + (middleRow ? ' class=\"k-middle-row\"' : \"\") + '>';\n\n              if (byDate) {\n                for (idx = 0, length = columnCount; idx < length; idx++) {\n                  for (groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                    var dateIndex = idx;\n\n                    if (isVerticalGroupped) {\n                      dateIndex = dateID;\n                    }\n\n                    content = that._addCellsToContent(content, dates, date, dateIndex, groupIdx, rowIdx);\n                  }\n\n                  if (isVerticalGroupped) {\n                    break;\n                  }\n                }\n              } else {\n                for (; groupIdx < groupsCount; groupIdx++) {\n                  for (idx = 0, length = columnCount; idx < length; idx++) {\n                    content = that._addCellsToContent(content, dates, date, idx, groupIdx, rowIdx);\n                  }\n                }\n              }\n\n              content += \"</tr>\";\n              return content;\n            };\n\n            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n              html += options.allDaySlot && isVerticalGroupped ? this._allDayVerticalGroupRow(dates, rowIdx, groupsCount, dateID) : \"\";\n              html += this._forTimeRange(start, end, appendRow);\n\n              if (isVerticalGroupped) {\n                dateID++;\n              }\n            }\n\n            return html;\n          },\n          _recalculateLevels: function (rowLevels, columnLevels) {\n            var that = this;\n\n            var byDate = that._isGroupedByDate();\n\n            var isVerticalGroupped = that._groupOrientation() === \"vertical\";\n            var groupsCount = 1;\n            var rowCount = 1;\n\n            if (isVerticalGroupped) {\n              rowCount = that._rowCountForLevel(rowLevels.length - 2, rowLevels);\n\n              if (byDate) {\n                groupsCount = that._columnCountForLevel(columnLevels.length - 1);\n              }\n            } else {\n              if (byDate) {\n                groupsCount = that._columnCountForLevel(columnLevels.length - 1) / this._columnCountForLevel(0);\n              } else {\n                groupsCount = that._columnCountForLevel(columnLevels.length - 2);\n              }\n            }\n\n            return {\n              rowCount: rowCount,\n              groupsCount: groupsCount\n            };\n          },\n          _allDayVerticalGroupRow: function (dates, groupIndex, groupsCount, dateID) {\n            var that = this;\n            var result = '<tr class=\"k-scheduler-header-all-day\">';\n\n            var byDate = that._isGroupedByDate();\n\n            var dateGroupIndex = byDate ? 0 : groupIndex;\n            var allDaySlotTemplate = that.allDaySlotTemplate;\n\n            var resources = function () {\n              return that._resourceBySlot({\n                groupIndex: dateGroupIndex\n              });\n            };\n\n            if (byDate) {\n              for (; dateGroupIndex < groupsCount; dateGroupIndex++) {\n                result += \"<td>\" + allDaySlotTemplate({\n                  date: dates[dateID],\n                  resources: resources\n                }) + \"</td>\";\n              }\n            } else {\n              for (var idx = 0; idx < dates.length; idx++) {\n                result += \"<td>\" + allDaySlotTemplate({\n                  date: dates[idx],\n                  resources: resources\n                }) + \"</td>\";\n              }\n            }\n\n            return result + \"</tr>\";\n          },\n          _addCellsToContent: function (content, dates, date, idx, groupIdx, rowIdx) {\n            var that = this;\n            var classes = \"\";\n            var tmplDate;\n            var slotTemplate = this.slotTemplate;\n            var isVerticalGroupped = this._groupOrientation() === \"vertical\";\n\n            var resources = function (groupIndex) {\n              return function () {\n                return that._resourceBySlot({\n                  groupIndex: groupIndex\n                });\n              };\n            };\n\n            if (kendo.date.isToday(dates[idx])) {\n              classes += \"k-today\";\n            }\n\n            if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(this.options.workDayStart) || kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(this.options.workDayEnd) || !this._isWorkDay(dates[idx])) {\n              classes += \" k-nonwork-hour\";\n            }\n\n            content += '<td' + (classes !== \"\" ? ' class=\"' + classes + '\"' : \"\") + \">\";\n            tmplDate = kendo.date.getDate(dates[idx]);\n            kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n            content += slotTemplate({\n              date: tmplDate,\n              resources: resources(isVerticalGroupped && !that._isGroupedByDate() ? rowIdx : groupIdx)\n            });\n            content += \"</td>\";\n            return content;\n          },\n          _isWorkDay: function (date) {\n            var day = date.getDay();\n            var workDays = this._workDays;\n\n            for (var i = 0; i < workDays.length; i++) {\n              if (workDays[i] === day) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _render: function (dates) {\n            var that = this;\n            dates = dates || [];\n            this._dates = dates;\n            this._startDate = dates[0];\n            this._endDate = dates[dates.length - 1 || 0];\n            this.createLayout(this._layout(dates));\n\n            this._content(dates);\n\n            this._footer();\n\n            this.refreshLayout();\n\n            if (this._isVirtualized()) {\n              this._tryRenderContent();\n            }\n\n            var allDayHeader = this.element.find(\".k-scheduler-header-all-day td\");\n\n            if (allDayHeader.length) {\n              this._allDayHeaderHeight = allDayHeader.first()[0].clientHeight;\n            }\n\n            that.element.on(\"click\" + NS, \".k-nav-day\", function (e) {\n              var th = $(e.currentTarget).closest(\"th\");\n              var offset = th.offset();\n              var additioanlWidth = 0;\n              var additionalHeight = outerHeight(th);\n\n              if (that._isGroupedByDate()) {\n                if (that._isVerticallyGrouped()) {\n                  additioanlWidth = outerWidth(that.times);\n                  additionalHeight = 0;\n                } else {\n                  additionalHeight = outerHeight(that.datesHeader);\n                }\n              }\n\n              var slot = that._slotByPosition(offset.left + additioanlWidth, offset.top + additionalHeight);\n\n              that.trigger(\"navigate\", {\n                view: \"day\",\n                date: slot.startDate()\n              });\n            });\n          },\n          startTime: function () {\n            var options = this.options;\n            return options.showWorkHours ? options.workDayStart : options.startTime;\n          },\n          endTime: function () {\n            var options = this.options;\n            return options.showWorkHours ? options.workDayEnd : options.endTime;\n          },\n          startDate: function () {\n            return this._startDate;\n          },\n          endDate: function () {\n            return this._endDate;\n          },\n          _end: function (isAllDay) {\n            var time = getMilliseconds(this.endTime()) || MS_PER_DAY;\n\n            if (isAllDay) {\n              time = 0;\n            }\n\n            return new Date(this._endDate.getTime() + time);\n          },\n          nextDate: function () {\n            return kendo.date.nextDay(this.endDate());\n          },\n          previousDate: function () {\n            return kendo.date.previousDay(this.startDate());\n          },\n          calculateDateRange: function () {\n            this._render([this.options.date]);\n          },\n          destroy: function () {\n            var that = this;\n\n            if (that._currentTimeUpdateTimer) {\n              clearInterval(that._currentTimeUpdateTimer);\n            }\n\n            if (that.datesHeader) {\n              that.datesHeader.off(NS);\n            }\n\n            if (that.element) {\n              that.element.off(NS);\n            }\n\n            if (that.footer) {\n              that.footer.remove();\n            }\n\n            SchedulerView.fn.destroy.call(this);\n\n            if (this._isMobile() && that.options.editable) {\n              if (that.options.editable.create !== false) {\n                that._addUserEvents.destroy();\n\n                that._allDayUserEvents.destroy();\n              }\n\n              if (that.options.editable.update !== false) {\n                that._editUserEvents.destroy();\n              }\n            }\n          },\n          inRange: function (options) {\n            var inRange = SchedulerView.fn.inRange.call(this, options);\n\n            if (options.isAllDay) {\n              return inRange;\n            }\n\n            var startTime = getMilliseconds(this.startTime());\n            var endTime = getMilliseconds(this.endTime()) || kendo.date.MS_PER_DAY;\n            var start = getMilliseconds(options.start);\n            var end = getMilliseconds(options.end) || kendo.date.MS_PER_DAY;\n            return inRange && startTime <= start && end <= endTime;\n          },\n          selectionByElement: function (cell) {\n            var offset = cell.offset(); // The magical number 5 is to buffer properly the height of the cell for all browsers\n\n            var height = Math.round(cell.innerHeight()) - 5;\n            return this._slotByPosition(offset.left, offset.top + height);\n          },\n          _timeSlotInterval: function () {\n            var options = this.options;\n            return options.majorTick / options.minorTickCount * MS_PER_MINUTE;\n          },\n          _timeSlotIndex: function (date) {\n            var options = this.options;\n            var eventStartTime = getMilliseconds(date);\n            var startTime = getMilliseconds(this.startTime());\n            var timeSlotInterval = options.majorTick / options.minorTickCount * MS_PER_MINUTE;\n            return (eventStartTime - startTime) / timeSlotInterval;\n          },\n          _slotIndex: function (date, multiday) {\n            if (multiday) {\n              return this._dateSlotIndex(date);\n            }\n\n            return this._timeSlotIndex(date);\n          },\n          _dateSlotIndex: function (date, overlaps) {\n            var idx;\n            var length;\n            var slots = this._dates || [];\n            var slotStart;\n            var slotEnd;\n            var offset = 1;\n\n            for (idx = 0, length = slots.length; idx < length; idx++) {\n              slotStart = kendo.date.getDate(slots[idx]);\n              slotEnd = new Date(kendo.date.getDate(slots[idx]).getTime() + MS_PER_DAY - (overlaps ? 0 : 1));\n\n              if (isInDateRange(date, slotStart, slotEnd)) {\n                return idx * offset;\n              }\n            }\n\n            return -1;\n          },\n          _positionAllDayEvent: function (element, slotRange) {\n            var slotWidth = slotRange.innerWidth();\n            var startIndex = slotRange.start.index;\n            var endIndex = slotRange.end.index;\n            var allDayEvents = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n            var currentColumnCount = this._headerColumnCount || 0;\n            var leftOffset = 2;\n            var rightOffset = startIndex !== endIndex ? 3 : 2;\n            var eventHeight = this._allDayHeaderHeight;\n            var start = slotRange.startSlot();\n            element.css({\n              left: start.offsetLeft + leftOffset,\n              width: slotWidth - rightOffset\n            });\n            slotRange.addEvent({\n              slotIndex: startIndex,\n              start: startIndex,\n              end: endIndex,\n              element: element\n            });\n            allDayEvents.push({\n              slotIndex: startIndex,\n              start: startIndex,\n              end: endIndex,\n              element: element\n            });\n            var rows = SchedulerView.createRows(allDayEvents);\n\n            if (rows.length && rows.length > currentColumnCount) {\n              this._headerColumnCount = rows.length;\n            }\n\n            var top = slotRange.start.offsetTop;\n\n            for (var idx = 0, length = rows.length; idx < length; idx++) {\n              var rowEvents = rows[idx].events;\n\n              for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n                $(rowEvents[j].element).css({\n                  top: top + idx * eventHeight,\n                  // apply calculated height.\n                  // -2 is to match normal events\n                  height: eventHeight - 2\n                });\n              }\n            }\n          },\n          _arrangeColumns: function (element, top, height, slotRange) {\n            var startSlot = slotRange.start;\n            element = {\n              element: element,\n              slotIndex: startSlot.index,\n              start: top,\n              end: top + height\n            };\n            var columns,\n                slotWidth = startSlot.clientWidth,\n                eventRightOffset = slotWidth * 0.10,\n                columnEvents,\n                eventElements = slotRange.events(),\n                slotEvents = SchedulerView.collidingEvents(eventElements, element.start, element.end),\n                tableEl = this.table.find(\".k-scheduler-content .k-scheduler-table\")[0],\n                contentEl = this.table.find(\".k-scheduler-content\")[0];\n            slotRange.addEvent(element);\n            slotEvents.push(element);\n            columns = SchedulerView.createColumns(slotEvents);\n            var columnWidth = (slotWidth - eventRightOffset) / columns.length;\n\n            for (var idx = 0, length = columns.length; idx < length; idx++) {\n              columnEvents = columns[idx].events;\n\n              for (var j = 0, eventLength = columnEvents.length; j < eventLength; j++) {\n                var calculatedWidth = columnWidth - 2;\n                columnEvents[j].element[0].style.width = (calculatedWidth > 0 ? calculatedWidth : columnWidth) + \"px\";\n\n                if (this._isRtl && contentEl.clientWidth < contentEl.scrollWidth) {\n                  // RTL mobile rendering with horizontal scroll\n                  columnEvents[j].element[0].style.left = eventRightOffset + startSlot.offsetLeft + idx * columnWidth - (tableEl.clientWidth - contentEl.clientWidth) + \"px\";\n                } else {\n                  columnEvents[j].element[0].style.left = (this._isRtl ? eventRightOffset : 0) + startSlot.offsetLeft + idx * columnWidth + 2 + \"px\";\n                }\n              }\n            }\n          },\n          _positionEvent: function (event, element, slotRange) {\n            var start = event._startTime || event.start;\n            var end = event._endTime || event.end;\n            var borderWidths = kendo.getComputedStyles(slotRange.start.element, [\"border-top-width\", \"border-bottom-width\"]);\n            var rect = slotRange.innerRect(start, end, false);\n            var height = rect.bottom - rect.top - parseFloat(borderWidths[\"border-top-width\"]) - parseFloat(borderWidths[\"border-bottom-width\"]);\n\n            if (height < 0) {\n              height = 0;\n            }\n\n            element.css({\n              top: rect.top,\n              height: height\n            });\n\n            this._arrangeColumns(element, rect.top, element[0].clientHeight, slotRange);\n          },\n          _createEventElement: function (event, isOneDayEvent, head, tail) {\n            var template = isOneDayEvent ? this.eventTemplate : this.allDayEventTemplate;\n            var options = this.options;\n            var editable = options.editable;\n\n            var isMobile = this._isMobile();\n\n            var showDelete = editable && editable.destroy !== false && !isMobile;\n            var resizable = editable && editable.resize !== false;\n            var startDate = getDate(this.startDate());\n            var endDate = getDate(this.endDate());\n            var startTime = getMilliseconds(this.startTime());\n            var endTime = getMilliseconds(this.endTime());\n\n            var eventStartTime = event._time(\"start\");\n\n            var eventEndTime = event._time(\"end\");\n\n            var middle;\n\n            if (startTime >= endTime) {\n              endTime = getMilliseconds(new Date(this.endTime().getTime() + MS_PER_DAY - 1));\n            }\n\n            if (!isOneDayEvent && !event.isAllDay) {\n              endDate = new Date(endDate.getTime() + MS_PER_DAY);\n            }\n\n            var eventStartDate = event.start;\n            var eventEndDate = event.end;\n\n            if (event.isAllDay) {\n              eventEndDate = getDate(event.end);\n            }\n\n            if (!isInDateRange(getDate(eventStartDate), startDate, endDate) && !isInDateRange(eventEndDate, startDate, endDate) || isOneDayEvent && event.start.getTime() !== event.end.getTime() && (eventStartTime < startTime || eventStartTime >= endTime) && (eventEndTime > endTime || eventEndTime <= startTime)) {\n              middle = true;\n            } else if (getDate(eventStartDate) < startDate || isOneDayEvent && eventStartTime !== 0 && event.start.getTime() !== event.end.getTime() && (eventStartTime < startTime || eventStartTime >= endTime)) {\n              tail = true;\n            } else if (eventEndDate > endDate && !isOneDayEvent || isOneDayEvent && eventEndTime !== 0 && event.start.getTime() !== event.end.getTime() && (eventEndTime > endTime || eventEndTime <= startTime)) {\n              head = true;\n            }\n\n            var resources = this.eventResources(event);\n\n            if (event._startTime && eventStartTime !== kendo.date.getMilliseconds(event.start)) {\n              eventStartDate = new Date(eventStartTime);\n              eventStartDate = kendo.timezone.apply(eventStartDate, \"Etc/UTC\");\n            }\n\n            if (event._endTime && eventEndTime !== kendo.date.getMilliseconds(event.end)) {\n              eventEndDate = new Date(eventEndTime);\n              eventEndDate = kendo.timezone.apply(eventEndDate, \"Etc/UTC\");\n            }\n\n            var data = extend({}, {\n              ns: kendo.ns,\n              resizable: resizable,\n              showDelete: showDelete,\n              middle: middle,\n              head: head,\n              tail: tail,\n              singleDay: this._dates.length == 1,\n              resources: resources,\n              inverseColor: false,\n              messages: options.messages,\n              ariaLabel: this._formatEventAriaLabel(event.title, eventStartDate, eventEndDate, event.isAllDay)\n            }, event, {\n              start: eventStartDate,\n              end: eventEndDate\n            });\n            var element = $(template(data));\n            this.angular(\"compile\", function () {\n              return {\n                elements: element,\n                data: [{\n                  dataItem: data\n                }]\n              };\n            });\n            return element;\n          },\n          _isInTimeSlot: function (event) {\n            var slotStartTime = this.startTime(),\n                slotEndTime = this.endTime(),\n                startTime = event._startTime || event.start,\n                endTime = event._endTime || event.end;\n\n            if (getMilliseconds(slotEndTime) === getMilliseconds(kendo.date.getDate(slotEndTime))) {\n              slotEndTime = kendo.date.getDate(slotEndTime);\n              setTime(slotEndTime, MS_PER_DAY - 1);\n            }\n\n            if (event._date(\"end\") > event._date(\"start\")) {\n              endTime = +event._date(\"end\") + (MS_PER_DAY - 1);\n            }\n\n            endTime = event._endTime ? endTime - event._date(\"end\") : getMilliseconds(new Date(endTime));\n            startTime = event._startTime ? startTime - event._date(\"start\") : getMilliseconds(new Date(startTime));\n            slotEndTime = getMilliseconds(slotEndTime);\n            slotStartTime = getMilliseconds(slotStartTime);\n\n            if (slotStartTime === startTime && startTime === endTime) {\n              return true;\n            }\n\n            var overlaps = startTime !== slotEndTime;\n            return isInTimeRange(startTime, slotStartTime, slotEndTime, overlaps) || isInTimeRange(endTime, slotStartTime, slotEndTime, overlaps) || isInTimeRange(slotStartTime, startTime, endTime) || isInTimeRange(slotEndTime, startTime, endTime) || event.end.getDate() > event.start.getDate() && endTime > slotStartTime;\n          },\n          _isInDateSlot: function (event) {\n            var groups = this.groups[0];\n            var slotStart = groups.firstSlot().start;\n            var slotEnd = groups.lastSlot().end - 1;\n            var startTime = kendo.date.toUtcTime(event.start);\n            var endTime = kendo.date.toUtcTime(event.end);\n            return (isInDateRange(startTime, slotStart, slotEnd) || isInDateRange(endTime, slotStart, slotEnd) || isInDateRange(slotStart, startTime, endTime) || isInDateRange(slotEnd, startTime, endTime)) && (!isInDateRange(endTime, slotStart, slotStart) || isInDateRange(endTime, startTime, startTime) || event.isAllDay);\n          },\n          _updateAllDayHeaderHeight: function (height) {\n            if (this._height !== height) {\n              this._height = height;\n              var allDaySlots = this.element.find(\".k-scheduler-header-all-day td\");\n\n              if (allDaySlots.length) {\n                allDaySlots.parent().add(this.element.find(\".k-scheduler-times-all-day\").parent()).height(height);\n\n                for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n                  this.groups[groupIndex].refresh();\n                }\n              }\n            }\n          },\n          _renderEvents: function (events, groupIndex) {\n            var allDayEventContainer = this.datesHeader.find(\".k-scheduler-header-wrap > div\");\n\n            var byDate = this._isGroupedByDate();\n\n            var event;\n            var idx;\n            var length;\n\n            for (idx = 0, length = events.length; idx < length; idx++) {\n              event = events[idx];\n\n              if (this._isInDateSlot(event)) {\n                var isMultiDayEvent, container, element, ranges, range, start, end, group;\n\n                if (this.options.enforceAllDaySlot) {\n                  isMultiDayEvent = event.isAllDay || event.duration() >= MS_PER_DAY;\n                } else {\n                  isMultiDayEvent = event.isAllDay;\n                }\n\n                container = isMultiDayEvent && !this._isVerticallyGrouped() ? allDayEventContainer : this.content;\n\n                if (!isMultiDayEvent) {\n                  if (this._isInTimeSlot(event)) {\n                    group = this.groups[groupIndex];\n\n                    if (!group) {\n                      continue;\n                    }\n\n                    if (!group._continuousEvents) {\n                      group._continuousEvents = [];\n                    }\n\n                    ranges = group.slotRanges(event);\n                    var rangeCount = ranges.length;\n\n                    for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {\n                      range = ranges[rangeIndex];\n                      start = event.start;\n                      end = event.end;\n\n                      if (rangeCount > 1) {\n                        if (rangeIndex === 0) {\n                          end = range.end.endDate();\n                        } else if (rangeIndex == rangeCount - 1) {\n                          start = range.start.startDate();\n                        } else {\n                          start = range.start.startDate();\n                          end = range.end.endDate();\n                        }\n                      }\n\n                      var occurrence = event.clone({\n                        start: start,\n                        end: end,\n                        _startTime: event._startTime,\n                        _endTime: event.endTime\n                      });\n\n                      if (this._isInTimeSlot(occurrence)) {\n                        var head = range.head;\n                        element = this._createEventElement(event, !isMultiDayEvent, head, range.tail);\n                        element.appendTo(container);\n\n                        this._inverseEventColor(element);\n\n                        this._positionEvent(occurrence, element, range);\n\n                        addContinuousEvent(group, range, element, false);\n                      }\n                    }\n                  }\n                } else if (this.options.allDaySlot) {\n                  group = this.groups[groupIndex];\n\n                  if (!group) {\n                    continue;\n                  }\n\n                  if (!group._continuousEvents) {\n                    group._continuousEvents = [];\n                  }\n\n                  ranges = group.slotRanges(event);\n\n                  if (ranges.length) {\n                    range = ranges[0];\n                    var startIndex = range.start.index;\n                    var endIndex = range.end.index;\n\n                    if (byDate && startIndex !== endIndex) {\n                      start = range.start.start;\n                      end = range.end.end;\n                      var newStart = start;\n                      var newEnd = start;\n\n                      for (var i = range.start.index; i <= range.end.index; i++) {\n                        element = this._createEventElement(event, !isMultiDayEvent, i !== endIndex, i !== startIndex);\n                        var dateRange = group.daySlotRanges(newStart, newEnd, true)[0];\n                        newStart = newEnd += kendo.date.MS_PER_DAY;\n\n                        this._positionAllDayEvent(element, dateRange);\n\n                        addContinuousEvent(group, dateRange, element, true);\n                        element.appendTo(container);\n\n                        this._inverseEventColor(element);\n                      }\n                    } else {\n                      element = this._createEventElement(event, !isMultiDayEvent);\n\n                      this._positionAllDayEvent(element, ranges[0]);\n\n                      addContinuousEvent(group, ranges[0], element, true);\n                      element.appendTo(container);\n\n                      this._inverseEventColor(element);\n                    }\n                  }\n                }\n              }\n            }\n          },\n          render: function (events) {\n            var that = this;\n            this._headerColumnCount = 0;\n            this._cachedEvents = events;\n\n            this._groups();\n\n            this.element.find(\".k-event\").remove();\n            events = new kendo.data.Query(events).sort([{\n              field: \"start\",\n              dir: \"asc\"\n            }, {\n              field: \"end\",\n              dir: \"desc\"\n            }]).toArray();\n            var eventsByResource = [];\n\n            this._eventsByResource(events, this.groupedResources, eventsByResource);\n\n            var eventsPerDate = $.map(this._dates, function (date) {\n              return Math.max.apply(null, $.map(eventsByResource, function (events) {\n                return $.grep(events, function (event) {\n                  if (that.options.enforceAllDaySlot) {\n                    return event.isMultiDay() && isInDateRange(date, getDate(event.start), getDate(event.end));\n                  } else {\n                    return event.isAllDay && isInDateRange(date, getDate(event.start), getDate(event.end));\n                  }\n                }).length;\n              }));\n            });\n            var height = Math.max.apply(null, eventsPerDate);\n\n            this._updateAllDayHeaderHeight((height + 1) * this._allDayHeaderHeight);\n\n            for (var groupIndex = 0; groupIndex < eventsByResource.length; groupIndex++) {\n              this._renderEvents(eventsByResource[groupIndex], groupIndex);\n            }\n\n            this.refreshLayout();\n\n            this._currentTime(false);\n\n            this.trigger(\"activate\");\n          },\n          _eventsByResource: function (events, resources, result, parentValue) {\n            var resource = resources[0];\n\n            if (resource) {\n              var view = resource.dataSource.view();\n              view = view.filter(function (item) {\n                var itemParentValue = kendo.getter(resource.dataParentValueField)(item);\n                return itemParentValue === null || itemParentValue === undefined || itemParentValue === parentValue;\n              });\n\n              for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n                var value = this._resourceValue(resource, view[itemIdx]);\n\n                var eventsFilteredByResource = new kendo.data.Query(events).filter({\n                  field: resource.field,\n                  operator: SchedulerView.groupEqFilter(value)\n                }).toArray();\n\n                if (resources.length > 1) {\n                  this._eventsByResource(eventsFilteredByResource, resources.slice(1), result, value);\n                } else {\n                  result.push(eventsFilteredByResource);\n                }\n              }\n            } else {\n              result.push(events);\n            }\n          },\n          _columnOffsetForResource: function (index) {\n            return this._columnCountForLevel(index) / this._columnCountForLevel(index - 1);\n          },\n          _columnCountForLevel: function (level) {\n            var columnLevel = this.columnLevels[level];\n            return columnLevel ? columnLevel.length : 0;\n          },\n          _rowCountForLevel: function (level, rowLevels) {\n            rowLevels = rowLevels || this.rowLevels;\n            var rowLevel = rowLevels[level];\n            return rowLevel ? rowLevel.length : 0;\n          },\n          clearSelection: function () {\n            this.content.add(this.datesHeader).find(\".k-state-selected\").removeAttr(\"id\").removeClass(\"k-state-selected\");\n          },\n          _updateDirection: function (selection, ranges, multiple, reverse, vertical) {\n            var isDaySlot = selection.isAllDay;\n            var startSlot = ranges[0].start;\n            var endSlot = ranges[ranges.length - 1].end;\n\n            if (multiple) {\n              if (vertical) {\n                if (!isDaySlot && startSlot.index === endSlot.index && startSlot.collectionIndex === endSlot.collectionIndex) {\n                  selection.backward = reverse;\n                }\n              } else {\n                if (isDaySlot && startSlot.index === endSlot.index || !isDaySlot && startSlot.collectionIndex === endSlot.collectionIndex) {\n                  selection.backward = reverse;\n                }\n              }\n            }\n          },\n          _changeViewPeriod: function (selection, reverse, vertical) {\n            if (!vertical) {\n              var date = reverse ? this.previousDate() : this.nextDate();\n              var start = selection.start;\n              var end = selection.end;\n\n              var verticalByDate = this._isGroupedByDate() && this._isVerticallyGrouped();\n\n              var group = this.groups[selection.groupIndex];\n              var collection = reverse ? group._timeSlotCollections : group._getCollections(group.daySlotCollectionCount());\n              var slots = collection[collection.length - 1]._slots;\n              var slotIndex = !reverse && !group.daySlotCollectionCount() ? 0 : slots.length - 1;\n              var endMilliseconds;\n              var newDateStart, newDateEnd;\n              newDateStart = new Date(date);\n              newDateEnd = new Date(date);\n\n              if (this._isInRange(newDateStart, newDateEnd)) {\n                return false;\n              }\n\n              selection.start = newDateStart;\n              selection.end = newDateEnd;\n\n              if (verticalByDate) {\n                var newStart = new Date(slots[slotIndex].startDate());\n                var newEnd = new Date(slots[slotIndex].endDate());\n                endMilliseconds = getMilliseconds(newEnd) ? getMilliseconds(newEnd) : MS_PER_DAY;\n                setTime(selection.start, getMilliseconds(newStart));\n                setTime(selection.end, endMilliseconds);\n\n                if (group.daySlotCollectionCount()) {\n                  selection.isAllDay = !selection.isAllDay;\n                }\n              } else {\n                endMilliseconds = selection.isAllDay || !getMilliseconds(end) ? MS_PER_DAY : getMilliseconds(end);\n                setTime(selection.start, getMilliseconds(start));\n                setTime(selection.end, endMilliseconds);\n              }\n\n              if (!this._isVerticallyGrouped()) {\n                selection.groupIndex = reverse ? this.groups.length - 1 : 0;\n              }\n\n              selection.events = [];\n              return true;\n            }\n          }\n        });\n        extend(true, ui, {\n          MultiDayView: MultiDayView,\n          DayView: MultiDayView.extend({\n            options: {\n              name: \"DayView\",\n              title: \"Day\",\n              selectedMobileDateFormat: \"{0:MMM d}\"\n            },\n            name: \"day\"\n          }),\n          WeekView: MultiDayView.extend({\n            options: {\n              name: \"WeekView\",\n              title: \"Week\",\n              selectedDateFormat: \"{0:D} - {1:D}\",\n              selectedShortDateFormat: \"{0:d} - {1:d}\"\n            },\n            name: \"week\",\n            calculateDateRange: function () {\n              var selectedDate = this.options.date,\n                  start = kendo.date.dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n                  idx,\n                  length,\n                  dates = [];\n\n              for (idx = 0, length = 7; idx < length; idx++) {\n                dates.push(start);\n                start = kendo.date.nextDay(start);\n              }\n\n              this._render(dates);\n            }\n          }),\n          WorkWeekView: MultiDayView.extend({\n            options: {\n              name: \"WorkWeekView\",\n              title: \"Work Week\",\n              selectedDateFormat: \"{0:D} - {1:D}\",\n              selectedShortDateFormat: \"{0:d} - {1:d}\"\n            },\n            name: \"workWeek\",\n            nextDate: function () {\n              var weekStart = kendo.date.dayOfWeek(kendo.date.nextDay(this.startDate()), this.calendarInfo().firstDay, 1);\n              return kendo.date.addDays(weekStart, this._workDays[0]);\n            },\n            previousDate: function () {\n              var weekStart = kendo.date.dayOfWeek(this.startDate(), this.calendarInfo().firstDay, -1);\n              var workDays = this._workDays;\n              return kendo.date.addDays(weekStart, workDays[workDays.length - 1] - 7);\n            },\n            calculateDateRange: function () {\n              var options = this.options,\n                  selectedDate = options.date,\n                  dayOfWeek = kendo.date.dayOfWeek,\n                  weekStart = dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n                  start = dayOfWeek(weekStart, options.workWeekStart, 1),\n                  end = dayOfWeek(start, options.workWeekEnd, 1),\n                  dates = [],\n                  workDays = options.workDays && options.workDays.length ? options.workDays.map(function (day) {\n                return dayOfWeek(weekStart, day, 1).getTime();\n              }) : null;\n\n              if (workDays) {\n                start = weekStart;\n                end = dayOfWeek(start, this.calendarInfo().firstDay + 6, 1);\n              }\n\n              while (start <= end) {\n                if (workDays && workDays.indexOf(start.getTime()) > -1) {\n                  dates.push(start);\n                } else if (!workDays) {\n                  dates.push(start);\n                }\n\n                start = kendo.date.nextDay(start);\n              }\n\n              this._render(dates);\n            }\n          })\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}