{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1362);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1132:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.fx\");\n    /***/\n  },\n\n  /***/\n  1136:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.draganddrop\");\n    /***/\n  },\n\n  /***/\n  1362:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1132), __webpack_require__(1136)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"mobile.scroller\",\n        name: \"Scroller\",\n        category: \"mobile\",\n        description: \"The Kendo Mobile Scroller widget enables touch friendly kinetic scrolling for the contents of a given DOM element.\",\n        depends: [\"fx\", \"draganddrop\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            mobile = kendo.mobile,\n            fx = kendo.effects,\n            ui = mobile.ui,\n            extend = $.extend,\n            Widget = ui.Widget,\n            Class = kendo.Class,\n            Movable = kendo.ui.Movable,\n            Pane = kendo.ui.Pane,\n            PaneDimensions = kendo.ui.PaneDimensions,\n            Transition = fx.Transition,\n            Animation = fx.Animation,\n            abs = Math.abs,\n            SNAPBACK_DURATION = 500,\n            SCROLLBAR_OPACITY = 0.7,\n            FRICTION = 0.96,\n            VELOCITY_MULTIPLIER = 10,\n            MAX_VELOCITY = 55,\n            OUT_OF_BOUNDS_FRICTION = 0.5,\n            ANIMATED_SCROLLER_PRECISION = 5,\n            RELEASECLASS = \"km-scroller-release\",\n            REFRESHCLASS = \"km-scroller-refresh\",\n            PULL = \"pull\",\n            CHANGE = \"change\",\n            RESIZE = \"resize\",\n            SCROLL = \"scroll\",\n            MOUSE_WHEEL_ID = 2;\n        var ZoomSnapBack = Animation.extend({\n          init: function (options) {\n            var that = this;\n            Animation.fn.init.call(that);\n            extend(that, options);\n            that.userEvents.bind(\"gestureend\", that.start.bind(that));\n            that.tapCapture.bind(\"press\", that.cancel.bind(that));\n          },\n          enabled: function () {\n            return this.movable.scale < this.dimensions.minScale;\n          },\n          done: function () {\n            return this.dimensions.minScale - this.movable.scale < 0.01;\n          },\n          tick: function () {\n            var movable = this.movable;\n            movable.scaleWith(1.1);\n            this.dimensions.rescale(movable.scale);\n          },\n          onEnd: function () {\n            var movable = this.movable;\n            movable.scaleTo(this.dimensions.minScale);\n            this.dimensions.rescale(movable.scale);\n          }\n        });\n        var DragInertia = Animation.extend({\n          init: function (options) {\n            var that = this;\n            Animation.fn.init.call(that);\n            extend(that, options, {\n              transition: new Transition({\n                axis: options.axis,\n                movable: options.movable,\n                onEnd: function () {\n                  that._end();\n                }\n              })\n            });\n            that.tapCapture.bind(\"press\", function () {\n              that.cancel();\n            });\n            that.userEvents.bind(\"end\", that.start.bind(that));\n            that.userEvents.bind(\"gestureend\", that.start.bind(that));\n            that.userEvents.bind(\"tap\", that.onEnd.bind(that));\n          },\n          onCancel: function () {\n            this.transition.cancel();\n          },\n          freeze: function (location) {\n            var that = this;\n            that.cancel();\n\n            that._moveTo(location);\n          },\n          onEnd: function () {\n            var that = this;\n\n            if (that.paneAxis.outOfBounds()) {\n              that._snapBack();\n            } else {\n              that._end();\n            }\n          },\n          done: function () {\n            return abs(this.velocity) < 1;\n          },\n          start: function (e) {\n            var that = this,\n                velocity;\n\n            if (!that.dimension.enabled) {\n              return;\n            }\n\n            if (that.paneAxis.outOfBounds()) {\n              if (that.transition._started) {\n                that.transition.cancel();\n                that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);\n                Animation.fn.start.call(that);\n              } else {\n                that._snapBack();\n              }\n            } else {\n              velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;\n              that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);\n              that.tapCapture.captureNext();\n              Animation.fn.start.call(that);\n            }\n          },\n          tick: function () {\n            var that = this,\n                dimension = that.dimension,\n                friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction,\n                delta = that.velocity *= friction,\n                location = that.movable[that.axis] + delta;\n\n            if (!that.elastic && dimension.outOfBounds(location)) {\n              location = Math.max(Math.min(location, dimension.max), dimension.min);\n              that.velocity = 0;\n            }\n\n            that.movable.moveAxis(that.axis, location);\n          },\n          _end: function () {\n            this.tapCapture.cancelCapture();\n            this.end();\n          },\n          _snapBack: function () {\n            var that = this,\n                dimension = that.dimension,\n                snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;\n\n            that._moveTo(snapBack);\n          },\n          _moveTo: function (location) {\n            this.transition.moveTo({\n              location: location,\n              duration: SNAPBACK_DURATION,\n              ease: Transition.easeOutExpo\n            });\n          }\n        });\n        var AnimatedScroller = Animation.extend({\n          init: function (options) {\n            var that = this;\n            kendo.effects.Animation.fn.init.call(this);\n            extend(that, options, {\n              origin: {},\n              destination: {},\n              offset: {}\n            });\n          },\n          tick: function () {\n            this._updateCoordinates();\n\n            this.moveTo(this.origin);\n          },\n          done: function () {\n            return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;\n          },\n          onEnd: function () {\n            this.moveTo(this.destination);\n\n            if (this.callback) {\n              this.callback.call();\n            }\n          },\n          setCoordinates: function (from, to) {\n            this.offset = {};\n            this.origin = from;\n            this.destination = to;\n          },\n          setCallback: function (callback) {\n            if (callback && kendo.isFunction(callback)) {\n              this.callback = callback;\n            } else {\n              callback = undefined;\n            }\n          },\n          _updateCoordinates: function () {\n            this.offset = {\n              x: (this.destination.x - this.origin.x) / 4,\n              y: (this.destination.y - this.origin.y) / 4\n            };\n            this.origin = {\n              y: this.origin.y + this.offset.y,\n              x: this.origin.x + this.offset.x\n            };\n          }\n        });\n        var ScrollBar = Class.extend({\n          init: function (options) {\n            var that = this,\n                horizontal = options.axis === \"x\",\n                element = $('<div role=\"scrollbar\" aria-controls=\"' + options.controlsId + '\" class=\"km-touch-scrollbar km-' + (horizontal ? \"horizontal\" : \"vertical\") + '-scrollbar\" />');\n\n            if (horizontal) {\n              element.attr(\"aria-orientation\", \"horizontal\");\n            }\n\n            extend(that, options, {\n              element: element,\n              elementSize: 0,\n              movable: new Movable(element),\n              scrollMovable: options.movable,\n              alwaysVisible: options.alwaysVisible,\n              size: horizontal ? \"width\" : \"height\"\n            });\n            that.scrollMovable.bind(CHANGE, that.refresh.bind(that));\n            that.container.append(element);\n\n            if (options.alwaysVisible) {\n              that.show();\n            }\n          },\n          refresh: function () {\n            var that = this,\n                axis = that.axis,\n                dimension = that.dimension,\n                paneSize = dimension.size,\n                scrollMovable = that.scrollMovable,\n                sizeRatio = paneSize / dimension.total,\n                position = Math.round(-scrollMovable[axis] * sizeRatio),\n                size = Math.round(paneSize * sizeRatio);\n\n            if (sizeRatio >= 1) {\n              this.element.css(\"display\", \"none\");\n            } else {\n              this.element.css(\"display\", \"\");\n            }\n\n            if (position + size > paneSize) {\n              size = paneSize - position;\n            } else if (position < 0) {\n              size += position;\n              position = 0;\n            }\n\n            if (that.elementSize != size) {\n              that.element.css(that.size, size + \"px\");\n              that.elementSize = size;\n            }\n\n            that._ariaValue(position, dimension.size - that.elementSize);\n\n            that.movable.moveAxis(axis, position);\n          },\n          show: function () {\n            this.element.css({\n              opacity: SCROLLBAR_OPACITY,\n              visibility: \"visible\"\n            });\n          },\n          hide: function () {\n            if (!this.alwaysVisible) {\n              this.element.css({\n                opacity: 0\n              });\n            }\n          },\n          _ariaValue: function (current, total) {\n            var element = this.element;\n\n            if (current > total) {\n              current = total;\n            }\n\n            element.attr(\"aria-valuemax\", total);\n            element.attr(\"aria-valuenow\", current);\n          }\n        });\n        var Scroller = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            element = that.element;\n            that._native = that.options.useNative && kendo.support.hasNativeScrolling;\n\n            if (that._native) {\n              element.addClass(\"km-native-scroller\").prepend('<div class=\"km-scroll-header\"/>');\n              extend(that, {\n                scrollElement: element,\n                fixedContainer: element.children().first()\n              });\n              return;\n            }\n\n            element.css(\"overflow\", \"hidden\").addClass(\"km-scroll-wrapper\").wrapInner('<div class=\"km-scroll-container\"/>').prepend('<div class=\"km-scroll-header\"/>');\n            var inner = element.children().eq(1),\n                tapCapture = new kendo.TapCapture(element),\n                movable = new Movable(inner),\n                dimensions = new PaneDimensions({\n              element: inner,\n              container: element,\n              forcedEnabled: that.options.zoom\n            }),\n                avoidScrolling = this.options.avoidScrolling,\n                userEvents = new kendo.UserEvents(element, {\n              touchAction: \"pan-y\",\n              fastTap: true,\n              allowSelection: true,\n              preventDragEvent: true,\n              captureUpIfMoved: true,\n              multiTouch: that.options.zoom,\n              supportDoubleTap: that.options.supportDoubleTap,\n              start: function (e) {\n                dimensions.refresh();\n                var velocityX = abs(e.x.velocity),\n                    velocityY = abs(e.y.velocity),\n                    horizontalSwipe = velocityX * 2 >= velocityY,\n                    originatedFromFixedContainer = $.contains(that.fixedContainer[0], e.event.target),\n                    verticalSwipe = velocityY * 2 >= velocityX;\n\n                if (!originatedFromFixedContainer && !avoidScrolling(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {\n                  userEvents.capture();\n                } else {\n                  userEvents.cancel();\n                }\n              }\n            }),\n                pane = new Pane({\n              movable: movable,\n              dimensions: dimensions,\n              userEvents: userEvents,\n              elastic: that.options.elastic\n            }),\n                zoomSnapBack = new ZoomSnapBack({\n              movable: movable,\n              dimensions: dimensions,\n              userEvents: userEvents,\n              tapCapture: tapCapture\n            }),\n                animatedScroller = new AnimatedScroller({\n              moveTo: function (coordinates) {\n                that.scrollTo(coordinates.x, coordinates.y);\n              }\n            });\n            movable.bind(CHANGE, function () {\n              that.scrollTop = -movable.y;\n              that.scrollLeft = -movable.x;\n              that.trigger(SCROLL, {\n                scrollTop: that.scrollTop,\n                scrollLeft: that.scrollLeft\n              });\n            });\n\n            if (that.options.mousewheelScrolling) {\n              element.on(\"DOMMouseScroll mousewheel\", this._wheelScroll.bind(this));\n            }\n\n            extend(that, {\n              movable: movable,\n              dimensions: dimensions,\n              zoomSnapBack: zoomSnapBack,\n              animatedScroller: animatedScroller,\n              userEvents: userEvents,\n              pane: pane,\n              tapCapture: tapCapture,\n              pulled: false,\n              enabled: true,\n              scrollElement: inner,\n              scrollTop: 0,\n              scrollLeft: 0,\n              fixedContainer: element.children().first()\n            });\n\n            that._initAxis(\"x\");\n\n            that._initAxis(\"y\"); // build closure\n\n\n            that._wheelEnd = function () {\n              that._wheel = false;\n              that.userEvents.end(0, that._wheelY);\n            };\n\n            dimensions.refresh();\n\n            if (that.options.pullToRefresh) {\n              that._initPullToRefresh();\n            }\n          },\n          _wheelScroll: function (e) {\n            if (e.ctrlKey) {\n              return;\n            }\n\n            if (!this._wheel) {\n              this._wheel = true;\n              this._wheelY = 0;\n              this.userEvents.press(0, this._wheelY);\n            }\n\n            clearTimeout(this._wheelTimeout);\n            this._wheelTimeout = setTimeout(this._wheelEnd, 50);\n            var delta = kendo.wheelDeltaY(e);\n\n            if (delta) {\n              this._wheelY += delta;\n              this.userEvents.move(0, this._wheelY);\n            }\n\n            e.preventDefault();\n          },\n          makeVirtual: function () {\n            this.dimensions.y.makeVirtual();\n          },\n          virtualSize: function (min, max) {\n            this.dimensions.y.virtualSize(min, max);\n          },\n          height: function () {\n            return this.dimensions.y.size;\n          },\n          scrollHeight: function () {\n            return this.scrollElement[0].scrollHeight;\n          },\n          scrollWidth: function () {\n            return this.scrollElement[0].scrollWidth;\n          },\n          options: {\n            name: \"Scroller\",\n            zoom: false,\n            pullOffset: 140,\n            visibleScrollHints: false,\n            elastic: true,\n            useNative: false,\n            mousewheelScrolling: true,\n            avoidScrolling: function () {\n              return false;\n            },\n            pullToRefresh: false,\n            messages: {\n              pullTemplate: \"Pull to refresh\",\n              releaseTemplate: \"Release to refresh\",\n              refreshTemplate: \"Refreshing\"\n            }\n          },\n          events: [PULL, SCROLL, RESIZE],\n          _resize: function () {\n            if (!this._native) {\n              this.contentResized();\n            }\n          },\n          setOptions: function (options) {\n            var that = this;\n            Widget.fn.setOptions.call(that, options);\n\n            if (options.pullToRefresh) {\n              that._initPullToRefresh();\n            }\n          },\n          reset: function () {\n            if (this._native) {\n              this.scrollElement.scrollTop(0);\n            } else {\n              this.movable.moveTo({\n                x: 0,\n                y: 0\n              });\n\n              this._scale(1);\n            }\n          },\n          contentResized: function () {\n            this.dimensions.refresh();\n\n            if (this.pane.x.outOfBounds()) {\n              this.movable.moveAxis(\"x\", this.dimensions.x.min);\n            }\n\n            if (this.pane.y.outOfBounds()) {\n              this.movable.moveAxis(\"y\", this.dimensions.y.min);\n            }\n          },\n          zoomOut: function () {\n            var dimensions = this.dimensions;\n            dimensions.refresh();\n\n            this._scale(dimensions.fitScale);\n\n            this.movable.moveTo(dimensions.centerCoordinates());\n          },\n          enable: function () {\n            this.enabled = true;\n          },\n          disable: function () {\n            this.enabled = false;\n          },\n          scrollTo: function (x, y) {\n            if (this._native) {\n              kendo.scrollLeft(this.scrollElement, abs(x));\n              this.scrollElement.scrollTop(abs(y));\n            } else {\n              this.dimensions.refresh();\n              this.movable.moveTo({\n                x: x,\n                y: y\n              });\n            }\n          },\n          animatedScrollTo: function (x, y, callback) {\n            var from, to;\n\n            if (this._native) {\n              this.scrollTo(x, y);\n            } else {\n              from = {\n                x: this.movable.x,\n                y: this.movable.y\n              };\n              to = {\n                x: x,\n                y: y\n              };\n              this.animatedScroller.setCoordinates(from, to);\n              this.animatedScroller.setCallback(callback);\n              this.animatedScroller.start();\n            }\n          },\n          pullHandled: function () {\n            var that = this;\n            that.refreshHint.removeClass(REFRESHCLASS);\n            that.hintContainer.html(that.pullTemplate({}));\n            that.yinertia.onEnd();\n            that.xinertia.onEnd();\n            that.userEvents.cancel();\n          },\n          destroy: function () {\n            Widget.fn.destroy.call(this);\n\n            if (this.userEvents) {\n              this.userEvents.destroy();\n            }\n          },\n          _scale: function (scale) {\n            this.dimensions.rescale(scale);\n            this.movable.scaleTo(scale);\n          },\n          _initPullToRefresh: function () {\n            var that = this;\n            that.dimensions.y.forceEnabled();\n            that.pullTemplate = kendo.template(that.options.messages.pullTemplate);\n            that.releaseTemplate = kendo.template(that.options.messages.releaseTemplate);\n            that.refreshTemplate = kendo.template(that.options.messages.refreshTemplate);\n            that.scrollElement.prepend('<span class=\"km-scroller-pull\"><span class=\"km-icon\"></span><span class=\"km-loading-left\"></span><span class=\"km-loading-right\"></span><span class=\"km-template\">' + that.pullTemplate({}) + '</span></span>');\n            that.refreshHint = that.scrollElement.children().first();\n            that.hintContainer = that.refreshHint.children(\".km-template\");\n            that.pane.y.bind(\"change\", that._paneChange.bind(that));\n            that.userEvents.bind(\"end\", that._dragEnd.bind(that));\n          },\n          _dragEnd: function () {\n            var that = this;\n\n            if (!that.pulled) {\n              return;\n            }\n\n            that.pulled = false;\n            that.refreshHint.removeClass(RELEASECLASS).addClass(REFRESHCLASS);\n            that.hintContainer.html(that.refreshTemplate({}));\n            that.yinertia.freeze(that.options.pullOffset / 2);\n            that.trigger(\"pull\");\n          },\n          _paneChange: function () {\n            var that = this;\n\n            if (that.movable.y / OUT_OF_BOUNDS_FRICTION > that.options.pullOffset) {\n              if (!that.pulled) {\n                that.pulled = true;\n                that.refreshHint.removeClass(REFRESHCLASS).addClass(RELEASECLASS);\n                that.hintContainer.html(that.releaseTemplate({}));\n              }\n            } else if (that.pulled) {\n              that.pulled = false;\n              that.refreshHint.removeClass(RELEASECLASS);\n              that.hintContainer.html(that.pullTemplate({}));\n            }\n          },\n          _initAxis: function (axis) {\n            var that = this,\n                elementId = that.element.attr(\"id\"),\n                movable = that.movable,\n                dimension = that.dimensions[axis],\n                tapCapture = that.tapCapture,\n                paneAxis = that.pane[axis],\n                scrollBar;\n\n            if (!elementId) {\n              elementId = kendo.guid();\n              that.element.attr(\"id\", elementId);\n            }\n\n            scrollBar = new ScrollBar({\n              axis: axis,\n              movable: movable,\n              dimension: dimension,\n              container: that.element,\n              alwaysVisible: that.options.visibleScrollHints,\n              controlsId: elementId\n            });\n            dimension.bind(CHANGE, function () {\n              scrollBar.refresh();\n            });\n            paneAxis.bind(CHANGE, function () {\n              scrollBar.show();\n            });\n            that[axis + \"inertia\"] = new DragInertia({\n              axis: axis,\n              paneAxis: paneAxis,\n              movable: movable,\n              tapCapture: tapCapture,\n              userEvents: that.userEvents,\n              dimension: dimension,\n              elastic: that.options.elastic,\n              friction: that.options.friction || FRICTION,\n              velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,\n              end: function () {\n                scrollBar.hide();\n                that.trigger(\"scrollEnd\", {\n                  axis: axis,\n                  scrollTop: that.scrollTop,\n                  scrollLeft: that.scrollLeft\n                });\n              }\n            });\n          }\n        });\n        ui.plugin(Scroller);\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}