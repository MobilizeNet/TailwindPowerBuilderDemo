{"ast":null,"code":"import { autoTextColor, deepExtend, getTemplate, valueOrDefault } from '../../common';\nimport { CENTER, ROUNDED_RECT, BOTTOM, WHITE } from '../../common/constants';\nimport { ChartElement, Point, rectToBox, ShapeElement, TextBox } from '../../core';\nimport { TOOLTIP_OFFSET } from '../constants';\nimport NoteMixin from '../mixins/note-mixin';\nimport PointEventsMixin from '../mixins/point-events-mixin';\n\nclass HeatmapPoint extends ChartElement {\n  constructor(value, options) {\n    super();\n    this.options = options;\n    this.color = options.color || WHITE;\n    this.value = value;\n  }\n\n  render() {\n    if (this._rendered) {\n      return;\n    }\n\n    this._rendered = true;\n    this.createMarker();\n    this.createLabel();\n    this.createNote();\n  }\n\n  createLabel() {\n    const options = this.options;\n    const labels = options.labels;\n\n    if (labels.visible) {\n      const pointData = this.pointData();\n      let labelTemplate = getTemplate(labels);\n      let labelText;\n      let labelColor = labels.color;\n\n      if (labelTemplate) {\n        labelText = labelTemplate(pointData);\n      } else {\n        labelText = this.formatValue(labels.format);\n      }\n\n      if (!labelColor) {\n        labelColor = autoTextColor(this.color);\n      }\n\n      this.label = new TextBox(labelText, deepExtend({\n        align: CENTER,\n        vAlign: CENTER,\n        margin: {\n          left: 5,\n          right: 5\n        },\n        zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n      }, labels, {\n        color: labelColor\n      }), pointData);\n      this.append(this.label);\n    }\n  }\n\n  formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  }\n\n  reflow(targetBox) {\n    this.render();\n    const label = this.label;\n    this.box = targetBox;\n\n    if (label) {\n      label.reflow(this.markerBox());\n    }\n\n    if (this.note) {\n      this.note.reflow(targetBox);\n    }\n\n    this.marker.reflow(this.markerBox());\n  }\n\n  markerBox() {\n    const options = this.options;\n    const markers = options.markers;\n    const border = markers.border;\n    const rect = this.box.toRect();\n    const type = valueOrDefault(markers.type, 'rect');\n    const isRoundRect = type === ROUNDED_RECT;\n    let borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);\n    const halfBorderWidth = Math.round(borderWidth / 2);\n\n    if (markers.size) {\n      const center = rect.center();\n      rect.size.width = rect.size.height = markers.size;\n      rect.origin.x = Math.round(center.x - rect.size.width / 2);\n      rect.origin.y = Math.round(center.y - rect.size.height / 2);\n    }\n\n    rect.size.width -= borderWidth;\n    rect.size.height -= borderWidth;\n    rect.origin.y += halfBorderWidth + 0.5;\n    rect.origin.x += halfBorderWidth + 0.5;\n    return rectToBox(rect);\n  }\n\n  markerBorder() {\n    const options = this.options;\n    const markers = options.markers;\n    const border = markers.border;\n    const opacity = valueOrDefault(border.opacity, options.opacity);\n    return {\n      color: border.color || this.color,\n      width: border.width,\n      opacity: opacity,\n      dashType: border.dashType\n    };\n  }\n\n  createMarker() {\n    const options = this.options;\n    const markerOptions = options.markers;\n    const marker = new ShapeElement({\n      type: valueOrDefault(markerOptions.type, 'rect'),\n      width: markerOptions.size,\n      height: markerOptions.size,\n      rotation: markerOptions.rotation,\n      background: this.color,\n      border: this.markerBorder(),\n      borderRadius: markerOptions.borderRadius,\n      opacity: this.series.opacity || options.opacity,\n      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n      animation: options.animation,\n      visual: options.visual\n    }, {\n      dataItem: this.dataItem,\n      value: this.value,\n      series: this.series,\n      category: this.category\n    });\n    this.marker = marker;\n    this.append(marker);\n  }\n\n  createHighlight(style) {\n    const options = this.options;\n    const markerOptions = this.options.highlight.markers || this.options.markers;\n    const highlight = new ShapeElement({\n      type: valueOrDefault(markerOptions.type, 'rect'),\n      width: markerOptions.size,\n      height: markerOptions.size,\n      rotation: markerOptions.rotation,\n      background: markerOptions.color || this.color,\n      border: this.markerBorder(),\n      borderRadius: markerOptions.borderRadius,\n      opacity: this.series.opacity || options.opacity,\n      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n    });\n    highlight.reflow(this.markerBox());\n    const visual = highlight.getElement();\n    visual.options.fill = style.fill;\n    visual.options.stroke = style.stroke;\n    return visual;\n  }\n\n  highlightVisual() {\n    return this.rectVisual;\n  }\n\n  highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this.rectVisual\n    };\n  }\n\n  tooltipAnchor() {\n    const left = this.box.center().x;\n    const top = this.box.y1 - TOOLTIP_OFFSET;\n    return {\n      point: new Point(left, top),\n      align: {\n        horizontal: CENTER,\n        vertical: BOTTOM\n      }\n    };\n  }\n\n  overlapsBox(box) {\n    return this.box.overlaps(box);\n  }\n\n  unclipElements() {\n    /* noop, clip labels */\n  }\n\n  pointData() {\n    return {\n      x: this.value.x,\n      y: this.value.y,\n      value: this.value.value,\n      dataItem: this.dataItem,\n      series: this.series\n    };\n  }\n\n}\n\ndeepExtend(HeatmapPoint.prototype, PointEventsMixin);\ndeepExtend(HeatmapPoint.prototype, NoteMixin);\nHeatmapPoint.prototype.defaults = {\n  markers: {\n    type: 'rect',\n    borderRadius: 4,\n    border: {\n      color: 'transparent'\n    }\n  },\n  padding: {\n    top: 1\n  },\n  labels: {\n    visible: false,\n    padding: 3\n  },\n  opacity: 1,\n  notes: {\n    label: {}\n  }\n};\nexport default HeatmapPoint;","map":null,"metadata":{},"sourceType":"module"}