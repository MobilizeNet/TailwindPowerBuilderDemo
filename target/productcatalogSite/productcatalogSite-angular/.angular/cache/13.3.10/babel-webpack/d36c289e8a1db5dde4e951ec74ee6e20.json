{"ast":null,"code":"import { deepExtend, eventElement, grep, inArray, setDefaultOptions, createHashSet } from '../../common';\nimport { DATE } from '../../common/constants';\nimport { CategoryAxis, DateCategoryAxis, Point } from '../../core';\nimport { HEATMAP } from '../constants';\nimport HeatmapChart from '../heatmap-chart/heatmap-chart';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesBinder from '../series-binder';\nimport { appendIfNotNull, equalsIgnoreCase, filterSeriesByType, singleItemOrArray } from '../utils';\nimport PlotAreaBase from './plotarea-base';\n\nclass HeatmapPlotArea extends PlotAreaBase {\n  initFields() {\n    this.namedXAxes = {};\n    this.namedYAxes = {};\n  }\n\n  render(panes = this.panes) {\n    this.bindCategories();\n    this.createAxes(panes);\n    this.createCharts(panes);\n    this.createAxisLabels();\n  }\n\n  bindCategories() {\n    const series = this.srcSeries || this.series;\n\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      const data = currentSeries.data || [];\n      const {\n        xAxis,\n        yAxis\n      } = this.seriesAxes(currentSeries);\n      const xCategories = createHashSet(xAxis.categories || []);\n      const yCategories = createHashSet(yAxis.categories || []);\n\n      for (let pointIndex = 0; pointIndex < data.length; pointIndex++) {\n        const {\n          x,\n          y\n        } = SeriesBinder.current.bindPoint(currentSeries, pointIndex).valueFields;\n\n        if (!xCategories.has(x)) {\n          xCategories.add(x);\n        }\n\n        if (!yCategories.has(y)) {\n          yCategories.add(y);\n        }\n      }\n\n      xAxis.categories = xCategories.values();\n      yAxis.categories = yCategories.values();\n    }\n  }\n\n  createCharts(panes) {\n    const seriesByPane = this.groupSeriesByPane();\n\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this.addToLegend(paneSeries);\n      const filteredSeries = this.filterVisibleSeries(paneSeries);\n\n      if (!filteredSeries) {\n        continue;\n      }\n\n      this.createHeatmapChart(filterSeriesByType(filteredSeries, [HEATMAP]), pane);\n    }\n  }\n\n  createHeatmapChart(series, pane) {\n    const chart = new HeatmapChart(this, {\n      series: series\n    });\n    this.appendChart(chart, pane);\n  }\n\n  seriesPaneName(series) {\n    const options = this.options;\n    const xAxisName = series.xAxis;\n    const xAxisOptions = [].concat(options.xAxis);\n    const xAxis = grep(xAxisOptions, function (a) {\n      return a.name === xAxisName;\n    })[0];\n    const yAxisName = series.yAxis;\n    const yAxisOptions = [].concat(options.yAxis);\n    const yAxis = grep(yAxisOptions, function (a) {\n      return a.name === yAxisName;\n    })[0];\n    const panes = options.panes || [{}];\n    const defaultPaneName = panes[0].name || \"default\";\n    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n    return paneName;\n  }\n\n  seriesAxes(series) {\n    let xAxis;\n    let yAxis;\n    const options = this.options;\n    const xAxisOptions = [].concat(options.xAxis);\n    const xAxisName = series.xAxis;\n\n    if (xAxisName) {\n      xAxis = xAxisOptions.find(axis => axis.name === xAxisName);\n    } else {\n      xAxis = xAxisOptions[0];\n    }\n\n    const yAxisOptions = [].concat(options.yAxis);\n    const yAxisName = series.yAxis;\n\n    if (yAxisName) {\n      yAxis = yAxisOptions.find(axis => axis.name === yAxisName);\n    } else {\n      yAxis = yAxisOptions[0];\n    }\n\n    if (!xAxis) {\n      throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n    }\n\n    if (!yAxis) {\n      throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n    }\n\n    return {\n      xAxis,\n      yAxis\n    };\n  }\n\n  createAxisLabels() {\n    const axes = this.axes;\n\n    for (let i = 0; i < axes.length; i++) {\n      axes[i].createLabels();\n    }\n  }\n\n  createXYAxis(options, vertical, axisIndex) {\n    const axisName = options.name;\n    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n    const axisOptions = Object.assign({\n      axisCrossingValue: 0\n    }, options, {\n      vertical: vertical,\n      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,\n      justified: false\n    });\n    const firstCategory = axisOptions.categories ? axisOptions.categories[0] : null;\n    const typeSamples = [axisOptions.min, axisOptions.max, firstCategory];\n    const series = this.series;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n\n      if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n        const firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n        typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n        break;\n      }\n    }\n\n    let inferredDate;\n\n    for (let i = 0; i < typeSamples.length; i++) {\n      if (typeSamples[i] instanceof Date) {\n        inferredDate = true;\n        break;\n      }\n    }\n\n    let axisType;\n\n    if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n      axisType = DateCategoryAxis;\n    } else {\n      axisType = CategoryAxis;\n    }\n\n    const axis = new axisType(axisOptions, this.chartService);\n    axis.axisIndex = axisIndex;\n\n    if (axisName) {\n      if (namedAxes[axisName]) {\n        throw new Error(`${vertical ? \"Y\" : \"X\"} axis with name ${axisName} is already defined`);\n      }\n\n      namedAxes[axisName] = axis;\n    }\n\n    this.appendAxis(axis);\n    axis.mapCategories();\n    return axis;\n  }\n\n  createAxes(panes) {\n    const options = this.options;\n    const xAxesOptions = [].concat(options.xAxis);\n    const xAxes = [];\n    const yAxesOptions = [].concat(options.yAxis);\n    const yAxes = [];\n\n    for (let idx = 0; idx < xAxesOptions.length; idx++) {\n      const axisPane = this.findPane(xAxesOptions[idx].pane);\n\n      if (inArray(axisPane, panes)) {\n        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));\n      }\n    }\n\n    for (let idx = 0; idx < yAxesOptions.length; idx++) {\n      const axisPane = this.findPane(yAxesOptions[idx].pane);\n\n      if (inArray(axisPane, panes)) {\n        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));\n      }\n    }\n\n    this.axisX = this.axisX || xAxes[0];\n    this.axisY = this.axisY || yAxes[0];\n  }\n\n  removeAxis(axis) {\n    const axisName = axis.options.name;\n    super.removeAxis(axis);\n\n    if (axis.options.vertical) {\n      delete this.namedYAxes[axisName];\n    } else {\n      delete this.namedXAxes[axisName];\n    }\n\n    if (axis === this.axisX) {\n      delete this.axisX;\n    }\n\n    if (axis === this.axisY) {\n      delete this.axisY;\n    }\n  }\n\n  _dispatchEvent(chart, e, eventType) {\n    const coords = chart._eventCoordinates(e);\n\n    const point = new Point(coords.x, coords.y);\n    const allAxes = this.axes;\n    const length = allAxes.length;\n    const xValues = [];\n    const yValues = [];\n\n    for (let i = 0; i < length; i++) {\n      const axis = allAxes[i];\n      const values = axis.options.vertical ? yValues : xValues;\n      appendIfNotNull(values, axis.getCategory(point));\n    }\n\n    if (xValues.length > 0 && yValues.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        x: singleItemOrArray(xValues),\n        y: singleItemOrArray(yValues)\n      });\n    }\n  }\n\n  updateAxisOptions(axis, options) {\n    const vertical = axis.options.vertical;\n    const axes = this.groupAxes(this.panes);\n    const index = (vertical ? axes.y : axes.x).indexOf(axis);\n    updateAxisOptions(this.options, index, vertical, options);\n    updateAxisOptions(this.originalOptions, index, vertical, options);\n  }\n\n  crosshairOptions(axis) {\n    // Stack the crosshair above the series points.\n    return Object.assign({}, axis.options.crosshair, {\n      zIndex: 0\n    });\n  }\n\n}\n\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n  const axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n  deepExtend(axisOptions, options);\n}\n\nsetDefaultOptions(HeatmapPlotArea, {\n  xAxis: {},\n  yAxis: {}\n});\ndeepExtend(HeatmapPlotArea.prototype, PlotAreaEventsMixin);\nexport default HeatmapPlotArea;","map":null,"metadata":{},"sourceType":"module"}