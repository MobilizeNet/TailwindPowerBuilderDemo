{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1128);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1128:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"data.odata\",\n        name: \"OData\",\n        category: \"framework\",\n        depends: [\"core\"],\n        hidden: true\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            extend = $.extend,\n            NEWLINE = \"\\r\\n\",\n            DOUBLELINE = \"\\r\\n\\r\\n\",\n            isFunction = kendo.isFunction,\n            odataFilters = {\n          eq: \"eq\",\n          neq: \"ne\",\n          gt: \"gt\",\n          gte: \"ge\",\n          lt: \"lt\",\n          lte: \"le\",\n          contains: \"substringof\",\n          doesnotcontain: \"substringof\",\n          endswith: \"endswith\",\n          startswith: \"startswith\",\n          isnull: \"eq\",\n          isnotnull: \"ne\",\n          isnullorempty: \"eq\",\n          isnotnullorempty: \"ne\",\n          isempty: \"eq\",\n          isnotempty: \"ne\"\n        },\n            odataFiltersVersionFour = extend({}, odataFilters, {\n          contains: \"contains\"\n        }),\n            mappers = {\n          pageSize: $.noop,\n          page: $.noop,\n          filter: function (params, filter, useVersionFour) {\n            if (filter) {\n              filter = toOdataFilter(filter, useVersionFour);\n\n              if (filter) {\n                params.$filter = filter;\n              }\n            }\n          },\n          sort: function (params, orderby) {\n            var expr = $.map(orderby, function (value) {\n              var order = value.field.replace(/\\./g, \"/\");\n\n              if (value.dir === \"desc\") {\n                order += \" desc\";\n              }\n\n              return order;\n            }).join(\",\");\n\n            if (expr) {\n              params.$orderby = expr;\n            }\n          },\n          skip: function (params, skip) {\n            if (skip) {\n              params.$skip = skip;\n            }\n          },\n          take: function (params, take) {\n            if (take) {\n              params.$top = take;\n            }\n          }\n        },\n            defaultDataType = {\n          read: {\n            dataType: \"jsonp\"\n          }\n        };\n\n        function toOdataFilter(filter, useOdataFour) {\n          var result = [],\n              logic = filter.logic || \"and\",\n              idx,\n              length,\n              field,\n              type,\n              format,\n              operator,\n              value,\n              ignoreCase,\n              filters = filter.filters;\n\n          for (idx = 0, length = filters.length; idx < length; idx++) {\n            filter = filters[idx];\n            field = filter.field;\n            value = filter.value;\n            operator = filter.operator;\n\n            if (filter.filters) {\n              filter = toOdataFilter(filter, useOdataFour);\n            } else {\n              ignoreCase = filter.ignoreCase;\n              field = field.replace(/\\./g, \"/\");\n              filter = odataFilters[operator];\n\n              if (useOdataFour) {\n                filter = odataFiltersVersionFour[operator];\n              }\n\n              if (operator === \"isnullorempty\") {\n                filter = kendo.format(\"{0} {1} null or {0} {1} ''\", field, filter);\n              } else if (operator === \"isnotnullorempty\") {\n                filter = kendo.format(\"{0} {1} null and {0} {1} ''\", field, filter);\n              } else if (operator === \"isnull\" || operator === \"isnotnull\") {\n                filter = kendo.format(\"{0} {1} null\", field, filter);\n              } else if (operator === \"isempty\" || operator === \"isnotempty\") {\n                filter = kendo.format(\"{0} {1} ''\", field, filter);\n              } else if (filter && value !== undefined) {\n                type = kendo.type(value);\n\n                if (type === \"string\") {\n                  format = \"'{1}'\";\n                  value = value.replace(/'/g, \"''\");\n\n                  if (ignoreCase === true) {\n                    field = \"tolower(\" + field + \")\";\n                  }\n                } else if (type === \"date\") {\n                  if (useOdataFour) {\n                    format = \"{1:yyyy-MM-ddTHH:mm:ss+00:00}\";\n                    value = kendo.timezone.apply(value, 'Etc/UTC');\n                  } else {\n                    format = \"datetime'{1:yyyy-MM-ddTHH:mm:ss}'\";\n                  }\n                } else {\n                  format = \"{1}\";\n                }\n\n                if (filter.length > 3) {\n                  if (filter !== \"substringof\") {\n                    format = \"{0}({2},\" + format + \")\";\n                  } else {\n                    format = \"{0}(\" + format + \",{2})\";\n\n                    if (operator === \"doesnotcontain\") {\n                      if (useOdataFour) {\n                        format = \"{0}({2},'{1}') eq -1\";\n                        filter = \"indexof\";\n                      } else {\n                        format += \" eq false\";\n                      }\n                    }\n                  }\n                } else {\n                  format = \"{2} {0} \" + format;\n                }\n\n                filter = kendo.format(format, filter, value, field);\n              }\n            }\n\n            result.push(filter);\n          }\n\n          filter = result.join(\" \" + logic + \" \");\n\n          if (result.length > 1) {\n            filter = \"(\" + filter + \")\";\n          }\n\n          return filter;\n        }\n\n        function stripMetadata(obj) {\n          for (var name in obj) {\n            if (name.indexOf(\"@odata\") === 0) {\n              delete obj[name];\n            }\n          }\n        }\n\n        function hex16() {\n          return Math.floor((1 + Math.random()) * 0x10000).toString(16).substr(1);\n        }\n\n        function createBoundary(prefix) {\n          return prefix + hex16() + '-' + hex16() + '-' + hex16();\n        }\n\n        function createDelimeter(boundary, close) {\n          var result = NEWLINE + \"--\" + boundary;\n\n          if (close) {\n            result += \"--\";\n          }\n\n          return result;\n        }\n\n        function createCommand(transport, item, httpVerb, command) {\n          var transportUrl = transport.options[command].url;\n          var commandPrefix = kendo.format(\"{0} \", httpVerb);\n\n          if (isFunction(transportUrl)) {\n            return commandPrefix + transportUrl(item);\n          } else {\n            return commandPrefix + transportUrl;\n          }\n        }\n\n        function getOperationHeader(changeset, changeId) {\n          var header = \"\";\n          header += createDelimeter(changeset, false);\n          header += NEWLINE + 'Content-Type: application/http';\n          header += NEWLINE + 'Content-Transfer-Encoding: binary';\n          header += NEWLINE + 'Content-ID: ' + changeId;\n          return header;\n        }\n\n        function getOperationContent(item) {\n          var content = \"\";\n          content += NEWLINE + \"Content-Type: application/json;odata=minimalmetadata\";\n          content += NEWLINE + \"Prefer: return=representation\";\n          content += DOUBLELINE + kendo.stringify(item);\n          return content;\n        }\n\n        function getOperations(collection, changeset, changeId, command, transport, skipContent) {\n          var requestBody = \"\";\n\n          for (var i = 0; i < collection.length; i++) {\n            requestBody += getOperationHeader(changeset, changeId);\n            requestBody += DOUBLELINE + createCommand(transport, collection[i], transport.options[command].type, command) + ' HTTP/1.1';\n\n            if (!skipContent) {\n              requestBody += getOperationContent(collection[i]);\n            }\n\n            requestBody += NEWLINE;\n            changeId++;\n          }\n\n          return requestBody;\n        }\n\n        function processCollection(colection, boundary, changeset, changeId, transport, command, skipContent) {\n          var requestBody = \"\";\n          requestBody += getBoundary(boundary, changeset);\n          requestBody += getOperations(colection, changeset, changeId, command, transport, skipContent);\n          requestBody += createDelimeter(changeset, true);\n          requestBody += NEWLINE;\n          return requestBody;\n        }\n\n        function getBoundary(boundary, changeset) {\n          var requestBody = \"\";\n          requestBody += \"--\" + boundary + NEWLINE;\n          requestBody += \"Content-Type: multipart/mixed; boundary=\" + changeset + NEWLINE;\n          return requestBody;\n        }\n\n        function createBatchRequest(transport, colections) {\n          var options = extend({}, transport.options.batch);\n          var boundary = createBoundary(\"sf_batch_\");\n          var requestBody = \"\";\n          var changeId = 0;\n          var batchURL = transport.options.batch.url;\n          var changeset = createBoundary(\"sf_changeset_\");\n          options.type = transport.options.batch.type;\n          options.url = isFunction(batchURL) ? batchURL() : batchURL;\n          options.headers = extend(options.headers || {}, {\n            \"Content-Type\": \"multipart/mixed; boundary=\" + boundary\n          });\n\n          if (colections.updated.length) {\n            requestBody += processCollection(colections.updated, boundary, changeset, changeId, transport, \"update\", false);\n            changeId += colections.updated.length;\n            changeset = createBoundary(\"sf_changeset_\");\n          }\n\n          if (colections.destroyed.length) {\n            requestBody += processCollection(colections.destroyed, boundary, changeset, changeId, transport, \"destroy\", true);\n            changeId += colections.destroyed.length;\n            changeset = createBoundary(\"sf_changeset_\");\n          }\n\n          if (colections.created.length) {\n            requestBody += processCollection(colections.created, boundary, changeset, changeId, transport, \"create\", false);\n          }\n\n          requestBody += createDelimeter(boundary, true);\n          options.data = requestBody;\n          return options;\n        }\n\n        function parseBatchResponse(responseText) {\n          var responseMarkers = responseText.match(/--changesetresponse_[a-z0-9-]+$/gm);\n          var markerIndex = 0;\n          var collections = [];\n          var changeBody;\n          var status;\n          var code;\n          var marker;\n          var jsonModel;\n          collections.push({\n            models: [],\n            passed: true\n          });\n\n          for (var i = 0; i < responseMarkers.length; i++) {\n            marker = responseMarkers[i];\n\n            if (marker.lastIndexOf('--', marker.length - 1)) {\n              if (i < responseMarkers.length - 1) {\n                collections.push({\n                  models: [],\n                  passed: true\n                });\n              }\n\n              continue;\n            }\n\n            if (!markerIndex) {\n              markerIndex = responseText.indexOf(marker);\n            } else {\n              markerIndex = responseText.indexOf(marker, markerIndex + marker.length);\n            }\n\n            changeBody = responseText.substring(markerIndex, responseText.indexOf(\"--\", markerIndex + 1));\n            status = changeBody.match(/^HTTP\\/1\\.\\d (\\d{3}) (.*)$/gm).pop();\n            code = kendo.parseFloat(status.match(/\\d{3}/g).pop());\n\n            if (code >= 200 && code <= 299) {\n              jsonModel = changeBody.match(/\\{.*\\}/gm);\n\n              if (jsonModel) {\n                collections[collections.length - 1].models.push(JSON.parse(jsonModel[0]));\n              }\n            } else {\n              collections[collections.length - 1].passed = false;\n            }\n          }\n\n          return collections;\n        }\n\n        extend(true, kendo.data, {\n          schemas: {\n            odata: {\n              type: \"json\",\n              data: function (data) {\n                return data.d.results || [data.d];\n              },\n              total: \"d.__count\"\n            }\n          },\n          transports: {\n            odata: {\n              read: {\n                cache: true,\n                // to prevent jQuery from adding cache buster\n                dataType: \"jsonp\",\n                jsonp: \"$callback\"\n              },\n              update: {\n                cache: true,\n                dataType: \"json\",\n                contentType: \"application/json\",\n                // to inform the server the the request body is JSON encoded\n                type: \"PUT\" // can be PUT or MERGE\n\n              },\n              create: {\n                cache: true,\n                dataType: \"json\",\n                contentType: \"application/json\",\n                type: \"POST\" // must be POST to create new entity\n\n              },\n              destroy: {\n                cache: true,\n                dataType: \"json\",\n                type: \"DELETE\"\n              },\n              parameterMap: function (options, type, useVersionFour) {\n                var params, value, option, dataType;\n                options = options || {};\n                type = type || \"read\";\n                dataType = (this.options || defaultDataType)[type];\n                dataType = dataType ? dataType.dataType : \"json\";\n\n                if (type === \"read\") {\n                  params = {\n                    $inlinecount: \"allpages\"\n                  };\n\n                  if (dataType != \"json\") {\n                    params.$format = \"json\";\n                  }\n\n                  for (option in options) {\n                    if (mappers[option]) {\n                      mappers[option](params, options[option], useVersionFour);\n                    } else {\n                      params[option] = options[option];\n                    }\n                  }\n                } else {\n                  if (dataType !== \"json\") {\n                    throw new Error(\"Only json dataType can be used for \" + type + \" operation.\");\n                  }\n\n                  if (type !== \"destroy\") {\n                    for (option in options) {\n                      value = options[option];\n\n                      if (typeof value === \"number\") {\n                        options[option] = value + \"\";\n                      }\n                    }\n\n                    params = kendo.stringify(options);\n                  }\n                }\n\n                return params;\n              }\n            }\n          }\n        });\n        extend(true, kendo.data, {\n          schemas: {\n            \"odata-v4\": {\n              type: \"json\",\n              data: function (data) {\n                if (Array.isArray(data)) {\n                  for (var i = 0; i < data.length; i++) {\n                    stripMetadata(data[i]);\n                  }\n\n                  return data;\n                } else {\n                  data = $.extend({}, data);\n                  stripMetadata(data);\n\n                  if (data.value) {\n                    return data.value;\n                  }\n\n                  return [data];\n                }\n              },\n              total: function (data) {\n                return data[\"@odata.count\"];\n              }\n            }\n          },\n          transports: {\n            \"odata-v4\": {\n              batch: {\n                type: \"POST\"\n              },\n              read: {\n                cache: true,\n                // to prevent jQuery from adding cache buster\n                dataType: \"json\"\n              },\n              update: {\n                cache: true,\n                dataType: \"json\",\n                contentType: \"application/json;IEEE754Compatible=true\",\n                // to inform the server the the request body is JSON encoded\n                type: \"PUT\" // can be PUT or MERGE\n\n              },\n              create: {\n                cache: true,\n                dataType: \"json\",\n                contentType: \"application/json;IEEE754Compatible=true\",\n                type: \"POST\" // must be POST to create new entity\n\n              },\n              destroy: {\n                cache: true,\n                dataType: \"json\",\n                type: \"DELETE\"\n              },\n              parameterMap: function (options, type) {\n                var result = kendo.data.transports.odata.parameterMap(options, type, true);\n\n                if (type == \"read\") {\n                  result.$count = true;\n                  delete result.$inlinecount;\n                }\n\n                if (result && result.$filter) {\n                  // Remove the single quotation marks around the GUID (OData v4).\n                  result.$filter = result.$filter.replace(/('[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}')/ig, function (x) {\n                    return x.substring(1, x.length - 1);\n                  });\n                }\n\n                return result;\n              },\n              submit: function (e) {\n                var that = this;\n                var options = createBatchRequest(that, e.data);\n                var collections = e.data;\n\n                if (!collections.updated.length && !collections.destroyed.length && !collections.created.length) {\n                  return;\n                }\n\n                $.ajax(extend(true, {}, {\n                  success: function (response) {\n                    var responses = parseBatchResponse(response);\n                    var index = 0;\n                    var current;\n\n                    if (collections.updated.length) {\n                      current = responses[index];\n\n                      if (current.passed) {\n                        // Pass either the obtained models or an empty array if only status codes are returned.\n                        e.success(current.models.length ? current.models : [], \"update\");\n                      }\n\n                      index++;\n                    }\n\n                    if (collections.destroyed.length) {\n                      current = responses[index];\n\n                      if (current.passed) {\n                        // For delete operations OData returns only status codes.\n                        // Passing empty array to datasource will force it to correctly remove the deleted items from the pristine collection.\n                        e.success([], \"destroy\");\n                      }\n\n                      index++;\n                    }\n\n                    if (collections.created.length) {\n                      current = responses[index];\n\n                      if (current.passed) {\n                        e.success(current.models, \"create\");\n                      }\n                    }\n                  },\n                  error: function (response, status, error) {\n                    e.error(response, status, error);\n                  }\n                }, options));\n              }\n            }\n          }\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}