{"ast":null,"code":"import { ChartElement, BoxElement, Title, Box } from '../core';\nimport { ChartPane } from './api-elements';\nimport ChartContainer from './chart-container';\nimport { PANE_RENDER } from './constants';\nimport { TOP, LEFT, X, Y } from '../common/constants';\nimport { append, deepExtend, isObject, last, setDefaultOptions } from '../common';\n\nclass Pane extends BoxElement {\n  constructor(options) {\n    super(options);\n    this.id = paneID();\n    this.createTitle();\n    this.content = new ChartElement();\n    this.chartContainer = new ChartContainer({}, this);\n    this.append(this.content);\n    this.axes = [];\n    this.charts = [];\n  }\n\n  createTitle() {\n    let titleOptions = this.options.title;\n\n    if (isObject(titleOptions)) {\n      titleOptions = deepExtend({}, titleOptions, {\n        align: titleOptions.position,\n        position: TOP\n      });\n    }\n\n    this.title = Title.buildTitle(titleOptions, Pane.prototype.options.title);\n\n    if (this.title) {\n      this.append(this.title);\n    }\n  }\n\n  appendAxis(axis) {\n    this.content.append(axis);\n    this.axes.push(axis);\n    axis.pane = this;\n  }\n\n  appendAxisAt(axis, pos) {\n    this.content.append(axis);\n    this.axes.splice(pos, 0, axis);\n    axis.pane = this;\n  }\n\n  appendChart(chart) {\n    if (this.chartContainer.parent !== this.content) {\n      this.content.append(this.chartContainer);\n    }\n\n    this.charts.push(chart);\n    this.chartContainer.append(chart);\n    chart.pane = this;\n  }\n\n  empty() {\n    const plotArea = this.parent;\n\n    if (plotArea) {\n      for (let i = 0; i < this.axes.length; i++) {\n        plotArea.removeAxis(this.axes[i]);\n      }\n\n      for (let i = 0; i < this.charts.length; i++) {\n        plotArea.removeChart(this.charts[i]);\n      }\n    }\n\n    this.axes = [];\n    this.charts = [];\n    this.content.destroy();\n    this.content.children = [];\n    this.chartContainer.children = [];\n  }\n\n  reflow(targetBox) {\n    // Content (such as charts) is rendered, but excluded from reflows\n    let content;\n\n    if (last(this.children) === this.content) {\n      content = this.children.pop();\n    }\n\n    super.reflow(targetBox);\n\n    if (content) {\n      this.children.push(content);\n    }\n\n    if (this.title) {\n      this.contentBox.y1 += this.title.box.height();\n    }\n  }\n\n  visualStyle() {\n    const style = super.visualStyle();\n    style.zIndex = -10;\n    return style;\n  }\n\n  renderComplete() {\n    if (this.options.visible) {\n      this.createGridLines();\n    }\n  }\n\n  stackRoot() {\n    return this;\n  }\n\n  clipRoot() {\n    return this;\n  }\n\n  createGridLines() {\n    const axes = this.axes;\n    const allAxes = axes.concat(this.parent.axes);\n    const vGridLines = [];\n    const hGridLines = []; // TODO\n    // Is full combination really necessary?\n\n    for (let i = 0; i < axes.length; i++) {\n      const axis = axes[i];\n      const vertical = axis.options.vertical;\n      const gridLines = vertical ? vGridLines : hGridLines;\n\n      for (let j = 0; j < allAxes.length; j++) {\n        if (gridLines.length === 0) {\n          const altAxis = allAxes[j];\n\n          if (vertical !== altAxis.options.vertical) {\n            append(gridLines, axis.createGridLines(altAxis));\n          }\n        }\n      }\n    }\n  }\n\n  refresh() {\n    this.visual.clear();\n    this.content.parent = null;\n    this.content.createGradient = this.createGradient.bind(this);\n    this.content.renderVisual();\n    this.content.parent = this;\n\n    if (this.title) {\n      this.visual.append(this.title.visual);\n    }\n\n    this.visual.append(this.content.visual);\n    this.renderComplete();\n    this.notifyRender();\n  }\n\n  chartsBox() {\n    const axes = this.axes;\n    const length = axes.length;\n    const chartsBox = new Box();\n\n    for (let idx = 0; idx < length; idx++) {\n      const axis = axes[idx];\n      const axisValueField = axis.options.vertical ? Y : X;\n      const lineBox = axis.lineBox();\n      chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\n      chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\n    }\n\n    if (chartsBox.x2 === 0) {\n      const allAxes = this.parent.axes;\n      const length = allAxes.length;\n\n      for (let idx = 0; idx < length; idx++) {\n        const axis = allAxes[idx];\n\n        if (!axis.options.vertical) {\n          const lineBox = axis.lineBox();\n          chartsBox.x1 = lineBox.x1;\n          chartsBox.x2 = lineBox.x2;\n        }\n      }\n    }\n\n    return chartsBox;\n  }\n\n  clipBox() {\n    return this.chartContainer.clipBox;\n  }\n\n  notifyRender() {\n    const service = this.getService();\n\n    if (service) {\n      service.notify(PANE_RENDER, {\n        pane: new ChartPane(this),\n        index: this.paneIndex,\n        name: this.options.name\n      });\n    }\n  }\n\n}\n\nlet ID = 1;\n\nfunction paneID() {\n  return \"pane\" + ID++;\n}\n\nPane.prototype.isStackRoot = true;\nsetDefaultOptions(Pane, {\n  zIndex: -1,\n  shrinkToFit: true,\n  title: {\n    align: LEFT\n  },\n  visible: true\n});\nexport default Pane;","map":null,"metadata":{},"sourceType":"module"}