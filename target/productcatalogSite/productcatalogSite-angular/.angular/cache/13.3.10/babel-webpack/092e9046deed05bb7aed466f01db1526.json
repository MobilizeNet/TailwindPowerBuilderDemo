{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1401);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1058:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.dom\");\n    /***/\n  },\n\n  /***/\n  1063:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data\");\n    /***/\n  },\n\n  /***/\n  1397:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.pivot.common\");\n    /***/\n  },\n\n  /***/\n  1401:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1397), __webpack_require__(1058), __webpack_require__(1063)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"pivotgrid\",\n        name: \"PivotGrid\",\n        category: \"web\",\n        description: \"The PivotGrid widget is a data summarization tool.\",\n        depends: [\"dom\", \"data\", \"data.xml\", \"sortable\", \"pivot.common\"],\n        features: [{\n          id: \"pivotgrid-configurator\",\n          name: \"Configurator\",\n          description: \"The PivotConfigurator widget allows the user to select data slices displayed in PivotGrid\",\n          depends: [\"pivot.configurator\"]\n        }, {\n          id: \"pivotgrid-filtering\",\n          name: \"Filtering\",\n          description: \"Support for filtering\",\n          depends: [\"pivot.fieldmenu\"]\n        }, {\n          id: \"pivotgrid-excel-export\",\n          name: \"Excel export\",\n          description: \"Export pivot grid data as Excel spreadsheet\",\n          depends: [\"ooxml\"]\n        }, {\n          id: \"pivotgrid-pdf-export\",\n          name: \"PDF export\",\n          description: \"Export pivot grid data as PDF\",\n          depends: [\"pdf\", \"drawing\"]\n        }, {\n          id: \"mobile-scroller\",\n          name: \"Mobile scroller\",\n          description: \"Support for kinetic scrolling in mobile device\",\n          depends: [\"mobile.scroller\"]\n        }]\n      };\n      /*jshint eqnull: true, laxbreak:true */\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            ui = kendo.ui,\n            Class = kendo.Class,\n            Comparer = kendo.data.Comparer,\n            Widget = ui.Widget,\n            DataSource = kendo.data.DataSource,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            common = window.kendo.pivotgrid.common,\n            fetchDiscover = common.fetchDiscover,\n            normalizeFilter = kendo.data.Query.normalizeFilter,\n            normalizeSort = kendo.data.Query.normalizeSort,\n            toString = {}.toString,\n            identity = function (o) {\n          return o;\n        },\n            map = $.map,\n            extend = $.extend,\n            isFunction = kendo.isFunction,\n            fetchData = common.fetchData,\n            createDataState = common.createDataState,\n            toColumns = common.toColumns,\n            toRows = common.toRows,\n            toTree = common.toTree,\n            toData = common.toData,\n            headersReducer = common.headersReducer,\n            RESIZE = \"resize\",\n            READ = \"read\",\n            CHANGE = \"change\",\n            ERROR = \"error\",\n            REQUESTSTART = \"requestStart\",\n            PROGRESS = \"progress\",\n            REQUESTEND = \"requestEnd\",\n            MEASURES = \"Measures\",\n            STATERESET = \"stateReset\",\n            AUTO = \"auto\",\n            DIV = \"<div></div>\",\n            NS = \".kendoPivotGrid\",\n            ROW_TOTAL_KEY = \"__row_total__\",\n            DATABINDING = \"dataBinding\",\n            DATABOUND = \"dataBound\",\n            EXPANDMEMBER = \"expandMember\",\n            HEADERTEMPLATE = '<th data-key=\"#:key#\" class=\"#:headerClass#\" #if (colspan) {#colspan=\"#:colspan#\"#}# #if (rowspan) {#rowspan=\"#:rowspan#\"#}#>' + '#if (expandable) {# <span class=\"k-icon k-i-arrow-chevron-#:iconClass# k-color-inherit\" role=\"presentation\"></span>#}#' + '</th>',\n            COLLAPSEMEMBER = \"collapseMember\",\n            STATE_EXPANDED = \"k-i-collapse\",\n            STATE_COLLAPSED = \"k-i-expand\",\n            HEADER_TEMPLATE = \"<span>#: data.member.caption || data.member.name #</span>\",\n            KPISTATUS_TEMPLATE = '<span class=\"k-icon k-i-kpi-status-#=data.dataItem.value > 0 ? \\\"open\\\" : data.dataItem.value < 0 ? \\\"deny\\\" : \\\"hold\\\"#\" title=\"#:data.dataItem.value#\"></span>',\n            KPITREND_TEMPLATE = '<span class=\"k-icon k-i-kpi-trend-#=data.dataItem.value > 0 ? \\\"increase\\\" : data.dataItem.value < 0 ? \\\"decrease\\\" : \\\"equal\\\"#\" title=\"#:data.dataItem.value#\"></span>',\n            DATACELL_TEMPLATE = '#= data.dataItem ? kendo.htmlEncode(data.dataItem.fmtValue || data.dataItem.value) || \"&nbsp;\" : \"&nbsp;\" #',\n            LAYOUT_TABLE = '<table class=\"k-pivot-layout\">' + '<tr>' + '<td>' + '<div class=\"k-pivot-rowheaders\"></div>' + '</td>' + '<td>' + '<div class=\"k-pivot-table\"></div>' + '</td>' + '</tr>' + '</table>';\n\n        var AXIS_ROWS = \"rows\";\n        var AXIS_COLUMNS = \"columns\";\n\n        function normalizeMeasures(measure) {\n          var descriptor = typeof measure === \"string\" ? [{\n            name: measure\n          }] : measure;\n          var descriptors = toString.call(descriptor) === \"[object Array]\" ? descriptor : descriptor !== undefined ? [descriptor] : [];\n          return map(descriptors, function (d) {\n            if (typeof d === \"string\") {\n              return {\n                name: d\n              };\n            }\n\n            return {\n              name: d.name,\n              type: d.type\n            };\n          });\n        }\n\n        function normalizeMembers(member) {\n          var descriptor = typeof member === \"string\" ? [{\n            name: [member],\n            expand: false\n          }] : member;\n          var descriptors = toString.call(descriptor) === \"[object Array]\" ? descriptor : descriptor !== undefined ? [descriptor] : [];\n          return map(descriptors, function (d) {\n            if (typeof d === \"string\") {\n              return {\n                name: [d],\n                expand: false\n              };\n            }\n\n            return {\n              name: toString.call(d.name) === \"[object Array]\" ? d.name.slice() : [d.name],\n              expand: d.expand\n            };\n          });\n        }\n\n        function normalizeName(name) {\n          if (name.indexOf(\" \") !== -1) {\n            name = '[\"' + name + '\"]';\n          }\n\n          return name;\n        }\n\n        function accumulateMembers(accumulator, rootTuple, tuple, level) {\n          var idx, length;\n          var children;\n          var member;\n\n          if (!tuple) {\n            tuple = rootTuple;\n          }\n\n          if (!level) {\n            level = 0;\n          }\n\n          member = tuple.members[level];\n\n          if (!member || member.measure) {\n            //return if no member or measure\n            return;\n          }\n\n          children = member.children;\n          length = children.length;\n\n          if (tuple === rootTuple) {\n            accumulator[kendo.stringify([member.name])] = !!length;\n          } else if (length) {\n            accumulator[kendo.stringify(buildPath(tuple, level))] = true;\n          }\n\n          if (length) {\n            for (idx = 0; idx < length; idx++) {\n              accumulateMembers(accumulator, rootTuple, children[idx], level);\n            }\n          }\n\n          accumulateMembers(accumulator, rootTuple, tuple, level + 1);\n        }\n\n        function descriptorsForAxes(tuples) {\n          var result = {};\n\n          if (tuples.length) {\n            accumulateMembers(result, tuples[0]);\n          }\n\n          var descriptors = [];\n\n          for (var k in result) {\n            descriptors.push({\n              name: JSON.parse(k),\n              expand: result[k]\n            });\n          }\n\n          return descriptors;\n        }\n\n        function addMissingPathMembers(members, axis) {\n          var tuples = axis.tuples || [];\n          var firstTuple = tuples[0];\n\n          if (firstTuple && members.length < firstTuple.members.length) {\n            var tupleMembers = firstTuple.members;\n\n            for (var idx = 0; idx < tupleMembers.length; idx++) {\n              if (tupleMembers[idx].measure) {\n                continue;\n              }\n\n              var found = false;\n\n              for (var j = 0; j < members.length; j++) {\n                if (getName(members[j]).indexOf(tupleMembers[idx].hierarchy) === 0) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if (!found) {\n                members.push({\n                  name: [tupleMembers[idx].name],\n                  expand: false\n                }); //calling normalize here to make name from string to array\n              }\n            }\n          }\n        }\n\n        function tupleToDescriptors(tuple) {\n          var result = [];\n          var members = tuple.members;\n\n          for (var idx = 0; idx < members.length; idx++) {\n            if (members[idx].measure) {\n              continue;\n            } //make tuple name an array\n\n\n            result.push({\n              name: [members[idx].name],\n              expand: members[idx].children.length > 0\n            });\n          }\n\n          return result;\n        }\n\n        function descriptorsForMembers(axis, members, measures) {\n          axis = axis || {};\n          addMissingPathMembers(members, axis);\n\n          if (measures.length > 1) {\n            members.push({\n              name: MEASURES,\n              measure: true,\n              children: normalizeMembers(measures)\n            });\n          }\n\n          var tupletoSearch = {\n            members: members\n          };\n\n          if (axis.tuples) {\n            var result = findExistingTuple(axis.tuples, tupletoSearch);\n\n            if (result.tuple) {\n              members = tupleToDescriptors(result.tuple);\n            }\n          }\n\n          return members;\n        }\n\n        function createAggregateGetter(m) {\n          var measureGetter = kendo.getter(m.field, true);\n          return function (aggregatorContext, state) {\n            return m.aggregate(measureGetter(aggregatorContext.dataItem), state, aggregatorContext);\n          };\n        }\n\n        function isNumber(val) {\n          return typeof val === \"number\" && !isNaN(val);\n        }\n\n        function isDate(val) {\n          return val && val.getTime;\n        }\n\n        function getScollWidth() {\n          var scrollbar = 0;\n          var div;\n\n          if (document && document.createElement) {\n            div = document.createElement('div');\n            div.style.cssText = 'overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block';\n            div.innerHTML = '&nbsp;';\n            document.body.appendChild(div);\n            scrollbar = div.offsetWidth - div.scrollWidth;\n            document.body.removeChild(div);\n          }\n\n          return scrollbar;\n        }\n\n        var functions = {\n          sum: function (value, state) {\n            var accumulator = state.accumulator;\n\n            if (!isNumber(accumulator)) {\n              accumulator = value;\n            } else if (isNumber(value)) {\n              accumulator += value;\n            }\n\n            return accumulator;\n          },\n          count: function (value, state) {\n            return (state.accumulator || 0) + 1;\n          },\n          average: {\n            aggregate: function (value, state) {\n              var accumulator = state.accumulator;\n\n              if (state.count === undefined) {\n                state.count = 0;\n              }\n\n              if (!isNumber(accumulator)) {\n                accumulator = value;\n              } else if (isNumber(value)) {\n                accumulator += value;\n              }\n\n              if (isNumber(value)) {\n                state.count++;\n              }\n\n              return accumulator;\n            },\n            result: function (state) {\n              var accumulator = state.accumulator;\n\n              if (isNumber(accumulator)) {\n                accumulator = accumulator / state.count;\n              }\n\n              return accumulator;\n            }\n          },\n          max: function (value, state) {\n            var accumulator = state.accumulator;\n\n            if (!isNumber(accumulator) && !isDate(accumulator)) {\n              accumulator = value;\n            }\n\n            if (accumulator < value && (isNumber(value) || isDate(value))) {\n              accumulator = value;\n            }\n\n            return accumulator;\n          },\n          min: function (value, state) {\n            var accumulator = state.accumulator;\n\n            if (!isNumber(accumulator) && !isDate(accumulator)) {\n              accumulator = value;\n            }\n\n            if (accumulator > value && (isNumber(value) || isDate(value))) {\n              accumulator = value;\n            }\n\n            return accumulator;\n          }\n        };\n        var PivotCubeBuilder = Class.extend({\n          init: function (options) {\n            this.options = extend({}, this.options, options);\n            this.dimensions = this._normalizeDescriptors(\"field\", this.options.dimensions);\n            this.measures = this._normalizeDescriptors(\"name\", this.options.measures);\n          },\n          _normalizeDescriptors: function (keyField, descriptors) {\n            descriptors = descriptors || {};\n            var fields = {};\n            var field;\n\n            if (toString.call(descriptors) === \"[object Array]\") {\n              for (var idx = 0, length = descriptors.length; idx < length; idx++) {\n                field = descriptors[idx];\n\n                if (typeof field === \"string\") {\n                  fields[field] = {};\n                } else if (field[keyField]) {\n                  fields[field[keyField]] = field;\n                }\n              }\n\n              descriptors = fields;\n            }\n\n            return descriptors;\n          },\n          _rootTuples: function (rootNames, measureAggregators) {\n            var aggregatorsLength = measureAggregators.length || 1;\n            var dimensionsSchema = this.dimensions || [];\n            var root, name, parts;\n            var measureIdx = 0;\n            var idx;\n            var rootNamesLength = rootNames.length;\n            var result = [];\n            var keys = [];\n\n            if (rootNamesLength || measureAggregators.length) {\n              for (measureIdx = 0; measureIdx < aggregatorsLength; measureIdx++) {\n                root = {\n                  members: []\n                };\n\n                for (idx = 0; idx < rootNamesLength; idx++) {\n                  name = rootNames[idx];\n                  parts = name.split(\"&\");\n                  root.members[root.members.length] = {\n                    children: [],\n                    caption: (dimensionsSchema[name] || {}).caption || \"All\",\n                    name: name,\n                    levelName: name,\n                    levelNum: \"0\",\n                    hasChildren: true,\n                    parentName: parts.length > 1 ? parts[0] : undefined,\n                    hierarchy: name\n                  };\n                }\n\n                if (aggregatorsLength > 1) {\n                  root.members[root.members.length] = {\n                    children: [],\n                    caption: measureAggregators[measureIdx].caption,\n                    name: measureAggregators[measureIdx].descriptor.name,\n                    levelName: \"MEASURES\",\n                    levelNum: \"0\",\n                    hasChildren: false,\n                    parentName: undefined,\n                    hierarchy: \"MEASURES\"\n                  };\n                }\n\n                result[result.length] = root;\n              }\n\n              keys.push(ROW_TOTAL_KEY);\n            }\n\n            return {\n              keys: keys,\n              tuples: result\n            };\n          },\n          _sortMap: function (map, sortDescriptors) {\n            var sortedMaps = [];\n            var sortTree = [];\n            var flattenTree = [];\n            var mapItem;\n            var key;\n\n            for (key in map) {\n              if (!map[key].directParentName) {\n                sortTree.push($.extend({}, {\n                  name: key,\n                  parentName: map[key].parentName\n                }));\n              }\n            } //if there are no root this means that something is expanding\n            //and we should only sort that part of the tree\n\n\n            if (!sortTree.length) {\n              for (key in map) {\n                sortTree.push($.extend({}, {\n                  name: key,\n                  parentName: map[key].parentName\n                }));\n              }\n            }\n\n            fillSortTree(sortTree, map); // fill tree recursive\n\n            for (var i = 0; i < sortDescriptors.length; i++) {\n              sortItemsTree(sortDescriptors[i].field.split(\".\").pop(), sortTree, Comparer.create({\n                field: \"name\",\n                dir: sortDescriptors[i].dir\n              }));\n            }\n\n            flattenTree = flatColumns(sortTree); //we need to flatten the structure so the tuples can build correctly\n\n            for (var j = 0; j < flattenTree.length; j++) {\n              mapItem = map[flattenTree[j].name];\n              mapItem.index = j;\n              sortedMaps[j] = mapItem;\n            }\n\n            return sortedMaps;\n          },\n          _expandedTuples: function (map, expanded, measureAggregators, sortDescriptors) {\n            var aggregatorsLength = measureAggregators.length || 1;\n            var dimensionsSchema = this.dimensions || [];\n            var measureIdx;\n            var tuple;\n            var key;\n            var mapItem;\n            var current;\n            var currentKeys;\n            var accumulator = [];\n            var accumulatorKeys = [];\n            var memberInfo;\n            var expandedNames;\n            var parts;\n            var name;\n            var idx;\n\n            if (sortDescriptors && sortDescriptors.length && !$.isEmptyObject(map)) {\n              map = this._sortMap(map, sortDescriptors);\n            }\n\n            for (key in map) {\n              mapItem = map[key];\n              memberInfo = this._findExpandedMember(expanded, mapItem.uniquePath);\n              current = accumulator[memberInfo.index] || [];\n              currentKeys = accumulatorKeys[memberInfo.index] || [];\n              expandedNames = memberInfo.member.names;\n\n              for (measureIdx = 0; measureIdx < aggregatorsLength; measureIdx++) {\n                tuple = {\n                  members: []\n                };\n\n                for (idx = 0; idx < expandedNames.length; idx++) {\n                  if (idx === memberInfo.member.expandedIdx) {\n                    tuple.members[tuple.members.length] = {\n                      children: [],\n                      caption: mapItem.value,\n                      name: mapItem.name,\n                      hasChildren: false,\n                      levelNum: 1,\n                      levelName: mapItem.parentName + mapItem.name,\n                      parentName: mapItem.parentName,\n                      hierarchy: mapItem.parentName + mapItem.name\n                    };\n\n                    if (measureIdx === 0) {\n                      currentKeys.push(buildPath(tuple, idx).join(\"\"));\n                    }\n                  } else {\n                    name = expandedNames[idx];\n                    parts = name.split(\"&\");\n                    tuple.members[tuple.members.length] = {\n                      children: [],\n                      caption: (dimensionsSchema[name] || {}).caption || \"All\",\n                      name: name,\n                      levelName: name,\n                      levelNum: \"0\",\n                      hasChildren: true,\n                      parentName: parts.length > 1 ? parts[0] : undefined,\n                      hierarchy: name\n                    };\n                  }\n                }\n\n                if (aggregatorsLength > 1) {\n                  tuple.members[tuple.members.length] = {\n                    children: [],\n                    caption: measureAggregators[measureIdx].caption,\n                    name: measureAggregators[measureIdx].descriptor.name,\n                    levelName: \"MEASURES\",\n                    levelNum: \"0\",\n                    hasChildren: true,\n                    parentName: undefined,\n                    hierarchy: \"MEASURES\"\n                  };\n                }\n\n                current[current.length] = tuple;\n              }\n\n              accumulator[memberInfo.index] = current;\n              accumulatorKeys[memberInfo.index] = currentKeys;\n            }\n\n            return {\n              keys: accumulatorKeys,\n              tuples: accumulator\n            };\n          },\n          _findExpandedMember: function (members, parentName) {\n            for (var idx = 0; idx < members.length; idx++) {\n              if (members[idx].uniquePath === parentName) {\n                return {\n                  member: members[idx],\n                  index: idx\n                };\n              }\n            }\n          },\n          _asTuples: function (map, descriptor, measureAggregators, sortDescriptors) {\n            measureAggregators = measureAggregators || [];\n\n            var rootInfo = this._rootTuples(descriptor.root, measureAggregators);\n\n            var expandedInfo = this._expandedTuples(map, descriptor.expanded, measureAggregators, sortDescriptors);\n\n            return {\n              keys: [].concat.apply(rootInfo.keys, expandedInfo.keys),\n              tuples: [].concat.apply(rootInfo.tuples, expandedInfo.tuples)\n            };\n          },\n          _measuresInfo: function (measures, rowAxis) {\n            var idx = 0;\n            var length = measures && measures.length;\n            var aggregateNames = [];\n            var resultFuncs = {};\n            var formats = {};\n            var descriptors = this.measures || {};\n            var measure;\n            var name;\n\n            for (; idx < length; idx++) {\n              name = measures[idx].descriptor.name;\n              measure = descriptors[name] || {};\n              aggregateNames.push(name);\n\n              if (measure.result) {\n                resultFuncs[name] = measure.result;\n              }\n\n              if (measure.format) {\n                formats[name] = measure.format;\n              }\n            }\n\n            return {\n              names: aggregateNames,\n              formats: formats,\n              resultFuncs: resultFuncs,\n              rowAxis: rowAxis\n            };\n          },\n          _toDataArray: function (map, measuresInfo, rowKeys, columnKeys) {\n            var result = [];\n            var aggregates;\n            var name, i, j, k, n;\n            var row, column, columnKey;\n            var rowMeasureNamesLength = 1;\n            var rowMeasureNames = [];\n            var columnMeasureNames;\n            var rowLength = rowKeys.length || 1;\n            var columnLength = columnKeys.length || 1;\n\n            if (measuresInfo.rowAxis) {\n              rowMeasureNames = measuresInfo.names;\n              rowMeasureNamesLength = rowMeasureNames.length;\n            } else {\n              columnMeasureNames = measuresInfo.names;\n            }\n\n            for (i = 0; i < rowLength; i++) {\n              row = map[rowKeys[i] || ROW_TOTAL_KEY];\n\n              for (n = 0; n < rowMeasureNamesLength; n++) {\n                if (measuresInfo.rowAxis) {\n                  columnMeasureNames = [rowMeasureNames[n]];\n                }\n\n                for (j = 0; j < columnLength; j++) {\n                  columnKey = columnKeys[j] || ROW_TOTAL_KEY;\n                  column = row.items[columnKey];\n\n                  if (columnKey === ROW_TOTAL_KEY) {\n                    aggregates = row.aggregates;\n                  } else {\n                    aggregates = column ? column.aggregates : {};\n                  }\n\n                  for (k = 0; k < columnMeasureNames.length; k++) {\n                    name = columnMeasureNames[k];\n\n                    this._addData(result, aggregates[name], measuresInfo.formats[name], measuresInfo.resultFuncs[name]);\n                  }\n                }\n              }\n            }\n\n            return result;\n          },\n          _addData: function (result, value, format, resultFunc) {\n            var fmtValue = \"\";\n            var ordinal;\n\n            if (value) {\n              value = resultFunc ? resultFunc(value) : value.accumulator;\n              fmtValue = format ? kendo.format(format, value) : value;\n            }\n\n            ordinal = result.length;\n            result[ordinal] = {\n              ordinal: ordinal,\n              value: value || \"\",\n              fmtValue: fmtValue\n            };\n          },\n          _matchDescriptors: function (dataItem, descriptor, getters) {\n            var parts;\n            var parentField;\n            var expectedValue;\n            var names = descriptor.names;\n            var idx = descriptor.expandedIdx;\n            var value;\n\n            while (idx > 0) {\n              parts = names[--idx].split(\"&\");\n\n              if (parts.length > 1) {\n                parentField = parts[0];\n                expectedValue = parts[1];\n                value = getters[parentField](dataItem);\n                value = value !== undefined && value !== null ? value.toString() : value;\n\n                if (value != expectedValue) {\n                  return false;\n                }\n              }\n            }\n\n            return true;\n          },\n          _calculateAggregate: function (measureAggregators, aggregatorContext, totalItem) {\n            var result = {};\n            var state;\n            var name;\n\n            for (var measureIdx = 0; measureIdx < measureAggregators.length; measureIdx++) {\n              name = measureAggregators[measureIdx].descriptor.name;\n              state = totalItem.aggregates[name] || {};\n              state.accumulator = measureAggregators[measureIdx].aggregator(aggregatorContext, state);\n              result[name] = state;\n            }\n\n            return result;\n          },\n          _processColumns: function (measureAggregators, descriptors, getters, columns, aggregatorContext, rowTotal, state, updateColumn) {\n            var value;\n            var descriptor;\n            var column;\n            var totalItem;\n            var key, name, parentName, path;\n            var dataItem = aggregatorContext.dataItem;\n            var idx = 0;\n\n            for (; idx < descriptors.length; idx++) {\n              descriptor = descriptors[idx]; //checks whether the dataItem is relevant to the descriptors\n\n              if (!this._matchDescriptors(dataItem, descriptor, getters)) {\n                continue;\n              }\n\n              path = descriptor.names.slice(0, descriptor.expandedIdx).join(\"\");\n              name = descriptor.names[descriptor.expandedIdx];\n              value = getters[name](dataItem);\n              value = value !== undefined && value !== null ? value.toString() : value;\n              parentName = name;\n              name = name + \"&\" + value;\n              key = path + name;\n              column = columns[key] || {\n                index: state.columnIndex,\n                parentName: parentName,\n                name: name,\n                directParentName: path.indexOf(\"&\") !== -1 ? path : \"\",\n                uniquePath: path + parentName,\n                childrenMap: {},\n                value: value\n              };\n\n              if (path && columns[path] && !columns[path].childrenMap[path + parentName + \"&\" + value]) {\n                columns[path].childrenMap[path + parentName + \"&\" + value] = true;\n              }\n\n              totalItem = rowTotal.items[key] || {\n                aggregates: {}\n              };\n              rowTotal.items[key] = {\n                index: column.index,\n                aggregates: this._calculateAggregate(measureAggregators, aggregatorContext, totalItem)\n              };\n\n              if (updateColumn) {\n                if (!columns[key]) {\n                  state.columnIndex++;\n                }\n\n                columns[key] = column;\n              }\n            }\n          },\n          _measureAggregators: function (options) {\n            var measureDescriptors = options.measures || [];\n            var measures = this.measures || {};\n            var aggregators = [];\n            var descriptor, measure, idx, length;\n            var defaultAggregate, aggregate;\n\n            if (measureDescriptors.length) {\n              for (idx = 0, length = measureDescriptors.length; idx < length; idx++) {\n                descriptor = measureDescriptors[idx];\n                measure = measures[descriptor.name];\n                defaultAggregate = null;\n\n                if (measure) {\n                  aggregate = measure.aggregate;\n\n                  if (typeof aggregate === \"string\") {\n                    defaultAggregate = functions[aggregate.toLowerCase()];\n\n                    if (!defaultAggregate) {\n                      throw new Error(\"There is no such aggregate function\");\n                    }\n\n                    measure.aggregate = defaultAggregate.aggregate || defaultAggregate;\n                    measure.result = defaultAggregate.result;\n                  }\n\n                  aggregators.push({\n                    descriptor: descriptor,\n                    caption: measure.caption,\n                    result: measure.result,\n                    aggregator: createAggregateGetter(measure)\n                  });\n                }\n              }\n            } else {\n              aggregators.push({\n                descriptor: {\n                  name: \"default\"\n                },\n                caption: \"default\",\n                aggregator: function () {\n                  return 1;\n                }\n              });\n            }\n\n            return aggregators;\n          },\n          _buildGetters: function (names) {\n            var result = {};\n            var parts;\n            var name;\n\n            for (var idx = 0; idx < names.length; idx++) {\n              name = names[idx];\n              parts = name.split(\"&\");\n\n              if (parts.length > 1) {\n                result[parts[0]] = kendo.getter(parts[0], true);\n              } else {\n                result[name] = kendo.getter(normalizeName(name), true);\n              }\n            }\n\n            return result;\n          },\n          _parseDescriptors: function (descriptors) {\n            var parsedDescriptors = parseDescriptors(descriptors);\n            var rootNames = getRootNames(parsedDescriptors.root);\n            var expanded = parsedDescriptors.expanded;\n            var result = [];\n\n            for (var idx = 0; idx < expanded.length; idx++) {\n              result.push(mapNames(expanded[idx].name, rootNames));\n            }\n\n            return {\n              root: rootNames,\n              expanded: result\n            };\n          },\n          _filter: function (data, filter) {\n            if (!filter) {\n              return data;\n            }\n\n            var expr;\n            var idx = 0;\n            var filters = filter.filters;\n\n            for (; idx < filters.length; idx++) {\n              expr = filters[idx];\n\n              if (expr.operator === \"in\") {\n                filters[idx] = this._normalizeFilter(expr);\n              }\n            }\n\n            return new kendo.data.Query(data).filter(filter).data;\n          },\n          _normalizeFilter: function (filter) {\n            var value = filter.value.split(\",\");\n            var result = [];\n\n            if (!value.length) {\n              return value;\n            }\n\n            for (var idx = 0; idx < value.length; idx++) {\n              result.push({\n                field: filter.field,\n                operator: \"eq\",\n                value: value[idx]\n              });\n            }\n\n            return {\n              logic: \"or\",\n              filters: result\n            };\n          },\n          process: function (data, options) {\n            data = data || [];\n            options = options || {};\n            data = this._filter(data, options.filter);\n            var measures = options.measures || [];\n            var measuresRowAxis = options.measuresAxis === \"rows\";\n            var columnDescriptors = options.columns || [];\n            var rowDescriptors = options.rows || [];\n\n            if (!columnDescriptors.length && rowDescriptors.length && (!measures.length || measures.length && measuresRowAxis)) {\n              columnDescriptors = rowDescriptors;\n              rowDescriptors = [];\n              measuresRowAxis = false;\n            }\n\n            if (!columnDescriptors.length && !rowDescriptors.length) {\n              measuresRowAxis = false;\n            }\n\n            if (!columnDescriptors.length && measures.length) {\n              columnDescriptors = normalizeMembers(options.measures);\n            }\n\n            columnDescriptors = this._parseDescriptors(columnDescriptors);\n            rowDescriptors = this._parseDescriptors(rowDescriptors);\n            var aggregatedData = {};\n            var columns = {};\n            var rows = {};\n            var rowValue;\n            var state = {\n              columnIndex: 0\n            };\n\n            var measureAggregators = this._measureAggregators(options);\n\n            var columnGetters = this._buildGetters(columnDescriptors.root);\n\n            var rowGetters = this._buildGetters(rowDescriptors.root);\n\n            var processed = false;\n            var expandedColumns = columnDescriptors.expanded;\n            var expandedRows = rowDescriptors.expanded;\n            var dataItem;\n            var aggregatorContext;\n            var hasExpandedRows = expandedRows.length !== 0;\n            var rowIdx, rowDescriptor, rowName, rowTotal;\n            var key, path, parentName, value;\n            var columnsInfo, rowsInfo;\n            var length = data.length;\n            var idx = 0;\n\n            if (columnDescriptors.root.length || rowDescriptors.root.length) {\n              processed = true;\n\n              for (idx = 0; idx < length; idx++) {\n                dataItem = data[idx];\n                aggregatorContext = {\n                  dataItem: dataItem,\n                  index: idx\n                };\n                rowTotal = aggregatedData[ROW_TOTAL_KEY] || {\n                  items: {},\n                  aggregates: {}\n                };\n\n                this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, rowTotal, state, !hasExpandedRows);\n\n                rowTotal.aggregates = this._calculateAggregate(measureAggregators, aggregatorContext, rowTotal);\n                aggregatedData[ROW_TOTAL_KEY] = rowTotal;\n\n                for (rowIdx = 0; rowIdx < expandedRows.length; rowIdx++) {\n                  rowDescriptor = expandedRows[rowIdx];\n\n                  if (!this._matchDescriptors(dataItem, rowDescriptor, rowGetters)) {\n                    this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, {\n                      items: {},\n                      aggregates: {}\n                    }, state, true);\n\n                    continue;\n                  }\n\n                  path = rowDescriptor.names.slice(0, rowDescriptor.expandedIdx).join(\"\");\n                  rowName = rowDescriptor.names[rowDescriptor.expandedIdx];\n                  parentName = rowName;\n                  rowValue = rowGetters[rowName](dataItem);\n                  rowValue = rowValue !== undefined ? rowValue.toString() : rowValue;\n                  rowName = rowName + \"&\" + rowValue;\n                  key = path + rowName;\n                  rows[key] = {\n                    uniquePath: path + parentName,\n                    parentName: parentName,\n                    name: rowName,\n                    value: rowValue\n                  };\n                  value = aggregatedData[key] || {\n                    items: {},\n                    aggregates: {}\n                  };\n\n                  this._processColumns(measureAggregators, expandedColumns, columnGetters, columns, aggregatorContext, value, state, true);\n\n                  value.aggregates = this._calculateAggregate(measureAggregators, aggregatorContext, value);\n                  aggregatedData[key] = value;\n                }\n              }\n            }\n\n            if (processed && length) {\n              if (measureAggregators.length > 1 && (!options.columns || !options.columns.length)) {\n                columnDescriptors = {\n                  root: [],\n                  expanded: []\n                };\n              }\n\n              columnsInfo = this._asTuples(columns, columnDescriptors, measuresRowAxis ? [] : measureAggregators, options.sort ? options.sort : []);\n              rowsInfo = this._asTuples(rows, rowDescriptors, measuresRowAxis ? measureAggregators : [], options.sort ? options.sort : []);\n              columns = columnsInfo.tuples;\n              rows = rowsInfo.tuples;\n              aggregatedData = this._toDataArray(aggregatedData, this._measuresInfo(measureAggregators, measuresRowAxis), rowsInfo.keys, columnsInfo.keys);\n            } else {\n              aggregatedData = columns = rows = [];\n            }\n\n            return {\n              axes: {\n                columns: {\n                  tuples: columns\n                },\n                rows: {\n                  tuples: rows\n                }\n              },\n              data: aggregatedData\n            };\n          }\n        });\n        var PivotTransport = Class.extend({\n          init: function (options, transport) {\n            this.transport = transport;\n            this.options = transport.options || {};\n\n            if (!this.transport.discover) {\n              if (isFunction(options.discover)) {\n                this.discover = options.discover;\n              }\n            }\n          },\n          read: function (options) {\n            return this.transport.read(options);\n          },\n          update: function (options) {\n            return this.transport.update(options);\n          },\n          create: function (options) {\n            return this.transport.create(options);\n          },\n          destroy: function (options) {\n            return this.transport.destroy(options);\n          },\n          discover: function (options) {\n            if (this.transport.discover) {\n              return this.transport.discover(options);\n            }\n\n            options.success({});\n          },\n          catalog: function (val) {\n            var options = this.options || {};\n\n            if (val === undefined) {\n              return (options.connection || {}).catalog;\n            }\n\n            var connection = options.connection || {};\n            connection.catalog = val;\n            this.options.connection = connection;\n            $.extend(this.transport.options, {\n              connection: connection\n            });\n          },\n          cube: function (val) {\n            var options = this.options || {};\n\n            if (val === undefined) {\n              return (options.connection || {}).cube;\n            }\n\n            var connection = options.connection || {};\n            connection.cube = val;\n            this.options.connection = connection;\n            extend(true, this.transport.options, {\n              connection: connection\n            });\n          }\n        });\n        var PivotDataSourceV2 = DataSource.extend({\n          init: function (options) {\n            DataSource.fn.init.call(this, extend(true, {}, {//schema: schema\n            }, options));\n            var transportOptions = this.options.transport || {};\n\n            if ((this.options.type || \"xmla\").toLowerCase() === \"xmla\") {\n              this._online = true;\n              this.transport = new XmlaTransportV2(transportOptions);\n            }\n\n            this._columns = normalizeMembers(this.options.columns);\n            this._rows = normalizeMembers(this.options.rows);\n            var measures = this.options.measures || [];\n\n            if (toString.call(measures) === \"[object Object]\") {\n              this._measuresAxis = measures.axis || \"columns\";\n              measures = measures.values || [];\n            }\n\n            this._measures = normalizeMeasures(measures);\n          },\n          options: {\n            serverSorting: true,\n            serverPaging: true,\n            serverFiltering: true,\n            serverGrouping: true,\n            serverAggregates: true\n          },\n          axes: function () {\n            return {\n              columns: normalizeAxis(this.columns()),\n              rows: normalizeAxis(this.rows())\n            };\n          },\n          catalog: function (val) {\n            if (val === undefined) {\n              return this.transport.catalog();\n            }\n\n            this.transport.catalog(val);\n\n            this._mergeState({}); // clears current state\n\n\n            this.read();\n          },\n          cube: function (val) {\n            if (val === undefined) {\n              return this.transport.cube();\n            }\n\n            this.transport.cube(val);\n\n            this._mergeState({}); // clears current state\n\n\n            this.read();\n          },\n          measuresAxis: function () {\n            return this._measuresAxis || \"columns\";\n          },\n          fetch: function () {\n            if (this.options.type.toLowerCase() === \"xmla\" && (this._data === undefined || this._data.length === 0)) {\n              this._query();\n            }\n          },\n          read: function (data) {\n            var that = this;\n            var isPrevented = that.trigger(REQUESTSTART, {\n              type: READ\n            });\n\n            var params = that._params(data);\n\n            if (!isPrevented) {\n              that.trigger(PROGRESS);\n              that.transport.read({\n                data: params,\n                success: function (newDataState) {\n                  that._saveState(newDataState);\n\n                  that.trigger(REQUESTEND, {\n                    response: newDataState,\n                    type: READ\n                  });\n                  that.trigger(CHANGE);\n\n                  if (that._preventRefresh) {\n                    that._preventRefresh = false;\n                  }\n                },\n                error: function (err) {\n                  that.trigger(ERROR, {\n                    error: err\n                  });\n                }\n              });\n            }\n          },\n          _params: function (data) {\n            var that = this;\n\n            var options = DataSource.fn._params.call(that, data);\n\n            options = extend({\n              connection: that.options.transport.connection,\n              columnAxes: JSON.parse(JSON.stringify(that._columns)),\n              rowAxes: JSON.parse(JSON.stringify(that._rows)),\n              measuresAxis: that.measuresAxis(),\n              measureAxes: that._measures\n            }, options);\n\n            if (options.filter) {\n              options.filter = normalizeFilter(options.filter);\n              options.filter = (options.filter || {}).filters;\n            }\n\n            if (options.sort) {\n              options.sort = normalizeSort(options.sort);\n            }\n\n            return options;\n          },\n          discover: function (options) {\n            var that = this,\n                transport = that.transport;\n\n            if (transport.discover) {\n              return transport.discover(options);\n            }\n          },\n          schemaMeasures: function () {\n            var that = this;\n            return that.discover({\n              command: \"schemaMeasures\",\n              restrictions: {\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube()\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaKPIs: function () {\n            var that = this;\n            return that.discover({\n              command: \"schemaKPIs\",\n              restrictions: {\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube()\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaDimensions: function () {\n            var that = this;\n            return that.discover({\n              command: \"schemaDimensions\",\n              restrictions: {\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube()\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaHierarchies: function (dimensionName) {\n            var that = this;\n            return that.discover({\n              command: \"schemaHierarchies\",\n              restrictions: {\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube(),\n                dimensionUniqueName: dimensionName\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaLevels: function (hierarchyName) {\n            var that = this;\n            return that.discover({\n              command: \"schemaLevels\",\n              restrictions: {\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube(),\n                hierarchyUniqueName: hierarchyName\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaCubes: function () {\n            var that = this;\n            return that.discover({\n              command: \"schemaCubes\",\n              restrictions: {\n                catalogName: that.transport.catalog()\n              }\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaCatalogs: function () {\n            var that = this;\n            return that.discover({\n              command: \"schemaCatalogs\"\n            }, function (response) {\n              return response;\n            });\n          },\n          schemaMembers: function (restrictions) {\n            var that = this;\n            return that.discover({\n              command: \"schemaMembers\",\n              restrictions: extend({\n                catalogName: that.transport.catalog(),\n                cubeName: that.transport.cube()\n              }, restrictions)\n            }, function (response) {\n              return response;\n            });\n          },\n          _saveState: function (state) {\n            var that = this;\n            that._columnTuples = state.columns;\n            that._rowTuples = state.rows;\n            that._view = state.data;\n          },\n          columns: function (val) {\n            if (val === undefined) {\n              return this._columns;\n            }\n\n            this._columns = normalizeMembers(val);\n            this.read();\n          },\n          rows: function (val) {\n            if (val === undefined) {\n              return this._rows;\n            }\n\n            this._rows = normalizeMembers(val);\n            this.read();\n          },\n          measures: function (val) {\n            if (val === undefined) {\n              return this._measures;\n            }\n\n            this._measures = normalizeMeasures(val);\n            this.read();\n          },\n          _mergeState: function (options) {\n            options = DataSource.fn._mergeState.call(this, options);\n            return options;\n          },\n          _query: function (options) {\n            var that = this;\n            var params = extend({}, {\n              sort: that.sort(),\n              measuresAxis: that.measuresAxis(),\n              filter: that.filter()\n            }, options);\n\n            var state = this._mergeState(params);\n\n            return this.read(state);\n          }\n        });\n        var PivotDataSource = DataSource.extend({\n          init: function (options) {\n            var cube = ((options || {}).schema || {}).cube;\n            var measuresAxis = \"columns\";\n            var measures;\n            var schema = {\n              axes: identity,\n              cubes: identity,\n              catalogs: identity,\n              measures: identity,\n              dimensions: identity,\n              hierarchies: identity,\n              levels: identity,\n              members: identity\n            };\n\n            if (cube) {\n              schema = $.extend(schema, this._cubeSchema(cube));\n              this.cubeBuilder = new PivotCubeBuilder(cube);\n            }\n\n            DataSource.fn.init.call(this, extend(true, {}, {\n              schema: schema\n            }, options));\n            this.transport = new PivotTransport(this.options.transport || {}, this.transport);\n            this._columns = normalizeMembers(this.options.columns);\n            this._rows = normalizeMembers(this.options.rows);\n            measures = this.options.measures || [];\n\n            if (toString.call(measures) === \"[object Object]\") {\n              measuresAxis = measures.axis || \"columns\";\n              measures = measures.values || [];\n            }\n\n            this._measures = normalizeMeasures(measures);\n            this._measuresAxis = measuresAxis;\n            this._skipNormalize = 0;\n            this._axes = {};\n          },\n          _cubeSchema: function (cube) {\n            return {\n              dimensions: function () {\n                var result = [];\n                var dimensions = cube.dimensions;\n\n                for (var key in dimensions) {\n                  result.push({\n                    name: key,\n                    caption: dimensions[key].caption || key,\n                    uniqueName: key,\n                    defaultHierarchy: key,\n                    type: 1\n                  });\n                }\n\n                if (cube.measures) {\n                  result.push({\n                    name: MEASURES,\n                    caption: MEASURES,\n                    uniqueName: MEASURES,\n                    type: 2\n                  });\n                }\n\n                return result;\n              },\n              hierarchies: function () {\n                return [];\n              },\n              measures: function () {\n                var result = [];\n                var measures = cube.measures;\n\n                for (var key in measures) {\n                  result.push({\n                    name: key,\n                    caption: key,\n                    uniqueName: key,\n                    aggregator: key\n                  });\n                }\n\n                return result;\n              },\n              members: function (response, restrictions) {\n                var name = restrictions.levelUniqueName || restrictions.memberUniqueName;\n                var schemaData = this.options.schema.data;\n                var dataGetter = isFunction(schemaData) ? schemaData : kendo.getter(schemaData, true);\n                var data = this.options.data && dataGetter(this.options.data) || this._rawData || [];\n                var result = [];\n                var getter;\n                var value;\n                var idx = 0;\n                var distinct = {};\n\n                if (name) {\n                  name = name.split(\".\")[0];\n                }\n\n                if (!restrictions.treeOp) {\n                  result.push({\n                    caption: cube.dimensions[name].caption || name,\n                    childrenCardinality: \"1\",\n                    dimensionUniqueName: name,\n                    hierarchyUniqueName: name,\n                    levelUniqueName: name,\n                    name: name,\n                    uniqueName: name\n                  });\n                  return result;\n                }\n\n                getter = kendo.getter(normalizeName(name), true);\n\n                for (; idx < data.length; idx++) {\n                  value = getter(data[idx]);\n\n                  if ((value || value === 0) && !distinct[value]) {\n                    distinct[value] = true;\n                    result.push({\n                      caption: value,\n                      childrenCardinality: \"0\",\n                      dimensionUniqueName: name,\n                      hierarchyUniqueName: name,\n                      levelUniqueName: name,\n                      name: value,\n                      uniqueName: value\n                    });\n                  }\n                }\n\n                return result;\n              }.bind(this)\n            };\n          },\n          options: {\n            serverSorting: true,\n            serverPaging: true,\n            serverFiltering: true,\n            serverGrouping: true,\n            serverAggregates: true\n          },\n          catalog: function (val) {\n            if (val === undefined) {\n              return this.transport.catalog();\n            }\n\n            this.transport.catalog(val);\n\n            this._mergeState({}); // clears current state\n\n\n            this._axes = {};\n            this.data([]);\n          },\n          cube: function (val) {\n            if (val === undefined) {\n              return this.transport.cube();\n            }\n\n            this.transport.cube(val);\n            this._axes = {};\n\n            this._mergeState({}); // clears current state\n\n\n            this.data([]);\n          },\n          axes: function () {\n            return this._axes;\n          },\n          columns: function (val) {\n            if (val === undefined) {\n              return this._columns;\n            }\n\n            this._skipNormalize += 1;\n            this._clearAxesData = true;\n            this._columns = normalizeMembers(val);\n            this.query({\n              columns: val,\n              rows: this.rowsAxisDescriptors(),\n              measures: this.measures(),\n              sort: this.sort(),\n              filter: this.filter()\n            });\n          },\n          rows: function (val) {\n            if (val === undefined) {\n              return this._rows;\n            }\n\n            this._skipNormalize += 1;\n            this._clearAxesData = true;\n            this._rows = normalizeMembers(val);\n            this.query({\n              columns: this.columnsAxisDescriptors(),\n              rows: val,\n              measures: this.measures(),\n              sort: this.sort(),\n              filter: this.filter()\n            });\n          },\n          measures: function (val) {\n            if (val === undefined) {\n              return this._measures;\n            }\n\n            this._skipNormalize += 1;\n            this._clearAxesData = true;\n            this.query({\n              columns: this.columnsAxisDescriptors(),\n              rows: this.rowsAxisDescriptors(),\n              measures: normalizeMeasures(val),\n              sort: this.sort(),\n              filter: this.filter()\n            });\n          },\n          measuresAxis: function () {\n            return this._measuresAxis || \"columns\";\n          },\n          _expandPath: function (path, axis) {\n            var origin = axis === \"columns\" ? \"columns\" : \"rows\";\n            var other = axis === \"columns\" ? \"rows\" : \"columns\";\n            var members = normalizeMembers(path);\n            var memberToExpand = getName(members[members.length - 1]);\n            this._lastExpanded = origin;\n            members = descriptorsForMembers(this.axes()[origin], members, this.measures());\n\n            for (var idx = 0; idx < members.length; idx++) {\n              var memberName = getName(members[idx]);\n\n              if (memberName === memberToExpand) {\n                if (members[idx].expand) {\n                  return;\n                }\n\n                members[idx].expand = true;\n              } else {\n                members[idx].expand = false;\n              }\n            }\n\n            var descriptors = {};\n            descriptors[origin] = members;\n            descriptors[other] = this._descriptorsForAxis(other);\n\n            this._query(descriptors);\n          },\n          _descriptorsForAxis: function (axis) {\n            var axes = this.axes();\n            var descriptors = this[axis]() || [];\n\n            if (axes && axes[axis] && axes[axis].tuples && axes[axis].tuples[0]) {\n              descriptors = descriptorsForAxes(axes[axis].tuples || []);\n            }\n\n            return descriptors;\n          },\n          columnsAxisDescriptors: function () {\n            return this._descriptorsForAxis(\"columns\");\n          },\n          rowsAxisDescriptors: function () {\n            return this._descriptorsForAxis(\"rows\");\n          },\n          _process: function (data, e) {\n            this._view = data;\n            e = e || {};\n            e.items = e.items || this._view;\n            this.trigger(CHANGE, e);\n          },\n          _query: function (options) {\n            var that = this;\n\n            if (!options) {\n              this._skipNormalize += 1;\n              this._clearAxesData = true;\n            }\n\n            return that.query(extend({}, {\n              page: that.page(),\n              pageSize: that.pageSize(),\n              sort: that.sort(),\n              filter: that.filter(),\n              group: that.group(),\n              aggregate: that.aggregate(),\n              columns: this.columnsAxisDescriptors(),\n              rows: this.rowsAxisDescriptors(),\n              measures: this.measures()\n            }, options));\n          },\n          query: function (options) {\n            var state = this._mergeState(options);\n\n            if (this._data.length && this.cubeBuilder) {\n              this._params(state);\n\n              this._updateLocalData(this._pristineData);\n\n              return $.Deferred().resolve().promise();\n            }\n\n            return this.read(state);\n          },\n          _mergeState: function (options) {\n            options = DataSource.fn._mergeState.call(this, options);\n\n            if (options !== undefined) {\n              this._measures = normalizeMeasures(options.measures);\n\n              if (options.columns) {\n                options.columns = normalizeMembers(options.columns);\n              } else if (!options.columns) {\n                this._columns = [];\n              }\n\n              if (options.rows) {\n                options.rows = normalizeMembers(options.rows);\n              } else if (!options.rows) {\n                this._rows = [];\n              }\n            }\n\n            return options;\n          },\n          filter: function (val) {\n            if (val === undefined) {\n              return this._filter;\n            }\n\n            this._skipNormalize += 1;\n            this._clearAxesData = true;\n\n            this._query({\n              filter: val,\n              page: 1\n            });\n          },\n          expandColumn: function (path) {\n            this._expandPath(path, \"columns\");\n          },\n          expandRow: function (path) {\n            this._expandPath(path, \"rows\");\n          },\n          success: function (data) {\n            var originalData;\n\n            if (this.cubeBuilder) {\n              originalData = (this.reader.data(data) || []).slice(0);\n            }\n\n            DataSource.fn.success.call(this, data);\n\n            if (originalData) {\n              this._pristineData = originalData;\n            }\n          },\n          _processResult: function (data, axes) {\n            if (this.cubeBuilder) {\n              var processedData = this.cubeBuilder.process(data, this._requestData);\n              data = processedData.data;\n              axes = processedData.axes;\n            }\n\n            var columnIndexes, rowIndexes;\n            var tuples, resultAxis, measures, axisToSkip;\n            var columnDescriptors = this.columns();\n            var rowDescriptors = this.rows();\n            var hasColumnTuples = axes.columns && axes.columns.tuples;\n\n            if (!columnDescriptors.length && rowDescriptors.length && hasColumnTuples && (this._rowMeasures().length || !this.measures().length)) {\n              axes = {\n                columns: {},\n                rows: axes.columns\n              };\n            }\n\n            if (!columnDescriptors.length && !rowDescriptors.length && this.measuresAxis() === \"rows\" && hasColumnTuples) {\n              axes = {\n                columns: {},\n                rows: axes.columns\n              };\n            }\n\n            this._axes = {\n              columns: normalizeAxis(this._axes.columns),\n              rows: normalizeAxis(this._axes.rows)\n            };\n            axes = {\n              columns: normalizeAxis(axes.columns),\n              rows: normalizeAxis(axes.rows)\n            };\n            columnIndexes = this._normalizeTuples(axes.columns.tuples, this._axes.columns.tuples, columnDescriptors, this._columnMeasures());\n            rowIndexes = this._normalizeTuples(axes.rows.tuples, this._axes.rows.tuples, rowDescriptors, this._rowMeasures());\n\n            if (this._skipNormalize > 0) {\n              this._skipNormalize -= 1;\n            }\n\n            if (!this.cubeBuilder) {\n              data = this._normalizeData({\n                columnsLength: axes.columns.tuples.length,\n                rowsLength: axes.rows.tuples.length,\n                columnIndexes: columnIndexes,\n                rowIndexes: rowIndexes,\n                data: data\n              });\n            }\n\n            if (this._lastExpanded == \"rows\") {\n              tuples = axes.columns.tuples;\n              measures = this._columnMeasures();\n              resultAxis = validateAxis(axes.columns, this._axes.columns, measures);\n\n              if (resultAxis) {\n                axisToSkip = \"columns\";\n                axes.columns = resultAxis;\n                adjustDataByColumn(tuples, resultAxis.tuples, axes.rows.tuples.length, measures, data);\n\n                if (!this.cubeBuilder) {\n                  data = this._normalizeData({\n                    columnsLength: membersCount(axes.columns.tuples, measures),\n                    rowsLength: axes.rows.tuples.length,\n                    data: data\n                  });\n                }\n              }\n            } else if (this._lastExpanded == \"columns\") {\n              tuples = axes.rows.tuples;\n              measures = this._rowMeasures();\n              resultAxis = validateAxis(axes.rows, this._axes.rows, measures);\n\n              if (resultAxis) {\n                axisToSkip = \"rows\";\n                axes.rows = resultAxis;\n                adjustDataByRow(tuples, resultAxis.tuples, axes.columns.tuples.length, measures, data);\n\n                if (!this.cubeBuilder) {\n                  data = this._normalizeData({\n                    columnsLength: membersCount(axes.rows.tuples, measures),\n                    rowsLength: axes.columns.tuples.length,\n                    data: data\n                  });\n                }\n              }\n            }\n\n            this._lastExpanded = null;\n\n            var result = this._mergeAxes(axes, data, axisToSkip);\n\n            this._axes = result.axes;\n            return result.data;\n          },\n          _readData: function (data) {\n            var axes = this.reader.axes(data);\n            var newData = this.reader.data(data);\n\n            if (this.cubeBuilder) {\n              this._rawData = newData;\n            }\n\n            return this._processResult(newData, axes);\n          },\n          _createTuple: function (tuple, measure, buildRoot) {\n            var members = tuple.members;\n            var length = members.length;\n            var root = {\n              members: []\n            };\n            var levelName, levelNum;\n            var name, parentName;\n            var hasChildren;\n            var hierarchy;\n            var caption;\n            var member;\n            var idx = 0;\n\n            if (measure) {\n              length -= 1;\n            }\n\n            for (; idx < length; idx++) {\n              member = members[idx];\n              levelNum = Number(member.levelNum);\n              name = member.name;\n              parentName = member.parentName;\n              caption = member.caption || name;\n              hasChildren = member.hasChildren;\n              hierarchy = member.hierarchy;\n              levelName = member.levelName;\n\n              if (buildRoot) {\n                caption = \"All\";\n\n                if (levelNum === 0) {\n                  parentName = member.name;\n                } else {\n                  levelNum -= 1;\n                }\n\n                hasChildren = true;\n                name = hierarchy = levelName = parentName;\n              }\n\n              root.members.push({\n                name: name,\n                children: [],\n                caption: caption,\n                levelName: levelName,\n                levelNum: levelNum.toString(),\n                hasChildren: hasChildren,\n                hierarchy: hierarchy,\n                parentName: !buildRoot ? parentName : \"\"\n              });\n            }\n\n            if (measure) {\n              root.members.push({\n                name: measure.name,\n                children: []\n              });\n            }\n\n            return root;\n          },\n          _hasRoot: function (target, source, descriptors) {\n            if (source.length) {\n              return findExistingTuple(source, target).tuple;\n            }\n\n            var members = target.members;\n            var member;\n            var descriptor;\n            var isRoot = true;\n            var levelNum;\n\n            for (var idx = 0, length = members.length; idx < length; idx++) {\n              member = members[idx];\n              levelNum = Number(member.levelNum) || 0;\n              descriptor = descriptors[idx];\n\n              if (!(levelNum === 0 || descriptor && member.name === getName(descriptor))) {\n                isRoot = false;\n                break;\n              }\n            }\n\n            return isRoot;\n          },\n          _mergeAxes: function (sourceAxes, data, axisToSkip) {\n            var columnMeasures = this._columnMeasures();\n\n            var rowMeasures = this._rowMeasures();\n\n            var axes = this.axes();\n            var startIndex, tuples;\n            var oldRowsLength = membersCount(axes.rows.tuples, rowMeasures);\n            var newRowsLength = sourceAxes.rows.tuples.length;\n            var oldColumnsLength = membersCount(axes.columns.tuples, columnMeasures);\n            var newColumnsLength = sourceAxes.columns.tuples.length;\n\n            if (axisToSkip == \"columns\") {\n              newColumnsLength = oldColumnsLength;\n              tuples = sourceAxes.columns.tuples;\n            } else {\n              tuples = parseSource(sourceAxes.columns.tuples, columnMeasures);\n              data = prepareDataOnColumns(tuples, data);\n            }\n\n            var mergedColumns = mergeTuples(axes.columns.tuples, tuples, columnMeasures);\n\n            if (axisToSkip == \"rows\") {\n              newRowsLength = membersCount(sourceAxes.rows.tuples, rowMeasures);\n              tuples = sourceAxes.rows.tuples;\n            } else {\n              tuples = parseSource(sourceAxes.rows.tuples, rowMeasures);\n              data = prepareDataOnRows(tuples, data);\n            }\n\n            var mergedRows = mergeTuples(axes.rows.tuples, tuples, rowMeasures);\n            axes.columns.tuples = mergedColumns.tuples;\n            axes.rows.tuples = mergedRows.tuples;\n\n            if (oldColumnsLength !== membersCount(axes.columns.tuples, columnMeasures)) {\n              //columns are expanded\n              startIndex = mergedColumns.index + findDataIndex(mergedColumns.parsedRoot, mergedColumns.memberIndex, columnMeasures);\n              var offset = oldColumnsLength + newColumnsLength;\n              data = this._mergeColumnData(data, startIndex, newRowsLength, newColumnsLength, offset);\n            } else if (oldRowsLength !== membersCount(axes.rows.tuples, rowMeasures)) {\n              //rows are expanded\n              startIndex = mergedRows.index + findDataIndex(mergedRows.parsedRoot, mergedRows.memberIndex, rowMeasures);\n              data = this._mergeRowData(data, startIndex, newRowsLength, newColumnsLength);\n            }\n\n            if (axes.columns.tuples.length === 0 && axes.rows.tuples.length === 0) {\n              data = [];\n            }\n\n            return {\n              axes: axes,\n              data: data\n            };\n          },\n          _mergeColumnData: function (newData, columnIndex, rowsLength, columnsLength, offset) {\n            var data = this.data().toJSON();\n            var rowIndex,\n                index,\n                drop = 0,\n                toAdd;\n            var columnMeasures = Math.max(this._columnMeasures().length, 1);\n            rowsLength = Math.max(rowsLength, 1);\n\n            if (data.length > 0) {\n              //if there is already data, drop the first new data item\n              drop = columnMeasures;\n              offset -= columnMeasures;\n            }\n\n            for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n              index = columnIndex + rowIndex * offset;\n              toAdd = newData.splice(0, columnsLength);\n              toAdd.splice(0, drop);\n              [].splice.apply(data, [index, 0].concat(toAdd));\n            }\n\n            return data;\n          },\n          _mergeRowData: function (newData, rowIndex, rowsLength, columnsLength) {\n            var data = this.data().toJSON();\n            var idx, dataIndex, toAdd;\n            var rowMeasures = Math.max(this._rowMeasures().length, 1);\n            columnsLength = Math.max(columnsLength, 1);\n\n            if (data.length > 0) {\n              //if there is already data, drop the first new data item\n              rowsLength -= rowMeasures;\n              newData.splice(0, columnsLength * rowMeasures);\n            }\n\n            for (idx = 0; idx < rowsLength; idx++) {\n              toAdd = newData.splice(0, columnsLength);\n              dataIndex = rowIndex * columnsLength + idx * columnsLength;\n              [].splice.apply(data, [dataIndex, 0].concat(toAdd));\n            }\n\n            return data;\n          },\n          _columnMeasures: function () {\n            var measures = this.measures();\n            var columnMeasures = [];\n\n            if (this.measuresAxis() === \"columns\") {\n              if (this.columns().length === 0) {\n                columnMeasures = measures;\n              } else if (measures.length > 1) {\n                columnMeasures = measures;\n              }\n            }\n\n            return columnMeasures;\n          },\n          _rowMeasures: function () {\n            var measures = this.measures();\n            var rowMeasures = [];\n\n            if (this.measuresAxis() === \"rows\") {\n              if (this.rows().length === 0) {\n                rowMeasures = measures;\n              } else if (measures.length > 1) {\n                rowMeasures = measures;\n              }\n            }\n\n            return rowMeasures;\n          },\n          _updateLocalData: function (data, state) {\n            if (this.cubeBuilder) {\n              if (state) {\n                this._requestData = state;\n              }\n\n              data = this._processResult(data);\n            }\n\n            this._data = this._observe(data);\n            this._ranges = [];\n\n            this._addRange(this._data);\n\n            this._total = this._data.length;\n            this._pristineTotal = this._total;\n\n            this._process(this._data);\n          },\n          data: function (value) {\n            var that = this;\n\n            if (value !== undefined) {\n              this._pristineData = value.slice(0);\n\n              this._updateLocalData(value, {\n                columns: this.columns(),\n                rows: this.rows(),\n                measures: this.measures()\n              });\n            } else {\n              return that._data;\n            }\n          },\n          _normalizeTuples: function (tuples, source, descriptors, measures) {\n            var length = measures.length || 1;\n            var idx = 0;\n            var roots = [];\n            var indexes = {};\n            var measureIdx = 0;\n            var tuple, memberIdx, last;\n\n            if (!tuples.length) {\n              return;\n            }\n\n            if (this._skipNormalize <= 0 && !this._hasRoot(tuples[0], source, descriptors)) {\n              this._skipNormalize = 0;\n\n              for (; idx < length; idx++) {\n                roots.push(this._createTuple(tuples[0], measures[idx], true));\n                indexes[idx] = idx;\n              }\n\n              tuples.splice.apply(tuples, [0, tuples.length].concat(roots).concat(tuples));\n              idx = length;\n            }\n\n            if (measures.length) {\n              last = tuple = tuples[idx];\n              memberIdx = tuple.members.length - 1;\n\n              while (tuple) {\n                if (measureIdx >= length) {\n                  measureIdx = 0;\n                }\n\n                if (tuple.members[memberIdx].name !== measures[measureIdx].name) {\n                  tuples.splice(idx, 0, this._createTuple(tuple, measures[measureIdx]));\n                  indexes[idx] = idx;\n                }\n\n                idx += 1;\n                measureIdx += 1;\n                tuple = tuples[idx];\n\n                if (length > measureIdx && (!tuple || tupleName(last, memberIdx - 1) !== tupleName(tuple, memberIdx - 1))) {\n                  for (; measureIdx < length; measureIdx++) {\n                    tuples.splice(idx, 0, this._createTuple(last, measures[measureIdx]));\n                    indexes[idx] = idx;\n                    idx += 1;\n                  }\n\n                  tuple = tuples[idx];\n                }\n\n                last = tuple;\n              }\n            }\n\n            return indexes;\n          },\n          _addMissingDataItems: function (result, metadata) {\n            while (metadata.rowIndexes[parseInt(result.length / metadata.columnsLength, 10)] !== undefined) {\n              for (var idx = 0; idx < metadata.columnsLength; idx++) {\n                result = addEmptyDataItem(result);\n              }\n            }\n\n            while (metadata.columnIndexes[result.length % metadata.columnsLength] !== undefined) {\n              result = addEmptyDataItem(result);\n            }\n\n            return result;\n          },\n          _normalizeOrdinals: function (result, dataItem, metadata) {\n            var lastOrdinal = metadata.lastOrdinal;\n\n            if (!dataItem) {\n              return addEmptyDataItem(result);\n            }\n\n            if (dataItem.ordinal - lastOrdinal > 1) {\n              lastOrdinal += 1;\n\n              while (lastOrdinal < dataItem.ordinal && result.length < metadata.length) {\n                result = this._addMissingDataItems(addEmptyDataItem(result), metadata);\n                lastOrdinal += 1;\n              }\n            }\n\n            dataItem.ordinal = result.length;\n            result[result.length] = dataItem;\n            return result;\n          },\n          _normalizeData: function (options) {\n            var data = options.data;\n            var dataIdx = 0;\n            var dataItem;\n            var result = [];\n            var lastOrdinal;\n            var length;\n            options.lastOrdinal = 0;\n            options.columnIndexes = options.columnIndexes || {};\n            options.rowIndexes = options.rowIndexes || {};\n            options.columnsLength = options.columnsLength || 1;\n            options.rowsLength = options.rowsLength || 1;\n            options.length = options.columnsLength * options.rowsLength;\n            length = options.length;\n\n            if (data.length === length) {\n              return data;\n            }\n\n            while (result.length < length) {\n              dataItem = data[dataIdx++];\n\n              if (dataItem) {\n                lastOrdinal = dataItem.ordinal;\n              }\n\n              result = this._normalizeOrdinals(this._addMissingDataItems(result, options), dataItem, options);\n              options.lastOrdinal = lastOrdinal;\n            }\n\n            return result;\n          },\n          discover: function (options, converter) {\n            var that = this,\n                transport = that.transport;\n            return $.Deferred(function (deferred) {\n              transport.discover(extend({\n                success: function (response) {\n                  response = that.reader.parse(response);\n\n                  if (that._handleCustomErrors(response)) {\n                    return;\n                  }\n\n                  if (converter) {\n                    response = converter(response);\n                  }\n\n                  deferred.resolve(response);\n                },\n                error: function (response, status, error) {\n                  deferred.reject(response);\n                  that.error(response, status, error);\n                }\n              }, options));\n            }).promise().done(function () {\n              that.trigger(\"schemaChange\");\n            });\n          },\n          schemaMeasures: function () {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaMeasures\",\n                restrictions: {\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube()\n                }\n              }\n            }, function (response) {\n              return that.reader.measures(response);\n            });\n          },\n          schemaKPIs: function () {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaKPIs\",\n                restrictions: {\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube()\n                }\n              }\n            }, function (response) {\n              return that.reader.kpis(response);\n            });\n          },\n          schemaDimensions: function () {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaDimensions\",\n                restrictions: {\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube()\n                }\n              }\n            }, function (response) {\n              return that.reader.dimensions(response);\n            });\n          },\n          schemaHierarchies: function (dimensionName) {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaHierarchies\",\n                restrictions: {\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube(),\n                  dimensionUniqueName: dimensionName\n                }\n              }\n            }, function (response) {\n              return that.reader.hierarchies(response);\n            });\n          },\n          schemaLevels: function (hierarchyName) {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaLevels\",\n                restrictions: {\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube(),\n                  hierarchyUniqueName: hierarchyName\n                }\n              }\n            }, function (response) {\n              return that.reader.levels(response);\n            });\n          },\n          schemaCubes: function () {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaCubes\",\n                restrictions: {\n                  catalogName: that.transport.catalog()\n                }\n              }\n            }, function (response) {\n              return that.reader.cubes(response);\n            });\n          },\n          schemaCatalogs: function () {\n            var that = this;\n            return that.discover({\n              data: {\n                command: \"schemaCatalogs\"\n              }\n            }, function (response) {\n              return that.reader.catalogs(response);\n            });\n          },\n          schemaMembers: function (restrictions) {\n            var that = this;\n\n            var success = function (restrictions) {\n              return function (response) {\n                return that.reader.members(response, restrictions);\n              };\n            }(restrictions);\n\n            return that.discover({\n              data: {\n                command: \"schemaMembers\",\n                restrictions: extend({\n                  catalogName: that.transport.catalog(),\n                  cubeName: that.transport.cube()\n                }, restrictions)\n              }\n            }, success);\n          },\n          _params: function (data) {\n            if (this._clearAxesData) {\n              this._axes = {};\n              this._data = this._observe([]);\n              this._clearAxesData = false;\n              this.trigger(STATERESET);\n            }\n\n            var options = DataSource.fn._params.call(this, data);\n\n            options = extend({\n              measures: this.measures(),\n              measuresAxis: this.measuresAxis(),\n              columns: this.columns(),\n              rows: this.rows()\n            }, options);\n\n            if (this.cubeBuilder) {\n              this._requestData = options;\n            }\n\n            return options;\n          }\n        });\n\n        function flatColumns(columns) {\n          var result = [];\n\n          for (var idx = 0; idx < columns.length; idx++) {\n            result.push(columns[idx]);\n\n            if (columns[idx].children) {\n              result = result.concat(flatColumns(columns[idx].children));\n            }\n          }\n\n          return result;\n        }\n\n        function sortItemsTree(field, items, sortFunction) {\n          for (var i = 0; i < items.length; i++) {\n            if (items[i].children && items[i].children.length) {\n              sortItemsTree(field, items[i].children, sortFunction);\n            }\n          }\n\n          if (items[0].parentName != field) {\n            return;\n          }\n\n          items = items.sort(sortFunction);\n        }\n\n        function fillSortTree(items, map) {\n          for (var i = 0; i < items.length; i++) {\n            var currentItem = map[items[i].name];\n\n            if (!$.isEmptyObject(currentItem.childrenMap)) {\n              items[i].children = [];\n\n              for (var name in currentItem.childrenMap) {\n                items[i].children.push($.extend({}, {\n                  name: name,\n                  parentName: map[name].parentName\n                }));\n              }\n\n              fillSortTree(items[i].children, map);\n            }\n          }\n        }\n\n        function addEmptyDataItem(result) {\n          result[result.length] = {\n            value: \"\",\n            fmtValue: \"\",\n            ordinal: result.length\n          };\n          return result;\n        }\n\n        function validateAxis(newAxis, axis, measures) {\n          if (newAxis.tuples.length < membersCount(axis.tuples, measures)) {\n            return axis;\n          }\n\n          return;\n        }\n\n        function adjustDataByColumn(sourceTuples, targetTuples, rowsLength, measures, data) {\n          var columnIdx, rowIdx, dataIdx;\n          var columnsLength = sourceTuples.length;\n          var targetColumnsLength = membersCount(targetTuples, measures);\n          var measuresLength = measures.length || 1;\n\n          for (rowIdx = 0; rowIdx < rowsLength; rowIdx++) {\n            for (columnIdx = 0; columnIdx < columnsLength; columnIdx++) {\n              dataIdx = tupleIndex(sourceTuples[columnIdx], targetTuples) * measuresLength;\n              dataIdx += columnIdx % measuresLength;\n              data[rowIdx * columnsLength + columnIdx].ordinal = rowIdx * targetColumnsLength + dataIdx;\n            }\n          }\n        }\n\n        function adjustDataByRow(sourceTuples, targetTuples, columnsLength, measures, data) {\n          var columnIdx, rowIdx, dataIdx;\n          var rowsLength = sourceTuples.length;\n          var measuresLength = measures.length || 1;\n\n          for (rowIdx = 0; rowIdx < rowsLength; rowIdx++) {\n            dataIdx = tupleIndex(sourceTuples[rowIdx], targetTuples);\n            dataIdx *= measuresLength;\n            dataIdx += rowIdx % measuresLength;\n\n            for (columnIdx = 0; columnIdx < columnsLength; columnIdx++) {\n              data[rowIdx * columnsLength + columnIdx].ordinal = dataIdx * columnsLength + columnIdx;\n            }\n          }\n        }\n\n        function tupleIndex(tuple, collection) {\n          return findExistingTuple(collection, tuple).index;\n        }\n\n        function membersCount(tuples, measures) {\n          if (!tuples.length) {\n            return 0;\n          }\n\n          var queue = tuples.slice();\n          var current = queue.shift();\n          var result = 1;\n\n          while (current) {\n            if (current.members) {\n              [].push.apply(queue, current.members);\n            } else if (current.children) {\n              if (!current.measure) {\n                result += current.children.length;\n              }\n\n              [].push.apply(queue, current.children);\n            }\n\n            current = queue.shift();\n          }\n\n          if (measures.length) {\n            result = result * measures.length;\n          }\n\n          return result;\n        }\n\n        function normalizeAxis(axis) {\n          if (!axis) {\n            axis = {\n              tuples: []\n            };\n          }\n\n          if (!axis.tuples) {\n            axis.tuples = [];\n          }\n\n          return axis;\n        }\n\n        function findDataIndex(tuple, memberIndex, measures) {\n          if (!tuple) {\n            return 0;\n          }\n\n          var measuresLength = Math.max(measures.length, 1);\n          var tuples = tuple.members.slice(0, memberIndex);\n          var current = tuples.shift(); //the initial value is equal to the total number of measures\n          //as the measures member is not extracted from the members of the starting tuple\n          //but should be calculated in the final result\n\n          var counter = measuresLength;\n\n          while (current) {\n            if (current.name === MEASURES) {\n              //subtract 1 as the measures member has been already counted as a single standard member\n              //but we are interested in the total number of measures instead\n              counter += measuresLength - 1;\n            } else if (current.children) {\n              //is member\n              [].push.apply(tuples, current.children);\n            } else {\n              //is tuple\n              counter++;\n              [].push.apply(tuples, current.members);\n            }\n\n            current = tuples.shift();\n          }\n\n          return counter;\n        }\n\n        function mergeTuples(target, source, measures) {\n          if (!source[0]) {\n            return {\n              parsedRoot: null,\n              tuples: target,\n              memberIndex: 0,\n              index: 0\n            };\n          }\n\n          var result = findExistingTuple(target, source[0]);\n\n          if (!result.tuple) {\n            return {\n              parsedRoot: null,\n              tuples: source,\n              memberIndex: 0,\n              index: 0\n            };\n          }\n\n          var targetMembers = result.tuple.members;\n          var sourceMembers = source[0].members;\n          var memberIndex = -1;\n\n          if (targetMembers.length !== sourceMembers.length) {\n            return {\n              parsedRoot: null,\n              tuples: source,\n              memberIndex: 0,\n              index: 0\n            };\n          }\n\n          for (var idx = 0, length = targetMembers.length; idx < length; idx++) {\n            if (!targetMembers[idx].measure && sourceMembers[idx].children[0]) {\n              if (memberIndex == -1 && sourceMembers[idx].children.length) {\n                memberIndex = idx;\n              }\n\n              targetMembers[idx].children = sourceMembers[idx].children;\n            }\n          }\n\n          measures = Math.max(measures.length, 1);\n          return {\n            parsedRoot: result.tuple,\n            index: result.index * measures,\n            memberIndex: memberIndex,\n            tuples: target\n          };\n        }\n\n        function equalTuples(first, second) {\n          var equal = true;\n          var idx, length;\n          first = first.members;\n          second = second.members;\n\n          for (idx = 0, length = first.length; idx < length; idx++) {\n            if (first[idx].measure || second[idx].measure) {\n              continue;\n            }\n\n            equal = equal && getName(first[idx]) === getName(second[idx]);\n          }\n\n          return equal;\n        }\n\n        function findExistingTuple(tuples, toFind) {\n          var idx,\n              length,\n              tuple,\n              found,\n              counter = 0;\n          var memberIndex, membersLength, member;\n\n          for (idx = 0, length = tuples.length; idx < length; idx++) {\n            tuple = tuples[idx];\n\n            if (equalTuples(tuple, toFind)) {\n              return {\n                tuple: tuple,\n                index: counter\n              };\n            }\n\n            counter++;\n\n            for (memberIndex = 0, membersLength = tuple.members.length; memberIndex < membersLength; memberIndex++) {\n              member = tuple.members[memberIndex];\n\n              if (member.measure) {\n                //counter += member.children.length;\n                continue;\n              }\n\n              found = findExistingTuple(member.children, toFind);\n              counter += found.index;\n\n              if (found.tuple) {\n                return {\n                  tuple: found.tuple,\n                  index: counter\n                };\n              }\n            }\n          }\n\n          return {\n            index: counter\n          };\n        }\n\n        function addMembers(members, map) {\n          var member,\n              i,\n              len,\n              path = \"\";\n\n          for (i = 0, len = members.length; i < len; i++) {\n            member = members[i];\n            path += member.name;\n\n            if (!map[path]) {\n              map[path] = member;\n            }\n          }\n        }\n\n        function findParentMember(tuple, map) {\n          var members = tuple.members;\n          var i,\n              len,\n              member,\n              path = \"\";\n          var parentPath = \"\";\n          var parentMember;\n\n          for (i = 0, len = members.length; i < len; i++) {\n            member = members[i];\n\n            if (parentMember) {\n              if (map[path + member.name]) {\n                path += member.name;\n                parentMember = map[path];\n                continue;\n              } else if (map[path + member.parentName]) {\n                return map[path + member.parentName];\n              } else if (map[parentPath + member.parentName]) {\n                return map[parentPath + member.parentName];\n              } else {\n                return map[parentPath];\n              }\n            }\n\n            path += member.name;\n            parentMember = map[member.parentName];\n\n            if (!parentMember) {\n              parentMember = map[path];\n\n              if (!parentMember) {\n                return null;\n              }\n            }\n\n            if (parentMember) {\n              parentPath += parentMember.name;\n            }\n          }\n\n          return parentMember;\n        }\n\n        function measurePosition(tuple, measures) {\n          if (measures.length === 0) {\n            return -1;\n          }\n\n          var measure = measures[0];\n          var members = tuple.members;\n\n          for (var idx = 0, len = members.length; idx < len; idx++) {\n            if (members[idx].name == measure.name) {\n              return idx;\n            }\n          }\n        }\n\n        function normalizeTupleMeasures(tuple, index) {\n          if (index < 0) {\n            return;\n          }\n\n          var member = {\n            name: MEASURES,\n            measure: true,\n            children: [$.extend({\n              members: [],\n              dataIndex: tuple.dataIndex\n            }, tuple.members[index])]\n          };\n          tuple.members.splice(index, 1, member);\n          tuple.dataIndex = undefined;\n        }\n\n        function parseSource(tuples, measures) {\n          if (tuples.length < 1) {\n            return [];\n          }\n\n          var result = [];\n          var map = {};\n          var measureIndex = measurePosition(tuples[0], measures);\n\n          for (var i = 0; i < tuples.length; i++) {\n            var tuple = tuples[i]; //keep the old data index of the tuple\n\n            tuple.dataIndex = i;\n            normalizeTupleMeasures(tuple, measureIndex);\n            var parentMember = findParentMember(tuple, map);\n\n            if (parentMember) {\n              if (measureIndex < 0 || !parentMember.measure) {\n                parentMember.children.push(tuple);\n              } else {\n                parentMember.children.push(tuple.members[measureIndex].children[0]);\n              }\n            } else {\n              result.push(tuple);\n            }\n\n            addMembers(tuple.members, map);\n          }\n\n          return result;\n        }\n\n        function prepareDataOnRows(tuples, data) {\n          if (!tuples || !tuples.length) {\n            return data;\n          }\n\n          var result = [];\n          var indices = buildDataIndices(tuples);\n          var rowsLength = indices.length;\n          var columnsLength = Math.max(data.length / rowsLength, 1);\n          var rowIndex, columnIndex, targetIndex, sourceIndex;\n          var calcIndex;\n\n          for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n            targetIndex = columnsLength * rowIndex;\n            sourceIndex = columnsLength * indices[rowIndex];\n\n            for (columnIndex = 0; columnIndex < columnsLength; columnIndex++) {\n              calcIndex = parseInt(sourceIndex + columnIndex, 10);\n              result[parseInt(targetIndex + columnIndex, 10)] = data[calcIndex] || {\n                value: \"\",\n                fmtValue: \"\",\n                ordinal: calcIndex\n              };\n            }\n          }\n\n          return result;\n        }\n\n        function prepareDataOnColumns(tuples, data) {\n          if (!tuples || !tuples.length) {\n            return data;\n          }\n\n          var result = [];\n          var indices = buildDataIndices(tuples);\n          var columnsLength = indices.length;\n          var rowsLength = Math.max(data.length / columnsLength, 1);\n          var columnIndex, rowIndex, dataIndex, calcIndex;\n\n          for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {\n            dataIndex = columnsLength * rowIndex;\n\n            for (columnIndex = 0; columnIndex < columnsLength; columnIndex++) {\n              calcIndex = indices[columnIndex] + dataIndex;\n              result[dataIndex + columnIndex] = data[calcIndex] || {\n                value: \"\",\n                fmtValue: \"\",\n                ordinal: calcIndex\n              };\n            }\n          }\n\n          return result;\n        }\n\n        function buildDataIndices(tuples) {\n          tuples = tuples.slice();\n          var result = [];\n          var tuple = tuples.shift();\n          var idx, length, spliceIndex, children, member;\n\n          while (tuple) {\n            //required for multiple measures\n            if (tuple.dataIndex !== undefined) {\n              result.push(tuple.dataIndex);\n            }\n\n            spliceIndex = 0;\n\n            for (idx = 0, length = tuple.members.length; idx < length; idx++) {\n              member = tuple.members[idx];\n              children = member.children;\n\n              if (member.measure) {\n                [].splice.apply(tuples, [0, 0].concat(children));\n              } else {\n                [].splice.apply(tuples, [spliceIndex, 0].concat(children));\n              }\n\n              spliceIndex += children.length;\n            }\n\n            tuple = tuples.shift();\n          }\n\n          return result;\n        }\n\n        PivotDataSourceV2.create = function (options) {\n          options = options && options.push ? {\n            data: options\n          } : options;\n          var dataSource = options || {},\n              data = dataSource.data;\n          dataSource.data = data;\n\n          if (!(dataSource instanceof PivotDataSourceV2) && dataSource instanceof kendo.data.DataSource) {\n            throw new Error(\"Incorrect DataSource type. Only PivotDataSource instances are supported\");\n          }\n\n          return dataSource instanceof PivotDataSourceV2 ? dataSource : new PivotDataSourceV2(dataSource);\n        };\n\n        PivotDataSource.create = function (options) {\n          options = options && options.push ? {\n            data: options\n          } : options;\n          var dataSource = options || {},\n              data = dataSource.data;\n          dataSource.data = data;\n\n          if (!(dataSource instanceof PivotDataSource) && dataSource instanceof kendo.data.DataSource) {\n            throw new Error(\"Incorrect DataSource type. Only PivotDataSource instances are supported\");\n          }\n\n          return dataSource instanceof PivotDataSource ? dataSource : new PivotDataSource(dataSource);\n        };\n\n        function baseHierarchyPath(memberName) {\n          var parts = memberName.split(\".\");\n\n          if (parts.length > 2) {\n            return parts[0] + \".\" + parts[1];\n          }\n\n          return memberName;\n        }\n\n        function expandMemberDescriptor(names, sort) {\n          var idx = names.length - 1;\n          var name = names[idx];\n          var sortDescriptor;\n          sortDescriptor = sortDescriptorForMember(sort, name);\n\n          if (sortDescriptor && sortDescriptor.dir) {\n            name = \"ORDER(\" + name + \".Children,\" + sortDescriptor.field + \".CurrentMember.MEMBER_CAPTION,\" + sortDescriptor.dir + \")\";\n          } else {\n            name += \".Children\";\n          }\n\n          names[idx] = name;\n          return names;\n        }\n\n        function sortDescriptorForMember(sort, member) {\n          for (var idx = 0, length = sort.length; idx < length; idx++) {\n            if (member.indexOf(sort[idx].field) === 0) {\n              return sort[idx];\n            }\n          }\n\n          return null;\n        }\n\n        function crossJoin(names) {\n          var result = \"CROSSJOIN({\";\n          var r;\n\n          if (names.length > 2) {\n            r = names.pop();\n            result += crossJoin(names);\n          } else {\n            result += names.shift();\n            r = names.pop();\n          }\n\n          result += \"},{\";\n          result += r;\n          result += \"})\";\n          return result;\n        }\n\n        function crossJoinCommand(members, measures) {\n          var tmp = members.slice(0);\n\n          if (measures.length > 1) {\n            tmp.push(\"{\" + measureNames(measures).join(\",\") + \"}\");\n          }\n\n          return crossJoin(tmp);\n        }\n\n        function measureNames(measures) {\n          var idx = 0;\n          var length = measures.length;\n          var result = [];\n          var measure;\n\n          for (; idx < length; idx++) {\n            measure = measures[idx];\n            result.push(measure.name !== undefined ? measure.name : measure);\n          }\n\n          return result;\n        }\n\n        function indexOf(name, items) {\n          var idx,\n              length,\n              index = -1;\n\n          for (idx = 0, length = items.length; idx < length; idx++) {\n            if (getName(items[idx]) === name) {\n              index = idx;\n              break;\n            }\n          }\n\n          return index;\n        }\n\n        function getName(name) {\n          name = name.name || name;\n\n          if (toString.call(name) === \"[object Array]\") {\n            name = name[name.length - 1];\n          }\n\n          return name;\n        }\n\n        function getRootNames(members) {\n          var length = members.length;\n          var names = [];\n          var idx = 0;\n\n          for (; idx < length; idx++) {\n            names.push(members[idx].name[0]);\n          }\n\n          return names;\n        }\n\n        function mapNames(names, rootNames) {\n          var name;\n          var rootName;\n          var j;\n          var idx = 0;\n          var length = names.length;\n          var rootLength = rootNames.length;\n          rootNames = rootNames.slice(0);\n\n          for (; idx < length; idx++) {\n            name = names[idx];\n\n            for (j = 0; j < rootLength; j++) {\n              rootName = baseHierarchyPath(rootNames[j]);\n\n              if (name.indexOf(rootName) !== -1) {\n                rootNames[j] = name;\n                break;\n              }\n            }\n          }\n\n          return {\n            names: rootNames,\n            expandedIdx: j,\n            uniquePath: rootNames.slice(0, j + 1).join(\"\")\n          };\n        }\n\n        function parseDescriptors(members) {\n          var expanded = [];\n          var child = [];\n          var root = [];\n          var member;\n          var j, l;\n          var idx = 0;\n          var length = members.length;\n          var name;\n          var hierarchyName;\n          var found;\n\n          for (; idx < length; idx++) {\n            member = members[idx];\n            name = member.name;\n            found = false;\n\n            if (toString.call(name) !== \"[object Array]\") {\n              member.name = name = [name];\n            }\n\n            if (name.length > 1) {\n              child.push(member);\n            } else {\n              hierarchyName = baseHierarchyPath(name[0]);\n\n              for (j = 0, l = root.length; j < l; j++) {\n                if (root[j].name[0].indexOf(hierarchyName) === 0) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if (!found) {\n                root.push(member);\n              }\n\n              if (member.expand) {\n                expanded.push(member);\n              }\n            }\n          }\n\n          expanded = expanded.concat(child);\n          return {\n            root: root,\n            expanded: expanded\n          };\n        }\n\n        function serializeMembers(members, measures, sort) {\n          var command = \"\";\n          members = members || [];\n          var expanded = parseDescriptors(members);\n          var root = expanded.root;\n          var rootNames = getRootNames(root);\n          var crossJoinCommands = [];\n          expanded = expanded.expanded;\n          var length = expanded.length;\n          var idx = 0;\n          var memberName;\n          var names = [];\n\n          if (rootNames.length > 1 || measures.length > 1) {\n            crossJoinCommands.push(crossJoinCommand(rootNames, measures));\n\n            for (; idx < length; idx++) {\n              memberName = expandMemberDescriptor(expanded[idx].name, sort);\n              names = mapNames(memberName, rootNames).names;\n              crossJoinCommands.push(crossJoinCommand(names, measures));\n            }\n\n            command += crossJoinCommands.join(\",\");\n          } else {\n            for (; idx < length; idx++) {\n              memberName = expandMemberDescriptor(expanded[idx].name, sort);\n              names.push(memberName[0]); //check if this is ok\n            }\n\n            command += rootNames.concat(names).join(\",\");\n          }\n\n          return command;\n        }\n\n        var filterFunctionFormats = {\n          contains: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\") > 0\",\n          doesnotcontain: \", InStr({0}.CurrentMember.MEMBER_CAPTION,\\\"{1}\\\")\",\n          startswith: \", Left({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\",\n          endswith: \", Right({0}.CurrentMember.MEMBER_CAPTION,Len(\\\"{1}\\\"))=\\\"{1}\\\"\",\n          eq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\",\n          neq: \", {0}.CurrentMember.MEMBER_CAPTION = \\\"{1}\\\"\"\n        };\n\n        function serializeExpression(expression) {\n          var command = \"\";\n          var value = expression.value;\n          var field = expression.field;\n          var operator = expression.operator;\n\n          if (operator == \"in\") {\n            command += \"{\";\n            command += value;\n            command += \"}\";\n          } else {\n            command += operator == \"neq\" || operator == \"doesnotcontain\" ? \"-\" : \"\";\n            command += \"Filter(\";\n            command += field + \".MEMBERS\";\n            command += kendo.format(filterFunctionFormats[operator], field, value);\n            command += \")\";\n          }\n\n          return command;\n        }\n\n        function serializeFilters(filter, cube) {\n          var command = \"\",\n              current;\n          var filters = filter.filters;\n          var length = filters.length;\n          var idx;\n\n          for (idx = length - 1; idx >= 0; idx--) {\n            current = \"SELECT (\";\n            current += serializeExpression(filters[idx]);\n            current += \") ON 0\";\n\n            if (idx == length - 1) {\n              current += \" FROM [\" + cube + \"]\";\n              command = current;\n            } else {\n              command = current + \" FROM ( \" + command + \" )\";\n            }\n          }\n\n          return command;\n        }\n\n        function serializeOptions(parentTagName, options, capitalize) {\n          var result = \"\";\n\n          if (options) {\n            result += \"<\" + parentTagName + \">\";\n            var value;\n\n            for (var key in options) {\n              value = options[key];\n\n              if (capitalize) {\n                key = key.replace(/([A-Z]+(?=$|[A-Z][a-z])|[A-Z]?[a-z]+)/g, \"$1_\").toUpperCase().replace(/_$/, \"\");\n              }\n\n              result += \"<\" + key + \">\" + value + \"</\" + key + \">\";\n            }\n\n            result += \"</\" + parentTagName + \">\";\n          } else {\n            result += \"<\" + parentTagName + \"/>\";\n          }\n\n          return result;\n        }\n\n        var xmlaDiscoverCommands = {\n          schemaCubes: \"MDSCHEMA_CUBES\",\n          schemaCatalogs: \"DBSCHEMA_CATALOGS\",\n          schemaMeasures: \"MDSCHEMA_MEASURES\",\n          schemaDimensions: \"MDSCHEMA_DIMENSIONS\",\n          schemaHierarchies: \"MDSCHEMA_HIERARCHIES\",\n          schemaLevels: \"MDSCHEMA_LEVELS\",\n          schemaMembers: \"MDSCHEMA_MEMBERS\",\n          schemaKPIs: \"MDSCHEMA_KPIS\"\n        };\n        var convertersMap = {\n          read: function (options) {\n            var command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>';\n            command += \"SELECT NON EMPTY {\";\n            var columns = options.columns || [];\n            var rows = options.rows || [];\n            var measures = options.measures || [];\n            var measuresRowAxis = options.measuresAxis === \"rows\";\n            var sort = options.sort || [];\n\n            if (!columns.length && rows.length && (!measures.length || measures.length && measuresRowAxis)) {\n              columns = rows;\n              rows = [];\n              measuresRowAxis = false;\n            }\n\n            if (!columns.length && !rows.length) {\n              measuresRowAxis = false;\n            }\n\n            if (columns.length) {\n              command += serializeMembers(columns, !measuresRowAxis ? measures : [], sort);\n            } else if (measures.length && !measuresRowAxis) {\n              command += measureNames(measures).join(\",\");\n            }\n\n            command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON COLUMNS\";\n\n            if (rows.length || measuresRowAxis && measures.length > 1) {\n              command += \", NON EMPTY {\";\n\n              if (rows.length) {\n                command += serializeMembers(rows, measuresRowAxis ? measures : [], sort);\n              } else {\n                command += measureNames(measures).join(\",\");\n              }\n\n              command += \"} DIMENSION PROPERTIES CHILDREN_CARDINALITY, PARENT_UNIQUE_NAME ON ROWS\";\n            }\n\n            if (options.filter) {\n              command += \" FROM \";\n              command += \"(\";\n              command += serializeFilters(options.filter, options.connection.cube);\n              command += \")\";\n            } else {\n              command += \" FROM [\" + options.connection.cube + \"]\";\n            }\n\n            if (measures.length == 1 && columns.length) {\n              command += \" WHERE (\" + measureNames(measures).join(\",\") + \")\";\n            }\n\n            command += '</Statement></Command><Properties><PropertyList><Catalog>' + options.connection.catalog + '</Catalog><Format>Multidimensional</Format></PropertyList></Properties></Execute></Body></Envelope>';\n            return command.replace(/\\&/g, \"&amp;\");\n          },\n          discover: function (options) {\n            options = options || {};\n            var command = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\">';\n            command += \"<RequestType>\" + (xmlaDiscoverCommands[options.command] || options.command) + \"</RequestType>\";\n            command += \"<Restrictions>\" + serializeOptions(\"RestrictionList\", options.restrictions, true) + \"</Restrictions>\";\n\n            if (options.connection && options.connection.catalog) {\n              options.properties = $.extend({}, {\n                Catalog: options.connection.catalog\n              }, options.properties);\n            }\n\n            command += \"<Properties>\" + serializeOptions(\"PropertyList\", options.properties) + \"</Properties>\";\n            command += '</Discover></Body></Envelope>';\n            return command;\n          }\n        };\n        var XmlaTransport = kendo.data.RemoteTransport.extend({\n          init: function (options) {\n            var originalOptions = options;\n            options = this.options = extend(true, {}, this.options, options);\n            kendo.data.RemoteTransport.call(this, options);\n\n            if (isFunction(originalOptions.discover)) {\n              this.discover = originalOptions.discover;\n            } else if (typeof originalOptions.discover === \"string\") {\n              this.options.discover = {\n                url: originalOptions.discover\n              };\n            } else if (!originalOptions.discover) {\n              this.options.discover = this.options.read;\n            }\n          },\n          setup: function (options, type) {\n            options.data = options.data || {};\n            $.extend(true, options.data, {\n              connection: this.options.connection\n            });\n            return kendo.data.RemoteTransport.fn.setup.call(this, options, type);\n          },\n          options: {\n            read: {\n              dataType: \"text\",\n              contentType: \"text/xml\",\n              type: \"POST\"\n            },\n            discover: {\n              dataType: \"text\",\n              contentType: \"text/xml\",\n              type: \"POST\"\n            },\n            parameterMap: function (options, type) {\n              return convertersMap[type](options, type);\n            }\n          },\n          discover: function (options) {\n            return $.ajax(this.setup(options, \"discover\"));\n          }\n        });\n        var XmlaTransportV2 = Class.extend({\n          init: function (options) {\n            options = this.options = extend(true, {}, this.options, options);\n          },\n          setup: function (options) {\n            return $.extend(true, options || {}, {\n              connection: this.options.connection\n            });\n          },\n          read: function (options) {\n            var that = this,\n                success,\n                error;\n            var fetchOptions = that.setup(options.data, READ);\n            success = options.success || $.noop;\n            error = options.error || $.noop;\n\n            if (options.parameterMap) {\n              fetchOptions = that.parameterMap(fetchOptions, READ);\n            }\n\n            fetchData({\n              url: that.options.read\n            }, fetchOptions).then(createDataState).then(function (newDataState) {\n              success(newDataState);\n            }).catch(function (err) {\n              error(err);\n            });\n          },\n          catalog: function (val) {\n            var options = this.options || {};\n\n            if (val === undefined) {\n              return (options.connection || {}).catalog;\n            }\n\n            var connection = options.connection || {};\n            connection.catalog = val;\n            this.options.connection = connection;\n            $.extend(this.transport.options, {\n              connection: connection\n            });\n          },\n          cube: function (val) {\n            var options = this.options || {};\n\n            if (val === undefined) {\n              return (options.connection || {}).cube;\n            }\n\n            var connection = options.connection || {};\n            connection.cube = val;\n            this.options.connection = connection;\n            extend(true, this.transport.options, {\n              connection: connection\n            });\n          },\n          discover: function (options) {\n            return fetchDiscover({\n              url: this.options.read\n            }, options);\n          }\n        });\n\n        function asArray(object) {\n          if (object == null) {\n            return [];\n          }\n\n          var type = toString.call(object);\n\n          if (type !== \"[object Array]\") {\n            return [object];\n          }\n\n          return object;\n        }\n\n        function translateAxis(axis) {\n          var result = {\n            tuples: []\n          };\n          var tuples = asArray(kendo.getter(\"Tuples.Tuple\", true)(axis));\n          var captionGetter = kendo.getter(\"Caption['#text']\");\n          var unameGetter = kendo.getter(\"UName['#text']\");\n          var levelNameGetter = kendo.getter(\"LName['#text']\");\n          var levelNumGetter = kendo.getter(\"LNum['#text']\");\n          var childrenGetter = kendo.getter(\"CHILDREN_CARDINALITY['#text']\", true);\n          var hierarchyGetter = kendo.getter(\"['@Hierarchy']\");\n          var parentNameGetter = kendo.getter(\"PARENT_UNIQUE_NAME['#text']\", true);\n\n          for (var idx = 0; idx < tuples.length; idx++) {\n            var members = [];\n            var member = asArray(tuples[idx].Member);\n\n            for (var memberIdx = 0; memberIdx < member.length; memberIdx++) {\n              members.push({\n                children: [],\n                caption: captionGetter(member[memberIdx]),\n                name: unameGetter(member[memberIdx]),\n                levelName: levelNameGetter(member[memberIdx]),\n                levelNum: levelNumGetter(member[memberIdx]),\n                hasChildren: parseInt(childrenGetter(member[memberIdx]), 10) > 0,\n                parentName: parentNameGetter(member[memberIdx]),\n                hierarchy: hierarchyGetter(member[memberIdx])\n              });\n            }\n\n            result.tuples.push({\n              members: members\n            });\n          }\n\n          return result;\n        }\n\n        var schemaDataReaderMap = {\n          cubes: {\n            name: kendo.getter(\"CUBE_NAME['#text']\", true),\n            caption: kendo.getter(\"CUBE_CAPTION['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true),\n            type: kendo.getter(\"CUBE_TYPE['#text']\", true)\n          },\n          catalogs: {\n            name: kendo.getter(\"CATALOG_NAME['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true)\n          },\n          measures: {\n            name: kendo.getter(\"MEASURE_NAME['#text']\", true),\n            caption: kendo.getter(\"MEASURE_CAPTION['#text']\", true),\n            uniqueName: kendo.getter(\"MEASURE_UNIQUE_NAME['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true),\n            aggregator: kendo.getter(\"MEASURE_AGGREGATOR['#text']\", true),\n            groupName: kendo.getter(\"MEASUREGROUP_NAME['#text']\", true),\n            displayFolder: kendo.getter(\"MEASURE_DISPLAY_FOLDER['#text']\", true),\n            defaultFormat: kendo.getter(\"DEFAULT_FORMAT_STRING['#text']\", true)\n          },\n          kpis: {\n            name: kendo.getter(\"KPI_NAME['#text']\", true),\n            caption: kendo.getter(\"KPI_CAPTION['#text']\", true),\n            value: kendo.getter(\"KPI_VALUE['#text']\", true),\n            goal: kendo.getter(\"KPI_GOAL['#text']\", true),\n            status: kendo.getter(\"KPI_STATUS['#text']\", true),\n            trend: kendo.getter(\"KPI_TREND['#text']\", true),\n            statusGraphic: kendo.getter(\"KPI_STATUS_GRAPHIC['#text']\", true),\n            trendGraphic: kendo.getter(\"KPI_TREND_GRAPHIC['#text']\", true),\n            description: kendo.getter(\"KPI_DESCRIPTION['#text']\", true),\n            groupName: kendo.getter(\"MEASUREGROUP_NAME['#text']\", true)\n          },\n          dimensions: {\n            name: kendo.getter(\"DIMENSION_NAME['#text']\", true),\n            caption: kendo.getter(\"DIMENSION_CAPTION['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true),\n            uniqueName: kendo.getter(\"DIMENSION_UNIQUE_NAME['#text']\", true),\n            defaultHierarchy: kendo.getter(\"DEFAULT_HIERARCHY['#text']\", true),\n            type: kendo.getter(\"DIMENSION_TYPE['#text']\", true) //unknown = 0; time = 1; measure = 2; other = 3; quantitative = 5; accounts = 6; customers = 7; products = 8; scenario = 9; utility = 10; currency = 11; rates = 12; channel = 13; promotion = 14; organization = 15; billOfMaterials = 16; geography = 17;\n\n          },\n          hierarchies: {\n            name: kendo.getter(\"HIERARCHY_NAME['#text']\", true),\n            caption: kendo.getter(\"HIERARCHY_CAPTION['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true),\n            uniqueName: kendo.getter(\"HIERARCHY_UNIQUE_NAME['#text']\", true),\n            dimensionUniqueName: kendo.getter(\"DIMENSION_UNIQUE_NAME['#text']\", true),\n            displayFolder: kendo.getter(\"HIERARCHY_DISPLAY_FOLDER['#text']\", true),\n            origin: kendo.getter(\"HIERARCHY_ORIGIN['#text']\", true),\n            defaultMember: kendo.getter(\"DEFAULT_MEMBER['#text']\", true)\n          },\n          levels: {\n            name: kendo.getter(\"LEVEL_NAME['#text']\", true),\n            caption: kendo.getter(\"LEVEL_CAPTION['#text']\", true),\n            description: kendo.getter(\"DESCRIPTION['#text']\", true),\n            uniqueName: kendo.getter(\"LEVEL_UNIQUE_NAME['#text']\", true),\n            dimensionUniqueName: kendo.getter(\"DIMENSION_UNIQUE_NAME['#text']\", true),\n            displayFolder: kendo.getter(\"LEVEL_DISPLAY_FOLDER['#text']\", true),\n            orderingProperty: kendo.getter(\"LEVEL_ORDERING_PROPERTY['#text']\", true),\n            origin: kendo.getter(\"LEVEL_ORIGIN['#text']\", true),\n            hierarchyUniqueName: kendo.getter(\"HIERARCHY_UNIQUE_NAME['#text']\", true)\n          },\n          members: {\n            name: kendo.getter(\"MEMBER_NAME['#text']\", true),\n            caption: kendo.getter(\"MEMBER_CAPTION['#text']\", true),\n            uniqueName: kendo.getter(\"MEMBER_UNIQUE_NAME['#text']\", true),\n            dimensionUniqueName: kendo.getter(\"DIMENSION_UNIQUE_NAME['#text']\", true),\n            hierarchyUniqueName: kendo.getter(\"HIERARCHY_UNIQUE_NAME['#text']\", true),\n            levelUniqueName: kendo.getter(\"LEVEL_UNIQUE_NAME['#text']\", true),\n            childrenCardinality: kendo.getter(\"CHILDREN_CARDINALITY['#text']\", true)\n          }\n        };\n        var xmlaReaderMethods = [\"axes\", \"catalogs\", \"cubes\", \"dimensions\", \"hierarchies\", \"levels\", \"measures\"];\n        var XmlaDataReader = kendo.data.XmlDataReader.extend({\n          init: function (options) {\n            kendo.data.XmlDataReader.call(this, options);\n\n            this._extend(options);\n          },\n          _extend: function (options) {\n            var idx = 0;\n            var length = xmlaReaderMethods.length;\n            var methodName;\n            var option;\n\n            for (; idx < length; idx++) {\n              methodName = xmlaReaderMethods[idx];\n              option = options[methodName];\n\n              if (option && option !== identity) {\n                this[methodName] = option;\n              }\n            }\n          },\n          parse: function (xml) {\n            var result = kendo.data.XmlDataReader.fn.parse(xml.replace(/<(\\/?)(\\w|-)+:/g, \"<$1\"));\n            return kendo.getter(\"['Envelope']['Body']\", true)(result);\n          },\n          errors: function (root) {\n            var fault = kendo.getter(\"['Fault']\", true)(root);\n\n            if (fault) {\n              return [{\n                faultstring: kendo.getter(\"faultstring['#text']\", true)(fault),\n                faultcode: kendo.getter(\"faultcode['#text']\", true)(fault)\n              }];\n            }\n\n            return null;\n          },\n          axes: function (root) {\n            root = kendo.getter(\"ExecuteResponse[\\\"return\\\"].root\", true)(root);\n            var axes = asArray(kendo.getter(\"Axes.Axis\", true)(root));\n            var axis;\n            var result = {\n              columns: {},\n              rows: {}\n            };\n\n            for (var idx = 0; idx < axes.length; idx++) {\n              axis = axes[idx];\n\n              if (axis[\"@name\"].toLowerCase() !== \"sliceraxis\") {\n                if (!result.columns.tuples) {\n                  result.columns = translateAxis(axis);\n                } else {\n                  result.rows = translateAxis(axis);\n                }\n              }\n            }\n\n            return result;\n          },\n          data: function (root) {\n            root = kendo.getter(\"ExecuteResponse[\\\"return\\\"].root\", true)(root);\n            var cells = asArray(kendo.getter(\"CellData.Cell\", true)(root));\n            var result = [];\n            var ordinalGetter = kendo.getter(\"['@CellOrdinal']\");\n            var valueGetter = kendo.getter(\"Value['#text']\");\n            var fmtValueGetter = kendo.getter(\"FmtValue['#text']\");\n\n            for (var idx = 0; idx < cells.length; idx++) {\n              result.push({\n                value: valueGetter(cells[idx]),\n                fmtValue: fmtValueGetter(cells[idx]),\n                ordinal: parseInt(ordinalGetter(cells[idx]), 10)\n              });\n            }\n\n            return result;\n          },\n          _mapSchema: function (root, getters) {\n            root = kendo.getter(\"DiscoverResponse[\\\"return\\\"].root\", true)(root);\n            var rows = asArray(kendo.getter(\"row\", true)(root));\n            var result = [];\n\n            for (var idx = 0; idx < rows.length; idx++) {\n              var obj = {};\n\n              for (var key in getters) {\n                obj[key] = getters[key](rows[idx]);\n              }\n\n              result.push(obj);\n            }\n\n            return result;\n          },\n          measures: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.measures);\n          },\n          kpis: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.kpis);\n          },\n          hierarchies: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.hierarchies);\n          },\n          levels: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.levels);\n          },\n          dimensions: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.dimensions);\n          },\n          cubes: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.cubes);\n          },\n          catalogs: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.catalogs);\n          },\n          members: function (root) {\n            return this._mapSchema(root, schemaDataReaderMap.members);\n          }\n        });\n        extend(true, kendo.data, {\n          PivotDataSource: PivotDataSource,\n          PivotDataSourceV2: PivotDataSourceV2,\n          XmlaTransport: XmlaTransport,\n          XmlaDataReader: XmlaDataReader,\n          PivotCubeBuilder: PivotCubeBuilder,\n          transports: {\n            xmla: XmlaTransport\n          },\n          readers: {\n            xmla: XmlaDataReader\n          }\n        });\n\n        var sortExpr = function (expressions, name) {\n          if (!expressions) {\n            return null;\n          }\n\n          for (var idx = 0, length = expressions.length; idx < length; idx++) {\n            if (expressions[idx].field === name) {\n              return expressions[idx];\n            }\n          }\n\n          return null;\n        };\n\n        var removeExpr = function (expressions, name) {\n          var result = [];\n\n          for (var idx = 0, length = expressions.length; idx < length; idx++) {\n            if (expressions[idx].field !== name) {\n              result.push(expressions[idx]);\n            }\n          }\n\n          return result;\n        };\n\n        kendo.ui.PivotSettingTarget = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that.element.addClass(\"k-pivot-setting\");\n            that.dataSource = kendo.data.PivotDataSource.create(options.dataSource);\n            that._refreshHandler = that.refresh.bind(that);\n            that.dataSource.first(CHANGE, that._refreshHandler);\n\n            if (!options.template) {\n              var actions = '';\n\n              if (that.options.enabled) {\n                actions = '<span class=\"k-setting-delete k-chip-action\"><span class=\"k-icon k-i-close\"></span></span>';\n              }\n\n              that.options.template = '' + '<span class=\"k-chip k-chip-md k-rounded-full k-chip-solid k-chip-solid-base\" data-' + kendo.ns + 'name=\"${data.name || data}\">' + '<span class=\"k-chip-content\">' + '<span class=\"k-chip-text\">${data.name || data}</span>' + '</span>' + '<span class=\"k-chip-actions\">' + actions + '</span>' + '</span>';\n            }\n\n            that.template = kendo.template(that.options.template);\n            that.emptyTemplate = kendo.template(that.options.emptyTemplate);\n\n            that._sortable();\n\n            that.element.on(\"click\" + NS, '.k-chip, .k-button', function (e) {\n              var target = $(e.target);\n              var action = target.closest('.k-chip-action');\n              var name = target.closest(\"[\" + kendo.attr(\"name\") + \"]\").attr(kendo.attr(\"name\"));\n\n              if (!name) {\n                return;\n              }\n\n              if (action.hasClass(\"k-setting-delete\")) {\n                that.remove(name);\n                return;\n              }\n\n              if (target.closest('.k-chip-actions').length > 0) {\n                return;\n              }\n\n              if (that.options.sortable) {\n                var sortDirection = $(e.currentTarget).find('.k-i-sort-asc-sm').length ? 'desc' : 'asc';\n                that.sort({\n                  field: name,\n                  dir: sortDirection\n                });\n              }\n            });\n\n            if (options.filterable || options.sortable) {\n              that.fieldMenu = new ui.PivotFieldMenu(that.element, {\n                messages: that.options.messages.fieldMenu,\n                filter: \".k-setting-fieldmenu\",\n                filterable: options.filterable,\n                sortable: options.sortable,\n                dataSource: that.dataSource\n              });\n            }\n\n            that.refresh();\n          },\n          options: {\n            name: \"PivotSettingTarget\",\n            template: null,\n            filterable: false,\n            sortable: false,\n            emptyTemplate: \"<div class='k-empty'>${data}</div>\",\n            setting: \"columns\",\n            enabled: true,\n            messages: {\n              empty: \"Drop Fields Here\"\n            }\n          },\n          setDataSource: function (dataSource) {\n            this.dataSource.unbind(CHANGE, this._refreshHandler);\n            this.dataSource = this.options.dataSource = dataSource;\n\n            if (this.fieldMenu) {\n              this.fieldMenu.setDataSource(dataSource);\n            }\n\n            dataSource.first(CHANGE, this._refreshHandler);\n            this.refresh();\n          },\n          _sortable: function () {\n            var that = this;\n\n            if (that.options.enabled) {\n              this.sortable = this.element.kendoSortable({\n                connectWith: this.options.connectWith,\n                hint: that.options.hint,\n                filter: \">*:not(.k-empty)\",\n                cursor: \"move\",\n                start: function (e) {\n                  e.item.trigger(\"focus\").trigger(\"blur\");\n                },\n                change: function (e) {\n                  var name = e.item.attr(kendo.attr(\"name\"));\n\n                  if (e.action == \"receive\") {\n                    that.add(name);\n                  } else if (e.action == \"remove\") {\n                    that.remove(name);\n                  } else if (e.action == \"sort\") {\n                    that.move(name, e.newIndex);\n                  }\n                }\n              }).data(\"kendoSortable\");\n            }\n          },\n          _isKPI: function (data) {\n            return data.type === \"kpi\" || data.measure;\n          },\n          validate: function (data) {\n            var isMeasure = data.type == 2 || \"aggregator\" in data || this._isKPI(data);\n\n            if (isMeasure) {\n              return this.options.setting === \"measures\";\n            }\n\n            if (this.options.setting === \"measures\") {\n              return isMeasure;\n            }\n\n            var items = this.dataSource[this.options.setting]();\n            var name = data.defaultHierarchy || data.uniqueName;\n\n            if (indexOf(name, items) > -1) {\n              return false;\n            }\n\n            items = this.dataSource[this.options.setting === \"columns\" ? \"rows\" : \"columns\"]();\n\n            if (indexOf(name, items) > -1) {\n              return false;\n            }\n\n            return true;\n          },\n          add: function (name) {\n            var items = this.dataSource[this.options.setting]();\n            var i, l;\n            name = Array.isArray(name) ? name.slice(0) : [name];\n\n            for (i = 0, l = name.length; i < l; i++) {\n              if (indexOf(name[i], items) !== -1) {\n                name.splice(i, 1);\n                i -= 1;\n                l -= 1;\n              }\n            }\n\n            if (name.length) {\n              items = items.concat(name);\n              this.dataSource[this.options.setting](items);\n            }\n          },\n          move: function (name, index) {\n            var items = this.dataSource[this.options.setting]();\n            var idx = indexOf(name, items);\n\n            if (idx > -1) {\n              name = items.splice(idx, 1)[0];\n              items.splice(index, 0, name);\n              this.dataSource[this.options.setting](items);\n            }\n          },\n          remove: function (name) {\n            var items = this.dataSource[this.options.setting]();\n            var idx = indexOf(name, items);\n            var sortExpressions = this.dataSource.sort();\n            var filter = this.dataSource.filter();\n\n            if (idx > -1) {\n              if (filter) {\n                filter.filters = removeExpr(filter.filters, name);\n                this.dataSource._filter.filters = filter.filters;\n\n                if (!filter.filters.length) {\n                  this.dataSource._filter = null;\n                }\n              }\n\n              if (sortExpressions) {\n                sortExpressions = removeExpr(sortExpressions, name);\n                this.dataSource._sort = sortExpressions;\n              }\n\n              items.splice(idx, 1);\n              this.dataSource[this.options.setting](items);\n            }\n          },\n          sort: function (expr) {\n            var sortable = this.options.sortable;\n            var allowUnsort = sortable === true || sortable.allowUnsort;\n            var skipExpr = allowUnsort && expr.dir === \"asc\";\n            var expressions = this.dataSource.sort() || [];\n            var result = removeExpr(expressions, expr.field);\n\n            if (skipExpr && expressions.length !== result.length) {\n              expr = null;\n            }\n\n            if (expr) {\n              result.push(expr);\n            }\n\n            this.dataSource.sort(result);\n          },\n          refresh: function () {\n            var html = \"\";\n            var items = this.dataSource[this.options.setting]();\n            var length = items.length;\n            var idx = 0;\n            var item;\n\n            if (length) {\n              for (; idx < length; idx++) {\n                item = items[idx];\n                item = item.name === undefined ? {\n                  name: item\n                } : item;\n                html += this.template(extend({\n                  sortIcon: this._sortIcon(item.name)\n                }, item));\n              }\n            } else {\n              html = this.emptyTemplate(this.options.messages.empty);\n            }\n\n            this.element.html(html);\n          },\n          destroy: function () {\n            Widget.fn.destroy.call(this);\n            this.dataSource.unbind(CHANGE, this._refreshHandler);\n            this.element.off(NS);\n\n            if (this.sortable) {\n              this.sortable.destroy();\n            }\n\n            if (this.fieldMenu) {\n              this.fieldMenu.destroy();\n            }\n\n            this.element = null;\n            this._refreshHandler = null;\n          },\n          _sortIcon: function (name) {\n            var expressions = this.dataSource.sort();\n            var expr = sortExpr(expressions, getName(name));\n            var icon = \"\";\n\n            if (expr) {\n              icon = \"k-i-sort-\" + expr.dir;\n            }\n\n            return icon;\n          }\n        });\n        kendo.ui.PivotSettingTargetV2 = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that.dataSource = kendo.data.PivotDataSourceV2.create(options.dataSource);\n            that._refreshHandler = that.refresh.bind(that);\n            that.dataSource.first(CHANGE, that._refreshHandler);\n            that.template = kendo.template(that.options.template);\n\n            that._sortable();\n\n            that.element.on(\"click\" + NS, \".k-i-close-circle\", function (e) {\n              var target = $(e.target);\n              var parent = target.closest(\".k-chip\");\n              var name = parent.find(\".k-chip-label\").text();\n\n              if (!name) {\n                return;\n              }\n\n              that.remove(name);\n              parent.remove();\n              that.trigger(\"remove\", {\n                name: name\n              });\n            });\n\n            if (options.filterable || options.sortable) {\n              that.fieldMenu = new ui.PivotFieldMenuV2(that.element, {\n                messages: that.options.messages.fieldMenu,\n                filterable: options.filterable,\n                filter: \".k-i-more-vertical\",\n                sortable: options.sortable,\n                dataSource: that.dataSource\n              });\n            }\n\n            that.refresh();\n          },\n          events: [\"remove\"],\n          options: {\n            name: \"PivotSettingTargetV2\",\n            template: null,\n            filterable: false,\n            sortable: false,\n            setting: \"columns\",\n            enabled: true,\n            messages: {\n              empty: \"Drop Fields Here\"\n            }\n          },\n          setDataSource: function (dataSource) {\n            this.dataSource.unbind(CHANGE, this._refreshHandler);\n            this.dataSource = this.options.dataSource = dataSource;\n\n            if (this.fieldMenu) {\n              this.fieldMenu.setDataSource(dataSource);\n            }\n\n            dataSource.first(CHANGE, this._refreshHandler);\n            this.refresh();\n          },\n          _applyState: function () {\n            if (this._sortState !== undefined) {\n              this.dataSource._sort = this._sortState;\n              this._sortState = undefined;\n            }\n\n            if (this._stateFilter !== undefined) {\n              this.dataSource._filter = this._stateFilter;\n              this._stateFilter = undefined;\n            }\n\n            this.dataSource[\"_\" + this.options.setting] = this.options.setting === \"measures\" ? normalizeMeasures(this._savedState) : normalizeMembers(this._savedState);\n          },\n          _cancelChanges: function () {\n            this._sortState = undefined;\n            this._stateFilter = undefined;\n            this._savedState = kendo.deepExtend([], this._initialState);\n\n            this._redraw();\n          },\n          _state: function (newState, modifyInit) {\n            var that = this;\n\n            if (!newState) {\n              return that._savedState || [];\n            } else {\n              if (!that._savedState || modifyInit) {\n                that._initialState = kendo.deepExtend([], newState);\n              }\n\n              that._savedState = kendo.deepExtend([], newState);\n            }\n          },\n          _sortable: function () {\n            var that = this;\n            this.sortable = this.element.kendoSortable({\n              connectWith: this.options.connectWith,\n              hint: that.options.hint,\n              filter: \">*:not(.k-empty)\",\n              cursor: \"move\",\n              start: function (e) {\n                e.item.focus().blur();\n              },\n              change: function (e) {\n                var name = e.item.find(\".k-chip-label\").text();\n\n                if (e.action == \"receive\") {\n                  that.add(name);\n                } else if (e.action == \"remove\") {\n                  that.remove(name);\n                } else if (e.action == \"sort\") {\n                  that.move(name, e.newIndex);\n                }\n              }\n            }).data(\"kendoSortable\");\n          },\n          add: function (name) {\n            var items = this._state();\n\n            var i, l;\n            name = Array.isArray(name) ? name.slice(0) : [name];\n\n            for (i = 0, l = name.length; i < l; i++) {\n              if (indexOf(name[i], items) !== -1) {\n                name.splice(i, 1);\n                i -= 1;\n                l -= 1;\n              }\n            }\n\n            if (name.length) {\n              items = items.concat(name);\n\n              this._state(items);\n\n              this._redraw();\n            }\n          },\n          move: function (name, index) {\n            var items = this._state();\n\n            var idx = indexOf(name, items);\n\n            if (idx > -1) {\n              name = items.splice(idx, 1)[0];\n              items.splice(index, 0, name);\n\n              this._state(items);\n\n              this._redraw();\n            }\n          },\n          remove: function (name) {\n            var items = this._state();\n\n            var idx = indexOf(name, items);\n            var sortExpressions = this.dataSource.sort();\n            var filter = this.dataSource.filter();\n\n            if (idx > -1) {\n              if (filter) {\n                filter.filters = removeExpr(filter.filters, name);\n                this._savedFilter = this.dataSource._filter;\n                this._savedFilter.filters = filter.filters;\n\n                if (!filter.filters.length) {\n                  this._savedFilter = null;\n                }\n              }\n\n              if (sortExpressions) {\n                sortExpressions = removeExpr(sortExpressions, name);\n                this._sortState = sortExpressions;\n              }\n\n              items.splice(idx, 1);\n\n              this._state(items);\n\n              this._redraw();\n            }\n          },\n          _emptyState: function (enable) {\n            var that = this;\n\n            if (enable) {\n              that.element.html(this.options.messages.empty).addClass(\"k-settings-description\").removeClass(\"k-chip-list\");\n            } else {\n              that.element.removeClass(\"k-settings-description\").addClass(\"k-chip-list\");\n            }\n          },\n          _redraw: function () {\n            var items = this._state() || [];\n\n            this._emptyState(!items.length);\n\n            if (items.length) {\n              this.element.html(this._targetsHTML(items));\n            }\n          },\n          _targetsHTML: function (items) {\n            var item;\n            var html = \"\";\n            var idx = 0;\n            var options = this.options;\n            var enabled = false;\n\n            if (this.options.setting != \"measures\") {\n              enabled = options.filterable || options.sortable;\n            }\n\n            if (items.length) {\n              for (; idx < items.length; idx++) {\n                item = items[idx];\n                item = item.name === undefined ? {\n                  name: item\n                } : item;\n                html += this.template({\n                  name: item.name,\n                  menuenabled: enabled\n                });\n              }\n            }\n\n            return html;\n          },\n          refresh: function () {\n            if (this.dataSource._preventRefresh) {\n              return;\n            }\n\n            var items = this.dataSource[this.options.setting]();\n\n            this._emptyState(!this._state().length);\n\n            this._state(items, true);\n\n            if (items.length) {\n              this.element.html(this._targetsHTML(items));\n            }\n          },\n          destroy: function () {\n            Widget.fn.destroy.call(this);\n            this.dataSource.unbind(CHANGE, this._refreshHandler);\n            this.element.off(NS);\n\n            if (this.sortable) {\n              this.sortable.destroy();\n            }\n\n            if (this.fieldMenu) {\n              this.fieldMenu.destroy();\n            }\n\n            this.element = null;\n            this._refreshHandler = null;\n          }\n        });\n        var PivotConfiguratorButton = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that.element = $(element);\n\n            that._element();\n\n            that._attachEvents();\n          },\n          options: {\n            name: \"PivotConfiguratorButton\",\n            text: \"Change settings\",\n            configurator: \"\"\n          },\n          destroy: function () {\n            this.element.off(NS);\n          },\n          setOptions: function (options) {\n            var that = this;\n            kendo.deepExtend(that.options, options);\n            this.init(this.element, this.options);\n          },\n          toggle: function () {\n            var attr = kendo.attr(\"role\");\n            var pivotEl = this.element.closest(\"[\" + attr + \"=pivotcontainer]\").find(\"[\" + attr + \"=pivotgridv2]\");\n            var pivot;\n            $(\"#\" + this.options.configurator).toggleClass(\"k-hidden\");\n\n            if (pivotEl.length) {\n              pivot = pivotEl.getKendoPivotGridV2();\n\n              pivot._setContentWidth();\n\n              pivot._updateDimensions();\n            }\n          },\n          _attachEvents: function () {\n            this.element.on(\"click\" + NS, this.toggle.bind(this));\n          },\n          _element: function () {\n            var options = this.options;\n            this.element.addClass(\"k-pivotgrid-configurator-button\");\n            this.element.html(kendo.format(\"<span>{0}<span class='k-icon k-i-gear k-color-inherit'></span></span>\", options.text));\n          }\n        });\n        var PivotContainer = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that.element = $(element);\n            that.options = options;\n\n            that._addClasses();\n          },\n          options: {\n            name: \"PivotContainer\",\n            configuratorPosition: \"left\"\n          },\n          setOptions: function (options) {\n            var that = this;\n            kendo.deepExtend(that.options, options);\n            this.init(this.element, this.options);\n          },\n          _addClasses: function () {\n            var options = this.options;\n            var className;\n            this.element.removeClass(\"k-flex-row k-flex-row-reverse k-flex-column k-flex-column-reverse\");\n\n            switch (options.configuratorPosition) {\n              case \"right\":\n                className = \"k-flex-row\";\n                break;\n\n              case \"left\":\n                className = \"k-flex-row-reverse\";\n                break;\n\n              case \"bottom\":\n                className = \"k-flex-column\";\n                break;\n\n              case \"top\":\n                className = \"k-flex-column-reverse\";\n                break;\n\n              default:\n                className = \"k-flex-row\";\n            }\n\n            this.element.addClass(\"k-d-flex k-pos-relative\").addClass(className);\n          }\n        });\n        var PivotGridV2 = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n\n            that._dataSource();\n\n            that._bindConfigurator();\n\n            that._wrapper();\n\n            that._columnHeadersWrapper = $('<div class=\"k-pivotgrid-column-headers\"></div>');\n            that._rowHeadersWrapper = $('<div class=\"k-pivotgrid-row-headers\"></div>');\n            that._contentWrapper = $('<div class=\"k-pivotgrid-values\"></div>');\n            that.wrapper.append(that._columnHeadersWrapper);\n            that.wrapper.append(that._rowHeadersWrapper);\n            that.wrapper.append(that._contentWrapper);\n            that._columnBuilder = new ColumnRowBuilder({\n              template: this.options.columnHeaderTemplate,\n              axes: \"columns\"\n            });\n            that._rowBuilder = new ColumnRowBuilder({\n              template: this.options.rowHeaderTemplate,\n              axes: \"rows\"\n            });\n            that._contentBuilder = new ContentBuilderV2({\n              template: this.options.dataCellTemplate || DATACELL_TEMPLATE\n            });\n\n            that._scrollable();\n\n            that._rowHeadersWrapper.add(that._columnHeadersWrapper).on(\"click\", \"span.k-icon\", function () {\n              var button = $(this);\n              var path = button.parent().attr(kendo.attr(\"key\"));\n              var expanded = button.hasClass(\"k-i-arrow-chevron-up\");\n              var isRow = button.closest(\".k-pivotgrid-row-headers\").length !== 0;\n              var paths = path.split(\",\");\n              var eventName = expanded ? COLLAPSEMEMBER : EXPANDMEMBER;\n\n              if (that.trigger(eventName, {\n                path: paths,\n                axis: isRow ? \"rows\" : \"columns\"\n              })) {\n                return;\n              }\n\n              var reducerPayLoad = {\n                type: \"HEADERS_ACTION_TOGGLE\",\n                payload: paths,\n                tree: isRow ? that._rowBuilder.getTree() : that._columnBuilder.getTree()\n              };\n              var currentAxes = isRow ? that.dataSource._rows : that.dataSource._columns;\n              var newHeaders = headersReducer(currentAxes, reducerPayLoad);\n              that.dataSource._preventRefresh = true;\n\n              if (isRow) {\n                that.dataSource.rows(newHeaders);\n              } else {\n                that.dataSource.columns(newHeaders);\n              }\n            });\n\n            if (that.options.autoBind) {\n              that.dataSource.fetch();\n            }\n\n            kendo.notify(that);\n          },\n          events: [DATABINDING, DATABOUND, EXPANDMEMBER, COLLAPSEMEMBER],\n          options: {\n            name: \"PivotGridV2\",\n            autoBind: true,\n            height: null,\n            columnWidth: null,\n            configurator: \"\",\n            columnHeaderTemplate: null,\n            rowHeaderTemplate: null,\n            dataCellTemplate: null\n          },\n          destroy: function () {\n            var that = this;\n            Widget.fn.destroy.call(that);\n\n            if (that._windowResizeHandler) {\n              $(window).off(RESIZE + NS, that._windowResizeHandler);\n              that._windowResizeHandler = null;\n            }\n          },\n          _dataSource: function () {\n            var that = this;\n            var dataSource = that.options.dataSource;\n            dataSource = Array.isArray(dataSource) ? {\n              data: dataSource\n            } : dataSource;\n\n            if (that.dataSource && this._refreshHandler) {\n              that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(PROGRESS, that._progressHandler).unbind(ERROR, that._errorHandler);\n            } else {\n              that._refreshHandler = that.refresh.bind(that);\n              that._progressHandler = that._requestStart.bind(that);\n              that._errorHandler = that._error.bind(that);\n            }\n\n            that.dataSource = kendo.data.PivotDataSourceV2.create(dataSource).bind(CHANGE, that._refreshHandler).bind(PROGRESS, that._progressHandler).bind(ERROR, that._errorHandler);\n          },\n          _resize: function () {\n            var that = this;\n            that.wrapper[0].style.setProperty('--kendo-scrollbar-width', kendo.format(\"{0}px\", getScollWidth()));\n          },\n          _scrollable: function () {\n            var that = this;\n            var columnsHeader = that._columnHeadersWrapper;\n            var rowsHeader = that._rowHeadersWrapper;\n\n            that._resize();\n\n            that._windowResizeHandler = that._resize.bind(that);\n\n            that._contentWrapper.scroll(function () {\n              kendo.scrollLeft(columnsHeader, this.scrollLeft);\n              rowsHeader.scrollTop(this.scrollTop);\n            });\n\n            rowsHeader.bind(\"DOMMouseScroll\" + NS + \" mousewheel\" + NS, that._wheelScroll.bind(that));\n            $(window).on(RESIZE + NS, that._windowResizeHandler);\n          },\n          _wheelScroll: function (e) {\n            if (e.ctrlKey) {\n              return;\n            }\n\n            var delta = kendo.wheelDeltaY(e);\n\n            var scrollTop = this._contentWrapper.scrollTop();\n\n            if (delta) {\n              e.preventDefault();\n              $(e.currentTarget).one(\"wheel\" + NS, false);\n\n              this._rowHeadersWrapper.scrollTop(scrollTop + -delta);\n\n              this._contentWrapper.scrollTop(scrollTop + -delta);\n            }\n          },\n          _wrapper: function () {\n            var height = this.options.height;\n            this.wrapper = this.element.addClass(\"k-widget k-pivotgrid\");\n            this.wrapper.append('<span class=\"k-pivotgrid-empty-cell\" />');\n\n            if (height) {\n              this.wrapper.css(\"height\", height);\n            }\n          },\n          _progress: function (toggle) {\n            kendo.ui.progress(this.wrapper, toggle);\n          },\n          _error: function () {\n            this._progress(false);\n          },\n          _requestStart: function () {\n            this._progress(true);\n          },\n          _updateDimensions: function () {\n            var that = this;\n            that.wrapper.css({\n              \"grid-template-columns\": kendo.format(\"{0}px 1fr\", that._rowHeadersWrapper.find(\".k-pivotgrid-table\")[0].offsetWidth),\n              \"grid-template-rows\": kendo.format(\"{0}px 1fr\", that._columnHeadersWrapper.find(\".k-pivotgrid-table\")[0].offsetHeight)\n            });\n          },\n          _setContentWidth: function () {\n            if (!this.options.columnWidth) {\n              return;\n            }\n\n            var contentTable = this._contentWrapper.find(\"table\");\n\n            var columnTable = this._columnHeadersWrapper.children(\"table\");\n\n            var rowLength = contentTable.children(\"colgroup\").children().length;\n            var calculatedWidth = rowLength * this.options.columnWidth;\n            var minWidth = Math.ceil(calculatedWidth / this._contentWrapper.width() * 100);\n\n            if (minWidth < 100) {\n              minWidth = 100;\n            }\n\n            contentTable.add(columnTable).css(\"width\", minWidth + \"%\");\n          },\n          _bindConfigurator: function () {\n            var configurator = this.options.configurator;\n\n            if (configurator) {\n              $(configurator).kendoPivotConfiguratorV2(\"setDataSource\", this.dataSource);\n            }\n          },\n          cellInfoByElement: function (element) {\n            element = $(element);\n            return this.cellInfo(element.index(), element.parent(\"tr\").index());\n          },\n          cellInfo: function (columnIndex, rowIndex) {\n            var contentBuilder = this._contentBuilder;\n            var dataIndex;\n            var dataItem;\n\n            if (columnIndex >= contentBuilder.columnsCount || columnIndex < 0 || rowIndex >= contentBuilder.rowsCount || rowIndex < 0) {\n              return null;\n            }\n\n            dataIndex = rowIndex * contentBuilder.columnsCount + columnIndex;\n            dataItem = contentBuilder.hash[dataIndex < 0 ? 0 : dataIndex];\n            return {\n              columnTuple: dataItem.columnTuple,\n              rowTuple: dataItem.rowTuple,\n              dataItem: dataItem.data\n            };\n          },\n          refresh: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n\n            if (that.trigger(DATABINDING, {\n              action: \"rebind\"\n            })) {\n              return;\n            }\n\n            that._columnBuilder.setTuples(dataSource._columnTuples);\n\n            that._columnHeadersWrapper.html(that._columnBuilder.build());\n\n            that._rowBuilder.setTuples(dataSource._rowTuples);\n\n            that._rowHeadersWrapper.html(that._rowBuilder.build());\n\n            that._contentBuilder.setRowColumnInfo({\n              columnHeaderLeafs: that._columnBuilder.getHeaderLeafs(),\n              rowHeaderLeafs: that._rowBuilder.getHeaderLeafs(),\n              columnHeaderBreadth: that._columnBuilder.getBreadth(),\n              rowHeaderDepth: that._rowBuilder.getBreadth(),\n              data: dataSource._view\n            });\n\n            that._contentWrapper.html(that._contentBuilder.build());\n\n            that._setContentWidth();\n\n            that._updateDimensions();\n\n            that._progress(false);\n\n            that.trigger(DATABOUND);\n          }\n        });\n        ui.plugin(PivotConfiguratorButton);\n        ui.plugin(PivotContainer);\n        ui.plugin(PivotGridV2);\n        var PivotGrid = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            var columnBuilder;\n            var rowBuilder;\n            Widget.fn.init.call(that, element, options);\n\n            that._dataSource();\n\n            that._bindConfigurator();\n\n            that._wrapper();\n\n            that._createLayout();\n\n            that._columnBuilder = columnBuilder = new ColumnBuilder();\n            that._rowBuilder = rowBuilder = new RowBuilder();\n            that._contentBuilder = new ContentBuilder();\n\n            that._templates();\n\n            that.columnsHeader.add(that.rowsHeader).on(\"click\", \"span.k-icon\", function () {\n              var button = $(this);\n              var builder = columnBuilder;\n              var action = \"expandColumn\";\n              var eventName;\n              var path = button.attr(kendo.attr(\"path\"));\n              var eventArgs = {\n                axis: \"columns\",\n                path: $.parseJSON(path)\n              };\n\n              if (button.parent().is(\"td\")) {\n                builder = rowBuilder;\n                action = \"expandRow\";\n                eventArgs.axis = \"rows\";\n              }\n\n              var expanded = button.hasClass(STATE_EXPANDED);\n              var metadata = builder.metadata[path];\n              var request = metadata.expanded === undefined;\n              eventName = expanded ? COLLAPSEMEMBER : EXPANDMEMBER;\n              eventArgs.childrenLoaded = metadata.maxChildren > metadata.children;\n\n              if (that.trigger(eventName, eventArgs)) {\n                return;\n              }\n\n              builder.metadata[path].expanded = !expanded;\n              button.toggleClass(STATE_EXPANDED, !expanded).toggleClass(STATE_COLLAPSED, expanded);\n\n              if (!expanded && request) {\n                that.dataSource[action](eventArgs.path);\n              } else {\n                that.refresh();\n              }\n            });\n\n            that._scrollable();\n\n            if (that.options.autoBind) {\n              that.dataSource.fetch();\n            }\n\n            kendo.notify(that);\n          },\n          events: [DATABINDING, DATABOUND, EXPANDMEMBER, COLLAPSEMEMBER],\n          options: {\n            name: \"PivotGrid\",\n            autoBind: true,\n            reorderable: true,\n            filterable: false,\n            sortable: false,\n            height: null,\n            columnWidth: 100,\n            configurator: \"\",\n            columnHeaderTemplate: null,\n            rowHeaderTemplate: null,\n            dataCellTemplate: null,\n            kpiStatusTemplate: null,\n            kpiTrendTemplate: null,\n            messages: {\n              measureFields: \"Drop Data Fields Here\",\n              columnFields: \"Drop Column Fields Here\",\n              rowFields: \"Drop Rows Fields Here\"\n            }\n          },\n          _templates: function () {\n            var columnTemplate = this.options.columnHeaderTemplate;\n            var rowTemplate = this.options.rowHeaderTemplate;\n            var dataTemplate = this.options.dataCellTemplate;\n            var kpiStatusTemplate = this.options.kpiStatusTemplate;\n            var kpiTrendTemplate = this.options.kpiTrendTemplate;\n            this._columnBuilder.template = kendo.template(columnTemplate || HEADER_TEMPLATE, {\n              useWithBlock: !!columnTemplate\n            });\n            this._contentBuilder.dataTemplate = kendo.template(dataTemplate || DATACELL_TEMPLATE, {\n              useWithBlock: !!dataTemplate\n            });\n            this._contentBuilder.kpiStatusTemplate = kendo.template(kpiStatusTemplate || KPISTATUS_TEMPLATE, {\n              useWithBlock: !!kpiStatusTemplate\n            });\n            this._contentBuilder.kpiTrendTemplate = kendo.template(kpiTrendTemplate || KPITREND_TEMPLATE, {\n              useWithBlock: !!kpiTrendTemplate\n            });\n            this._rowBuilder.template = kendo.template(rowTemplate || HEADER_TEMPLATE, {\n              useWithBlock: !!rowTemplate\n            });\n          },\n          _bindConfigurator: function () {\n            var configurator = this.options.configurator;\n\n            if (configurator) {\n              $(configurator).kendoPivotConfigurator(\"setDataSource\", this.dataSource);\n            }\n          },\n          cellInfoByElement: function (element) {\n            element = $(element);\n            return this.cellInfo(element.index(), element.parent(\"tr\").index());\n          },\n          cellInfo: function (columnIndex, rowIndex) {\n            var contentBuilder = this._contentBuilder;\n            var columnInfo = contentBuilder.columnIndexes[columnIndex || 0];\n            var rowInfo = contentBuilder.rowIndexes[rowIndex || 0];\n            var dataIndex;\n\n            if (!columnInfo || !rowInfo) {\n              return null;\n            }\n\n            dataIndex = rowInfo.index * contentBuilder.rowLength + columnInfo.index;\n            return {\n              columnTuple: columnInfo.tuple,\n              rowTuple: rowInfo.tuple,\n              measure: columnInfo.measure || rowInfo.measure,\n              dataItem: this.dataSource.view()[dataIndex]\n            };\n          },\n          setDataSource: function (dataSource) {\n            this.options.dataSource = dataSource;\n\n            this._dataSource();\n\n            if (this.measuresTarget) {\n              this.measuresTarget.setDataSource(dataSource);\n            }\n\n            if (this.rowsTarget) {\n              this.rowsTarget.setDataSource(dataSource);\n            }\n\n            if (this.columnsTarget) {\n              this.columnsTarget.setDataSource(dataSource);\n            }\n\n            this._bindConfigurator();\n\n            if (this.options.autoBind) {\n              dataSource.fetch();\n            }\n          },\n          setOptions: function (options) {\n            Widget.fn.setOptions.call(this, options);\n\n            this._templates();\n          },\n          destroy: function () {\n            Widget.fn.destroy.call(this);\n            clearTimeout(this._headerReflowTimeout);\n          },\n          _dataSource: function () {\n            var that = this;\n            var dataSource = that.options.dataSource;\n            dataSource = Array.isArray(dataSource) ? {\n              data: dataSource\n            } : dataSource;\n\n            if (that.dataSource && this._refreshHandler) {\n              that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(STATERESET, that._stateResetHandler).unbind(PROGRESS, that._progressHandler).unbind(ERROR, that._errorHandler);\n            } else {\n              that._refreshHandler = that.refresh.bind(that);\n              that._progressHandler = that._requestStart.bind(that);\n              that._stateResetHandler = that._stateReset.bind(that);\n              that._errorHandler = that._error.bind(that);\n            }\n\n            that.dataSource = kendo.data.PivotDataSource.create(dataSource).bind(CHANGE, that._refreshHandler).bind(PROGRESS, that._progressHandler).bind(STATERESET, that._stateResetHandler).bind(ERROR, that._errorHandler);\n          },\n          _error: function () {\n            this._progress(false);\n          },\n          _requestStart: function () {\n            this._progress(true);\n          },\n          _stateReset: function () {\n            this._columnBuilder.reset();\n\n            this._rowBuilder.reset();\n          },\n          _wrapper: function () {\n            var height = this.options.height;\n            this.wrapper = this.element.addClass(\"k-widget k-pivot\");\n\n            if (height) {\n              this.wrapper.css(\"height\", height);\n            }\n          },\n          _measureFields: function () {\n            this.measureFields = $(DIV).addClass(\"k-pivot-toolbar k-toolbar k-settings-measures\");\n            this.measuresTarget = this._createSettingTarget(this.measureFields, {\n              setting: \"measures\",\n              messages: {\n                empty: this.options.messages.measureFields\n              }\n            });\n          },\n          _createSettingTarget: function (element, options) {\n            var template;\n            var sortable = options.sortable;\n            var icons = '';\n\n            if (sortable) {\n              icons += '#if (data.sortIcon) {#';\n              icons += '<span class=\"k-chip-action\"><span class=\"k-icon ${data.sortIcon}-sm\"></span></span>';\n              icons += '#}#';\n            }\n\n            if (options.filterable || sortable) {\n              icons += '<span class=\"k-setting-fieldmenu k-chip-action\"><span class=\"k-icon k-i-more-vertical\"></span></span>';\n            }\n\n            if (this.options.reorderable) {\n              icons += '<span class=\"k-setting-delete k-chip-action\"><span class=\"k-icon k-i-close\"></span></span>';\n            }\n\n            template = '' + '<span class=\"k-chip k-chip-md k-rounded-full k-chip-solid k-chip-solid-base\" tabindex=\"0\" data-' + kendo.ns + 'name=\"${data.name}\">' + '<span class=\"k-chip-content\">' + '<span class=\"k-chip-text\">${data.name}</span>' + '</span>' + '<span class=\"k-chip-actions k-field-actions\">' + icons + '</span>' + '</span>';\n            return new kendo.ui.PivotSettingTarget(element, $.extend({\n              dataSource: this.dataSource,\n              template: template,\n              emptyTemplate: '<span class=\"k-empty\">${data}</span>',\n              enabled: this.options.reorderable\n            }, options));\n          },\n          _initSettingTargets: function () {\n            this.columnsTarget = this._createSettingTarget(this.columnFields, {\n              connectWith: this.rowFields,\n              setting: \"columns\",\n              filterable: this.options.filterable,\n              sortable: this.options.sortable,\n              messages: {\n                empty: this.options.messages.columnFields,\n                fieldMenu: this.options.messages.fieldMenu\n              }\n            });\n            this.rowsTarget = this._createSettingTarget(this.rowFields, {\n              connectWith: this.columnFields,\n              setting: \"rows\",\n              filterable: this.options.filterable,\n              sortable: this.options.sortable,\n              messages: {\n                empty: this.options.messages.rowFields,\n                fieldMenu: this.options.messages.fieldMenu\n              }\n            });\n          },\n          _createLayout: function () {\n            var that = this;\n            var layoutTable = $(LAYOUT_TABLE);\n            var leftContainer = layoutTable.find(\".k-pivot-rowheaders\");\n            var rightContainer = layoutTable.find(\".k-pivot-table\");\n            var gridWrapper = $(DIV).addClass(\"k-grid k-widget\");\n\n            that._measureFields();\n\n            that.columnFields = $(DIV).addClass(\"k-pivot-toolbar k-toolbar k-settings-columns\");\n            that.rowFields = $(DIV).addClass(\"k-pivot-toolbar k-toolbar k-settings-rows\");\n            that.columnsHeader = $('<div class=\"k-grid-header-wrap\" />').wrap('<div class=\"k-grid-header\" />');\n            that.columnsHeader.parent().css(\"padding-right\", kendo.support.scrollbar());\n            that.rowsHeader = $('<div class=\"k-grid k-widget k-alt\"/>');\n            that.content = $('<div class=\"k-grid-content\" />');\n            leftContainer.append(that.measureFields);\n            leftContainer.append(that.rowFields);\n            leftContainer.append(that.rowsHeader);\n            gridWrapper.append(that.columnsHeader.parent());\n            gridWrapper.append(that.content);\n            rightContainer.append(that.columnFields);\n            rightContainer.append(gridWrapper);\n            that.wrapper.append(layoutTable);\n            that.columnsHeaderTree = new kendo.dom.Tree(that.columnsHeader[0]);\n            that.rowsHeaderTree = new kendo.dom.Tree(that.rowsHeader[0]);\n            that.contentTree = new kendo.dom.Tree(that.content[0]);\n\n            that._initSettingTargets();\n          },\n          _progress: function (toggle) {\n            kendo.ui.progress(this.wrapper, toggle);\n          },\n          _resize: function () {\n            if (this.content[0].firstChild) {\n              this._setSectionsWidth();\n\n              this._setSectionsHeight();\n\n              this._setContentWidth();\n\n              this._setContentHeight();\n\n              this._columnHeaderReflow();\n            }\n          },\n          _columnHeaderReflow: function () {\n            var columnTable = this.columnsHeader.children(\"table\");\n\n            if (!kendo.support.browser.mozilla) {\n              return;\n            }\n\n            clearTimeout(this._headerReflowTimeout);\n            columnTable.css(\"table-layout\", \"auto\");\n            this._headerReflowTimeout = setTimeout(function () {\n              columnTable.css(\"table-layout\", \"\");\n            });\n          },\n          _setSectionsWidth: function () {\n            var rowsHeader = this.rowsHeader;\n            var leftColumn = rowsHeader.parent(\".k-pivot-rowheaders\").width(AUTO);\n            var width;\n            width = Math.max(outerWidth(this.measureFields), outerWidth(this.rowFields));\n            width = Math.max(rowsHeader.children(\"table\").width(), width);\n            leftColumn.width(width);\n          },\n          _setSectionsHeight: function () {\n            var measureFieldsHeight = this.measureFields.height(AUTO).height();\n            var columnFieldsHeight = this.columnFields.height(AUTO).height();\n            var rowFieldsHeight = this.rowFields.height(AUTO).innerHeight();\n            var columnsHeight = this.columnsHeader.height(AUTO).innerHeight();\n            var padding = rowFieldsHeight - this.rowFields.height();\n            var firstRowHeight = columnFieldsHeight > measureFieldsHeight ? columnFieldsHeight : measureFieldsHeight;\n            var secondRowHeight = columnsHeight > rowFieldsHeight ? columnsHeight : rowFieldsHeight;\n            this.measureFields.height(firstRowHeight);\n            this.columnFields.height(firstRowHeight);\n            this.rowFields.height(secondRowHeight - padding);\n            this.columnsHeader.height(secondRowHeight);\n          },\n          _setContentWidth: function () {\n            var contentTable = this.content.find(\"table\");\n            var columnTable = this.columnsHeader.children(\"table\");\n            var rowLength = contentTable.children(\"colgroup\").children().length;\n            var calculatedWidth = rowLength * this.options.columnWidth;\n            var minWidth = Math.ceil(calculatedWidth / this.content.width() * 100);\n\n            if (minWidth < 100) {\n              minWidth = 100;\n            }\n\n            contentTable.add(columnTable).css(\"width\", minWidth + \"%\");\n\n            this._resetColspan(columnTable);\n          },\n          _setContentHeight: function () {\n            var that = this;\n            var content = that.content;\n            var rowsHeader = that.rowsHeader;\n            var innerHeight = that.wrapper.innerHeight();\n            var scrollbar = kendo.support.scrollbar();\n            var skipScrollbar = content[0].offsetHeight === content[0].clientHeight;\n            var height = that.options.height;\n\n            if (that.wrapper.is(\":visible\")) {\n              if (!innerHeight || !height) {\n                if (skipScrollbar) {\n                  scrollbar = 0;\n                }\n\n                content.height(\"auto\");\n                rowsHeader.height(content.height() - scrollbar);\n                return;\n              }\n\n              innerHeight -= outerHeight(that.columnFields);\n              innerHeight -= outerHeight(that.columnsHeader.parent());\n\n              if (innerHeight <= scrollbar * 2) {\n                // do not set height if proper scrollbar cannot be displayed\n                innerHeight = scrollbar * 2 + 1;\n\n                if (!skipScrollbar) {\n                  innerHeight += scrollbar;\n                }\n              }\n\n              content.height(innerHeight);\n\n              if (skipScrollbar) {\n                scrollbar = 0;\n              }\n\n              rowsHeader.height(innerHeight - scrollbar);\n            }\n          },\n          _resetColspan: function (columnTable) {\n            var that = this;\n            var cell = columnTable.children(\"tbody\").children().first().children().first();\n\n            if (that._colspan === undefined) {\n              that._colspan = cell.attr(\"colspan\");\n            }\n\n            cell.attr(\"colspan\", 1);\n            clearTimeout(that._layoutTimeout);\n            that._layoutTimeout = setTimeout(function () {\n              cell.attr(\"colspan\", that._colspan);\n              that._colspan = undefined;\n            });\n          },\n          _axisMeasures: function (axis) {\n            var result = [];\n            var dataSource = this.dataSource;\n            var measures = dataSource.measures();\n            var hasMeasure = measures.length > 1 || measures[0] && measures[0].type;\n\n            if (dataSource.measuresAxis() === axis) {\n              if (dataSource[axis]().length === 0 || hasMeasure) {\n                result = measures;\n              }\n            }\n\n            return result;\n          },\n          items: function () {\n            return [];\n          },\n          refresh: function () {\n            var that = this;\n            var dataSource = that.dataSource;\n            var axes = dataSource.axes();\n            var columns = (axes.columns || {}).tuples || [];\n            var rows = (axes.rows || {}).tuples || [];\n            var columnBuilder = that._columnBuilder;\n            var rowBuilder = that._rowBuilder;\n            var columnAxis = {};\n            var rowAxis = {};\n\n            if (that.trigger(DATABINDING, {\n              action: \"rebind\"\n            })) {\n              return;\n            }\n\n            columnBuilder.measures = that._axisMeasures(AXIS_COLUMNS);\n            rowBuilder.measures = that._axisMeasures(AXIS_ROWS);\n            that.columnsHeaderTree.render(columnBuilder.build(columns));\n            that.rowsHeaderTree.render(rowBuilder.build(rows));\n            columnAxis = {\n              indexes: columnBuilder._indexes,\n              measures: columnBuilder.measures,\n              metadata: columnBuilder.metadata\n            };\n            rowAxis = {\n              indexes: rowBuilder._indexes,\n              measures: rowBuilder.measures,\n              metadata: rowBuilder.metadata\n            };\n            that.contentTree.render(that._contentBuilder.build(dataSource.view(), columnAxis, rowAxis));\n\n            that._resize();\n\n            if (that.touchScroller) {\n              that.touchScroller.contentResized();\n            } else {\n              var touchScroller = kendo.touchScroller(that.content);\n\n              if (touchScroller && touchScroller.movable) {\n                that.touchScroller = touchScroller;\n                touchScroller.movable.bind(\"change\", function (e) {\n                  kendo.scrollLeft(that.columnsHeader, -e.sender.x);\n                  that.rowsHeader.scrollTop(-e.sender.y);\n                });\n              }\n            }\n\n            that._progress(false);\n\n            that.trigger(DATABOUND);\n          },\n          _scrollable: function () {\n            var that = this;\n            var columnsHeader = that.columnsHeader;\n            var rowsHeader = that.rowsHeader;\n            that.content.on(\"scroll\", function () {\n              kendo.scrollLeft(columnsHeader, this.scrollLeft);\n              rowsHeader.scrollTop(this.scrollTop);\n            });\n            rowsHeader.on(\"DOMMouseScroll\" + NS + \" mousewheel\" + NS, that._wheelScroll.bind(that));\n          },\n          _wheelScroll: function (e) {\n            if (e.ctrlKey) {\n              return;\n            }\n\n            var delta = kendo.wheelDeltaY(e);\n            var scrollTop = this.content.scrollTop();\n\n            if (delta) {\n              e.preventDefault(); //In Firefox DOMMouseScroll event cannot be canceled\n\n              $(e.currentTarget).one(\"wheel\" + NS, false);\n              this.rowsHeader.scrollTop(scrollTop + -delta);\n              this.content.scrollTop(scrollTop + -delta);\n            }\n          }\n        });\n        var element = kendo.dom.element;\n        var htmlNode = kendo.dom.html;\n\n        var createMetadata = function (levelNum, memberIdx) {\n          return {\n            maxChildren: 0,\n            children: 0,\n            maxMembers: 0,\n            members: 0,\n            measures: 1,\n            levelNum: levelNum,\n            parentMember: memberIdx !== 0\n          };\n        };\n\n        var buildPath = function (tuple, index) {\n          var path = [];\n          var idx = 0;\n\n          for (; idx <= index; idx++) {\n            path.push(tuple.members[idx].name);\n          }\n\n          return path;\n        };\n\n        var tupleName = function (tuple, index) {\n          var name = \"\";\n          var idx = 0;\n\n          for (; idx <= index; idx++) {\n            name += tuple.members[idx].name;\n          }\n\n          return name;\n        };\n\n        var ContentBuilderV2 = Class.extend({\n          init: function (options) {\n            this.template = kendo.template(options.template);\n            this.hash = [];\n          },\n          setRowColumnInfo: function (options) {\n            this.data = options.data;\n            this.columnHeaderLeafs = options.columnHeaderLeafs;\n            this.rowHeaderLeafs = options.rowHeaderLeafs;\n            this.columnHeaderBreadth = options.columnHeaderBreadth;\n            this.rowHeaderDepth = options.rowHeaderDepth;\n            this.hash.length = 0;\n          },\n          addColElements: function (count) {\n            var html = \"\";\n\n            for (var index = 0; index < count; index++) {\n              html += \"<col>\";\n            }\n\n            this.table.find(\"colgroup\").append(html);\n          },\n          addRowElements: function (data) {\n            var that = this;\n            var body = that.table.find(\"tbody\");\n            var row;\n\n            for (var index = 0; index < data.length; index++) {\n              row = $('<tr class=\"k-pivotgrid-row\"></tr>');\n              body.append(row);\n              that.addColumCell(row, data[index], index);\n            }\n\n            this.rowsCount = data.length;\n          },\n          addColumCell: function (rowEl, rowItem, rowIndex) {\n            var that = this;\n\n            for (var index = 0; index < rowItem.cells.length; index++) {\n              var cell = rowItem.cells[index];\n\n              if (cell) {\n                var cellEl = $('<td class=\"k-pivotgrid-cell\"></td>');\n\n                if (this.rowHeaderLeafs[rowIndex].total || this.columnHeaderLeafs[index].total) {\n                  cellEl.addClass(\"k-pivotgrid-header-total\");\n                }\n\n                cellEl.append(that.template({\n                  dataItem: cell.data,\n                  rowTuple: cell.rowTuple,\n                  columnTuple: cell.columnTuple\n                }));\n                this.hash.push(cell);\n                rowEl.append(cellEl);\n              }\n            }\n          },\n          build: function () {\n            var data = toData((this.data || []).slice(), this.columnHeaderLeafs, this.rowHeaderLeafs, this.columnHeaderBreadth, this.rowHeaderDepth);\n            var that = this;\n            var table = $(\"<table class='k-pivotgrid-table'><colgroup></colgroup><tbody class='k-pivotgrid-tbody'></tbody></table>\");\n            that.table = table;\n            that.addColElements(this.columnHeaderLeafs.length);\n            that.addRowElements(data);\n            this.rowsCount = data.length;\n            this.columnsCount = this.columnHeaderLeafs.length;\n            return that.table;\n          }\n        });\n        var ColumnRowBuilder = Class.extend({\n          init: function (options) {\n            this.tuples = options.tuples;\n            this.axes = options.axes;\n            this.headerTemplate = kendo.template(HEADERTEMPLATE);\n\n            if (options.template) {\n              this.template = kendo.template(options.template);\n            }\n          },\n          setTuples: function (tuples) {\n            this.tuples = tuples;\n          },\n          addColElements: function (count) {\n            var html = \"\";\n\n            for (var index = 0; index < count; index++) {\n              html += \"<col>\";\n            }\n\n            this.table.find(\"colgroup\").append(html);\n          },\n          addRowElements: function (columnHeaderRows) {\n            var that = this;\n            var body = that.table.find(\"tbody\");\n            var row;\n\n            for (var index = 0; index < columnHeaderRows.length; index++) {\n              row = $('<tr class=\"k-pivotgrid-row\"></tr>');\n              body.append(row);\n              that.addColumCell(row, columnHeaderRows[index]);\n            }\n          },\n          addColumCell: function (rowEl, rowItem) {\n            var that = this;\n            var cellEl;\n            var cell;\n\n            for (var index = 0; index < rowItem.cells.length; index++) {\n              cell = rowItem.cells[index];\n\n              if (cell) {\n                cellEl = $(that.headerTemplate({\n                  rowspan: cell.rowSpan,\n                  colspan: cell.colSpan,\n                  key: cell.path.join(\",\") + (cell.total ? '|[TOTAL]' : ''),\n                  iconClass: cell.children && cell.children.length ? \"up\" : \"down\",\n                  expandable: cell.hasChildren && !cell.total,\n                  headerClass: kendo.format(\"k-pivotgrid-cell{0}{1}\", cell.total ? \" k-pivotgrid-header-total\" : \"\", cell.levelNum === 0 ? \" k-pivotgrid-header-root\" : \"\")\n                }));\n                cellEl.append(that.template ? that.template({\n                  member: cell\n                }) : cell.caption);\n                rowEl.append(cellEl);\n              }\n            }\n          },\n          build: function () {\n            var tree = toTree((this.tuples || []).slice());\n            var treeData = this.axes == \"columns\" ? toColumns(tree) : toRows(tree);\n            var headerRows = treeData[0];\n            var headerLeafs = treeData[1];\n            var breadth = treeData[2];\n            var rowHeaderBreadth = treeData[3];\n            var that = this;\n            that._tree = tree;\n            that._breadth = breadth;\n            that._headerLeafs = headerLeafs;\n            var table = $(\"<table class='k-pivotgrid-table'><colgroup></colgroup><tbody class='k-pivotgrid-tbody'></tbody></table>\");\n            that.table = table;\n            that.addColElements(this.axes == \"columns\" ? headerLeafs.length : rowHeaderBreadth);\n            that.addRowElements(headerRows);\n            return that.table;\n          },\n          getTree: function () {\n            return this._tree;\n          },\n          getBreadth: function () {\n            return this._breadth;\n          },\n          getHeaderLeafs: function () {\n            return this._headerLeafs;\n          }\n        });\n        var ColumnBuilder = Class.extend({\n          init: function () {\n            this.measures = 1;\n            this.metadata = {};\n          },\n          build: function (tuples) {\n            var tbody = this._tbody(tuples);\n\n            var colgroup = this._colGroup();\n\n            return [element(\"table\", null, [colgroup, tbody])];\n          },\n          reset: function () {\n            this.metadata = {};\n          },\n          _colGroup: function () {\n            var length = this._rowLength();\n\n            var children = [];\n            var idx = 0;\n\n            for (; idx < length; idx++) {\n              children.push(element(\"col\", null));\n            }\n\n            return element(\"colgroup\", null, children);\n          },\n          _tbody: function (tuples) {\n            var root = tuples[0];\n            this.map = {};\n            this.rows = [];\n            this.rootTuple = root;\n            this._indexes = [];\n\n            if (root) {\n              this._buildRows(root, 0);\n\n              this._normalize();\n            } else {\n              this.rows.push(element(\"tr\", null, [element(\"th\", null, [htmlNode(\"&nbsp;\")])]));\n            }\n\n            return element(\"tbody\", null, this.rows);\n          },\n          _normalize: function () {\n            var rows = this.rows;\n            var rowsLength = rows.length;\n            var rowIdx = 0;\n            var row;\n            var cellsLength;\n            var cellIdx;\n            var cells;\n            var cell;\n\n            for (; rowIdx < rowsLength; rowIdx++) {\n              row = rows[rowIdx];\n\n              if (row.rowSpan === 1) {\n                continue;\n              }\n\n              cells = row.children;\n              cellIdx = 0;\n              cellsLength = cells.length;\n\n              for (; cellIdx < cellsLength; cellIdx++) {\n                cell = cells[cellIdx];\n\n                if (cell.tupleAll) {\n                  cell.attr.rowSpan = row.rowSpan;\n                }\n              }\n            }\n          },\n          _rowIndex: function (row) {\n            var rows = this.rows;\n            var length = rows.length;\n            var idx = 0;\n\n            for (; idx < length; idx++) {\n              if (rows[idx] === row) {\n                break;\n              }\n            }\n\n            return idx;\n          },\n          _rowLength: function () {\n            var cells = this.rows[0] ? this.rows[0].children : [];\n            var length = cells.length;\n            var rowLength = 0;\n            var idx = 0;\n\n            if (length) {\n              for (; idx < length; idx++) {\n                rowLength += cells[idx].attr.colSpan || 1;\n              }\n            }\n\n            if (!rowLength) {\n              rowLength = this.measures;\n            }\n\n            return rowLength;\n          },\n          _row: function (tuple, memberIdx, parentMember) {\n            var rootName = this.rootTuple.members[memberIdx].name;\n            var levelNum = tuple.members[memberIdx].levelNum;\n            var rowKey = rootName + levelNum;\n            var map = this.map;\n            var parentRow;\n            var children;\n            var row = map[rowKey];\n\n            if (!row) {\n              row = element(\"tr\", null, []);\n              row.parentMember = parentMember;\n              row.collapsed = 0;\n              row.colSpan = 0;\n              row.rowSpan = 1;\n              map[rowKey] = row;\n              parentRow = map[rootName + (Number(levelNum) - 1)];\n\n              if (parentRow) {\n                children = parentRow.children;\n\n                if (children[1] && children[1].attr.className.indexOf(\"k-alt\") === -1) {\n                  row.notFirst = true;\n                } else {\n                  row.notFirst = parentRow.notFirst;\n                }\n              }\n\n              this.rows.splice(this._rowIndex(parentRow) + 1, 0, row);\n            } else {\n              row.notFirst = false;\n\n              if (!row.parentMember || row.parentMember !== parentMember) {\n                row.parentMember = parentMember;\n                row.collapsed = 0;\n                row.colSpan = 0;\n              }\n            }\n\n            return row;\n          },\n          _measures: function (measures, tuple, className) {\n            var map = this.map;\n            var row = map.measureRow;\n            var measure;\n\n            if (!row) {\n              row = element(\"tr\", null, []);\n              map.measureRow = row;\n              this.rows.push(row);\n            }\n\n            for (var idx = 0, length = measures.length; idx < length; idx++) {\n              measure = measures[idx];\n              row.children.push(this._cell(className || \"\", [this._content(measure, tuple)], measure));\n            }\n\n            return length;\n          },\n          _content: function (member, tuple) {\n            return htmlNode(this.template({\n              member: member,\n              tuple: tuple\n            }));\n          },\n          _cell: function (className, children, member) {\n            var cell = element(\"th\", {\n              className: \"k-header\" + className\n            }, children);\n            cell.value = member.caption || member.name;\n            return cell;\n          },\n          _buildRows: function (tuple, memberIdx, parentMember) {\n            var members = tuple.members;\n            var member = members[memberIdx];\n            var nextMember = members[memberIdx + 1];\n            var row, childRow, children, childrenLength;\n            var cell, allCell, cellAttr;\n            var cellChildren = [];\n            var path;\n            var idx = 0;\n            var metadata;\n            var colSpan;\n            var collapsed = 0;\n            var memberCollapsed = 0;\n\n            if (member.measure) {\n              this._measures(member.children, tuple);\n\n              return;\n            }\n\n            path = kendo.stringify(buildPath(tuple, memberIdx));\n            row = this._row(tuple, memberIdx, parentMember);\n            children = member.children;\n            childrenLength = children.length;\n            metadata = this.metadata[path];\n\n            if (!metadata) {\n              this.metadata[path] = metadata = createMetadata(Number(member.levelNum), memberIdx);\n              metadata.rootLevelNum = Number(this.rootTuple.members[memberIdx].levelNum);\n            }\n\n            this._indexes.push({\n              path: path,\n              tuple: tuple\n            });\n\n            if (member.hasChildren) {\n              if (metadata.expanded === false) {\n                collapsed = metadata.maxChildren;\n                row.collapsed += collapsed;\n                metadata.children = 0;\n                childrenLength = 0;\n              }\n\n              cellAttr = {\n                className: \"k-icon \" + (childrenLength ? STATE_EXPANDED : STATE_COLLAPSED)\n              };\n              cellAttr[kendo.attr(\"path\")] = path;\n              cellChildren.push(element(\"span\", cellAttr));\n            }\n\n            cellChildren.push(this._content(member, tuple));\n            cell = this._cell(row.notFirst ? \" k-first\" : \"\", cellChildren, member);\n            row.children.push(cell);\n            row.colSpan += 1;\n\n            if (childrenLength) {\n              allCell = this._cell(\" k-alt\", [this._content(member, tuple)], member);\n              row.children.push(allCell);\n\n              for (; idx < childrenLength; idx++) {\n                childRow = this._buildRows(children[idx], memberIdx, member);\n              }\n\n              colSpan = childRow.colSpan;\n              collapsed = childRow.collapsed;\n              cell.attr.colSpan = colSpan;\n              metadata.children = colSpan;\n              metadata.members = 1;\n              row.colSpan += colSpan;\n              row.collapsed += collapsed;\n              row.rowSpan = childRow.rowSpan + 1;\n\n              if (nextMember) {\n                if (nextMember.measure) {\n                  colSpan = this._measures(nextMember.children, tuple, \" k-alt\");\n                } else {\n                  childRow = this._buildRows(tuple, memberIdx + 1);\n                  colSpan = childRow.colSpan;\n                  row.collapsed += childRow.collapsed;\n                  memberCollapsed = childRow.collapsed;\n                }\n\n                allCell.attr.colSpan = colSpan;\n                colSpan -= 1;\n                metadata.members += colSpan;\n                row.colSpan += colSpan;\n              }\n            } else if (nextMember) {\n              if (nextMember.measure) {\n                colSpan = this._measures(nextMember.children, tuple);\n              } else {\n                childRow = this._buildRows(tuple, memberIdx + 1);\n                colSpan = childRow.colSpan;\n                row.collapsed += childRow.collapsed;\n                memberCollapsed = childRow.collapsed;\n              }\n\n              metadata.members = colSpan;\n\n              if (colSpan > 1) {\n                cell.attr.colSpan = colSpan;\n                row.colSpan += colSpan - 1;\n              }\n            }\n\n            if (metadata.maxMembers < metadata.members + memberCollapsed) {\n              metadata.maxMembers = metadata.members + memberCollapsed;\n            }\n\n            children = metadata.children + collapsed;\n\n            if (metadata.maxChildren < children) {\n              metadata.maxChildren = children;\n            }\n\n            (allCell || cell).tupleAll = true;\n            return row;\n          }\n        });\n        var RowBuilder = Class.extend({\n          init: function () {\n            this.metadata = {};\n          },\n          build: function (tuples) {\n            var tbody = this._tbody(tuples);\n\n            var colgroup = this._colGroup();\n\n            return [element(\"table\", null, [colgroup, tbody])];\n          },\n          reset: function () {\n            this.metadata = {};\n          },\n          _rowLength: function () {\n            var children = this.rows[0].children;\n            var length = 0;\n            var idx = 0;\n            var cell = children[idx];\n\n            while (cell) {\n              length += cell.attr.colSpan || 1;\n              cell = children[++idx];\n            }\n\n            return length;\n          },\n          _colGroup: function () {\n            var length = this._rowLength();\n\n            var children = [];\n            var idx = 0;\n\n            for (; idx < length; idx++) {\n              children.push(element(\"col\", null));\n            }\n\n            return element(\"colgroup\", null, children);\n          },\n          _tbody: function (tuples) {\n            var root = tuples[0];\n            this.rootTuple = root;\n            this.rows = [];\n            this.map = {};\n            this._indexes = [];\n\n            if (root) {\n              this._buildRows(root, 0);\n\n              this._normalize();\n            } else {\n              this.rows.push(element(\"tr\", null, [element(\"td\", null, [htmlNode(\"&nbsp;\")])]));\n            }\n\n            return element(\"tbody\", null, this.rows);\n          },\n          _normalize: function () {\n            var rows = this.rows;\n            var rowsLength = rows.length;\n            var rowIdx = 0;\n            var members = this.rootTuple.members;\n            var firstMemberName = members[0].name;\n            var membersLength = members.length;\n            var memberIdx = 0;\n            var row;\n            var cell;\n            var maxcolSpan;\n            var map = this.map;\n            var allRow;\n\n            for (; rowIdx < rowsLength; rowIdx++) {\n              row = rows[rowIdx];\n\n              for (memberIdx = 0; memberIdx < membersLength; memberIdx++) {\n                maxcolSpan = this[members[memberIdx].name];\n                cell = row.colSpan[\"dim\" + memberIdx];\n\n                if (cell && cell.colSpan < maxcolSpan) {\n                  cell.attr.colSpan = maxcolSpan - cell.colSpan + 1;\n                }\n              }\n            }\n\n            row = map[firstMemberName];\n            allRow = map[firstMemberName + \"all\"];\n\n            if (row) {\n              row.children[0].attr.className = \"k-first\";\n            }\n\n            if (allRow) {\n              allRow.children[0].attr.className += \" k-first\";\n            }\n          },\n          _row: function (children) {\n            var row = element(\"tr\", null, children);\n            row.rowSpan = 1;\n            row.colSpan = {};\n            this.rows.push(row);\n            return row;\n          },\n          _content: function (member, tuple) {\n            return htmlNode(this.template({\n              member: member,\n              tuple: tuple\n            }));\n          },\n          _cell: function (className, children, member) {\n            var cell = element(\"td\", {\n              className: className\n            }, children);\n            cell.value = member.caption || member.name;\n            return cell;\n          },\n          _buildRows: function (tuple, memberIdx) {\n            var map = this.map;\n            var path;\n            var members = tuple.members;\n            var member = members[memberIdx];\n            var nextMember = members[memberIdx + 1];\n            var children = member.children;\n            var childrenLength = children.length;\n            var levelNum = Number(member.levelNum);\n            var rootName = this.rootTuple.members[memberIdx].name;\n            var tuplePath = buildPath(tuple, memberIdx - 1).join(\"\");\n            var rootLevelNum = Number(this.rootTuple.members[memberIdx].levelNum);\n            var parentName = tuplePath + (rootLevelNum === levelNum ? \"\" : member.parentName || \"\");\n            var row = map[parentName + \"all\"] || map[parentName];\n            var colSpan = levelNum + 1;\n            var cell, allCell;\n            var childRow, allRow;\n            var metadata;\n            var className;\n            var cellChildren = [];\n            var expandIconAttr;\n            var idx;\n\n            if (!row || row.hasChild) {\n              row = this._row();\n            } else {\n              row.hasChild = true;\n            }\n\n            if (member.measure) {\n              className = row.allCell ? \"k-grid-footer\" : \"\";\n              row.children.push(this._cell(className, [this._content(children[0], tuple)], children[0]));\n              row.rowSpan = childrenLength;\n\n              for (idx = 1; idx < childrenLength; idx++) {\n                this._row([this._cell(className, [this._content(children[idx], tuple)], children[idx])]);\n              }\n\n              return row;\n            }\n\n            map[tuplePath + member.name] = row;\n            path = kendo.stringify(buildPath(tuple, memberIdx));\n            metadata = this.metadata[path];\n\n            if (!metadata) {\n              this.metadata[path] = metadata = createMetadata(levelNum, memberIdx);\n              metadata.rootLevelNum = rootLevelNum;\n            }\n\n            this._indexes.push({\n              path: path,\n              tuple: tuple\n            });\n\n            if (member.hasChildren) {\n              if (metadata.expanded === false) {\n                childrenLength = 0;\n                metadata.children = 0;\n              }\n\n              expandIconAttr = {\n                className: \"k-icon \" + (childrenLength ? STATE_EXPANDED : STATE_COLLAPSED)\n              };\n              expandIconAttr[kendo.attr(\"path\")] = path;\n              cellChildren.push(element(\"span\", expandIconAttr));\n            }\n\n            cellChildren.push(this._content(member, tuple));\n            className = row.allCell && !childrenLength ? \"k-grid-footer\" : \"\";\n            cell = this._cell(className, cellChildren, member);\n            cell.colSpan = colSpan;\n            row.children.push(cell);\n            row.colSpan[\"dim\" + memberIdx] = cell;\n\n            if (!this[rootName] || this[rootName] < colSpan) {\n              this[rootName] = colSpan;\n            }\n\n            if (childrenLength) {\n              row.allCell = false;\n              row.hasChild = false;\n\n              for (idx = 0; idx < childrenLength; idx++) {\n                childRow = this._buildRows(children[idx], memberIdx);\n\n                if (row !== childRow) {\n                  row.rowSpan += childRow.rowSpan;\n                }\n              }\n\n              if (row.rowSpan > 1) {\n                cell.attr.rowSpan = row.rowSpan;\n              }\n\n              metadata.children = row.rowSpan;\n              allCell = this._cell(\"k-grid-footer\", [this._content(member, tuple)], member);\n              allCell.colSpan = colSpan;\n              allRow = this._row([allCell]);\n              allRow.colSpan[\"dim\" + memberIdx] = allCell;\n              allRow.allCell = true;\n              map[tuplePath + member.name + \"all\"] = allRow;\n\n              if (nextMember) {\n                childRow = this._buildRows(tuple, memberIdx + 1);\n                allCell.attr.rowSpan = childRow.rowSpan;\n              }\n\n              row.rowSpan += allRow.rowSpan;\n              metadata.members = allRow.rowSpan;\n            } else if (nextMember) {\n              row.hasChild = false;\n\n              this._buildRows(tuple, memberIdx + 1);\n\n              (allCell || cell).attr.rowSpan = row.rowSpan;\n              metadata.members = row.rowSpan;\n            }\n\n            if (metadata.maxChildren < metadata.children) {\n              metadata.maxChildren = metadata.children;\n            }\n\n            if (metadata.maxMembers < metadata.members) {\n              metadata.maxMembers = metadata.members;\n            }\n\n            return row;\n          }\n        });\n        var ContentBuilder = Class.extend({\n          init: function () {\n            this.columnAxis = {};\n            this.rowAxis = {};\n          },\n          build: function (data, columnAxis, rowAxis) {\n            var index = columnAxis.indexes[0];\n            var metadata = columnAxis.metadata[index ? index.path : undefined];\n            this.columnAxis = columnAxis;\n            this.rowAxis = rowAxis;\n            this.data = data;\n            this.rowLength = metadata ? metadata.maxChildren + metadata.maxMembers : columnAxis.measures.length || 1;\n\n            if (!this.rowLength) {\n              this.rowLength = 1;\n            }\n\n            var tbody = this._tbody();\n\n            var colgroup = this._colGroup();\n\n            return [element(\"table\", null, [colgroup, tbody])];\n          },\n          _colGroup: function () {\n            var length = this.columnAxis.measures.length || 1;\n            var children = [];\n            var idx = 0;\n\n            if (this.rows[0]) {\n              length = this.rows[0].children.length;\n            }\n\n            for (; idx < length; idx++) {\n              children.push(element(\"col\", null));\n            }\n\n            return element(\"colgroup\", null, children);\n          },\n          _tbody: function () {\n            this.rows = [];\n\n            if (this.data[0]) {\n              this.columnIndexes = this._indexes(this.columnAxis, this.rowLength);\n              this.rowIndexes = this._indexes(this.rowAxis, Math.ceil(this.data.length / this.rowLength));\n\n              this._buildRows();\n            } else {\n              this.rows.push(element(\"tr\", null, [element(\"td\", null, [htmlNode(\"&nbsp;\")])]));\n            }\n\n            return element(\"tbody\", null, this.rows);\n          },\n          _indexes: function (axisInfo, total) {\n            var result = [];\n            var axisInfoMember;\n            var indexes = axisInfo.indexes;\n            var metadata = axisInfo.metadata;\n            var measures = axisInfo.measures;\n            var measuresLength = measures.length || 1;\n            var current;\n            var dataIdx = 0;\n            var firstEmpty = 0;\n            var idx = 0;\n            var length = indexes.length;\n            var measureIdx;\n            var index;\n            var children;\n            var skipChildren;\n\n            if (!length) {\n              for (measureIdx = 0; measureIdx < measuresLength; measureIdx++) {\n                result[measureIdx] = {\n                  index: measureIdx,\n                  measure: measures[measureIdx],\n                  tuple: null\n                };\n              }\n\n              return result;\n            }\n\n            for (; idx < length; idx++) {\n              axisInfoMember = indexes[idx];\n              current = metadata[axisInfoMember.path];\n              children = current.children + current.members;\n              skipChildren = 0;\n\n              if (children) {\n                children -= measuresLength;\n              }\n\n              if (current.expanded === false && current.children !== current.maxChildren) {\n                skipChildren = current.maxChildren;\n              }\n\n              if (current.parentMember && current.levelNum === current.rootLevelNum) {\n                children = -1;\n              }\n\n              if (children > -1) {\n                for (measureIdx = 0; measureIdx < measuresLength; measureIdx++) {\n                  index = children + measureIdx;\n\n                  if (!current.children) {\n                    index += firstEmpty;\n                  }\n\n                  result[children + firstEmpty + measureIdx] = {\n                    children: children,\n                    index: dataIdx,\n                    measure: measures[measureIdx],\n                    tuple: axisInfoMember.tuple\n                  };\n                  dataIdx += 1;\n                }\n\n                while (result[firstEmpty] !== undefined) {\n                  firstEmpty += 1;\n                }\n              }\n\n              if (firstEmpty === total) {\n                break;\n              }\n\n              dataIdx += skipChildren;\n            }\n\n            return result;\n          },\n          _buildRows: function () {\n            var rowIndexes = this.rowIndexes;\n            var length = rowIndexes.length;\n            var idx = 0;\n\n            for (; idx < length; idx++) {\n              var rowIndex = rowIndexes[idx];\n\n              if (rowIndex) {\n                this.rows.push(this._buildRow(rowIndex));\n              }\n            }\n          },\n          _buildRow: function (rowInfo) {\n            var startIdx = rowInfo.index * this.rowLength;\n            var columnIndexes = this.columnIndexes;\n            var length = columnIndexes.length;\n            var columnInfo;\n            var cells = [];\n            var idx = 0;\n            var templateInfo;\n            var cell, cellContent;\n            var attr, dataItem, measure;\n\n            for (; idx < length; idx++) {\n              columnInfo = columnIndexes[idx];\n\n              if (columnInfo === undefined) {\n                continue;\n              }\n\n              attr = {};\n\n              if (columnInfo.children) {\n                attr.className = \"k-alt\";\n              }\n\n              cellContent = \"\";\n              dataItem = this.data[startIdx + columnInfo.index];\n              measure = columnInfo.measure || rowInfo.measure;\n              templateInfo = {\n                columnTuple: columnInfo.tuple,\n                rowTuple: rowInfo.tuple,\n                measure: measure,\n                dataItem: dataItem\n              };\n\n              if (dataItem.value !== \"\" && measure && measure.type) {\n                if (measure.type === \"status\") {\n                  cellContent = this.kpiStatusTemplate(templateInfo);\n                } else if (measure.type === \"trend\") {\n                  cellContent = this.kpiTrendTemplate(templateInfo);\n                }\n              }\n\n              if (!cellContent) {\n                cellContent = this.dataTemplate(templateInfo);\n              }\n\n              cell = element(\"td\", attr, [htmlNode(cellContent)]);\n              cell.value = dataItem.value;\n              cells.push(cell);\n            }\n\n            attr = {};\n\n            if (rowInfo.children) {\n              attr.className = \"k-grid-footer\";\n            }\n\n            return element(\"tr\", attr, cells);\n          }\n        });\n        ui.plugin(PivotGrid);\n        kendo.PivotExcelExporter = kendo.Class.extend({\n          init: function (options) {\n            this.options = options;\n            this.widget = options.widget;\n            this.dataSource = this.widget.dataSource;\n          },\n          _columns: function () {\n            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n            var columnHeaderLength = columnHeaderTable.children[0].children.length;\n            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n            var width = this.widget.options.columnWidth;\n            var result = [];\n            var idx;\n\n            if (rowHeaderLength && this.dataSource.data()[0]) {\n              for (idx = 0; idx < rowHeaderLength; idx++) {\n                result.push({\n                  autoWidth: true\n                });\n              }\n            }\n\n            for (idx = 0; idx < columnHeaderLength; idx++) {\n              result.push({\n                autoWidth: false,\n                width: width\n              });\n            }\n\n            return result;\n          },\n          _cells: function (rows, type, callback) {\n            var result = [];\n            var i = 0;\n            var length = rows.length;\n            var cellsLength;\n            var row, cells;\n            var j, cell;\n\n            for (; i < length; i++) {\n              row = [];\n              cells = rows[i].children;\n              cellsLength = cells.length;\n\n              for (j = 0; j < cellsLength; j++) {\n                cell = cells[j];\n                row.push({\n                  background: \"#7a7a7a\",\n                  color: \"#fff\",\n                  value: cell.value,\n                  colSpan: cell.attr.colSpan || 1,\n                  rowSpan: cell.attr.rowSpan || 1\n                });\n              }\n\n              if (callback) {\n                callback(row, i);\n              }\n\n              result.push({\n                cells: row,\n                type: type\n              });\n            }\n\n            return result;\n          },\n          _rows: function () {\n            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n            var columnHeaderLength = columnHeaderTable.children[0].children.length;\n            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n            var columnHeaderRows = columnHeaderTable.children[1].children;\n            var rowHeaderRows = rowHeaderTable.children[1].children;\n            var contentRows = this.widget.contentTree.children[0].children[1].children;\n\n            var columnRows = this._cells(columnHeaderRows, \"header\");\n\n            if (rowHeaderLength) {\n              columnRows[0].cells.splice(0, 0, {\n                background: \"#7a7a7a\",\n                color: \"#fff\",\n                value: \"\",\n                colSpan: rowHeaderLength,\n                rowSpan: columnHeaderRows.length\n              });\n            }\n\n            var dataCallback = function (row, index) {\n              var j = 0;\n              var cell, value;\n              var cells = contentRows[index].children;\n\n              for (; j < columnHeaderLength; j++) {\n                cell = cells[j];\n                value = Number(cell.value);\n\n                if (isNaN(value)) {\n                  value = cell.value;\n                }\n\n                row.push({\n                  background: \"#dfdfdf\",\n                  color: \"#333\",\n                  value: value,\n                  colSpan: 1,\n                  rowSpan: 1\n                });\n              }\n            };\n\n            var rowRows = this._cells(rowHeaderRows, \"data\", dataCallback);\n\n            return columnRows.concat(rowRows);\n          },\n          _freezePane: function () {\n            var columnHeaderTable = this.widget.columnsHeaderTree.children[0];\n            var rowHeaderTable = this.widget.rowsHeaderTree.children[0];\n            var rowHeaderLength = rowHeaderTable.children[0].children.length;\n            var columnHeaderRows = columnHeaderTable.children[1].children;\n            return {\n              colSplit: rowHeaderLength,\n              rowSplit: columnHeaderRows.length\n            };\n          },\n          workbook: function () {\n            var promise,\n                resolveFn = function () {\n              return {\n                sheets: [{\n                  columns: this._columns(),\n                  rows: this._rows(),\n                  freezePane: this._freezePane(),\n                  filter: null\n                }]\n              };\n            };\n\n            if (this.dataSource.view()[0]) {\n              promise = $.Deferred();\n              promise.resolve();\n            } else {\n              promise = this.dataSource.fetch();\n            }\n\n            return promise.then(resolveFn.bind(this));\n          }\n        });\n        var PivotExcelMixin = {\n          extend: function (proto) {\n            proto.events.push(\"excelExport\");\n            proto.options.excel = $.extend(proto.options.excel, this.options);\n            proto.saveAsExcel = this.saveAsExcel;\n          },\n          options: {\n            proxyURL: \"\",\n            filterable: false,\n            fileName: \"Export.xlsx\"\n          },\n          saveAsExcel: function () {\n            var excel = this.options.excel || {};\n            var exporter = new kendo.PivotExcelExporter({\n              widget: this\n            });\n\n            var resolveFn = function (book) {\n              if (!this.trigger(\"excelExport\", {\n                workbook: book\n              })) {\n                var workbook = new kendo.ooxml.Workbook(book);\n                workbook.toDataURLAsync().then(function (dataURI) {\n                  kendo.saveAs({\n                    dataURI: dataURI,\n                    fileName: book.fileName || excel.fileName,\n                    proxyURL: excel.proxyURL,\n                    forceProxy: excel.forceProxy\n                  });\n                });\n              }\n            };\n\n            exporter.workbook().then(resolveFn.bind(this));\n          }\n        };\n        kendo.PivotExcelMixin = PivotExcelMixin;\n\n        if (kendo.ooxml && kendo.ooxml.Workbook) {\n          PivotExcelMixin.extend(PivotGrid.prototype);\n        }\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(PivotGrid.prototype);\n\n          PivotGrid.fn._drawPDF = function () {\n            return this._drawPDFShadow({\n              width: this.wrapper.width()\n            }, {\n              avoidLinks: this.options.pdf.avoidLinks\n            });\n          };\n        }\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(PivotGridV2.prototype);\n\n          PivotGridV2.fn._drawPDF = function () {\n            return this._drawPDFShadow({\n              width: this.wrapper.width()\n            }, {\n              avoidLinks: this.options.pdf.avoidLinks\n            });\n          };\n        }\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}