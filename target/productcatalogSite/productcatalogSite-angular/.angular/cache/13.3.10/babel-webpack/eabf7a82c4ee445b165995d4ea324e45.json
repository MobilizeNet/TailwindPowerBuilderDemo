{"ast":null,"code":"import BarChart from '../bar-chart/bar-chart';\nimport SeriesBinder from '../series-binder';\nimport WaterfallSegment from './waterfall-segment';\nimport categoriesCount from '../utils/categories-count';\nimport { isNumber } from '../../common';\n\nclass WaterfallChart extends BarChart {\n  render() {\n    super.render();\n    this.createSegments();\n  }\n\n  traverseDataPoints(callback) {\n    const series = this.options.series;\n    const totalCategories = categoriesCount(series);\n    const isVertical = !this.options.invertAxes;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      let total = 0;\n      let runningTotal = 0;\n\n      for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n        const data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n        const value = data.valueFields.value;\n        const summary = data.fields.summary;\n        let from = total;\n        let to;\n\n        if (summary) {\n          if (summary.toLowerCase() === \"total\") {\n            data.valueFields.value = total;\n            from = 0;\n            to = total;\n          } else {\n            data.valueFields.value = runningTotal;\n            to = from - runningTotal;\n            runningTotal = 0;\n          }\n        } else if (isNumber(value)) {\n          runningTotal += value;\n          total += value;\n          to = total;\n        }\n\n        callback(data, {\n          category: this.categoryAxis.categoryAt(categoryIx),\n          categoryIx: categoryIx,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          total: total,\n          runningTotal: runningTotal,\n          from: from,\n          to: to,\n          isVertical: isVertical\n        });\n      }\n    }\n  }\n\n  updateRange(value, fields) {\n    super.updateRange({\n      value: fields.to\n    }, fields);\n  }\n\n  aboveAxis(point) {\n    return point.value >= 0;\n  }\n\n  plotRange(point) {\n    return [point.from, point.to];\n  }\n\n  createSegments() {\n    const series = this.options.series;\n    const seriesPoints = this.seriesPoints;\n    const segments = this.segments = [];\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const points = seriesPoints[seriesIx];\n\n      if (points) {\n        let prevPoint;\n\n        for (let pointIx = 0; pointIx < points.length; pointIx++) {\n          const point = points[pointIx];\n\n          if (point && prevPoint) {\n            const segment = new WaterfallSegment(prevPoint, point, currentSeries);\n            segments.push(segment);\n            this.append(segment);\n          }\n\n          prevPoint = point;\n        }\n      }\n    }\n  }\n\n}\n\nexport default WaterfallChart;","map":null,"metadata":{},"sourceType":"module"}