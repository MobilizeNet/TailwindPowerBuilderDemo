{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined, round, getSpacing } from '../../common';\nimport { BLACK, COORD_PRECISION } from '../../common/constants';\nimport { autoMajorUnit, Box, NumericAxis } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\nimport { DEGREE, DEFAULT_LINE_WIDTH, INSIDE, OUTSIDE } from '../constants';\nconst GEO_ARC_ADJUST_ANGLE = 180;\nconst {\n  Arc,\n  Path,\n  Group\n} = drawing;\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n  const ticks = new Group();\n  const center = arc.center;\n  const radius = arc.getRadiusX();\n\n  if (tickOptions.visible) {\n    for (let i = 0; i < tickAngles.length; i++) {\n      const tickStart = arc.pointAt(tickAngles[i]);\n      const tickEnd = new geo.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n      ticks.append(new Path({\n        stroke: {\n          color: tickOptions.color,\n          width: tickOptions.width\n        }\n      }).moveTo(tickStart).lineTo(tickEnd));\n    }\n  }\n\n  return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n  return {\n    from: from,\n    to: to,\n    color: color,\n    opacity: opacity\n  };\n}\n\nclass RadialScale extends NumericAxis {\n  constructor(options, service) {\n    super(0, 1, options, service);\n  }\n\n  initUserOptions(options) {\n    const scaleOptions = deepExtend({}, this.options, options);\n    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n    return scaleOptions;\n  }\n\n  initFields() {}\n\n  render(center, radius) {\n    const arc = this.renderArc(center, radius);\n    this.bbox = arc.bbox();\n    this.labelElements = this.renderLabels();\n    this.ticks = this.renderTicks();\n    this.ranges = this.renderRanges();\n  }\n\n  reflow(bbox) {\n    const center = bbox.center();\n    const radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n    if (defined(this.bbox)) {\n      this.bbox = this.arc.bbox();\n      this.radius(this.arc.getRadiusX());\n      this.repositionRanges();\n      this.renderLabels();\n    } else {\n      return this.render(center, radius);\n    }\n  }\n\n  slotAngle(value) {\n    const {\n      min,\n      max,\n      reverse,\n      startAngle,\n      endAngle\n    } = this.options;\n    const angle = endAngle - startAngle;\n    let result;\n\n    if (reverse) {\n      result = endAngle - (value - min) / (max - min) * angle;\n    } else {\n      result = (value - min) / (max - min) * angle + startAngle;\n    }\n\n    return result + GEO_ARC_ADJUST_ANGLE;\n  }\n\n  hasRanges() {\n    const ranges = this.options.ranges;\n    return ranges && ranges.length;\n  }\n\n  ticksSize() {\n    const {\n      majorTicks,\n      minorTicks\n    } = this.options;\n    let size = 0;\n\n    if (majorTicks.visible) {\n      size = majorTicks.size;\n    }\n\n    if (minorTicks.visible) {\n      size = Math.max(minorTicks.size, size);\n    }\n\n    return size;\n  }\n\n  labelsCount() {\n    let count = super.labelsCount();\n    const options = this.options;\n    const angle = options.endAngle - options.startAngle;\n\n    if (angle >= 360 && options.max % options.majorUnit === 0) {\n      count -= 1;\n    }\n\n    return count;\n  }\n\n  renderLabels() {\n    const options = this.options;\n    const arc = this.arc.clone();\n    let radius = arc.getRadiusX();\n    const tickAngles = this.tickAngles(arc, options.majorUnit);\n    const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n    const labelsGroup = new Group();\n    let rangeDistance = radius * 0.05;\n\n    if (defined(options.rangeDistance)) {\n      rangeDistance = options.rangeDistance;\n    } else {\n      options.rangeDistance = rangeDistance;\n    }\n\n    const labelsOptions = options.labels;\n    const isInside = labelsOptions.position === INSIDE;\n    const hasLabelElements = defined(this.labelElements);\n\n    if (isInside) {\n      radius -= this.ticksSize();\n\n      if (this.hasRanges() && !hasLabelElements) {\n        radius -= rangeSize + rangeDistance;\n      }\n\n      arc.setRadiusX(radius).setRadiusY(radius);\n    }\n\n    const labels = this.labels;\n    const count = labels.length;\n    const padding = getSpacing(labelsOptions.padding);\n    const paddingWidth = (padding.left + padding.right) / 2;\n    const paddingHeight = (padding.top + padding.bottom) / 2;\n\n    for (let i = 0; i < count; i++) {\n      const label = labels[i];\n      const halfWidth = label.box.width() / 2;\n      const halfHeight = label.box.height() / 2;\n      const angle = tickAngles[i];\n      const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n      const lp = arc.pointAt(angle);\n      const cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);\n      const cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);\n      label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n      const labelPos = new geo.Point(label.box.x1, label.box.y1);\n      let labelElement;\n\n      if (!hasLabelElements) {\n        labelElement = buildLabelElement(label, options.labels);\n        labelsGroup.append(labelElement);\n      } else {\n        labelElement = this.labelElements.children[i];\n        const prevLabelPos = labelElement.bbox().origin;\n        const labelTransform = labelElement.transform() || geo.transform();\n        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n        labelElement.transform(labelTransform);\n      }\n\n      this.bbox = geo.Rect.union(this.bbox, labelElement.bbox());\n    }\n\n    return labelsGroup;\n  }\n\n  repositionRanges() {\n    const ranges = this.ranges.children;\n\n    if (ranges.length > 0) {\n      const {\n        rangeDistance,\n        rangeSize\n      } = this.options;\n      let rangeRadius = this.getRangeRadius();\n\n      if (this.options.labels.position === INSIDE) {\n        rangeRadius += rangeSize + rangeDistance;\n      }\n\n      const newRadius = rangeRadius + rangeSize / 2;\n\n      for (let i = 0; i < ranges.length; i++) {\n        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n      }\n\n      this.bbox = geo.Rect.union(this.bbox, this.ranges.bbox());\n    }\n  }\n\n  renderRanges() {\n    const segments = this.rangeSegments();\n    const segmentsCount = segments.length;\n    const result = new Group();\n\n    if (segmentsCount) {\n      const {\n        rangeSize,\n        reverse,\n        rangeDistance\n      } = this.options;\n      const rangeRadius = this.getRangeRadius(); // move the ticks with a range distance and a range size\n\n      this.radius(this.radius() - rangeSize - rangeDistance);\n\n      for (let i = 0; i < segmentsCount; i++) {\n        const segment = segments[i];\n        const from = this.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n        const to = this.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n        if (to - from !== 0) {\n          result.append(this.createRange(from, to, rangeRadius, segment));\n        }\n      }\n    }\n\n    return result;\n  }\n\n  createRange(startAngle, endAngle, rangeRadius, options) {\n    const rangeSize = this.options.rangeSize;\n    const rangeGeom = new geo.Arc(this.arc.center, {\n      radiusX: rangeRadius + rangeSize / 2,\n      radiusY: rangeRadius + rangeSize / 2,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n    return new Arc(rangeGeom, {\n      stroke: {\n        width: rangeSize,\n        color: options.color,\n        opacity: options.opacity,\n        lineCap: options.lineCap\n      }\n    });\n  }\n\n  rangeSegments() {\n    const options = this.options;\n    const ranges = options.ranges || [];\n    const count = ranges.length;\n    const segments = [];\n\n    if (count) {\n      const {\n        min,\n        max,\n        rangePlaceholderColor: defaultColor\n      } = options;\n      segments.push(rangeSegment(min, max, defaultColor));\n\n      for (let i = 0; i < count; i++) {\n        const range = getRange(ranges[i], min, max);\n        const segmentsCount = segments.length;\n\n        for (let j = 0; j < segmentsCount; j++) {\n          const segment = segments[j];\n\n          if (segment.from <= range.from && range.from <= segment.to) {\n            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n            if (segment.from <= range.to && range.to <= segment.to) {\n              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n            }\n\n            segment.to = range.from;\n            break;\n          }\n        }\n      }\n    }\n\n    return segments;\n  }\n\n  getRangeRadius() {\n    const {\n      arc,\n      options\n    } = this;\n    const {\n      rangeSize,\n      rangeDistance,\n      majorTicks: {\n        size: majorTickSize\n      }\n    } = options;\n    let radius;\n\n    if (options.labels.position === OUTSIDE) {\n      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n    } else {\n      radius = arc.getRadiusX() - rangeSize;\n    }\n\n    return radius;\n  }\n\n  renderArc(center, radius) {\n    const options = this.options;\n    const arc = this.arc = new geo.Arc(center, {\n      radiusX: radius,\n      radiusY: radius,\n      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n    });\n    return arc;\n  }\n\n  renderTicks() {\n    const {\n      arc,\n      options\n    } = this;\n    const tickArc = arc.clone();\n    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n    const allTicks = new Group();\n    allTicks.append(this.majorTicks);\n    const majorTickSize = options.majorTicks.size;\n    const minorTickSize = options.minorTicks.size;\n    this._tickDifference = majorTickSize - minorTickSize;\n\n    if (options.labels.position === OUTSIDE) {\n      const radius = tickArc.getRadiusX();\n      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);\n    }\n\n    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n    allTicks.append(this.minorTicks);\n    return allTicks;\n  }\n\n  normalizeTickAngles(angles) {\n    const options = this.options;\n    const skip = options.majorUnit / options.minorUnit;\n\n    for (let i = angles.length - 1; i >= 0; i--) {\n      if (i % skip === 0) {\n        angles.splice(i, 1);\n      }\n    }\n\n    return angles;\n  }\n\n  tickAngles(ring, stepValue) {\n    const options = this.options;\n    const reverse = options.reverse;\n    const range = options.max - options.min;\n    const angle = ring.endAngle - ring.startAngle;\n    let tickCount = range / stepValue;\n    let pos = ring.startAngle;\n    let step = angle / tickCount;\n\n    if (reverse) {\n      pos += angle;\n      step = -step;\n    }\n\n    if (angle >= 360 && options.max % stepValue === 0) {\n      tickCount -= 1;\n    }\n\n    const positions = [];\n\n    for (let i = 0; i < tickCount; i++) {\n      positions.push(round(pos, COORD_PRECISION));\n      pos += step;\n    }\n\n    if (round(pos) <= ring.endAngle) {\n      positions.push(pos);\n    }\n\n    return positions;\n  }\n\n  radius(value) {\n    if (value) {\n      this.arc.setRadiusX(value).setRadiusY(value);\n      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n    } else {\n      return this.arc.getRadiusX();\n    }\n  }\n\n  repositionTicks(ticks, tickAngles, minor) {\n    const diff = minor ? this._tickDifference || 0 : 0;\n    let tickArc = this.arc;\n    const radius = tickArc.getRadiusX();\n\n    if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n      tickArc = this.arc.clone();\n      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n    }\n\n    for (let i = 0; i < ticks.length; i++) {\n      const newPoint = tickArc.pointAt(tickAngles[i]);\n      const segments = ticks[i].segments;\n      const xDiff = newPoint.x - segments[0].anchor().x;\n      const yDiff = newPoint.y - segments[0].anchor().y;\n      ticks[i].transform(new geo.transform().translate(xDiff, yDiff));\n    }\n  }\n\n}\n\nsetDefaultOptions(RadialScale, {\n  min: 0,\n  max: 100,\n  majorTicks: {\n    size: 15,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  minorTicks: {\n    size: 10,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  startAngle: -30,\n  endAngle: 210,\n  labels: {\n    position: INSIDE,\n    padding: 2\n  }\n});\nexport default RadialScale;","map":null,"metadata":{},"sourceType":"module"}