{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1008);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1008:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /*jshint boss: true */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1009)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            browser = kendo.support.browser,\n            dom = Editor.Dom,\n            findNodeIndex = dom.findNodeIndex,\n            isDataNode = dom.isDataNode,\n            findClosestAncestor = dom.findClosestAncestor,\n            getNodeLength = dom.getNodeLength,\n            normalize = dom.normalize;\n        var SelectionUtils = {\n          selectionFromWindow: function (window) {\n            if (!window) {\n              return;\n            }\n\n            if (!(\"getSelection\" in window)) {\n              return new W3CSelection(window.document);\n            }\n\n            return window.getSelection();\n          },\n          selectionFromRange: function (range) {\n            var rangeDocument = RangeUtils.documentFromRange(range);\n            return SelectionUtils.selectionFromDocument(rangeDocument);\n          },\n          selectionFromDocument: function (document) {\n            return SelectionUtils.selectionFromWindow(dom.windowFromDocument(document));\n          }\n        };\n        var W3CRange = Class.extend({\n          init: function (doc) {\n            $.extend(this, {\n              ownerDocument: doc,\n\n              /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */\n              startContainer: doc,\n              endContainer: doc,\n              commonAncestorContainer: doc,\n              startOffset: 0,\n              endOffset: 0,\n              collapsed: true\n            });\n          },\n          // Positioning Methods\n          setStart: function (node, offset) {\n            this.startContainer = node;\n            this.startOffset = offset;\n            updateRangeProperties(this);\n            fixIvalidRange(this, true);\n          },\n          setEnd: function (node, offset) {\n            this.endContainer = node;\n            this.endOffset = offset;\n            updateRangeProperties(this);\n            fixIvalidRange(this, false);\n          },\n          setStartBefore: function (node) {\n            this.setStart(node.parentNode, findNodeIndex(node));\n          },\n          setStartAfter: function (node) {\n            this.setStart(node.parentNode, findNodeIndex(node) + 1);\n          },\n          setEndBefore: function (node) {\n            this.setEnd(node.parentNode, findNodeIndex(node));\n          },\n          setEndAfter: function (node) {\n            this.setEnd(node.parentNode, findNodeIndex(node) + 1);\n          },\n          selectNode: function (node) {\n            this.setStartBefore(node);\n            this.setEndAfter(node);\n          },\n          selectNodeContents: function (node) {\n            this.setStart(node, 0);\n            this.setEnd(node, node[node.nodeType === 1 ? 'childNodes' : 'nodeValue'].length);\n          },\n          collapse: function (toStart) {\n            var that = this;\n\n            if (toStart) {\n              that.setEnd(that.startContainer, that.startOffset);\n            } else {\n              that.setStart(that.endContainer, that.endOffset);\n            }\n          },\n          // Editing Methods\n          deleteContents: function () {\n            var that = this,\n                range = that.cloneRange();\n\n            if (that.startContainer != that.commonAncestorContainer) {\n              that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n            }\n\n            that.collapse(true);\n\n            (function deleteSubtree(iterator) {\n              while (iterator.next()) {\n                if (iterator.hasPartialSubtree()) {\n                  deleteSubtree(iterator.getSubtreeIterator());\n                } else {\n                  iterator.remove();\n                }\n              }\n            })(new RangeIterator(range));\n          },\n          cloneContents: function () {\n            // clone subtree\n            var document = RangeUtils.documentFromRange(this);\n            return function cloneSubtree(iterator) {\n              var node,\n                  frag = document.createDocumentFragment();\n\n              while (node = iterator.next()) {\n                node = node.cloneNode(!iterator.hasPartialSubtree());\n\n                if (iterator.hasPartialSubtree()) {\n                  node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));\n                }\n\n                frag.appendChild(node);\n              }\n\n              return frag;\n            }(new RangeIterator(this));\n          },\n          extractContents: function () {\n            var that = this,\n                range = that.cloneRange();\n\n            if (that.startContainer != that.commonAncestorContainer) {\n              that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n            }\n\n            that.collapse(true);\n            var document = RangeUtils.documentFromRange(that);\n            return function extractSubtree(iterator) {\n              var node,\n                  frag = document.createDocumentFragment();\n\n              while (node = iterator.next()) {\n                if (iterator.hasPartialSubtree()) {\n                  node = node.cloneNode(false);\n                  node.appendChild(extractSubtree(iterator.getSubtreeIterator()));\n                } else {\n                  iterator.remove(that.originalRange);\n                }\n\n                frag.appendChild(node);\n              }\n\n              return frag;\n            }(new RangeIterator(range));\n          },\n          insertNode: function (node) {\n            var that = this;\n\n            if (isDataNode(that.startContainer)) {\n              if (that.startOffset != that.startContainer.nodeValue.length) {\n                dom.splitDataNode(that.startContainer, that.startOffset);\n              }\n\n              dom.insertAfter(node, that.startContainer);\n            } else {\n              dom.insertAt(that.startContainer, node, that.startOffset);\n            }\n\n            that.setStart(that.startContainer, that.startOffset);\n          },\n          cloneRange: function () {\n            // fast copy\n            return $.extend(new W3CRange(this.ownerDocument), {\n              startContainer: this.startContainer,\n              endContainer: this.endContainer,\n              commonAncestorContainer: this.commonAncestorContainer,\n              startOffset: this.startOffset,\n              endOffset: this.endOffset,\n              collapsed: this.collapsed,\n              originalRange: this\n              /* not part of the spec; used to update the original range when calling extractContents() on clones */\n\n            });\n          },\n          // used for debug purposes\n          toString: function () {\n            var startNodeName = this.startContainer.nodeName,\n                endNodeName = this.endContainer.nodeName;\n            return [startNodeName == \"#text\" ? this.startContainer.nodeValue : startNodeName, '(', this.startOffset, ') : ', endNodeName == \"#text\" ? this.endContainer.nodeValue : endNodeName, '(', this.endOffset, ')'].join('');\n          }\n        });\n\n        W3CRange.fromNode = function (node) {\n          return new W3CRange(node.ownerDocument);\n        };\n        /* can be used in Range.compareBoundaryPoints if we need it one day */\n\n\n        function compareBoundaries(start, end, startOffset, endOffset) {\n          if (start == end) {\n            return endOffset - startOffset;\n          } // end is child of start\n\n\n          var container = end;\n\n          while (container && container.parentNode != start) {\n            container = container.parentNode;\n          }\n\n          if (container) {\n            return findNodeIndex(container) - startOffset;\n          } // start is child of end\n\n\n          container = start;\n\n          while (container && container.parentNode != end) {\n            container = container.parentNode;\n          }\n\n          if (container) {\n            return endOffset - findNodeIndex(container) - 1;\n          } // deep traversal\n\n\n          var root = dom.commonAncestor(start, end);\n          var startAncestor = start;\n\n          while (startAncestor && startAncestor.parentNode != root) {\n            startAncestor = startAncestor.parentNode;\n          }\n\n          if (!startAncestor) {\n            startAncestor = root;\n          }\n\n          var endAncestor = end;\n\n          while (endAncestor && endAncestor.parentNode != root) {\n            endAncestor = endAncestor.parentNode;\n          }\n\n          if (!endAncestor) {\n            endAncestor = root;\n          }\n\n          if (startAncestor == endAncestor) {\n            return 0;\n          }\n\n          return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);\n        }\n\n        function fixIvalidRange(range, toStart) {\n          function isInvalidRange(range) {\n            try {\n              return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;\n            } catch (ex) {\n              // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed\n              return true;\n            }\n          }\n\n          if (isInvalidRange(range)) {\n            if (toStart) {\n              range.commonAncestorContainer = range.endContainer = range.startContainer;\n              range.endOffset = range.startOffset;\n            } else {\n              range.commonAncestorContainer = range.startContainer = range.endContainer;\n              range.startOffset = range.endOffset;\n            }\n\n            range.collapsed = true;\n          }\n        }\n\n        function updateRangeProperties(range) {\n          range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;\n          var node = range.startContainer;\n\n          while (node && node != range.endContainer && !dom.isAncestorOf(node, range.endContainer)) {\n            node = node.parentNode;\n          }\n\n          range.commonAncestorContainer = node;\n        }\n\n        var RangeIterator = Class.extend({\n          init: function (range) {\n            $.extend(this, {\n              range: range,\n              _current: null,\n              _next: null,\n              _end: null\n            });\n\n            if (range.collapsed) {\n              return;\n            }\n\n            var root = range.commonAncestorContainer;\n            this._next = range.startContainer == root && !isDataNode(range.startContainer) ? range.startContainer.childNodes[range.startOffset] : findClosestAncestor(root, range.startContainer);\n            this._end = range.endContainer == root && !isDataNode(range.endContainer) ? range.endContainer.childNodes[range.endOffset] : findClosestAncestor(root, range.endContainer).nextSibling;\n          },\n          hasNext: function () {\n            return !!this._next;\n          },\n          next: function () {\n            var that = this,\n                current = that._current = that._next;\n            that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n\n            if (isDataNode(that._current)) {\n              if (that.range.endContainer == that._current) {\n                current = current.cloneNode(true);\n                current.deleteData(that.range.endOffset, current.length - that.range.endOffset);\n              }\n\n              if (that.range.startContainer == that._current) {\n                current = current.cloneNode(true);\n                current.deleteData(0, that.range.startOffset);\n              }\n            }\n\n            return current;\n          },\n          traverse: function (callback) {\n            var that = this,\n                current;\n\n            function next() {\n              that._current = that._next;\n              that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n              return that._current;\n            }\n\n            while (current = next()) {\n              if (that.hasPartialSubtree()) {\n                that.getSubtreeIterator().traverse(callback);\n              } else {\n                callback(current);\n              }\n            }\n\n            return current;\n          },\n          remove: function (originalRange) {\n            var that = this,\n                inStartContainer = that.range.startContainer == that._current,\n                inEndContainer = that.range.endContainer == that._current,\n                start,\n                end,\n                delta;\n\n            if (isDataNode(that._current) && (inStartContainer || inEndContainer)) {\n              start = inStartContainer ? that.range.startOffset : 0;\n              end = inEndContainer ? that.range.endOffset : that._current.length;\n              delta = end - start;\n\n              if (originalRange && (inStartContainer || inEndContainer)) {\n                if (that._current == originalRange.startContainer && start <= originalRange.startOffset) {\n                  originalRange.startOffset -= delta;\n                }\n\n                if (that._current == originalRange.endContainer && end <= originalRange.endOffset) {\n                  originalRange.endOffset -= delta;\n                }\n              }\n\n              that._current.deleteData(start, delta);\n            } else {\n              var parent = that._current.parentNode;\n\n              if (originalRange && (that.range.startContainer == parent || that.range.endContainer == parent)) {\n                var nodeIndex = findNodeIndex(that._current);\n\n                if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset) {\n                  originalRange.startOffset -= 1;\n                }\n\n                if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset) {\n                  originalRange.endOffset -= 1;\n                }\n              }\n\n              dom.remove(that._current);\n            }\n          },\n          hasPartialSubtree: function () {\n            return !isDataNode(this._current) && (dom.isAncestorOrSelf(this._current, this.range.startContainer) || dom.isAncestorOrSelf(this._current, this.range.endContainer));\n          },\n          getSubtreeIterator: function () {\n            return new RangeIterator(this.getSubRange());\n          },\n          getSubRange: function () {\n            var that = this,\n                subRange = that.range.cloneRange();\n            subRange.selectNodeContents(that._current);\n\n            if (dom.isAncestorOrSelf(that._current, that.range.startContainer)) {\n              subRange.setStart(that.range.startContainer, that.range.startOffset);\n            }\n\n            if (dom.isAncestorOrSelf(that._current, that.range.endContainer)) {\n              subRange.setEnd(that.range.endContainer, that.range.endOffset);\n            }\n\n            return subRange;\n          }\n        });\n        var W3CSelection = Class.extend({\n          init: function (doc) {\n            this.ownerDocument = doc;\n            this.rangeCount = 1;\n          },\n          addRange: function (range) {\n            var textRange = this.ownerDocument.body.createTextRange(); // end container should be adopted first in order to prevent selection with negative length\n\n            adoptContainer(textRange, range, false);\n            adoptContainer(textRange, range, true);\n            textRange.select();\n          },\n          removeAllRanges: function () {\n            var selection = this.ownerDocument.selection;\n\n            if (selection.type != \"None\") {\n              selection.empty();\n            }\n          },\n          getRangeAt: function () {\n            var textRange,\n                range = new W3CRange(this.ownerDocument),\n                selection = this.ownerDocument.selection,\n                element,\n                commonAncestor;\n\n            try {\n              textRange = selection.createRange();\n              element = textRange.item ? textRange.item(0) : textRange.parentElement();\n\n              if (element.ownerDocument != this.ownerDocument) {\n                return range;\n              }\n            } catch (ex) {\n              return range;\n            }\n\n            if (selection.type == \"Control\") {\n              range.selectNode(textRange.item(0));\n            } else {\n              commonAncestor = textRangeContainer(textRange);\n              adoptEndPoint(textRange, range, commonAncestor, true);\n              adoptEndPoint(textRange, range, commonAncestor, false);\n\n              if (range.startContainer.nodeType == 9) {\n                range.setStart(range.endContainer, range.startOffset);\n              }\n\n              if (range.endContainer.nodeType == 9) {\n                range.setEnd(range.startContainer, range.endOffset);\n              }\n\n              if (textRange.compareEndPoints(\"StartToEnd\", textRange) === 0) {\n                range.collapse(false);\n              }\n\n              var startContainer = range.startContainer,\n                  endContainer = range.endContainer,\n                  body = this.ownerDocument.body;\n\n              if (!range.collapsed && range.startOffset === 0 && range.endOffset == getNodeLength(range.endContainer) && // check for full body selection\n              !(startContainer == endContainer && isDataNode(startContainer) && startContainer.parentNode == body)) {\n                // but not when single textnode is selected\n                var movedStart = false,\n                    movedEnd = false;\n\n                while (findNodeIndex(startContainer) === 0 && startContainer == startContainer.parentNode.firstChild && startContainer != body) {\n                  startContainer = startContainer.parentNode;\n                  movedStart = true;\n                }\n\n                while (findNodeIndex(endContainer) == getNodeLength(endContainer.parentNode) - 1 && endContainer == endContainer.parentNode.lastChild && endContainer != body) {\n                  endContainer = endContainer.parentNode;\n                  movedEnd = true;\n                }\n\n                if (startContainer == body && endContainer == body && movedStart && movedEnd) {\n                  range.setStart(startContainer, 0);\n                  range.setEnd(endContainer, getNodeLength(body));\n                }\n              }\n            }\n\n            return range;\n          }\n        });\n\n        function textRangeContainer(textRange) {\n          var left = textRange.duplicate(),\n              right = textRange.duplicate();\n          left.collapse(true);\n          right.collapse(false);\n          return dom.commonAncestor(textRange.parentElement(), left.parentElement(), right.parentElement());\n        }\n\n        function adoptContainer(textRange, range, start) {\n          // find anchor node and offset\n          var container = range[start ? \"startContainer\" : \"endContainer\"],\n              offset = range[start ? \"startOffset\" : \"endOffset\"],\n              textOffset = 0,\n              isData = isDataNode(container),\n              anchorNode = isData ? container : container.childNodes[offset] || null,\n              anchorParent = isData ? container.parentNode : container,\n              doc = range.ownerDocument,\n              cursor = doc.body.createTextRange(),\n              cursorNode; // visible data nodes need a text offset\n\n          if (container.nodeType == 3 || container.nodeType == 4) {\n            textOffset = offset;\n          }\n\n          if (!anchorParent) {\n            anchorParent = doc.body;\n          }\n\n          if (anchorParent.nodeName.toLowerCase() == \"img\") {\n            cursor.moveToElementText(anchorParent);\n            cursor.collapse(false);\n            textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n          } else {\n            // create a cursor element node to position range (since we can't select text nodes)\n            cursorNode = anchorParent.insertBefore(dom.create(doc, \"a\"), anchorNode);\n            cursor.moveToElementText(cursorNode);\n            dom.remove(cursorNode);\n            cursor[start ? \"moveStart\" : \"moveEnd\"](\"character\", textOffset);\n            cursor.collapse(false);\n            textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n          }\n        }\n\n        function adoptEndPoint(textRange, range, commonAncestor, start) {\n          var cursorNode = dom.create(range.ownerDocument, \"a\"),\n              cursor = textRange.duplicate(),\n              comparison = start ? \"StartToStart\" : \"StartToEnd\",\n              result,\n              parent,\n              target,\n              previous,\n              next,\n              args,\n              index,\n              appended = false;\n          cursorNode.innerHTML = \"\\ufeff\";\n          cursor.collapse(start);\n          parent = cursor.parentElement();\n\n          if (!dom.isAncestorOrSelf(commonAncestor, parent)) {\n            parent = commonAncestor;\n          } // detect range end points\n          // insert cursorNode within the textRange parent and move the cursor until it gets outside of the textRange\n\n\n          do {\n            if (appended) {\n              parent.insertBefore(cursorNode, cursorNode.previousSibling);\n            } else {\n              parent.appendChild(cursorNode);\n              appended = true;\n            }\n\n            cursor.moveToElementText(cursorNode);\n          } while ((result = cursor.compareEndPoints(comparison, textRange)) > 0 && cursorNode.previousSibling);\n\n          target = cursorNode.nextSibling;\n\n          if (result == -1 && isDataNode(target)) {\n            cursor.setEndPoint(start ? \"EndToStart\" : \"EndToEnd\", textRange);\n            dom.remove(cursorNode);\n            args = [target, cursor.text.length];\n          } else {\n            previous = !start && cursorNode.previousSibling;\n            next = start && cursorNode.nextSibling;\n\n            if (isDataNode(next)) {\n              args = [next, 0];\n            } else if (isDataNode(previous)) {\n              args = [previous, previous.length];\n            } else {\n              index = findNodeIndex(cursorNode);\n\n              if (parent.nextSibling && index == parent.childNodes.length - 1) {\n                args = [parent.nextSibling, 0];\n              } else {\n                args = [parent, index];\n              }\n            }\n\n            dom.remove(cursorNode);\n          }\n\n          range[start ? \"setStart\" : \"setEnd\"].apply(range, args);\n        }\n\n        var RangeEnumerator = Class.extend({\n          init: function (range) {\n            this.enumerate = function () {\n              var nodes = [];\n\n              function visit(node) {\n                if (dom.is(node, \"img\") || node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\")) {\n                  nodes.push(node);\n                } else {\n                  node = node.firstChild;\n\n                  while (node) {\n                    visit(node);\n                    node = node.nextSibling;\n                  }\n                }\n              }\n\n              new RangeIterator(range).traverse(visit);\n              return nodes;\n            };\n          }\n        });\n        var ImmutablesRangeIterator = RangeIterator.extend({\n          hasPartialSubtree: function () {\n            var immutable = Editor.Immutables && Editor.Immutables.immutable;\n            return immutable && !immutable(this._current) && RangeIterator.fn.hasPartialSubtree.call(this);\n          },\n          getSubtreeIterator: function () {\n            return new ImmutablesRangeIterator(this.getSubRange());\n          }\n        });\n        var ImmutablesRangeEnumerator = Class.extend({\n          init: function (range) {\n            this.enumerate = function () {\n              var nodes = [];\n              var immutable = Editor.Immutables && Editor.Immutables.immutable;\n\n              function visit(node) {\n                if (immutable && !immutable(node)) {\n                  if (dom.is(node, \"img\") || node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\")) {\n                    nodes.push(node);\n                  } else {\n                    node = node.firstChild;\n\n                    while (node) {\n                      visit(node);\n                      node = node.nextSibling;\n                    }\n                  }\n                }\n              }\n\n              new ImmutablesRangeIterator(range).traverse(visit);\n              return nodes;\n            };\n          }\n        });\n        var RestorePoint = Class.extend({\n          init: function (range, body, options) {\n            var that = this;\n            that.range = range;\n            that.rootNode = RangeUtils.documentFromRange(range);\n            that.body = body || that.getEditable(range);\n\n            if (dom.name(that.body) != \"body\") {\n              that.rootNode = that.body;\n            }\n\n            that.startContainer = that.nodeToPath(range.startContainer);\n            that.endContainer = that.nodeToPath(range.endContainer);\n            that.startOffset = that.offset(range.startContainer, range.startOffset);\n            that.endOffset = that.offset(range.endContainer, range.endOffset);\n            that.immutables = options && options.immutables;\n\n            if (that.immutables) {\n              that.serializedImmutables = Editor.Immutables.removeImmutables(that.body);\n            }\n\n            that.html = that.body.innerHTML;\n\n            if (that.immutables && !that.serializedImmutables.empty) {\n              Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n            }\n          },\n          index: function (node) {\n            var result = 0,\n                lastType = node.nodeType;\n\n            while (node = node.previousSibling) {\n              var nodeType = node.nodeType;\n\n              if (nodeType != 3 || lastType != nodeType) {\n                result++;\n              }\n\n              lastType = nodeType;\n            }\n\n            return result;\n          },\n          getEditable: function (range) {\n            var root = range.commonAncestorContainer;\n\n            while (root && (root.nodeType == 3 || root.attributes && (!root.attributes.contentEditable || root.attributes.contentEditable.nodeValue.toLowerCase() == \"false\"))) {\n              root = root.parentNode;\n            }\n\n            return root;\n          },\n          restoreHtml: function () {\n            var that = this;\n            dom.removeChildren(that.body);\n            that.body.innerHTML = that.html;\n\n            if (that.immutables && !that.serializedImmutables.empty) {\n              Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n            }\n          },\n          offset: function (node, value) {\n            if (node.nodeType == 3) {\n              while ((node = node.previousSibling) && node.nodeType == 3) {\n                value += node.nodeValue.length;\n              }\n            }\n\n            return value;\n          },\n          nodeToPath: function (node) {\n            var path = [];\n\n            while (node != this.rootNode) {\n              path.push(this.index(node));\n              node = node.parentNode;\n            }\n\n            return path;\n          },\n          toRangePoint: function (range, start, path, denormalizedOffset) {\n            var node = this.rootNode,\n                length = path.length,\n                offset = denormalizedOffset;\n\n            while (length-- && node) {\n              node = node.childNodes[path[length]];\n            }\n\n            while (node && node.nodeType == 3 && node.nodeValue.length < offset) {\n              offset -= node.nodeValue.length;\n              node = node.nextSibling;\n            }\n\n            if (node && offset >= 0) {\n              range[start ? 'setStart' : 'setEnd'](node, offset);\n            }\n          },\n          toRange: function () {\n            var that = this,\n                result = that.range.cloneRange();\n            that.toRangePoint(result, true, that.startContainer, that.startOffset);\n            that.toRangePoint(result, false, that.endContainer, that.endOffset);\n            return result;\n          }\n        });\n        var Marker = Class.extend({\n          init: function () {\n            this.caret = null;\n          },\n          addCaret: function (range) {\n            var that = this;\n            var caret = that.caret = dom.create(RangeUtils.documentFromRange(range), 'span', {\n              className: 'k-marker'\n            });\n            range.insertNode(caret);\n            dom.stripBomNode(caret.previousSibling);\n            dom.stripBomNode(caret.nextSibling);\n            range.selectNode(caret);\n            return caret;\n          },\n          removeCaret: function (range) {\n            var that = this,\n                previous = that.caret.previousSibling,\n                startOffset = 0;\n\n            if (previous) {\n              startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);\n            }\n\n            var container = that.caret.parentNode;\n            var containerIndex = previous ? findNodeIndex(previous) : 0;\n            dom.remove(that.caret);\n            normalize(container);\n            var node = container.childNodes[containerIndex];\n\n            if (isDataNode(node)) {\n              range.setStart(node, startOffset);\n            } else if (node) {\n              var textNode = dom.lastTextNode(node);\n\n              if (textNode) {\n                range.setStart(textNode, textNode.nodeValue.length);\n              } else {\n                range[previous ? 'setStartAfter' : 'setStartBefore'](node);\n              }\n            } else {\n              if (!browser.msie && !container.innerHTML) {\n                container.innerHTML = '<br _moz_dirty=\"\" />';\n              }\n\n              range.selectNodeContents(container);\n            }\n\n            range.collapse(true);\n          },\n          add: function (range, expand) {\n            var that = this;\n            var collapsed = range.collapsed && !RangeUtils.isExpandable(range);\n            var doc = RangeUtils.documentFromRange(range);\n\n            if (expand && range.collapsed) {\n              that.addCaret(range);\n              range = RangeUtils.expand(range);\n            }\n\n            var rangeBoundary = range.cloneRange();\n            rangeBoundary.collapse(false);\n            that.end = dom.create(doc, 'span', {\n              className: 'k-marker'\n            });\n            rangeBoundary.insertNode(that.end);\n            rangeBoundary = range.cloneRange();\n            rangeBoundary.collapse(true);\n            that.start = that.end.cloneNode(true);\n            rangeBoundary.insertNode(that.start);\n\n            that._removeDeadMarkers(that.start, that.end);\n\n            if (collapsed) {\n              var bom = doc.createTextNode(\"\\ufeff\");\n              dom.insertAfter(bom.cloneNode(), that.start);\n              dom.insertBefore(bom, that.end);\n            }\n\n            normalize(range.commonAncestorContainer);\n            range.setStartBefore(that.start);\n            range.setEndAfter(that.end);\n            return range;\n          },\n          _removeDeadMarkers: function (start, end) {\n            if (start.previousSibling && start.previousSibling.nodeValue == \"\\ufeff\") {\n              dom.remove(start.previousSibling);\n            }\n\n            if (end.nextSibling && end.nextSibling.nodeValue == \"\\ufeff\") {\n              dom.remove(end.nextSibling);\n            }\n          },\n          _normalizedIndex: function (node) {\n            var index = findNodeIndex(node);\n            var pointer = node;\n\n            while (pointer.previousSibling) {\n              if (pointer.nodeType == 3 && pointer.previousSibling.nodeType == 3) {\n                index--;\n              }\n\n              pointer = pointer.previousSibling;\n            }\n\n            return index;\n          },\n          remove: function (range) {\n            var that = this,\n                start = that.start,\n                end = that.end,\n                shouldNormalizeStart,\n                shouldNormalizeEnd,\n                shouldNormalize;\n            normalize(range.commonAncestorContainer);\n\n            while (!start.nextSibling && start.parentNode) {\n              start = start.parentNode;\n            }\n\n            while (!end.previousSibling && end.parentNode) {\n              end = end.parentNode;\n            } // merely accessing the siblings will solve range issues in IE\n\n\n            shouldNormalizeStart = start.previousSibling && start.previousSibling.nodeType == 3 && start.nextSibling && start.nextSibling.nodeType == 3;\n            shouldNormalizeEnd = end.previousSibling && end.previousSibling.nodeType == 3 && end.nextSibling && end.nextSibling.nodeType == 3;\n            shouldNormalize = shouldNormalizeStart && shouldNormalizeEnd;\n            start = start.nextSibling;\n            end = end.previousSibling;\n            var isBomSelected = start === end && dom.isBom(start);\n\n            if (isBomSelected && start.length > 1) {\n              start.nodeValue = start.nodeValue.charAt(0);\n            }\n\n            var collapsed = isBomSelected;\n            var collapsedToStart = false; // collapsed range\n\n            if (start == that.end) {\n              collapsedToStart = !!that.start.previousSibling;\n              start = end = that.start.previousSibling || that.end.nextSibling;\n              collapsed = true;\n            }\n\n            dom.remove(that.start);\n            dom.remove(that.end);\n\n            if (!start || !end) {\n              range.selectNodeContents(range.commonAncestorContainer);\n              range.collapse(true);\n              return;\n            }\n\n            var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;\n            var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;\n\n            if (start.nodeType == 3) {\n              while (start.previousSibling && start.previousSibling.nodeType == 3) {\n                start = start.previousSibling;\n                startOffset += start.nodeValue.length;\n              }\n            }\n\n            if (end.nodeType == 3) {\n              while (end.previousSibling && end.previousSibling.nodeType == 3) {\n                end = end.previousSibling;\n                endOffset += end.nodeValue.length;\n              }\n            }\n\n            var startParent = start.parentNode;\n            var endParent = end.parentNode;\n\n            var startIndex = this._normalizedIndex(start);\n\n            var endIndex = this._normalizedIndex(end);\n\n            normalize(startParent);\n\n            if (start.nodeType == 3) {\n              start = startParent.childNodes[startIndex];\n            }\n\n            normalize(endParent);\n\n            if (end.nodeType == 3) {\n              end = endParent.childNodes[endIndex];\n            }\n\n            if (collapsed) {\n              if (start.nodeType == 3) {\n                range.setStart(start, startOffset);\n              } else {\n                range[collapsedToStart ? 'setStartAfter' : 'setStartBefore'](start);\n              }\n\n              range.collapse(true);\n            } else {\n              if (start.nodeType == 3) {\n                range.setStart(start, startOffset);\n              } else {\n                range.setStartBefore(start);\n              }\n\n              if (end.nodeType == 3) {\n                range.setEnd(end, endOffset);\n              } else {\n                range.setEndAfter(end);\n              }\n            }\n\n            if (that.caret) {\n              that.removeCaret(range);\n            }\n          }\n        });\n        var boundary = /[\\u0009-\\u000d]|\\u0020|\\u00a0|\\ufeff|\\.|,|;|:|!|\\(|\\)|\\?/;\n        var RangeUtils = {\n          nodes: function (range) {\n            var nodes = RangeUtils.textNodes(range);\n\n            if (!nodes.length) {\n              range.selectNodeContents(range.commonAncestorContainer);\n              nodes = RangeUtils.textNodes(range);\n\n              if (!nodes.length) {\n                nodes = dom.significantChildNodes(range.commonAncestorContainer);\n              }\n            }\n\n            return nodes;\n          },\n          textNodes: function (range) {\n            var allNodes = new RangeEnumerator(range).enumerate(),\n                result = allNodes.filter(function (node) {\n              return dom.allowsTextContent(node.parentElement);\n            });\n            return result;\n          },\n          editableTextNodes: function (range) {\n            var nodes = [],\n                immutableParent = Editor.Immutables && Editor.Immutables.immutableParent;\n\n            if (immutableParent && !immutableParent(range.commonAncestorContainer)) {\n              nodes = new ImmutablesRangeEnumerator(range).enumerate();\n            }\n\n            return nodes;\n          },\n          documentFromRange: function (range) {\n            var startContainer = range.startContainer;\n            return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;\n          },\n          createRange: function (document) {\n            return document.createRange();\n          },\n          selectRange: function (range) {\n            var image = RangeUtils.image(range);\n\n            if (image) {\n              range.setStartAfter(image);\n              range.setEndAfter(image);\n            }\n\n            var selection = SelectionUtils.selectionFromRange(range);\n            selection.removeAllRanges();\n            selection.addRange(range);\n          },\n          stringify: function (range) {\n            return kendo.format(\"{0}:{1} - {2}:{3}\", dom.name(range.startContainer), range.startOffset, dom.name(range.endContainer), range.endOffset);\n          },\n          split: function (range, node, trim) {\n            function partition(start) {\n              var partitionRange = range.cloneRange();\n              partitionRange.collapse(start);\n              partitionRange[start ? 'setStartBefore' : 'setEndAfter'](node);\n              var contents = partitionRange.extractContents();\n\n              if (trim) {\n                contents = dom.trim(contents);\n              }\n\n              dom[start ? 'insertBefore' : 'insertAfter'](contents, node);\n            }\n\n            partition(true);\n            partition(false);\n          },\n          mapAll: function (range, map) {\n            var nodes = [];\n            new RangeIterator(range).traverse(function (node) {\n              var mapped = map(node);\n\n              if (mapped && $.inArray(mapped, nodes) < 0) {\n                nodes.push(mapped);\n              }\n            });\n            return nodes;\n          },\n          getAll: function (range, predicate) {\n            var selector = predicate;\n\n            if (typeof predicate == \"string\") {\n              predicate = function (node) {\n                return dom.is(node, selector);\n              };\n            }\n\n            return RangeUtils.mapAll(range, function (node) {\n              if (predicate(node)) {\n                return node;\n              }\n            });\n          },\n          getMarkers: function (range) {\n            return RangeUtils.getAll(range, function (node) {\n              return node.className == 'k-marker';\n            });\n          },\n          image: function (range) {\n            var nodes = RangeUtils.getAll(range, \"img\");\n\n            if (nodes.length == 1) {\n              return nodes[0];\n            }\n          },\n          isStartOf: function (originalRange, node) {\n            if (originalRange.startOffset !== 0) {\n              return false;\n            }\n\n            var range = originalRange.cloneRange();\n\n            while (range.startOffset === 0 && range.startContainer != node) {\n              var index = dom.findNodeIndex(range.startContainer);\n              var parent = range.startContainer.parentNode;\n\n              while (index > 0 && parent[index - 1] && dom.insignificant(parent[index - 1])) {\n                index--;\n              }\n\n              range.setStart(parent, index);\n            }\n\n            return range.startOffset === 0 && range.startContainer == node;\n          },\n          isEndOf: function (originalRange, node) {\n            var range = originalRange.cloneRange();\n            range.collapse(false);\n            var start = range.startContainer;\n\n            if (dom.isDataNode(start) && range.startOffset == dom.getNodeLength(start)) {\n              range.setStart(start.parentNode, dom.findNodeIndex(start) + 1);\n              range.collapse(true);\n            }\n\n            range.setEnd(node, dom.getNodeLength(node));\n            var nodes = [];\n\n            function visit(node) {\n              if (!dom.insignificant(node) && !(dom.isDataNode(node) && /^[\\ufeff]*$/.test(node.nodeValue))) {\n                nodes.push(node);\n              }\n            }\n\n            new RangeIterator(range).traverse(visit);\n            return !nodes.length;\n          },\n          wrapSelectedElements: function (range) {\n            var startEditable = dom.editableParent(range.startContainer);\n            var endEditable = dom.editableParent(range.endContainer);\n\n            while (range.startOffset === 0 && range.startContainer != startEditable) {\n              range.setStart(range.startContainer.parentNode, dom.findNodeIndex(range.startContainer));\n            }\n\n            function isEnd(offset, container) {\n              var length = dom.getNodeLength(container);\n\n              if (offset == length) {\n                return true;\n              }\n\n              for (var i = offset; i < length; i++) {\n                if (!dom.insignificant(container.childNodes[i])) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n\n            while (isEnd(range.endOffset, range.endContainer) && range.endContainer != endEditable) {\n              range.setEnd(range.endContainer.parentNode, dom.findNodeIndex(range.endContainer) + 1);\n            }\n\n            return range;\n          },\n          expand: function (range) {\n            var result = range.cloneRange();\n            var startContainer = result.startContainer.childNodes[result.startOffset === 0 ? 0 : result.startOffset - 1];\n            var endContainer = result.endContainer.childNodes[result.endOffset];\n\n            if (!isDataNode(startContainer) || !isDataNode(endContainer)) {\n              return result;\n            }\n\n            var beforeCaret = startContainer.nodeValue;\n            var afterCaret = endContainer.nodeValue;\n\n            if (!beforeCaret || !afterCaret) {\n              return result;\n            }\n\n            var startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n            var endOffset = afterCaret.search(boundary);\n\n            if (!startOffset || !endOffset) {\n              return result;\n            }\n\n            endOffset = endOffset == -1 ? afterCaret.length : endOffset;\n            startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;\n            result.setStart(startContainer, startOffset);\n            result.setEnd(endContainer, endOffset);\n            return result;\n          },\n          isExpandable: function (range) {\n            var node = range.startContainer;\n            var rangeDocument = RangeUtils.documentFromRange(range);\n\n            if (node == rangeDocument || node == rangeDocument.body) {\n              return false;\n            }\n\n            var result = range.cloneRange();\n            var value = node.nodeValue;\n\n            if (!value) {\n              return false;\n            }\n\n            var beforeCaret = value.substring(0, result.startOffset);\n            var afterCaret = value.substring(result.startOffset);\n            var startOffset = 0,\n                endOffset = 0;\n\n            if (beforeCaret) {\n              startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n            }\n\n            if (afterCaret) {\n              endOffset = afterCaret.search(boundary);\n            }\n\n            return startOffset && endOffset;\n          }\n        };\n        extend(Editor, {\n          SelectionUtils: SelectionUtils,\n          W3CRange: W3CRange,\n          RangeIterator: RangeIterator,\n          W3CSelection: W3CSelection,\n          RangeEnumerator: RangeEnumerator,\n          RestorePoint: RestorePoint,\n          Marker: Marker,\n          RangeUtils: RangeUtils\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1009:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./components\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}