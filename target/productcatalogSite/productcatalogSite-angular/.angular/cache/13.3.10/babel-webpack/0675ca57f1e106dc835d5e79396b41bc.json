{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(996);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  996:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(997)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            dom = Editor.Dom,\n            EditorUtils = Editor.EditorUtils,\n            registerTool = EditorUtils.registerTool,\n            Command = Editor.Command,\n            Tool = Editor.Tool,\n            ToolTemplate = Editor.ToolTemplate,\n            RangeUtils = Editor.RangeUtils,\n            blockElements = dom.blockElements,\n            BlockFormatFinder = Editor.BlockFormatFinder,\n            BlockFormatter = Editor.BlockFormatter;\n\n        function indent(node, value) {\n          var isRtl = $(node).css(\"direction\") == \"rtl\",\n              indentDirection = isRtl ? \"Right\" : \"Left\",\n              property = dom.name(node) != \"td\" ? \"margin\" + indentDirection : \"padding\" + indentDirection;\n\n          if (value === undefined) {\n            return node.style[property] || 0;\n          } else {\n            if (value > 0) {\n              node.style[property] = value + \"px\";\n            } else {\n              node.style[property] = \"\";\n\n              if (!node.style.cssText) {\n                node.removeAttribute(\"style\");\n              }\n            }\n          }\n        }\n\n        var IndentFormatter = Class.extend({\n          init: function () {\n            this.finder = new BlockFormatFinder([{\n              tags: dom.blockElements\n            }]);\n          },\n          apply: function (nodes) {\n            nodes = dom.filterBy(nodes, dom.htmlIndentSpace, true);\n            var formatNodes = this.finder.findSuitable(nodes),\n                targets = [],\n                i,\n                len,\n                formatNode,\n                parentList,\n                sibling;\n            formatNodes = this.mapImmutables(formatNodes);\n\n            if (formatNodes.length) {\n              for (i = 0, len = formatNodes.length; i < len; i++) {\n                if (dom.is(formatNodes[i], \"li\")) {\n                  if (!$(formatNodes[i]).index()) {\n                    targets.push(formatNodes[i].parentNode);\n                  } else if ($.inArray(formatNodes[i].parentNode, targets) < 0) {\n                    targets.push(formatNodes[i]);\n                  }\n                } else {\n                  targets.push(formatNodes[i]);\n                }\n              }\n\n              while (targets.length) {\n                formatNode = targets.shift();\n\n                if (dom.is(formatNode, \"li\")) {\n                  parentList = formatNode.parentNode;\n                  sibling = $(formatNode).prev(\"li\");\n                  var siblingList = sibling.find(\"ul,ol\").last();\n                  var nestedList = $(formatNode).children(\"ul,ol\")[0];\n\n                  if (nestedList && sibling[0]) {\n                    if (siblingList[0]) {\n                      siblingList.append(formatNode);\n                      siblingList.append($(nestedList).children());\n                      dom.remove(nestedList);\n                    } else {\n                      sibling.append(nestedList);\n                      nestedList.insertBefore(formatNode, nestedList.firstChild);\n                    }\n                  } else {\n                    nestedList = sibling.children(\"ul,ol\")[0];\n\n                    if (!nestedList) {\n                      nestedList = dom.create(formatNode.ownerDocument, dom.name(parentList), this.getListTypeAttr(parentList));\n                      sibling.append(nestedList);\n                    }\n\n                    while (formatNode && formatNode.parentNode == parentList) {\n                      nestedList.appendChild(formatNode);\n                      formatNode = targets.shift();\n                    }\n                  }\n                } else {\n                  var marginLeft = parseInt(indent(formatNode), 10) + 30;\n                  indent(formatNode, marginLeft);\n\n                  for (var targetIndex = 0; targetIndex < targets.length; targetIndex++) {\n                    if ($.contains(formatNode, targets[targetIndex])) {\n                      targets.splice(targetIndex, 1);\n                    }\n                  }\n                }\n              }\n            } else {\n              var formatter = new BlockFormatter([{\n                tags: [\"p\"]\n              }], {\n                style: {\n                  marginLeft: 30\n                }\n              });\n              formatter.apply(nodes);\n            }\n          },\n          getListTypeAttr: function (list) {\n            var type = list.getAttribute(\"type\");\n            var styleType = list.style.listStyleType;\n            return type ? {\n              type: type\n            } : {\n              style: {\n                listStyleType: styleType\n              }\n            };\n          },\n          mapImmutables: function (nodes) {\n            if (!this.immutables) {\n              return nodes;\n            } else {\n              var immutables = [];\n              return $.map(nodes, function (node) {\n                var immutable = Editor.Immutables.immutableParent(node);\n\n                if (immutable) {\n                  if ($.inArray(immutable, immutables) === -1) {\n                    immutables.push(immutable);\n                  } else {\n                    return null;\n                  }\n                }\n\n                return immutable || node;\n              });\n            }\n          },\n          remove: function (nodes) {\n            nodes = dom.filterBy(nodes, dom.htmlIndentSpace, true);\n            var formatNodes = this.finder.findSuitable(nodes),\n                targetNode,\n                i,\n                len,\n                list,\n                listParent,\n                siblings,\n                formatNode,\n                marginLeft;\n            formatNodes = this.mapImmutables(formatNodes);\n\n            for (i = 0, len = formatNodes.length; i < len; i++) {\n              formatNode = $(formatNodes[i]);\n\n              if (formatNode.is(\"li\")) {\n                list = formatNode.parent();\n                listParent = list.parent(); // listParent will be ul or ol in case of invalid dom - <ul><li></li><ul><li></li></ul></ul>\n\n                if (listParent.is(\"li,ul,ol\") && !indent(list[0])) {\n                  // skip already processed nodes\n                  if (targetNode && $.contains(targetNode, listParent[0])) {\n                    continue;\n                  }\n\n                  siblings = formatNode.nextAll(\"li\");\n\n                  if (siblings.length) {\n                    $(list[0].cloneNode(false)).appendTo(formatNode).append(siblings);\n                  }\n\n                  if (listParent.is(\"li\")) {\n                    formatNode.insertAfter(listParent);\n                  } else {\n                    formatNode.appendTo(listParent);\n                  }\n\n                  if (!list.children(\"li\").length) {\n                    list.remove();\n                  }\n\n                  continue;\n                } else {\n                  if (targetNode == list[0]) {\n                    // removing format on sibling LI elements\n                    continue;\n                  }\n\n                  targetNode = list[0];\n                }\n              } else {\n                targetNode = formatNodes[i];\n              }\n\n              marginLeft = parseInt(indent(targetNode), 10) - 30;\n              indent(targetNode, marginLeft);\n            }\n          }\n        });\n        var IndentCommand = Command.extend({\n          init: function (options) {\n            var that = this;\n            options.formatter =\n            /** @ignore */\n            {\n              toggle: function (range) {\n                var indentFormatter = new IndentFormatter();\n                indentFormatter.immutables = this.editor && this.editor.options.immutables;\n                indentFormatter.apply(RangeUtils.nodes(range));\n              }.bind(that)\n            };\n            Command.fn.init.call(this, options);\n          }\n        });\n        var OutdentCommand = Command.extend({\n          init: function (options) {\n            var that = this;\n            options.formatter = {\n              toggle: function (range) {\n                var indentFormatter = new IndentFormatter();\n                indentFormatter.immutables = this.editor && this.editor.options.immutables;\n                indentFormatter.remove(RangeUtils.nodes(range));\n              }.bind(that)\n            };\n            Command.fn.init.call(this, options);\n          }\n        });\n        var OutdentTool = Tool.extend({\n          init: function (options) {\n            Tool.fn.init.call(this, options);\n            this.finder = new BlockFormatFinder([{\n              tags: blockElements\n            }]);\n          },\n          initialize: function (ui, options) {\n            Tool.fn.initialize.call(this, ui, options);\n            $.extend(this.options, {\n              immutables: options.editor && options.editor.options.immutables\n            });\n            ui.addClass(\"k-disabled\");\n          },\n          update: function (ui, nodes) {\n            var suitableNodes = this.finder.findSuitable(nodes),\n                isOutdentable,\n                listParentsCount,\n                i,\n                len,\n                suitable,\n                immutableParent;\n\n            for (i = 0, len = suitableNodes.length; i < len; i++) {\n              suitable = suitableNodes[i];\n\n              if (this.options.immutables) {\n                immutableParent = Editor.Immutables.immutableParent(suitable);\n\n                if (immutableParent) {\n                  suitable = immutableParent;\n                }\n              }\n\n              isOutdentable = indent(suitable);\n\n              if (!isOutdentable) {\n                listParentsCount = $(suitable).parents(\"ul,ol\").length;\n                isOutdentable = dom.is(suitable, \"li\") && (listParentsCount > 1 || indent(suitable.parentNode)) || dom.ofType(suitable, [\"ul\", \"ol\"]) && listParentsCount > 0;\n              }\n\n              if (isOutdentable) {\n                ui.removeClass(\"k-disabled\");\n                return;\n              }\n            }\n\n            ui.addClass(\"k-disabled\").removeClass(\"k-hover\");\n          }\n        });\n        extend(Editor, {\n          IndentFormatter: IndentFormatter,\n          IndentCommand: IndentCommand,\n          OutdentCommand: OutdentCommand,\n          OutdentTool: OutdentTool\n        });\n        registerTool(\"indent\", new Tool({\n          command: IndentCommand,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Indent\"\n          })\n        }));\n        registerTool(\"outdent\", new OutdentTool({\n          command: OutdentCommand,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Outdent\"\n          })\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  997:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./formatblock\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}