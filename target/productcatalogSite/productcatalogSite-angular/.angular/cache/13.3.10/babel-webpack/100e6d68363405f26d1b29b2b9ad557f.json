{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1684);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1684:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        var $ = kendo.jQuery;\n        var CellRef = kendo.spreadsheet.CellRef;\n        var Clipboard = kendo.Class.extend({\n          init: function (workbook) {\n            this._content = {};\n            this._externalContent = {};\n            this._internalContent = {};\n            this.workbook = workbook;\n            this.origin = kendo.spreadsheet.NULLREF;\n            this.iframe = document.createElement(\"iframe\");\n            this.iframe.className = \"k-spreadsheet-clipboard-paste\";\n            this.iframe.setAttribute(\"title\", \"Spreadsheet clipboard iframe\");\n            this.menuInvoked = false;\n            this._uid = kendo.guid();\n            document.body.appendChild(this.iframe);\n          },\n          destroy: function () {\n            $(this.iframe).remove();\n          },\n          canCopy: function () {\n            var status = {\n              canCopy: true\n            };\n            var selection = this.workbook.activeSheet().select();\n\n            if (selection === kendo.spreadsheet.NULLREF) {\n              status.canCopy = false;\n            }\n\n            if (selection instanceof kendo.spreadsheet.UnionRef) {\n              status.canCopy = false;\n              status.multiSelection = true;\n            }\n\n            if (this.menuInvoked) {\n              status.canCopy = false;\n              status.menuInvoked = true;\n            }\n\n            return status;\n          },\n          canPaste: function () {\n            var sheet = this.workbook.activeSheet();\n            var ref = this.pasteRef();\n            var range = sheet.range(ref);\n            var status = {\n              canPaste: true,\n              pasteOnMerged: false,\n              pasteOnDisabled: false\n            };\n\n            if (!range.enable()) {\n              status.canPaste = false;\n              status.pasteOnDisabled = true;\n            }\n\n            if (!ref.eq(sheet.unionWithMerged(ref))) {\n              status.canPaste = false;\n              status.pasteOnMerged = true;\n            }\n\n            if (this.menuInvoked) {\n              status.canPaste = false;\n              status.menuInvoked = true;\n            }\n\n            return status;\n          },\n          intersectsMerged: function () {\n            var sheet = this.workbook.activeSheet();\n            this.parse();\n            this.origin = this._content.origRef;\n            var ref = this.pasteRef();\n            return !ref.eq(sheet.unionWithMerged(ref));\n          },\n          copy: function () {\n            var sheet = this.workbook.activeSheet();\n            this.origin = sheet.select();\n            this._internalContent = sheet.selection().getState();\n            delete this._externalContent.html;\n            delete this._externalContent.plain;\n          },\n          cut: function () {\n            var sheet = this.workbook.activeSheet();\n            this.copy();\n            sheet.range(sheet.select()).clear();\n          },\n          pasteRef: function () {\n            var sheet = this.workbook.activeSheet(); // When pasting from an external source, origin will be\n            // NULLREF.  Just return the destination range.\n            // https://github.com/telerik/kendo-ui-core/issues/3486\n\n            if (this.origin === kendo.spreadsheet.NULLREF) {\n              return sheet.select();\n            }\n\n            var destination = sheet.activeCell().first();\n            var originActiveCell = this.origin.first();\n            var rowDelta = originActiveCell.row - destination.row;\n            var colDelta = originActiveCell.col - destination.col;\n            return this.origin.relative(rowDelta, colDelta, 3);\n          },\n          paste: function () {\n            var sheet = this.workbook.activeSheet();\n            var pasteRef = this.pasteRef();\n\n            if (pasteRef.bottomRight.row >= sheet._rows._count || pasteRef.bottomRight.col >= sheet._columns._count) {\n              sheet.resize(Math.max(pasteRef.bottomRight.row + 1, sheet._rows._count), Math.max(pasteRef.bottomRight.col + 1, sheet._columns._count));\n            }\n\n            sheet.range(pasteRef).setState(this._content, this);\n            sheet.triggerChange({\n              recalc: true,\n              ref: pasteRef\n            });\n          },\n          external: function (data) {\n            if (data && (data.html || data.plain)) {\n              this._externalContent = data;\n            } else {\n              return this._externalContent;\n            }\n          },\n          isExternal: function () {\n            return !this._isInternal();\n          },\n          parse: function () {\n            var state = newState();\n\n            if (this._isInternal()) {\n              state = this._internalContent;\n            } else {\n              var data = this._externalContent;\n\n              if (data.html) {\n                var doc = this.iframe.contentWindow.document;\n                doc.open();\n                doc.write(data.html);\n                doc.close();\n                var table = doc.querySelector(\"table\");\n\n                if (table) {\n                  state = parseHTML(table);\n                } else {\n                  state = parseTSV(data.plain);\n                }\n              } else {\n                state = parseTSV(data.plain);\n              }\n\n              this.origin = state.origRef;\n            }\n\n            this._content = state;\n          },\n          _isInternal: function () {\n            if (this._externalContent.html === undefined) {\n              return true;\n            }\n\n            var internalHTML = $(\"<div/>\").html(this._externalContent.html).find(\"table.kendo-clipboard-\" + this._uid).length ? true : false;\n            var internalPlain = $(\"<div/>\").html(this._externalContent.plain).find(\"table.kendo-clipboard-\" + this._uid).length ? true : false;\n            return internalHTML || internalPlain;\n          }\n        });\n        kendo.spreadsheet.Clipboard = Clipboard;\n\n        function newState() {\n          var ref = new CellRef(0, 0, 0);\n          return {\n            ref: ref,\n            mergedCells: [],\n            data: [],\n            foreign: true,\n            origRef: ref.toRangeRef()\n          };\n        }\n\n        function setStateData(state, row, col, value) {\n          var data = state.data || (state.data = []);\n\n          if (!data[row]) {\n            data[row] = [];\n          }\n\n          data[row][col] = value;\n          var br = state.origRef.bottomRight;\n          br.row = Math.max(br.row, row);\n          br.col = Math.max(br.col, col);\n        }\n\n        function stripStyle(style) {\n          return style.replace(/^-(?:ms|moz|webkit)-/, \"\");\n        }\n\n        function borderObject(styles) {\n          var obj = {};\n          [\"borderBottom\", \"borderRight\", \"borderLeft\", \"borderTop\"].forEach(function (key) {\n            obj[key] = styles[key + \"Style\"] == \"none\" ? null : {\n              size: 1,\n              color: styles[key + \"Color\"]\n            };\n          });\n          return obj;\n        }\n\n        function cellState(row, col, element, hBorders, vBorders) {\n          var styles = window.getComputedStyle(element); // note: Chrome 70 appends a \\t to a cell's text, which is actually mandated by the standard\n          // ([1] item 6).  We remove it below.  In [2] it's suggested they might switch back to\n          // previous behavior, but removing an eventual last TAB won't hurt anyway.\n          //\n          // [1] https://www.w3.org/TR/html53/dom.html#dom-htmlelement-innertext\n          // [2] https://bugs.chromium.org/p/chromium/issues/detail?id=897373\n\n          var text = element.innerText.replace(/\\t$/, \"\");\n          var borders = borderObject(styles);\n          var state = {\n            value: text === \"\" ? null : text,\n            borderTop: borders.borderTop || hBorders.get(row, col) || null,\n            borderBottom: borders.borderBottom || hBorders.get(row + 1, col) || null,\n            borderLeft: borders.borderLeft || vBorders.get(row, col) || null,\n            borderRight: borders.borderRight || vBorders.get(row, col + 1) || null,\n            fontSize: parseInt(styles[\"font-size\"], 10)\n          };\n          hBorders.set(row, col, state.borderTop);\n          hBorders.set(row + 1, col, state.borderBottom);\n          vBorders.set(row, col, state.borderLeft);\n          vBorders.set(row, col + 1, state.borderRight);\n\n          if (styles[\"background-color\"] !== \"rgb(0, 0, 0)\" && styles[\"background-color\"] !== \"rgba(0, 0, 0, 0)\") {\n            state.background = styles[\"background-color\"];\n          }\n\n          if (styles.color !== \"rgb(0, 0, 0)\" && styles.color !== \"rgba(0, 0, 0, 0)\") {\n            state.color = styles.color;\n          }\n\n          if (styles[\"text-decoration\"] == \"underline\") {\n            state.underline = true;\n          }\n\n          if (styles[\"font-style\"] == \"italic\") {\n            state.italic = true;\n          }\n\n          if (styles[\"font-weight\"] == \"bold\") {\n            state.bold = true;\n          }\n\n          if (stripStyle(styles[\"text-align\"]) !== \"right\") {\n            state.textAlign = stripStyle(styles[\"text-align\"]);\n          }\n\n          if (styles[\"vertical-align\"] !== \"middle\") {\n            state.verticalAlign = styles[\"vertical-align\"];\n          }\n\n          if (styles[\"word-wrap\"] !== \"normal\") {\n            state.wrap = true;\n          }\n\n          return state;\n        }\n\n        function parseHTML(table) {\n          var state = newState();\n          var done = [],\n              row = 0,\n              col = 0;\n\n          for (var i = 0; i < table.rows.length; ++i) {\n            done.push([]);\n          }\n\n          var hBorders = new kendo.spreadsheet.calc.runtime.Matrix();\n          var vBorders = new kendo.spreadsheet.calc.runtime.Matrix();\n\n          for (var ri = 0; ri < table.rows.length; ++ri, ++row) {\n            var tr = table.rows[ri];\n            col = 0;\n\n            for (var ci = 0; ci < tr.cells.length; ++ci) {\n              var td = tr.cells[ci];\n              var rowSpan = td.rowSpan;\n              var colSpan = td.colSpan;\n\n              while (done[row][col]) {\n                col++;\n              } // A cell containing a long text overflowing the next (empty) cell will weirdly be\n              // reported as merged by Excel (has colspan=2).  Then, Excel informatively suggests\n              // us to ignore the colSpan by passing mso-ignore:colspan in the style.  Much thanks!\n              // https://github.com/telerik/kendo-ui-core/issues/3760\n\n\n              var style = td.getAttribute(\"style\");\n              var ignoreColspan = /mso-ignore:colspan/.test(style);\n              setStateData(state, row, col, cellState(row, col, td, hBorders, vBorders));\n\n              if (rowSpan > 1 || colSpan > 1 && !ignoreColspan) {\n                state.mergedCells.push(new kendo.spreadsheet.RangeRef(new CellRef(row, col), new CellRef(row + rowSpan - 1, col + colSpan - 1)).toString());\n              }\n\n              for (var dr = row + rowSpan; --dr >= row;) {\n                for (var dc = col + colSpan; --dc >= col;) {\n                  if (dr < done.length) {\n                    done[dr][dc] = true;\n\n                    if (!(dr == row && dc == col)) {\n                      setStateData(state, dr, dc, {});\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          return state;\n        }\n\n        function parseTSV(data) {\n          var state = newState();\n\n          if (data.indexOf(\"\\t\") === -1 && data.indexOf(\"\\n\") == -1) {\n            setStateData(state, 0, 0, {\n              value: data\n            });\n          } else {\n            var rows = data.split(\"\\n\");\n\n            for (var ri = 0; ri < rows.length; ri++) {\n              var cols = rows[ri].split(\"\\t\");\n\n              for (var ci = 0; ci < cols.length; ci++) {\n                setStateData(state, ri, ci, {\n                  value: cols[ci]\n                });\n              }\n            }\n          }\n\n          return state;\n        }\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}