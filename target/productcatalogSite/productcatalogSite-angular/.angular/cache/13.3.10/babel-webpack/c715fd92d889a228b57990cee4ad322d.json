{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport Bar from './bar';\nimport CategoricalChart from '../categorical-chart';\nimport ClusterLayout from '../layout/cluster-layout';\nimport StackWrap from '../layout/stack-wrap';\nimport { BAR, OUTSIDE_END, INSIDE_END } from '../constants';\nimport anyHasZIndex from '../utils/any-has-z-index';\nimport { STRING, X, Y } from '../../common/constants';\nimport { defined, isFunction, setDefaultOptions } from '../../common';\n\nclass BarChart extends CategoricalChart {\n  render() {\n    super.render();\n    this.updateStackRange();\n  }\n\n  pointType() {\n    return Bar;\n  }\n\n  clusterType() {\n    return ClusterLayout;\n  }\n\n  stackType() {\n    return StackWrap;\n  }\n\n  stackLimits(axisName, stackName) {\n    const limits = super.stackLimits(axisName, stackName);\n    return limits;\n  }\n\n  createPoint(data, fields) {\n    const {\n      categoryIx,\n      category,\n      series,\n      seriesIx\n    } = fields;\n    const {\n      options,\n      children\n    } = this;\n    const isStacked = options.isStacked;\n    const value = this.pointValue(data);\n    let pointOptions = this.pointOptions(series, seriesIx);\n    const labelOptions = pointOptions.labels;\n\n    if (isStacked) {\n      if (labelOptions.position === OUTSIDE_END) {\n        labelOptions.position = INSIDE_END;\n      }\n    }\n\n    pointOptions.isStacked = isStacked;\n    let color = data.fields.color || series.color;\n\n    if (value < 0 && pointOptions.negativeColor) {\n      color = pointOptions.negativeColor;\n    }\n\n    pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    const pointType = this.pointType();\n    const point = new pointType(value, pointOptions);\n    point.color = color;\n    let cluster = children[categoryIx];\n\n    if (!cluster) {\n      const clusterType = this.clusterType();\n      cluster = new clusterType({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n\n    if (isStacked) {\n      const stackWrap = this.getStackWrap(series, cluster);\n      stackWrap.append(point);\n    } else {\n      cluster.append(point);\n    }\n\n    return point;\n  }\n\n  getStackWrap(series, cluster) {\n    const stack = series.stack;\n    const stackGroup = stack ? stack.group || stack : stack;\n    const wraps = cluster.children;\n    let stackWrap;\n\n    if (typeof stackGroup === STRING) {\n      for (let i = 0; i < wraps.length; i++) {\n        if (wraps[i]._stackGroup === stackGroup) {\n          stackWrap = wraps[i];\n          break;\n        }\n      }\n    } else {\n      stackWrap = wraps[0];\n    }\n\n    if (!stackWrap) {\n      const stackType = this.stackType();\n      stackWrap = new stackType({\n        vertical: !this.options.invertAxes\n      });\n      stackWrap._stackGroup = stackGroup;\n      cluster.append(stackWrap);\n    }\n\n    return stackWrap;\n  }\n\n  categorySlot(categoryAxis, categoryIx, valueAxis) {\n    const options = this.options;\n    const categorySlot = categoryAxis.getSlot(categoryIx);\n    const startValue = valueAxis.startValue();\n\n    if (options.isStacked) {\n      const zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n      const stackAxis = options.invertAxes ? X : Y;\n      categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n    }\n\n    return categorySlot;\n  }\n\n  reflowCategories(categorySlots) {\n    const children = this.children;\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      children[i].reflow(categorySlots[i]);\n    }\n  }\n\n  createAnimation() {\n    this._setAnimationOptions();\n\n    super.createAnimation();\n\n    if (anyHasZIndex(this.options.series)) {\n      this._setChildrenAnimation();\n    }\n  }\n\n  _setChildrenAnimation() {\n    const points = this.points;\n\n    for (let idx = 0; idx < points.length; idx++) {\n      const point = points[idx];\n      const pointVisual = point.visual;\n\n      if (pointVisual && defined(pointVisual.options.zIndex)) {\n        point.options.animation = this.options.animation;\n        point.createAnimation();\n      }\n    }\n  }\n\n  _setAnimationOptions() {\n    const options = this.options;\n    const animation = options.animation || {};\n    let origin;\n\n    if (options.isStacked) {\n      const valueAxis = this.seriesValueAxis(options.series[0]);\n      origin = valueAxis.getSlot(valueAxis.startValue());\n    } else {\n      origin = this.categoryAxis.getSlot(0);\n    }\n\n    animation.origin = new geom.Point(origin.x1, origin.y1);\n    animation.vertical = !options.invertAxes;\n  }\n\n}\n\nsetDefaultOptions(BarChart, {\n  animation: {\n    type: BAR\n  }\n});\nexport default BarChart;","map":null,"metadata":{},"sourceType":"module"}