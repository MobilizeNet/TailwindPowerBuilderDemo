{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(988);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  988:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(989)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            formats = kendo.ui.Editor.fn.options.formats,\n            dom = Editor.Dom,\n            ToolTemplate = Editor.ToolTemplate,\n            FormatTool = Editor.FormatTool,\n            EditorUtils = Editor.EditorUtils,\n            registerTool = EditorUtils.registerTool,\n            registerFormat = EditorUtils.registerFormat,\n            RangeUtils = Editor.RangeUtils;\n        var BlockFormatFinder = Class.extend({\n          init: function (format) {\n            this.format = format;\n          },\n          contains: function (node, children) {\n            var i, len, child;\n\n            for (i = 0, len = children.length; i < len; i++) {\n              child = children[i];\n\n              if (!child || !dom.isAncestorOrSelf(node, child)) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          findSuitable: function (nodes) {\n            var format = this.format,\n                suitable = [],\n                i,\n                len,\n                candidate;\n\n            for (i = 0, len = nodes.length; i < len; i++) {\n              for (var f = format.length - 1; f >= 0; f--) {\n                candidate = dom.ofType(nodes[i], format[f].tags) ? nodes[i] : dom.closestEditableOfType(nodes[i], format[f].tags);\n\n                if (candidate) {\n                  break;\n                }\n              }\n\n              if (!candidate || candidate.contentEditable === 'true') {\n                return [];\n              }\n\n              if ($.inArray(candidate, suitable) < 0) {\n                suitable.push(candidate);\n              }\n            }\n\n            this._resolveListsItems(suitable);\n\n            for (i = 0, len = suitable.length; i < len; i++) {\n              if (this.contains(suitable[i], suitable)) {\n                return [suitable[i]];\n              }\n            }\n\n            return suitable;\n          },\n          _resolveListsItems: function (nodes) {\n            var i, node, wrapper;\n\n            for (i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n              wrapper = dom.is(node, \"li\") ? node : dom.wrapper(node);\n              wrapper = wrapper && dom.list(wrapper) ? wrapper.children[0] : wrapper;\n\n              if (dom.is(wrapper, \"li\")) {\n                node = nodes[i] = wrapper;\n              }\n            }\n          },\n          findFormat: function (sourceNode, until) {\n            var format = this.format,\n                i,\n                len,\n                node,\n                tags,\n                attributes;\n            var editableParent = dom.editableParent(sourceNode);\n            var immutables = this.options && this.options.immutables;\n            var ImmutablesNS = Editor.Immutables;\n\n            for (i = 0, len = format.length; i < len; i++) {\n              node = sourceNode;\n              tags = format[i].tags;\n              attributes = format[i].attr;\n\n              if (immutables && tags && tags[0] == \"immutable\") {\n                var immutable = ImmutablesNS.immutableParent(node);\n\n                if (immutable && dom.attrEquals(immutable, attributes)) {\n                  return node;\n                }\n              }\n\n              while (node && dom.isAncestorOf(editableParent, node)) {\n                if (dom.ofType(node, tags) && dom.attrEquals(node, attributes)) {\n                  return node;\n                }\n\n                if (until && until(node)) {\n                  break;\n                }\n\n                node = node.parentNode;\n              }\n            }\n\n            return null;\n          },\n          getFormat: function (nodes) {\n            var that = this,\n                findFormat = function (node) {\n              return that.findFormat(dom.isDataNode(node) ? node.parentNode : node);\n            },\n                result = findFormat(nodes[0]),\n                i,\n                len;\n\n            if (!result) {\n              return \"\";\n            }\n\n            for (i = 1, len = nodes.length; i < len; i++) {\n              if (result != findFormat(nodes[i])) {\n                return \"\";\n              }\n            }\n\n            return result.nodeName.toLowerCase();\n          },\n          isFormatted: function (nodes, until) {\n            for (var i = 0, len = nodes.length; i < len; i++) {\n              if (!this.findFormat(nodes[i], until)) {\n                return false;\n              }\n            }\n\n            return true;\n          }\n        });\n        var BlockFormatter = Class.extend({\n          init: function (format, values) {\n            this.format = format;\n            this.values = values;\n            this.finder = new BlockFormatFinder(format);\n          },\n          wrap: function (tag, attributes, nodes) {\n            var commonAncestor = nodes.length == 1 ? dom.blockParentOrBody(nodes[0]) : dom.commonAncestor.apply(null, nodes);\n\n            if (dom.isInline(commonAncestor)) {\n              commonAncestor = dom.blockParentOrBody(commonAncestor);\n            }\n\n            var ancestors = dom.significantChildNodes(commonAncestor),\n                position = dom.findNodeIndex(ancestors[0]),\n                wrapper = dom.create(commonAncestor.ownerDocument, tag, attributes),\n                i,\n                ancestor;\n\n            for (i = 0; i < ancestors.length; i++) {\n              ancestor = ancestors[i];\n\n              if (dom.isBlock(ancestor)) {\n                dom.attr(ancestor, attributes);\n\n                if (wrapper.childNodes.length) {\n                  dom.insertBefore(wrapper, ancestor);\n                  wrapper = wrapper.cloneNode(false);\n                }\n\n                position = dom.findNodeIndex(ancestor) + 1;\n                continue;\n              }\n\n              wrapper.appendChild(ancestor);\n            }\n\n            if (wrapper.firstChild) {\n              dom.insertAt(commonAncestor, wrapper, position);\n            }\n          },\n          apply: function (nodes) {\n            var format,\n                values = this.values;\n\n            function attributes(format) {\n              return extend({}, format && format.attr, values);\n            }\n\n            this._handleImmutables(nodes, true);\n\n            var images = dom.filter(\"img\", nodes);\n            var imageFormat = EditorUtils.formatByName(\"img\", this.format);\n            var imageAttributes = attributes(imageFormat);\n            $.each(images, function () {\n              dom.attr(this, imageAttributes);\n            }); // only images were selected, no need to wrap\n\n            if (images.length == nodes.length) {\n              return;\n            }\n\n            var nonImages = dom.filter(\"img\", nodes, true);\n            var formatNodes = this.finder.findSuitable(nonImages);\n\n            if (formatNodes.length) {\n              for (var i = 0, len = formatNodes.length; i < len; i++) {\n                format = EditorUtils.formatByName(dom.name(formatNodes[i]), this.format);\n                dom.attr(formatNodes[i], attributes(format));\n              }\n            } else {\n              format = this.format[0];\n              this.wrap(format.tags[0], attributes(format), nonImages);\n            }\n          },\n          _handleImmutables: function (nodes, applyFormatting) {\n            if (!this.immutables()) {\n              return;\n            }\n\n            var immutableFormat = EditorUtils.formatByName(\"immutable\", this.format);\n\n            if (!immutableFormat) {\n              return;\n            }\n\n            var ImmutablesNS = Editor.Immutables;\n            var l = nodes.length - 1;\n\n            for (var i = l; i >= 0; i--) {\n              var immutableParent = ImmutablesNS.immutableParent(nodes[i]);\n\n              if (!immutableParent) {\n                continue;\n              }\n\n              if (immutableParent !== nodes[i + 1]) {\n                if (applyFormatting) {\n                  dom.attr(immutableParent, immutableFormat.attr);\n                } else {\n                  dom.unstyle(immutableParent, immutableFormat.attr.style);\n                }\n              }\n\n              nodes.splice(i, 1);\n            }\n          },\n          immutables: function () {\n            return this.editor && this.editor.options.immutables;\n          },\n          remove: function (nodes) {\n            var i, l, formatNode, namedFormat, name;\n\n            this._handleImmutables(nodes, false);\n\n            for (i = 0, l = nodes.length; i < l; i++) {\n              formatNode = this.finder.findFormat(nodes[i]);\n\n              if (formatNode) {\n                name = dom.name(formatNode);\n                namedFormat = EditorUtils.formatByName(name, this.format);\n\n                if (namedFormat.attr.style) {\n                  dom.unstyle(formatNode, namedFormat.attr.style);\n                }\n\n                if (namedFormat.attr.className) {\n                  dom.removeClass(formatNode, namedFormat.attr.className);\n                }\n              }\n            }\n          },\n          toggle: function (range) {\n            var that = this,\n                nodes = dom.filterBy(RangeUtils.nodes(range), dom.htmlIndentSpace, true);\n\n            if (that.finder.isFormatted(nodes)) {\n              that.remove(nodes);\n            } else {\n              that.apply(nodes);\n            }\n          }\n        });\n        var GreedyBlockFormatter = Class.extend({\n          init: function (format, values) {\n            var that = this;\n            that.format = format;\n            that.values = values;\n            that.finder = new BlockFormatFinder(format);\n          },\n          apply: function (nodes) {\n            var format = this.format;\n            var blocks = dom.blockParents(nodes);\n            var formatTag = format[0].tags[0];\n            var i, len, list, formatter, range;\n            var element;\n            var tagName;\n            var block;\n            var immutalbeParent;\n\n            if (blocks.length) {\n              for (i = 0, len = blocks.length; i < len; i++) {\n                block = blocks[i];\n                immutalbeParent = this.immutables() && Editor.Immutables.immutableParent(block);\n\n                if (!immutalbeParent) {\n                  tagName = dom.name(block);\n\n                  if (tagName == \"li\") {\n                    list = block.parentNode;\n                    formatter = new Editor.ListFormatter(list.nodeName.toLowerCase(), formatTag);\n                    range = this.editor.createRange();\n                    range.selectNode(blocks[i]);\n                    formatter.toggle(range);\n                  } else if (formatTag && (tagName == \"td\" || block.attributes.contentEditable)) {\n                    new BlockFormatter(format, this.values).apply(block.childNodes);\n                  } else {\n                    element = dom.changeTag(block, formatTag);\n                    dom.attr(element, format[0].attr);\n                  }\n                }\n              }\n            } else {\n              var blockFormatter = new BlockFormatter(format, this.values);\n              blockFormatter.editor = this.editor;\n              blockFormatter.apply(nodes);\n            }\n          },\n          toggle: function (range) {\n            var nodes = RangeUtils.textNodes(range);\n\n            if (!nodes.length) {\n              range.selectNodeContents(range.commonAncestorContainer);\n              nodes = RangeUtils.textNodes(range);\n\n              if (!nodes.length) {\n                nodes = dom.significantChildNodes(range.commonAncestorContainer);\n              }\n            }\n\n            this.apply(nodes);\n          },\n          immutables: function () {\n            return this.editor && this.editor.options.immutables;\n          }\n        });\n        var BlockFormatTool = FormatTool.extend({\n          init: function (options) {\n            FormatTool.fn.init.call(this, extend(options, {\n              finder: new BlockFormatFinder(options.format),\n              formatter: function () {\n                return new BlockFormatter(options.format);\n              }\n            }));\n          }\n        });\n        extend(Editor, {\n          BlockFormatFinder: BlockFormatFinder,\n          BlockFormatter: BlockFormatter,\n          GreedyBlockFormatter: GreedyBlockFormatter,\n          BlockFormatTool: BlockFormatTool\n        });\n        var listElements = [\"ul\", \"ol\", \"li\"];\n        registerFormat(\"justifyLeft\", [{\n          tags: dom.nonListBlockElements,\n          attr: {\n            style: {\n              textAlign: \"left\"\n            }\n          }\n        }, {\n          tags: [\"img\"],\n          attr: {\n            style: {\n              \"float\": \"left\",\n              display: \"\",\n              marginLeft: \"\",\n              marginRight: \"\"\n            }\n          }\n        }, {\n          tags: [\"immutable\"],\n          attr: {\n            style: {\n              \"float\": \"left\",\n              display: \"\",\n              marginLeft: \"\",\n              marginRight: \"\"\n            }\n          }\n        }, {\n          tags: listElements,\n          attr: {\n            style: {\n              textAlign: \"left\",\n              listStylePosition: \"\"\n            }\n          }\n        }]);\n        registerTool(\"justifyLeft\", new BlockFormatTool({\n          format: formats.justifyLeft,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Justify Left\"\n          })\n        }));\n        registerFormat(\"justifyCenter\", [{\n          tags: dom.nonListBlockElements,\n          attr: {\n            style: {\n              textAlign: \"center\"\n            }\n          }\n        }, {\n          tags: [\"img\"],\n          attr: {\n            style: {\n              display: \"block\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n              \"float\": \"\"\n            }\n          }\n        }, {\n          tags: [\"immutable\"],\n          attr: {\n            style: {\n              display: \"block\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n              \"float\": \"\"\n            }\n          }\n        }, {\n          tags: listElements,\n          attr: {\n            style: {\n              textAlign: \"center\",\n              listStylePosition: \"inside\"\n            }\n          }\n        }]);\n        registerTool(\"justifyCenter\", new BlockFormatTool({\n          format: formats.justifyCenter,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Justify Center\"\n          })\n        }));\n        registerFormat(\"justifyRight\", [{\n          tags: dom.nonListBlockElements,\n          attr: {\n            style: {\n              textAlign: \"right\"\n            }\n          }\n        }, {\n          tags: [\"img\"],\n          attr: {\n            style: {\n              \"float\": \"right\",\n              display: \"\",\n              marginLeft: \"\",\n              marginRight: \"\"\n            }\n          }\n        }, {\n          tags: [\"immutable\"],\n          attr: {\n            style: {\n              \"float\": \"right\",\n              display: \"\",\n              marginLeft: \"\",\n              marginRight: \"\"\n            }\n          }\n        }, {\n          tags: listElements,\n          attr: {\n            style: {\n              textAlign: \"right\",\n              listStylePosition: \"inside\"\n            }\n          }\n        }]);\n        registerTool(\"justifyRight\", new BlockFormatTool({\n          format: formats.justifyRight,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Justify Right\"\n          })\n        }));\n        registerFormat(\"justifyFull\", [{\n          tags: dom.nonListBlockElements,\n          attr: {\n            style: {\n              textAlign: \"justify\"\n            }\n          }\n        }, {\n          tags: [\"img\"],\n          attr: {\n            style: {\n              display: \"block\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n              \"float\": \"\"\n            }\n          }\n        }, {\n          tags: [\"immutable\"],\n          attr: {\n            style: {\n              display: \"block\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n              \"float\": \"\"\n            }\n          }\n        }, {\n          tags: listElements,\n          attr: {\n            style: {\n              textAlign: \"justify\",\n              listStylePosition: \"\"\n            }\n          }\n        }]);\n        registerTool(\"justifyFull\", new BlockFormatTool({\n          format: formats.justifyFull,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Justify Full\"\n          })\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  989:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./format\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}