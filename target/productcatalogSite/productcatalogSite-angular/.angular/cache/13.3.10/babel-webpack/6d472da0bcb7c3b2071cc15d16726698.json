{"ast":null,"code":"import { drawing } from '@progress/kendo-drawing';\nimport { Box } from '../../core';\nimport { setDefaultOptions, deepExtend, isArray } from '../../common';\nimport { ARROW, DEFAULT_WIDTH, DEFAULT_HEIGHT } from '../constants';\nimport Gauge from '../gauge';\nimport LinearScale from './linear-scale';\nimport ArrowLinearPointer from './arrow-linear-pointer';\nimport BarLinearPointer from './bar-linear-pointer';\nconst DEFAULT_MIN_WIDTH = 60;\nconst DEFAULT_MIN_HEIGHT = 60;\nconst Group = drawing.Group;\n\nclass LinearGauge extends Gauge {\n  reflow(bbox) {\n    const pointers = this.pointers;\n    const bboxX = bbox.origin.x;\n    const bboxY = bbox.origin.y;\n    const box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n    this.scale.reflow(box);\n\n    this._shrinkScaleWidth(box);\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow();\n    }\n\n    this.bbox = this._getBox(box);\n\n    this._alignElements();\n\n    this._shrinkElements();\n\n    this._buildVisual();\n\n    this._draw();\n  }\n\n  _buildVisual() {\n    const visuals = new Group();\n    const scaleElements = this.scale.render();\n    const pointers = this.pointers;\n    visuals.append(this.gaugeArea);\n    visuals.append(scaleElements);\n\n    for (let i = 0; i < pointers.length; i++) {\n      const current = pointers[i];\n      visuals.append(current.render());\n      current.value(current.options.value);\n    }\n\n    this._visuals = visuals;\n  }\n\n  _createModel() {\n    const options = this.options;\n    const scale = this.scale = new LinearScale(options.scale, this.contextService);\n    this.pointers = [];\n    let pointers = options.pointer;\n    pointers = isArray(pointers) ? pointers : [pointers];\n\n    for (let i = 0; i < pointers.length; i++) {\n      const currentOptions = deepExtend({}, pointers[i], {\n        animation: {\n          transitions: options.transitions\n        }\n      });\n      const pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n      this.pointers.push(new pointerType(scale, currentOptions));\n    }\n  }\n\n  _defaultSize() {\n    const vertical = this.options.scale.vertical;\n    return {\n      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n      height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n    };\n  }\n\n  _getBox(box) {\n    const {\n      scale,\n      pointers\n    } = this;\n    const boxCenter = box.center();\n    let plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n    for (let i = 0; i < pointers.length; i++) {\n      plotAreaBox.wrap(pointers[i].box.clone());\n    }\n\n    let size;\n\n    if (scale.options.vertical) {\n      size = plotAreaBox.width() / 2;\n      plotAreaBox = new Box(boxCenter.x - size, box.y1, boxCenter.x + size, box.y2);\n    } else {\n      size = plotAreaBox.height() / 2;\n      plotAreaBox = new Box(box.x1, boxCenter.y - size, box.x2, boxCenter.y + size);\n    }\n\n    return plotAreaBox;\n  }\n\n  _alignElements() {\n    const {\n      scale,\n      pointers\n    } = this;\n    const scaleBox = scale.box;\n    const box = pointers[0].box.clone().wrap(scale.box);\n    const plotAreaBox = this.bbox;\n\n    for (let i = 0; i < pointers.length; i++) {\n      box.wrap(pointers[i].box.clone());\n    }\n\n    let diff;\n\n    if (scale.options.vertical) {\n      diff = plotAreaBox.center().x - box.center().x;\n      scale.reflow(new Box(scaleBox.x1 + diff, plotAreaBox.y1, scaleBox.x2 + diff, plotAreaBox.y2));\n    } else {\n      diff = plotAreaBox.center().y - box.center().y;\n      scale.reflow(new Box(scaleBox.x1, scaleBox.y1 + diff, scaleBox.x2, scaleBox.y2 + diff));\n    }\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(this.bbox);\n    }\n  }\n\n  _shrinkScaleWidth(bbox) {\n    const {\n      scale\n    } = this;\n\n    if (!scale.options.vertical) {\n      const overflow = scale.contentBox().width() - bbox.width();\n\n      if (overflow > 0) {\n        scale.box.shrink(overflow, 0);\n        scale.box.alignTo(bbox, 'center');\n        scale.reflow(scale.box);\n      }\n    }\n  }\n\n  _shrinkElements() {\n    const {\n      scale,\n      pointers\n    } = this;\n    const scaleBox = scale.box.clone();\n    const pos = scale.options.vertical ? \"y\" : \"x\";\n    const pointerBox = pointers[0].box;\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointerBox.wrap(pointers[i].box.clone());\n    }\n\n    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n    scale.reflow(scaleBox);\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(this.bbox);\n    }\n  }\n\n}\n\nsetDefaultOptions(LinearGauge, {\n  transitions: true,\n  gaugeArea: {\n    background: \"\"\n  },\n  scale: {\n    vertical: true\n  }\n});\nexport default LinearGauge;","map":null,"metadata":{},"sourceType":"module"}