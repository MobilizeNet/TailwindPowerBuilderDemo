{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport GridLinesMixin from './mixins/grid-lines-mixin';\nimport RadarCategoryAxis from './radar-category-axis';\nimport NumericAxis from './numeric-axis';\nimport Axis from './axis';\nimport Ring from './ring';\nimport Box from './box';\nimport { BLACK } from '../common/constants';\nimport { deepExtend, deg, getSpacing, inArray, limitValue, setDefaultOptions } from '../common';\n\nclass PolarAxis extends Axis {\n  constructor(options, chartService) {\n    super(options, chartService);\n    const instanceOptions = this.options;\n    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n  }\n\n  getDivisions(stepValue) {\n    return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n  }\n\n  reflow(box) {\n    this.box = box;\n    this.reflowLabels();\n  }\n\n  reflowLabels() {\n    const {\n      options,\n      labels,\n      options: {\n        labels: labelOptions\n      }\n    } = this;\n    const skip = labelOptions.skip || 0;\n    const step = labelOptions.step || 1;\n    const measureBox = new Box();\n    const divs = this.intervals(options.majorUnit, skip, step);\n\n    for (let i = 0; i < labels.length; i++) {\n      labels[i].reflow(measureBox);\n      const labelBox = labels[i].box;\n      labels[i].reflow(this.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n    }\n  }\n\n  lineBox() {\n    return this.box;\n  }\n\n  intervals(size, skipOption, stepOption, skipAngles = false) {\n    const min = this.options.min;\n    const divisions = this.getDivisions(size);\n    const divs = [];\n    const skip = skipOption || 0;\n    const step = stepOption || 1;\n\n    for (let i = skip; i < divisions; i += step) {\n      const current = (360 + min + i * size) % 360;\n\n      if (!(skipAngles && inArray(current, skipAngles))) {\n        divs.push(current);\n      }\n    }\n\n    return divs;\n  }\n\n  majorIntervals() {\n    return this.intervals(this.options.majorUnit);\n  }\n\n  minorIntervals() {\n    return this.intervals(this.options.minorUnit);\n  }\n\n  intervalAngle(i) {\n    return (540 - i - this.options.startAngle) % 360;\n  }\n\n  createLine() {\n    return [];\n  }\n\n  majorGridLineAngles(altAxis) {\n    const majorGridLines = this.options.majorGridLines;\n    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n  }\n\n  minorGridLineAngles(altAxis, skipMajor) {\n    const options = this.options;\n    const {\n      minorGridLines,\n      majorGridLines\n    } = options;\n    const majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n    return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n  }\n\n  plotBandSlot(band) {\n    return this.getSlot(band.from, band.to);\n  }\n\n  getSlot(a, b) {\n    const {\n      options,\n      box\n    } = this;\n    const startAngle = options.startAngle;\n    let start = limitValue(a, options.min, options.max);\n    let end = limitValue(b || start, start, options.max);\n\n    if (options.reverse) {\n      start *= -1;\n      end *= -1;\n    }\n\n    start = (540 - start - startAngle) % 360;\n    end = (540 - end - startAngle) % 360;\n\n    if (end < start) {\n      const tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n  }\n\n  slot(from, to = from) {\n    const options = this.options;\n    const start = 360 - options.startAngle;\n    const slot = this.getSlot(from, to);\n    const min = Math.min(from, to);\n    const max = Math.max(from, to);\n    let startAngle, endAngle;\n\n    if (options.reverse) {\n      startAngle = min;\n      endAngle = max;\n    } else {\n      startAngle = 360 - max;\n      endAngle = 360 - min;\n    }\n\n    startAngle = (startAngle + start) % 360;\n    endAngle = (endAngle + start) % 360;\n    return new geom.Arc([slot.center.x, slot.center.y], {\n      startAngle: startAngle,\n      endAngle: endAngle,\n      radiusX: slot.radius,\n      radiusY: slot.radius\n    });\n  }\n\n  getValue(point) {\n    const options = this.options;\n    const center = this.box.center();\n    const dx = point.x - center.x;\n    const dy = point.y - center.y;\n    let theta = Math.round(deg(Math.atan2(dy, dx)));\n    let start = options.startAngle;\n\n    if (!options.reverse) {\n      theta *= -1;\n      start *= -1;\n    }\n\n    return (theta + start + 360) % 360;\n  }\n\n  valueRange() {\n    return {\n      min: 0,\n      max: Math.PI * 2\n    };\n  }\n\n}\n\nsetDefaultOptions(PolarAxis, {\n  type: \"polar\",\n  startAngle: 0,\n  reverse: false,\n  majorUnit: 60,\n  min: 0,\n  max: 360,\n  labels: {\n    margin: getSpacing(10)\n  },\n  majorGridLines: {\n    color: BLACK,\n    visible: true,\n    width: 1\n  },\n  minorGridLines: {\n    color: \"#aaa\"\n  }\n});\ndeepExtend(PolarAxis.prototype, GridLinesMixin, {\n  createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n  majorAngles: RadarCategoryAxis.prototype.majorAngles,\n  range: NumericAxis.prototype.range,\n  labelsCount: NumericAxis.prototype.labelsCount,\n  createAxisLabel: NumericAxis.prototype.createAxisLabel\n});\nexport default PolarAxis;","map":null,"metadata":{},"sourceType":"module"}