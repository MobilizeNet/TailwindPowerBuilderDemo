{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { Class, elementSize, setDefaultOptions, deepExtend, isArray, isNumber } from '../common';\nimport { DEFAULT_WIDTH, DEFAULT_HEIGHT } from './constants';\nimport { ChartService } from '../services';\nimport { unpad } from './utils';\nconst DEFAULT_MARGIN = 5;\nconst {\n  Path,\n  Surface\n} = drawing;\n\nclass Gauge extends Class {\n  constructor(element, userOptions, theme, context = {}) {\n    super();\n    this.element = element;\n    this.theme = theme;\n    this.contextService = new ChartService(this, context);\n    this._originalOptions = deepExtend({}, this.options, userOptions);\n    this.options = deepExtend({}, this._originalOptions);\n\n    this._initTheme(theme);\n\n    this.redraw();\n  }\n\n  destroy() {\n    if (this.surface) {\n      this.surface.destroy();\n      this.surface = null;\n    }\n\n    delete this.element;\n    delete this.surfaceElement;\n  }\n\n  value(pointerValue) {\n    const pointer = this.pointers[0];\n\n    if (arguments.length === 0) {\n      return pointer.value();\n    }\n\n    pointer.value(pointerValue);\n\n    this._setValueOptions(pointerValue);\n  }\n\n  _draw() {\n    const surface = this.surface;\n    surface.clear();\n    surface.draw(this._visuals);\n  }\n\n  exportVisual() {\n    return this._visuals;\n  }\n\n  allValues(values) {\n    const pointers = this.pointers;\n    const allValues = [];\n\n    if (arguments.length === 0) {\n      for (let i = 0; i < pointers.length; i++) {\n        allValues.push(pointers[i].value());\n      }\n\n      return allValues;\n    }\n\n    if (isArray(values)) {\n      for (let i = 0; i < values.length; i++) {\n        if (isNumber(values[i])) {\n          pointers[i].value(values[i]);\n        }\n      }\n    }\n\n    this._setValueOptions(values);\n  }\n\n  _setValueOptions(values) {\n    const pointers = [].concat(this.options.pointer);\n    const arrayValues = [].concat(values);\n\n    for (let i = 0; i < arrayValues.length; i++) {\n      pointers[i].value = arrayValues[i];\n    }\n  }\n\n  resize() {\n    this.noTransitionsRedraw();\n  }\n\n  noTransitionsRedraw() {\n    const transitions = this.options.transitions;\n\n    this._toggleTransitions(false);\n\n    this.redraw();\n\n    this._toggleTransitions(transitions);\n  }\n\n  redraw() {\n    const size = this._surfaceSize();\n\n    const wrapper = new geo.Rect([0, 0], [size.width, size.height]);\n\n    this._initSurface();\n\n    this.gaugeArea = this._createGaugeArea();\n\n    this._createModel();\n\n    const bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n    this.reflow(bbox);\n  }\n\n  setOptions(options, theme) {\n    this._originalOptions = deepExtend(this._originalOptions, options);\n    this.options = deepExtend({}, this._originalOptions);\n\n    this._initTheme(theme);\n\n    this.redraw();\n  }\n\n  setDirection(rtl) {\n    this.contextService.rtl = Boolean(rtl);\n\n    if (this.surface && this.surface.type === 'svg') {\n      this.surface.destroy();\n      this.surface = null;\n    }\n  }\n\n  setIntlService(intl) {\n    this.contextService.intl = intl;\n  }\n\n  _initTheme(theme) {\n    let currentTheme = theme || this.theme || {};\n    this.theme = currentTheme;\n    this.options = deepExtend({}, currentTheme, this.options);\n    const options = this.options;\n    const pointer = options.pointer;\n\n    if (isArray(pointer)) {\n      const pointers = [];\n\n      for (let i = 0; i < pointer.length; i++) {\n        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n      }\n\n      options.pointer = pointers;\n    }\n  }\n\n  _createGaugeArea() {\n    const options = this.options.gaugeArea;\n    const size = this.surface.size();\n    const border = options.border || {};\n    let areaGeometry = new geo.Rect([0, 0], [size.width, size.height]);\n    this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n    if (border.width > 0) {\n      areaGeometry = unpad(areaGeometry, border.width);\n    }\n\n    const gaugeArea = Path.fromRect(areaGeometry, {\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType,\n        lineJoin: \"round\",\n        lineCap: \"round\"\n      },\n      fill: {\n        color: options.background\n      }\n    });\n    return gaugeArea;\n  }\n\n  _initSurface() {\n    const {\n      options,\n      surface\n    } = this;\n\n    const element = this._surfaceElement();\n\n    const size = this._surfaceSize();\n\n    elementSize(element, size);\n\n    if (!surface || surface.options.type !== options.renderAs) {\n      if (surface) {\n        surface.destroy();\n      }\n\n      this.surface = Surface.create(element, {\n        type: options.renderAs\n      });\n    } else {\n      this.surface.clear();\n      this.surface.resize();\n    }\n  }\n\n  _surfaceSize() {\n    const options = this.options;\n\n    const size = this._getSize();\n\n    if (options.gaugeArea) {\n      deepExtend(size, options.gaugeArea);\n    }\n\n    return size;\n  }\n\n  _surfaceElement() {\n    if (!this.surfaceElement) {\n      this.surfaceElement = document.createElement('div');\n      this.element.appendChild(this.surfaceElement);\n    }\n\n    return this.surfaceElement;\n  }\n\n  getSize() {\n    return this._getSize();\n  }\n\n  _getSize() {\n    const element = this.element;\n\n    const defaultSize = this._defaultSize();\n\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n\n    if (!width) {\n      width = defaultSize.width;\n    }\n\n    if (!height) {\n      height = defaultSize.height;\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n\n  _defaultSize() {\n    return {\n      width: DEFAULT_WIDTH,\n      height: DEFAULT_HEIGHT\n    };\n  }\n\n  _toggleTransitions(value) {\n    this.options.transitions = value;\n\n    for (let i = 0; i < this.pointers.length; i++) {\n      this.pointers[i].options.animation.transitions = value;\n    }\n  }\n\n}\n\nsetDefaultOptions(Gauge, {\n  plotArea: {},\n  theme: \"default\",\n  renderAs: \"\",\n  pointer: {},\n  scale: {},\n  gaugeArea: {}\n});\nexport default Gauge;","map":null,"metadata":{},"sourceType":"module"}