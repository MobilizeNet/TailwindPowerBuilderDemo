{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(28);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  28:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        var colorpicker = kendo.ui.colorpicker,\n            extend = $.extend,\n            Color = kendo.Color,\n            parseColor = kendo.parseColor,\n            AA_CONTRAST = 4.5,\n            AAA_CONTRAST = 7,\n            STEP_COUNT = 16; // Color utils - calc contrast\n\n        function getContrast(luminance1, luminance2) {\n          var brightest = Math.max(luminance1, luminance2);\n          var darkest = Math.min(luminance1, luminance2);\n          return (brightest + 0.05) / (darkest + 0.05);\n        }\n\n        function getContrastFromTwoRGBAs(a, b) {\n          return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n          })));\n        }\n\n        function getLuminance(rgb) {\n          var a = [rgb.r, rgb.g, rgb.b].map(function (v) {\n            v /= 255;\n            return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n          });\n          return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n        }\n\n        function getRGBFromRGBA(foregroundColor, backgroundColor) {\n          var r1 = fitIntoBounds(foregroundColor.r, 0, 255);\n          var g1 = fitIntoBounds(foregroundColor.g, 0, 255);\n          var b1 = fitIntoBounds(foregroundColor.b, 0, 255);\n          var a1 = fitIntoBounds(foregroundColor.a, 0, 1);\n          var r2 = fitIntoBounds(backgroundColor.r, 0, 255);\n          var g2 = fitIntoBounds(backgroundColor.g, 0, 255);\n          var b2 = fitIntoBounds(backgroundColor.b, 0, 255);\n          return {\n            r: Math.round((1 - a1) * r2 + a1 * r1),\n            g: Math.round((1 - a1) * g2 + a1 * g1),\n            b: Math.round((1 - a1) * b2 + a1 * b1)\n          };\n        }\n\n        function fitIntoBounds(contender, min, max) {\n          if (!isPresent(contender) || isNaN(contender)) {\n            return min;\n          }\n\n          return contender <= min ? min : contender >= max ? max : contender;\n        }\n\n        function isPresent(value) {\n          return value !== null && value !== undefined;\n        } // Color utils - Contrast tool SVG path\n\n\n        function renderSvgCurveLine(gradientRectMetrics, hsva, backgroundColor) {\n          var findValue = function (contrast, saturation, low, high, comparer) {\n            var mid = (low + high) / 2;\n            var currentHsva = extend({}, hsva, {\n              s: saturation / gradientRectMetrics.width,\n              v: 1 - mid / gradientRectMetrics.height\n            });\n            var currentContrast = getContrastFromTwoRGBAs(parseColor(getColorFromHSV(currentHsva)).toBytes(), parseColor(backgroundColor).toBytes());\n\n            if (low + 0.5 > high) {\n              if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {\n                return mid;\n              } else {\n                return null;\n              }\n            }\n\n            if (comparer(currentContrast, contrast)) {\n              return findValue(contrast, saturation, low, high - (high - low) / 2, comparer);\n            }\n\n            return findValue(contrast, saturation, low + (high - low) / 2, high, comparer);\n          };\n\n          var comparer = function (a, b) {\n            return a > b;\n          };\n\n          var reversedComparer = function (a, b) {\n            return a < b;\n          };\n\n          var getPaths = function (contrast, stepCount, reversed) {\n            var points = [];\n\n            for (var i = 0; i <= gradientRectMetrics.width; i += gradientRectMetrics.width / stepCount) {\n              var value = findValue(contrast, i, 0, gradientRectMetrics.height, reversed ? reversedComparer : comparer);\n\n              if (value !== null) {\n                points.push([i, value]);\n              }\n            }\n\n            return points;\n          };\n\n          var bezierCommandCalc = bezierCommand(controlPoint(line));\n          var paths = svgPath(getPaths(AA_CONTRAST, STEP_COUNT, false), bezierCommandCalc) + svgPath(getPaths(AA_CONTRAST, STEP_COUNT, true), bezierCommandCalc) + svgPath(getPaths(AAA_CONTRAST, STEP_COUNT, false), bezierCommandCalc) + svgPath(getPaths(AAA_CONTRAST, STEP_COUNT, true), bezierCommandCalc);\n          return '<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px; z-index: 3;\" >' + paths + '</svg>';\n        }\n\n        function svgPath(points, command) {\n          if (points.length === 0) {\n            return '';\n          }\n\n          var reducer = function (acc, point, i, a) {\n            return i === 0 ? // if first point\n            kendo.format(\"M {0},{1}\", point[0], point[1]) : // else\n            kendo.format(\"{0} {1}\", acc, command(point, i, a));\n          }; // build the d attributes by looping over the points\n\n\n          var d = points.reduce(reducer, \"\");\n          return kendo.format('<path d=\"{0}\" fill=\"none\" stroke=\"white\" stroke-width=\"1\"/>', d);\n        }\n\n        function bezierCommand(controlPointCalc) {\n          return function (point, i, a) {\n            // start control point\n            var cps = controlPointCalc(a[i - 1], a[i - 2], point); // [cpsX, cpsY]\n            // end control point\n\n            var cpe = controlPointCalc(point, a[i - 1], a[i + 1], true); //  [cpeX, cpeY]\n\n            return kendo.format(\"C {0},{1} {2},{3} {4},{5}\", cps[0], cps[1], cpe[0], cpe[1], point[0], point[1]);\n          };\n        }\n\n        function controlPoint(lineCalc) {\n          return function (current, previous, next, reverse) {\n            // when 'current' is the first or last point of the array\n            // 'previous' and 'next' are undefined\n            // replace with 'current'\n            var p = previous || current;\n            var n = next || current;\n            var smooth = 0.1; // properties of the line between previous and next\n\n            var l = lineCalc(p, n); // If is end-control-point, add PI to the angle to go backward\n\n            var angle = l.angle + (reverse ? Math.PI : 0);\n            var length = l.length * smooth; // The control point position is relative to the current point\n\n            var x = current[0] + Math.cos(angle) * length;\n            var y = current[1] + Math.sin(angle) * length;\n            return [x, y];\n          };\n        }\n\n        function line(pointA, pointB) {\n          var lengthX = pointB[0] - pointA[0];\n          var lengthY = pointB[1] - pointA[1];\n          return {\n            length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n            angle: Math.atan2(lengthY, lengthX)\n          };\n        }\n\n        function getColorFromHSV(hsva) {\n          var hue = fitIntoBounds(hsva.h, 0, 359.9);\n          var saturation = fitIntoBounds(hsva.s, 0, 1);\n          var value = fitIntoBounds(hsva.v, 0, 1);\n          var alpha = fitIntoBounds(hsva.a, 0, 1);\n          return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n        }\n\n        extend(colorpicker, {\n          contrastToolUtils: {\n            getContrastFromTwoRGBAs: getContrastFromTwoRGBAs,\n            renderSvgCurveLine: renderSvgCurveLine\n          }\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}