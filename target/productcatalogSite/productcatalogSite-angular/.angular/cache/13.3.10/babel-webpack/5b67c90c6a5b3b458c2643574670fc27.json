{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1202);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1112:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.userevents\");\n    /***/\n  },\n\n  /***/\n  1202:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051), __webpack_require__(1112)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"draganddrop\",\n        name: \"Drag & drop\",\n        category: \"framework\",\n        description: \"Drag & drop functionality for any DOM element.\",\n        depends: [\"core\", \"userevents\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            support = kendo.support,\n            document = window.document,\n            $window = $(window),\n            Class = kendo.Class,\n            Widget = kendo.ui.Widget,\n            Observable = kendo.Observable,\n            UserEvents = kendo.UserEvents,\n            extend = $.extend,\n            getOffset = kendo.getOffset,\n            draggables = {},\n            dropTargets = {},\n            dropAreas = {},\n            lastDropTarget,\n            elementUnderCursor = kendo.elementUnderCursor,\n            KEYUP = \"keyup\",\n            CHANGE = \"change\",\n            // Draggable events\n        DRAGSTART = \"dragstart\",\n            HOLD = \"hold\",\n            DRAG = \"drag\",\n            DRAGEND = \"dragend\",\n            DRAGCANCEL = \"dragcancel\",\n            HINTDESTROYED = \"hintDestroyed\",\n            // DropTarget events\n        DRAGENTER = \"dragenter\",\n            DRAGLEAVE = \"dragleave\",\n            DROP = \"drop\";\n\n        function contains(parent, child) {\n          try {\n            return $.contains(parent, child) || parent == child;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function numericCssPropery(element, property) {\n          return parseInt(element.css(property), 10) || 0;\n        }\n\n        function within(value, range) {\n          return Math.min(Math.max(value, range.min), range.max);\n        }\n\n        function containerBoundaries(container, element) {\n          var offset = getOffset(container),\n              outerWidth = kendo._outerWidth,\n              outerHeight = kendo._outerHeight,\n              minX = offset.left + numericCssPropery(container, \"borderLeftWidth\") + numericCssPropery(container, \"paddingLeft\"),\n              minY = offset.top + numericCssPropery(container, \"borderTopWidth\") + numericCssPropery(container, \"paddingTop\"),\n              maxX = minX + container.width() - outerWidth(element, true),\n              maxY = minY + container.height() - outerHeight(element, true);\n          return {\n            x: {\n              min: minX,\n              max: maxX\n            },\n            y: {\n              min: minY,\n              max: maxY\n            }\n          };\n        }\n\n        function checkTarget(target, targets, areas) {\n          var theTarget,\n              theFilter,\n              i = 0,\n              targetLen = targets && targets.length,\n              areaLen = areas && areas.length;\n\n          while (target && target.parentNode) {\n            for (i = 0; i < targetLen; i++) {\n              theTarget = targets[i];\n\n              if (theTarget.element[0] === target) {\n                return {\n                  target: theTarget,\n                  targetElement: target\n                };\n              }\n            }\n\n            for (i = 0; i < areaLen; i++) {\n              theFilter = areas[i];\n\n              if ($.contains(theFilter.element[0], target) && support.matchesSelector.call(target, theFilter.options.filter)) {\n                return {\n                  target: theFilter,\n                  targetElement: target\n                };\n              }\n            }\n\n            target = target.parentNode;\n          }\n\n          return undefined;\n        }\n\n        var TapCapture = Observable.extend({\n          init: function (element, options) {\n            var that = this,\n                domElement = element[0];\n            that.capture = false;\n\n            if (domElement.addEventListener) {\n              $.each(kendo.eventMap.down.split(\" \"), function () {\n                domElement.addEventListener(this, that._press.bind(that), true);\n              });\n              $.each(kendo.eventMap.up.split(\" \"), function () {\n                domElement.addEventListener(this, that._release.bind(that), true);\n              });\n            } else {\n              $.each(kendo.eventMap.down.split(\" \"), function () {\n                domElement.attachEvent(this, that._press.bind(that));\n              });\n              $.each(kendo.eventMap.up.split(\" \"), function () {\n                domElement.attachEvent(this, that._release.bind(that));\n              });\n            }\n\n            Observable.fn.init.call(that);\n            that.bind([\"press\", \"release\"], options || {});\n          },\n          captureNext: function () {\n            this.capture = true;\n          },\n          cancelCapture: function () {\n            this.capture = false;\n          },\n          _press: function (e) {\n            var that = this;\n            that.trigger(\"press\");\n\n            if (that.capture) {\n              e.preventDefault();\n            }\n          },\n          _release: function (e) {\n            var that = this;\n            that.trigger(\"release\");\n\n            if (that.capture) {\n              e.preventDefault();\n              that.cancelCapture();\n            }\n          }\n        });\n        var PaneDimension = Observable.extend({\n          init: function (options) {\n            var that = this;\n            Observable.fn.init.call(that);\n            that.forcedEnabled = false;\n            $.extend(that, options);\n            that.scale = 1;\n\n            if (that.horizontal) {\n              that.measure = \"offsetWidth\";\n              that.scrollSize = \"scrollWidth\";\n              that.axis = \"x\";\n            } else {\n              that.measure = \"offsetHeight\";\n              that.scrollSize = \"scrollHeight\";\n              that.axis = \"y\";\n            }\n          },\n          makeVirtual: function () {\n            $.extend(this, {\n              virtual: true,\n              forcedEnabled: true,\n              _virtualMin: 0,\n              _virtualMax: 0\n            });\n          },\n          virtualSize: function (min, max) {\n            if (this._virtualMin !== min || this._virtualMax !== max) {\n              this._virtualMin = min;\n              this._virtualMax = max;\n              this.update();\n            }\n          },\n          outOfBounds: function (offset) {\n            return offset > this.max || offset < this.min;\n          },\n          forceEnabled: function () {\n            this.forcedEnabled = true;\n          },\n          getSize: function () {\n            return this.container[0][this.measure];\n          },\n          getTotal: function () {\n            return this.element[0][this.scrollSize];\n          },\n          rescale: function (scale) {\n            this.scale = scale;\n          },\n          update: function (silent) {\n            var that = this,\n                total = that.virtual ? that._virtualMax : that.getTotal(),\n                scaledTotal = total * that.scale,\n                size = that.getSize();\n\n            if (total === 0 && !that.forcedEnabled) {\n              return; // we are not visible.\n            }\n\n            that.max = that.virtual ? -that._virtualMin : 0;\n            that.size = size;\n            that.total = scaledTotal;\n            that.min = Math.min(that.max, size - scaledTotal);\n            that.minScale = size / total;\n            that.centerOffset = (scaledTotal - size) / 2;\n            that.enabled = that.forcedEnabled || scaledTotal > size;\n\n            if (!silent) {\n              that.trigger(CHANGE, that);\n            }\n          }\n        });\n        var PaneDimensions = Observable.extend({\n          init: function (options) {\n            var that = this;\n            Observable.fn.init.call(that);\n            that.x = new PaneDimension(extend({\n              horizontal: true\n            }, options));\n            that.y = new PaneDimension(extend({\n              horizontal: false\n            }, options));\n            that.container = options.container;\n            that.forcedMinScale = options.minScale;\n            that.maxScale = options.maxScale || 100;\n            that.bind(CHANGE, options);\n          },\n          rescale: function (newScale) {\n            this.x.rescale(newScale);\n            this.y.rescale(newScale);\n            this.refresh();\n          },\n          centerCoordinates: function () {\n            return {\n              x: Math.min(0, -this.x.centerOffset),\n              y: Math.min(0, -this.y.centerOffset)\n            };\n          },\n          refresh: function () {\n            var that = this;\n            that.x.update();\n            that.y.update();\n            that.enabled = that.x.enabled || that.y.enabled;\n            that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);\n            that.fitScale = Math.max(that.x.minScale, that.y.minScale);\n            that.trigger(CHANGE);\n          }\n        });\n        var PaneAxis = Observable.extend({\n          init: function (options) {\n            var that = this;\n            extend(that, options);\n            Observable.fn.init.call(that);\n          },\n          outOfBounds: function () {\n            return this.dimension.outOfBounds(this.movable[this.axis]);\n          },\n          dragMove: function (delta) {\n            var that = this,\n                dimension = that.dimension,\n                axis = that.axis,\n                movable = that.movable,\n                position = movable[axis] + delta;\n\n            if (!dimension.enabled) {\n              return;\n            }\n\n            if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n              delta *= that.resistance;\n            }\n\n            movable.translateAxis(axis, delta);\n            that.trigger(CHANGE, that);\n          }\n        });\n        var Pane = Class.extend({\n          init: function (options) {\n            var that = this,\n                x,\n                y,\n                resistance,\n                movable;\n            extend(that, {\n              elastic: true\n            }, options);\n            resistance = that.elastic ? 0.5 : 0;\n            movable = that.movable;\n            that.x = x = new PaneAxis({\n              axis: \"x\",\n              dimension: that.dimensions.x,\n              resistance: resistance,\n              movable: movable\n            });\n            that.y = y = new PaneAxis({\n              axis: \"y\",\n              dimension: that.dimensions.y,\n              resistance: resistance,\n              movable: movable\n            });\n            that.userEvents.bind([\"press\", \"move\", \"end\", \"gesturestart\", \"gesturechange\"], {\n              gesturestart: function (e) {\n                that.gesture = e;\n                that.offset = that.dimensions.container.offset();\n              },\n              press: function (e) {\n                if ($(e.event.target).closest(\"a\").is(\"[data-navigate-on-press=true]\")) {\n                  e.sender.cancel();\n                }\n              },\n              gesturechange: function (e) {\n                var previousGesture = that.gesture,\n                    previousCenter = previousGesture.center,\n                    center = e.center,\n                    scaleDelta = e.distance / previousGesture.distance,\n                    minScale = that.dimensions.minScale,\n                    maxScale = that.dimensions.maxScale,\n                    coordinates;\n\n                if (movable.scale <= minScale && scaleDelta < 1) {\n                  // Resist shrinking. Instead of shrinking from 1 to 0.5, it will shrink to 0.5 + (1 /* minScale */ - 0.5) * 0.8 = 0.9;\n                  scaleDelta += (1 - scaleDelta) * 0.8;\n                }\n\n                if (movable.scale * scaleDelta >= maxScale) {\n                  scaleDelta = maxScale / movable.scale;\n                }\n\n                var offsetX = movable.x + that.offset.left,\n                    offsetY = movable.y + that.offset.top;\n                coordinates = {\n                  x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n                  y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n                };\n                movable.scaleWith(scaleDelta);\n                x.dragMove(coordinates.x);\n                y.dragMove(coordinates.y);\n                that.dimensions.rescale(movable.scale);\n                that.gesture = e;\n                e.preventDefault();\n              },\n              move: function (e) {\n                if (e.event.target.tagName.match(/textarea|input/i)) {\n                  return;\n                }\n\n                if (x.dimension.enabled || y.dimension.enabled) {\n                  x.dragMove(e.x.delta);\n                  y.dragMove(e.y.delta);\n                  e.preventDefault();\n                } else {\n                  e.touch.skip();\n                }\n              },\n              end: function (e) {\n                e.preventDefault();\n              }\n            });\n          }\n        });\n        var TRANSFORM_STYLE = support.transitions.prefix + \"Transform\",\n            translate;\n\n        if (support.hasHW3D) {\n          translate = function (x, y, scale) {\n            return \"translate3d(\" + x + \"px,\" + y + \"px,0) scale(\" + scale + \")\";\n          };\n        } else {\n          translate = function (x, y, scale) {\n            return \"translate(\" + x + \"px,\" + y + \"px) scale(\" + scale + \")\";\n          };\n        }\n\n        var Movable = Observable.extend({\n          init: function (element) {\n            var that = this;\n            Observable.fn.init.call(that);\n            that.element = $(element);\n            that.element[0].style.webkitTransformOrigin = \"left top\";\n            that.x = 0;\n            that.y = 0;\n            that.scale = 1;\n\n            that._saveCoordinates(translate(that.x, that.y, that.scale));\n          },\n          translateAxis: function (axis, by) {\n            this[axis] += by;\n            this.refresh();\n          },\n          scaleTo: function (scale) {\n            this.scale = scale;\n            this.refresh();\n          },\n          scaleWith: function (scaleDelta) {\n            this.scale *= scaleDelta;\n            this.refresh();\n          },\n          translate: function (coordinates) {\n            this.x += coordinates.x;\n            this.y += coordinates.y;\n            this.refresh();\n          },\n          moveAxis: function (axis, value) {\n            this[axis] = value;\n            this.refresh();\n          },\n          moveTo: function (coordinates) {\n            extend(this, coordinates);\n            this.refresh();\n          },\n          refresh: function () {\n            var that = this,\n                x = that.x,\n                y = that.y,\n                newCoordinates;\n\n            if (that.round) {\n              x = Math.round(x);\n              y = Math.round(y);\n            }\n\n            newCoordinates = translate(x, y, that.scale);\n\n            if (newCoordinates != that.coordinates) {\n              if (kendo.support.browser.msie && kendo.support.browser.version < 10) {\n                that.element[0].style.position = \"absolute\";\n                that.element[0].style.left = that.x + \"px\";\n                that.element[0].style.top = that.y + \"px\";\n              } else {\n                that.element[0].style[TRANSFORM_STYLE] = newCoordinates;\n              }\n\n              that._saveCoordinates(newCoordinates);\n\n              that.trigger(CHANGE);\n            }\n          },\n          _saveCoordinates: function (coordinates) {\n            this.coordinates = coordinates;\n          }\n        });\n\n        function destroyDroppable(collection, widget) {\n          var groupName = widget.options.group,\n              droppables = collection[groupName],\n              i;\n          Widget.fn.destroy.call(widget);\n\n          if (droppables.length > 1) {\n            for (i = 0; i < droppables.length; i++) {\n              if (droppables[i] == widget) {\n                droppables.splice(i, 1);\n                break;\n              }\n            }\n          } else {\n            droppables.length = 0; // WTF, porting this from the previous destroyGroup\n\n            delete collection[groupName];\n          }\n        }\n\n        var DropTarget = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            var group = that.options.group;\n\n            if (!(group in dropTargets)) {\n              dropTargets[group] = [that];\n            } else {\n              dropTargets[group].push(that);\n            }\n          },\n          events: [DRAGENTER, DRAGLEAVE, DROP],\n          options: {\n            name: \"DropTarget\",\n            group: \"default\"\n          },\n          destroy: function () {\n            destroyDroppable(dropTargets, this);\n          },\n          _trigger: function (eventName, e) {\n            var that = this,\n                draggable = draggables[that.options.group];\n\n            if (draggable) {\n              return that.trigger(eventName, extend({}, e.event, {\n                draggable: draggable,\n                dropTarget: e.dropTarget\n              }));\n            }\n          },\n          _over: function (e) {\n            this._trigger(DRAGENTER, e);\n          },\n          _out: function (e) {\n            this._trigger(DRAGLEAVE, e);\n          },\n          _drop: function (e) {\n            var that = this,\n                draggable = draggables[that.options.group];\n\n            if (draggable) {\n              draggable.dropped = !that._trigger(DROP, e);\n            }\n          }\n        });\n\n        DropTarget.destroyGroup = function (groupName) {\n          var group = dropTargets[groupName] || dropAreas[groupName],\n              i;\n\n          if (group) {\n            for (i = 0; i < group.length; i++) {\n              Widget.fn.destroy.call(group[i]);\n            }\n\n            group.length = 0;\n            delete dropTargets[groupName];\n            delete dropAreas[groupName];\n          }\n        };\n\n        DropTarget._cache = dropTargets;\n        var DropTargetArea = DropTarget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            var group = that.options.group;\n\n            if (!(group in dropAreas)) {\n              dropAreas[group] = [that];\n            } else {\n              dropAreas[group].push(that);\n            }\n          },\n          destroy: function () {\n            destroyDroppable(dropAreas, this);\n          },\n          options: {\n            name: \"DropTargetArea\",\n            group: \"default\",\n            filter: null\n          }\n        });\n        var Draggable = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            that._activated = false;\n            that.userEvents = new UserEvents(that.element, {\n              global: true,\n              allowSelection: true,\n              filter: that.options.filter,\n              threshold: that.options.distance,\n              start: that._start.bind(that),\n              hold: that._hold.bind(that),\n              move: that._drag.bind(that),\n              end: that._end.bind(that),\n              cancel: that._cancel.bind(that),\n              select: that._select.bind(that)\n            });\n\n            if (kendo.support.touch) {\n              that.element.find(that.options.filter).css('touch-action', 'none');\n            }\n\n            that._afterEndHandler = that._afterEnd.bind(that);\n            that._captureEscape = that._captureEscape.bind(that);\n          },\n          events: [HOLD, DRAGSTART, DRAG, DRAGEND, DRAGCANCEL, HINTDESTROYED],\n          options: {\n            name: \"Draggable\",\n            distance: kendo.support.touch ? 0 : 5,\n            group: \"default\",\n            cursorOffset: null,\n            axis: null,\n            container: null,\n            filter: null,\n            ignore: null,\n            holdToDrag: false,\n            autoScroll: false,\n            dropped: false\n          },\n          cancelHold: function () {\n            this._activated = false;\n          },\n          _captureEscape: function (e) {\n            var that = this;\n\n            if (e.keyCode === kendo.keys.ESC) {\n              that._trigger(DRAGCANCEL, {\n                event: e\n              });\n\n              that.userEvents.cancel();\n            }\n          },\n          _updateHint: function (e) {\n            var that = this,\n                coordinates,\n                options = that.options,\n                boundaries = that.boundaries,\n                axis = options.axis,\n                cursorOffset = that.options.cursorOffset;\n\n            if (cursorOffset) {\n              coordinates = {\n                left: e.x.location + cursorOffset.left,\n                top: e.y.location + cursorOffset.top\n              };\n            } else {\n              that.hintOffset.left += e.x.delta;\n              that.hintOffset.top += e.y.delta;\n              coordinates = $.extend({}, that.hintOffset);\n            }\n\n            if (boundaries) {\n              coordinates.top = within(coordinates.top, boundaries.y);\n              coordinates.left = within(coordinates.left, boundaries.x);\n            }\n\n            if (axis === \"x\") {\n              delete coordinates.top;\n            } else if (axis === \"y\") {\n              delete coordinates.left;\n            }\n\n            that.hint.css(coordinates);\n          },\n          _shouldIgnoreTarget: function (target) {\n            var ignoreSelector = this.options.ignore;\n            return ignoreSelector && $(target).is(ignoreSelector);\n          },\n          _select: function (e) {\n            if (!this._shouldIgnoreTarget(e.event.target)) {\n              e.preventDefault();\n            }\n          },\n          _start: function (e) {\n            var that = this,\n                options = that.options,\n                container = options.container ? $(options.container) : null,\n                hint = options.hint;\n\n            if (this._shouldIgnoreTarget(e.touch.initialTouch) || options.holdToDrag && !that._activated) {\n              that.userEvents.cancel();\n              return;\n            }\n\n            that.currentTarget = e.target;\n            that.currentTargetOffset = getOffset(that.currentTarget);\n\n            if (hint) {\n              if (that.hint) {\n                that.hint.stop(true, true).remove();\n              }\n\n              that.hint = kendo.isFunction(hint) ? $(hint.call(that, that.currentTarget)) : hint;\n              var offset = getOffset(that.currentTarget);\n              that.hintOffset = offset;\n              that.hint.css({\n                position: \"absolute\",\n                zIndex: 20000,\n                // the Window's z-index is 10000 and can be raised because of z-stacking\n                left: offset.left,\n                top: offset.top\n              }).appendTo(document.body);\n              that.angular(\"compile\", function () {\n                that.hint.removeAttr(\"ng-repeat\");\n                var scopeTarget = $(e.target);\n\n                while (!scopeTarget.data(\"$$kendoScope\") && scopeTarget.length) {\n                  scopeTarget = scopeTarget.parent();\n                }\n\n                return {\n                  elements: that.hint.get(),\n                  scopeFrom: scopeTarget.data(\"$$kendoScope\")\n                };\n              });\n            }\n\n            draggables[options.group] = that;\n            that.dropped = false;\n\n            if (container) {\n              that.boundaries = containerBoundaries(container, that.hint);\n            }\n\n            $(document).on(KEYUP, that._captureEscape);\n\n            if (that._trigger(DRAGSTART, e)) {\n              that.userEvents.cancel();\n\n              that._afterEnd();\n            }\n\n            that.userEvents.capture();\n          },\n          _hold: function (e) {\n            this.currentTarget = e.target;\n\n            if (this._trigger(HOLD, e)) {\n              this.userEvents.cancel();\n            } else {\n              this._activated = true;\n            }\n          },\n          _drag: function (e) {\n            e.preventDefault();\n\n            var cursorElement = this._elementUnderCursor(e);\n\n            if (this.options.autoScroll && this._cursorElement !== cursorElement) {\n              this._scrollableParent = findScrollableParent(cursorElement);\n              this._cursorElement = cursorElement;\n            }\n\n            this._lastEvent = e;\n\n            this._processMovement(e, cursorElement);\n\n            if (this.options.autoScroll) {\n              // chrome seems to trigger mousemove when mouse is moved outside of the window (over the Chrome), too.\n              if (this._scrollableParent[0]) {\n                var velocity = autoScrollVelocity(e.x.location, e.y.location, scrollableViewPort(this._scrollableParent));\n                this._scrollCompenstation = $.extend({}, this.hintOffset);\n                this._scrollVelocity = velocity;\n\n                if (velocity.y === 0 && velocity.x === 0) {\n                  clearInterval(this._scrollInterval);\n                  this._scrollInterval = null;\n                } else if (!this._scrollInterval) {\n                  this._scrollInterval = setInterval(this._autoScroll.bind(this), 50);\n                }\n              }\n            }\n\n            if (this.hint) {\n              this._updateHint(e);\n            }\n          },\n          _processMovement: function (e, cursorElement) {\n            this._withDropTarget(cursorElement, function (target, targetElement) {\n              if (!target) {\n                if (lastDropTarget) {\n                  lastDropTarget._trigger(DRAGLEAVE, extend(e, {\n                    dropTarget: $(lastDropTarget.targetElement)\n                  }));\n\n                  lastDropTarget = null;\n                }\n\n                return;\n              }\n\n              if (lastDropTarget) {\n                if (targetElement === lastDropTarget.targetElement) {\n                  return;\n                }\n\n                lastDropTarget._trigger(DRAGLEAVE, extend(e, {\n                  dropTarget: $(lastDropTarget.targetElement)\n                }));\n              }\n\n              target._trigger(DRAGENTER, extend(e, {\n                dropTarget: $(targetElement)\n              }));\n\n              lastDropTarget = extend(target, {\n                targetElement: targetElement\n              });\n            });\n\n            this._trigger(DRAG, extend(e, {\n              dropTarget: lastDropTarget,\n              elementUnderCursor: cursorElement\n            }));\n          },\n          _autoScroll: function () {\n            var parent = this._scrollableParent[0],\n                velocity = this._scrollVelocity,\n                compensation = this._scrollCompenstation;\n\n            if (!parent) {\n              return;\n            }\n\n            var cursorElement = this._elementUnderCursor(this._lastEvent);\n\n            this._processMovement(this._lastEvent, cursorElement);\n\n            var yIsScrollable, xIsScrollable;\n            var isRootNode = parent === scrollableRoot()[0];\n\n            if (isRootNode) {\n              yIsScrollable = document.body.scrollHeight > $window.height();\n              xIsScrollable = document.body.scrollWidth > $window.width();\n            } else {\n              yIsScrollable = parent.offsetHeight <= parent.scrollHeight;\n              xIsScrollable = parent.offsetWidth <= parent.scrollWidth;\n            }\n\n            var yDelta = parent.scrollTop + velocity.y;\n            var yInBounds = yIsScrollable && yDelta > 0 && yDelta < parent.scrollHeight;\n            var xDelta = parent.scrollLeft + velocity.x;\n            var xInBounds = xIsScrollable && xDelta > 0 && xDelta < parent.scrollWidth;\n\n            if (yInBounds) {\n              parent.scrollTop += velocity.y;\n            } else if (yIsScrollable && yDelta < 0) {\n              parent.scrollTop = 0;\n            }\n\n            if (xInBounds) {\n              parent.scrollLeft += velocity.x;\n            } else if (xIsScrollable && xDelta < 0) {\n              parent.scrollLeft = 0;\n            }\n\n            if (this.hint && isRootNode && (xInBounds || yInBounds)) {\n              if (yInBounds) {\n                compensation.top += velocity.y;\n              }\n\n              if (xInBounds) {\n                compensation.left += velocity.x;\n              }\n\n              this.hint.css(compensation);\n            }\n          },\n          _end: function (e) {\n            this._withDropTarget(this._elementUnderCursor(e), function (target, targetElement) {\n              if (target) {\n                target._drop(extend({}, e, {\n                  dropTarget: $(targetElement)\n                }));\n\n                lastDropTarget = null;\n              }\n            });\n\n            clearInterval(this._scrollInterval);\n            this._scrollInterval = null;\n\n            this._cancel(this._trigger(DRAGEND, e));\n          },\n          _cancel: function (isDefaultPrevented) {\n            var that = this;\n            that._scrollableParent = null;\n            this._cursorElement = null;\n            clearInterval(this._scrollInterval);\n            that._activated = false;\n\n            if (that.hint && !that.dropped) {\n              setTimeout(function () {\n                that.hint.stop(true, true);\n\n                if (isDefaultPrevented) {\n                  that._afterEndHandler();\n                } else {\n                  that.hint.animate(that.currentTargetOffset, \"fast\", that._afterEndHandler);\n                }\n              }, 0);\n            } else {\n              that._afterEnd();\n            }\n          },\n          _trigger: function (eventName, e) {\n            var that = this;\n            return that.trigger(eventName, extend({}, e.event, {\n              x: e.x,\n              y: e.y,\n              currentTarget: that.currentTarget,\n              initialTarget: e.touch ? e.touch.initialTouch : null,\n              dropTarget: e.dropTarget,\n              elementUnderCursor: e.elementUnderCursor\n            }));\n          },\n          _elementUnderCursor: function (e) {\n            var target = elementUnderCursor(e),\n                hint = this.hint;\n\n            if (hint && contains(hint[0], target)) {\n              hint.hide();\n              target = elementUnderCursor(e); // IE8 does not return the element in iframe from first attempt\n\n              if (!target) {\n                target = elementUnderCursor(e);\n              }\n\n              hint.show();\n            }\n\n            return target;\n          },\n          _withDropTarget: function (element, callback) {\n            var result,\n                group = this.options.group,\n                targets = dropTargets[group],\n                areas = dropAreas[group];\n\n            if (targets && targets.length || areas && areas.length) {\n              result = checkTarget(element, targets, areas);\n\n              if (result) {\n                callback(result.target, result.targetElement);\n              } else {\n                callback();\n              }\n            }\n          },\n          destroy: function () {\n            var that = this;\n            Widget.fn.destroy.call(that);\n\n            that._afterEnd();\n\n            that.userEvents.destroy();\n            this._scrollableParent = null;\n            this._cursorElement = null;\n            clearInterval(this._scrollInterval);\n            that.currentTarget = null;\n          },\n          _afterEnd: function () {\n            var that = this;\n\n            if (that.hint) {\n              that.hint.remove();\n            }\n\n            delete draggables[that.options.group];\n            that.trigger(\"destroy\");\n            that.trigger(HINTDESTROYED);\n            $(document).off(KEYUP, that._captureEscape);\n          }\n        });\n        kendo.ui.plugin(DropTarget);\n        kendo.ui.plugin(DropTargetArea);\n        kendo.ui.plugin(Draggable);\n        kendo.TapCapture = TapCapture;\n        kendo.containerBoundaries = containerBoundaries;\n        extend(kendo.ui, {\n          Pane: Pane,\n          PaneDimensions: PaneDimensions,\n          Movable: Movable\n        });\n\n        function scrollableViewPort(element) {\n          var root = scrollableRoot()[0],\n              offset,\n              top,\n              left;\n\n          if (element[0] === root) {\n            top = root.scrollTop;\n            left = root.scrollLeft;\n            return {\n              top: top,\n              left: left,\n              bottom: top + $window.height(),\n              right: left + $window.width()\n            };\n          } else {\n            offset = element.offset();\n            offset.bottom = offset.top + element.height();\n            offset.right = offset.left + element.width();\n            return offset;\n          }\n        }\n\n        function scrollableRoot() {\n          return $(kendo.support.browser.edge || kendo.support.browser.safari ? document.body : document.documentElement);\n        }\n\n        function findScrollableParent(element) {\n          var root = scrollableRoot();\n\n          if (!element || element === document.body || element === document.documentElement) {\n            return root;\n          }\n\n          var parent = $(element)[0];\n\n          while (parent && !kendo.isScrollable(parent) && parent !== document.body) {\n            parent = parent.parentNode;\n          }\n\n          if (parent === document.body) {\n            return root;\n          }\n\n          return $(parent);\n        }\n\n        function autoScrollVelocity(mouseX, mouseY, rect) {\n          var velocity = {\n            x: 0,\n            y: 0\n          };\n          var AUTO_SCROLL_AREA = 50;\n\n          if (mouseX - rect.left < AUTO_SCROLL_AREA) {\n            velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));\n          } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {\n            velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);\n          }\n\n          if (mouseY - rect.top < AUTO_SCROLL_AREA) {\n            velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));\n          } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {\n            velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);\n          }\n\n          return velocity;\n        } // export for testing\n\n\n        kendo.ui.Draggable.utils = {\n          autoScrollVelocity: autoScrollVelocity,\n          scrollableViewPort: scrollableViewPort,\n          findScrollableParent: findScrollableParent\n        };\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}