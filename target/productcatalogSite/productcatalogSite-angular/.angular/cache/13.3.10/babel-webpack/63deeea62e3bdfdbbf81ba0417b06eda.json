{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport Point from './point';\nimport { X, Y, TOP, BOTTOM, LEFT, RIGHT, CENTER, WIDTH, HEIGHT } from '../common/constants';\nimport { Class, defined, getSpacing, inArray, isArray, rad } from '../common';\n\nclass Box extends Class {\n  constructor(x1, y1, x2, y2) {\n    super();\n    this.x1 = x1 || 0;\n    this.y1 = y1 || 0;\n    this.x2 = x2 || 0;\n    this.y2 = y2 || 0;\n  }\n\n  equals(box) {\n    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;\n  }\n\n  width() {\n    return this.x2 - this.x1;\n  }\n\n  height() {\n    return this.y2 - this.y1;\n  }\n\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  }\n\n  move(x, y) {\n    const height = this.height();\n    const width = this.width();\n\n    if (defined(x)) {\n      this.x1 = x;\n      this.x2 = this.x1 + width;\n    }\n\n    if (defined(y)) {\n      this.y1 = y;\n      this.y2 = this.y1 + height;\n    }\n\n    return this;\n  }\n\n  wrap(targetBox) {\n    this.x1 = Math.min(this.x1, targetBox.x1);\n    this.y1 = Math.min(this.y1, targetBox.y1);\n    this.x2 = Math.max(this.x2, targetBox.x2);\n    this.y2 = Math.max(this.y2, targetBox.y2);\n    return this;\n  }\n\n  wrapPoint(point) {\n    const arrayPoint = isArray(point);\n    const x = arrayPoint ? point[0] : point.x;\n    const y = arrayPoint ? point[1] : point.y;\n    this.wrap(new Box(x, y, x, y));\n    return this;\n  }\n\n  snapTo(targetBox, axis) {\n    if (axis === X || !axis) {\n      this.x1 = targetBox.x1;\n      this.x2 = targetBox.x2;\n    }\n\n    if (axis === Y || !axis) {\n      this.y1 = targetBox.y1;\n      this.y2 = targetBox.y2;\n    }\n\n    return this;\n  }\n\n  alignTo(targetBox, anchor) {\n    const height = this.height();\n    const width = this.width();\n    const axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n    const offset = axis === Y ? height : width;\n\n    if (anchor === CENTER) {\n      const targetCenter = targetBox.center();\n      const center = this.center();\n      this.x1 += targetCenter.x - center.x;\n      this.y1 += targetCenter.y - center.y;\n    } else if (anchor === TOP || anchor === LEFT) {\n      this[axis + 1] = targetBox[axis + 1] - offset;\n    } else {\n      this[axis + 1] = targetBox[axis + 2];\n    }\n\n    this.x2 = this.x1 + width;\n    this.y2 = this.y1 + height;\n    return this;\n  }\n\n  shrink(dw, dh) {\n    this.x2 -= dw;\n    this.y2 -= dh;\n    return this;\n  }\n\n  expand(dw, dh) {\n    this.shrink(-dw, -dh);\n    return this;\n  }\n\n  pad(padding) {\n    const spacing = getSpacing(padding);\n    this.x1 -= spacing.left;\n    this.x2 += spacing.right;\n    this.y1 -= spacing.top;\n    this.y2 += spacing.bottom;\n    return this;\n  }\n\n  unpad(padding) {\n    const spacing = getSpacing(padding);\n    spacing.left = -spacing.left;\n    spacing.top = -spacing.top;\n    spacing.right = -spacing.right;\n    spacing.bottom = -spacing.bottom;\n    return this.pad(spacing);\n  }\n\n  clone() {\n    return new Box(this.x1, this.y1, this.x2, this.y2);\n  }\n\n  center() {\n    return new Point(this.x1 + this.width() / 2, this.y1 + this.height() / 2);\n  }\n\n  containsPoint(point) {\n    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;\n  }\n\n  points() {\n    return [new Point(this.x1, this.y1), new Point(this.x2, this.y1), new Point(this.x2, this.y2), new Point(this.x1, this.y2)];\n  }\n\n  getHash() {\n    return [this.x1, this.y1, this.x2, this.y2].join(\",\");\n  }\n\n  overlaps(box) {\n    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n  }\n\n  rotate(rotation) {\n    let width = this.width();\n    let height = this.height();\n    const {\n      x: cx,\n      y: cy\n    } = this.center();\n    const r1 = rotatePoint(0, 0, cx, cy, rotation);\n    const r2 = rotatePoint(width, 0, cx, cy, rotation);\n    const r3 = rotatePoint(width, height, cx, cy, rotation);\n    const r4 = rotatePoint(0, height, cx, cy, rotation);\n    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n    this.x2 = this.x1 + width;\n    this.y2 = this.y1 + height;\n    return this;\n  }\n\n  toRect() {\n    return new geom.Rect([this.x1, this.y1], [this.width(), this.height()]);\n  }\n\n  hasSize() {\n    return this.width() !== 0 && this.height() !== 0;\n  }\n\n  align(targetBox, axis, alignment) {\n    const c1 = axis + 1;\n    const c2 = axis + 2;\n    const sizeFunc = axis === X ? WIDTH : HEIGHT;\n    const size = this[sizeFunc]();\n\n    if (inArray(alignment, [LEFT, TOP])) {\n      this[c1] = targetBox[c1];\n      this[c2] = this[c1] + size;\n    } else if (inArray(alignment, [RIGHT, BOTTOM])) {\n      this[c2] = targetBox[c2];\n      this[c1] = this[c2] - size;\n    } else if (alignment === CENTER) {\n      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n      this[c2] = this[c1] + size;\n    }\n  }\n\n}\n\nfunction rotatePoint(x, y, cx, cy, angle) {\n  const theta = rad(angle);\n  return new Point(cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta), cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta));\n}\n\nexport default Box;","map":null,"metadata":{},"sourceType":"module"}