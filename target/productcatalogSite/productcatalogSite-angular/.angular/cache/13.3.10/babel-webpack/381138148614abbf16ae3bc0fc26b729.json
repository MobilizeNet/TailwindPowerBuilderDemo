{"ast":null,"code":"import { drawing as draw, throttle, geometry } from '@progress/kendo-drawing';\nimport { RootElement, Title, CategoryAxis, Point } from '../core';\nimport Highlight from './highlight';\nimport Pannable from './pan-and-zoom/pannable';\nimport ZoomSelection from './pan-and-zoom/zoom-selection';\nimport MousewheelZoom from './pan-and-zoom/mousewheel-zoom';\nimport Legend from './legend/legend';\nimport PlotAreaFactory from './plotarea/plotarea-factory';\nimport Selection from './selection';\nimport SeriesBinder from './series-binder';\nimport Tooltip from './tooltip/tooltip';\nimport SharedTooltip from './tooltip/shared-tooltip';\nimport CategoricalPlotArea from './plotarea/categorical-plotarea';\nimport PlotAreaBase from './plotarea/plotarea-base';\nimport { ChartService, DomEventsBuilder } from '../services';\nimport getField from './utils/get-field';\nimport isDateAxis from './utils/is-date-axis';\nimport getDateField from './utils/get-date-field';\nimport { ChartPane, ChartPlotArea, findAxisByName } from './api-elements';\nimport { X, Y, VALUE, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_SERIES_OPACITY } from '../common/constants';\nimport { addClass, Class, setDefaultOptions, deepExtend, defined, find, isObject, isFunction, elementSize, elementOffset, elementScale, elementStyles, eventCoordinates, bindEvents, unbindEvents, mousewheelDelta, FontLoader, inArray, last, round, HashMap, valueOrDefault } from '../common';\nimport { dateComparer } from '../date-utils';\nimport { DRAG_START, DRAG, DRAG_END, ZOOM_START, ZOOM, ZOOM_END, SELECT_START, SELECT, SELECT_END, PLOT_AREA_HOVER, PLOT_AREA_LEAVE, RENDER, CATEGORY, PIE, DONUT, FUNNEL, COLUMN, MOUSEWHEEL, MOUSEWHEEL_DELAY, MOUSEWHEEL_ZOOM_RATE, SHOW_TOOLTIP, SERIES_HOVER } from './constants';\nimport './animations';\nimport './register-charts';\nconst AXIS_NAMES = [CATEGORY, VALUE, X, Y];\nconst MOUSEMOVE = \"mousemove\";\nconst CONTEXTMENU = \"contextmenu\";\nconst MOUSELEAVE = \"mouseleave\";\nconst MOUSEMOVE_DELAY = 20;\n\nclass Chart extends Class {\n  constructor(element, userOptions, themeOptions, context = {}) {\n    super();\n    this.observers = [];\n    this.addObserver(context.observer);\n    this.chartService = new ChartService(this, context);\n    this.chartService.theme = themeOptions;\n\n    this._initElement(element);\n\n    const options = deepExtend({}, this.options, userOptions);\n    this._originalOptions = deepExtend({}, options);\n    this._theme = themeOptions;\n\n    this._initTheme(options, themeOptions);\n\n    this._initHandlers();\n\n    this._initSurface();\n\n    this.bindCategories();\n    FontLoader.preloadFonts(userOptions, () => {\n      this.fontLoaded = true;\n\n      if (!this._destroyed) {\n        this.trigger('init');\n\n        this._redraw();\n\n        this._attachEvents();\n      }\n    });\n  }\n\n  _initElement(element) {\n    this._setElementClass(element);\n\n    element.style.position = \"relative\";\n\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n\n    this.element = element;\n  }\n\n  _setElementClass(element) {\n    addClass(element, \"k-chart\");\n  }\n\n  _initTheme(options, themeOptions) {\n    const seriesCopies = [];\n    const series = options.series || [];\n\n    for (let i = 0; i < series.length; i++) {\n      seriesCopies.push(Object.assign({}, series[i]));\n    }\n\n    options.series = seriesCopies;\n    resolveAxisAliases(options);\n    this.applyDefaults(options, themeOptions); // Clean up default if not overriden by data attributes\n\n    if (options.seriesColors === null) {\n      delete options.seriesColors;\n    }\n\n    this.options = deepExtend({}, themeOptions, options);\n    this.applySeriesColors();\n  }\n\n  getSize() {\n    const chartArea = this.options.chartArea || {};\n    const width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n    const height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n    return {\n      width: width,\n      height: height\n    };\n  }\n\n  resize(force) {\n    const size = this.getSize();\n    const currentSize = this._size;\n    const hasSize = size.width > 0 || size.height > 0;\n\n    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n      this._size = size;\n\n      this._resize(size, force);\n\n      this.trigger(\"resize\", size);\n    } else if (hasSize && this._selections && find(this._selections, s => !s.visible)) {\n      this._destroySelections();\n\n      this._setupSelection();\n    }\n  }\n\n  _resize() {\n    this._noTransitionsRedraw();\n  }\n\n  redraw(paneName) {\n    this.applyDefaults(this.options);\n    this.applySeriesColors();\n\n    if (paneName) {\n      const plotArea = this._model._plotArea;\n      const pane = plotArea.findPane(paneName);\n      plotArea.redraw(pane);\n    } else {\n      this._redraw();\n    }\n  }\n\n  getAxis(name) {\n    return findAxisByName(name, this._plotArea.axes);\n  }\n\n  findAxisByName(name) {\n    return this.getAxis(name);\n  }\n\n  findPaneByName(name) {\n    const panes = this._plotArea.panes;\n\n    for (let idx = 0; idx < panes.length; idx++) {\n      if (panes[idx].options.name === name) {\n        return new ChartPane(panes[idx]);\n      }\n    }\n  }\n\n  findPaneByIndex(idx) {\n    const panes = this._plotArea.panes;\n\n    if (panes[idx]) {\n      return new ChartPane(panes[idx]);\n    }\n  }\n\n  plotArea() {\n    return new ChartPlotArea(this._plotArea);\n  }\n\n  toggleHighlight(show, filter) {\n    const plotArea = this._plotArea;\n    const firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n    let points;\n\n    if (isFunction(filter)) {\n      points = plotArea.filterPoints(filter);\n    } else {\n      let seriesName, categoryName;\n\n      if (isObject(filter)) {\n        seriesName = filter.series;\n        categoryName = filter.category;\n      } else {\n        seriesName = categoryName = filter;\n      }\n\n      if (firstSeries.type === DONUT) {\n        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n      } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\n        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n      } else {\n        points = plotArea.pointsBySeriesName(seriesName);\n      }\n    }\n\n    if (points) {\n      this.togglePointsHighlight(show, points);\n    }\n  }\n\n  togglePointsHighlight(show, points) {\n    const highlight = this._highlight;\n\n    for (let idx = 0; idx < points.length; idx++) {\n      highlight.togglePointHighlight(points[idx], show);\n    }\n  }\n\n  showTooltip(filter) {\n    const shared = this._sharedTooltip();\n\n    const {\n      _tooltip: tooltip,\n      _plotArea: plotArea\n    } = this;\n    let point, categoryIndex;\n\n    if (isFunction(filter)) {\n      point = plotArea.findPoint(filter);\n\n      if (point && shared) {\n        categoryIndex = point.categoryIx;\n      }\n    } else if (shared && defined(filter)) {\n      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n    }\n\n    if (shared) {\n      if (categoryIndex >= 0) {\n        const points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n\n        tooltip.showAt(points);\n      }\n    } else if (point) {\n      tooltip.show(point);\n    }\n  }\n\n  hideTooltip() {\n    this._tooltip.hide();\n  }\n\n  _initSurface() {\n    const surface = this.surface;\n\n    const wrap = this._surfaceWrap();\n\n    const chartArea = this.options.chartArea || {};\n\n    if (chartArea.width) {\n      elementSize(wrap, {\n        width: chartArea.width\n      });\n    }\n\n    if (chartArea.height) {\n      elementSize(wrap, {\n        height: chartArea.height\n      });\n    }\n\n    if (!surface || surface.options.type !== this.options.renderAs) {\n      this._destroySurface();\n\n      this.surface = draw.Surface.create(wrap, {\n        type: this.options.renderAs\n      });\n      this.surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\n      this.surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\n    } else {\n      this.surface.clear();\n      this.surface.resize();\n    }\n  }\n\n  _surfaceWrap() {\n    return this.element;\n  }\n\n  _redraw() {\n    const model = this._getModel();\n\n    this._size = {\n      width: model.options.width,\n      height: model.options.height\n    };\n\n    this._destroyView();\n\n    this._model = model;\n    this._plotArea = model._plotArea;\n    model.renderVisual();\n\n    if (this.options.transitions !== false) {\n      model.traverse(function (element) {\n        if (element.animation) {\n          element.animation.setup();\n        }\n      });\n    }\n\n    this._initSurface();\n\n    this.surface.draw(model.visual);\n\n    if (this.options.transitions !== false) {\n      model.traverse(function (element) {\n        if (element.animation) {\n          element.animation.play();\n        }\n      });\n    }\n\n    this._tooltip = this._createTooltip();\n    this._highlight = new Highlight();\n\n    this._setupSelection();\n\n    this._createPannable();\n\n    this._createZoomSelection();\n\n    this._createMousewheelZoom();\n\n    this.trigger(RENDER);\n    triggerPaneRender(this._plotArea.panes);\n\n    if (!this._navState) {\n      this._cancelDomEvents();\n    }\n  }\n\n  exportVisual(exportOptions) {\n    let visual;\n\n    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n      const currentOptions = this.options;\n      const options = deepExtend({}, exportOptions.options, {\n        chartArea: {\n          width: exportOptions.width,\n          height: exportOptions.height\n        }\n      });\n      clearMissingValues(this._originalOptions, options);\n      this.options = deepExtend({}, this._originalOptions, options);\n\n      this._initTheme(this.options, this._theme);\n\n      this.bindCategories();\n\n      const model = this._getModel();\n\n      model.renderVisual();\n      triggerPaneRender(model._plotArea.panes);\n      visual = model.visual;\n      this.options = currentOptions;\n    } else {\n      visual = this.surface.exportVisual();\n    }\n\n    return visual;\n  }\n\n  _sharedTooltip() {\n    return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;\n  }\n\n  _createPannable() {\n    const options = this.options;\n\n    if (options.pannable !== false) {\n      this._pannable = new Pannable(this._plotArea, options.pannable);\n    }\n  }\n\n  _createZoomSelection() {\n    const zoomable = this.options.zoomable;\n    const selection = (zoomable || {}).selection;\n\n    if (zoomable !== false && selection !== false) {\n      this._zoomSelection = new ZoomSelection(this, selection);\n    }\n  }\n\n  _createMousewheelZoom() {\n    const zoomable = this.options.zoomable;\n    const mousewheel = (zoomable || {}).mousewheel;\n\n    if (zoomable !== false && mousewheel !== false) {\n      this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\n    }\n  }\n\n  _toggleDragZoomEvents() {\n    const pannable = this.options.pannable;\n    const zoomable = this.options.zoomable;\n    const selection = (zoomable || {}).selection;\n    const mousewheel = (zoomable || {}).mousewheel;\n    const allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);\n    const allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);\n    const element = this.element;\n\n    if (this._dragZoomEnabled && allowDrag && allowZoom) {\n      element.style.touchAction = this._touchAction || '';\n      this._dragZoomEnabled = false;\n    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n      element.style.touchAction = \"none\";\n      this._dragZoomEnabled = true;\n    }\n\n    this._toggleDomEvents(!allowDrag, !allowZoom);\n  }\n\n  _toggleDomEvents(drag, zoom) {\n    const domEvents = this.domEvents;\n\n    if (!domEvents) {\n      return;\n    }\n\n    if (domEvents.toggleDrag) {\n      domEvents.toggleDrag(drag);\n    }\n\n    if (domEvents.toggleZoom) {\n      domEvents.toggleZoom(zoom);\n    }\n  }\n\n  _createTooltip() {\n    const {\n      options: {\n        tooltip: tooltipOptions\n      }\n    } = this;\n    let tooltip;\n\n    if (this._sharedTooltip()) {\n      tooltip = this._createSharedTooltip(tooltipOptions);\n    } else {\n      tooltip = new Tooltip(this.chartService, tooltipOptions);\n    }\n\n    return tooltip;\n  }\n\n  _createSharedTooltip(options) {\n    return new SharedTooltip(this._plotArea, options);\n  }\n\n  applyDefaults(options, themeOptions) {\n    applyAxisDefaults(options, themeOptions);\n    applySeriesDefaults(options, themeOptions);\n  }\n\n  applySeriesColors() {\n    const options = this.options;\n    const series = options.series;\n    const colors = options.seriesColors || [];\n\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      const seriesColor = colors[i % colors.length];\n      const defaults = currentSeries._defaults;\n      currentSeries.color = currentSeries.color || seriesColor;\n\n      if (defaults) {\n        defaults.color = defaults.color || seriesColor;\n      }\n    }\n  }\n\n  _getModel() {\n    const options = this.options;\n\n    const plotArea = this._createPlotArea();\n\n    const model = new RootElement(this._modelOptions());\n    model.chart = this;\n    model._plotArea = plotArea;\n    const title = Title.buildTitle(options.title);\n    const subtitle = Title.buildTitle(options.subtitle, {\n      align: options.title.align,\n      position: options.title.position\n    });\n    model.append.apply(model, Title.orderTitles([title, subtitle]));\n\n    if (options.legend && options.legend.visible) {\n      model.append(new Legend(plotArea.options.legend, this.chartService));\n    }\n\n    model.append(plotArea);\n    model.reflow();\n    return model;\n  }\n\n  _modelOptions() {\n    const options = this.options;\n    const size = this.getSize();\n    return deepExtend({\n      transitions: options.transitions,\n      width: size.width || DEFAULT_WIDTH,\n      height: size.height || DEFAULT_HEIGHT\n    }, options.chartArea);\n  }\n\n  _createPlotArea(skipSeries) {\n    const options = this.options;\n    const plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n    return plotArea;\n  }\n\n  _setupSelection() {\n    const {\n      _plotArea: {\n        axes\n      }\n    } = this;\n    const selections = this._selections = [];\n\n    for (let i = 0; i < axes.length; i++) {\n      const axis = axes[i];\n      const options = axis.options;\n\n      if (axis instanceof CategoryAxis && options.select && !options.vertical) {\n        const range = axis.range();\n        const selection = new Selection(this, axis, deepExtend({\n          min: range.min,\n          max: range.max\n        }, options.select));\n        selections.push(selection);\n      }\n    }\n  }\n\n  _selectStart(e) {\n    return this.trigger(SELECT_START, e);\n  }\n\n  _select(e) {\n    return this.trigger(SELECT, e);\n  }\n\n  _selectEnd(e) {\n    return this.trigger(SELECT_END, e);\n  }\n\n  _initHandlers() {\n    this._clickHandler = this._click.bind(this);\n    this._mousewheelHandler = this._mousewheel.bind(this);\n    this._mouseleaveHandler = this._mouseleave.bind(this);\n    this._surfaceMouseenterHandler = this._mouseover.bind(this);\n    this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n    this._mousemove = throttle(this._mousemove.bind(this), MOUSEMOVE_DELAY);\n  }\n\n  addObserver(observer) {\n    if (observer) {\n      this.observers.push(observer);\n    }\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  requiresHandlers(eventNames) {\n    const observers = this.observers;\n\n    for (let idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].requiresHandlers(eventNames)) {\n        return true;\n      }\n    }\n  }\n\n  trigger(name, args = {}) {\n    if (name === SHOW_TOOLTIP) {\n      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n    }\n\n    args.sender = this;\n    const observers = this.observers;\n    let isDefaultPrevented = false;\n\n    for (let idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n\n    return isDefaultPrevented;\n  }\n\n  _attachEvents() {\n    const element = this.element;\n    this._touchAction = element.style.touchAction;\n    bindEvents(element, {\n      [CONTEXTMENU]: this._clickHandler,\n      [MOUSEWHEEL]: this._mousewheelHandler,\n      [MOUSELEAVE]: this._mouseleaveHandler\n    });\n\n    if (this._shouldAttachMouseMove()) {\n      bindEvents(element, {\n        [MOUSEMOVE]: this._mousemove\n      });\n    }\n\n    this.domEvents = DomEventsBuilder.create(this.element, {\n      start: this._start.bind(this),\n      move: this._move.bind(this),\n      end: this._end.bind(this),\n      tap: this._tap.bind(this),\n      gesturestart: this._gesturestart.bind(this),\n      gesturechange: this._gesturechange.bind(this),\n      gestureend: this._gestureend.bind(this)\n    });\n\n    this._toggleDragZoomEvents();\n  }\n\n  _mouseleave(e) {\n    if (this._hoveredPoint) {\n      this._hoveredPoint.out(this, e);\n\n      this._hoveredPoint = null;\n    }\n\n    if (this._plotAreaHovered) {\n      this._plotAreaHovered = false;\n      this.trigger(PLOT_AREA_LEAVE);\n    }\n  }\n\n  _cancelDomEvents() {\n    if (this.domEvents && this.domEvents.cancel) {\n      this.domEvents.cancel();\n    }\n  }\n\n  _gesturestart(e) {\n    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n      this._gestureDistance = e.distance;\n\n      this._unsetActivePoint();\n\n      this.surface.suspendTracking();\n    }\n  }\n\n  _gestureend(e) {\n    if (this._zooming && !this._stopChartHandlers(e)) {\n      if (this.surface) {\n        this.surface.resumeTracking();\n      }\n\n      this._zooming = false;\n      this.trigger(ZOOM_END, {});\n    }\n  }\n\n  _gesturechange(e) {\n    const mousewheelZoom = this._mousewheelZoom;\n\n    if (mousewheelZoom && !this._stopChartHandlers(e)) {\n      e.preventDefault();\n      const previousGestureDistance = this._gestureDistance;\n      let scaleDelta = -e.distance / previousGestureDistance + 1;\n\n      if (Math.abs(scaleDelta) >= 0.1) {\n        scaleDelta = Math.round(scaleDelta * 10);\n        this._gestureDistance = e.distance;\n        const args = {\n          delta: scaleDelta,\n          axisRanges: axisRanges(this._plotArea.axes),\n          originalEvent: e\n        };\n\n        if (this._zooming || !this.trigger(ZOOM_START, args)) {\n          const coords = this._eventCoordinates(e);\n\n          if (!this._zooming) {\n            this._zooming = true;\n          }\n\n          const ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);\n\n          if (ranges && !this.trigger(ZOOM, args)) {\n            mousewheelZoom.zoom();\n          }\n        }\n      }\n    }\n  }\n\n  _mouseout(e) {\n    if (e.element) {\n      const element = this._drawingChartElement(e.element, e);\n\n      if (element && element.leave) {\n        element.leave(this, e.originalEvent);\n      }\n    }\n  }\n\n  _start(e) {\n    const coords = this._eventCoordinates(e);\n\n    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n      return;\n    }\n\n    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {\n      this._startNavigation(e, coords, DRAG_START);\n    }\n\n    if (this._pannable && this._pannable.start(e)) {\n      this.surface.suspendTracking();\n\n      this._unsetActivePoint();\n\n      this._suppressHover = true;\n      this.chartService.panning = true;\n    }\n\n    if (this._zoomSelection) {\n      if (this._zoomSelection.start(e)) {\n        this.trigger(ZOOM_START, {\n          axisRanges: axisRanges(this._plotArea.axes),\n          originalEvent: e\n        });\n      }\n    }\n  }\n\n  _move(e) {\n    let {\n      _navState: state,\n      _pannable: pannable\n    } = this;\n\n    if (this._stopChartHandlers(e)) {\n      return;\n    }\n\n    if (pannable) {\n      const ranges = pannable.move(e);\n\n      if (ranges && !this.trigger(DRAG, {\n        axisRanges: ranges,\n        originalEvent: e\n      })) {\n        pannable.pan();\n      }\n    } else if (state) {\n      const ranges = {};\n      const axes = state.axes;\n\n      for (let i = 0; i < axes.length; i++) {\n        const currentAxis = axes[i];\n        const axisName = currentAxis.options.name;\n\n        if (axisName) {\n          const axis = currentAxis.options.vertical ? e.y : e.x;\n          const delta = axis.startLocation - axis.location;\n\n          if (delta !== 0) {\n            ranges[currentAxis.options.name] = currentAxis.translateRange(delta);\n          }\n        }\n      }\n\n      state.axisRanges = ranges;\n      this.trigger(DRAG, {\n        axisRanges: ranges,\n        originalEvent: e\n      });\n    }\n\n    if (this._zoomSelection) {\n      this._zoomSelection.move(e);\n    }\n  }\n\n  _end(e) {\n    if (this._stopChartHandlers(e)) {\n      return;\n    }\n\n    const pannable = this._pannable;\n\n    if (pannable && pannable.end(e)) {\n      this.surface.resumeTracking();\n      this.trigger(DRAG_END, {\n        axisRanges: axisRanges(this._plotArea.axes),\n        originalEvent: e\n      });\n      this._suppressHover = false;\n      this.chartService.panning = false;\n    } else {\n      this._endNavigation(e, DRAG_END);\n    }\n\n    if (this._zoomSelection) {\n      const ranges = this._zoomSelection.end(e);\n\n      if (ranges && !this.trigger(ZOOM, {\n        axisRanges: ranges,\n        originalEvent: e\n      })) {\n        this._zoomSelection.zoom();\n\n        this.trigger(ZOOM_END, {\n          axisRanges: ranges,\n          originalEvent: e\n        });\n      }\n    }\n  }\n\n  _stopChartHandlers(e) {\n    const selections = this._selections || [];\n\n    if (!selections.length) {\n      return false;\n    }\n\n    const coords = this._eventCoordinates(e);\n\n    const pane = this._plotArea.paneByPoint(coords);\n\n    if (pane) {\n      for (let idx = 0; idx < selections.length; idx++) {\n        if (selections[idx].onPane(pane)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  _mousewheelZoomRate() {\n    const zoomable = this.options.zoomable;\n    const mousewheel = (zoomable || {}).mousewheel || {};\n    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);\n  }\n\n  _mousewheel(e) {\n    const delta = mousewheelDelta(e);\n    const mousewheelZoom = this._mousewheelZoom;\n\n    const coords = this._eventCoordinates(e);\n\n    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n      return;\n    }\n\n    if (mousewheelZoom) {\n      const args = {\n        delta: delta,\n        axisRanges: axisRanges(this._plotArea.axes),\n        originalEvent: e\n      };\n\n      if (this._zooming || !this.trigger(ZOOM_START, args)) {\n        e.preventDefault();\n\n        if (!this._zooming) {\n          this._unsetActivePoint();\n\n          this.surface.suspendTracking();\n          this._zooming = true;\n        }\n\n        if (this._mwTimeout) {\n          clearTimeout(this._mwTimeout);\n        }\n\n        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);\n\n        if (args.axisRanges && !this.trigger(ZOOM, args)) {\n          mousewheelZoom.zoom();\n        }\n\n        this._mwTimeout = setTimeout(() => {\n          this.trigger(ZOOM_END, args);\n          this._zooming = false;\n\n          if (this.surface) {\n            this.surface.resumeTracking();\n          }\n        }, MOUSEWHEEL_DELAY);\n      }\n    } else {\n      let state = this._navState;\n\n      if (!state) {\n        const prevented = this._startNavigation(e, coords, ZOOM_START);\n\n        if (!prevented) {\n          state = this._navState;\n        }\n      }\n\n      if (state) {\n        const totalDelta = state.totalDelta || delta;\n        state.totalDelta = totalDelta + delta;\n        const axes = this._navState.axes;\n        const ranges = {};\n\n        for (let i = 0; i < axes.length; i++) {\n          const currentAxis = axes[i];\n          const axisName = currentAxis.options.name;\n\n          if (axisName) {\n            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this._mousewheelZoomRate(), coords);\n          }\n        }\n\n        this.trigger(ZOOM, {\n          delta: delta,\n          axisRanges: ranges,\n          originalEvent: e\n        });\n\n        if (this._mwTimeout) {\n          clearTimeout(this._mwTimeout);\n        }\n\n        this._mwTimeout = setTimeout(() => {\n          this._endNavigation(e, ZOOM_END);\n        }, MOUSEWHEEL_DELAY);\n      }\n    }\n  }\n\n  _startNavigation(e, coords, chartEvent) {\n    const plotArea = this._model._plotArea;\n    const pane = plotArea.findPointPane(coords);\n    const axes = plotArea.axes.slice(0);\n\n    if (!pane) {\n      return;\n    }\n\n    const ranges = axisRanges(axes);\n    const prevented = this.trigger(chartEvent, {\n      axisRanges: ranges,\n      originalEvent: e\n    });\n\n    if (prevented) {\n      this._cancelDomEvents();\n    } else {\n      this._suppressHover = true;\n\n      this._unsetActivePoint();\n\n      this._navState = {\n        axisRanges: ranges,\n        pane: pane,\n        axes: axes\n      };\n    }\n  }\n\n  _endNavigation(e, chartEvent) {\n    if (this._navState) {\n      this.trigger(chartEvent, {\n        axisRanges: this._navState.axisRanges,\n        originalEvent: e\n      });\n      this._suppressHover = false;\n      this._navState = null;\n    }\n  }\n\n  _getChartElement(e, match) {\n    const element = this.surface.eventTarget(e);\n\n    if (element) {\n      return this._drawingChartElement(element, e, match);\n    }\n  }\n\n  _drawingChartElement(element, e, match) {\n    let current = element;\n    let chartElement;\n\n    while (current && !chartElement) {\n      chartElement = current.chartElement;\n      current = current.parent;\n    }\n\n    if (chartElement) {\n      if (chartElement.aliasFor) {\n        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n      }\n\n      if (match) {\n        chartElement = chartElement.closest(match);\n\n        if (chartElement && chartElement.aliasFor) {\n          chartElement = chartElement.aliasFor();\n        }\n      }\n\n      return chartElement;\n    }\n  }\n\n  _eventCoordinates(e) {\n    const coordinates = eventCoordinates(e);\n    return this._toModelCoordinates(coordinates.x, coordinates.y);\n  }\n\n  _elementPadding() {\n    if (!this._padding) {\n      const {\n        paddingLeft,\n        paddingTop\n      } = elementStyles(this.element, [\"paddingLeft\", \"paddingTop\"]);\n      this._padding = {\n        top: paddingTop,\n        left: paddingLeft\n      };\n    }\n\n    return this._padding;\n  }\n\n  _toDocumentCoordinates(point) {\n    const padding = this._elementPadding();\n\n    const offset = elementOffset(this.element);\n    return {\n      left: round(point.x + padding.left + offset.left),\n      top: round(point.y + padding.top + offset.top)\n    };\n  } // TODO: Breaking change due to peer version change\n  // Reuse by exposing _surfacePoint on Surface\n\n\n  _toModelCoordinates(clientX, clientY) {\n    const element = this.element;\n    const offset = elementOffset(element);\n\n    const padding = this._elementPadding();\n\n    const inverseTransform = elementScale(element).invert();\n    const point = new geometry.Point(clientX - offset.left - padding.left, clientY - offset.top - padding.top).transform(inverseTransform);\n    return new Point(point.x, point.y);\n  }\n\n  _tap(e) {\n    const drawingElement = this.surface.eventTarget(e);\n\n    const element = this._drawingChartElement(drawingElement, e);\n\n    const sharedTooltip = this._sharedTooltip();\n\n    if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n      this._unsetActivePoint();\n    }\n\n    if (sharedTooltip) {\n      this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n    }\n\n    this._propagateClick(element, e); //part of fix for hover issue on windows touch\n\n\n    this.handlingTap = true;\n    setTimeout(() => {\n      this.handlingTap = false;\n    }, 0);\n  }\n\n  _click(e) {\n    const element = this._getChartElement(e);\n\n    this._propagateClick(element, e);\n  }\n\n  _propagateClick(element, e) {\n    let current = element;\n\n    while (current) {\n      if (current.click) {\n        current.click(this, e);\n      }\n\n      current = current.parent;\n    }\n  }\n\n  _startHover(element, e) {\n    if (this._suppressHover) {\n      return false;\n    }\n\n    let point = this._drawingChartElement(element, e, function (element) {\n      return (element.hover || element.over) && !(element instanceof PlotAreaBase);\n    });\n\n    this._showInactiveOpacity(point, e);\n\n    return point;\n  }\n\n  _displayTooltip(point) {\n    const tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n\n    if (tooltipOptions.visible) {\n      this._tooltip.show(point);\n    }\n  }\n\n  _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {\n    const chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);\n\n    if (!chartInstance) {\n      return;\n    }\n\n    if (multipleSeries) {\n      this._updateSeriesOpacity(activePoint);\n\n      this._applySeriesOpacity(chartInstance.children, null, true);\n\n      this._applySeriesOpacity(chartInstance.children, activePoint.series);\n\n      this._highlight.show(highlightPoints || activePoint);\n    } else {\n      let inactivePoints;\n\n      if (!chartInstance.supportsPointInactiveOpacity()) {\n        this._highlight.show(activePoint);\n\n        return;\n      }\n\n      inactivePoints = this._getInactivePoints(activePoint, chartInstance);\n\n      if (inactivePoints && inactivePoints.length) {\n        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));\n      }\n    }\n  }\n\n  _getInactivePoints(activePoint, chartInstance) {\n    let allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);\n\n    return allPoints.filter(point => point !== activePoint);\n  }\n\n  _getAllPointsOfType(container, type) {\n    let points = [];\n\n    for (let i = 0; i < container.children.length; i++) {\n      const element = container.children[i];\n\n      if (element.constructor === type) {\n        points.push(element);\n      } else if (element.children && element.children.length) {\n        points = points.concat(this._getAllPointsOfType(element, type));\n      }\n    }\n\n    return points;\n  }\n\n  _updateHoveredPoint(point, e) {\n    const hoveredPoint = this._hoveredPoint;\n\n    if (hoveredPoint && hoveredPoint !== point) {\n      hoveredPoint.out(this, e);\n      this._hoveredPoint = null;\n    }\n\n    if (point && hoveredPoint !== point && point.over) {\n      this._hoveredPoint = point;\n      point.over(this, e);\n    }\n  }\n\n  _updateSeriesOpacity(point, resetOpacity) {\n    const plotArea = this._plotArea;\n    const length = plotArea.series.length;\n\n    for (let i = 0; i < length; i++) {\n      const currSeries = plotArea.series[i];\n\n      const defaultOpacity = this._getDefaultOpacityForSeries(currSeries);\n\n      const inactiveOpacity = this._getInactiveOpacityForSeries(currSeries);\n\n      if (!resetOpacity && currSeries !== point.series) {\n        currSeries.defaultOpacity = defaultOpacity;\n        currSeries.opacity = inactiveOpacity;\n\n        if (currSeries.line) {\n          currSeries.line.opacity = inactiveOpacity;\n        }\n      } else {\n        currSeries.opacity = defaultOpacity;\n\n        if (currSeries.line) {\n          currSeries.line.opacity = defaultOpacity;\n        }\n      }\n    }\n  }\n\n  _applySeriesOpacity(elements, activeSeries, reset, series) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const currSeries = element.series || series;\n      const shouldHighlight = currSeries && (currSeries.highlight || {}).visible;\n\n      if (shouldHighlight && element.visual) {\n        const opacity = series ? series.opacity : element.series.opacity;\n\n        if (currSeries !== activeSeries || reset) {\n          element.visual.opacity(reset ? 1 : opacity);\n        }\n      }\n\n      if (element.children && element.children.length) {\n        this._applySeriesOpacity(element.children, activeSeries, reset, element.series);\n      }\n    }\n  }\n\n  _chartInstanceFromPoint(point) {\n    let chartInstance = point.parent;\n\n    while (chartInstance && !chartInstance.plotArea) {\n      chartInstance = chartInstance.parent;\n    }\n\n    return chartInstance;\n  }\n\n  _showInactiveOpacity(point, e) {\n    const activePoint = this._activePoint;\n    const multipleSeries = this._plotArea.series.length > 1;\n\n    const hasInactiveOpacity = this._hasInactiveOpacity();\n\n    this._updateHoveredPoint(point, e);\n\n    if (point && activePoint !== point && point.hover) {\n      this._activePoint = point;\n\n      if (!this._sharedTooltip() && !point.hover(this, e)) {\n        this._displayTooltip(point);\n\n        if (hasInactiveOpacity) {\n          this._displayInactiveOpacity(point, multipleSeries);\n        } else {\n          this._highlight.show(point);\n        }\n      }\n    }\n\n    return point;\n  }\n\n  _hideInactiveOpacity(point) {\n    const multipleSeries = this._plotArea.series.length > 1;\n\n    const hasInactiveOpacity = this._hasInactiveOpacity();\n\n    if (hasInactiveOpacity) {\n      if (multipleSeries && this._activeChartInstance) {\n        this._updateSeriesOpacity(point, true);\n\n        this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n\n        this._activeChartInstance = null;\n      }\n\n      this._highlight && this._highlight.hide();\n      this._activePoint = null;\n    }\n  }\n\n  _hasInactiveOpacity() {\n    let hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== undefined;\n    let hasInactiveOpacity = this.options.series.filter(s => s.highlight.inactiveOpacity !== undefined).length > 0;\n    return hasDefaultInactiveOpacity || hasInactiveOpacity;\n  }\n\n  _getInactiveOpacityForSeries(series) {\n    let defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;\n    let seriesInactiveOpacity = series.highlight.inactiveOpacity;\n    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n  }\n\n  _getDefaultOpacityForSeries(series) {\n    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n  }\n\n  _mouseover(e) {\n    const point = this._startHover(e.element, e.originalEvent);\n\n    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n      bindEvents(document, {\n        [MOUSEMOVE]: this._mouseMoveTrackHandler\n      });\n    }\n  }\n\n  _mouseMoveTracking(e) {\n    const {\n      options,\n      _tooltip: tooltip,\n      _highlight: highlight,\n      _activePoint: point\n    } = this;\n\n    const coords = this._eventCoordinates(e);\n\n    if (this._plotArea.box.containsPoint(coords)) {\n      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n        const seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n\n        if (seriesPoint && seriesPoint !== point) {\n          this._activePoint = seriesPoint;\n\n          if (!seriesPoint.hover(this, e)) {\n            const tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n\n            if (tooltipOptions.visible) {\n              tooltip.show(seriesPoint);\n            }\n\n            highlight.show(seriesPoint);\n          }\n        }\n      }\n    } else {\n      unbindEvents(document, {\n        [MOUSEMOVE]: this._mouseMoveTrackHandler\n      });\n\n      this._unsetActivePoint();\n\n      this._mouseMoveTrackHandler = null;\n\n      this._hideInactiveOpacity(point);\n    }\n  }\n\n  _mousemove(e) {\n    const coords = this._eventCoordinates(e);\n\n    const plotArea = this._plotArea;\n\n    this._trackCrosshairs(coords);\n\n    if (plotArea.hover) {\n      const overPlotArea = plotArea.backgroundContainsPoint(coords);\n\n      if (overPlotArea) {\n        this._plotAreaHovered = true;\n\n        this._plotArea.hover(this, e);\n      } else if (this._plotAreaHovered && !overPlotArea) {\n        this._plotAreaHovered = false;\n        this.trigger(PLOT_AREA_LEAVE);\n      }\n    }\n\n    if (this._sharedTooltip()) {\n      this._trackSharedTooltip(coords, e);\n    }\n  }\n\n  _trackCrosshairs(coords) {\n    const crosshairs = this._plotArea.crosshairs;\n\n    for (let i = 0; i < crosshairs.length; i++) {\n      const current = crosshairs[i];\n\n      if (current.box.containsPoint(coords)) {\n        current.showAt(coords);\n      } else {\n        current.hide();\n      }\n    }\n  }\n\n  _trackSharedTooltip(coords, e, toggle) {\n    if (this._suppressHover) {\n      return;\n    }\n\n    const {\n      options: {\n        tooltip: tooltipOptions\n      },\n      _plotArea: plotArea,\n      _plotArea: {\n        categoryAxis\n      },\n      _tooltip: tooltip,\n      _highlight: highlight\n    } = this;\n\n    if (plotArea.backgroundContainsPoint(coords)) {\n      const index = categoryAxis.pointCategoryIndex(coords);\n\n      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {\n        const points = plotArea.pointsByCategoryIndex(index);\n        const pointArgs = points.map(function (point) {\n          return point.eventArgs(e);\n        });\n        const hoverArgs = pointArgs[0] || {};\n        hoverArgs.categoryPoints = pointArgs;\n\n        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n          if (tooltipOptions.visible) {\n            tooltip.showAt(points, coords);\n          }\n\n          highlight.show(points);\n          this._sharedHighlight = true;\n        } else {\n          tooltip.hide();\n        }\n\n        this._tooltipCategoryIx = index;\n      } else if (toggle && this._sharedHighlight) {\n        highlight.hide();\n        tooltip.hide();\n        this._sharedHighlight = false;\n      }\n    } else if (this._sharedHighlight) {\n      highlight.hide();\n      tooltip.hide();\n      this._tooltipCategoryIx = null;\n      this._sharedHighlight = false;\n    }\n  }\n\n  hideElements(options) {\n    const plotArea = this._plotArea;\n\n    this._mousemove.cancel();\n\n    plotArea.hideCrosshairs();\n\n    this._unsetActivePoint(options);\n  }\n\n  _unsetActivePoint(options) {\n    const {\n      _tooltip: tooltip,\n      _highlight: highlight\n    } = this;\n    this._activePoint = null;\n    this._hoveredPoint = null;\n\n    if (tooltip && !(options && options.keepTooltipOpen)) {\n      tooltip.hide();\n    }\n\n    this._tooltipCategoryIx = null;\n    this._sharedHighlight = false;\n\n    if (highlight) {\n      highlight.hide();\n    }\n  }\n\n  _deferRedraw() {\n    this._redraw();\n  }\n\n  _clearRedrawTimeout() {\n    if (this._redrawTimeout) {\n      clearInterval(this._redrawTimeout);\n      this._redrawTimeout = null;\n    }\n  }\n\n  bindCategories() {\n    const options = this.options;\n    const definitions = [].concat(options.categoryAxis);\n\n    for (let axisIx = 0; axisIx < definitions.length; axisIx++) {\n      const axis = definitions[axisIx];\n\n      if (axis.autoBind !== false) {\n        this.bindCategoryAxisFromSeries(axis, axisIx);\n      }\n    }\n  }\n\n  bindCategoryAxisFromSeries(axis, axisIx) {\n    const series = this.options.series;\n    const seriesLength = series.length;\n    const uniqueCategories = new HashMap(); //perf improvement in case type category with dates\n\n    let items = [];\n    let bindable = false;\n    let dateAxis;\n\n    for (let seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n      const s = series[seriesIx];\n      const onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;\n      const data = s.data;\n      const dataLength = data.length;\n      const bind = s.categoryField && onAxis;\n      bindable = bind || bindable;\n\n      if (bind && dataLength > 0) {\n        dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\n        const getFn = dateAxis ? getDateField : getField;\n\n        for (let dataIx = 0; dataIx < dataLength; dataIx++) {\n          const dataRow = data[dataIx];\n          const category = getFn(s.categoryField, dataRow, this.chartService.intl);\n\n          if (dateAxis || !uniqueCategories.get(category)) {\n            items.push([category, dataRow]);\n\n            if (!dateAxis) {\n              uniqueCategories.set(category, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (items.length > 0) {\n      if (dateAxis) {\n        items = uniqueDates(items, function (a, b) {\n          return dateComparer(a[0], b[0]);\n        });\n      }\n\n      const result = transpose(items);\n      axis.categories = result[0];\n    } else if (bindable) {\n      axis.categories = [];\n    }\n  }\n\n  _isBindable(series) {\n    const valueFields = SeriesBinder.current.valueFields(series);\n    let result = true;\n\n    for (let i = 0; i < valueFields.length; i++) {\n      let field = valueFields[i];\n\n      if (field === VALUE) {\n        field = \"field\";\n      } else {\n        field = field + \"Field\";\n      }\n\n      if (!defined(series[field])) {\n        result = false;\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  _noTransitionsRedraw() {\n    const options = this.options;\n    let transitionsState;\n\n    if (options.transitions !== false) {\n      options.transitions = false;\n      transitionsState = true;\n    }\n\n    this._redraw();\n\n    if (transitionsState) {\n      options.transitions = true;\n    }\n  }\n\n  _legendItemHover(seriesIndex, pointIndex) {\n    const {\n      _plotArea: plotArea,\n      _highlight: highlight\n    } = this;\n    const currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n    let items;\n\n    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL])) {\n      items = plotArea.findPoint(function (point) {\n        return point.series.index === seriesIndex && point.index === pointIndex;\n      });\n    } else {\n      items = plotArea.pointsBySeriesIndex(seriesIndex);\n    }\n\n    if (this._hasInactiveOpacity() && currentSeries.visible && items) {\n      const multipleSeries = plotArea.series.length > 1;\n      const point = items.length ? items[0] : items;\n\n      this._displayInactiveOpacity(point, multipleSeries, items);\n    } else {\n      highlight.show(items);\n    }\n  }\n\n  _shouldAttachMouseMove() {\n    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);\n  }\n\n  updateMouseMoveHandler() {\n    unbindEvents(this.element, {\n      [MOUSEMOVE]: this._mousemove\n    });\n\n    if (this._shouldAttachMouseMove()) {\n      bindEvents(this.element, {\n        [MOUSEMOVE]: this._mousemove\n      });\n    }\n  }\n\n  applyOptions(options, theme) {\n    clearMissingValues(this._originalOptions, options);\n    this._originalOptions = deepExtend(this._originalOptions, options);\n    this.options = deepExtend({}, this._originalOptions);\n\n    if (theme) {\n      this._theme = theme;\n      this.chartService.theme = theme;\n    }\n\n    this._initTheme(this.options, this._theme);\n\n    this._toggleDragZoomEvents();\n  }\n\n  setOptions(options, theme) {\n    this.applyOptions(options, theme);\n    this.bindCategories();\n    this.redraw();\n    this.updateMouseMoveHandler();\n  }\n\n  setDirection(rtl) {\n    this.chartService.rtl = Boolean(rtl);\n\n    if (this.surface && this.surface.type === 'svg') {\n      this._destroySurface();\n    }\n  }\n\n  setIntlService(intl) {\n    this.chartService.intl = intl;\n  }\n\n  noTransitionsRedraw() {\n    this._noTransitionsRedraw();\n  }\n\n  destroy() {\n    this._destroyed = true;\n    unbindEvents(this.element, {\n      [CONTEXTMENU]: this._clickHandler,\n      [MOUSEWHEEL]: this._mousewheelHandler,\n      [MOUSEMOVE]: this._mousemove,\n      [MOUSELEAVE]: this._mouseleaveHandler\n    });\n\n    if (this.domEvents) {\n      this.domEvents.destroy();\n      delete this.domEvents;\n    }\n\n    if (this._mouseMoveTrackHandler) {\n      unbindEvents(document, {\n        [MOUSEMOVE]: this._mouseMoveTrackHandler\n      });\n    }\n\n    this._destroyView();\n\n    this._destroySurface();\n\n    this._clearRedrawTimeout();\n  }\n\n  _destroySurface() {\n    const surface = this.surface;\n\n    if (surface) {\n      surface.unbind(\"mouseenter\", this._surfaceMouseenterHandler);\n      surface.unbind(\"mouseleave\", this._surfaceMouseleaveHandler);\n      surface.destroy();\n      this.surface = null;\n    }\n  }\n\n  _destroySelections() {\n    const selections = this._selections;\n\n    if (selections) {\n      while (selections.length > 0) {\n        selections.shift().destroy();\n      }\n    }\n  }\n\n  _destroyView() {\n    const model = this._model;\n\n    if (model) {\n      model.destroy();\n      this._model = null;\n    }\n\n    this._unsetActivePoint();\n\n    this._destroySelections();\n\n    if (this._tooltip) {\n      this._tooltip.destroy();\n    }\n\n    if (this._highlight) {\n      this._highlight.destroy();\n    }\n\n    if (this._zoomSelection) {\n      this._zoomSelection.destroy();\n\n      delete this._zoomSelection;\n    }\n\n    if (this._pannable) {\n      this._pannable.destroy();\n\n      delete this._pannable;\n    }\n\n    if (this._mousewheelZoom) {\n      this._mousewheelZoom.destroy();\n\n      delete this._mousewheelZoom;\n    }\n  }\n\n}\n\nfunction resolveAxisAliases(options) {\n  const aliases = AXIS_NAMES;\n\n  for (let idx = 0; idx < aliases.length; idx++) {\n    const alias = aliases[idx] + \"Axes\";\n\n    if (options[alias]) {\n      options[aliases[idx] + \"Axis\"] = options[alias];\n      delete options[alias];\n    }\n  }\n}\n\nfunction pointByCategoryName(points, name) {\n  if (points) {\n    for (let idx = 0; idx < points.length; idx++) {\n      if (points[idx].category === name) {\n        return [points[idx]];\n      }\n    }\n  }\n}\n\nfunction applyAxisDefaults(options, themeOptions) {\n  const themeAxisDefaults = (themeOptions || {}).axisDefaults || {};\n  let axisName, axisDefaults, axes;\n\n  function mapAxisOptions(axisOptions) {\n    const axisColor = (axisOptions || {}).color || axisDefaults.color;\n    const result = deepExtend({}, themeAxisDefaults, themeAxisDefaults[axisName], axisDefaults, axisDefaults[axisName], {\n      line: {\n        color: axisColor\n      },\n      labels: {\n        color: axisColor\n      },\n      title: {\n        color: axisColor\n      }\n    }, axisOptions);\n    delete result[axisName];\n    return result;\n  }\n\n  for (let idx = 0; idx < AXIS_NAMES.length; idx++) {\n    axisName = AXIS_NAMES[idx] + \"Axis\";\n    axisDefaults = options.axisDefaults || {};\n    axes = [].concat(options[axisName]);\n    axes = axes.map(mapAxisOptions);\n    options[axisName] = axes.length > 1 ? axes : axes[0];\n  }\n}\n\nfunction applySeriesDefaults(options, themeOptions) {\n  const series = options.series;\n  const seriesLength = series.length;\n  const seriesDefaults = options.seriesDefaults;\n  const commonDefaults = deepExtend({}, options.seriesDefaults);\n  const themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n  const commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n  cleanupNestedSeriesDefaults(commonDefaults);\n  cleanupNestedSeriesDefaults(commonThemeDefaults);\n\n  for (let i = 0; i < seriesLength; i++) {\n    const seriesType = series[i].type || options.seriesDefaults.type;\n    const baseOptions = deepExtend({\n      data: []\n    }, commonThemeDefaults, themeSeriesDefaults[seriesType], {\n      tooltip: options.tooltip\n    }, commonDefaults, seriesDefaults[seriesType]);\n    series[i]._defaults = baseOptions;\n    series[i] = deepExtend({}, baseOptions, series[i]);\n    series[i].data = series[i].data || [];\n  }\n}\n\nfunction cleanupNestedSeriesDefaults(seriesDefaults) {\n  delete seriesDefaults.bar;\n  delete seriesDefaults.column;\n  delete seriesDefaults.rangeColumn;\n  delete seriesDefaults.line;\n  delete seriesDefaults.verticalLine;\n  delete seriesDefaults.pie;\n  delete seriesDefaults.donut;\n  delete seriesDefaults.area;\n  delete seriesDefaults.verticalArea;\n  delete seriesDefaults.scatter;\n  delete seriesDefaults.scatterLine;\n  delete seriesDefaults.bubble;\n  delete seriesDefaults.candlestick;\n  delete seriesDefaults.ohlc;\n  delete seriesDefaults.boxPlot;\n  delete seriesDefaults.bullet;\n  delete seriesDefaults.verticalBullet;\n  delete seriesDefaults.polarArea;\n  delete seriesDefaults.polarLine;\n  delete seriesDefaults.radarArea;\n  delete seriesDefaults.radarLine;\n  delete seriesDefaults.waterfall;\n}\n\nfunction axisRanges(axes) {\n  const ranges = {};\n\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const axisName = axis.options.name;\n\n    if (axisName) {\n      ranges[axisName] = axis.range();\n    }\n  }\n\n  return ranges;\n}\n\nfunction sortDates(dates, comparer = dateComparer) {\n  for (let i = 1, length = dates.length; i < length; i++) {\n    if (comparer(dates[i], dates[i - 1]) < 0) {\n      dates.sort(comparer);\n      break;\n    }\n  }\n\n  return dates;\n}\n\nfunction uniqueDates(srcDates, comparer = dateComparer) {\n  const dates = sortDates(srcDates, comparer);\n  const length = dates.length;\n  const result = length > 0 ? [dates[0]] : [];\n\n  for (let i = 1; i < length; i++) {\n    if (comparer(dates[i], last(result)) !== 0) {\n      result.push(dates[i]);\n    }\n  }\n\n  return result;\n}\n\nfunction transpose(rows) {\n  const rowCount = rows.length;\n  const result = [];\n\n  for (let rowIx = 0; rowIx < rowCount; rowIx++) {\n    const row = rows[rowIx];\n    const colCount = row.length;\n\n    for (let colIx = 0; colIx < colCount; colIx++) {\n      result[colIx] = result[colIx] || [];\n      result[colIx].push(row[colIx]);\n    }\n  }\n\n  return result;\n}\n\nconst DATA_FIELDS = ['data', 'categories'];\n\nfunction clearMissingValues(originalOptions, options) {\n  for (let field in options) {\n    if (!inArray(field, DATA_FIELDS) && options.hasOwnProperty(field)) {\n      const fieldValue = options[field];\n      const originalValue = originalOptions[field];\n\n      if (defined(originalValue)) {\n        const nullValue = fieldValue === null;\n\n        if (nullValue || !defined(fieldValue)) {\n          delete originalOptions[field];\n\n          if (nullValue) {\n            delete options[field];\n          }\n        } else if (originalValue && isObject(fieldValue)) {\n          if (isObject(originalValue)) {\n            clearMissingValues(originalValue, fieldValue);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction triggerPaneRender(panes) {\n  for (let idx = 0; idx < panes.length; idx++) {\n    panes[idx].notifyRender();\n  }\n}\n\nsetDefaultOptions(Chart, {\n  renderAs: \"\",\n  chartArea: {},\n  legend: {\n    visible: true,\n    labels: {}\n  },\n  categoryAxis: {},\n  seriesDefaults: {\n    type: COLUMN,\n    data: [],\n    highlight: {\n      visible: true\n    },\n    labels: {},\n    negativeValues: {\n      visible: false\n    }\n  },\n  series: [],\n  seriesColors: null,\n  tooltip: {\n    visible: false\n  },\n  transitions: true,\n  valueAxis: {},\n  plotArea: {},\n  title: {},\n  xAxis: {},\n  yAxis: {},\n  panes: [{}],\n  pannable: false,\n  zoomable: false\n});\nexport default Chart;","map":null,"metadata":{},"sourceType":"module"}