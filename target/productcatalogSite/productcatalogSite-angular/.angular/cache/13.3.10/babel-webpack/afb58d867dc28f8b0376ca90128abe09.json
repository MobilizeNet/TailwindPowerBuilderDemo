{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(935);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  925:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../location\");\n    /***/\n  },\n\n  /***/\n  931:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./base\");\n    /***/\n  },\n\n  /***/\n  935:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(931), __webpack_require__(925)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var math = Math,\n            kendo = window.kendo,\n            Class = kendo.Class,\n            template = kendo.template,\n            dataviz = kendo.dataviz,\n            deepExtend = kendo.deepExtend,\n            g = kendo.geometry,\n            Point = g.Point,\n            Layer = dataviz.map.layers.Layer,\n            util = kendo.util,\n            renderSize = util.renderSize,\n            drawingUtil = kendo.drawing.util,\n            round = drawingUtil.round,\n            limit = drawingUtil.limitValue; // Image tile layer =============================================================\n\n        var TileLayer = Layer.extend({\n          init: function (map, options) {\n            Layer.fn.init.call(this, map, options);\n\n            if (typeof this.options.subdomains === \"string\") {\n              this.options.subdomains = this.options.subdomains.split(\"\");\n            }\n\n            var viewType = this._viewType();\n\n            this._view = new viewType(this.element, this.options);\n          },\n          destroy: function () {\n            Layer.fn.destroy.call(this);\n\n            this._view.destroy();\n\n            this._view = null;\n          },\n          _beforeReset: function () {\n            var map = this.map;\n            var origin = map.locationToLayer(map.extent().nw).round();\n\n            this._view.viewOrigin(origin);\n          },\n          _reset: function (e) {\n            var tileTitle;\n\n            if (e) {\n              tileTitle = e.tileTitle;\n            } else {\n              tileTitle = \"\";\n            }\n\n            Layer.fn._reset.call(this);\n\n            this._updateView();\n\n            this._view.reset(tileTitle);\n          },\n          _viewType: function () {\n            return TileView;\n          },\n          _activate: function () {\n            Layer.fn._activate.call(this);\n\n            if (!kendo.support.mobileOS) {\n              if (!this._pan) {\n                this._pan = kendo.throttle(this._render.bind(this), 100);\n              }\n\n              this.map.bind(\"pan\", this._pan);\n            }\n          },\n          _deactivate: function () {\n            Layer.fn._deactivate.call(this);\n\n            if (this._pan) {\n              this.map.unbind(\"pan\", this._pan);\n            }\n          },\n          _updateView: function () {\n            var view = this._view,\n                map = this.map,\n                extent = map.extent(),\n                extentToPoint = {\n              nw: map.locationToLayer(extent.nw).round(),\n              se: map.locationToLayer(extent.se).round()\n            };\n            view.center(map.locationToLayer(map.center()));\n            view.extent(extentToPoint);\n            view.zoom(map.zoom());\n          },\n          _resize: function () {\n            this._render();\n          },\n          _panEnd: function (e) {\n            Layer.fn._panEnd.call(this, e);\n\n            this._render();\n          },\n          _render: function () {\n            this._updateView();\n\n            this._view.render();\n          }\n        });\n        var TileView = Class.extend({\n          init: function (element, options) {\n            this.element = element;\n\n            this._initOptions(options);\n\n            this.pool = new TilePool();\n          },\n          options: {\n            tileSize: 256,\n            subdomains: [\"a\", \"b\", \"c\"],\n            urlTemplate: \"\"\n          },\n          center: function (center) {\n            this._center = center;\n          },\n          extent: function (extent) {\n            this._extent = extent;\n          },\n          viewOrigin: function (origin) {\n            this._viewOrigin = origin;\n          },\n          zoom: function (zoom) {\n            this._zoom = zoom;\n          },\n          pointToTileIndex: function (point) {\n            return new Point(math.floor(point.x / this.options.tileSize), math.floor(point.y / this.options.tileSize));\n          },\n          tileCount: function () {\n            var size = this.size(),\n                firstTileIndex = this.pointToTileIndex(this._extent.nw),\n                nw = this._extent.nw,\n                point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);\n            return {\n              x: math.ceil((math.abs(point.x) + size.width) / this.options.tileSize),\n              y: math.ceil((math.abs(point.y) + size.height) / this.options.tileSize)\n            };\n          },\n          size: function () {\n            var nw = this._extent.nw,\n                se = this._extent.se,\n                diff = se.clone().translate(-nw.x, -nw.y);\n            return {\n              width: diff.x,\n              height: diff.y\n            };\n          },\n          indexToPoint: function (index) {\n            var x = index.x,\n                y = index.y;\n            return new Point(x * this.options.tileSize, y * this.options.tileSize);\n          },\n          subdomainText: function () {\n            var subdomains = this.options.subdomains;\n            return subdomains[this.subdomainIndex++ % subdomains.length];\n          },\n          destroy: function () {\n            this.element.empty();\n            this.pool.empty();\n          },\n          reset: function (tileTitle) {\n            this._tileTitle = tileTitle;\n            this.pool.reset();\n            this.subdomainIndex = 0;\n            this.render();\n          },\n          render: function () {\n            var size = this.tileCount(),\n                firstTileIndex = this.pointToTileIndex(this._extent.nw),\n                tile,\n                x,\n                y;\n\n            for (x = 0; x < size.x; x++) {\n              for (y = 0; y < size.y; y++) {\n                tile = this.createTile({\n                  x: firstTileIndex.x + x,\n                  y: firstTileIndex.y + y\n                });\n\n                if (!tile.visible) {\n                  tile.show();\n                }\n              }\n            }\n          },\n          createTile: function (currentIndex) {\n            var options = this.tileOptions(currentIndex);\n            var tile = this.pool.get(this._center, options);\n\n            if (tile.element.parent().length === 0) {\n              this.element.append(tile.element);\n            }\n\n            return tile;\n          },\n          tileOptions: function (currentIndex) {\n            var index = this.wrapIndex(currentIndex),\n                point = this.indexToPoint(currentIndex),\n                origin = this._viewOrigin,\n                offset = point.clone().translate(-origin.x, -origin.y);\n            return {\n              index: index,\n              currentIndex: currentIndex,\n              point: point,\n              offset: roundPoint(offset),\n              zoom: this._zoom,\n              size: this.options.tileSize,\n              subdomain: this.subdomainText(),\n              urlTemplate: this.options.urlTemplate,\n              errorUrlTemplate: this.options.errorUrlTemplate,\n              tileTitle: this._tileTitle\n            };\n          },\n          wrapIndex: function (index) {\n            var boundary = math.pow(2, this._zoom);\n            return {\n              x: this.wrapValue(index.x, boundary),\n              y: limit(index.y, 0, boundary - 1)\n            };\n          },\n          wrapValue: function (value, boundary) {\n            var remainder = math.abs(value) % boundary;\n\n            if (value >= 0) {\n              value = remainder;\n            } else {\n              value = boundary - (remainder === 0 ? boundary : remainder);\n            }\n\n            return value;\n          }\n        });\n        var ImageTile = Class.extend({\n          init: function (id, options) {\n            this.id = id;\n            this.visible = true;\n\n            this._initOptions(options);\n\n            this.createElement();\n            this.show();\n          },\n          options: {\n            urlTemplate: \"\",\n            errorUrlTemplate: \"\"\n          },\n          createElement: function () {\n            this.element = $(\"<img style='position: absolute; display: block;' alt='\" + this.options.tileTitle + \"' />\").css({\n              width: this.options.size,\n              height: this.options.size\n            }).on(\"error\", function (e) {\n              if (this.errorUrl()) {\n                e.target.setAttribute(\"src\", this.errorUrl());\n              } else {\n                e.target.removeAttribute(\"src\");\n              }\n            }.bind(this));\n          },\n          show: function () {\n            var element = this.element[0];\n            element.style.top = renderSize(this.options.offset.y);\n            element.style.left = renderSize(this.options.offset.x);\n            var url = this.url();\n\n            if (url) {\n              element.setAttribute(\"src\", url);\n            }\n\n            element.style.visibility = \"visible\";\n            this.visible = true;\n          },\n          hide: function () {\n            this.element[0].style.visibility = \"hidden\";\n            this.visible = false;\n          },\n          url: function () {\n            var urlResult = template(this.options.urlTemplate);\n            return urlResult(this.urlOptions());\n          },\n          errorUrl: function () {\n            var urlResult = template(this.options.errorUrlTemplate);\n            return urlResult(this.urlOptions());\n          },\n          urlOptions: function () {\n            var options = this.options;\n            return {\n              zoom: options.zoom,\n              subdomain: options.subdomain,\n              z: options.zoom,\n              x: options.index.x,\n              y: options.index.y,\n              s: options.subdomain,\n              quadkey: options.quadkey,\n              q: options.quadkey,\n              culture: options.culture,\n              c: options.culture\n            };\n          },\n          destroy: function () {\n            if (this.element) {\n              this.element.remove();\n              this.element = null;\n            }\n          }\n        });\n        var TilePool = Class.extend({\n          init: function () {\n            this._items = [];\n          },\n          options: {\n            maxSize: 100\n          },\n          get: function (center, options) {\n            if (this._items.length >= this.options.maxSize) {\n              this._remove(center);\n            }\n\n            return this._create(options);\n          },\n          empty: function () {\n            var items = this._items;\n\n            for (var i = 0; i < items.length; i++) {\n              items[i].destroy();\n            }\n\n            this._items = [];\n          },\n          reset: function () {\n            var items = this._items;\n\n            for (var i = 0; i < items.length; i++) {\n              items[i].hide();\n            }\n          },\n          _create: function (options) {\n            var items = this._items;\n            var tile; // Build an unique token for the image\n            // This normally would be the URL, but we don't care about subdomains\n\n            var id = util.hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);\n\n            for (var i = 0; i < items.length; i++) {\n              if (items[i].id === id) {\n                tile = items[i];\n                break;\n              }\n            }\n\n            if (tile) {\n              tile.show();\n            } else {\n              tile = new ImageTile(id, options);\n\n              this._items.push(tile);\n            }\n\n            return tile;\n          },\n          _remove: function (center) {\n            var items = this._items;\n            var maxDist = -1;\n            var index = -1;\n\n            for (var i = 0; i < items.length; i++) {\n              var dist = items[i].options.point.distanceTo(center);\n\n              if (dist > maxDist && !items[i].visible) {\n                index = i;\n                maxDist = dist;\n              }\n            }\n\n            if (index !== -1) {\n              items[index].destroy();\n              items.splice(index, 1);\n            }\n          }\n        }); // Methods ================================================================\n\n        function roundPoint(point) {\n          return new Point(round(point.x), round(point.y));\n        } // Exports ================================================================\n\n\n        deepExtend(dataviz, {\n          map: {\n            layers: {\n              tile: TileLayer,\n              TileLayer: TileLayer,\n              ImageTile: ImageTile,\n              TilePool: TilePool,\n              TileView: TileView\n            }\n          }\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}