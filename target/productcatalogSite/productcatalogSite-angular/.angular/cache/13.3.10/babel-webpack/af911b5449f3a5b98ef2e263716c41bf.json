{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport { Class, defined, addClass, setDefaultOptions, deepExtend, getSpacing, isObject, defaultErrorHandler } from '../common';\nimport { Box, TextBox } from '../core';\nimport { Encodings } from './encodings/main';\nimport { surfaceSize } from './surface-size';\nconst DEFAULT_BARCODE_WIDTH = 300;\nconst DEFAULT_BARCODE_HEIGHT = 100;\n\nclass Barcode extends Class {\n  constructor(element, options, errorHandler = defaultErrorHandler) {\n    super();\n    this.options = deepExtend({}, this.options, options);\n    this.element = element;\n    this.onError = errorHandler;\n\n    this._initElement();\n\n    this._initSurface();\n\n    this._setOptions(options);\n\n    if (options && defined(options.value)) {\n      this.redraw();\n    }\n  }\n\n  destroy() {\n    this._destroySurface();\n  }\n\n  _initElement() {\n    addClass(this.element, \"k-barcode\");\n  }\n\n  _initSurface() {\n    const {\n      options,\n      surface\n    } = this;\n\n    if (!surface || surface.options.type !== options.renderAs) {\n      this._destroySurface();\n\n      this._initSurfaceElement();\n\n      this.surface = this._createSurface();\n    }\n  }\n\n  _createSurface() {\n    return draw.Surface.create(this.surfaceElement, {\n      type: this.options.renderAs\n    });\n  }\n\n  _destroySurface() {\n    if (this.surface) {\n      this.surface.destroy();\n      this.surface = null;\n\n      this._destroySurfaceElement();\n    }\n  }\n\n  _initSurfaceElement() {\n    if (!this.surfaceElement) {\n      this.surfaceElement = document.createElement('div');\n      this.surfaceElement.style.position = 'relative';\n      this.element.appendChild(this.surfaceElement);\n    }\n  }\n\n  _destroySurfaceElement() {\n    if (this.surfaceElement && this.surfaceElement.parentNode) {\n      this.surfaceElement.parentNode.removeChild(this.surfaceElement);\n      this.surfaceElement = null;\n    }\n  }\n\n  setOptions(options) {\n    this._setOptions(options);\n\n    this._initSurface();\n\n    this.redraw();\n  }\n\n  redraw() {\n    let size = this._getSize();\n\n    this.surface.clear();\n    this.surface.setSize({\n      width: size.width,\n      height: size.height\n    });\n    this.createVisual();\n    this.surface.draw(this.visual);\n  }\n\n  getSize() {\n    return {\n      width: this.element.offsetWidth,\n      height: this.element.offsetHeight\n    };\n  }\n\n  _resize() {\n    this.redraw();\n  }\n\n  createVisual() {\n    this.visual = this._render();\n  }\n\n  _render() {\n    const options = this.options;\n    const value = options.value;\n    const textOptions = options.text;\n    const textMargin = getSpacing(textOptions.margin);\n\n    const size = this._getSize();\n\n    const border = options.border || {};\n    const encoding = this.encoding;\n    const contentBox = new Box(0, 0, size.width, size.height).unpad(border.width).unpad(options.padding);\n    let barHeight = contentBox.height();\n    let encodedValue;\n    let textToDisplay;\n    let textHeight;\n    const visual = new draw.Group();\n    this.contentBox = contentBox;\n    visual.append(this._getBackground(size));\n\n    if (textOptions.visible) {\n      textHeight = draw.util.measureText(value, {\n        font: textOptions.font\n      }).height;\n      barHeight -= textHeight + textMargin.top + textMargin.bottom;\n    }\n\n    try {\n      encodedValue = encoding.encode(value, contentBox.width(), barHeight);\n    } catch (error) {\n      this.onError(error);\n      return visual;\n    }\n\n    if (textOptions.visible) {\n      textToDisplay = value;\n\n      if (options.checksum && defined(encoding.checksum)) {\n        textToDisplay += \" \" + encoding.checksum;\n      }\n\n      visual.append(this._getText(textToDisplay));\n    }\n\n    this.barHeight = barHeight;\n    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);\n    visual.append(this._bandsGroup);\n    return visual;\n  }\n\n  exportVisual() {\n    return this._render();\n  }\n\n  _getSize() {\n    const element = this.element;\n    const elementSize = surfaceSize(element, this.options.renderAs);\n    const size = new geom.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);\n\n    if (elementSize.width > 0) {\n      size.width = elementSize.width;\n    }\n\n    if (elementSize.height > 0) {\n      size.height = elementSize.height;\n    }\n\n    if (this.options.width) {\n      size.width = this.options.width;\n    }\n\n    if (this.options.height) {\n      size.height = this.options.height;\n    }\n\n    return size;\n  }\n\n  value(value) {\n    if (!defined(value)) {\n      return this.options.value;\n    }\n\n    this.options.value = String(value);\n    this.redraw();\n  }\n\n  _getBands(pattern, baseUnit) {\n    const contentBox = this.contentBox;\n    let offsetX = contentBox.x1;\n    let stepX;\n    let patternItem;\n    const group = new draw.Group();\n\n    for (let i = 0; i < pattern.length; i++) {\n      patternItem = isObject(pattern[i]) ? pattern[i] : {\n        width: pattern[i],\n        y1: 0,\n        y2: this.barHeight\n      };\n      stepX = patternItem.width * baseUnit;\n\n      if (i % 2) {\n        const rect = geom.Rect.fromPoints(new geom.Point(offsetX, patternItem.y1 + contentBox.y1), new geom.Point(offsetX + stepX, patternItem.y2 + contentBox.y1));\n        const path = draw.Path.fromRect(rect, {\n          fill: {\n            color: this.options.color\n          },\n          stroke: null\n        });\n        group.append(path);\n      }\n\n      offsetX += stepX;\n    }\n\n    return group;\n  }\n\n  _getBackground(size) {\n    const options = this.options;\n    const border = options.border || {};\n    const box = new Box(0, 0, size.width, size.height).unpad(border.width / 2);\n    const path = draw.Path.fromRect(box.toRect(), {\n      fill: {\n        color: options.background\n      },\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      }\n    });\n    return path;\n  }\n\n  _getText(value) {\n    const textOptions = this.options.text;\n    const text = this._textbox = new TextBox(value, {\n      font: textOptions.font,\n      color: textOptions.color,\n      align: \"center\",\n      vAlign: \"bottom\",\n      margin: textOptions.margin\n    });\n    text.reflow(this.contentBox);\n    text.renderVisual();\n    return text.visual;\n  }\n\n  _setOptions(options) {\n    this.type = (options.type || this.options.type).toLowerCase();\n\n    if (this.type === \"upca\") {\n      this.type = \"ean13\";\n      options.value = '0' + options.value;\n    }\n\n    if (this.type === \"upce\") {\n      this.type = \"ean8\";\n      options.value = '0' + options.value;\n    }\n\n    if (!Encodings[this.type]) {\n      throw new Error(`Encoding '${this.type}' is not supported.`);\n    }\n\n    this.encoding = new Encodings[this.type]();\n    this.options = deepExtend({}, this.options, options);\n  }\n\n}\n\nsetDefaultOptions(Barcode, {\n  name: \"Barcode\",\n  renderAs: \"svg\",\n  value: \"\",\n  type: \"code39\",\n  checksum: false,\n  width: 0,\n  height: 0,\n  color: \"black\",\n  background: \"white\",\n  text: {\n    visible: true,\n    font: \"16px Consolas, Monaco, Sans Mono, monospace, sans-serif\",\n    color: \"black\",\n    margin: {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    }\n  },\n  border: {\n    width: 0,\n    dashType: \"solid\",\n    color: \"black\"\n  },\n  padding: {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }\n});\nexport default Barcode;","map":null,"metadata":{},"sourceType":"module"}