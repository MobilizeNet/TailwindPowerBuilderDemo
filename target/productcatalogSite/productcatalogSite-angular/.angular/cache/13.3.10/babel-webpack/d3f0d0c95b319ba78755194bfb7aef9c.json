{"ast":null,"code":"import NavigatorHint from './navigator-hint';\nimport { Selection, filterSeriesByType } from '../chart';\nimport { DRAG, DRAG_END, EQUALLY_SPACED_SERIES, ZOOM, ZOOM_END } from '../chart/constants';\nimport { DateCategoryAxis } from '../core';\nimport { addDuration, parseDate, toDate, toTime } from '../date-utils';\nimport { Class, deepExtend, defined, getTemplate, InstanceObserver, last, limitValue, valueOrDefault } from '../common';\nimport { NAVIGATOR_AXIS, NAVIGATOR_PANE, DEFAULT_PANE } from './constants';\nconst ZOOM_ACCELERATION = 3;\n\nclass Navigator extends Class {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n    const options = this.options = deepExtend({}, this.options, chart.options.navigator);\n    const select = options.select;\n\n    if (select) {\n      select.from = this.parseDate(select.from);\n      select.to = this.parseDate(select.to);\n    }\n\n    if (!defined(options.hint.visible)) {\n      options.hint.visible = options.visible;\n    }\n\n    this.chartObserver = new InstanceObserver(this, {\n      [DRAG]: '_drag',\n      [DRAG_END]: '_dragEnd',\n      [ZOOM]: '_zoom',\n      [ZOOM_END]: '_zoomEnd'\n    });\n    chart.addObserver(this.chartObserver);\n  }\n\n  parseDate(value) {\n    return parseDate(this.chart.chartService.intl, value);\n  }\n\n  clean() {\n    if (this.selection) {\n      this.selection.destroy();\n      this.selection = null;\n    }\n\n    if (this.hint) {\n      this.hint.destroy();\n      this.hint = null;\n    }\n  }\n\n  destroy() {\n    if (this.chart) {\n      this.chart.removeObserver(this.chartObserver);\n      delete this.chart;\n    }\n\n    this.clean();\n  }\n\n  redraw() {\n    this._redrawSelf();\n\n    this.initSelection();\n  }\n\n  initSelection() {\n    const {\n      chart,\n      options\n    } = this;\n    const axis = this.mainAxis();\n    const {\n      min,\n      max\n    } = axis.roundedRange();\n    const {\n      from,\n      to,\n      mousewheel\n    } = options.select;\n    const axisClone = clone(axis);\n\n    if (axis.categoriesCount() === 0) {\n      return;\n    }\n\n    this.clean(); // \"Freeze\" the selection axis position until the next redraw\n\n    axisClone.box = axis.box;\n    this.selection = new Selection(chart, axisClone, {\n      min: min,\n      max: max,\n      from: from || min,\n      to: to || max,\n      mousewheel: valueOrDefault(mousewheel, {\n        zoom: \"left\"\n      }),\n      visible: options.visible\n    }, new InstanceObserver(this, {\n      selectStart: '_selectStart',\n      select: '_select',\n      selectEnd: '_selectEnd'\n    }));\n\n    if (options.hint.visible) {\n      this.hint = new NavigatorHint(chart.element, chart.chartService, {\n        min: min,\n        max: max,\n        template: getTemplate(options.hint),\n        format: options.hint.format\n      });\n    }\n  }\n\n  setRange() {\n    const plotArea = this.chart._createPlotArea(true);\n\n    const axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];\n    const {\n      min,\n      max\n    } = axis.roundedRange();\n    const select = this.options.select || {};\n    let from = select.from || min;\n\n    if (from < min) {\n      from = min;\n    }\n\n    let to = select.to || max;\n\n    if (to > max) {\n      to = max;\n    }\n\n    this.options.select = deepExtend({}, select, {\n      from: from,\n      to: to\n    });\n    this.filterAxes();\n  }\n\n  _redrawSelf(silent) {\n    const plotArea = this.chart._plotArea;\n\n    if (plotArea) {\n      plotArea.redraw(last(plotArea.panes), silent);\n    }\n  }\n\n  redrawSlaves() {\n    const chart = this.chart;\n    const plotArea = chart._plotArea;\n    const slavePanes = plotArea.panes.filter(pane => pane.options.name !== NAVIGATOR_PANE); // Update the original series and categoryAxis before partial refresh.\n\n    plotArea.srcSeries = chart.options.series;\n    plotArea.options.categoryAxis = chart.options.categoryAxis;\n    plotArea.clearSeriesPointsCache();\n    plotArea.redraw(slavePanes);\n  }\n\n  _drag(e) {\n    const {\n      chart,\n      selection\n    } = this;\n\n    const coords = chart._eventCoordinates(e.originalEvent);\n\n    const navigatorAxis = this.mainAxis();\n    const naviRange = navigatorAxis.roundedRange();\n    const inNavigator = navigatorAxis.pane.box.containsPoint(coords);\n    const axis = chart._plotArea.categoryAxis;\n    const range = e.axisRanges[axis.options.name];\n    const select = this.options.select;\n    let duration;\n\n    if (!range || inNavigator || !selection) {\n      return;\n    }\n\n    if (select.from && select.to) {\n      duration = toTime(select.to) - toTime(select.from);\n    } else {\n      duration = toTime(selection.options.to) - toTime(selection.options.from);\n    }\n\n    const from = toDate(limitValue(toTime(range.min), naviRange.min, toTime(naviRange.max) - duration));\n    const to = toDate(limitValue(toTime(from) + duration, toTime(naviRange.min) + duration, naviRange.max));\n    this.options.select = {\n      from: from,\n      to: to\n    };\n\n    if (this.options.liveDrag) {\n      this.filterAxes();\n      this.redrawSlaves();\n    }\n\n    selection.set(from, to);\n    this.showHint(from, to);\n  }\n\n  _dragEnd() {\n    this.filterAxes();\n    this.filter();\n    this.redrawSlaves();\n\n    if (this.hint) {\n      this.hint.hide();\n    }\n  }\n\n  readSelection() {\n    const {\n      selection: {\n        options: {\n          from,\n          to\n        }\n      },\n      options: {\n        select\n      }\n    } = this;\n    select.from = from;\n    select.to = to;\n  }\n\n  filterAxes() {\n    const {\n      options: {\n        select = {}\n      },\n      chart\n    } = this;\n    const allAxes = chart.options.categoryAxis;\n    const {\n      from,\n      to\n    } = select;\n\n    for (let idx = 0; idx < allAxes.length; idx++) {\n      const axis = allAxes[idx];\n\n      if (axis.pane !== NAVIGATOR_PANE) {\n        axis.min = from;\n        axis.max = to;\n      }\n    }\n  }\n\n  filter() {\n    const {\n      chart,\n      options: {\n        select\n      }\n    } = this;\n\n    if (!chart.requiresHandlers([\"navigatorFilter\"])) {\n      return;\n    }\n\n    const mainAxis = this.mainAxis();\n    const args = {\n      from: select.from,\n      to: select.to\n    };\n\n    if (mainAxis.options.type !== 'category') {\n      const axisOptions = new DateCategoryAxis(deepExtend({\n        baseUnit: \"fit\"\n      }, chart.options.categoryAxis[0], {\n        categories: [select.from, select.to]\n      }), chart.chartService).options;\n      args.from = addDuration(axisOptions.min, -axisOptions.baseUnitStep, axisOptions.baseUnit);\n      args.to = addDuration(axisOptions.max, axisOptions.baseUnitStep, axisOptions.baseUnit);\n    }\n\n    this.chart.trigger(\"navigatorFilter\", args);\n  }\n\n  _zoom(e) {\n    const {\n      chart: {\n        _plotArea: {\n          categoryAxis: axis\n        }\n      },\n      selection,\n      options: {\n        select,\n        liveDrag\n      }\n    } = this;\n    const mainAxis = this.mainAxis();\n    let delta = e.delta;\n\n    if (!selection) {\n      return;\n    }\n\n    const fromIx = mainAxis.categoryIndex(selection.options.from);\n    const toIx = mainAxis.categoryIndex(selection.options.to);\n\n    const coords = this.chart._eventCoordinates(e.originalEvent);\n\n    e.originalEvent.preventDefault();\n\n    if (Math.abs(delta) > 1) {\n      delta *= ZOOM_ACCELERATION;\n    }\n\n    if (toIx - fromIx > 1) {\n      selection.zoom(delta, coords);\n      this.readSelection();\n    } else {\n      axis.options.min = select.from;\n      select.from = axis.scaleRange(-e.delta * this.chart._mousewheelZoomRate(), coords).min;\n    }\n\n    if (liveDrag) {\n      this.filterAxes();\n      this.redrawSlaves();\n    }\n\n    selection.set(select.from, select.to);\n    this.showHint(this.options.select.from, this.options.select.to);\n  }\n\n  _zoomEnd(e) {\n    this._dragEnd(e);\n  }\n\n  showHint(from, to) {\n    const plotArea = this.chart._plotArea;\n\n    if (this.hint) {\n      this.hint.show(from, to, plotArea.backgroundBox());\n    }\n  }\n\n  _selectStart(e) {\n    return this.chart._selectStart(e);\n  }\n\n  _select(e) {\n    this.showHint(e.from, e.to);\n    return this.chart._select(e);\n  }\n\n  _selectEnd(e) {\n    if (this.hint) {\n      this.hint.hide();\n    }\n\n    this.readSelection();\n    this.filterAxes();\n    this.filter();\n    this.redrawSlaves();\n    return this.chart._selectEnd(e);\n  }\n\n  mainAxis() {\n    const plotArea = this.chart._plotArea;\n\n    if (plotArea) {\n      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];\n    }\n  }\n\n  select(from, to) {\n    const select = this.options.select;\n\n    if (from && to) {\n      select.from = this.parseDate(from);\n      select.to = this.parseDate(to);\n      this.filterAxes();\n      this.filter();\n      this.redrawSlaves();\n      this.selection.set(from, to);\n    }\n\n    return {\n      from: select.from,\n      to: select.to\n    };\n  }\n\n  static setup(options = {}, themeOptions = {}) {\n    if (options.__navi) {\n      return;\n    }\n\n    options.__navi = true;\n    const naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);\n    const panes = options.panes = [].concat(options.panes);\n    const paneOptions = deepExtend({}, naviOptions.pane, {\n      name: NAVIGATOR_PANE\n    });\n\n    if (!naviOptions.visible) {\n      paneOptions.visible = false;\n      paneOptions.height = 0.1;\n    }\n\n    if (options.navigator.position !== 'top') {\n      panes.push(paneOptions);\n    } else {\n      panes.unshift(paneOptions);\n    }\n\n    panes.forEach(pane => pane.name = pane.name || DEFAULT_PANE);\n    Navigator.attachAxes(options, naviOptions);\n    Navigator.attachSeries(options, naviOptions, themeOptions);\n  }\n\n  static attachAxes(options, naviOptions) {\n    const series = naviOptions.series || [];\n    const categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);\n    const valueAxes = options.valueAxis = [].concat(options.valueAxis);\n    const allAxes = categoryAxes.concat(valueAxes);\n    allAxes.forEach(axis => axis.pane = axis.pane || DEFAULT_PANE);\n    const equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);\n    const justifyAxis = equallySpacedSeries.length === 0;\n    const base = deepExtend({\n      type: \"date\",\n      pane: NAVIGATOR_PANE,\n      roundToBaseUnit: !justifyAxis,\n      justified: justifyAxis,\n      _collapse: false,\n      majorTicks: {\n        visible: true\n      },\n      tooltip: {\n        visible: false\n      },\n      labels: {\n        step: 1\n      },\n      autoBind: naviOptions.autoBindElements,\n      autoBaseUnitSteps: {\n        minutes: [1],\n        hours: [1, 2],\n        days: [1, 2],\n        weeks: [],\n        months: [1],\n        years: [1]\n      }\n    });\n    const user = naviOptions.categoryAxis;\n    categoryAxes.push(deepExtend({}, base, {\n      maxDateGroups: 200\n    }, user, {\n      name: NAVIGATOR_AXIS,\n      title: null,\n      baseUnit: \"fit\",\n      baseUnitStep: \"auto\",\n      labels: {\n        visible: false\n      },\n      majorTicks: {\n        visible: false\n      }\n    }), deepExtend({}, base, user, {\n      name: NAVIGATOR_AXIS + \"_labels\",\n      maxDateGroups: 20,\n      baseUnitStep: \"auto\",\n      labels: {\n        position: \"\"\n      },\n      plotBands: [],\n      autoBaseUnitSteps: {\n        minutes: []\n      },\n      _overlap: true\n    }), deepExtend({}, base, user, {\n      name: NAVIGATOR_AXIS + \"_ticks\",\n      maxDateGroups: 200,\n      majorTicks: {\n        width: 0.5\n      },\n      plotBands: [],\n      title: null,\n      labels: {\n        visible: false,\n        mirror: true\n      },\n      _overlap: true\n    }));\n    valueAxes.push(deepExtend({\n      name: NAVIGATOR_AXIS,\n      pane: NAVIGATOR_PANE,\n      majorGridLines: {\n        visible: false\n      },\n      visible: false\n    }, naviOptions.valueAxis));\n  }\n\n  static attachSeries(options, naviOptions, themeOptions) {\n    const series = options.series = options.series || [];\n    const navigatorSeries = [].concat(naviOptions.series || []);\n    const seriesColors = themeOptions.seriesColors;\n    const defaults = naviOptions.seriesDefaults;\n\n    for (let idx = 0; idx < navigatorSeries.length; idx++) {\n      series.push(deepExtend({\n        color: seriesColors[idx % seriesColors.length],\n        categoryField: naviOptions.dateField,\n        visibleInLegend: false,\n        tooltip: {\n          visible: false\n        }\n      }, defaults, navigatorSeries[idx], {\n        axis: NAVIGATOR_AXIS,\n        categoryAxis: NAVIGATOR_AXIS,\n        autoBind: naviOptions.autoBindElements\n      }));\n    }\n  }\n\n}\n\nfunction ClonedObject() {}\n\nfunction clone(obj) {\n  ClonedObject.prototype = obj;\n  return new ClonedObject();\n}\n\nexport default Navigator;","map":null,"metadata":{},"sourceType":"module"}