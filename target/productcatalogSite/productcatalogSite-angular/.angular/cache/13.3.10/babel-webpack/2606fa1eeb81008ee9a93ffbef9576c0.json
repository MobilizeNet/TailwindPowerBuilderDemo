{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(888);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  888:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(889), __webpack_require__(890), __webpack_require__(891), __webpack_require__(892), __webpack_require__(893), __webpack_require__(894)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        var NS = \".kendoChart\";\n        var kendo = window.kendo;\n        var Class = kendo.Class;\n        var outerWidth = kendo._outerWidth;\n        var outerHeight = kendo._outerHeight;\n        var dataviz = kendo.dataviz;\n        var constants = dataviz.constants;\n        var KendoChart = dataviz.Chart;\n        var SeriesBinder = dataviz.SeriesBinder;\n        var Widget = kendo.ui.Widget;\n        var DataSource = kendo.data.DataSource;\n        var deepExtend = kendo.deepExtend;\n        var defined = dataviz.defined;\n        var getField = dataviz.getField;\n        var InstanceObserver = dataviz.InstanceObserver;\n        var inArray = dataviz.inArray;\n        var services = dataviz.services;\n        var isArray = Array.isArray;\n        var extend = $.extend;\n        var template = kendo.template;\n        var MOUSELEAVE_NS = \"mouseleave\" + NS;\n        var AXIS_LABEL_CLICK = constants.AXIS_LABEL_CLICK;\n        var LEGEND_ITEM_CLICK = constants.LEGEND_ITEM_CLICK;\n        var LEGEND_ITEM_HOVER = constants.LEGEND_ITEM_HOVER;\n        var LEGEND_ITEM_LEAVE = constants.LEGEND_ITEM_LEAVE;\n        var SERIES_CLICK = constants.SERIES_CLICK;\n        var SERIES_HOVER = constants.SERIES_HOVER;\n        var SERIES_OVER = constants.SERIES_OVER;\n        var SERIES_LEAVE = constants.SERIES_LEAVE;\n        var PANE_RENDER = constants.PANE_RENDER;\n        var PLOT_AREA_CLICK = constants.PLOT_AREA_CLICK;\n        var PLOT_AREA_HOVER = constants.PLOT_AREA_HOVER;\n        var PLOT_AREA_LEAVE = constants.PLOT_AREA_LEAVE;\n        var DRAG = constants.DRAG;\n        var DRAG_END = constants.DRAG_END;\n        var DRAG_START = constants.DRAG_START;\n        var ZOOM_START = constants.ZOOM_START;\n        var ZOOM = constants.ZOOM;\n        var ZOOM_END = constants.ZOOM_END;\n        var SELECT_START = constants.SELECT_START;\n        var SELECT = constants.SELECT;\n        var SELECT_END = constants.SELECT_END;\n        var RENDER = constants.RENDER;\n        var NOTE_CLICK = constants.NOTE_CLICK;\n        var NOTE_HOVER = constants.NOTE_HOVER;\n        var NOTE_LEAVE = constants.NOTE_LEAVE;\n        var DOCUMENT_ELEMENT = $(document.documentElement);\n        var CHANGE = \"change\";\n        var DATABOUND = \"dataBound\";\n        var LEAVE = \"leave\";\n        var MOUSEDOWN = \"down\";\n        var VALUE = constants.VALUE;\n        var PIE = constants.PIE;\n        var DONUT = constants.DONUT;\n        var FUNNEL = constants.FUNNEL;\n        var Observable = kendo.Observable;\n        var TOOLTIP_ANIMATION_DURATION = 150;\n        var TOOLTIP_SHOW_DELAY = 100;\n        var TOOLTIP_INVERSE = \"k-chart-tooltip-inverse\";\n        var SHARED_TOOLTIP_CLASS = \"k-chart-shared-tooltip\";\n        var RTL = \"rtl\";\n        services.DomEventsBuilder.register({\n          create: function (element, events) {\n            return new kendo.UserEvents(element, deepExtend({\n              global: true,\n              multiTouch: true,\n              fastTap: true\n            }, events));\n          }\n        });\n        var ChartInstanceObserver = InstanceObserver.extend({\n          handlerMap: {\n            showTooltip: '_showTooltip',\n            hideTooltip: '_hideTooltip',\n            legendItemClick: '_onLegendItemClick',\n            render: '_onRender',\n            init: '_onInit'\n          }\n        });\n        var Chart = Widget.extend({\n          init: function (element, userOptions) {\n            var dataSource;\n            kendo.destroy(element);\n            Widget.fn.init.call(this, element);\n\n            if (userOptions) {\n              dataSource = userOptions.dataSource;\n              delete userOptions.dataSource;\n            }\n\n            this.options = deepExtend({}, this.options, userOptions);\n            this.wrapper = this.element;\n\n            this._attachEvents();\n\n            if (userOptions) {\n              userOptions.dataSource = dataSource;\n            }\n\n            this._seriesVisibility = new SeriesVisibilityState();\n            this.bind(this.events, this.options);\n\n            this._initDataSource(userOptions);\n\n            kendo.notify(this, dataviz.ui);\n          },\n          events: [DATABOUND, SERIES_CLICK, SERIES_HOVER, SERIES_OVER, SERIES_LEAVE, AXIS_LABEL_CLICK, LEGEND_ITEM_CLICK, LEGEND_ITEM_HOVER, LEGEND_ITEM_LEAVE, PANE_RENDER, PLOT_AREA_CLICK, PLOT_AREA_HOVER, PLOT_AREA_LEAVE, DRAG_START, DRAG, DRAG_END, ZOOM_START, ZOOM, ZOOM_END, SELECT_START, SELECT, SELECT_END, NOTE_CLICK, NOTE_HOVER, NOTE_LEAVE, RENDER],\n          options: {\n            name: \"Chart\",\n            renderAs: \"\",\n            theme: \"default\",\n            axisDefaults: {},\n            chartArea: {},\n            legend: {},\n            categoryAxis: {},\n            autoBind: true,\n            seriesDefaults: {},\n            series: [],\n            seriesColors: null,\n            tooltip: {},\n            transitions: true,\n            valueAxis: {},\n            plotArea: {},\n            title: {},\n            xAxis: {},\n            yAxis: {},\n            panes: [{}],\n            pannable: false,\n            zoomable: false\n          },\n          items: function () {\n            return $();\n          },\n          refresh: function () {\n            var chart = this;\n            var instance = chart._instance;\n            instance.applyDefaults(chart.options);\n            instance.applySeriesColors();\n\n            chart._bindSeries();\n\n            chart._bindCategories();\n\n            chart.trigger(DATABOUND);\n\n            chart._redraw();\n          },\n          getSize: function () {\n            return kendo.dimensions(this.element);\n          },\n          redraw: function (paneName) {\n            this._size = null;\n\n            this._instance.redraw(paneName);\n          },\n          setOptions: function (options) {\n            var chart = this,\n                dataSource = options.dataSource;\n            delete options.dataSource;\n\n            Widget.fn._setEvents.call(chart, options);\n\n            this._instance.applyOptions(options, this._getThemeOptions(options));\n\n            this.options = this._instance.options;\n\n            this._tooltip.setOptions(this.options.tooltip);\n\n            this._seriesVisibility.setOptions(this.options);\n\n            this._sourceSeries = null;\n\n            if (dataSource) {\n              chart.setDataSource(dataSource);\n            }\n\n            if (chart._hasDataSource) {\n              chart._onDataChanged();\n            } else {\n              chart._bindCategories();\n\n              chart.redraw();\n            }\n\n            chart._instance.updateMouseMoveHandler();\n          },\n          setDataSource: function (dataSource) {\n            var chart = this;\n            chart.dataSource.unbind(CHANGE, chart._dataChangeHandler);\n            chart.dataSource = dataSource = DataSource.create(dataSource);\n            chart._hasDataSource = true;\n            chart._hasData = false;\n            dataSource.bind(CHANGE, chart._dataChangeHandler);\n\n            if (chart.options.autoBind) {\n              dataSource.fetch();\n            }\n          },\n          destroy: function () {\n            var chart = this,\n                dataSource = chart.dataSource;\n            chart.element.off(NS);\n\n            if (dataSource) {\n              dataSource.unbind(CHANGE, chart._dataChangeHandler);\n            }\n\n            if (chart._instance) {\n              chart._instance.destroy();\n\n              delete this._instance;\n            }\n\n            if (this._tooltip) {\n              this._tooltip.destroy();\n\n              delete this._tooltip;\n            }\n\n            this._destroyCrosshairTooltips();\n\n            Widget.fn.destroy.call(chart);\n          },\n          findPaneByName: function (name) {\n            var panes = this._plotArea.panes;\n\n            for (var idx = 0; idx < panes.length; idx++) {\n              if (panes[idx].options.name === name) {\n                return new ChartPane(this, panes[idx]);\n              }\n            }\n          },\n          findPaneByIndex: function (idx) {\n            var panes = this._plotArea.panes;\n\n            if (panes[idx]) {\n              return new ChartPane(this, panes[idx]);\n            }\n          },\n          findSeries: function (callback) {\n            var plotArea = this._plotArea;\n            var series = plotArea.srcSeries || plotArea.series;\n\n            for (var idx = 0; idx < series.length; idx++) {\n              if (callback(series[idx])) {\n                return new ChartSeries(this, series[idx]);\n              }\n            }\n          },\n          findSeriesByName: function (name) {\n            return this._createSeries({\n              name: name\n            });\n          },\n          findSeriesByIndex: function (index) {\n            return this._createSeries({\n              index: index\n            });\n          },\n          exportVisual: function (options) {\n            var instance = this._instance;\n\n            if (!instance) {\n              return;\n            }\n\n            var visual; //TO DO: support for setting any options. already available in kendo-charts\n\n            if (options && (options.width || options.height)) {\n              var chartArea = instance.options.chartArea;\n              var originalChartArea = instance._originalOptions.chartArea;\n              deepExtend(chartArea, options);\n\n              var model = instance._getModel();\n\n              chartArea.width = originalChartArea.width;\n              chartArea.height = originalChartArea.height;\n              model.renderVisual();\n              triggerPaneRender(model._plotArea.panes);\n              visual = model.visual;\n            } else {\n              visual = instance.exportVisual();\n            }\n\n            return visual;\n          },\n          _createSeries: function (options) {\n            var seriesOptions = this._seriesOptions(options);\n\n            if (seriesOptions) {\n              return new ChartSeries(this, seriesOptions);\n            }\n          },\n          _seriesOptions: function (options) {\n            var plotArea = this._plotArea;\n            var series = plotArea.srcSeries || plotArea.series;\n            var seriesOptions;\n\n            if (defined(options.index)) {\n              seriesOptions = series[options.index];\n            } else if (defined(options.name)) {\n              for (var idx = 0; idx < series.length; idx++) {\n                if (series[idx].name === options.name) {\n                  seriesOptions = series[idx];\n                  break;\n                }\n              }\n            }\n\n            return seriesOptions;\n          },\n          _attachEvents: function () {\n            this.element.on(MOUSELEAVE_NS, this._mouseleave.bind(this));\n          },\n          _mouseleave: function (e) {\n            var instance = this._instance;\n            var tooltip = this._tooltip;\n            var target = e.relatedTarget;\n\n            if (!(target && $(target).closest(tooltip.element).length) && instance && !instance.handlingTap) {\n              instance.hideElements({\n                keepTooltipOpen: !tooltip.options.autoHide\n              });\n            }\n          },\n          _getThemeOptions: function (userOptions) {\n            var themeName = (userOptions || {}).theme;\n\n            if (themeName && dataviz.SASS_THEMES.indexOf(themeName.toLowerCase()) !== -1) {\n              return dataviz.autoTheme().chart;\n            }\n\n            if (defined(themeName)) {\n              var themes = dataviz.ui.themes || {};\n              var theme = themes[themeName] || themes[themeName.toLowerCase()] || {};\n              return theme.chart || {};\n            }\n          },\n          _initChart: function () {\n            this._createChart(this.options, this._getThemeOptions(this.options));\n\n            this.options = this._instance.options;\n\n            this._seriesVisibility.setOptions(this.options);\n          },\n          _createChart: function (options, themeOptions) {\n            this._instance = new KendoChart(this.element[0], options, themeOptions, {\n              observer: new ChartInstanceObserver(this),\n              sender: this,\n              rtl: this._isRtl()\n            });\n          },\n          _onInit: function (e) {\n            this._instance = e.sender;\n          },\n          _initDataSource: function (userOptions) {\n            var chart = this,\n                dataSource = (userOptions || {}).dataSource;\n            chart._dataChangeHandler = chart._onDataChanged.bind(chart);\n            chart.dataSource = DataSource.create(dataSource).bind(\"change\", chart._dataChangeHandler);\n\n            chart._bindCategories();\n\n            if (dataSource) {\n              chart._hasDataSource = true;\n            }\n\n            this._initChart();\n\n            this._initTooltip();\n\n            if (dataSource) {\n              if (chart.options.autoBind) {\n                chart.dataSource.fetch();\n              }\n            }\n          },\n          _destroyCrosshairTooltips: function () {\n            var tooltips = this._crosshairTooltips;\n\n            if (tooltips) {\n              for (var key in tooltips) {\n                tooltips[key].destroy();\n              }\n            }\n\n            this._crosshairTooltips = {};\n          },\n          _getCrosshairTooltip: function (name, index) {\n            var tooltips = this._crosshairTooltips = this._crosshairTooltips || {};\n            var key = name + index;\n            var tooltip = tooltips[key];\n\n            if (!tooltip) {\n              tooltip = tooltips[key] = new CrosshairTooltip(this.element);\n            }\n\n            return tooltip;\n          },\n          _showTooltip: function (e) {\n            if (e.crosshair) {\n              var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n\n              tooltip.show(e);\n            } else if (this._tooltip) {\n              this._tooltip.show(e);\n            }\n          },\n          _hideTooltip: function (e) {\n            if (e.crosshair) {\n              var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n\n              tooltip.hide();\n            } else if (this._tooltip) {\n              this._tooltip.hide();\n            }\n          },\n          _onRender: function (e) {\n            this._destroyCrosshairTooltips();\n\n            this._copyMembers(e.sender);\n\n            if (!this._hasDataSource || this._hasData || !this.options.autoBind) {\n              this.trigger(RENDER);\n            }\n          },\n          _copyMembers: function (instance) {\n            this.options = instance.options;\n            this._originalOptions = instance._originalOptions;\n            this.surface = instance.surface;\n            this._plotArea = instance._plotArea;\n            this._model = instance._model;\n            this._highlight = instance._highlight;\n            this._selections = instance._selections;\n            this._pannable = instance._pannable;\n            this._zoomSelection = instance._zoomSelection;\n            this._mousewheelZoom = instance._mousewheelZoom;\n          },\n          requiresHandlers: function (names) {\n            var events = this._events;\n\n            for (var idx = 0; idx < names.length; idx++) {\n              if (defined(events[names[idx]])) {\n                return true;\n              }\n            }\n          },\n          _initTooltip: function () {\n            this._tooltip = this._createTooltip();\n\n            this._tooltip.bind(LEAVE, this._tooltipleave.bind(this));\n          },\n          _onLegendItemClick: function (e) {\n            if (!this.trigger(LEGEND_ITEM_CLICK, e)) {\n              this._legendItemClick(e.seriesIndex, e.pointIndex);\n            }\n          },\n          _legendItemClick: function (seriesIndex, pointIndex) {\n            var chart = this._instance,\n                plotArea = chart._plotArea,\n                currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n\n            if (chart._hasInactiveOpacity() && chart._activeChartInstance) {\n              chart._updateSeriesOpacity(null, true);\n\n              chart._applySeriesOpacity(chart._activeChartInstance.children, null, true);\n\n              chart._activeChartInstance = null;\n            }\n\n            if ($.inArray(currentSeries.type, [PIE, DONUT, FUNNEL]) >= 0) {\n              var point = currentSeries.data[pointIndex];\n\n              if (point && defined(point.visible)) {\n                point.visible = !point.visible;\n              } else {\n                var pointVisibility = currentSeries.pointVisibility = currentSeries.pointVisibility || {};\n                var visible = pointVisibility[pointIndex];\n                pointVisibility[pointIndex] = defined(visible) ? !visible : false;\n              }\n            } else {\n              currentSeries.visible = !currentSeries.visible;\n\n              this._seriesVisibility.save(currentSeries);\n            }\n\n            chart._noTransitionsRedraw();\n          },\n          _createTooltip: function () {\n            return new Tooltip(this.element, extend({}, this.options.tooltip, {\n              rtl: this._isRtl()\n            }));\n          },\n          _tooltipleave: function () {\n            if (this._instance) {\n              this._instance.hideElements();\n            }\n          },\n          _bindData: function (e) {\n            var chart = this,\n                options = chart.options,\n                series = chart._sourceSeries || options.series,\n                seriesIx,\n                seriesLength = series.length,\n                data = chart.dataSource.view(),\n                grouped = (chart.dataSource.group() || []).length > 0,\n                processedSeries = [],\n                seriesVisibility = this._seriesVisibility,\n                currentSeries,\n                groupedSeries;\n            seriesVisibility.read();\n\n            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n              currentSeries = series[seriesIx];\n\n              if (chart._isBindable(currentSeries) && grouped) {\n                groupedSeries = groupSeries(currentSeries, data);\n                processedSeries = processedSeries.concat(groupedSeries);\n                seriesVisibility.applyByGroup(groupedSeries, e);\n              } else {\n                currentSeries = extend({}, currentSeries);\n                processedSeries.push(currentSeries);\n                seriesVisibility.applyByIndex(currentSeries, e);\n              }\n            }\n\n            chart._sourceSeries = series;\n            options.series = processedSeries;\n\n            this._instance.applySeriesColors();\n\n            chart._bindSeries();\n\n            chart._bindCategories();\n\n            this._hasData = true;\n          },\n          _onDataChanged: function (e) {\n            this._bindData(e);\n\n            this.trigger(DATABOUND);\n\n            if (this._instance && this._instance.fontLoaded) {\n              this._redraw();\n            }\n          },\n          _bindSeries: function () {\n            var chart = this,\n                data = chart.dataSource.view(),\n                series = chart.options.series,\n                seriesIx,\n                seriesLength = series.length,\n                currentSeries,\n                groupIx,\n                seriesData;\n\n            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n              currentSeries = series[seriesIx];\n\n              if (chart._isBindable(currentSeries)) {\n                groupIx = currentSeries._groupIx;\n                seriesData = defined(groupIx) ? (data[groupIx] || {}).items : data;\n\n                if (currentSeries.autoBind !== false) {\n                  currentSeries.data = seriesData;\n                }\n              }\n            }\n          },\n          _bindCategories: function () {\n            var chart = this,\n                data = chart.dataSource.view() || [],\n                grouped = (chart.dataSource.group() || []).length > 0,\n                categoriesData = data,\n                options = chart.options,\n                definitions = [].concat(options.categoryAxis),\n                axisIx,\n                axis;\n\n            if (grouped) {\n              if (data.length) {\n                categoriesData = data[0].items;\n              }\n            }\n\n            for (axisIx = 0; axisIx < definitions.length; axisIx++) {\n              axis = definitions[axisIx];\n\n              if (axis.autoBind !== false) {\n                chart._bindCategoryAxis(axis, categoriesData, axisIx);\n              }\n            }\n          },\n          _bindCategoryAxis: function (axis, data, axisIx) {\n            var count = (data || []).length,\n                categoryIx,\n                category,\n                row;\n\n            if (axis.field) {\n              axis.categories = [];\n\n              for (categoryIx = 0; categoryIx < count; categoryIx++) {\n                row = data[categoryIx];\n                category = getField(axis.field, row);\n\n                if (categoryIx === 0) {\n                  axis.categories = [category];\n                  axis.dataItems = [row];\n                } else {\n                  axis.categories.push(category);\n                  axis.dataItems.push(row);\n                }\n              }\n            } else if (this._instance) {\n              this._instance.bindCategoryAxisFromSeries(axis, axisIx);\n            }\n          },\n          _isBindable: function (series) {\n            var valueFields = SeriesBinder.current.valueFields(series),\n                result = true,\n                field,\n                i;\n\n            for (i = 0; i < valueFields.length; i++) {\n              field = valueFields[i];\n\n              if (field === VALUE) {\n                field = \"field\";\n              } else {\n                field = field + \"Field\";\n              }\n\n              if (!defined(series[field])) {\n                result = false;\n                break;\n              }\n            }\n\n            return result;\n          },\n          _isRtl: function () {\n            return kendo.support.isRtl(this.element) && this.element.css(\"direction\") === RTL;\n          }\n        });\n        var proxyMembers = [\"getAxis\", \"findAxisByName\", \"plotArea\", \"toggleHighlight\", \"showTooltip\", \"hideTooltip\", \"_resize\", \"_redraw\", \"_noTransitionsRedraw\", \"_legendItemHover\", \"_eventCoordinates\"];\n\n        function createProxyMember(name) {\n          Chart.fn[name] = function () {\n            var instance = this._instance;\n\n            if (instance) {\n              return instance[name].apply(instance, arguments);\n            }\n          };\n        }\n\n        for (var idx = 0; idx < proxyMembers.length; idx++) {\n          createProxyMember(proxyMembers[idx]);\n        }\n\n        function groupSeries(series, data) {\n          var result = [],\n              nameTemplate,\n              legacyTemplate = series.groupNameTemplate,\n              groupIx,\n              dataLength = data.length,\n              seriesClone;\n\n          if (dataLength === 0) {\n            seriesClone = deepExtend({}, series);\n            seriesClone.visibleInLegend = false;\n            return [seriesClone];\n          }\n\n          if (defined(legacyTemplate)) {\n            kendo.logToConsole(\"'groupNameTemplate' is obsolete and will be removed in future versions. \" + \"Specify the group name template as 'series.name'\");\n\n            if (legacyTemplate) {\n              nameTemplate = template(legacyTemplate);\n            }\n          } else {\n            nameTemplate = template(series.name || \"\");\n\n            if (nameTemplate._slotCount === 0) {\n              nameTemplate = template(defined(series.name) ? \"#= group.value #: #= series.name #\" : \"#= group.value #\");\n            }\n          }\n\n          for (groupIx = 0; groupIx < dataLength; groupIx++) {\n            seriesClone = deepExtend({}, series);\n\n            if (!kendo.isFunction(seriesClone.color)) {\n              seriesClone.color = undefined;\n            }\n\n            seriesClone._groupIx = groupIx;\n            seriesClone._groupValue = data[groupIx].value;\n            result.push(seriesClone);\n\n            if (nameTemplate) {\n              seriesClone.name = nameTemplate({\n                series: seriesClone,\n                group: data[groupIx]\n              });\n            }\n          }\n\n          return result;\n        }\n\n        dataviz.ExportMixin.extend(Chart.fn);\n\n        if (kendo.PDFMixin) {\n          kendo.PDFMixin.extend(Chart.fn);\n        }\n\n        dataviz.ui.plugin(Chart);\n        var SeriesVisibilityState = Class.extend({\n          init: function () {\n            this.groups = {};\n            this.index = {};\n            this.options = {};\n          },\n          applyByGroup: function (series, e) {\n            if (e && e.action || this.options.persistSeriesVisibility) {\n              for (var idx = 0; idx < series.length; idx++) {\n                if (this.groups[series[idx]._groupValue] === false) {\n                  series[idx].visible = false;\n                }\n              }\n            } else {\n              this.groups = {};\n            }\n          },\n          applyByIndex: function (series, e) {\n            if (e && e.action || this.options.persistSeriesVisibility) {\n              if (this.index[series.index] === false) {\n                series.visible = false;\n              }\n            } else {\n              this.index = {};\n            }\n          },\n          save: function (series) {\n            if (!series) {\n              return;\n            }\n\n            if (this.options.persistSeriesVisibility) {\n              this.options.series[series.index].visible = series.visible;\n            } else {\n              this.saveState(series);\n            }\n          },\n          setOptions: function (options) {\n            this.options = options;\n            this.groups = {};\n            this.index = {};\n          },\n          read: function () {\n            var options = this.options;\n\n            if (options.persistSeriesVisibility) {\n              var series = options.series;\n\n              for (var idx = 0; idx < series.length; idx++) {\n                this.saveState(series[idx]);\n              }\n            }\n          },\n          saveState: function (series) {\n            if (defined(series._groupValue)) {\n              this.groups[series._groupValue] = series.visible;\n            } else {\n              this.index[series.index] = series.visible;\n            }\n          }\n        });\n        var geom = kendo.geometry;\n\n        function normalizeStyle(style) {\n          for (var field in style) {\n            if (style[field] === undefined) {\n              style[field] = '';\n            }\n          }\n\n          return style;\n        }\n\n        var Tooltip = Observable.extend({\n          init: function (chartElement, options) {\n            var tooltip = this;\n            Observable.fn.init.call(tooltip);\n            this.setOptions(options);\n            tooltip.chartElement = chartElement;\n            tooltip.template = Tooltip.template;\n\n            if (!tooltip.template) {\n              tooltip.template = Tooltip.template = kendo.template(\"<div class='k-tooltip #if (!d.autoHide) {# k-tooltip-closable#}# k-chart-tooltip#= d.rtl ? \\\" k-rtl\\\" : \\\"\\\"#' \" + \"style='display:none; position: absolute; font: #= d.font #;\" + \"#if (d.border) {# border: #= d.border.width #px solid; #}#\" + \"opacity: #= d.opacity #;'>\" + '<div class=\"k-tooltip-content\"></div>' + '#if (!d.autoHide) {# <div class=\"k-tooltip-button\"><a href=\"\\\\#\" class=\"k-icon k-i-close\" title=\"Close\"></a></div> #}#' + \"</div>\", {\n                useWithBlock: false,\n                paramName: \"d\"\n              });\n            }\n\n            tooltip.element = $(tooltip.template(tooltip.options));\n            tooltip.move = tooltip.move.bind(tooltip);\n            tooltip._mouseleave = tooltip._mouseleave.bind(tooltip);\n            var mobileScrollerSelector = kendo.format(\"[{0}='content'],[{0}='scroller']\", kendo.attr(\"role\"));\n            tooltip._mobileScroller = chartElement.closest(mobileScrollerSelector).data(\"kendoMobileScroller\");\n            tooltip.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());\n            tooltip._closeTooltipHandler = tooltip._closeTooltip.bind(tooltip);\n          },\n          destroy: function () {\n            var tooltip = this;\n\n            this._clearShowTimeout();\n\n            DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler);\n\n            if (this.element) {\n              this.element.off(MOUSELEAVE_NS).remove();\n              this.element = null;\n            }\n          },\n          setOptions: function (options) {\n            this.options = deepExtend({}, this.options, options);\n          },\n          options: {\n            opacity: 1,\n            animation: {\n              duration: TOOLTIP_ANIMATION_DURATION\n            },\n            sharedTemplate: \"<table>\" + \"<th colspan='#= colspan #'>#= categoryText #</th>\" + \"# for(var i = 0; i < points.length; i++) { #\" + \"# var point = points[i]; #\" + \"<tr>\" + \"# if(colorMarker) { # \" + \"<td><span class='k-chart-shared-tooltip-marker' style='background-color:#:point.series.color#'></span></td>\" + \"# } #\" + \"# if(nameColumn) { # \" + \"<td> #if (point.series.name) {# #: point.series.name #: #} else {# &nbsp; #}#</td>\" + \"# } #\" + \"<td>#= content(point) #</td>\" + \"</tr>\" + \"# } #\" + \"</table>\",\n            categoryFormat: \"{0:d}\",\n            autoHide: true\n          },\n          move: function () {\n            var tooltip = this,\n                options = tooltip.options,\n                element = tooltip.element,\n                offset;\n\n            if (!tooltip.anchor || !tooltip.element) {\n              return;\n            }\n\n            offset = tooltip._offset();\n\n            if (!tooltip.visible) {\n              element.css({\n                top: offset.top,\n                left: offset.left\n              });\n            }\n\n            tooltip.visible = true;\n\n            tooltip._ensureElement(document.body);\n\n            element.stop(true, true).show().animate({\n              left: offset.left,\n              top: offset.top\n            }, options.animation.duration);\n          },\n          _clearShowTimeout: function () {\n            if (this.showTimeout) {\n              clearTimeout(this.showTimeout);\n              this.showTimeout = null;\n            }\n          },\n          getAnchor: function (size) {\n            var anchor = this.anchor;\n            var point = anchor.point;\n            var align = anchor.align;\n            var x = point.left;\n            var y = point.top;\n\n            if (align.horizontal === \"center\") {\n              x -= size.width / 2;\n            } else if (align.horizontal === \"right\") {\n              x -= size.width;\n            }\n\n            if (align.vertical === \"center\") {\n              y -= size.height / 2;\n            } else if (align.vertical === \"bottom\") {\n              y -= size.height;\n            }\n\n            return {\n              x: x,\n              y: y\n            };\n          },\n          _offset: function () {\n            var tooltip = this,\n                size = tooltip._measure(),\n                anchor = tooltip.getAnchor(size),\n                top = anchor.y,\n                left = anchor.x,\n                zoomLevel = kendo.support.zoomLevel(),\n                viewport = $(window),\n                scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0,\n                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || 0,\n                movable = (this._mobileScroller || {}).movable;\n\n            if (!movable || movable.scale === 1) {\n              top += tooltip._fit(top - scrollTop, size.height, outerHeight(viewport) / zoomLevel);\n              left += tooltip._fit(left - scrollLeft, size.width, outerWidth(viewport) / zoomLevel);\n            } else {\n              var transform = geom.transform().scale(movable.scale, movable.scale, [movable.x, movable.y]);\n              var point = new geom.Point(left, top).transform(transform);\n              left = point.x;\n              top = point.y;\n            }\n\n            return {\n              top: top,\n              left: left\n            };\n          },\n          show: function (e) {\n            var tooltip = this;\n            this.anchor = e.anchor;\n            this.element.css(normalizeStyle(e.style));\n            this.element.toggleClass(TOOLTIP_INVERSE, !!e.className);\n            this.element.toggleClass(SHARED_TOOLTIP_CLASS, !!e.shared);\n            var content = e.shared ? this._sharedContent(e) : this._pointContent(e.point);\n            this.element.find('.k-tooltip-content').html(content);\n\n            if (!tooltip.options.autoHide) {\n              tooltip.element.off(\"click\" + NS).on(\"click\" + NS, \".k-tooltip-button\", tooltip._closeTooltipHandler);\n              DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler).on(tooltip.downEvent, tooltip._closeTooltipHandler);\n            }\n\n            this._clearShowTimeout();\n\n            this.showTimeout = setTimeout(this.move, TOOLTIP_SHOW_DELAY);\n          },\n          hide: function (forceHide) {\n            var tooltip = this;\n\n            if (!tooltip.options.autoHide && !forceHide) {\n              return;\n            }\n\n            clearTimeout(tooltip.showTimeout);\n\n            tooltip._hideElement();\n\n            if (tooltip.visible) {\n              tooltip.point = null;\n              tooltip.visible = false;\n              tooltip.index = null;\n              DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler);\n            }\n          },\n          _closeTooltip: function (e) {\n            var target = $(e.target);\n\n            if (!target.is(\".k-chart-tooltip, .k-tooltip-content\")) {\n              e.preventDefault();\n\n              this.chartElement.data(\"kendoChart\")._instance.hideElements();\n\n              this.hide(true);\n            }\n          },\n          _sharedContent: function (e) {\n            var points = e.points;\n            var nameColumn = dataviz.grep(points, function (point) {\n              return defined(point.series.name);\n            }).length;\n            var colorMarker = e.series.length > 1;\n            var colspan = 1;\n\n            if (nameColumn) {\n              colspan++;\n            }\n\n            if (colorMarker) {\n              colspan++;\n            }\n\n            var template = kendo.template(this.options.sharedTemplate);\n            var content = template({\n              points: points,\n              category: e.category,\n              categoryText: e.categoryText,\n              content: this._pointContent,\n              colorMarker: colorMarker,\n              nameColumn: nameColumn,\n              colspan: colspan\n            });\n            return content;\n          },\n          _measure: function () {\n            this._ensureElement();\n\n            var size = {\n              width: outerWidth(this.element),\n              height: outerHeight(this.element)\n            };\n            return size;\n          },\n          _ensureElement: function () {\n            if (this.element) {\n              this.element.appendTo(document.body).on(MOUSELEAVE_NS, this._mouseleave);\n            }\n          },\n          _mouseleave: function (e) {\n            var target = e.relatedTarget;\n            var chart = this.chartElement[0];\n\n            if (target && target !== chart && !$.contains(chart, target)) {\n              this.trigger(LEAVE);\n            }\n          },\n          _hideElement: function () {\n            var tooltip = this;\n            var element = this.element;\n\n            if (element) {\n              element.fadeOut({\n                always: function () {\n                  if (!tooltip.visible) {\n                    element.off(MOUSELEAVE_NS).remove();\n                  }\n                }\n              });\n            }\n          },\n          _pointContent: function (point) {\n            var tooltip = this,\n                options = deepExtend({}, tooltip.options, point.options.tooltip),\n                content,\n                tooltipTemplate;\n\n            if (defined(point.value)) {\n              content = point.value.toString();\n            }\n\n            if (options.template) {\n              tooltipTemplate = template(options.template);\n              content = tooltipTemplate({\n                value: point.value,\n                category: point.category,\n                series: point.series,\n                dataItem: point.dataItem,\n                percentage: point.percentage,\n                runningTotal: point.runningTotal,\n                total: point.total,\n                low: point.low,\n                high: point.high,\n                xLow: point.xLow,\n                xHigh: point.xHigh,\n                yLow: point.yLow,\n                yHigh: point.yHigh\n              });\n            } else if (options.format) {\n              content = point.formatValue(options.format);\n            }\n\n            return content;\n          },\n          _fit: function (offset, size, viewPortSize) {\n            var output = 0;\n\n            if (offset + size > viewPortSize) {\n              output = viewPortSize - (offset + size);\n            }\n\n            if (offset < 0) {\n              output = -offset;\n            }\n\n            return output;\n          }\n        });\n        var CrosshairTooltip = Tooltip.extend({\n          init: function (chartElement, options) {\n            Tooltip.fn.init.call(this, chartElement, options);\n            this.element.addClass(\"k-chart-crosshair-tooltip\");\n          },\n          show: function (e) {\n            var element = this.element;\n\n            if (element) {\n              this.anchor = e.anchor;\n              this.element.css(e.style);\n              this.element.html(this.content(e));\n              this.move();\n            }\n          },\n          move: function () {\n            var tooltip = this,\n                element = tooltip.element,\n                offset = tooltip._offset();\n\n            tooltip._ensureElement();\n\n            element.css({\n              top: offset.top,\n              left: offset.left\n            }).show();\n          },\n          content: function (e) {\n            var content = e.value,\n                options = e.crosshair.options.tooltip;\n\n            if (options.template) {\n              content = template(options.template)({\n                value: content\n              });\n            }\n\n            return content;\n          },\n          hide: function () {\n            this.element.hide();\n          }\n        });\n        var ChartPane = Class.extend({\n          init: function (chart, pane) {\n            this._chart = chart;\n            this._pane = pane;\n            this.visual = pane.visual;\n            this.chartsVisual = pane.chartContainer.visual;\n            this.name = pane.options.name;\n          },\n          series: function () {\n            var chart = this._chart;\n\n            var seriesByPane = chart._plotArea.groupSeriesByPane();\n\n            var series = seriesByPane[this.name || \"default\"];\n            var result = [];\n\n            if (series) {\n              for (var idx = 0; idx < series.length; idx++) {\n                result.push(new ChartSeries(chart, series[idx]));\n              }\n            }\n\n            return result;\n          }\n        });\n        var ChartSeries = Class.extend({\n          init: function (chart, options) {\n            this._chart = chart;\n            this._options = options;\n          },\n          points: function (filter) {\n            var points = this._points;\n\n            if (!points) {\n              var series = this._seriesOptions();\n\n              var plotArea = this._chart._plotArea;\n              this._points = points = plotArea.pointsBySeriesIndex(series.index);\n            }\n\n            if (kendo.isFunction(filter)) {\n              points = this._filterPoints(points, filter);\n            }\n\n            return points;\n          },\n          data: function (data) {\n            var series = this._seriesOptions();\n\n            if (data) {\n              var chart = this._chart;\n              var plotArea = chart._plotArea;\n              series.data = data;\n\n              if (series.categoryField) {\n                var axis = plotArea.seriesCategoryAxis(series);\n                var options = [].concat(chart.options.categoryAxis);\n\n                chart._instance.bindCategoryAxisFromSeries(options[axis.axisIndex], axis.axisIndex);\n              }\n\n              chart._noTransitionsRedraw();\n\n              this._clearFields();\n            }\n\n            return series.data;\n          },\n          findPoint: function (filter) {\n            var points = this.points();\n\n            for (var idx = 0; idx < points.length; idx++) {\n              if (filter(points[idx])) {\n                return points[idx];\n              }\n            }\n          },\n          toggleHighlight: function (show, elements) {\n            if (!elements) {\n              elements = this.points();\n            } else if (kendo.isFunction(elements)) {\n              elements = this.points(elements);\n            } else {\n              elements = isArray(elements) ? elements : [elements];\n            }\n\n            this._chart._instance.togglePointsHighlight(show, elements);\n          },\n          toggleVisibility: function (visible, filter) {\n            var chart = this._chart;\n\n            var seriesOptions = this._seriesOptions();\n\n            var hasFilter = kendo.isFunction(filter);\n\n            if (!hasFilter) {\n              seriesOptions.visible = visible;\n\n              chart._seriesVisibility.save(seriesOptions);\n            } else {\n              if (inArray(seriesOptions.type, [PIE, DONUT, FUNNEL])) {\n                var data = this._filterData(filter);\n\n                for (var idx = 0; idx < data.length; idx++) {\n                  data[idx].visible = visible;\n                }\n              } else {\n                seriesOptions.visible = function (data) {\n                  return filter(data.dataItem) ? visible : true;\n                };\n              }\n            }\n\n            chart._noTransitionsRedraw();\n\n            this._clearFields();\n          },\n          _filterData: function (filter) {\n            var data = this._seriesOptions().data;\n\n            var length = data.length;\n            var result = [];\n\n            for (var idx = 0; idx < length; idx++) {\n              if (filter(data[idx])) {\n                result.push(data[idx]);\n              }\n            }\n\n            return result;\n          },\n          _filterPoints: function (points, filter) {\n            var result = [];\n            var length = points.length;\n\n            for (var idx = 0; idx < length; idx++) {\n              if (filter(points[idx])) {\n                result.push(points[idx]);\n              }\n            }\n\n            return result;\n          },\n          _seriesOptions: function () {\n            var series = this._series;\n\n            if (!series) {\n              series = this._series = this._chart._seriesOptions(this._options);\n            }\n\n            return series;\n          },\n          _clearFields: function () {\n            delete this._points;\n            delete this._series;\n          }\n        });\n\n        function triggerPaneRender(panes) {\n          for (var idx = 0; idx < panes.length; idx++) {\n            panes[idx].notifyRender();\n          }\n        }\n\n        dataviz.Tooltip = Tooltip;\n        dataviz.CrosshairTooltip = CrosshairTooltip;\n        dataviz.ChartInstanceObserver = ChartInstanceObserver;\n        dataviz.ChartPane = ChartPane;\n        dataviz.ChartSeries = ChartSeries;\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  889:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo-chart\");\n    /***/\n  },\n\n  /***/\n  890:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.data\");\n    /***/\n  },\n\n  /***/\n  891:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  892:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.themes\");\n    /***/\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  894:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.userevents\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}