{"ast":null,"code":"import { geometry as g, drawing as d } from '@progress/kendo-drawing';\nimport { Class, defined, isFunction, getter, setDefaultOptions } from '../../common';\nimport { ShapeLayer } from './shape';\nimport { Location } from '../location';\nexport class BubbleLayer extends ShapeLayer {\n  _readData() {\n    const data = this.options.data || [];\n    return data;\n  }\n\n  _load(data) {\n    this._data = data;\n    this.surface.clear();\n\n    if (data.length === 0) {\n      return;\n    }\n\n    let options = this.options;\n    let getValue = getter(options.valueField);\n    let newData = data.slice(0);\n    newData.sort(function (a, b) {\n      return getValue(b) - getValue(a);\n    });\n\n    let scaleType = this._scaleType();\n\n    let scale;\n    let getLocation = getter(this.options.locationField);\n\n    for (let i = 0; i < newData.length; i++) {\n      let dataItem = newData[i];\n      let location = getLocation(dataItem);\n      let value = getValue(dataItem);\n\n      if (defined(location) && defined(value)) {\n        if (!scale) {\n          scale = new scaleType([0, value], [options.minSize, options.maxSize]);\n        }\n\n        location = Location.create(location);\n        let center = this.map.locationToView(location);\n        let size = scale.map(value);\n\n        let symbol = this._createSymbol({\n          center: center,\n          size: size,\n          style: options.style,\n          dataItem: dataItem,\n          location: location\n        });\n\n        symbol.dataItem = dataItem;\n        symbol.location = location;\n        symbol.value = value;\n\n        this._drawSymbol(symbol);\n      }\n    }\n  }\n\n  _scaleType() {\n    let scale = this.options.scale;\n\n    if (isFunction(scale)) {\n      return scale;\n    }\n\n    return Scales[scale];\n  }\n\n  _createSymbol(args) {\n    let symbol = this.options.symbol;\n\n    if (!isFunction(symbol)) {\n      symbol = Symbols[symbol];\n    }\n\n    return symbol(args);\n  }\n\n  _drawSymbol(shape) {\n    let args = {\n      layer: this,\n      shape: shape\n    };\n    let cancelled = this.map.trigger('shapeCreated', args);\n\n    if (!cancelled) {\n      this.surface.draw(shape);\n    }\n  }\n\n  _tooltipContext(shape) {\n    return {\n      type: 'bubble',\n      layerIndex: this._layerIndex(),\n      className: 'k-map-bubble-tooltip',\n      dataItem: shape.dataItem,\n      location: shape.location,\n      value: shape.value\n    };\n  }\n\n  _tooltipAnchor(e) {\n    const shape = e.element;\n    const center = shape.bbox().center();\n    return {\n      top: center.y,\n      left: center.x\n    };\n  }\n\n}\nsetDefaultOptions(BubbleLayer, {\n  // autoBind: true,\n  locationField: 'location',\n  valueField: 'value',\n  minSize: 0,\n  maxSize: 100,\n  scale: 'sqrt',\n  symbol: 'circle',\n  // ensure bubble layers are displayed over tile and shape layers\n  zIndex: 200\n});\n\nclass SqrtScale extends Class {\n  constructor(domain, range) {\n    super();\n    this._domain = domain;\n    this._range = range;\n    let domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);\n    let outputRange = range[1] - range[0];\n    this._ratio = outputRange / domainRange;\n  }\n\n  map(value) {\n    let rel = (Math.sqrt(value) - Math.sqrt(this._domain[0])) * this._ratio;\n\n    return this._range[0] + rel;\n  }\n\n}\n\nlet Scales = {\n  sqrt: SqrtScale\n};\nlet Symbols = {\n  circle: function (args) {\n    let geo = new g.Circle(args.center, args.size / 2);\n    return new d.Circle(geo, args.style);\n  },\n  square: function (args) {\n    let path = new d.Path(args.style);\n    let halfSize = args.size / 2;\n    let center = args.center;\n    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();\n    return path;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}