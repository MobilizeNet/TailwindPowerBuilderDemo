{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined } from '../../common';\nimport { BLACK } from '../../common/constants';\nimport { NumericAxis } from '../../core';\nimport { DEFAULT_LINE_WIDTH, INSIDE } from '../constants';\nimport { autoMajorUnit } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\nconst {\n  Path,\n  Group\n} = drawing;\nconst Point = geo.Point;\n\nfunction renderAxisTick(tickRenderOptions, tickOptions) {\n  const {\n    position,\n    tickX,\n    tickY\n  } = tickRenderOptions;\n  let start, end;\n\n  if (tickRenderOptions.vertical) {\n    start = new Point(tickX, position);\n    end = new Point(tickX + tickOptions.size, position);\n  } else {\n    start = new Point(position, tickY);\n    end = new Point(position, tickY + tickOptions.size);\n  }\n\n  const tickPath = new Path({\n    stroke: {\n      color: tickOptions.color,\n      width: tickOptions.width\n    }\n  }).moveTo(start).lineTo(end);\n  return tickPath;\n}\n\nfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n  const count = tickPositions.length;\n\n  if (tickOptions.visible) {\n    const {\n      mirror,\n      lineBox\n    } = tickRenderOptions;\n\n    for (let i = tickOptions.skip; i < count; i += tickOptions.step) {\n      if (i % tickOptions.skipUnit === 0) {\n        continue;\n      }\n\n      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickRenderOptions.position = tickPositions[i];\n      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n    }\n  }\n}\n\nclass LinearScale extends NumericAxis {\n  constructor(options, service) {\n    let scaleOptions = options || {};\n\n    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n      scaleOptions = Object.assign({}, scaleOptions, {\n        reverse: true\n      });\n    }\n\n    super(0, 1, scaleOptions, service);\n    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n  }\n\n  initUserOptions(options) {\n    let scaleOptions = deepExtend({}, this.options, options);\n    scaleOptions = deepExtend({}, scaleOptions, {\n      labels: {\n        mirror: scaleOptions.mirror\n      }\n    });\n    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n    return scaleOptions;\n  }\n\n  initFields() {}\n\n  render() {\n    const elements = this.elements = new Group();\n    const labels = this.renderLabels();\n    const scaleLine = this.renderLine();\n    const scaleTicks = this.renderTicks();\n    const ranges = this.renderRanges();\n    elements.append(scaleLine, labels, scaleTicks, ranges);\n    return elements;\n  }\n\n  renderRanges() {\n    const options = this.options;\n    const {\n      min,\n      max,\n      vertical,\n      labels: {\n        mirror\n      }\n    } = options;\n    const ranges = options.ranges || [];\n    const elements = new Group();\n    const count = ranges.length;\n    const rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n    for (let i = 0; i < count; i++) {\n      const range = getRange(ranges[i], min, max);\n      const slot = this.getSlot(range.from, range.to);\n      const slotX = vertical ? this.lineBox() : slot;\n      const slotY = vertical ? slot : this.lineBox();\n\n      if (vertical) {\n        slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n      } else {\n        slotY.y2 += rangeSize * (mirror ? -1 : 1);\n      }\n\n      elements.append(Path.fromRect(new geo.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {\n        fill: {\n          color: range.color,\n          opacity: range.opacity\n        },\n        stroke: {}\n      }));\n    }\n\n    return elements;\n  }\n\n  renderLabels() {\n    const {\n      labels,\n      options\n    } = this;\n    const elements = new Group();\n\n    for (let i = 0; i < labels.length; i++) {\n      elements.append(buildLabelElement(labels[i], options.labels));\n    }\n\n    return elements;\n  }\n\n  renderLine() {\n    const line = this.options.line;\n    const lineBox = this.lineBox();\n    const elements = new Group();\n\n    if (line.width > 0 && line.visible) {\n      const linePath = new Path({\n        stroke: {\n          color: line.color,\n          dashType: line.dashType,\n          width: line.width\n        }\n      });\n      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n      elements.append(linePath);\n    }\n\n    return elements;\n  }\n\n  renderTicks() {\n    const ticks = new Group();\n    const options = this.options;\n    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    const tickRenderOptions = {\n      vertical: options.vertical,\n      mirror: options.labels.mirror,\n      lineBox: this.lineBox()\n    };\n    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n      skipUnit: majorUnit / options.minorUnit\n    }, options.minorTicks));\n    return ticks;\n  }\n\n}\n\nsetDefaultOptions(LinearScale, {\n  min: 0,\n  max: 50,\n  majorTicks: {\n    size: 15,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  minorTicks: {\n    size: 10,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  line: {\n    width: DEFAULT_LINE_WIDTH\n  },\n  labels: {\n    position: INSIDE,\n    padding: 2\n  },\n  mirror: false,\n  _alignLines: false\n});\nexport default LinearScale;","map":null,"metadata":{},"sourceType":"module"}