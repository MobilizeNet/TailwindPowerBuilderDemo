{"ast":null,"code":"import { Class } from '../../../common';\nimport { EncodingResult } from '../encoding-result';\nimport { DataModeInstances } from '../data-modes/data-mode-instances';\nimport { extend } from '../../utils';\nimport { toBitsString } from '../../utils';\nimport { getVersion } from '../encoding';\nconst BYTE = \"byte\";\nexport class Utf8Encoder extends Class {\n  constructor() {\n    super();\n    this.initProperties();\n    this.mode = DataModeInstances[this.encodingMode];\n  }\n\n  initProperties() {\n    extend(this, {\n      encodingMode: BYTE,\n      utfBOM: \"111011111011101110111111\",\n      initialModeCountStringLength: 20,\n      ranges: [128, 2048, 65536, 2097152, 67108864]\n    });\n  }\n\n  getEncodingResult(inputString, errorCorrectionLevel) {\n    let data = this.encode(inputString),\n        dataCodewordsCount = this.getDataCodewordsCount(data),\n        version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n        dataString = this.mode.getModeCountString(data.length / 8, version) + data;\n    return new EncodingResult(dataString, version);\n  }\n\n  getDataCodewordsCount(data) {\n    let dataLength = data.length,\n        dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);\n    return dataCodewordsCount;\n  }\n\n  encode(str) {\n    let result = this.utfBOM;\n\n    for (let i = 0; i < str.length; i++) {\n      result += this.encodeCharacter(str.charCodeAt(i));\n    }\n\n    return result;\n  }\n\n  encodeCharacter(code) {\n    let bytesCount = this.getBytesCount(code),\n        bc = bytesCount - 1,\n        result = \"\";\n\n    if (bytesCount === 1) {\n      result = toBitsString(code, 8);\n    } else {\n      let significantOnes = 8 - bytesCount;\n\n      for (let i = 0; i < bc; i++) {\n        result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;\n      }\n\n      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;\n    }\n\n    return result;\n  }\n\n  getBytesCount(code) {\n    let ranges = this.ranges;\n\n    for (let i = 0; i < ranges.length; i++) {\n      if (code < ranges[i]) {\n        return i + 1;\n      }\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}