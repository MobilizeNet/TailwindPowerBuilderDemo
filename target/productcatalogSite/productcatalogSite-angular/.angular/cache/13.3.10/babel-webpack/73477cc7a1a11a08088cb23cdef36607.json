{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1721);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  },\n\n  /***/\n  1712:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../util/main\");\n    /***/\n  },\n\n  /***/\n  1721:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1678), __webpack_require__(1712)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\"; // WARNING: removing the following jshint declaration and turning\n      // == into === to make JSHint happy will break functionality.\n\n      /* jshint eqnull:true, newcap:false, laxbreak:true, validthis:true */\n\n      /* jshint latedef:false */\n\n      var util = kendo.util;\n      var spreadsheet = kendo.spreadsheet;\n      var calc = spreadsheet.calc;\n      var runtime = calc.runtime;\n      var defineFunction = runtime.defineFunction;\n      var defineAlias = runtime.defineAlias;\n      var CalcError = runtime.CalcError;\n      var RangeRef = spreadsheet.RangeRef;\n      var CellRef = spreadsheet.CellRef;\n      var UnionRef = spreadsheet.UnionRef;\n      var Matrix = runtime.Matrix;\n      var Ref = spreadsheet.Ref;\n      var NameRef = spreadsheet.NameRef;\n      var daysInMonth = runtime.daysInMonth;\n      var packDate = runtime.packDate;\n      var unpackDate = runtime.unpackDate;\n      var daysInYear = runtime.daysInYear;\n      var limitPrecision = runtime.limitPrecision;\n      /* -----[ Math functions ]----- */\n\n      [\"abs\", \"cos\", \"sin\", \"acos\", \"asin\", \"tan\", \"atan\", \"exp\", \"sqrt\"].forEach(function (name) {\n        defineFunction(name, Math[name]).args([[\"*n\", \"number\"]]);\n      });\n      defineFunction(\"ln\", Math.log).args([[\"*n\", \"number\"]]);\n      defineFunction(\"log\", function (num, base) {\n        return Math.log(num) / Math.log(base);\n      }).args([[\"*num\", \"number++\"], [\"*base\", [\"or\", \"number++\", [\"null\", 10]]], [\"?\", [\"assert\", \"$base != 1\", \"DIV/0\"]]]);\n      defineFunction(\"log10\", function (num) {\n        return Math.log(num) / Math.log(10);\n      }).args([[\"*num\", \"number++\"]]);\n      defineFunction(\"pi\", function () {\n        return Math.PI;\n      }).args([]);\n      defineFunction(\"sqrtpi\", function (n) {\n        return Math.sqrt(n * Math.PI);\n      }).args([[\"*num\", \"number+\"]]);\n      defineFunction(\"degrees\", function (rad) {\n        return 180 * rad / Math.PI % 360;\n      }).args([[\"*radians\", \"number\"]]);\n      defineFunction(\"radians\", function (deg) {\n        return Math.PI * deg / 180;\n      }).args([[\"*degrees\", \"number\"]]);\n\n      function _cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      defineFunction(\"cosh\", _cosh).args([[\"*num\", \"number\"]]);\n      defineFunction(\"acosh\", function (n) {\n        return Math.log(n + Math.sqrt(n - 1) * Math.sqrt(n + 1));\n      }).args([[\"*num\", \"number\"], [\"?\", [\"assert\", \"$num >= 1\"]]]);\n\n      function _sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      defineFunction(\"sinh\", _sinh).args([[\"*num\", \"number\"]]);\n      defineFunction(\"asinh\", function (n) {\n        return Math.log(n + Math.sqrt(n * n + 1));\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"sec\", function (n) {\n        return 1 / Math.cos(n);\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"sech\", function (n) {\n        return 1 / _cosh(n);\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"csc\", function (n) {\n        return 1 / Math.sin(n);\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"csch\", function (n) {\n        return 1 / _sinh(n);\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"atan2\", function (x, y) {\n        return Math.atan(y / x);\n      }).args([[\"*x\", \"divisor\"], [\"*y\", \"number\"]]);\n\n      function _tanh(n) {\n        return _sinh(n) / _cosh(n);\n      }\n\n      defineFunction(\"tanh\", _tanh).args([[\"*num\", \"number\"]]);\n      defineFunction(\"atanh\", function (n) {\n        return Math.log(Math.sqrt(1 - n * n) / (1 - n));\n      }).args([[\"*num\", [\"and\", \"number\", [\"(between)\", -1, 1]]]]);\n      defineFunction(\"cot\", function (n) {\n        return 1 / Math.tan(n);\n      }).args([[\"*num\", \"divisor\"]]);\n      defineFunction(\"coth\", function (n) {\n        return 1 / _tanh(n);\n      }).args([[\"*num\", \"divisor\"]]);\n      defineFunction(\"acot\", function (n) {\n        return Math.PI / 2 - Math.atan(n);\n      }).args([[\"*num\", \"number\"]]);\n      defineFunction(\"acoth\", function (n) {\n        return Math.log((n + 1) / (n - 1)) / 2;\n      }).args([[\"*num\", \"number\"], [\"?\", [\"or\", [\"assert\", \"$num < -1\"], [\"assert\", \"$num > 1\"]]]]);\n      defineFunction(\"power\", function (a, b) {\n        return Math.pow(a, b);\n      }).args([[\"*a\", \"number\"], [\"*b\", \"number\"]]);\n      defineFunction(\"mod\", function (a, b) {\n        return a % b;\n      }).args([[\"*a\", \"number\"], [\"*b\", \"divisor\"]]);\n      defineFunction(\"quotient\", function (a, b) {\n        return Math.floor(a / b);\n      }).args([[\"*a\", \"number\"], [\"*b\", \"divisor\"]]);\n      defineFunction(\"ceiling\", function (num, s) {\n        return s ? s * Math.ceil(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", \"number\"], [\"?\", [\"assert\", \"$significance >= 0 || $number < 0\"]]]);\n      defineFunction(\"ceiling.precise\", function (num, s) {\n        s = Math.abs(s);\n        return s ? s * Math.ceil(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", [\"or\", \"number\", [\"null\", 1]]]]);\n      defineAlias(\"iso.ceiling\", \"ceiling.precise\"); // XXX: how do we know if this function is correct?\n      //\n      // https://support.office.com/en-gb/article/CEILING-MATH-function-80f95d2f-b499-4eee-9f16-f795a8e306c8\n      //\n      // “There are many combinations of Significance and Mode values that affect rounding of negative\n      // numbers in different ways.” — right, thanks for the info. :-\\\n\n      defineFunction(\"ceiling.math\", function (num, s, mode) {\n        if (!s || !num) {\n          return 0;\n        }\n\n        if (num < 0 && (!mode && s < 0 || mode && s > 0)) {\n          s = -s;\n        }\n\n        return s ? s * Math.ceil(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", [\"or\", \"number\", [\"null\", \"$number < 0 ? -1 : 1\"]]], [\"*mode\", [\"or\", \"logical\", [\"null\", 0]]]]);\n      defineFunction(\"floor\", function (num, s) {\n        return s ? s * Math.floor(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", \"number\"], [\"?\", [\"assert\", \"$significance >= 0 || $number < 0\"]]]);\n      defineFunction(\"floor.precise\", function (num, s) {\n        s = Math.abs(s);\n        return s ? s * Math.floor(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", [\"or\", \"number\", [\"null\", 1]]]]); // XXX: check this\n\n      defineFunction(\"floor.math\", function (num, s, mode) {\n        if (!s || !num) {\n          return 0;\n        }\n\n        if (num < 0 && (!mode && s < 0 || mode && s > 0)) {\n          s = -s;\n        }\n\n        return s ? s * Math.floor(num / s) : 0;\n      }).args([[\"*number\", \"number\"], [\"*significance\", [\"or\", \"number\", [\"null\", \"$number < 0 ? -1 : 1\"]]], [\"*mode\", [\"or\", \"logical\", [\"null\", 0]]]]);\n      defineFunction(\"int\", Math.floor).args([[\"*number\", \"number\"]]);\n      defineFunction(\"mround\", function (num, mult) {\n        return mult ? mult * Math.round(num / mult) : 0;\n      }).args([[\"*number\", \"number\"], [\"*multiple\", \"number\"]]);\n      defineFunction(\"round\", function (num, digits) {\n        var sign = num < 0 ? -1 : 1;\n\n        if (sign < 0) {\n          num = -num;\n        }\n\n        digits = Math.pow(10, digits);\n        num = limitPrecision(num * digits);\n        num = Math.round(num);\n        return sign * num / digits;\n      }).args([[\"*number\", \"number\"], [\"*digits\", \"number\"]]);\n      defineFunction(\"roundup\", function (num, digits) {\n        digits = Math.pow(10, digits);\n        num = limitPrecision(num * digits);\n        num = num < 0 ? Math.floor(num) : Math.ceil(num);\n        return num / digits;\n      }).args([[\"*number\", \"number\"], [\"*digits\", \"number\"]]);\n      defineFunction(\"rounddown\", function (num, digits) {\n        digits = Math.pow(10, digits);\n        num = limitPrecision(num * digits);\n        num = num < 0 ? Math.ceil(num) : Math.floor(num);\n        return num / digits;\n      }).args([[\"*number\", \"number\"], [\"*digits\", \"number\"]]);\n      defineFunction(\"even\", function (num) {\n        var n = num < 0 ? Math.floor(num) : Math.ceil(num);\n        return n % 2 ? n + (n < 0 ? -1 : 1) : n;\n      }).args([[\"*number\", \"number\"]]);\n      defineFunction(\"odd\", function (num) {\n        var n = num < 0 ? Math.floor(num) : Math.ceil(num);\n        return n % 2 ? n : n + (n < 0 ? -1 : 1);\n      }).args([[\"*number\", \"number\"]]);\n      defineFunction(\"sign\", function (num) {\n        return num < 0 ? -1 : num > 0 ? 1 : 0;\n      }).args([[\"*number\", \"number\"]]);\n\n      function _gcd(a, b) {\n        while (b) {\n          var r = a % b;\n          a = b;\n          b = r;\n        }\n\n        return a;\n      }\n\n      function _lcm(a, b) {\n        return Math.abs(a * b) / _gcd(a, b);\n      }\n\n      defineFunction(\"gcd\", function (args) {\n        var a = args[0];\n\n        for (var i = 1; i < args.length; ++i) {\n          a = _gcd(a, args[i]);\n        }\n\n        return a;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"lcm\", function (args) {\n        var a = args[0];\n\n        for (var i = 1; i < args.length; ++i) {\n          a = _lcm(a, args[i]);\n        }\n\n        return a;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"sum\", function (numbers) {\n        return numbers.reduce(function (sum, num) {\n          return sum + num;\n        }, 0);\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"product\", function (numbers) {\n        return numbers.reduce(function (prod, num) {\n          return prod * num;\n        }, 1);\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"sumproduct\", function (first, rest) {\n        var sum = 0;\n        first.each(function (p, row, col) {\n          if (typeof p == \"number\") {\n            for (var i = 0; i < rest.length; ++i) {\n              var v = rest[i].get(row, col);\n\n              if (typeof v != \"number\") {\n                return;\n              }\n\n              p *= v;\n            }\n\n            sum += p;\n          }\n        });\n        return sum;\n      }).args([[\"a1\", \"matrix\"], [\"+\", [\"a2\", [\"and\", \"matrix\", [\"assert\", \"$a2.width == $a1.width\"], [\"assert\", \"$a2.height == $a1.height\"]]]]]);\n      defineFunction(\"sumsq\", function (numbers) {\n        return numbers.reduce(function (sum, num) {\n          return sum + num * num;\n        }, 0);\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"sumx2my2\", function (a, b) {\n        var sum = 0;\n        a.each(function (x, row, col) {\n          var y = b.get(row, col);\n\n          if (typeof x == \"number\" && typeof y == \"number\") {\n            sum += x * x - y * y;\n          }\n        });\n        return sum;\n      }).args([[\"a\", \"matrix\"], [\"b\", [\"and\", \"matrix\", [\"assert\", \"$b.width == $a.width\"], [\"assert\", \"$b.height == $a.height\"]]]]);\n      defineFunction(\"sumx2py2\", function (a, b) {\n        var sum = 0;\n        a.each(function (x, row, col) {\n          var y = b.get(row, col);\n\n          if (typeof x == \"number\" && typeof y == \"number\") {\n            sum += x * x + y * y;\n          }\n        });\n        return sum;\n      }).args([[\"a\", \"matrix\"], [\"b\", [\"and\", \"matrix\", [\"assert\", \"$b.width == $a.width\"], [\"assert\", \"$b.height == $a.height\"]]]]);\n      defineFunction(\"sumxmy2\", function (a, b) {\n        var sum = 0;\n        a.each(function (x, row, col) {\n          var y = b.get(row, col);\n\n          if (typeof x == \"number\" && typeof y == \"number\") {\n            sum += (x - y) * (x - y);\n          }\n        });\n        return sum;\n      }).args([[\"a\", \"matrix\"], [\"b\", [\"and\", \"matrix\", [\"assert\", \"$b.width == $a.width\"], [\"assert\", \"$b.height == $a.height\"]]]]);\n      defineFunction(\"seriessum\", function (x, n, m, a) {\n        var sum = 0;\n        a.each(function (coef) {\n          if (typeof coef != \"number\") {\n            throw new CalcError(\"VALUE\");\n          }\n\n          sum += coef * Math.pow(x, n);\n          n += m;\n        });\n        return sum;\n      }).args([[\"x\", \"number\"], [\"y\", \"number\"], [\"m\", \"number\"], [\"a\", \"matrix\"]]);\n      defineFunction(\"min\", function (numbers) {\n        return numbers.length ? Math.min.apply(Math, numbers) : 0;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"max\", function (numbers) {\n        return numbers.length ? Math.max.apply(Math, numbers) : 0;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"counta\", function (values) {\n        return values.length;\n      }).args([[\"values\", [\"#collect\", \"anyvalue\"]]]);\n      defineFunction(\"count\", function (numbers) {\n        return numbers.length;\n      }).args([[\"numbers\", [\"#collect\", \"number\"]]]);\n      defineFunction(\"countunique\", function (values) {\n        var count = 0,\n            seen = [];\n        values.forEach(function (val) {\n          if (seen.indexOf(val) < 0) {\n            count++;\n            seen.push(val);\n          }\n        });\n        return count;\n      }).args([[\"values\", [\"#collect\", \"anyvalue\"]]]);\n      defineFunction(\"countblank\", function (a) {\n        var count = 0;\n\n        function add(val) {\n          if (val == null || val === \"\") {\n            count++;\n          }\n        }\n\n        function loop(args) {\n          for (var i = 0; i < args.length; ++i) {\n            var x = args[i];\n\n            if (x instanceof Matrix) {\n              x.each(add, true);\n            } else {\n              add(x);\n            }\n          }\n        }\n\n        loop(a);\n        return count;\n      }).args([[\"+\", [\"args\", [\"or\", \"matrix\", \"anyvalue\"]]]]);\n      defineFunction(\"iseven\", function (num) {\n        return num % 2 === 0;\n      }).args([[\"*number\", \"number\"]]);\n      defineFunction(\"isodd\", function (num) {\n        return num % 2 !== 0;\n      }).args([[\"*number\", \"number\"]]);\n      defineFunction(\"n\", function (val) {\n        if (typeof val == \"boolean\") {\n          return val ? 1 : 0;\n        }\n\n        if (typeof val == \"number\") {\n          return val;\n        }\n\n        return 0;\n      }).args([[\"*value\", \"anyvalue\"]]);\n      defineFunction(\"na\", function () {\n        return new CalcError(\"N/A\");\n      }).args([]);\n      /* -----[ the \"*IFS\" functions ]----- */\n      // helper function: take `args` like COUNTIFS (see Excel docs) and\n      // calls `f` for each cell matching all criteria.  `f` receives\n      // `chunks` (parsed args containing matrix and predicate) and\n      // row,col of matching cells.\n\n      function forIFS(args, f) {\n        var chunks = [],\n            i = 0,\n            matrix = args[0];\n\n        while (i < args.length) {\n          chunks.push({\n            matrix: args[i++],\n            pred: parseCriteria(args[i++])\n          });\n        }\n\n        ROW: for (var row = 0; row < matrix.height; ++row) {\n          COL: for (var col = 0; col < matrix.width; ++col) {\n            for (i = 0; i < chunks.length; ++i) {\n              var val = chunks[i].matrix.get(row, col);\n\n              if (!chunks[i].pred(val == null || val === \"\" ? 0 : val)) {\n                continue COL;\n              }\n            }\n\n            f(row, col);\n          }\n        }\n      }\n\n      var ARGS_COUNTIFS = [[\"m1\", \"matrix\"], [\"c1\", \"anyvalue\"], [[\"m2\", \"matrix\"], [\"c2\", \"anyvalue\"]]];\n      defineFunction(\"countifs\", function (m1, c1, rest) {\n        var count = 0;\n        rest.unshift(m1, c1);\n        forIFS(rest, function () {\n          count++;\n        });\n        return count;\n      }).args(ARGS_COUNTIFS);\n      var ARGS_SUMIFS = [[\"range\", \"matrix\"]].concat(ARGS_COUNTIFS);\n      defineFunction(\"sumifs\", function (range, m1, c1, args) {\n        // hack: insert a predicate that filters out non-numeric\n        // values; should also accept blank cells.  it's safe to\n        // modify args.\n        args.unshift(range, numericPredicate, m1, c1);\n        var sum = 0;\n        forIFS(args, function (row, col) {\n          var val = range.get(row, col);\n\n          if (val) {\n            sum += val;\n          }\n        });\n        return sum;\n      }).args(ARGS_SUMIFS); // similar to sumifs, but compute average of matching cells\n\n      defineFunction(\"averageifs\", function (range, m1, c1, args) {\n        args.unshift(range, numericPredicate, m1, c1);\n        var sum = 0,\n            count = 0;\n        forIFS(args, function (row, col) {\n          var val = range.get(row, col);\n\n          if (val == null || val === \"\") {\n            val = 0;\n          }\n\n          sum += val;\n          count++;\n        });\n        return count ? sum / count : new CalcError(\"DIV/0\");\n      }).args(ARGS_SUMIFS);\n      defineFunction(\"countif\", function (matrix, criteria) {\n        criteria = parseCriteria(criteria);\n        var count = 0;\n        matrix.each(function (val) {\n          if (criteria(val)) {\n            count++;\n          }\n        });\n        return count;\n      }).args([[\"range\", \"matrix\"], [\"*criteria\", \"anyvalue\"]]);\n      var ARGS_SUMIF = [[\"range\", \"matrix\"], [\"*criteria\", \"anyvalue\"], [\"sumRange\", [\"or\", \"area\", \"#matrix\", [\"null\", \"$range\"]]]];\n\n      function fetchSumRange(continuation) {\n        return function (callback, range, criteria, sumRange) {\n          var self = this;\n\n          if (sumRange instanceof Ref) {\n            // make sure it covers the same area as `range`, as the “spec” mentions:\n            //\n            //     The sum_range argument does not have to be the same size and shape as the\n            //     range argument. The actual cells that are added are determined by using the\n            //     upper leftmost cell in the sum_range argument as the beginning cell, and then\n            //     including cells that correspond in size and shape to the range argument.\n            //\n            // It does make one wonder, since only the top-left cell in `sumRange` matters, why\n            // should it be a range at all?  Oh well, Excel.\n            var r = sumRange.clone().toRangeRef();\n\n            if (r.width() != range.width || r.height() != range.height) {\n              if (!isFinite(r.topLeft.row)) {\n                r.topLeft.row = 0;\n              }\n\n              if (!isFinite(r.topLeft.col)) {\n                r.topLeft.col = 0;\n              }\n\n              r.bottomRight.row = r.topLeft.row + range.height - 1;\n              r.bottomRight.col = r.topLeft.col + range.width - 1;\n              return self.resolveCells([r], function () {\n                callback(continuation(range, criteria, self.asMatrix(r)));\n              });\n            }\n          }\n\n          callback(continuation(range, criteria, self.asMatrix(sumRange)));\n        };\n      }\n\n      defineFunction(\"sumif\", fetchSumRange(function (range, criteria, sumRange) {\n        var sum = 0;\n        criteria = parseCriteria(criteria);\n        range.each(function (val, row, col) {\n          if (criteria(val)) {\n            var v = sumRange.get(row, col);\n\n            if (numericPredicate(v)) {\n              sum += v || 0;\n            }\n          }\n        });\n        return sum;\n      })).argsAsync(ARGS_SUMIF);\n      defineFunction(\"averageif\", fetchSumRange(function (range, criteria, sumRange) {\n        var sum = 0,\n            count = 0;\n        criteria = parseCriteria(criteria);\n        range.each(function (val, row, col) {\n          if (criteria(val)) {\n            var v = sumRange.get(row, col);\n\n            if (numericPredicate(v)) {\n              sum += v || 0;\n              count++;\n            }\n          }\n        });\n        return count ? sum / count : new CalcError(\"DIV/0\");\n      })).argsAsync(ARGS_SUMIF);\n\n      (function (def) {\n        def(\"large\", function (numbers, nth) {\n          return numbers.sort(descending)[nth];\n        });\n        def(\"small\", function (numbers, nth) {\n          return numbers.sort(ascending)[nth];\n        });\n      })(function (name, handler) {\n        defineFunction(name, function (matrix, nth) {\n          var numbers = [];\n          var error = matrix.each(function (val) {\n            if (val instanceof CalcError) {\n              return val;\n            }\n\n            if (typeof val == \"number\") {\n              numbers.push(val);\n            }\n          });\n\n          if (error) {\n            return error;\n          }\n\n          if (nth > numbers.length) {\n            return new CalcError(\"NUM\");\n          }\n\n          return handler(numbers, nth - 1);\n        }).args([[\"array\", \"matrix\"], [\"*nth\", \"number++\"]]);\n      });\n\n      function _avg(numbers) {\n        return numbers.reduce(function (sum, num) {\n          return sum + num;\n        }, 0) / numbers.length;\n      }\n\n      function _var_sp(numbers, divisor, avg) {\n        if (avg == null) {\n          avg = _avg(numbers);\n        }\n\n        return numbers.reduce(function (sum, num) {\n          return sum + Math.pow(num - avg, 2);\n        }, 0) / divisor;\n      }\n\n      function _stdev_sp(numbers, divisor) {\n        return Math.sqrt(_var_sp(numbers, divisor));\n      } // https://support.office.com/en-sg/article/STDEV-S-function-7d69cf97-0c1f-4acf-be27-f3e83904cc23\n\n\n      defineFunction(\"stdev.s\", function (numbers) {\n        return _stdev_sp(numbers, numbers.length - 1);\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 2\", \"NUM\"]]]); // https://support.office.com/en-sg/article/STDEV-P-function-6e917c05-31a0-496f-ade7-4f4e7462f285\n\n      defineFunction(\"stdev.p\", function (numbers) {\n        return _stdev_sp(numbers, numbers.length);\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 2\", \"NUM\"]]]);\n      defineFunction(\"var.s\", function (numbers) {\n        return _var_sp(numbers, numbers.length - 1);\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 2\", \"NUM\"]]]);\n      defineFunction(\"var.p\", function (numbers) {\n        return _var_sp(numbers, numbers.length);\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 2\", \"NUM\"]]]);\n      defineFunction(\"median\", function (numbers) {\n        var n = numbers.length;\n        numbers.sort(ascending);\n\n        if (n % 2) {\n          // when length is odd, the median is the number in the middle\n          return numbers[n >> 1];\n        } // that's the average of the two middle numbers, written in in a fancy way\n\n\n        return (numbers[n >>= 1] + numbers[n - 1]) / 2;\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length > 0\", \"N/A\"]]]);\n      defineFunction(\"mode.sngl\", function (numbers) {\n        numbers.sort(ascending);\n        var prev = null,\n            count = 0,\n            max = 1,\n            mode = null;\n\n        for (var i = 0; i < numbers.length; ++i) {\n          var n = numbers[i];\n\n          if (n != prev) {\n            count = 1;\n            prev = n;\n          } else {\n            count++;\n          }\n\n          if (count > max) {\n            max = count;\n            mode = n;\n          }\n        }\n\n        return mode == null ? new CalcError(\"N/A\") : mode;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"mode.mult\", function (numbers) {\n        var seen = Object.create(null),\n            max = 2,\n            res = [];\n        numbers.forEach(function (num) {\n          var s = seen[num] || 0;\n          seen[num] = ++s;\n\n          if (s == max) {\n            res.push(num);\n          } else if (s > max) {\n            max = s;\n            res = [num];\n          }\n        });\n        var m = new Matrix(this);\n        res.forEach(function (num, i) {\n          m.set(i, 0, num);\n        });\n        return m;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n      defineFunction(\"geomean\", function (numbers) {\n        var n = numbers.length;\n        var p = numbers.reduce(function (p, num) {\n          if (num < 0) {\n            throw new CalcError(\"NUM\");\n          }\n\n          return p * num;\n        }, 1);\n        return Math.pow(p, 1 / n);\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length > 0\", \"NUM\"]]]);\n      defineFunction(\"harmean\", function (numbers) {\n        var n = numbers.length;\n        var s = numbers.reduce(function (s, num) {\n          if (!num) {\n            throw new CalcError(\"DIV/0\");\n          }\n\n          return s + 1 / num;\n        }, 0);\n        return n / s;\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length > 0\", \"NUM\"]]]);\n      defineFunction(\"trimmean\", function (numbers, p) {\n        var n = numbers.length;\n        numbers.sort(ascending);\n        var discard = Math.floor(n * p);\n\n        if (discard % 2) {\n          --discard;\n        }\n\n        discard /= 2;\n        var sum = 0;\n\n        for (var i = discard; i < n - discard; ++i) {\n          sum += numbers[i];\n        }\n\n        return sum / (n - discard * 2);\n      }).args([[\"numbers\", [\"collect\", \"number\", 1]], [\"percent\", [\"and\", \"number\", [\"[between)\", 0, 1]]], [\"?\", [\"assert\", \"$numbers.length > 0\", \"NUM\"]]]);\n      defineFunction(\"frequency\", function (data, bins) {\n        // apparently this always returns a vertical matrix in Excel, so we collect all numbers in\n        // bins instead of receiving it as a Matrix and try to mimic its shape.\n        data.sort(ascending);\n        bins.sort(ascending);\n        var prev = -Infinity;\n        var i = 0;\n\n        function count(max) {\n          var n = 0;\n\n          while (i < data.length && data[i] > prev && data[i] <= max) {\n            ++n;\n            ++i;\n          }\n\n          return n;\n        }\n\n        var m = new Matrix(this);\n        bins.forEach(function (val, i) {\n          var n = count(val);\n          prev = val;\n          m.set(i, 0, n);\n        });\n        m.set(m.height, 0, data.length - i);\n        return m;\n      }).args([[\"data\", [\"collect\", \"number\", 1]], [\"bins\", [\"collect\", \"number\", 1]]]);\n      defineFunction(\"rank.eq\", function (val, numbers, asc) {\n        numbers.sort(asc ? ascending : descending);\n        var pos = numbers.indexOf(val);\n        return pos < 0 ? new CalcError(\"N/A\") : pos + 1;\n      }).args([[\"value\", \"number\"], [\"numbers\", [\"collect\", \"number\"]], [\"order\", [\"or\", \"logical\", [\"null\", false]]]]);\n      defineAlias(\"rank\", \"rank.eq\");\n      defineFunction(\"rank.avg\", function (val, numbers, asc) {\n        numbers.sort(asc ? ascending : descending);\n        var pos = numbers.indexOf(val);\n\n        if (pos < 0) {\n          return new CalcError(\"N/A\");\n        }\n\n        for (var i = pos; numbers[i] == val; ++i) {}\n\n        return (pos + i + 1) / 2;\n      }).args([[\"value\", \"number\"], [\"numbers\", [\"collect\", \"number\"]], [\"order\", [\"or\", \"logical\", [\"null\", false]]]]); // formula available at https://support.office.microsoft.com/en-us/article/KURT-function-cbbc2312-dfa6-4cc4-b5c0-1b3c59cc9377\n\n      defineFunction(\"kurt\", function (numbers) {\n        var n = numbers.length;\n\n        var avg = _avg(numbers);\n\n        var variance = _var_sp(numbers, n - 1, avg);\n\n        var stddev = Math.sqrt(variance);\n        var sum = numbers.reduce(function (sum, num) {\n          return sum + Math.pow((num - avg) / stddev, 4);\n        }, 0);\n        return n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sum - 3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3));\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 4\", \"NUM\"]]]);\n\n      function _percentrank(numbers, x, exc) {\n        var nlt = 0,\n            ngt = 0,\n            left = null,\n            right = null,\n            found = false;\n        numbers.forEach(function (num) {\n          if (num < x) {\n            nlt++;\n            left = left == null ? num : Math.max(left, num);\n          } else if (num > x) {\n            ngt++;\n            right = right == null ? num : Math.min(right, num);\n          } else {\n            found = true;\n          }\n        });\n\n        if (!nlt && !ngt) {\n          return new CalcError(\"N/A\");\n        }\n\n        if (found) {\n          if (exc) {\n            return (nlt + 1) / (numbers.length + 1);\n          }\n\n          return nlt / (nlt + ngt);\n        }\n\n        return ((right - x) * _percentrank(numbers, left, exc) + (x - left) * _percentrank(numbers, right, exc)) / (right - left);\n      }\n\n      var ARGS_PERCENTRANK = [[\"array\", [\"collect\", \"number\", 1]], [\"x\", \"number\"], [\"significance\", [\"or\", [\"null\", 3], \"integer++\"]], [\"?\", [\"assert\", \"$array.length > 0\", \"NUM\"]]];\n      defineFunction(\"percentrank.inc\", function (numbers, x, significance) {\n        var p = _percentrank(numbers, x, 0);\n\n        p = p.toFixed(significance + 1);\n        return parseFloat(p.substr(0, p.length - 1));\n      }).args(ARGS_PERCENTRANK);\n      defineFunction(\"percentrank.exc\", function (numbers, x, significance) {\n        var p = _percentrank(numbers, x, 1);\n\n        p = p.toFixed(significance + 1);\n        return parseFloat(p.substr(0, p.length - 1));\n      }).args(ARGS_PERCENTRANK);\n      defineAlias(\"percentrank\", \"percentrank.inc\");\n\n      function _covariance(x, y, divisor) {\n        var sum = 0;\n\n        var ax = _avg(x);\n\n        var ay = _avg(y);\n\n        var n = x.length;\n\n        for (var i = 0; i < n; ++i) {\n          sum += (x[i] - ax) * (y[i] - ay);\n        }\n\n        return sum / divisor;\n      }\n\n      defineFunction(\"covariance.p\", function (x, y) {\n        return _covariance(x, y, x.length);\n      }).args([[\"array1\", [\"collect\", \"number\", 1]], [\"array2\", [\"collect\", \"number\", 1]], [\"?\", [\"assert\", \"$array1.length == $array2.length\", \"N/A\"]], [\"?\", [\"assert\", \"$array1.length > 0\", \"DIV/0\"]]]);\n      defineFunction(\"covariance.s\", function (x, y) {\n        return _covariance(x, y, x.length - 1);\n      }).args([[\"array1\", [\"collect\", \"number\", 1]], [\"array2\", [\"collect\", \"number\", 1]], [\"?\", [\"assert\", \"$array1.length == $array2.length\", \"N/A\"]], [\"?\", [\"assert\", \"$array1.length > 1\", \"DIV/0\"]]]);\n      defineAlias(\"covar\", \"covariance.p\");\n      /* -----[ Factorials ]----- */\n\n      var _fact = util.memoize(function (n) {\n        for (var i = 2, fact = 1; i <= n; ++i) {\n          fact *= i;\n        }\n\n        return fact;\n      });\n\n      defineFunction(\"fact\", _fact).args([[\"*n\", \"integer+\"]]);\n      defineFunction(\"factdouble\", function (n) {\n        for (var i = 2 + (n & 1), fact = 1; i <= n; i += 2) {\n          fact *= i;\n        }\n\n        return fact;\n      }).args([[\"*n\", \"integer+\"]]);\n      defineFunction(\"multinomial\", function (numbers) {\n        var div = 1,\n            sum = 0;\n        numbers.forEach(function (n) {\n          if (n < 0) {\n            throw new CalcError(\"NUM\");\n          }\n\n          sum += n;\n          div *= _fact(n);\n        });\n        return _fact(sum) / div;\n      }).args([[\"numbers\", [\"collect\", \"number\"]]]);\n\n      var _combinations = util.memoize(function (n, k) {\n        for (var f1 = k + 1, f2 = 1, p1 = 1, p2 = 1; f2 <= n - k; ++f1, ++f2) {\n          p1 *= f1;\n          p2 *= f2;\n        }\n\n        return p1 / p2;\n      });\n\n      defineFunction(\"combin\", _combinations).args([[\"*n\", \"integer++\"], [\"*k\", [\"and\", \"integer\", [\"[between]\", 0, \"$n\"]]]]);\n      defineFunction(\"combina\", function (n, k) {\n        return _combinations(n + k - 1, n - 1);\n      }).args([[\"*n\", \"integer++\"], [\"*k\", [\"and\", \"integer\", [\"[between]\", 1, \"$n\"]]]]);\n      /* -----[ Statistical functions ]----- */\n\n      defineFunction(\"average\", function (numbers) {\n        var sum = numbers.reduce(function (sum, num) {\n          return sum + num;\n        }, 0);\n        return sum / numbers.length;\n      }).args([// most numeric functions must treat booleans as numbers (1 for TRUE\n      // and 0 for FALSE), but AVERAGE shouldn't.\n      [\"numbers\", [\"collect\", \"number!\"]], [\"?\", [\"assert\", \"$numbers.length > 0\", \"DIV/0\"]]]);\n      defineFunction(\"averagea\", function (values) {\n        var sum = 0,\n            count = 0;\n        values.forEach(function (num) {\n          if (typeof num != \"string\") {\n            sum += num;\n          }\n\n          ++count;\n        });\n        return count ? sum / count : new CalcError(\"DIV/0\");\n      }).args([[\"values\", [\"collect\", \"anyvalue\"]]]);\n\n      function _percentile(numbers, rank) {\n        numbers.sort(ascending);\n        var n = numbers.length;\n        var k = rank | 0,\n            d = rank - k;\n\n        if (k === 0) {\n          return numbers[0];\n        }\n\n        if (k >= n) {\n          return numbers[n - 1];\n        }\n\n        --k;\n        return numbers[k] + d * (numbers[k + 1] - numbers[k]);\n      }\n\n      function _percentile_inc(numbers, p) {\n        // algorithm from https://en.wikipedia.org/wiki/Percentile#Microsoft_Excel_method\n        var rank = p * (numbers.length - 1) + 1;\n        return _percentile(numbers, rank);\n      }\n\n      function _percentile_exc(numbers, p) {\n        // https://en.wikipedia.org/wiki/Percentile#NIST_method\n        var rank = p * (numbers.length + 1);\n        return _percentile(numbers, rank);\n      }\n\n      defineFunction(\"percentile.inc\", _percentile_inc).args([[\"numbers\", [\"collect\", \"number\", 1]], [\"p\", [\"and\", \"number\", [\"[between]\", 0, 1]]]]);\n      defineFunction(\"percentile.exc\", _percentile_exc).args([[\"numbers\", [\"collect\", \"number\", 1]], [\"p\", [\"and\", \"number\", [\"(between)\", 0, 1]]]]);\n      defineFunction(\"quartile.inc\", function (numbers, quarter) {\n        return _percentile_inc(numbers, quarter / 4);\n      }).args([[\"numbers\", [\"collect\", \"number\", 1]], [\"quarter\", [\"values\", 0, 1, 2, 3, 4]]]);\n      defineFunction(\"quartile.exc\", function (numbers, quarter) {\n        return _percentile_exc(numbers, quarter / 4);\n      }).args([[\"numbers\", [\"collect\", \"number\", 1]], [\"quarter\", [\"values\", 0, 1, 2, 3, 4]]]);\n      defineAlias(\"quartile\", \"quartile.inc\");\n      defineAlias(\"percentile\", \"percentile.inc\");\n      var AGGREGATE_FUNCS = [\"AVERAGE\", \"COUNT\", \"COUNTA\", \"MAX\", \"MIN\", \"PRODUCT\", \"STDEV.S\", \"STDEV.P\", \"SUM\", \"VAR.S\", \"VAR.P\", \"MEDIAN\", \"MODE.SNGL\", \"LARGE\", \"SMALL\", \"PERCENTILE.INC\", \"QUARTILE.INC\", \"PERCENTILE.EXC\", \"QUARTILE.EXC\"];\n\n      function fetchValuesForAggregate(self, args, options) {\n        var values = [];\n        var opt_ignore_hidden_rows = 1;\n        var opt_ignore_errors = 2;\n        var opt_use_aggregates = 4;\n\n        (function fetchValues(args) {\n          if (args instanceof Ref) {\n            self.getRefCells(args, true).forEach(function (cell) {\n              var value = cell.value;\n\n              if (options & opt_ignore_hidden_rows && cell.hidden) {\n                return;\n              }\n\n              if (cell.formula) {\n                // XXX: formula.print is fast, but still, can't we do any better here?\n                //      perhaps access the input string directly somehow?\n                var str = cell.formula.print(cell.row, cell.col);\n\n                if (/^\\s*(?:aggregate|subtotal)\\s*\\(/i.test(str)) {\n                  if (!(options & opt_use_aggregates)) {\n                    return;\n                  }\n                }\n              }\n\n              if (options & opt_ignore_errors && value instanceof CalcError) {\n                return;\n              }\n\n              if (typeof value == \"number\" || value instanceof CalcError) {\n                values.push(value);\n              }\n            });\n          } else if (Array.isArray(args)) {\n            for (var i = 0; i < args.length; ++i) {\n              fetchValues(args[i]);\n            }\n          } else if (args instanceof Matrix) {\n            args.each(fetchValues);\n          } else if (typeof args == \"number\") {\n            values.push(args);\n          } else if (args instanceof CalcError && !(options & opt_ignore_errors)) {\n            values.push(args);\n          }\n        })(args);\n\n        return values;\n      } // AGGREGATE function\n      //\n      // https://support.office.com/en-SG/article/aggregate-function-c8caed56-07df-4aeb-9741-23693ffbe525\n      //\n      // we can only partially type-check this function.  also, we need to use the async version in\n      // order to resolve references and delegate values to the function to aggregate.\n\n\n      defineFunction(\"aggregate\", function (callback, funcId, options, args) {\n        // options is a bit field.  that makes sense; it's the documentation which doesn't.\n        var self = this;\n        self.resolveCells(args, function () {\n          var values;\n\n          if (funcId > 12) {\n            // \"array form\"\n            values = fetchValuesForAggregate(self, args[0], options);\n            var k = args[1];\n\n            if (k instanceof CellRef) {\n              k = self.getRefData(k);\n            }\n\n            if (typeof k != \"number\") {\n              return callback(new CalcError(\"VALUE\"));\n            }\n          } else {\n            values = fetchValuesForAggregate(self, args, options);\n          }\n\n          self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);\n        });\n      }).argsAsync([[\"funcId\", [\"values\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]], [\"options\", [\"or\", [\"null\", 0], [\"values\", 0, 1, 2, 3, 4, 5, 6, 7]]], [\"args\", \"rest\"]]);\n      defineFunction(\"subtotal\", function (callback, funcId) {\n        var self = this;\n        var ignoreHidden = funcId > 100;\n\n        if (ignoreHidden) {\n          funcId -= 100;\n        }\n\n        var args = [];\n\n        for (var i = 2; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n\n        self.resolveCells(args, function () {\n          var values = fetchValuesForAggregate(self, args, ignoreHidden ? 1 : 0);\n          self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);\n        });\n      }).argsAsync([[\"funcId\", [\"values\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]], [\"+\", [\"ref\", [\"or\", \"ref\", \"#matrix\"]]]]); // https://support.office.com/en-sg/article/AVEDEV-function-ec78fa01-4755-466c-9a2b-0c4f9eacaf6d\n\n      defineFunction(\"avedev\", function (numbers) {\n        var avg = numbers.reduce(function (sum, num) {\n          return sum + num;\n        }, 0) / numbers.length;\n        return numbers.reduce(function (sum, num) {\n          return sum + Math.abs(num - avg);\n        }, 0) / numbers.length;\n      }).args([[\"numbers\", [\"collect\", \"number\"]], [\"?\", [\"assert\", \"$numbers.length >= 2\", \"NUM\"]]]);\n\n      function _binom_dist(x, n, p, cumulative) {\n        if (!cumulative) {\n          return _combinations(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);\n        } else {\n          var sum = 0;\n\n          for (var j = 0; j <= x; ++j) {\n            sum += _combinations(n, j) * Math.pow(p, j) * Math.pow(1 - p, n - j);\n          }\n\n          return sum;\n        }\n      }\n\n      defineFunction(\"binom.dist\", _binom_dist).args([[\"successes\", \"integer+\"], [\"trials\", [\"and\", \"integer\", [\"assert\", \"$trials >= $successes\"]]], [\"probability\", [\"and\", \"number\", [\"[between]\", 0, 1]]], [\"cumulative\", \"logical\"]]);\n      defineAlias(\"binomdist\", \"binom.dist\");\n      defineFunction(\"binom.inv\", function (n, p, alpha) {\n        // XXX: could a binary search be faster?\n        for (var x = 0; x <= n; ++x) {\n          if (_binom_dist(x, n, p, true) >= alpha) {\n            return x;\n          }\n        }\n\n        return new CalcError(\"N/A\"); // XXX: is this right?\n      }).args([[\"trials\", \"integer+\"], [\"probability\", [\"and\", \"number\", [\"[between]\", 0, 1]]], [\"alpha\", [\"and\", \"number\", [\"[between]\", 0, 1]]]]);\n      defineAlias(\"critbinom\", \"binom.inv\");\n      defineFunction(\"binom.dist.range\", function (n, p, s, s2) {\n        var sum = 0;\n\n        for (var k = s; k <= s2; ++k) {\n          sum += _combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n        }\n\n        return sum;\n      }).args([[\"trials\", \"integer+\"], [\"probability\", [\"and\", \"number\", [\"[between]\", 0, 1]]], [\"successes_min\", [\"and\", \"integer\", [\"[between]\", 0, \"$trials\"]]], [\"successes_max\", [\"or\", [\"and\", \"integer\", [\"[between]\", \"$successes_min\", \"$trials\"]], [\"null\", \"$successes_min\"]]]]);\n      defineFunction(\"negbinom.dist\", function (x, k, p, cumulative) {\n        if (cumulative) {\n          var sum = 0;\n\n          while (x >= 0) {\n            sum += _combinations(x + k - 1, x) * Math.pow(p, k) * Math.pow(1 - p, x);\n            x--;\n          }\n\n          return sum;\n        }\n\n        return _combinations(x + k - 1, x) * Math.pow(p, k) * Math.pow(1 - p, x);\n      }).args([[\"number_f\", \"integer+\"], [\"number_s\", \"integer+\"], [\"probability_s\", [\"and\", \"number\", [\"[between]\", 0, 1]]], [\"cumulative\", \"logical\"]]);\n      defineAlias(\"negbinomdist\", \"negbinom.dist\");\n      /* -----[ lookup functions ]----- */\n\n      defineFunction(\"address\", function (row, col, abs, a1, sheet) {\n        // by some lucky coincidence, we get the corret `rel` value by just subtracting 1 from the\n        // abs argument\n        var cell = new CellRef(row - 1, col - 1, abs - 1);\n\n        if (sheet) {\n          cell.setSheet(sheet, true);\n        }\n\n        return a1 ? cell.print(0, 0) : cell.print();\n      }).args([[\"row\", \"integer++\"], [\"col\", \"integer++\"], [\"abs\", [\"or\", [\"null\", 1], [\"values\", 1, 2, 3, 4]]], [\"a1\", [\"or\", [\"null\", true], \"logical\"]], [\"sheet\", [\"or\", \"null\", \"string\"]]]);\n      defineFunction(\"areas\", function (ref) {\n        var count = 0;\n\n        (function loop(x) {\n          if (x instanceof CellRef || x instanceof RangeRef) {\n            count++;\n          } else if (x instanceof UnionRef) {\n            x.refs.forEach(loop);\n          } // XXX: NameRef if we add support\n\n        })(ref);\n\n        return count;\n      }).args([[\"ref\", \"ref\"]]);\n      defineFunction(\"choose\", function (index, args) {\n        if (index > args.length) {\n          return new CalcError(\"N/A\");\n        } else {\n          return args[index - 1];\n        }\n      }).args([[\"*index\", \"integer\"], [\"+\", [\"value\", \"anything\"]]]);\n      defineFunction(\"column\", function (ref) {\n        if (!ref) {\n          return this.formula.col + 1;\n        }\n\n        if (ref instanceof CellRef) {\n          return ref.col + 1;\n        }\n\n        return this.asMatrix(ref).mapCol(function (col) {\n          return col + ref.topLeft.col + 1;\n        });\n      }).args([[\"ref\", [\"or\", \"area\", \"null\"]]]);\n      defineFunction(\"columns\", function (m) {\n        return m instanceof Ref ? m.width() : m.width;\n      }).args([[\"ref\", [\"or\", \"area\", \"#matrix\"]]]);\n      defineFunction(\"formulatext\", function (ref) {\n        var cell = this.getRefCells(ref)[0]; // XXX: overkill, but oh well.\n\n        if (!cell.formula) {\n          return new CalcError(\"N/A\");\n        }\n\n        return cell.formula.print(cell.row, cell.col);\n      }).args([[\"ref\", \"ref\"]]);\n      defineFunction(\"hlookup\", function (value, m, row, approx) {\n        var resultCol = null;\n        m.eachCol(function (col) {\n          var data = m.get(0, col);\n\n          if (approx) {\n            if (data > value) {\n              return true;\n            }\n\n            resultCol = col;\n          } else if (data === value) {\n            resultCol = col;\n            return true;\n          }\n        });\n\n        if (resultCol == null) {\n          return new CalcError(\"N/A\");\n        }\n\n        return m.get(row - 1, resultCol);\n      }).args([[\"value\", \"anyvalue\"], [\"range\", \"matrix\"], [\"row\", \"integer++\"], [\"approx\", [\"or\", \"logical\", [\"null\", true]]]]);\n      defineFunction(\"index\", function (callback, ref, row, col, areanum) {\n        var self = this;\n\n        if (ref instanceof UnionRef) {\n          ref = ref.refs[areanum - 1];\n        }\n\n        if (!row && !col || !ref) {\n          return callback(new CalcError(\"N/A\"));\n        }\n\n        if (ref instanceof CellRef) {\n          ref = ref.toRangeRef();\n        }\n\n        if (ref instanceof RangeRef) {\n          if (row && col) {\n            if (col > ref.width() || row > ref.height()) {\n              return callback(new CalcError(\"REF\"));\n            } // fetching a single cell\n\n\n            var cell = ref.toCell(row - 1, col - 1);\n            self.resolveCells([cell], function () {\n              callback(self.getRefData(cell));\n            });\n            return;\n          }\n\n          if (!row) {\n            // fetch a full column\n            var colRange = ref.toColumn(col - 1);\n            self.resolveCells([colRange], function () {\n              callback(self.asMatrix(colRange));\n            });\n            return;\n          }\n\n          if (!col) {\n            // fetch a full row\n            var rowRange = ref.toRow(row - 1);\n            self.resolveCells([rowRange], function () {\n              callback(self.asMatrix(rowRange));\n            });\n            return;\n          }\n        } else if (ref instanceof Matrix) {\n          if (ref.width > 1 && ref.height > 1) {\n            if (row && col) {\n              return callback(ref.get(row - 1, col - 1));\n            }\n\n            if (!row) {\n              return callback(ref.mapRow(function (row) {\n                return ref.get(row, col - 1);\n              }));\n            }\n\n            if (!col) {\n              return callback(ref.mapCol(function (col) {\n                return ref.get(row - 1, col);\n              }));\n            }\n          }\n\n          if (ref.width == 1) {\n            return callback(ref.get(row - 1, 0));\n          }\n\n          if (ref.height == 1) {\n            return callback(ref.get(0, col - 1));\n          }\n        } else {\n          callback(new CalcError(\"REF\"));\n        }\n      }).argsAsync([[\"range\", [\"or\", \"ref\", \"matrix\"]], [\"row\", [\"or\", \"integer+\", \"null\"]], [\"col\", [\"or\", \"integer+\", \"null\"]], [\"areanum\", [\"or\", \"integer++\", [\"null\", 1]]]]);\n      defineFunction(\"indirect\", function (thing) {\n        try {\n          // XXX: does more work than needed.  we could go for parseReference, but that one\n          // doesn't (yet?) support \"SheetName!\" prefix.\n          var f = this.formula;\n          var exp = calc.parseFormula(f.sheet, f.row, f.col, thing);\n          var ref = exp.ast;\n\n          if (ref instanceof NameRef) {\n            ref = this.ss.nameValue(ref, f.sheet, f.row, f.col);\n          }\n\n          if (!(ref instanceof Ref)) {\n            throw 1;\n          }\n\n          return ref.absolute(f.row, f.col);\n        } catch (ex) {\n          return new CalcError(\"REF\");\n        }\n      }).args([[\"thing\", \"string\"]]); // XXX: LOOKUP.  seems to be deprecated in favor of HLOOKUP/VLOOKUP\n      // XXX: double-check this one.\n\n      defineFunction(\"match\", function (val, m, type) {\n        var index = 1,\n            cmp;\n\n        if (type === 0) {\n          cmp = parseCriteria(val);\n        } else if (type === -1) {\n          cmp = parseCriteria(\"<=\" + val);\n        } else if (type === 1) {\n          cmp = parseCriteria(\">=\" + val);\n        }\n\n        if (m.each(function (el) {\n          if (el != null && cmp(el)) {\n            if (type !== 0 && val != el) {\n              --index;\n            }\n\n            return true;\n          }\n\n          index++;\n        }, true) && index > 0) {\n          return index;\n        } else {\n          return new CalcError(\"N/A\");\n        }\n      }).args([[\"value\", \"anyvalue\"], [\"range\", \"matrix\"], [\"type\", [\"or\", [\"values\", -1, 0, 1], [\"null\", 1]]]]);\n      defineFunction(\"offset\", function (ref, rows, cols, height, width) {\n        var topLeft = (ref instanceof CellRef ? ref : ref.topLeft).clone();\n        topLeft.row += rows;\n        topLeft.col += cols;\n\n        if (topLeft.row < 0 || topLeft.col < 0) {\n          return new CalcError(\"VALUE\");\n        }\n\n        if (height > 1 || width > 1) {\n          return new RangeRef(topLeft, new CellRef(topLeft.row + height - 1, topLeft.col + width - 1)).setSheet(ref.sheet, ref.hasSheet());\n        }\n\n        return topLeft;\n      }).args([[\"ref\", \"area\"], [\"*rows\", \"integer\"], [\"*cols\", \"integer\"], [\"*height\", [\"or\", \"integer++\", [\"null\", \"$ref.height()\"]]], [\"*width\", [\"or\", \"integer++\", [\"null\", \"$ref.width()\"]]]]);\n      defineFunction(\"row\", function (ref) {\n        if (!ref) {\n          return this.formula.row + 1;\n        }\n\n        if (ref instanceof CellRef) {\n          return ref.row + 1;\n        }\n\n        return this.asMatrix(ref).mapRow(function (row) {\n          return row + ref.topLeft.row + 1;\n        });\n      }).args([[\"ref\", [\"or\", \"area\", \"null\"]]]);\n      defineFunction(\"rows\", function (m) {\n        return m instanceof Ref ? m.height() : m.height;\n      }).args([[\"ref\", [\"or\", \"area\", \"#matrix\"]]]);\n      defineFunction(\"vlookup\", function (value, m, col, approx) {\n        var resultRow = null;\n\n        if (typeof value != \"number\") {\n          approx = false;\n        }\n\n        if (typeof value == \"string\") {\n          value = value.toLowerCase();\n        }\n\n        m.eachRow(function (row) {\n          var data = m.get(row, 0);\n\n          if (approx) {\n            if (data > value) {\n              return true;\n            }\n\n            resultRow = row;\n          } else {\n            if (typeof data == \"string\") {\n              data = data.toLowerCase();\n            }\n\n            if (data === value) {\n              resultRow = row;\n              return true;\n            }\n          }\n        });\n\n        if (resultRow == null) {\n          return new CalcError(\"N/A\");\n        }\n\n        return m.get(resultRow, col - 1);\n      }).args([[\"value\", \"anyvalue\"], [\"range\", \"matrix\"], [\"col\", \"integer++\"], [\"approx\", [\"or\", \"logical\", [\"null\", true]]]]);\n      /* -----[ Date and time functions ]----- */\n\n      defineFunction(\"date\", function (year, month, date) {\n        return packDate(year, month - 1, date);\n      }).args([[\"*year\", \"integer\"], [\"*month\", \"integer\"], [\"*date\", \"integer\"]]);\n      defineFunction(\"day\", function (date) {\n        return unpackDate(date).date;\n      }).args([[\"*date\", \"date\"]]);\n      defineFunction(\"month\", function (date) {\n        return unpackDate(date).month + 1;\n      }).args([[\"*date\", \"date\"]]);\n      defineFunction(\"year\", function (date) {\n        return unpackDate(date).year;\n      }).args([[\"*date\", \"date\"]]);\n      defineFunction(\"weekday\", function (date) {\n        // XXX: TODO type\n        return unpackDate(date).day + 1;\n      }).args([[\"*date\", \"date\"]]); // https://support.office.com/en-GB/article/WEEKNUM-function-e5c43a03-b4ab-426c-b411-b18c13c75340\n      // XXX: this is a mess.\n\n      defineFunction(\"weeknum\", function (date, type) {\n        var fw = packDate(unpackDate(date).year, 0, 1);\n        var sy = unpackDate(fw);\n        var diff;\n\n        if (type == 21) {\n          // Monday-based weeks, first week is the one containing the first Thursday of the year\n          // we want to place in fw and sy the first Thursday\n          diff = 3 - (sy.day + 6) % 7;\n\n          if (diff < 0) {\n            diff += 7;\n          }\n\n          fw += diff;\n          sy.date += diff;\n          sy.day = 4; // Thursday.\n\n          type = 1;\n        } else {\n          if (type == 1) {\n            type = 0;\n          } else if (type == 2) {\n            type = 1;\n          } else {\n            type = (type - 10) % 7;\n          } // finally compatible with what we got:\n          // type == 0 means week starts on Sunday\n          //         1                      Monday\n          //         2                      Tuesday\n          // ...\n\n        }\n\n        diff = sy.day - type;\n\n        if (diff < 0) {\n          diff += 7;\n        }\n\n        fw -= diff;\n        return Math.ceil((date + 1 - fw) / 7);\n      }).args([[\"*date\", \"date\"], [\"*type\", [\"or\", [\"null\", 1], [\"values\", 1, 2, 11, 12, 13, 14, 15, 16, 17, 21]]]]);\n\n      function weeksInYear(year) {\n        var d = unpackDate(packDate(year, 0, 1));\n\n        if (d.day == 4 || d.day == 3 && runtime.isLeapYear(year)) {\n          // long year\n          return 53;\n        }\n\n        return 52;\n      }\n\n      defineFunction(\"isoweeknum\", function isoweeknum(date) {\n        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_of_a_given_date\n        var d = unpackDate(date);\n        var dow = d.day || 7;\n        var wk = Math.floor((d.ord - dow + 10) / 7);\n\n        if (wk < 1) {\n          return weeksInYear(d.year - 1);\n        } else if (wk == 53 && wk > weeksInYear(d.year)) {\n          return 1;\n        }\n\n        return wk;\n      }).args([[\"*date\", \"date\"]]);\n      defineFunction(\"now\", function () {\n        return runtime.dateToSerial(new Date());\n      }).args([]);\n      defineFunction(\"today\", function () {\n        return runtime.dateToSerial(new Date()) | 0;\n      }).args([]);\n      defineFunction(\"time\", function (hh, mm, ss) {\n        return runtime.packTime(hh, mm, ss, 0);\n      }).args([[\"*hours\", \"integer\"], [\"*minutes\", \"integer\"], [\"*seconds\", \"integer\"]]);\n      defineFunction(\"hour\", function (time) {\n        return runtime.unpackTime(time).hours;\n      }).args([[\"*time\", \"datetime\"]]);\n      defineFunction(\"minute\", function (time) {\n        return runtime.unpackTime(time).minutes;\n      }).args([[\"*time\", \"datetime\"]]);\n      defineFunction(\"second\", function (time) {\n        return runtime.unpackTime(time).seconds;\n      }).args([[\"*time\", \"datetime\"]]);\n      defineFunction(\"edate\", function (base, months) {\n        var d = unpackDate(base);\n        var m = d.month + months;\n        var y = d.year + Math.floor(m / 12);\n        m %= 12;\n\n        if (m < 0) {\n          m += 12;\n        }\n\n        d = Math.min(d.date, daysInMonth(y, m));\n        return packDate(y, m, d);\n      }).args([[\"*start_date\", \"date\"], [\"*months\", \"integer\"]]);\n      defineFunction(\"eomonth\", function (base, months) {\n        var d = unpackDate(base);\n        var m = d.month + months;\n        var y = d.year + Math.floor(m / 12);\n        m %= 12;\n\n        if (m < 0) {\n          m += 12;\n        }\n\n        d = daysInMonth(y, m);\n        return packDate(y, m, d);\n      }).args([[\"*start_date\", \"date\"], [\"*months\", \"integer\"]]);\n      defineFunction(\"workday\", function (date, n, holidays) {\n        // XXX: the algorithm here is pretty dumb, can we do better?\n        var inc = n > 0 ? 1 : -1;\n        n = Math.abs(n);\n        var dow = unpackDate(date).day;\n\n        while (n > 0) {\n          date += inc;\n          dow = (dow + inc) % 7;\n\n          if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {\n            --n;\n          }\n        }\n\n        return date;\n      }).args([[\"start_date\", \"date\"], [\"days\", \"integer\"], [\"holidays\", [\"collect\", \"date\"]]]);\n      defineFunction(\"networkdays\", function (date, end, holidays) {\n        // XXX: the algorithm here is pretty dumb, can we do better?\n        if (date > end) {\n          var tmp = date;\n          date = end;\n          end = tmp;\n        }\n\n        var count = 0;\n        var dow = unpackDate(date).day;\n\n        while (date <= end) {\n          if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {\n            count++;\n          }\n\n          date++;\n          dow = (dow + 1) % 7;\n        }\n\n        return count;\n      }).args([[\"start_date\", \"date\"], [\"end_date\", \"date\"], [\"holidays\", [\"collect\", \"date\"]]]);\n      defineFunction(\"days\", function (end, start) {\n        return end - start;\n      }).args([[\"*start_date\", \"date\"], [\"*end_date\", \"date\"]]);\n\n      function _days_360(start, end, method) {\n        var d1 = unpackDate(start);\n        var d2 = unpackDate(end); // https://en.wikipedia.org/wiki/360-day_calendar\n        // humanity is a mess.\n\n        if (method) {\n          // EU method\n          if (d1.date == 31) {\n            d1.date = 30;\n          }\n\n          if (d2.date == 31) {\n            d2.date = 30;\n          }\n        } else {\n          // US method\n          if (d1.month == 1 && d2.month == 1 && d1.date == daysInMonth(d1.year, 1) && d2.date == daysInMonth(d2.year, 1)) {\n            d2.date = 30;\n          }\n\n          if (d1.date == daysInMonth(d1.year, d1.month)) {\n            d1.date = 30;\n\n            if (d2.date == 31) {\n              d2.date = 30;\n            }\n          } else {\n            if (d1.date == 30 && d2.date == 31) {\n              d2.date = 30;\n            }\n          }\n        }\n\n        return 360 * (d2.year - d1.year) + 30 * (d2.month - d1.month) + (d2.date - d1.date);\n      }\n\n      runtime._days_360 = _days_360;\n      defineFunction(\"days360\", _days_360).args([[\"*start_date\", \"date\"], [\"*end_date\", \"date\"], [\"*method\", [\"or\", \"logical\", [\"null\", false]]]]);\n      defineFunction(\"yearfrac\", function (start, end, method) {\n        switch (method) {\n          case 0:\n            return _days_360(start, end, false) / 360;\n\n          case 1:\n            return (end - start) / daysInYear(unpackDate(start).year);\n\n          case 2:\n            return (end - start) / 360;\n\n          case 3:\n            return (end - start) / 365;\n\n          case 4:\n            return _days_360(start, end, true) / 360;\n        }\n      }).args([[\"*start_date\", \"date\"], [\"*end_date\", \"date\"], [\"*method\", [\"or\", [\"null\", 0], [\"values\", 0, 1, 2, 3, 4]]]]);\n      defineFunction(\"datevalue\", function (text) {\n        var date = runtime.parseDate(text);\n\n        if (date) {\n          return runtime.dateToSerial(date);\n        }\n\n        return new CalcError(\"VALUE\");\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"timevalue\", function (text) {\n        var m = text.toLowerCase().match(/(\\d+):(\\d+)(:(\\d+)(\\.(\\d+))?)?\\s*(am?|pm?)?/);\n\n        if (m) {\n          var hh = parseFloat(m[1]);\n          var mm = parseFloat(m[2]);\n          var ss = m[3] ? parseFloat(m[4]) : 0; //var ms = m[5] ? parseFloat(m[6]) : 0;\n\n          var ampm = m[7];\n\n          if (ampm && (hh > 12 || hh < 1)) {\n            return new CalcError(\"VALUE\");\n          }\n\n          if (/^p/.test(ampm)) {\n            hh += 12;\n          }\n\n          return runtime.packTime(hh, mm, ss, 0);\n        }\n\n        return new CalcError(\"VALUE\");\n      }).args([[\"*text\", \"string\"]]);\n      /* -----[ Matrix functions ]----- */\n\n      defineFunction(\"mdeterm\", function (m) {\n        var error = m.each(function (val) {\n          if (typeof val != \"number\") {\n            return new CalcError(\"VALUE\");\n          }\n        }, true);\n        return error || m.determinant();\n      }).args([[\"m\", [\"and\", \"matrix\", [\"assert\", \"$m.width == $m.height\"]]]]);\n      defineFunction(\"transpose\", function (m) {\n        return m.transpose();\n      }).args([[\"range\", \"matrix\"]]);\n      defineFunction(\"mmult\", function (a, b) {\n        return a.multiply(b);\n      }).args([[\"a\", \"matrix\"], [\"b\", [\"and\", \"matrix\", [\"assert\", \"$b.height == $a.width\"]]]]);\n      defineFunction(\"munit\", function (n) {\n        return new Matrix(this).unit(n);\n      }).args([[\"n\", \"integer+\"]]);\n      defineFunction(\"minverse\", function (m) {\n        var error = m.each(function (val) {\n          if (typeof val != \"number\") {\n            return new CalcError(\"VALUE\");\n          }\n        }, true);\n        return error || m.inverse() || new CalcError(\"VALUE\");\n      }).args([[\"m\", [\"and\", \"matrix\", [\"assert\", \"$m.width == $m.height\"]]]]);\n      /* -----[ Other ]----- */\n\n      defineFunction(\"rand\", function () {\n        return Math.random();\n      }).args([]);\n      defineFunction(\"randbetween\", function (min, max) {\n        return min + Math.floor((max - min + 1) * Math.random());\n      }).args([[\"min\", \"integer\"], [\"max\", [\"and\", \"integer\", [\"assert\", \"$max >= $min\"]]]]);\n      defineFunction(\"true\", function () {\n        return true;\n      }).args([]);\n      defineFunction(\"false\", function () {\n        return true;\n      }).args([]);\n      defineFunction(\"roman\", function (num) {\n        return util.arabicToRoman(num).toUpperCase();\n      }).args([[\"*number\", \"integer\"]]);\n      defineFunction(\"arabic\", function (rom) {\n        var num = util.romanToArabic(rom);\n        return num == null ? new CalcError(\"VALUE\") : num;\n      }).args([[\"*roman\", \"string\"]]);\n      defineFunction(\"base\", function (number, radix, minLen) {\n        var str = number.toString(radix).toUpperCase();\n\n        while (str.length < minLen) {\n          str = \"0\" + str;\n        }\n\n        return str;\n      }).args([[\"*number\", \"integer\"], [\"*radix\", [\"and\", \"integer\", [\"[between]\", 2, 36]]], [\"*minLen\", [\"or\", \"integer+\", [\"null\", 0]]]]);\n      defineFunction(\"decimal\", function (text, radix) {\n        text = text.toUpperCase();\n        var val = 0;\n\n        for (var i = 0; i < text.length; ++i) {\n          var d = text.charCodeAt(i);\n\n          if (d >= 48 && d <= 57) {\n            d -= 48;\n          } else if (d >= 65 && d < 55 + radix) {\n            d -= 55;\n          } else {\n            return new CalcError(\"VALUE\");\n          }\n\n          val = val * radix + d;\n        }\n\n        return val;\n      }).args([[\"*text\", \"string\"], [\"*radix\", [\"and\", \"integer\", [\"[between]\", 2, 36]]]]);\n      /* -----[ String functions ]----- */\n\n      defineFunction(\"char\", function (code) {\n        return String.fromCharCode(code);\n      }).args([[\"*code\", \"integer+\"]]); // From XRegExp\n\n      var RX_NON_PRINTABLE = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\n      defineFunction(\"clean\", function (text) {\n        return text.replace(RX_NON_PRINTABLE, \"\");\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"code\", function (text) {\n        return text.charAt(0);\n      }).args([[\"*text\", \"string\"]]);\n      defineAlias(\"unichar\", \"char\");\n      defineAlias(\"unicode\", \"code\");\n      defineFunction(\"concatenate\", function (args) {\n        var out = \"\";\n\n        for (var i = 0; i < args.length; ++i) {\n          out += args[i];\n        }\n\n        return out;\n      }).args([[\"+\", [\"*text\", \"string\"]]]);\n      defineFunction(\"dollar\", function (number, decimals) {\n        var format = \"$#,##0DECIMALS;($#,##0DECIMALS)\";\n        var dec = \"\";\n        var denomitator = 1;\n\n        while (decimals-- > 0) {\n          dec += \"0\";\n        }\n\n        while (++decimals < 0) {\n          denomitator *= 10;\n        }\n\n        if (dec !== \"\") {\n          dec = \".\" + dec;\n        } else if (denomitator !== 1) {\n          number = Math.round(number / denomitator) * denomitator;\n        }\n\n        format = format.replace(/DECIMALS/g, dec);\n        return spreadsheet.formatting.text(number, format);\n      }).args([[\"*number\", \"number\"], [\"*decimals\", [\"or\", \"integer\", [\"null\", 2]]]]);\n      defineFunction(\"exact\", function (a, b) {\n        return a === b;\n      }).args([[\"*text1\", \"string\"], [\"*text2\", \"string\"]]);\n      defineFunction(\"find\", function (substring, string, start) {\n        var pos = string.indexOf(substring, start - 1);\n        return pos < 0 ? new CalcError(\"VALUE\") : pos + 1;\n      }).args([[\"*substring\", \"string\"], [\"*string\", \"string\"], [\"*start\", [\"or\", \"integer++\", [\"null\", 1]]]]);\n      defineFunction(\"fixed\", function (number, decimals, noCommas) {\n        var scale = Math.pow(10, decimals);\n        number = Math.round(number * scale) / scale;\n        var format = noCommas ? \"0\" : \"#,##0\";\n\n        if (decimals > 0) {\n          format += \".\";\n\n          while (decimals-- > 0) {\n            format += \"0\";\n          }\n        }\n\n        return spreadsheet.formatting.text(number, format);\n      }).args([[\"*number\", \"number\"], [\"*decimals\", [\"or\", \"integer\", [\"null\", 2]]], [\"*noCommas\", [\"or\", \"boolean\", [\"null\", false]]]]);\n      defineFunction(\"left\", function (text, length) {\n        return text.substr(0, length);\n      }).args([[\"*text\", \"string\"], [\"*length\", [\"or\", \"integer+\", [\"null\", 1]]]]);\n      defineFunction(\"right\", function (text, length) {\n        return text.substr(-length);\n      }).args([[\"*text\", \"string\"], [\"*length\", [\"or\", \"integer+\", [\"null\", 1]]]]);\n      defineFunction(\"len\", function (text) {\n        return text.length;\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"lower\", function (text) {\n        return text.toLowerCase();\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"upper\", function (text) {\n        return text.toUpperCase();\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"ltrim\", function (text) {\n        return text.replace(/^\\s+/, \"\");\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"rtrim\", function (text) {\n        return text.replace(/\\s+$/, \"\");\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"trim\", function (text) {\n        return text.replace(/^\\s+|\\s+$/, \"\");\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"mid\", function (text, start, length) {\n        return text.substr(start - 1, length);\n      }).args([[\"*text\", \"string\"], [\"*start\", \"integer++\"], [\"*length\", \"integer+\"]]);\n      defineFunction(\"proper\", function (text) {\n        return text.toLowerCase().replace(/\\b./g, function (s) {\n          return s.toUpperCase();\n        });\n      }).args([[\"*text\", \"string\"]]);\n      defineFunction(\"replace\", function (text, start, length, newText) {\n        return text.substr(0, --start) + newText + text.substr(start + length);\n      }).args([[\"*text\", \"string\"], [\"*start\", \"integer++\"], [\"*length\", \"integer+\"], [\"*newText\", \"string\"]]);\n      defineFunction(\"rept\", function (text, number) {\n        var out = \"\";\n\n        while (number-- > 0) {\n          out += text;\n        }\n\n        return out;\n      }).args([[\"*text\", \"string\"], [\"*number\", \"integer+\"]]);\n      defineFunction(\"search\", function (substring, string, start) {\n        var pos = string.toLowerCase().indexOf(substring.toLowerCase(), start - 1);\n        return pos < 0 ? new CalcError(\"VALUE\") : pos + 1;\n      }).args([[\"*substring\", \"string\"], [\"*string\", \"string\"], [\"*start\", [\"or\", \"integer++\", [\"null\", 1]]]]);\n      defineFunction(\"substitute\", function (text, oldText, newText, nth) {\n        if (oldText === newText) {\n          return text;\n        }\n\n        var a = text.split(oldText);\n\n        if (nth == null) {\n          return a.join(newText);\n        }\n\n        text = \"\";\n        nth--;\n\n        for (var i = 0; i < a.length; ++i) {\n          text += a[i];\n\n          if (i < a.length - 1) {\n            if (i === nth) {\n              text += newText;\n            } else {\n              text += oldText;\n            }\n          }\n        }\n\n        return text;\n      }).args([[\"*text\", \"string\"], [\"*oldText\", \"string\"], [\"*newText\", \"string\"], [\"*nth\", [\"or\", \"integer++\", \"null\"]]]);\n      defineFunction(\"t\", function (value) {\n        return typeof value == \"string\" ? value : \"\";\n      }).args([[\"*value\", \"anyvalue\"]]);\n      defineFunction(\"text\", function (value, format) {\n        return spreadsheet.formatting.text(value, format);\n      }).args([[\"*value\", \"anyvalue\"], [\"*format\", \"string\"]]);\n      defineFunction(\"value\", function (value) {\n        if (typeof value == \"number\") {\n          return value;\n        }\n\n        if (typeof value == \"boolean\") {\n          return +value;\n        } // XXX: this is dirty.  we need it so we can parse i.e. \"$12,345.50\"\n\n\n        value = (value + \"\").replace(/[$€,]/g, \"\");\n        value = parseFloat(value);\n        return isNaN(value) ? new CalcError(\"VALUE\") : value;\n      }).args([[\"*value\", \"anyvalue\"]]);\n\n      function Hyperlink(link, text) {\n        this.link = link;\n        this.text = text;\n      }\n\n      Hyperlink.prototype.toString = function () {\n        return this.text;\n      };\n\n      defineFunction(\"hyperlink\", function (link, text) {\n        return new Hyperlink(link, text);\n      }).args([[\"*link\", \"string\"], [\"*text\", [\"or\", \"string\", [\"null\", \"$link\"]]]]); //// other misc functions\n\n      defineFunction(\"iferror\", function (value, valueIfError) {\n        return value instanceof CalcError ? valueIfError : value;\n      }).args([[\"*value\", \"forced!\"], [\"*value_if_error\", \"anyvalue!\"]]); //// utils\n\n      var parseCriteria = function () {\n        var RXCACHE = Object.create(null);\n\n        function makeComparator(cmp, x) {\n          if (typeof x == \"string\") {\n            var num = parseFloat(x);\n\n            if (!isNaN(num) && num == x) {\n              x = num;\n            }\n          }\n\n          return function (a) {\n            var b = x;\n\n            if (typeof a == \"string\" && typeof b == \"string\") {\n              a = a.toLowerCase();\n              b = b.toLowerCase();\n            }\n\n            return cmp(a, b);\n          };\n        }\n\n        function lc(a) {\n          var num, str;\n\n          if (typeof a == \"string\") {\n            a = a.toLowerCase();\n          }\n\n          if (/^[0-9.]+%$/.test(a)) {\n            str = a.substr(0, a.length - 1);\n            num = parseFloat(str);\n\n            if (!isNaN(num) && num == str) {\n              a = num / 100;\n            }\n          } else if (/^[0-9.]+$/.test(a)) {\n            num = parseFloat(a);\n\n            if (!isNaN(num) && num == a) {\n              a = num;\n            }\n          }\n\n          return a;\n        }\n\n        function compLT(a, b) {\n          return lc(a) < lc(b);\n        }\n\n        function compLTE(a, b) {\n          return lc(a) <= lc(b);\n        }\n\n        function compGT(a, b) {\n          return lc(a) > lc(b);\n        }\n\n        function compGTE(a, b) {\n          return lc(a) >= lc(b);\n        }\n\n        function compNE(a, b) {\n          return !compEQ(a, b);\n        }\n\n        function compEQ(a, b) {\n          if (b instanceof RegExp) {\n            return b.test(a);\n          }\n\n          if (typeof a == \"string\" || typeof b == \"string\") {\n            // if either one is string, make sure both are strings\n            a = String(a);\n            b = String(b);\n          }\n\n          return lc(a) == lc(b);\n        }\n\n        return function (cmp) {\n          if (typeof cmp == \"function\") {\n            return cmp;\n          }\n\n          var m;\n\n          if (m = /^=(.*)$/.exec(cmp)) {\n            return makeComparator(compEQ, m[1]);\n          }\n\n          if (m = /^<>(.*)$/.exec(cmp)) {\n            return makeComparator(compNE, m[1]);\n          }\n\n          if (m = /^<=(.*)$/.exec(cmp)) {\n            return makeComparator(compLTE, m[1]);\n          }\n\n          if (m = /^<(.*)$/.exec(cmp)) {\n            return makeComparator(compLT, m[1]);\n          }\n\n          if (m = /^>=(.*)$/.exec(cmp)) {\n            return makeComparator(compGTE, m[1]);\n          }\n\n          if (m = /^>(.*)$/.exec(cmp)) {\n            return makeComparator(compGT, m[1]);\n          }\n\n          if (/[?*]/.exec(cmp)) {\n            // has wildchars\n            var rx = RXCACHE[cmp];\n\n            if (!rx) {\n              rx = cmp.replace(/(~\\?|~\\*|[\\]({\\+\\.\\|\\^\\$\\\\})\\[]|[?*])/g, function (s) {\n                switch (s) {\n                  case \"~?\":\n                    return \"\\\\?\";\n\n                  case \"~*\":\n                    return \"\\\\*\";\n\n                  case \"?\":\n                    return \".\";\n\n                  case \"*\":\n                    return \".*\";\n\n                  default:\n                    return \"\\\\\" + s;\n                }\n              });\n              rx = RXCACHE[cmp] = new RegExp(\"^\" + rx + \"$\", \"i\");\n            }\n\n            return makeComparator(compEQ, rx);\n          }\n\n          return makeComparator(compEQ, cmp);\n        };\n      }();\n\n      function numericPredicate(val) {\n        return typeof val == \"number\" || typeof val == \"boolean\" || val == null || val === \"\";\n      }\n\n      function ascending(a, b) {\n        return a === b ? 0 : a < b ? -1 : 1;\n      }\n\n      function descending(a, b) {\n        return a === b ? 0 : a < b ? 1 : -1;\n      } // var m = new Matrix();\n      // m.data = [[1, 2, 3], [4, 1, 6], [7, 8, 9]];\n      // //m.data = [[0, 2, 1], [2, 6, 1], [1, 1, 4]];\n      // //m.data = [[1,4,1,1], [1,4,0,1], [2,3,1,2], [3,2,6,4]];\n      // m.width = m.height = 3;\n      // var x = m.inverse();\n      // x.dump();\n\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}