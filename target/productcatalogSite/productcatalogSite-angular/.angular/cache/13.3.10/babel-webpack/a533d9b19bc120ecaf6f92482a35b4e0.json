{"ast":null,"code":"import { geometry as g, drawing as d } from '@progress/kendo-drawing';\nimport { Class, defined, last, setDefaultOptions } from '../../common';\nimport { proxy } from '../utils';\nimport { Layer } from './layer';\nimport { Movable } from '../scroller/draggable';\nimport { Location } from '../location';\nconst Group = d.Group;\nexport class ShapeLayer extends Layer {\n  constructor(map, options) {\n    super(map, options);\n    this._pan = proxy(this._pan, this);\n    this.surface = d.Surface.create(this.element, {\n      width: map.scrollElement.clientWidth,\n      height: map.scrollElement.clientHeight\n    });\n\n    this._initRoot();\n\n    this.movable = new Movable(this.surface.element);\n    this._markers = [];\n    this._click = this._handler('shapeClick');\n    this.surface.bind('click', this._click);\n    this._mouseleave = this._handler('shapeMouseLeave');\n    this.surface.bind('mouseleave', this._mouseleave);\n    this.surface.bind('mouseenter', this._mouseenter.bind(this));\n  }\n\n  destroy() {\n    super.destroy();\n    this.surface.destroy();\n  }\n\n  _reset() {\n    super._reset();\n\n    this._translateSurface();\n\n    this._data = this._readData();\n\n    if (this._hasData()) {\n      this._load(this._data);\n    }\n  }\n\n  _initRoot() {\n    this._root = new Group();\n    this.surface.draw(this._root);\n  }\n\n  _beforeReset() {\n    this.surface.clear();\n\n    this._initRoot();\n  }\n\n  _resize() {\n    this.surface.size(this.map.size());\n  }\n\n  _readData() {\n    const data = super._readData();\n\n    if (data.type === \"FeatureCollection\") {\n      return data.features;\n    }\n\n    if (data.type === \"GeometryCollection\") {\n      return data.geometries;\n    }\n\n    return data;\n  }\n\n  _load(data) {\n    this._data = data;\n\n    this._clearMarkers();\n\n    if (!this._loader) {\n      this._loader = new GeoJsonLoader(this.map, this.options.style, this);\n    }\n\n    let container = new Group();\n\n    for (let i = 0; i < data.length; i++) {\n      let shape = this._loader.parse(data[i]);\n\n      if (shape) {\n        container.append(shape);\n      }\n    }\n\n    this._root.clear();\n\n    this._root.append(container);\n  }\n\n  shapeCreated(shape) {\n    let cancelled = false; // the GeoJSON loader builds \"Point\" type as a circle\n    // use the circle shape type as and indicator for rendering a marker\n    // keep the behavior under a setting as this is supported by kendo jQuery Map\n    // but we opted out of this in blazor\n\n    if (shape instanceof d.Circle && this.map.options.renderPointsAsMarkers) {\n      cancelled = defined(this._createMarker(shape));\n    }\n\n    if (!cancelled) {\n      let args = {\n        layer: this,\n        shape: shape\n      };\n      cancelled = this.map.trigger('shapeCreated', args);\n    }\n\n    return cancelled;\n  }\n\n  featureCreated(e) {\n    e.layer = this;\n    this.map.trigger('shapeFeatureCreated', e);\n  }\n\n  _createMarker(shape) {\n    let marker = this.map.markers.bind({\n      location: shape.location\n    }, shape.dataItem);\n\n    if (marker) {\n      this._markers.push(marker);\n    }\n\n    return marker;\n  }\n\n  _clearMarkers() {\n    for (let i = 0; i < this._markers.length; i++) {\n      this.map.markers.remove(this._markers[i]);\n    }\n\n    this._markers = [];\n  }\n\n  _pan() {\n    if (!this._panning) {\n      this._panning = true;\n      this.surface.suspendTracking();\n    }\n  }\n\n  _panEnd(e) {\n    super._panEnd(e);\n\n    this._translateSurface();\n\n    this.surface.resumeTracking();\n    this._panning = false;\n  }\n\n  _translateSurface() {\n    let map = this.map;\n    let nw = map.locationToView(map.extent().nw);\n\n    if (this.surface.translate) {\n      this.surface.translate(nw);\n      this.movable.moveTo({\n        x: nw.x,\n        y: nw.y\n      });\n    }\n  }\n\n  _eventArgs(e) {\n    return {\n      layer: this,\n      layerIndex: this._layerIndex(),\n      shape: e.element,\n      shapeIndex: (this._data || []).indexOf(e.element.dataItem),\n      originalEvent: e.originalEvent\n    };\n  }\n\n  _handler(eventName) {\n    return e => {\n      if (e.element) {\n        this.map.trigger(eventName, this._eventArgs(e));\n      }\n    };\n  }\n\n  _mouseenter(e) {\n    if (!e.element) {\n      return;\n    }\n\n    this.map.trigger('shapeMouseEnter', this._eventArgs(e));\n    const shape = e.element;\n\n    const anchor = this._tooltipAnchor(e);\n\n    this.map._tooltip.show(anchor, this._tooltipContext(shape));\n  }\n\n  _tooltipContext(shape) {\n    return {\n      type: 'shape',\n      layerIndex: this._layerIndex(),\n      className: 'k-map-shape-tooltip',\n      dataItem: shape.dataItem,\n      location: shape.location\n    };\n  }\n\n  _tooltipAnchor(e) {\n    const cursor = this.map.eventOffset(e.originalEvent);\n    return {\n      top: cursor.y,\n      left: cursor.x\n    };\n  }\n\n  _activate() {\n    super._activate();\n\n    this._panHandler = proxy(this._pan, this);\n    this.map.bind('pan', this.panHandler);\n  }\n\n  _deactivate() {\n    super._deactivate();\n\n    this.map.unbind('pan', this._panHandler);\n  }\n\n}\nsetDefaultOptions(ShapeLayer, {\n  autoBind: true,\n  zIndex: 100\n});\n\nclass GeoJsonLoader extends Class {\n  constructor(locator, defaultStyle, observer) {\n    super();\n    this.observer = observer;\n    this.locator = locator;\n    this.style = defaultStyle;\n  }\n\n  parse(item) {\n    let root = new Group();\n    let unwrap = true;\n\n    if (item.type === 'Feature') {\n      unwrap = false;\n\n      this._loadGeometryTo(root, item.geometry, item);\n\n      this._featureCreated(root, item);\n    } else {\n      this._loadGeometryTo(root, item, item);\n    }\n\n    if (unwrap && root.children.length < 2) {\n      root = root.children[0];\n    }\n\n    return root;\n  }\n\n  _shapeCreated(shape) {\n    let cancelled = false;\n\n    if (this.observer && this.observer.shapeCreated) {\n      cancelled = this.observer.shapeCreated(shape);\n    }\n\n    return cancelled;\n  }\n\n  _featureCreated(group, dataItem) {\n    if (this.observer && this.observer.featureCreated) {\n      this.observer.featureCreated({\n        group: group,\n        dataItem: dataItem,\n        properties: dataItem.properties\n      });\n    }\n  }\n  /* eslint-disable indent */\n\n\n  _loadGeometryTo(container, geometry, dataItem) {\n    let coords = geometry.coordinates;\n    let i;\n    let path;\n\n    switch (geometry.type) {\n      case 'LineString':\n        path = this._loadPolygon(container, [coords], dataItem);\n\n        this._setLineFill(path);\n\n        break;\n\n      case 'MultiLineString':\n        for (i = 0; i < coords.length; i++) {\n          path = this._loadPolygon(container, [coords[i]], dataItem);\n\n          this._setLineFill(path);\n        }\n\n        break;\n\n      case 'Polygon':\n        this._loadPolygon(container, coords, dataItem);\n\n        break;\n\n      case 'MultiPolygon':\n        for (i = 0; i < coords.length; i++) {\n          this._loadPolygon(container, coords[i], dataItem);\n        }\n\n        break;\n\n      case 'Point':\n        this._loadPoint(container, coords, dataItem);\n\n        break;\n\n      case 'MultiPoint':\n        for (i = 0; i < coords.length; i++) {\n          this._loadPoint(container, coords[i], dataItem);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }\n  /* eslint-disable indent */\n\n\n  _setLineFill(path) {\n    let segments = path.segments;\n\n    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {\n      path.options.fill = null;\n    }\n  }\n\n  _loadShape(container, shape) {\n    if (!this._shapeCreated(shape)) {\n      container.append(shape);\n    }\n\n    return shape;\n  }\n\n  _loadPolygon(container, rings, dataItem) {\n    let shape = this._buildPolygon(rings);\n\n    shape.dataItem = dataItem;\n    shape.location = this.locator.viewToLocation(shape.bbox().center());\n    return this._loadShape(container, shape);\n  }\n\n  _buildPolygon(rings) {\n    let type = rings.length > 1 ? d.MultiPath : d.Path;\n    let path = new type(this.style);\n\n    for (let i = 0; i < rings.length; i++) {\n      for (let j = 0; j < rings[i].length; j++) {\n        let point = this.locator.locationToView(Location.fromLngLat(rings[i][j]));\n\n        if (j === 0) {\n          path.moveTo(point.x, point.y);\n        } else {\n          path.lineTo(point.x, point.y);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _loadPoint(container, coords, dataItem) {\n    let location = Location.fromLngLat(coords);\n    let point = this.locator.locationToView(location);\n    let circle = new g.Circle(point, 10);\n    let shape = new d.Circle(circle, this.style);\n    shape.dataItem = dataItem;\n    shape.location = location;\n    return this._loadShape(container, shape);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}