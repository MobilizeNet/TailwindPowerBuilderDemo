{"ast":null,"code":"import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\nimport SeriesBinder from './series-binder';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\nimport evalOptions from './utils/eval-options';\nimport categoriesCount from './utils/categories-count';\nimport { ChartElement, Box } from '../core';\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\n\nclass CategoricalChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]); // Value axis ranges grouped by axis name, e.g.:\n    // primary: { min: 0, max: 1 }\n\n    this.valueAxisRanges = {};\n    this.points = [];\n    this.categoryPoints = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n    this.render();\n  }\n\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n\n  pointOptions(series, seriesIx) {\n    let options = this.seriesOptions[seriesIx];\n\n    if (!options) {\n      const defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        vertical: !this.options.invertAxes\n      }, series);\n    }\n\n    return options;\n  }\n\n  plotValue(point) {\n    if (!point) {\n      return 0;\n    }\n\n    if (this.options.isStacked100 && isNumber(point.value)) {\n      const categoryIx = point.categoryIx;\n      const categoryPoints = this.categoryPoints[categoryIx];\n      const otherValues = [];\n      let categorySum = 0;\n\n      for (let i = 0; i < categoryPoints.length; i++) {\n        const other = categoryPoints[i];\n\n        if (other) {\n          const stack = point.series.stack;\n          const otherStack = other.series.stack;\n\n          if (stack && otherStack && stack.group !== otherStack.group) {\n            continue;\n          }\n\n          if (isNumber(other.value)) {\n            categorySum += Math.abs(other.value);\n            otherValues.push(Math.abs(other.value));\n          }\n        }\n      }\n\n      if (categorySum > 0) {\n        return point.value / categorySum;\n      }\n    }\n\n    return point.value;\n  }\n\n  plotRange(point, startValue = 0) {\n    const categoryPoints = this.categoryPoints[point.categoryIx];\n\n    if (this.options.isStacked) {\n      let plotValue = this.plotValue(point);\n      const positive = plotValue >= 0;\n      let prevValue = startValue;\n      let isStackedBar = false;\n\n      for (let i = 0; i < categoryPoints.length; i++) {\n        const other = categoryPoints[i];\n\n        if (point === other) {\n          break;\n        }\n\n        const stack = point.series.stack;\n        const otherStack = other.series.stack;\n\n        if (stack && otherStack) {\n          if (typeof stack === STRING && stack !== otherStack) {\n            continue;\n          }\n\n          if (stack.group && stack.group !== otherStack.group) {\n            continue;\n          }\n        }\n\n        const otherValue = this.plotValue(other);\n\n        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n          prevValue += otherValue;\n          plotValue += otherValue;\n          isStackedBar = true;\n\n          if (this.options.isStacked100) {\n            plotValue = Math.min(plotValue, 1);\n          }\n        }\n      }\n\n      if (isStackedBar) {\n        prevValue -= startValue;\n      }\n\n      return [prevValue, plotValue];\n    }\n\n    const series = point.series;\n    const valueAxis = this.seriesValueAxis(series);\n    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];\n  }\n\n  stackLimits(axisName, stackName) {\n    let min = MAX_VALUE;\n    let max = MIN_VALUE;\n\n    for (let i = 0; i < this.categoryPoints.length; i++) {\n      const categoryPoints = this.categoryPoints[i];\n\n      if (!categoryPoints) {\n        continue;\n      }\n\n      for (let pIx = 0; pIx < categoryPoints.length; pIx++) {\n        const point = categoryPoints[pIx];\n\n        if (point) {\n          if (point.series.stack === stackName || point.series.axis === axisName) {\n            const to = this.plotRange(point, 0)[1];\n\n            if (defined(to) && isFinite(to)) {\n              max = Math.max(max, to);\n              min = Math.min(min, to);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  updateStackRange() {\n    const {\n      isStacked,\n      series: chartSeries\n    } = this.options;\n    const limitsCache = {};\n\n    if (isStacked) {\n      for (let i = 0; i < chartSeries.length; i++) {\n        const series = chartSeries[i];\n        const axisName = series.axis;\n        const key = axisName + series.stack;\n        let limits = limitsCache[key];\n\n        if (!limits) {\n          limits = this.stackLimits(axisName, series.stack);\n          const errorTotals = this.errorTotals;\n\n          if (errorTotals) {\n            if (errorTotals.negative.length) {\n              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n            }\n\n            if (errorTotals.positive.length) {\n              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n            }\n          }\n\n          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n            limitsCache[key] = limits;\n          } else {\n            limits = null;\n          }\n        }\n\n        if (limits) {\n          this.valueAxisRanges[axisName] = limits;\n        }\n      }\n    }\n  }\n\n  addErrorBar(point, data, categoryIx) {\n    const {\n      value,\n      series,\n      seriesIx\n    } = point;\n    const errorBars = point.options.errorBars;\n    const lowValue = data.fields[ERROR_LOW_FIELD];\n    const highValue = data.fields[ERROR_HIGH_FIELD];\n    let errorRange;\n\n    if (isNumber(lowValue) && isNumber(highValue)) {\n      errorRange = {\n        low: lowValue,\n        high: highValue\n      };\n    } else if (errorBars && defined(errorBars.value)) {\n      this.seriesErrorRanges = this.seriesErrorRanges || [];\n      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n    }\n\n    if (errorRange) {\n      point.low = errorRange.low;\n      point.high = errorRange.high;\n      this.addPointErrorBar(point, categoryIx);\n    }\n  }\n\n  addPointErrorBar(point, categoryIx) {\n    const isVertical = !this.options.invertAxes;\n    const options = point.options.errorBars;\n    let {\n      series,\n      low,\n      high\n    } = point;\n\n    if (this.options.isStacked) {\n      const stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n      low = stackedErrorRange.low;\n      high = stackedErrorRange.high;\n    } else {\n      const fields = {\n        categoryIx: categoryIx,\n        series: series\n      };\n      this.updateRange({\n        value: low\n      }, fields);\n      this.updateRange({\n        value: high\n      }, fields);\n    }\n\n    const errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars = [errorBar];\n    point.append(errorBar);\n  }\n\n  stackedErrorRange(point, categoryIx) {\n    const plotValue = this.plotRange(point, 0)[1] - point.value;\n    const low = point.low + plotValue;\n    const high = point.high + plotValue;\n    this.errorTotals = this.errorTotals || {\n      positive: [],\n      negative: []\n    };\n\n    if (low < 0) {\n      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n    }\n\n    if (high > 0) {\n      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n    }\n\n    return {\n      low: low,\n      high: high\n    };\n  }\n\n  addValue(data, fields) {\n    const {\n      categoryIx,\n      series,\n      seriesIx\n    } = fields;\n    let categoryPoints = this.categoryPoints[categoryIx];\n\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n\n    let seriesPoints = this.seriesPoints[seriesIx];\n\n    if (!seriesPoints) {\n      this.seriesPoints[seriesIx] = seriesPoints = [];\n    }\n\n    const point = this.createPoint(data, fields);\n\n    if (point) {\n      Object.assign(point, fields);\n      point.owner = this;\n      point.noteText = data.fields.noteText;\n\n      if (!defined(point.dataItem)) {\n        point.dataItem = series.data[categoryIx];\n      }\n\n      this.addErrorBar(point, data, categoryIx);\n    }\n\n    this.points.push(point);\n    seriesPoints.push(point);\n    categoryPoints.push(point);\n    this.updateRange(data.valueFields, fields);\n  }\n\n  evalPointOptions(options, value, category, categoryIx, series, seriesIx) {\n    const state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n    };\n    let doEval = this._evalSeries[seriesIx];\n\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n\n    let pointOptions = options;\n\n    if (doEval) {\n      pointOptions = deepExtend({}, pointOptions);\n      evalOptions(pointOptions, {\n        value: value,\n        category: category,\n        index: categoryIx,\n        series: series,\n        dataItem: series.data[categoryIx]\n      }, state);\n    }\n\n    return pointOptions;\n  }\n\n  updateRange(data, fields) {\n    const axisName = fields.series.axis;\n    const value = data.value;\n    let axisRange = this.valueAxisRanges[axisName];\n\n    if (isFinite(value) && value !== null) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, value);\n      axisRange.max = Math.max(axisRange.max, value);\n    }\n  }\n\n  seriesValueAxis(series) {\n    const plotArea = this.plotArea;\n    const axisName = series.axis;\n    const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n    if (!axis) {\n      throw new Error(\"Unable to locate value axis with name \" + axisName);\n    }\n\n    return axis;\n  }\n\n  reflow(targetBox) {\n    const categorySlots = this.categorySlots = [];\n    const chartPoints = this.points;\n    const categoryAxis = this.categoryAxis;\n    let pointIx = 0;\n    this.traverseDataPoints((data, fields) => {\n      const {\n        categoryIx,\n        series: currentSeries\n      } = fields;\n      const valueAxis = this.seriesValueAxis(currentSeries);\n      const point = chartPoints[pointIx++];\n      let categorySlot = categorySlots[categoryIx];\n\n      if (!categorySlot) {\n        categorySlots[categoryIx] = categorySlot = this.categorySlot(categoryAxis, categoryIx, valueAxis);\n      }\n\n      if (point) {\n        const plotRange = this.plotRange(point, valueAxis.startValue());\n        const valueSlot = this.valueSlot(valueAxis, plotRange);\n\n        if (valueSlot) {\n          const pointSlot = this.pointSlot(categorySlot, valueSlot);\n          point.aboveAxis = this.aboveAxis(point, valueAxis);\n          point.stackValue = plotRange[1];\n\n          if (this.options.isStacked100) {\n            point.percentage = this.plotValue(point);\n          }\n\n          this.reflowPoint(point, pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.reflowCategories(categorySlots);\n\n    if (!this.options.clip && this.options.limitPoints && this.points.length) {\n      this.limitPoints();\n    }\n\n    this.box = targetBox;\n  }\n\n  valueSlot(valueAxis, plotRange) {\n    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n  }\n\n  limitPoints() {\n    const categoryPoints = this.categoryPoints;\n    const points = categoryPoints[0].concat(last(categoryPoints));\n\n    for (let idx = 0; idx < points.length; idx++) {\n      if (points[idx]) {\n        this.limitPoint(points[idx]);\n      }\n    }\n  }\n\n  limitPoint(point) {\n    const limittedSlot = this.categoryAxis.limitSlot(point.box);\n\n    if (!limittedSlot.equals(point.box)) {\n      point.reflow(limittedSlot);\n    }\n  }\n\n  aboveAxis(point, valueAxis) {\n    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    const value = point.value;\n    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n  }\n\n  categoryAxisCrossingValue(valueAxis) {\n    const categoryAxis = this.categoryAxis;\n    const options = valueAxis.options;\n    const crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    return crossingValues[categoryAxis.axisIndex || 0] || 0;\n  }\n\n  reflowPoint(point, pointSlot) {\n    point.reflow(pointSlot);\n  }\n\n  reflowCategories() {}\n\n  pointSlot(categorySlot, valueSlot) {\n    const options = this.options;\n    const invertAxes = options.invertAxes;\n    const slotX = invertAxes ? valueSlot : categorySlot;\n    const slotY = invertAxes ? categorySlot : valueSlot;\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  }\n\n  categorySlot(categoryAxis, categoryIx) {\n    return categoryAxis.getSlot(categoryIx);\n  }\n\n  traverseDataPoints(callback) {\n    const series = this.options.series;\n    const count = categoriesCount(series);\n    const seriesCount = series.length;\n\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n    }\n\n    for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n      for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n        const currentSeries = series[seriesIx];\n        const currentCategory = this.categoryAxis.categoryAt(categoryIx);\n\n        const pointData = this._bindPoint(currentSeries, seriesIx, categoryIx);\n\n        callback(pointData, {\n          category: currentCategory,\n          categoryIx: categoryIx,\n          categoriesCount: count,\n          series: currentSeries,\n          seriesIx: seriesIx\n        });\n      }\n    }\n\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMaxPoint\", seriesIx, callback);\n    }\n  }\n\n  _outOfRangeCallback(series, field, seriesIx, callback) {\n    const outOfRangePoint = series[field];\n\n    if (outOfRangePoint) {\n      const categoryIx = outOfRangePoint.categoryIx;\n\n      const pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n      callback(pointData, {\n        category: outOfRangePoint.category,\n        categoryIx: categoryIx,\n        series: series,\n        seriesIx: seriesIx,\n        dataItem: outOfRangePoint.item\n      });\n    }\n  }\n\n  _bindPoint(series, seriesIx, categoryIx, item) {\n    if (!this._bindCache) {\n      this._bindCache = [];\n    }\n\n    let bindCache = this._bindCache[seriesIx];\n\n    if (!bindCache) {\n      bindCache = this._bindCache[seriesIx] = [];\n    }\n\n    let data = bindCache[categoryIx];\n\n    if (!data) {\n      data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n    }\n\n    return data;\n  }\n\n  formatPointValue(point, format) {\n    if (point.value === null) {\n      return \"\";\n    }\n\n    return this.chartService.format.auto(format, point.value);\n  }\n\n  pointValue(data) {\n    return data.valueFields.value;\n  }\n\n}\n\nsetDefaultOptions(CategoricalChart, {\n  series: [],\n  invertAxes: false,\n  isStacked: false,\n  clip: true,\n  limitPoints: true\n});\nexport default CategoricalChart;","map":null,"metadata":{},"sourceType":"module"}