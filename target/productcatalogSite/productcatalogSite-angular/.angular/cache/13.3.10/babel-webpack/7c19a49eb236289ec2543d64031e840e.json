{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\nconst RadarNumericAxisMixin = {\n  options: {\n    majorGridLines: {\n      visible: true\n    }\n  },\n  createPlotBands: function () {\n    const {\n      majorGridLines: {\n        type\n      },\n      plotBands = []\n    } = this.options;\n    const altAxis = this.plotArea.polarAxis;\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    const group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n\n    for (let i = 0; i < plotBands.length; i++) {\n      const band = plotBands[i];\n      const bandStyle = {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      };\n      const slot = this.getSlot(band.from, band.to, true);\n      const ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n      let shape;\n\n      if (type === ARC) {\n        shape = ShapeBuilder.current.createRing(ring, bandStyle);\n      } else {\n        shape = draw.Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();\n      }\n\n      group.append(shape);\n    }\n\n    this.appendVisual(group);\n  },\n  plotBandPoints: function (ring, angles) {\n    const innerPoints = [];\n    const outerPoints = [];\n    const center = [ring.center.x, ring.center.y];\n    const innerCircle = new geom.Circle(center, ring.innerRadius);\n    const outerCircle = new geom.Circle(center, ring.radius);\n\n    for (let i = 0; i < angles.length; i++) {\n      innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n      outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n    }\n\n    innerPoints.reverse();\n    innerPoints.push(innerPoints[0]);\n    outerPoints.push(outerPoints[0]);\n    return outerPoints.concat(innerPoints);\n  },\n  createGridLines: function (altAxis) {\n    const options = this.options;\n    const majorTicks = this.radarMajorGridLinePositions();\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    let gridLines = [];\n\n    if (options.majorGridLines.visible) {\n      gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);\n    }\n\n    if (options.minorGridLines.visible) {\n      const minorTicks = this.radarMinorGridLinePositions();\n      append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));\n    }\n\n    return gridLines;\n  },\n  renderGridLines: function (center, ticks, angles, options) {\n    const style = {\n      stroke: {\n        width: options.width,\n        color: options.color,\n        dashType: options.dashType\n      }\n    };\n    const {\n      skip = 0,\n      step = 0\n    } = options;\n    const container = this.gridLinesVisual();\n\n    for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {\n      const tickRadius = center.y - ticks[tickIx];\n\n      if (tickRadius > 0) {\n        const circle = new geom.Circle([center.x, center.y], tickRadius);\n\n        if (options.type === ARC) {\n          container.append(new draw.Circle(circle, style));\n        } else {\n          const line = new draw.Path(style);\n\n          for (let angleIx = 0; angleIx < angles.length; angleIx++) {\n            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n          }\n\n          line.close();\n          container.append(line);\n        }\n      }\n    }\n\n    return container.children;\n  },\n  getValue: function (point) {\n    const lineBox = this.lineBox();\n    const altAxis = this.plotArea.polarAxis;\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    const radius = point.distanceTo(center);\n    let distance = radius;\n\n    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n      const dx = point.x - center.x;\n      const dy = point.y - center.y;\n      const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n      majorAngles.sort(function (a, b) {\n        return angularDistance(a, theta) - angularDistance(b, theta);\n      }); // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n      // Angles are derived from triangle (center, point, gridline X)\n\n      const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n      const alpha = angularDistance(theta, majorAngles[0]);\n      const gamma = 90 - midAngle;\n      const beta = 180 - alpha - gamma;\n      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n    }\n\n    return this.axisType().prototype.getValue.call(this, new Point(lineBox.x1, lineBox.y2 - distance));\n  }\n};\n\nfunction angularDistance(a, b) {\n  return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nexport default RadarNumericAxisMixin;","map":null,"metadata":{},"sourceType":"module"}