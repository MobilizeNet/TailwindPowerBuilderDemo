{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1403);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1403:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"popup\",\n        name: \"Pop-up\",\n        category: \"framework\",\n        depends: [\"core\"],\n        advanced: true\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            ui = kendo.ui,\n            Widget = ui.Widget,\n            Class = kendo.Class,\n            support = kendo.support,\n            getOffset = kendo.getOffset,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            OPEN = \"open\",\n            CLOSE = \"close\",\n            DEACTIVATE = \"deactivate\",\n            ACTIVATE = \"activate\",\n            CENTER = \"center\",\n            LEFT = \"left\",\n            RIGHT = \"right\",\n            TOP = \"top\",\n            BOTTOM = \"bottom\",\n            ABSOLUTE = \"absolute\",\n            HIDDEN = \"hidden\",\n            BODY = \"body\",\n            LOCATION = \"location\",\n            POSITION = \"position\",\n            VISIBLE = \"visible\",\n            EFFECTS = \"effects\",\n            ACTIVE = \"k-state-active\",\n            ACTIVEBORDER = \"k-state-border\",\n            ACTIVEBORDERREGEXP = /k-state-border-(\\w+)/,\n            ACTIVECHILDREN = \".k-picker-wrap, .k-dropdown-wrap, .k-link\",\n            MOUSEDOWN = \"down\",\n            DOCUMENT_ELEMENT = $(document.documentElement),\n            WINDOW = $(window),\n            SCROLL = \"scroll\",\n            cssPrefix = support.transitions.css,\n            TRANSFORM = cssPrefix + \"transform\",\n            extend = $.extend,\n            NS = \".kendoPopup\",\n            styles = [\"font-size\", \"font-family\", \"font-stretch\", \"font-style\", \"font-weight\", \"line-height\"];\n\n        function contains(container, target) {\n          if (!container || !target) {\n            return false;\n          }\n\n          return container === target || $.contains(container, target);\n        }\n\n        var Popup = Widget.extend({\n          init: function (element, options) {\n            var that = this,\n                parentPopup;\n            options = options || {};\n\n            if (options.isRtl) {\n              options.origin = options.origin || BOTTOM + \" \" + RIGHT;\n              options.position = options.position || TOP + \" \" + RIGHT;\n            }\n\n            Widget.fn.init.call(that, element, options);\n            element = that.element;\n            options = that.options;\n            that.collisions = options.collision ? options.collision.split(\" \") : [];\n            that.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());\n\n            if (that.collisions.length === 1) {\n              that.collisions.push(that.collisions[0]);\n            }\n\n            parentPopup = $(that.options.anchor).closest(\".k-popup,.k-group\").filter(\":not([class^=km-])\"); // When popup is in another popup, make it relative.\n\n            options.appendTo = $($(options.appendTo)[0] || parentPopup[0] || document.body);\n            that.element.hide().addClass(\"k-popup k-group k-reset\").toggleClass(\"k-rtl\", !!options.isRtl).css({\n              position: ABSOLUTE\n            }).appendTo(options.appendTo).attr(\"aria-hidden\", true).on(\"mouseenter\" + NS, function () {\n              that._hovered = true;\n            }).on(\"wheel\" + NS, function (e) {\n              var list = $(e.target).find(\".k-list\");\n              var scrollArea = list.parent();\n\n              if (list.length && list.is(\":visible\") && (scrollArea.scrollTop() === 0 && e.originalEvent.deltaY < 0 || scrollArea.scrollTop() === scrollArea.prop('scrollHeight') - scrollArea.prop('offsetHeight') && e.originalEvent.deltaY > 0)) {\n                e.preventDefault();\n              }\n            }).on(\"mouseleave\" + NS, function () {\n              that._hovered = false;\n            });\n            that.wrapper = $();\n\n            if (options.animation === false) {\n              options.animation = {\n                open: {\n                  effects: {}\n                },\n                close: {\n                  hide: true,\n                  effects: {}\n                }\n              };\n            }\n\n            extend(options.animation.open, {\n              complete: function () {\n                that.wrapper.css({\n                  overflow: VISIBLE\n                }); // Forcing refresh causes flickering in mobile.\n\n                that._activated = true;\n\n                that._trigger(ACTIVATE);\n              }\n            });\n            extend(options.animation.close, {\n              complete: function () {\n                that._animationClose();\n              }\n            });\n\n            that._mousedownProxy = function (e) {\n              that._mousedown(e);\n            };\n\n            if (support.mobileOS.android) {\n              that._resizeProxy = function (e) {\n                setTimeout(function () {\n                  that._resize(e);\n                }, 600); //Logic from kendo.onResize\n              };\n            } else {\n              that._resizeProxy = function (e) {\n                that._resize(e);\n              };\n            }\n\n            if (options.toggleTarget) {\n              $(options.toggleTarget).on(options.toggleEvent + NS, that.toggle.bind(that));\n            }\n          },\n          events: [OPEN, ACTIVATE, CLOSE, DEACTIVATE],\n          options: {\n            name: \"Popup\",\n            toggleEvent: \"click\",\n            origin: BOTTOM + \" \" + LEFT,\n            position: TOP + \" \" + LEFT,\n            anchor: BODY,\n            appendTo: null,\n            collision: \"flip fit\",\n            viewport: window,\n            copyAnchorStyles: true,\n            autosize: false,\n            modal: false,\n            adjustSize: {\n              width: 0,\n              height: 0\n            },\n            animation: {\n              open: {\n                effects: \"slideIn:down\",\n                transition: true,\n                duration: 200\n              },\n              close: {\n                // if close animation effects are defined, they will be used instead of open.reverse\n                duration: 100,\n                hide: true\n              }\n            },\n            omitOriginOffsets: false\n          },\n          _animationClose: function () {\n            var that = this;\n            var location = that.wrapper.data(LOCATION);\n            that.wrapper.hide();\n\n            if (location) {\n              that.wrapper.css(location);\n            }\n\n            if (that.options.anchor != BODY) {\n              that._hideDirClass();\n            }\n\n            that._closing = false;\n\n            that._trigger(DEACTIVATE);\n          },\n          destroy: function () {\n            var that = this,\n                options = that.options,\n                element = that.element.off(NS),\n                parent;\n            Widget.fn.destroy.call(that);\n\n            if (options.toggleTarget) {\n              $(options.toggleTarget).off(NS);\n            }\n\n            if (!options.modal) {\n              DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy);\n\n              that._toggleResize(false);\n            }\n\n            kendo.destroy(that.element.children());\n            element.removeData();\n\n            if (options.appendTo[0] === document.body) {\n              parent = element.parent(\".k-animation-container\");\n\n              if (parent[0]) {\n                parent.remove();\n              } else {\n                element.remove();\n              }\n            }\n          },\n          open: function (x, y) {\n            var that = this,\n                fixed = {\n              isFixed: !isNaN(parseInt(y, 10)),\n              x: x,\n              y: y\n            },\n                element = that.element,\n                options = that.options,\n                animation,\n                wrapper,\n                anchor = $(options.anchor),\n                mobile = element[0] && element.hasClass(\"km-widget\"),\n                listbox = element.find(\"[role='listbox']\");\n\n            if (!that.visible()) {\n              if (options.copyAnchorStyles) {\n                if (mobile && styles[0] == \"font-size\") {\n                  styles.shift();\n                }\n\n                element.css(kendo.getComputedStyles(anchor[0], styles));\n              }\n\n              if (element.data(\"animating\") || that._trigger(OPEN)) {\n                return;\n              }\n\n              that._activated = false;\n\n              if (!options.modal) {\n                DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy).on(that.downEvent, that._mousedownProxy); // this binding hangs iOS in editor\n                // all elements in IE7/8 fire resize event, causing mayhem\n\n                that._toggleResize(false);\n\n                that._toggleResize(true);\n              }\n\n              that.wrapper = wrapper = kendo.wrap(element, options.autosize).css({\n                overflow: HIDDEN,\n                display: \"block\",\n                position: ABSOLUTE\n              }).attr(\"aria-hidden\", false);\n\n              if (listbox.attr(\"aria-label\")) {\n                wrapper.attr(\"aria-label\", listbox.attr(\"aria-label\"));\n              } else if (listbox.attr(\"aria-labelledby\")) {\n                wrapper.attr(\"aria-labelledby\", listbox.attr(\"aria-labelledby\"));\n              }\n\n              if (support.mobileOS.android) {\n                wrapper.css(TRANSFORM, \"translatez(0)\"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\n              }\n\n              wrapper.css(POSITION);\n\n              if ($(options.appendTo)[0] == document.body) {\n                wrapper.css(TOP, \"-10000px\");\n              }\n\n              that.flipped = that._position(fixed);\n              animation = that._openAnimation();\n\n              if (options.anchor != BODY) {\n                that._showDirClass(animation);\n              }\n\n              if (!element.is(\":visible\") && element.data(\"olddisplay\") === undefined) {\n                element.show();\n                element.data(\"olddisplay\", element.css(\"display\"));\n                element.hide();\n              }\n\n              element.data(EFFECTS, animation.effects).kendoStop(true).kendoAnimate(animation).attr(\"aria-hidden\", false);\n            }\n          },\n          _location: function (isFixed) {\n            var that = this,\n                element = that.element,\n                options = that.options,\n                wrapper,\n                anchor = $(options.anchor),\n                mobile = element[0] && element.hasClass(\"km-widget\");\n\n            if (options.copyAnchorStyles) {\n              if (mobile && styles[0] == \"font-size\") {\n                styles.shift();\n              }\n\n              element.css(kendo.getComputedStyles(anchor[0], styles));\n            }\n\n            that.wrapper = wrapper = kendo.wrap(element, options.autosize).css({\n              overflow: HIDDEN,\n              display: \"block\",\n              position: ABSOLUTE\n            });\n\n            if (support.mobileOS.android) {\n              wrapper.css(TRANSFORM, \"translatez(0)\"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\n            }\n\n            wrapper.css(POSITION);\n\n            if ($(options.appendTo)[0] == document.body) {\n              wrapper.css(TOP, \"-10000px\");\n            }\n\n            that._position(isFixed || {});\n\n            var offset = wrapper.offset();\n            return {\n              width: kendo._outerWidth(wrapper),\n              height: kendo._outerHeight(wrapper),\n              left: offset.left,\n              top: offset.top\n            };\n          },\n          _openAnimation: function () {\n            var animation = extend(true, {}, this.options.animation.open);\n            animation.effects = kendo.parseEffects(animation.effects, this.flipped);\n            return animation;\n          },\n          _hideDirClass: function () {\n            var anchor = $(this.options.anchor);\n            var direction = ((anchor.attr(\"class\") || \"\").match(ACTIVEBORDERREGEXP) || [\"\", \"down\"])[1];\n            var dirClass = ACTIVEBORDER + \"-\" + direction;\n            anchor.removeClass(dirClass).children(ACTIVECHILDREN).removeClass(ACTIVE).removeClass(dirClass);\n            this.element.removeClass(ACTIVEBORDER + \"-\" + kendo.directions[direction].reverse);\n          },\n          _showDirClass: function (animation) {\n            var direction = animation.effects.slideIn ? animation.effects.slideIn.direction : \"down\";\n            var dirClass = ACTIVEBORDER + \"-\" + direction;\n            $(this.options.anchor).addClass(dirClass).children(ACTIVECHILDREN).addClass(ACTIVE).addClass(dirClass);\n            this.element.addClass(ACTIVEBORDER + \"-\" + kendo.directions[direction].reverse);\n          },\n          position: function () {\n            if (this.visible()) {\n              this.flipped = this._position(); //this._hideDirClass();\n              //this._showDirClass(this._openAnimation());\n            }\n          },\n          toggle: function () {\n            var that = this;\n            that[that.visible() ? CLOSE : OPEN]();\n          },\n          visible: function () {\n            return this.element.is(\":\" + VISIBLE);\n          },\n          close: function (skipEffects) {\n            var that = this,\n                options = that.options,\n                wrap,\n                animation,\n                openEffects,\n                closeEffects;\n\n            if (that.visible()) {\n              wrap = that.wrapper[0] ? that.wrapper : kendo.wrap(that.element).hide();\n\n              that._toggleResize(false);\n\n              if (that._closing || that._trigger(CLOSE)) {\n                that._toggleResize(true);\n\n                return;\n              } // Close all inclusive popups.\n\n\n              that.element.find(\".k-popup\").each(function () {\n                var that = $(this),\n                    popup = that.data(\"kendoPopup\");\n\n                if (popup) {\n                  popup.close(skipEffects);\n                }\n              });\n              DOCUMENT_ELEMENT.off(that.downEvent, that._mousedownProxy);\n\n              if (skipEffects) {\n                animation = {\n                  hide: true,\n                  effects: {}\n                };\n              } else {\n                animation = extend(true, {}, options.animation.close);\n                openEffects = that.element.data(EFFECTS);\n                closeEffects = animation.effects;\n\n                if (!closeEffects && !kendo.size(closeEffects) && openEffects && kendo.size(openEffects)) {\n                  animation.effects = openEffects;\n                  animation.reverse = true;\n                }\n\n                that._closing = true;\n              }\n\n              that.element.kendoStop(true).attr(\"aria-hidden\", true);\n              wrap.css({\n                overflow: HIDDEN\n              }) // stop callback will remove hidden overflow\n              .attr(\"aria-hidden\", true);\n              that.element.kendoAnimate(animation);\n\n              if (skipEffects) {\n                that._animationClose();\n              }\n            }\n          },\n          _trigger: function (ev) {\n            return this.trigger(ev, {\n              type: ev\n            });\n          },\n          _resize: function (e) {\n            var that = this;\n\n            if (support.resize.indexOf(e.type) !== -1) {\n              clearTimeout(that._resizeTimeout);\n              that._resizeTimeout = setTimeout(function () {\n                that._position();\n\n                that._resizeTimeout = null;\n              }, 50);\n            } else {\n              if (!that._hovered || that._activated && that.element.find(\".k-list\").length > 0) {\n                that.close();\n              }\n            }\n          },\n          _toggleResize: function (toggle) {\n            var method = toggle ? \"on\" : \"off\";\n            var eventNames = support.resize;\n\n            if (!(support.mobileOS.ios || support.mobileOS.android || support.browser.safari)) {\n              eventNames += \" \" + SCROLL;\n            }\n\n            if (toggle && !this.scrollableParents) {\n              this.scrollableParents = this._scrollableParents();\n            }\n\n            if (this.scrollableParents && this.scrollableParents.length) {\n              this.scrollableParents[method](SCROLL, this._resizeProxy);\n            }\n\n            WINDOW[method](eventNames, this._resizeProxy);\n          },\n          _mousedown: function (e) {\n            var that = this,\n                container = that.element[0],\n                options = that.options,\n                anchor = $(options.anchor)[0],\n                toggleTarget = options.toggleTarget,\n                target = kendo.eventTarget(e),\n                popup = $(target).closest(\".k-popup\"),\n                mobile = popup.parent().parent(\".km-shim\").length;\n            popup = popup[0];\n\n            if (!mobile && popup && popup !== that.element[0]) {\n              return;\n            } // This MAY result in popup not closing in certain cases.\n\n\n            if ($(e.target).closest(\"a\").data(\"rel\") === \"popover\") {\n              return;\n            }\n\n            if (!contains(container, target) && !contains(anchor, target) && !(toggleTarget && contains($(toggleTarget)[0], target))) {\n              that.close();\n            }\n          },\n          _fit: function (position, size, viewPortSize) {\n            var output = 0;\n\n            if (position + size > viewPortSize) {\n              output = viewPortSize - (position + size);\n            }\n\n            if (position < 0) {\n              output = -position;\n            }\n\n            return output;\n          },\n          _flip: function (offset, size, anchorSize, viewPortSize, origin, position, boxSize) {\n            var output = 0;\n            boxSize = boxSize || size;\n\n            if (position !== origin && position !== CENTER && origin !== CENTER) {\n              if (offset + boxSize > viewPortSize) {\n                output += -(anchorSize + size);\n              }\n\n              if (offset + output < 0) {\n                output += anchorSize + size;\n              }\n            }\n\n            return output;\n          },\n          _scrollableParents: function () {\n            return $(this.options.anchor).parentsUntil(\"body\").filter(function (index, element) {\n              return kendo.isScrollable(element);\n            });\n          },\n          _position: function (fixed) {\n            var that = this,\n                //element = that.element.css(POSITION, \"\"), /* fixes telerik/kendo-ui-core#790, comes from telerik/kendo#615 */\n            element = that.element,\n                wrapper = that.wrapper,\n                options = that.options,\n                viewport = $(options.viewport),\n                zoomLevel = support.zoomLevel(),\n                isWindow = !!(viewport[0] == window && window.innerWidth && zoomLevel <= 1.02),\n                anchor = $(options.anchor),\n                origins = options.origin.toLowerCase().split(\" \"),\n                positions = options.position.toLowerCase().split(\" \"),\n                collisions = that.collisions,\n                siblingContainer,\n                parents,\n                parentZIndex,\n                zIndex = 10002,\n                idx = 0,\n                docEl = document.documentElement,\n                length,\n                viewportOffset,\n                viewportWidth,\n                viewportHeight;\n\n            if (options.viewport === window) {\n              viewportOffset = {\n                top: window.pageYOffset || document.documentElement.scrollTop || 0,\n                left: window.pageXOffset || document.documentElement.scrollLeft || 0\n              };\n            } else {\n              viewportOffset = viewport.offset();\n            }\n\n            if (isWindow) {\n              viewportWidth = window.innerWidth;\n              viewportHeight = window.innerHeight;\n            } else {\n              viewportWidth = viewport.width();\n              viewportHeight = viewport.height();\n            }\n\n            if (isWindow && docEl.scrollHeight - docEl.clientHeight > 0) {\n              var sign = options.isRtl ? -1 : 1;\n              viewportWidth -= sign * kendo.support.scrollbar();\n            }\n\n            siblingContainer = anchor.parents().filter(wrapper.siblings());\n\n            if (siblingContainer[0]) {\n              parentZIndex = Math.max(Number(siblingContainer.css(\"zIndex\")), 0); // set z-index to be more than that of the container/sibling\n              // compensate with more units for window z-stack\n\n              if (parentZIndex) {\n                zIndex = parentZIndex + 10;\n              } else {\n                parents = anchor.parentsUntil(siblingContainer);\n\n                for (length = parents.length; idx < length; idx++) {\n                  parentZIndex = Number($(parents[idx]).css(\"zIndex\"));\n\n                  if (parentZIndex && zIndex < parentZIndex) {\n                    zIndex = parentZIndex + 10;\n                  }\n                }\n              }\n            }\n\n            wrapper.css(\"zIndex\", zIndex);\n\n            if (fixed && fixed.isFixed) {\n              wrapper.css({\n                left: fixed.x,\n                top: fixed.y\n              });\n            } else {\n              wrapper.css(that._align(origins, positions));\n            }\n\n            var pos = getOffset(wrapper, POSITION, anchor[0] === wrapper.offsetParent()[0]),\n                offset = getOffset(wrapper),\n                anchorParent = anchor.offsetParent().parent(\".k-animation-container,.k-popup,.k-group\"); // If the parent is positioned, get the current positions\n\n            if (anchorParent.length) {\n              pos = getOffset(wrapper, POSITION, true);\n              offset = getOffset(wrapper);\n            }\n\n            offset.top -= viewportOffset.top;\n            offset.left -= viewportOffset.left;\n\n            if (!that.wrapper.data(LOCATION)) {\n              // Needed to reset the popup location after every closure - fixes the resize bugs.\n              wrapper.data(LOCATION, extend({}, pos));\n            }\n\n            var offsets = extend({}, offset),\n                location = extend({}, pos),\n                adjustSize = options.adjustSize;\n\n            if (collisions[0] === \"fit\") {\n              location.top += that._fit(offsets.top, outerHeight(wrapper) + adjustSize.height, viewportHeight / zoomLevel);\n            }\n\n            if (collisions[1] === \"fit\") {\n              location.left += that._fit(offsets.left, outerWidth(wrapper) + adjustSize.width, viewportWidth / zoomLevel);\n            }\n\n            var flipPos = extend({}, location);\n            var elementHeight = outerHeight(element);\n            var wrapperHeight = outerHeight(wrapper);\n\n            if (!wrapper.height() && elementHeight) {\n              wrapperHeight = wrapperHeight + elementHeight;\n            }\n\n            if (collisions[0] === \"flip\") {\n              location.top += that._flip(offsets.top, elementHeight, outerHeight(anchor), viewportHeight / zoomLevel, origins[0], positions[0], wrapperHeight);\n            }\n\n            if (collisions[1] === \"flip\") {\n              location.left += that._flip(offsets.left, outerWidth(element), outerWidth(anchor), viewportWidth / zoomLevel, origins[1], positions[1], outerWidth(wrapper));\n            }\n\n            element.css(POSITION, ABSOLUTE);\n            wrapper.css(location);\n            return location.left != flipPos.left || location.top != flipPos.top;\n          },\n          _align: function (origin, position) {\n            var that = this,\n                element = that.wrapper,\n                anchor = $(that.options.anchor),\n                verticalOrigin = origin[0],\n                horizontalOrigin = origin[1],\n                verticalPosition = position[0],\n                horizontalPosition = position[1],\n                anchorOffset = getOffset(anchor),\n                appendTo = $(that.options.appendTo),\n                appendToOffset,\n                width = outerWidth(element),\n                height = outerHeight(element) || outerHeight(element.children().first()),\n                anchorWidth = outerWidth(anchor),\n                anchorHeight = outerHeight(anchor),\n                top = that.options.omitOriginOffsets ? 0 : anchorOffset.top,\n                left = that.options.omitOriginOffsets ? 0 : anchorOffset.left,\n                round = Math.round;\n\n            if (appendTo[0] != document.body) {\n              appendToOffset = getOffset(appendTo);\n              top -= appendToOffset.top;\n              left -= appendToOffset.left;\n            }\n\n            if (verticalOrigin === BOTTOM) {\n              top += anchorHeight;\n            }\n\n            if (verticalOrigin === CENTER) {\n              top += round(anchorHeight / 2);\n            }\n\n            if (verticalPosition === BOTTOM) {\n              top -= height;\n            }\n\n            if (verticalPosition === CENTER) {\n              top -= round(height / 2);\n            }\n\n            if (horizontalOrigin === RIGHT) {\n              left += anchorWidth;\n            }\n\n            if (horizontalOrigin === CENTER) {\n              left += round(anchorWidth / 2);\n            }\n\n            if (horizontalPosition === RIGHT) {\n              left -= width;\n            }\n\n            if (horizontalPosition === CENTER) {\n              left -= round(width / 2);\n            }\n\n            return {\n              top: top,\n              left: left\n            };\n          }\n        });\n        ui.plugin(Popup);\n        var stableSort = kendo.support.stableSort;\n        var tabKeyTrapNS = \"kendoTabKeyTrap\";\n        var focusableNodesSelector = \"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], *[contenteditable]\";\n        var TabKeyTrap = Class.extend({\n          init: function (element) {\n            this.element = $(element);\n            this.element.autoApplyNS(tabKeyTrapNS);\n          },\n          trap: function () {\n            this.element.on(\"keydown\", this._keepInTrap.bind(this));\n          },\n          removeTrap: function () {\n            this.element.kendoDestroy(tabKeyTrapNS);\n          },\n          destroy: function () {\n            this.element.kendoDestroy(tabKeyTrapNS);\n            this.element = undefined;\n          },\n          shouldTrap: function () {\n            return true;\n          },\n          _keepInTrap: function (e) {\n            if (e.which !== 9 || !this.shouldTrap() || e.isDefaultPrevented()) {\n              return;\n            }\n\n            var elements = this._focusableElements();\n\n            var sortedElements = this._sortFocusableElements(elements);\n\n            var next = this._nextFocusable(e, sortedElements);\n\n            this._focus(next);\n\n            e.preventDefault();\n          },\n          _focusableElements: function () {\n            var elements = this.element.find(focusableNodesSelector).filter(function (i, item) {\n              return item.tabIndex >= 0 && $(item).is(':visible') && !$(item).is('[disabled]');\n            });\n\n            if (this.element.is(\"[tabindex]\")) {\n              elements.push(this.element[0]);\n            }\n\n            return elements;\n          },\n          _sortFocusableElements: function (elements) {\n            var sortedElements;\n\n            if (stableSort) {\n              sortedElements = elements.sort(function (prev, next) {\n                return prev.tabIndex - next.tabIndex;\n              });\n            } else {\n              var attrName = \"__k_index\";\n              elements.each(function (i, item) {\n                item.setAttribute(attrName, i);\n              });\n              sortedElements = elements.sort(function (prev, next) {\n                return prev.tabIndex === next.tabIndex ? parseInt(prev.getAttribute(attrName), 10) - parseInt(next.getAttribute(attrName), 10) : prev.tabIndex - next.tabIndex;\n              });\n              elements.removeAttr(attrName);\n            }\n\n            return sortedElements;\n          },\n          _nextFocusable: function (e, elements) {\n            var count = elements.length;\n            var current = elements.index(e.target);\n            return elements.get((current + (e.shiftKey ? -1 : 1)) % count);\n          },\n          _focus: function (element) {\n            if (element.nodeName == \"IFRAME\") {\n              element.contentWindow.document.body.focus();\n              return;\n            }\n\n            element.focus();\n\n            if (element.nodeName == \"INPUT\" && element.setSelectionRange && this._haveSelectionRange(element)) {\n              element.setSelectionRange(0, element.value.length);\n            }\n          },\n          _haveSelectionRange: function (element) {\n            var elementType = element.type.toLowerCase();\n            return elementType === \"text\" || elementType === \"search\" || elementType === \"url\" || elementType === \"tel\" || elementType === \"password\";\n          }\n        });\n        ui.Popup.TabKeyTrap = TabKeyTrap;\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}