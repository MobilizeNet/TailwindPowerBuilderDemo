{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesAggregator from '../aggregates/series-aggregator';\nimport DefaultAggregates from '../aggregates/default-aggregates';\nimport SeriesBinder from '../series-binder';\nimport BarChart from '../bar-chart/bar-chart';\nimport RangeBarChart from '../range-bar-chart/range-bar-chart';\nimport BulletChart from '../bullet-chart/bullet-chart';\nimport LineChart from '../line-chart/line-chart';\nimport AreaChart from '../area-chart/area-chart';\nimport RangeAreaChart from '../range-area-chart/range-area-chart';\nimport OHLCChart from '../ohlc-chart/ohlc-chart';\nimport CandlestickChart from '../candlestick-chart/candlestick-chart';\nimport BoxPlotChart from '../box-plot-chart/box-plot-chart';\nimport WaterfallChart from '../waterfall-chart/waterfall-chart';\nimport { CategoryAxis, DateCategoryAxis, NumericAxis, LogarithmicAxis, Point } from '../../core';\nimport { appendIfNotNull, categoriesCount, createOutOfRangePoints, equalsIgnoreCase, filterSeriesByType, getDateField, getField, isDateAxis, singleItemOrArray } from '../utils';\nimport { BAR, COLUMN, BULLET, VERTICAL_BULLET, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, BOX_PLOT, VERTICAL_BOX_PLOT, OHLC, CANDLESTICK, LOGARITHMIC, STEP, EQUALLY_SPACED_SERIES } from '../constants';\nimport { DATE, MAX_VALUE } from '../../common/constants';\nimport { setDefaultOptions, inArray, isNumber, deepExtend, defined, eventElement, grep } from '../../common';\nconst AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];\nconst OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);\n\nclass CategoricalPlotArea extends PlotAreaBase {\n  initFields(series) {\n    this.namedCategoryAxes = {};\n    this.namedValueAxes = {};\n    this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n\n    if (series.length > 0) {\n      this.invertAxes = inArray(series[0].type, [BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA, RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT]);\n\n      for (let i = 0; i < series.length; i++) {\n        const stack = series[i].stack;\n\n        if (stack && stack.type === \"100%\") {\n          this.stack100 = true;\n          break;\n        }\n      }\n    }\n  }\n\n  render(panes = this.panes) {\n    this.createCategoryAxes(panes);\n    this.aggregateCategories(panes);\n    this.createCategoryAxesLabels(panes);\n    this.createCharts(panes);\n    this.createValueAxes(panes);\n  }\n\n  removeAxis(axis) {\n    const axisName = axis.options.name;\n    super.removeAxis(axis);\n\n    if (axis instanceof CategoryAxis) {\n      delete this.namedCategoryAxes[axisName];\n    } else {\n      this.valueAxisRangeTracker.reset(axisName);\n      delete this.namedValueAxes[axisName];\n    }\n\n    if (axis === this.categoryAxis) {\n      delete this.categoryAxis;\n    }\n\n    if (axis === this.valueAxis) {\n      delete this.valueAxis;\n    }\n  }\n\n  createCharts(panes) {\n    const seriesByPane = this.groupSeriesByPane();\n\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this.addToLegend(paneSeries);\n      const visibleSeries = this.filterVisibleSeries(paneSeries);\n\n      if (!visibleSeries) {\n        continue;\n      }\n\n      const groups = this.groupSeriesByCategoryAxis(visibleSeries);\n\n      for (let groupIx = 0; groupIx < groups.length; groupIx++) {\n        this.createChartGroup(groups[groupIx], pane);\n      }\n    }\n  }\n\n  createChartGroup(series, pane) {\n    this.createAreaChart(filterSeriesByType(series, [AREA, VERTICAL_AREA]), pane);\n    this.createRangeAreaChart(filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]), pane);\n    this.createBarChart(filterSeriesByType(series, [COLUMN, BAR]), pane);\n    this.createRangeBarChart(filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]), pane);\n    this.createBulletChart(filterSeriesByType(series, [BULLET, VERTICAL_BULLET]), pane);\n    this.createCandlestickChart(filterSeriesByType(series, CANDLESTICK), pane);\n    this.createBoxPlotChart(filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]), pane);\n    this.createOHLCChart(filterSeriesByType(series, OHLC), pane);\n    this.createWaterfallChart(filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]), pane);\n    this.createLineChart(filterSeriesByType(series, [LINE, VERTICAL_LINE]), pane);\n  }\n\n  aggregateCategories(panes) {\n    const series = this.srcSeries || this.series;\n    const processedSeries = [];\n    this._currentPointsCache = {};\n    this._seriesPointsCache = this._seriesPointsCache || {};\n\n    for (let i = 0; i < series.length; i++) {\n      let currentSeries = series[i];\n      const categoryAxis = this.seriesCategoryAxis(currentSeries);\n      const axisPane = this.findPane(categoryAxis.options.pane);\n      const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n      if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n        currentSeries = this.aggregateSeries(currentSeries, categoryAxis);\n      } else {\n        currentSeries = this.filterSeries(currentSeries, categoryAxis);\n      }\n\n      processedSeries.push(currentSeries);\n    }\n\n    this._seriesPointsCache = this._currentPointsCache;\n    this._currentPointsCache = null;\n    this.srcSeries = series;\n    this.series = processedSeries;\n  }\n\n  filterSeries(series, categoryAxis) {\n    const dataLength = (series.data || {}).length;\n    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n    if (!(isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max))) {\n      return series;\n    }\n\n    const range = categoryAxis.currentRangeIndices();\n    const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n    const currentSeries = deepExtend({}, series);\n    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n    if (outOfRangePoints) {\n      createOutOfRangePoints(currentSeries, range, dataLength, idx => ({\n        item: series.data[idx],\n        category: categoryAxis.categoryAt(idx, true),\n        categoryIx: idx - range.min\n      }), idx => defined(series.data[idx]));\n    }\n\n    return currentSeries;\n  }\n\n  clearSeriesPointsCache() {\n    this._seriesPointsCache = {};\n  }\n\n  seriesSourcePoints(series, categoryAxis) {\n    const key = `${series.index};${categoryAxis.categoriesHash()}`;\n\n    if (this._seriesPointsCache[key]) {\n      this._currentPointsCache[key] = this._seriesPointsCache[key];\n      return this._seriesPointsCache[key];\n    }\n\n    const axisOptions = categoryAxis.options;\n    const srcCategories = axisOptions.srcCategories;\n    const dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n    const srcData = series.data;\n    const getFn = dateAxis ? getDateField : getField;\n    const result = [];\n\n    if (!dateAxis) {\n      categoryAxis.mapCategories(); //fixes major performance issue caused by searching for the index for large data\n    }\n\n    for (let idx = 0; idx < srcData.length; idx++) {\n      let category;\n\n      if (series.categoryField) {\n        category = getFn(series.categoryField, srcData[idx], this.chartService.intl);\n      } else {\n        category = srcCategories[idx];\n      }\n\n      if (defined(category) && category !== null) {\n        const categoryIx = categoryAxis.totalIndex(category);\n        result[categoryIx] = result[categoryIx] || {\n          items: [],\n          category: category\n        };\n        result[categoryIx].items.push(idx);\n      }\n    }\n\n    this._currentPointsCache[key] = result;\n    return result;\n  }\n\n  aggregateSeries(series, categoryAxis) {\n    const srcData = series.data;\n\n    if (!srcData.length) {\n      return series;\n    }\n\n    const srcPoints = this.seriesSourcePoints(series, categoryAxis);\n    const result = deepExtend({}, series);\n    const aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n    const data = result.data = [];\n    const dataItems = categoryAxis.options.dataItems || [];\n    const range = categoryAxis.currentRangeIndices();\n\n    const categoryItem = idx => {\n      const categoryIdx = idx - range.min;\n      let point = srcPoints[idx];\n\n      if (!point) {\n        point = srcPoints[idx] = {};\n      }\n\n      point.categoryIx = categoryIdx;\n\n      if (!point.item) {\n        const category = categoryAxis.categoryAt(idx, true);\n        point.category = category;\n        point.item = aggregator.aggregatePoints(point.items, category);\n      }\n\n      return point;\n    };\n\n    for (let idx = range.min; idx <= range.max; idx++) {\n      const point = categoryItem(idx);\n      data[point.categoryIx] = point.item;\n\n      if (point.items && point.items.length) {\n        dataItems[point.categoryIx] = point.item;\n      }\n    }\n\n    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, idx => srcPoints[idx]);\n    }\n\n    categoryAxis.options.dataItems = dataItems;\n    return result;\n  }\n\n  appendChart(chart, pane) {\n    const series = chart.options.series;\n    const categoryAxis = this.seriesCategoryAxis(series[0]);\n    let categories = categoryAxis.options.categories;\n    let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n    if (categoriesToAdd > 0) {\n      //consider setting an option to axis instead of adding fake categories\n      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n\n      while (categoriesToAdd--) {\n        categories.push(\"\");\n      }\n    }\n\n    this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n    super.appendChart(chart, pane);\n  } // TODO: Refactor, optionally use series.pane option\n\n\n  seriesPaneName(series) {\n    const options = this.options;\n    const axisName = series.axis;\n    const axisOptions = [].concat(options.valueAxis);\n    const axis = grep(axisOptions, function (a) {\n      return a.name === axisName;\n    })[0];\n    const panes = options.panes || [{}];\n    const defaultPaneName = (panes[0] || {}).name || \"default\";\n    const paneName = (axis || {}).pane || defaultPaneName;\n    return paneName;\n  }\n\n  seriesCategoryAxis(series) {\n    const axisName = series.categoryAxis;\n    const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n    if (!axis) {\n      throw new Error(\"Unable to locate category axis with name \" + axisName);\n    }\n\n    return axis;\n  }\n\n  stackableChartOptions(firstSeries, pane) {\n    const stack = firstSeries.stack;\n    const isStacked100 = stack && stack.type === \"100%\";\n    const clip = pane.options.clip;\n    return {\n      isStacked: stack,\n      isStacked100: isStacked100,\n      clip: clip\n    };\n  }\n\n  groupSeriesByCategoryAxis(series) {\n    const categoryAxes = [];\n    const unique = {};\n\n    for (let idx = 0; idx < series.length; idx++) {\n      const name = series[idx].categoryAxis || \"$$default$$\";\n\n      if (!unique.hasOwnProperty(name)) {\n        unique[name] = true;\n        categoryAxes.push(name);\n      }\n    }\n\n    const groups = [];\n\n    for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n      const axis = categoryAxes[axisIx];\n      const axisSeries = groupSeries(series, axis, axisIx);\n\n      if (axisSeries.length === 0) {\n        continue;\n      }\n\n      groups.push(axisSeries);\n    }\n\n    return groups;\n  }\n\n  createBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const barChart = new BarChart(this, Object.assign({\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(barChart, pane);\n  }\n\n  createRangeBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const rangeColumnChart = new RangeBarChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(rangeColumnChart, pane);\n  }\n\n  createBulletChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const bulletChart = new BulletChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(bulletChart, pane);\n  }\n\n  createLineChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const lineChart = new LineChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(lineChart, pane);\n  }\n\n  createAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const areaChart = new AreaChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(areaChart, pane);\n  }\n\n  createRangeAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const rangeAreaChart = new RangeAreaChart(this, {\n      invertAxes: this.invertAxes,\n      series: series,\n      clip: pane.options.clip\n    });\n    this.appendChart(rangeAreaChart, pane);\n  }\n\n  createOHLCChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const chart = new OHLCChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n\n  createCandlestickChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const chart = new CandlestickChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n\n  createBoxPlotChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const chart = new BoxPlotChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n\n  createWaterfallChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    const firstSeries = series[0];\n    const waterfallChart = new WaterfallChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(waterfallChart, pane);\n  }\n\n  axisRequiresRounding(categoryAxisName, categoryAxisIndex) {\n    const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n    for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n      const currentSeries = this.series[seriesIx];\n\n      if (inArray(currentSeries.type, AREA_SERIES)) {\n        const line = currentSeries.line;\n\n        if (line && line.style === STEP) {\n          centeredSeries.push(currentSeries);\n        }\n      }\n    }\n\n    for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {\n      const seriesAxis = centeredSeries[seriesIx].categoryAxis || \"\";\n\n      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {\n        return true;\n      }\n    }\n  }\n\n  aggregatedAxis(categoryAxisName, categoryAxisIndex) {\n    const series = this.series;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const seriesAxis = series[seriesIx].categoryAxis || \"\";\n\n      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {\n        return true;\n      }\n    }\n  }\n\n  createCategoryAxesLabels() {\n    const axes = this.axes;\n\n    for (let i = 0; i < axes.length; i++) {\n      if (axes[i] instanceof CategoryAxis) {\n        axes[i].createLabels();\n      }\n    }\n  }\n\n  createCategoryAxes(panes) {\n    const invertAxes = this.invertAxes;\n    const definitions = [].concat(this.options.categoryAxis);\n    const axes = [];\n\n    for (let i = 0; i < definitions.length; i++) {\n      let axisOptions = definitions[i];\n      const axisPane = this.findPane(axisOptions.pane);\n\n      if (inArray(axisPane, panes)) {\n        const {\n          name,\n          categories = []\n        } = axisOptions;\n        axisOptions = deepExtend({\n          vertical: invertAxes,\n          reverse: !invertAxes && this.chartService.rtl,\n          axisCrossingValue: invertAxes ? MAX_VALUE : 0\n        }, axisOptions);\n\n        if (!defined(axisOptions.justified)) {\n          axisOptions.justified = this.isJustified();\n        }\n\n        if (this.axisRequiresRounding(name, i)) {\n          axisOptions.justified = false;\n        }\n\n        let categoryAxis;\n\n        if (isDateAxis(axisOptions, categories[0])) {\n          categoryAxis = new DateCategoryAxis(axisOptions, this.chartService);\n        } else {\n          categoryAxis = new CategoryAxis(axisOptions, this.chartService);\n        }\n\n        definitions[i].categories = categoryAxis.options.srcCategories;\n\n        if (name) {\n          if (this.namedCategoryAxes[name]) {\n            throw new Error(`Category axis with name ${name} is already defined`);\n          }\n\n          this.namedCategoryAxes[name] = categoryAxis;\n        }\n\n        categoryAxis.axisIndex = i;\n        axes.push(categoryAxis);\n        this.appendAxis(categoryAxis);\n      }\n    }\n\n    const primaryAxis = this.categoryAxis || axes[0];\n    this.categoryAxis = primaryAxis;\n\n    if (invertAxes) {\n      this.axisY = primaryAxis;\n    } else {\n      this.axisX = primaryAxis;\n    }\n  }\n\n  isJustified() {\n    const series = this.series;\n\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n\n      if (!inArray(currentSeries.type, AREA_SERIES)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  createValueAxes(panes) {\n    const tracker = this.valueAxisRangeTracker;\n    const defaultRange = tracker.query();\n    const definitions = [].concat(this.options.valueAxis);\n    const invertAxes = this.invertAxes;\n    const baseOptions = {\n      vertical: !invertAxes,\n      reverse: invertAxes && this.chartService.rtl\n    };\n    const axes = [];\n\n    if (this.stack100) {\n      baseOptions.roundToMajorUnit = false;\n      baseOptions.labels = {\n        format: \"P0\"\n      };\n    }\n\n    for (let i = 0; i < definitions.length; i++) {\n      const axisOptions = definitions[i];\n      const axisPane = this.findPane(axisOptions.pane);\n\n      if (inArray(axisPane, panes)) {\n        const name = axisOptions.name;\n        const defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? {\n          min: 0.1,\n          max: 1\n        } : {\n          min: 0,\n          max: 1\n        };\n        const range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n        if (i === 0 && range && defaultRange) {\n          range.min = Math.min(range.min, defaultRange.min);\n          range.max = Math.max(range.max, defaultRange.max);\n        }\n\n        let axisType;\n\n        if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n          axisType = LogarithmicAxis;\n        } else {\n          axisType = NumericAxis;\n        }\n\n        const valueAxis = new axisType(range.min, range.max, deepExtend({}, baseOptions, axisOptions), this.chartService);\n\n        if (name) {\n          if (this.namedValueAxes[name]) {\n            throw new Error(`Value axis with name ${name} is already defined`);\n          }\n\n          this.namedValueAxes[name] = valueAxis;\n        }\n\n        valueAxis.axisIndex = i;\n        axes.push(valueAxis);\n        this.appendAxis(valueAxis);\n      }\n    }\n\n    const primaryAxis = this.valueAxis || axes[0];\n    this.valueAxis = primaryAxis;\n\n    if (invertAxes) {\n      this.axisX = primaryAxis;\n    } else {\n      this.axisY = primaryAxis;\n    }\n  }\n\n  _dispatchEvent(chart, e, eventType) {\n    const coords = chart._eventCoordinates(e);\n\n    const point = new Point(coords.x, coords.y);\n    const pane = this.pointPane(point);\n    const categories = [];\n    const values = [];\n\n    if (!pane) {\n      return;\n    }\n\n    const allAxes = pane.axes;\n\n    for (let i = 0; i < allAxes.length; i++) {\n      const axis = allAxes[i];\n\n      if (axis.getValue) {\n        appendIfNotNull(values, axis.getValue(point));\n      } else {\n        appendIfNotNull(categories, axis.getCategory(point));\n      }\n    }\n\n    if (categories.length === 0) {\n      appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n    }\n\n    if (categories.length > 0 && values.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        category: singleItemOrArray(categories),\n        value: singleItemOrArray(values)\n      });\n    }\n  }\n\n  pointPane(point) {\n    const panes = this.panes;\n\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n\n      if (currentPane.contentBox.containsPoint(point)) {\n        return currentPane;\n      }\n    }\n  }\n\n  updateAxisOptions(axis, options) {\n    updateAxisOptions(this.options, axis, options);\n    updateAxisOptions(this.originalOptions, axis, options);\n  }\n\n}\n\nfunction updateAxisOptions(targetOptions, axis, options) {\n  const axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n  deepExtend(axesOptions[axis.axisIndex], options);\n}\n\nfunction groupSeries(series, axis, axisIx) {\n  return grep(series, function (s) {\n    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;\n  });\n}\n\nsetDefaultOptions(CategoricalPlotArea, {\n  categoryAxis: {},\n  valueAxis: {}\n});\ndeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\nexport default CategoricalPlotArea;","map":null,"metadata":{},"sourceType":"module"}