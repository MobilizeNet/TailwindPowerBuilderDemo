{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, forwardRef, Directive, Input, EventEmitter, Component, HostBinding, Output, isDevMode, Optional, Inject, ContentChild, ElementRef, NgModule } from '@angular/core';\nimport { filter, debounceTime, take, auditTime } from 'rxjs/operators';\nimport { fromEvent, Subscription, BehaviorSubject, Subject, combineLatest } from 'rxjs';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport { PreventableEvent, isDocumentAvailable, closest, hasObservers } from '@progress/kendo-angular-common';\n/**\n * @hidden\n */\n\nfunction TooltipContentComponent_div_2_ng_template_1_Template(rf, ctx) {}\n\nconst _c2 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    anchor: a1\n  };\n};\n\nfunction TooltipContentComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtemplate(1, TooltipContentComponent_div_2_ng_template_1_Template, 0, 0, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.titleTemplate)(\"ngTemplateOutlet\", ctx_r0.titleTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c2, ctx_r0.anchor, ctx_r0.anchor));\n  }\n}\n\nfunction TooltipContentComponent_ng_template_3_Template(rf, ctx) {}\n\nfunction TooltipContentComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.templateString, \" \");\n  }\n}\n\nfunction TooltipContentComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵlistener(\"click\", function TooltipContentComponent_div_5_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.onCloseClick($event);\n    });\n    i0.ɵɵelement(1, \"a\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"title\", ctx_r3.closeButtonTitle);\n  }\n}\n\nfunction TooltipContentComponent_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r4.calloutPositionClass());\n  }\n}\n\nfunction PopoverComponent_div_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.getCalloutPosition());\n  }\n}\n\nfunction PopoverComponent_div_0_div_2_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c3 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    data: a1\n  };\n};\n\nfunction PopoverComponent_div_0_div_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PopoverComponent_div_0_div_2_1_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.titleTemplate == null ? null : ctx_r5.titleTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c3, ctx_r5.anchor, ctx_r5.contextData));\n  }\n}\n\nfunction PopoverComponent_div_0_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r6.title, \" \");\n  }\n}\n\nfunction PopoverComponent_div_0_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtemplate(1, PopoverComponent_div_0_div_2_1_Template, 1, 5, null, 8);\n    i0.ɵɵtemplate(2, PopoverComponent_div_0_div_2_ng_container_2_Template, 2, 1, \"ng-container\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.titleTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.title && !ctx_r2.titleTemplate);\n  }\n}\n\nfunction PopoverComponent_div_0_div_3_1_ng_template_0_Template(rf, ctx) {}\n\nfunction PopoverComponent_div_0_div_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PopoverComponent_div_0_div_3_1_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.bodyTemplate == null ? null : ctx_r8.bodyTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c3, ctx_r8.anchor, ctx_r8.contextData));\n  }\n}\n\nfunction PopoverComponent_div_0_div_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.body, \" \");\n  }\n}\n\nfunction PopoverComponent_div_0_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 10);\n    i0.ɵɵtemplate(1, PopoverComponent_div_0_div_3_1_Template, 1, 5, null, 8);\n    i0.ɵɵtemplate(2, PopoverComponent_div_0_div_3_ng_container_2_Template, 2, 1, \"ng-container\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.bodyTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.body && !ctx_r3.bodyTemplate);\n  }\n}\n\nfunction PopoverComponent_div_0_div_4_1_ng_template_0_Template(rf, ctx) {}\n\nfunction PopoverComponent_div_0_div_4_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PopoverComponent_div_0_div_4_1_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r11.actionsTemplate == null ? null : ctx_r11.actionsTemplate.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c3, ctx_r11.anchor, ctx_r11.contextData));\n  }\n}\n\nfunction PopoverComponent_div_0_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtemplate(1, PopoverComponent_div_0_div_4_1_Template, 1, 5, null, 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.actionsTemplate);\n  }\n}\n\nconst _c4 = function (a0, a1) {\n  return {\n    \"width\": a0,\n    \"height\": a1\n  };\n};\n\nfunction PopoverComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵtemplate(1, PopoverComponent_div_0_div_1_Template, 1, 1, \"div\", 2);\n    i0.ɵɵtemplate(2, PopoverComponent_div_0_div_2_Template, 3, 2, \"div\", 3);\n    i0.ɵɵtemplate(3, PopoverComponent_div_0_div_3_Template, 3, 2, \"div\", 4);\n    i0.ɵɵtemplate(4, PopoverComponent_div_0_div_4_Template, 2, 1, \"div\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction2(5, _c4, ctx_r0.width, ctx_r0.height));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.callout);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.titleTemplate || ctx_r0.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.bodyTemplate || ctx_r0.body);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.actionsTemplate);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-tooltip',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654094943,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * Obsolete. Provide the TooltipSettings class instead.\n *\n * @hidden\n */\n\nconst TOOLTIP_SETTINGS = new InjectionToken('kendo-ui-tooltip-settings');\n/**\n * Provides a global configuration for the Kendo UI Tooltip. Once injected through\n * the `AppComponent` constructor, the configuration properties can be overridden.\n *\n * @example\n * ```ts-no-run\n * import { TooltipSettings } from '@progress/kendo-angular-tooltip';\n *\n * _@Component({\n *    selector: 'my-app',\n *    template: `\n *      <div kendoTooltip>\n *          <button title=\"Saves the current document\">Save</button>\n *      </div>`,\n *    providers: [{\n *        provide: TooltipSettings,\n *        useFactory: (): TooltipSettings => ({\n *          // Override default values of tooltips if wanted\n *          position: 'right'\n *        })\n *    }]\n * })\n * export class AppComponent { }\n * ```\n */\n\nlet TooltipSettings = /*#__PURE__*/(() => {\n  class TooltipSettings {\n    /**\n     * @hidden\n     */\n    constructor() {}\n\n  }\n\n  TooltipSettings.ɵfac = function TooltipSettings_Factory(t) {\n    return new (t || TooltipSettings)();\n  };\n\n  TooltipSettings.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TooltipSettings,\n    factory: TooltipSettings.ɵfac\n  });\n  return TooltipSettings;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction align(position, offset) {\n  let anchorAlign = {};\n  let popupAlign = {};\n  let popupMargin = {};\n\n  switch (position) {\n    case 'top':\n      anchorAlign = {\n        horizontal: 'center',\n        vertical: 'top'\n      };\n      popupAlign = {\n        horizontal: 'center',\n        vertical: 'bottom'\n      };\n      popupMargin = {\n        horizontal: 0,\n        vertical: offset\n      };\n      break;\n\n    case 'bottom':\n      anchorAlign = {\n        horizontal: 'center',\n        vertical: 'bottom'\n      };\n      popupAlign = {\n        horizontal: 'center',\n        vertical: 'top'\n      };\n      popupMargin = {\n        horizontal: 0,\n        vertical: offset\n      };\n      break;\n\n    case 'right':\n      anchorAlign = {\n        horizontal: 'right',\n        vertical: 'center'\n      };\n      popupAlign = {\n        horizontal: 'left',\n        vertical: 'center'\n      };\n      popupMargin = {\n        horizontal: offset,\n        vertical: 0\n      };\n      break;\n\n    case 'left':\n      anchorAlign = {\n        horizontal: 'left',\n        vertical: 'center'\n      };\n      popupAlign = {\n        horizontal: 'right',\n        vertical: 'center'\n      };\n      popupMargin = {\n        horizontal: offset,\n        vertical: 0\n      };\n      break;\n\n    default:\n      break;\n  }\n\n  return {\n    anchorAlign,\n    popupAlign,\n    popupMargin\n  };\n}\n/**\n * @hidden\n */\n\n\nfunction collision(inputcollision, position) {\n  if (inputcollision) {\n    return inputcollision;\n  }\n\n  if (position === 'top' || position === 'bottom') {\n    return {\n      horizontal: 'fit',\n      vertical: 'flip'\n    };\n  }\n\n  return {\n    horizontal: 'flip',\n    vertical: 'fit'\n  };\n}\n\nfunction isDocumentNode(container) {\n  return container.nodeType === 9;\n}\n/**\n * @hidden\n */\n\n\nfunction closestBySelector(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n\n  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);\n  let node = element;\n\n  while (node && !isDocumentNode(node)) {\n    if (matches(node, selector)) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n}\n/**\n * @hidden\n */\n\n\nfunction contains(container, child) {\n  if (!container) {\n    return false;\n  }\n\n  if (isDocumentNode(container)) {\n    return false;\n  }\n\n  if (container.contains) {\n    return container.contains(child);\n  }\n\n  if (container.compareDocumentPosition) {\n    return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n}\n/**\n * @hidden\n */\n\n\nconst hasParent = (node, parent) => {\n  while (node && node !== parent) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nfunction getCenterOffset(item, dir, size) {\n  const rect = item.getBoundingClientRect();\n  return rect[dir] + rect[size] / 2;\n}\n/**\n * @hidden\n */\n\n\nfunction containsItem(collection, item) {\n  return collection.indexOf(item) !== -1;\n}\n/**\n * @hidden\n */\n\n\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedMessagesDirective extends ComponentMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n    return new (t || LocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoTooltipLocalizedMessages\", \"\"]],\n    inputs: {\n      closeTitle: \"closeTitle\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ComponentMessages,\n      useExisting: forwardRef(() => LocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TooltipContentComponent = /*#__PURE__*/(() => {\n  class TooltipContentComponent {\n    constructor(content, localizationService) {\n      this.content = content;\n      this.localizationService = localizationService;\n      this.close = new EventEmitter();\n      this.tooltipWidth = null;\n      this.tooltipHeight = null;\n      this.callout = true;\n\n      this.calloutStyles = (position, calloutSize, isFlip) => {\n        const styles = {};\n        const isVertical = position === 'top' || position === 'bottom';\n        const flipDeg = '180deg';\n        const zeroDeg = '0deg';\n\n        if (!isFlip) {\n          styles.transform = isVertical ? `rotateX(${zeroDeg})` : `rotateY(${zeroDeg})`;\n          return styles;\n        }\n\n        if (position === 'top') {\n          styles.bottom = 'unset';\n        } else if (position === 'bottom') {\n          styles.top = 'unset';\n        } else if (position === 'left') {\n          styles.right = 'unset';\n        } else if (position === 'right') {\n          styles.left = 'unset';\n        }\n\n        styles[position] = `${-calloutSize}px`;\n        styles.transform = isVertical ? `rotateX(${flipDeg})` : `rotateY(${flipDeg})`;\n        return styles;\n      };\n\n      this.direction = localizationService.rtl ? 'rtl' : 'ltr';\n    }\n\n    get cssClasses() {\n      return 'k-widget k-tooltip';\n    }\n\n    get className() {\n      return this.closable;\n    }\n\n    get cssPosition() {\n      return 'relative';\n    }\n\n    ngOnInit() {\n      this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n\n    ngOnDestroy() {\n      if (this.dynamicRTLSubscription) {\n        this.dynamicRTLSubscription.unsubscribe();\n      }\n    }\n\n    get closeButtonTitle() {\n      return this.closeTitle || this.localizationService.get('closeTitle');\n    }\n\n    calloutPositionClass() {\n      return {\n        'top': 'k-callout-s',\n        'left': 'k-callout-e',\n        'bottom': 'k-callout-n',\n        'right': 'k-callout-w'\n      }[this.position];\n    }\n\n    onCloseClick(event) {\n      event.preventDefault();\n      this.close.emit();\n    }\n\n    updateCalloutPosition(position, isFlip) {\n      if (!this.callout) {\n        return;\n      }\n\n      const callout = this.content.nativeElement.querySelector('.k-callout');\n      const isVertical = position === 'top' || position === 'bottom';\n      const size = isVertical ? 'width' : 'height';\n      const dir = isVertical ? 'left' : 'top';\n      const offsetProperty = isVertical ? 'marginLeft' : 'marginTop';\n      const calloutSize = callout.getBoundingClientRect()[size];\n      const anchorCenter = getCenterOffset(this.anchor.nativeElement, dir, size);\n      const contentCenter = getCenterOffset(this.content.nativeElement, dir, size);\n      const diff = Math.abs(contentCenter - anchorCenter);\n\n      if (diff > 1 || diff === 0 || Math.round(diff) === 0) {\n        const newMargin = contentCenter - anchorCenter + calloutSize / 2;\n        callout.style[offsetProperty] = `${-newMargin}px`;\n      }\n\n      const calloutStyles = this.calloutStyles(position, calloutSize, isFlip);\n      Object.keys(calloutStyles).forEach(style => {\n        callout.style[style] = calloutStyles[style];\n      });\n    }\n\n  }\n\n  TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) {\n    return new (t || TooltipContentComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  TooltipContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TooltipContentComponent,\n    selectors: [[\"kendo-tooltip\"]],\n    hostVars: 11,\n    hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction);\n        i0.ɵɵclassMap(ctx.cssClasses);\n        i0.ɵɵstyleProp(\"position\", ctx.cssPosition)(\"width\", ctx.tooltipWidth, \"px\")(\"height\", ctx.tooltipHeight, \"px\");\n        i0.ɵɵclassProp(\"k-tooltip-closable\", ctx.className);\n      }\n    },\n    inputs: {\n      tooltipWidth: \"tooltipWidth\",\n      tooltipHeight: \"tooltipHeight\",\n      titleTemplate: \"titleTemplate\",\n      anchor: \"anchor\",\n      closable: \"closable\",\n      templateRef: \"templateRef\",\n      templateString: \"templateString\"\n    },\n    outputs: {\n      close: \"close\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.tooltip'\n    }])],\n    decls: 7,\n    vars: 10,\n    consts: function () {\n      let i18n_0;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the close button\n         * @meaning kendo.tooltip.closeTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLTIP_FESM2015_KENDO_ANGULAR_TOOLTIP_JS_1 = goog.getMsg(\"Close\");\n        i18n_0 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLTIP_FESM2015_KENDO_ANGULAR_TOOLTIP_JS_1;\n      } else {\n        i18n_0 = $localize`:kendo.tooltip.closeTitle|The title of the close button:Close`;\n      }\n\n      return [[\"kendoTooltipLocalizedMessages\", \"\", \"closeTitle\", i18n_0], [1, \"k-tooltip-content\"], [\"class\", \"k-tooltip-title\", 4, \"ngIf\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"ngIf\"], [\"class\", \"k-tooltip-button\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"k-callout\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"k-tooltip-title\"], [1, \"k-tooltip-button\", 3, \"click\"], [\"href\", \"#\", 1, \"k-icon\", \"k-i-close\"], [1, \"k-callout\", 3, \"ngClass\"]];\n    },\n    template: function TooltipContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵtemplate(2, TooltipContentComponent_div_2_Template, 2, 6, \"div\", 2);\n        i0.ɵɵtemplate(3, TooltipContentComponent_ng_template_3_Template, 0, 0, \"ng-template\", 3);\n        i0.ɵɵtemplate(4, TooltipContentComponent_ng_template_4_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, TooltipContentComponent_div_5_Template, 2, 1, \"div\", 5);\n        i0.ɵɵtemplate(6, TooltipContentComponent_div_6_Template, 1, 1, \"div\", 6);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.titleTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.templateRef)(\"ngTemplateOutlet\", ctx.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(7, _c2, ctx.anchor, ctx.anchor));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.templateString);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.closable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.callout);\n      }\n    },\n    directives: [LocalizedMessagesDirective, i2.NgIf, i2.NgTemplateOutlet, i2.NgClass],\n    encapsulation: 2\n  });\n  return TooltipContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Tooltip directive for Angular]({% slug overview_tooltip %}).\n * Used to display additional information that is related to an element.\n *\n * @example\n * ```ts-no-run\n * <div kendoTooltip>\n *    <a title=\"Tooltip title\" href=\"foo\">foo</a>\n * </div>\n * ```\n */\n\n\nlet TooltipDirective = /*#__PURE__*/(() => {\n  class TooltipDirective {\n    constructor(tooltipWrapper, ngZone, renderer, popupService, settings, legacySettings) {\n      this.tooltipWrapper = tooltipWrapper;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.popupService = popupService;\n      /**\n       * Specifies a selector for elements within a container which will display a tooltip\n       * ([see example]({% slug anchorelements_tooltip %})). The possible values include any\n       * DOM `selector`. The default value is `[title]`.\n       */\n\n      this.filter = '[title]';\n      /**\n       * Specifies the position of the Tooltip that is relative to the\n       * anchor element ([see example]({% slug positioning_tooltip %})).\n       *\n       * The possible values are:\n       * * `top` (default)\n       * * `bottom`\n       * * `left`\n       * * `right`\n       */\n\n      this.position = 'top';\n      /**\n       * Specifies the delay in milliseconds before the Tooltip is shown.\n       * * `100` (default) milliseconds.\n       */\n\n      this.showAfter = 100;\n      /**\n       * Specifies if the Тooltip will display a callout arrow.\n       *\n       * The possible values are:\n       * * `true` (default)\n       * * `false`\n       */\n\n      this.callout = true;\n      /**\n       * Specifies if the Тooltip will display a **Close** button\n       * ([see example]({% slug closable_tooltip %})).\n       *\n       * The possible values are:\n       * * `true`\n       * * `false`\n       */\n\n      this.closable = false;\n      /**\n       * Specifies the offset in pixels between the Tooltip and the anchor. Defaults to `6` pixels.\n       * If the `callout` property is set to `true`, the offset is rendered from the callout arrow.\n       * If the `callout` property is set to `false`, the offset is rendered from the content of the Tooltip.\n       */\n\n      this.offset = 6;\n      this.anchor = null;\n      this.validPositions = ['top', 'bottom', 'right', 'left'];\n      this.validShowOptions = ['hover', 'click', 'none'];\n      validatePackage(packageMetadata);\n      Object.assign(this, settings, legacySettings);\n      this.ngZone.runOutsideAngular(() => {\n        const wrapper = this.tooltipWrapper.nativeElement;\n        this.anchorTitleSubscription = fromEvent(wrapper, 'mouseover').pipe(filter(() => this.filter !== '')).subscribe(e => {\n          const filterElement = closestBySelector(e.target, this.filter);\n\n          if (filterElement) {\n            this.hideElementTitle({\n              nativeElement: filterElement\n            });\n          }\n        });\n        this.mouseOverSubscription = fromEvent(wrapper, 'mouseover').pipe(debounceTime(100), filter(() => this.filter !== '')).subscribe(e => this.onMouseOver(e));\n        this.mouseOutSubscription = fromEvent(wrapper, 'mouseout').subscribe(e => this.onMouseOut(e));\n      });\n    }\n    /**\n     * Sets the content of the Tooltip as a template reference\n     * ([see example]({% slug templates_tooltip %})).\n     */\n\n\n    set tooltipTemplate(value) {\n      this.template = value;\n    }\n\n    get tooltipTemplate() {\n      return this.template;\n    }\n    /**\n     * Shows the Tooltip.\n     * @param anchor&mdash; ElementRef|Element.\n     * Specifies the element that will be used as an anchor. The Tooltip opens relative to that element.\n     */\n\n\n    show(anchor) {\n      if (this.popupRef) {\n        return;\n      }\n\n      if (anchor instanceof Element) {\n        anchor = {\n          nativeElement: anchor\n        };\n      }\n\n      this.anchor = anchor;\n\n      if (this.showOn === 'hover') {\n        if (this.popupRef) {\n          return;\n        }\n\n        clearTimeout(this.showTimeout);\n        this.showTimeout = window.setTimeout(() => this.showContent(this.anchor), this.showAfter);\n      } else {\n        this.hideElementTitle(this.anchor);\n        this.showContent(this.anchor);\n      }\n    }\n    /**\n     * Hides the Tooltip.\n     */\n\n\n    hide() {\n      clearTimeout(this.showTimeout);\n      const anchor = this.anchor && this.anchor.nativeElement;\n\n      if (anchor && anchor.getAttribute('data-title')) {\n        if (!anchor.getAttribute('title') && anchor.hasAttribute('title')) {\n          anchor.setAttribute('title', anchor.getAttribute('data-title'));\n        }\n\n        anchor.setAttribute('data-title', '');\n      }\n\n      if (this.popupMouseOutSubscription) {\n        this.popupMouseOutSubscription.unsubscribe();\n      }\n\n      if (this.closeClickSubscription) {\n        this.closeClickSubscription.unsubscribe();\n      }\n\n      this.closePopup();\n    }\n    /**\n     * Toggle visibility of the Tooltip.\n     *\n     * @param anchor&mdash; ElementRef|Element. Specifies the element that will be used as an anchor.\n     * @param show&mdash; Optional. Boolean. Specifies if the Tooltip will be rendered.\n     */\n\n\n    toggle(anchor, show) {\n      const previousAnchor = this.anchor && this.anchor.nativeElement;\n\n      if (anchor instanceof Element) {\n        anchor = {\n          nativeElement: anchor\n        };\n      }\n\n      if (previousAnchor !== anchor.nativeElement) {\n        this.hide();\n      }\n\n      if (previousAnchor === anchor.nativeElement && this.showOn === 'click') {\n        this.hide();\n      }\n\n      if (typeof show === 'undefined') {\n        show = !this.popupRef;\n      }\n\n      if (show) {\n        this.show(anchor);\n      } else {\n        this.hide();\n      }\n    }\n\n    ngOnInit() {\n      if (this.showOn === undefined) {\n        this.showOn = 'hover';\n      }\n\n      this.verifyProperties();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.showOn) {\n        this.subscribeClick();\n      }\n    }\n\n    ngAfterViewChecked() {\n      if (!this.popupRef) {\n        return;\n      }\n\n      if (this.anchor && !hasParent(this.anchor.nativeElement || this.anchor, this.tooltipWrapper.nativeElement)) {\n        this.anchor = null;\n        this.hide();\n      }\n    }\n\n    ngOnDestroy() {\n      this.hide();\n      this.template = null;\n      this.anchorTitleSubscription.unsubscribe();\n      this.mouseOverSubscription.unsubscribe();\n      this.mouseOutSubscription.unsubscribe();\n\n      if (this.mouseClickSubscription) {\n        this.mouseClickSubscription.unsubscribe();\n      }\n\n      if (this.popupPositionChangeSubscription) {\n        this.popupPositionChangeSubscription.unsubscribe();\n      }\n\n      if (this.popupMouseOutSubscription) {\n        this.popupMouseOutSubscription.unsubscribe();\n      }\n    }\n\n    showContent(anchorRef) {\n      if (!anchorRef.nativeElement.getAttribute('data-title') && !this.template) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.openPopup(anchorRef);\n        this.bindContent(this.popupRef.content, anchorRef);\n      });\n      this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());\n    }\n\n    bindContent(contentComponent, anchorRef) {\n      const content = contentComponent.instance;\n      this.closeClickSubscription = content.close.subscribe(() => {\n        this.hide();\n      });\n\n      if (!this.template) {\n        content.templateString = this.anchor.nativeElement.getAttribute('data-title');\n      } else {\n        content.templateRef = this.template;\n      }\n\n      if (this.titleTemplate) {\n        content.titleTemplate = this.titleTemplate;\n      }\n\n      content.closeTitle = this.closeTitle;\n      content.anchor = anchorRef;\n      content.callout = this.callout;\n      content.closable = this.closable;\n      content.position = this.position;\n      content.tooltipWidth = this.tooltipWidth;\n      content.tooltipHeight = this.tooltipHeight;\n      this.popupRef.content.changeDetectorRef.detectChanges();\n    }\n\n    hideElementTitle(elementRef) {\n      const element = elementRef.nativeElement;\n\n      if (element.getAttribute('title')) {\n        element.setAttribute('data-title', element.getAttribute('title'));\n        element.setAttribute('title', '');\n      }\n    }\n\n    openPopup(anchorRef) {\n      const alignSettings = align(this.position, this.offset);\n      const anchorAlign = alignSettings.anchorAlign;\n      const popupAlign = alignSettings.popupAlign;\n      const popupMargin = alignSettings.popupMargin;\n      this.popupRef = this.popupService.open({\n        anchor: anchorRef,\n        anchorAlign,\n        animate: false,\n        content: TooltipContentComponent,\n        collision: collision(this.collision, this.position),\n        margin: popupMargin,\n        popupAlign,\n        popupClass: 'k-popup-transparent'\n      });\n      this.renderer.addClass(this.popupRef.popupElement, 'k-tooltip-wrapper');\n\n      if (this.tooltipClass) {\n        this.renderer.addClass(this.popupRef.popupElement, this.tooltipClass);\n      }\n\n      const popupInstance = this.popupRef.content.instance;\n\n      if (popupInstance.callout) {\n        this.popupPositionChangeSubscription = this.popupRef.popupPositionChange.subscribe(({\n          flip\n        }) => {\n          const isFlip = flip.horizontal === true || flip.vertical === true;\n          popupInstance.updateCalloutPosition(this.position, isFlip);\n        });\n      }\n\n      if (this.showOn === 'hover') {\n        this.ngZone.runOutsideAngular(() => {\n          const popup = this.popupRef.popupElement;\n          this.popupMouseOutSubscription = fromEvent(popup, 'mouseout').subscribe(e => this.onMouseOut(e));\n        });\n      }\n    }\n\n    closePopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n\n      if (this.popupPositionChangeSubscription) {\n        this.popupPositionChangeSubscription.unsubscribe();\n      }\n    }\n\n    subscribeClick() {\n      if (this.mouseClickSubscription) {\n        this.mouseClickSubscription.unsubscribe();\n      }\n\n      if (this.showOn === 'click') {\n        this.mouseClickSubscription = fromEvent(document, 'click').pipe(filter(() => this.filter !== '')).subscribe(e => this.onMouseClick(e, this.tooltipWrapper.nativeElement));\n      }\n    }\n\n    onMouseClick(e, wrapper) {\n      const target = e.target;\n      const filterElement = closestBySelector(target, this.filter);\n      const popup = this.popupRef && this.popupRef.popupElement;\n\n      if (popup) {\n        if (popup.contains(target)) {\n          return;\n        }\n\n        if (this.closable) {\n          return;\n        }\n      }\n\n      if (wrapper.contains(target) && filterElement) {\n        this.toggle(filterElement, true);\n      } else if (popup) {\n        this.hide();\n      }\n    }\n\n    onMouseOver(e) {\n      const filterElement = closestBySelector(e.target, this.filter);\n\n      if (this.showOn !== 'hover') {\n        return;\n      }\n\n      if (filterElement) {\n        this.toggle(filterElement, true);\n      }\n    }\n\n    onMouseOut(e) {\n      if (this.showOn !== 'hover') {\n        return;\n      }\n\n      if (this.closable) {\n        return;\n      }\n\n      const popup = this.popupRef && this.popupRef.popupElement;\n      const relatedTarget = e.relatedTarget;\n\n      if (relatedTarget && this.anchor && contains(this.anchor.nativeElement, relatedTarget)) {\n        return;\n      }\n\n      if (relatedTarget && contains(popup, relatedTarget)) {\n        return;\n      }\n\n      this.hide();\n    }\n\n    verifyProperties() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!containsItem(this.validPositions, this.position)) {\n        throw new Error(`Invalid value provided for position property.The available options are 'top', 'bottom', 'left', or 'right'.`);\n      }\n\n      if (!containsItem(this.validShowOptions, this.showOn)) {\n        throw new Error(`Invalid value provided for showOn property.The available options are 'hover' or 'none'.`);\n      }\n    }\n\n  }\n\n  TooltipDirective.ɵfac = function TooltipDirective_Factory(t) {\n    return new (t || TooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1$1.PopupService), i0.ɵɵdirectiveInject(TooltipSettings, 8), i0.ɵɵdirectiveInject(TOOLTIP_SETTINGS, 8));\n  };\n\n  TooltipDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TooltipDirective,\n    selectors: [[\"\", \"kendoTooltip\", \"\"]],\n    inputs: {\n      filter: \"filter\",\n      position: \"position\",\n      titleTemplate: \"titleTemplate\",\n      showOn: \"showOn\",\n      showAfter: \"showAfter\",\n      callout: \"callout\",\n      closable: \"closable\",\n      offset: \"offset\",\n      tooltipWidth: \"tooltipWidth\",\n      tooltipHeight: \"tooltipHeight\",\n      tooltipClass: \"tooltipClass\",\n      collision: \"collision\",\n      closeTitle: \"closeTitle\",\n      tooltipTemplate: \"tooltipTemplate\"\n    },\n    exportAs: [\"kendoTooltip\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TooltipDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst ERRORS = {\n  popover: `Invalid value provided for the 'popover' property. The accepted data types are 'PopoverComponent' or 'PopoverFn'.`,\n  templateData: `templateData must be a function, but received`,\n  showOn: `Invalid value provided for the 'showOn' property. The available options are 'click', 'hover', 'focus' or 'none'.`\n};\n/**\n * Represents a template that defines the content of the Popover title.\n *\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoPopoverTitleTemplate` directive inside the `<kendo-popover>` tag.\n */\n\nlet PopoverTitleTemplateDirective = /*#__PURE__*/(() => {\n  class PopoverTitleTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PopoverTitleTemplateDirective.ɵfac = function PopoverTitleTemplateDirective_Factory(t) {\n    return new (t || PopoverTitleTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PopoverTitleTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverTitleTemplateDirective,\n    selectors: [[\"\", \"kendoPopoverTitleTemplate\", \"\"]]\n  });\n  return PopoverTitleTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the content of the Popover body.\n *\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoPopoverBodyTemplate` directive inside the `<kendo-popover>` tag.\n */\n\n\nlet PopoverBodyTemplateDirective = /*#__PURE__*/(() => {\n  class PopoverBodyTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PopoverBodyTemplateDirective.ɵfac = function PopoverBodyTemplateDirective_Factory(t) {\n    return new (t || PopoverBodyTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PopoverBodyTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverBodyTemplateDirective,\n    selectors: [[\"\", \"kendoPopoverBodyTemplate\", \"\"]]\n  });\n  return PopoverBodyTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a template that defines the content of the Popover actions.\n *\n * To define the template, nest an `<ng-template>` tag\n * with the `kendoPopoverActionsTemplate` directive inside the `<kendo-popover>` tag.\n */\n\n\nlet PopoverActionsTemplateDirective = /*#__PURE__*/(() => {\n  class PopoverActionsTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  PopoverActionsTemplateDirective.ɵfac = function PopoverActionsTemplateDirective_Factory(t) {\n    return new (t || PopoverActionsTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  PopoverActionsTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverActionsTemplateDirective,\n    selectors: [[\"\", \"kendoPopoverActionsTemplate\", \"\"]]\n  });\n  return PopoverActionsTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI Popover component for Angular]({% slug overview_popover %}).\n * Used to display additional information that is related to a target element.\n *\n * @example\n * ```ts-no-run\n * <kendo-popover>\n *    <ng-template kendoPopoverTitleTemplate>Foo Title</ng-template>\n *    <ng-template kendoPopoverBodyTemplate>Foo Body</ng-template>\n *    <ng-template kendoPopoverActionsTemplate>Foo Actions</ng-template>\n * </kendo-popover>\n * ```\n */\n\n\nlet PopoverComponent = /*#__PURE__*/(() => {\n  class PopoverComponent {\n    constructor(localization) {\n      this.localization = localization;\n      /**\n       * Specifies the position of the Popover in relation to its anchor element. [See example]({% slug positioning_popover %})\n       *\n       * The possible options are:\n       * `top`\n       * `bottom`\n       * `right` (Default)\n       * `left`\n       */\n\n      this.position = 'right';\n      /**\n       * Determines whether a callout will be rendered along the Popover. [See example]({% slug callout_popover %})\n       *\n       * @default true\n       */\n\n      this.callout = true;\n      /**\n       * Enables and configures the Popover animation. [See example]({% slug animations_popover %})\n       *\n       * The possible options are:\n       *\n       * * `boolean`&mdash;Enables the default animation\n       * * `PopoverAnimation`&mdash;A configuration object which allows setting the `direction`, `duration` and `type` of the animation.\n       *\n       * @default false\n       */\n\n      this.animation = false;\n      /**\n       * @hidden\n       * Determines the visibility of the Popover.\n       */\n\n      this.visible = false;\n      /**\n       * Fires before the Popover is about to be shown ([see example]({% slug events_popover %})).\n       * The event is preventable. If canceled, the Popover will not be displayed. [See example]({% slug events_popover %})\n       */\n\n      this.show = new EventEmitter();\n      /**\n       * Fires after the Popover has been shown and the animation has ended. [See example]({% slug events_popover %})\n       */\n\n      this.shown = new EventEmitter();\n      /**\n       * Fires when the Popover is about to be hidden ([see example]({% slug events_popover %})).\n       * The event is preventable. If canceled, the Popover will remain visible.\n       */\n\n      this.hide = new EventEmitter();\n      /**\n       * Fires after the Popover has been hidden and the animation has ended. [See example]({% slug events_popover %})\n       */\n\n      this.hidden = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this._width = 'auto';\n      /**\n       * @hidden\n       */\n\n      this._height = 'auto';\n      this._offset = 6;\n      this.subs = new Subscription();\n      /**\n       * @hidden\n       */\n\n      this._templateData = () => null;\n\n      validatePackage(packageMetadata);\n    }\n    /**\n     * Specifies the distance from the Popover to its anchor element in pixels.\n     *\n     * @default `6`\n     */\n\n\n    set offset(value) {\n      this._offset = value;\n    }\n\n    get offset() {\n      const calloutBuffer = 14;\n      return this.callout ? calloutBuffer + this._offset : this._offset;\n    }\n    /**\n     * Determines the width of the popover. Numeric values are treated as pixels.\n     * @default 'auto'\n     */\n\n\n    set width(value) {\n      this._width = typeof value === 'number' ? `${value}px` : value;\n    }\n\n    get width() {\n      return this._width;\n    }\n    /**\n     * Determines the height of the popover. Numeric values are treated as pixels.\n     * @default 'auto'\n     */\n\n\n    set height(value) {\n      this._height = typeof value === 'number' ? `${value}px` : value;\n    }\n\n    get height() {\n      return this._height;\n    }\n    /**\n     * Defines a callback function which returns custom data passed to the Popover templates.\n     * It exposes the current anchor element as an argument. [See example]({% slug templates_popover %}#toc-popoverdatacallback)\n     */\n\n\n    set templateData(fn) {\n      if (isDevMode && typeof fn !== 'function') {\n        throw new Error(`${ERRORS.templateData} ${JSON.stringify(fn)}.`);\n      }\n\n      this._templateData = fn;\n    }\n\n    get templateData() {\n      return this._templateData;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isHidden() {\n      return !this.visible;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasAttributeHidden() {\n      return !this.visible;\n    }\n\n    ngOnInit() {\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n      }));\n    }\n\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    getCalloutPosition() {\n      switch (this.position) {\n        case 'top':\n          return {\n            'k-callout-s': true\n          };\n\n        case 'bottom':\n          return {\n            'k-callout-n': true\n          };\n\n        case 'left':\n          return {\n            'k-callout-e': true\n          };\n\n        case 'right':\n          return {\n            'k-callout-w': true\n          };\n\n        default:\n          return {\n            'k-callout-s': true\n          };\n      }\n    }\n\n  }\n\n  PopoverComponent.ɵfac = function PopoverComponent_Factory(t) {\n    return new (t || PopoverComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  PopoverComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PopoverComponent,\n    selectors: [[\"kendo-popover\"]],\n    contentQueries: function PopoverComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, PopoverTitleTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PopoverBodyTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, PopoverActionsTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bodyTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionsTemplate = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function PopoverComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.direction)(\"aria-hidden\", ctx.hasAttributeHidden);\n        i0.ɵɵstyleProp(\"width\", ctx._width)(\"height\", ctx._height);\n        i0.ɵɵclassProp(\"k-hidden\", ctx.isHidden);\n      }\n    },\n    inputs: {\n      position: \"position\",\n      offset: \"offset\",\n      width: \"width\",\n      height: \"height\",\n      title: \"title\",\n      subtitle: \"subtitle\",\n      body: \"body\",\n      callout: \"callout\",\n      animation: \"animation\",\n      templateData: \"templateData\"\n    },\n    outputs: {\n      show: \"show\",\n      shown: \"shown\",\n      hide: \"hide\",\n      hidden: \"hidden\"\n    },\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.popover'\n    }])],\n    decls: 1,\n    vars: 1,\n    consts: [[\"role\", \"tooltip\", \"class\", \"k-popover\", 3, \"ngStyle\", 4, \"ngIf\"], [\"role\", \"tooltip\", 1, \"k-popover\", 3, \"ngStyle\"], [\"class\", \"k-popover-callout\", 3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-popover-header\", 4, \"ngIf\"], [\"class\", \"k-popover-body\", 4, \"ngIf\"], [\"class\", \"k-popover-actions k-actions k-hstack k-justify-content-between\", 4, \"ngIf\"], [1, \"k-popover-callout\", 3, \"ngClass\"], [1, \"k-popover-header\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-popover-body\"], [1, \"k-popover-actions\", \"k-actions\", \"k-hstack\", \"k-justify-content-between\"]],\n    template: function PopoverComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, PopoverComponent_div_0_Template, 5, 8, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.visible);\n      }\n    },\n    directives: [i2.NgIf, i2.NgStyle, i2.NgClass, i2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return PopoverComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `show` event. The `show` event fires when a popover is about\n * to be opened. If you cancel the event, the opening is prevented.\n */\n\n\nclass PopoverShowEvent extends PreventableEvent {\n  /**\n   * @hidden\n   * Constructs the event arguments for the `show` event.\n   * @param anchor - The host element related to the popover.\n   */\n  constructor(anchor) {\n    super();\n    this.anchor = anchor;\n  }\n\n}\n/**\n * Arguments for the `hide` event. The `hide` event fires when a popover is about\n * to be closed. If you cancel the event, the popover stays open.\n */\n\n\nclass PopoverHideEvent extends PreventableEvent {\n  /**\n   * @hidden\n   * Constructs the event arguments for the `hide` event.\n   * @param anchor - The host element related to the popover.\n   * @param popover - The popover element.\n   */\n  constructor(anchor, popover) {\n    super();\n    this.anchor = anchor;\n    this.popover = popover;\n  }\n\n}\n/**\n * Arguments for the `shown` event. The `shown` event fires after the popover has opened and its opening animation has finished.\n */\n\n\nclass PopoverShownEvent {\n  /**\n   * @hidden\n   * Constructs the event arguments for the `shown` event.\n   * @param anchor - The host element related to the popover.\n   * @param popover - The popover element.\n   */\n  constructor(anchor, popover) {\n    this.anchor = anchor;\n    this.popover = popover;\n  }\n\n}\n/**\n * Arguments for the `hidden` event. The `hidden` event fires after the popover has closed and its closing animation has finished.\n */\n\n\nclass PopoverHiddenEvent {\n  /**\n   * @hidden\n   * Constructs the event arguments for the `hidden` event.\n   * @param anchor - The host element related to the popover.\n   */\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n\n}\n\nconst validShowOptions = ['hover', 'click', 'none', 'focus'];\n/**\n * @hidden\n */\n\nlet PopoverDirectivesBase = /*#__PURE__*/(() => {\n  class PopoverDirectivesBase {\n    constructor(ngZone, popupService, renderer) {\n      this.ngZone = ngZone;\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.subs = new Subscription();\n      this._showOn = 'click';\n    }\n    /**\n     * Specifies the popover instance that will be rendered.\n     * Accepts a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance or\n     * a [`PopoverFn`]({% slug api_tooltip_popoverfn %}) callback which returns a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance\n     * depending on the current anchor element.\n     *\n     * [See example]({% slug templates_popover %}#toc-popovercallback)\n     */\n\n\n    set popover(value) {\n      if (value instanceof PopoverComponent || typeof value === `function`) {\n        this._popover = value;\n      } else {\n        if (isDevMode) {\n          throw new Error(ERRORS.popover);\n        }\n      }\n    }\n\n    get popover() {\n      return this._popover;\n    }\n    /**\n     * The event on which the Popover will be shown\n     *\n     * The supported values are:\n     * - `click` (default) &mdash;The Popover will be shown when its `anchor` element is clicked.\n     * - `hover`&mdash;The Popover will be shown when its `anchor` element is hovered.\n     * - `focus`&mdash;The Popover will be shown when its `anchor` element is focused.\n     * - `none`&mdash;The Popover will not be shown on user interaction. It could be rendered via the Popover API methods.\n     */\n\n\n    set showOn(value) {\n      if (isDevMode && !containsItem(validShowOptions, value)) {\n        throw new Error(ERRORS.showOn);\n      }\n\n      this._showOn = value;\n    }\n\n    get showOn() {\n      return this._showOn;\n    }\n\n    ngAfterViewInit() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(() => {\n        switch (this.showOn) {\n          case 'hover':\n            this.subscribeToEvents([{\n              name: 'mouseenter',\n              handler: this.mouseenterHandler\n            }, {\n              name: 'mouseleave',\n              handler: this.mouseleaveHandler\n            }]);\n            break;\n\n          case 'focus':\n            this.subscribeToEvents([{\n              name: 'focus',\n              handler: this.focusHandler\n            }, {\n              name: 'blur',\n              handler: this.blurHandler\n            }]);\n            break;\n\n          case 'click':\n            this.subscribeClick();\n            break;\n\n          default:\n            break;\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.closePopup();\n\n      if (this.disposeHoverOverListener) {\n        this.disposeHoverOverListener();\n      }\n\n      if (this.disposeHoverOutListener) {\n        this.disposeHoverOutListener();\n      }\n\n      if (this.disposeClickListener) {\n        this.disposeClickListener();\n      }\n\n      if (this._focusInsideSub) {\n        this._focusInsideSub.unsubscribe();\n      }\n\n      if (this._hideSub) {\n        this._hideSub.unsubscribe();\n      }\n\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n\n      if (this._popupOpenSub) {\n        this._popupOpenSub.unsubscribe();\n      }\n\n      if (this._popupCloseSub) {\n        this._popupCloseSub.unsubscribe();\n      }\n    }\n    /**\n     * Hides the Popover ([See example]({% slug programmaticcontrol_popover %})).\n     */\n\n\n    hide() {\n      this.closePopup();\n    }\n    /**\n     * @hidden\n     */\n\n\n    closePopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n\n        if (this.disposePopupHoverOutListener) {\n          this.disposePopupHoverOutListener();\n        }\n\n        if (this.disposePopupHoverInListener) {\n          this.disposePopupHoverInListener();\n        }\n\n        if (this.disposePopupFocusOutListener) {\n          this.disposePopupFocusOutListener();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    openPopup(anchor) {\n      const _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;\n\n      const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(_anchor);\n      const alignSettings = align(popoverComp.position, popoverComp.offset);\n      const anchorAlign = alignSettings.anchorAlign;\n      const popupAlign = alignSettings.popupAlign;\n      const popupMargin = alignSettings.popupMargin;\n      const _animation = popoverComp.animation;\n      this.popupRef = this.popupService.open({\n        anchor: {\n          nativeElement: _anchor\n        },\n        animate: _animation,\n        content: PopoverComponent,\n        popupAlign,\n        anchorAlign,\n        margin: popupMargin,\n        popupClass: 'k-popup-transparent',\n        collision: {\n          horizontal: 'fit',\n          vertical: 'fit'\n        }\n      });\n      this.applySettings(this.popupRef.content, popoverComp, anchor);\n      this.monitorPopup();\n      this.initializeCompletionEvents(popoverComp, _anchor);\n    }\n    /**\n     * @hidden\n     */\n\n\n    isPrevented(anchorElement, show) {\n      const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(anchorElement);\n      let eventArgs;\n      eventArgs = this.initializeEvents(popoverComp, eventArgs, show, anchorElement);\n      return eventArgs.isDefaultPrevented();\n    }\n    /**\n     * @hidden\n     */\n\n\n    monitorPopup() {\n      if (this.showOn === 'hover') {\n        this.ngZone.runOutsideAngular(() => {\n          const popup = this.popupRef.popupElement;\n          this.disposePopupHoverInListener = this.renderer.listen(popup, 'mouseenter', _ => {\n            this.ngZone.run(_ => this._popoverService.emitPopoverState(true));\n          });\n          this.disposePopupHoverOutListener = this.renderer.listen(popup, 'mouseleave', _ => {\n            this.ngZone.run(_ => this._popoverService.emitPopoverState(false));\n          });\n        });\n      }\n\n      if (this.showOn === 'focus') {\n        this.ngZone.runOutsideAngular(() => {\n          const popup = this.popupRef.popupElement;\n          this.disposePopupFocusOutListener = this.renderer.listen(popup, 'focusout', e => {\n            const isInsidePopover = closest(e.relatedTarget, node => node.classList && node.classList.contains('k-popover'));\n\n            if (!isInsidePopover) {\n              this.ngZone.run(_ => this._popoverService.emitFocusInsidePopover(false));\n            }\n          });\n        });\n      }\n    }\n\n    applySettings(contentComponent, popover, anchor) {\n      const content = contentComponent.instance;\n\n      const _anchor = anchor instanceof ElementRef ? anchor.nativeElement : anchor;\n\n      content.visible = true;\n      content.anchor = _anchor;\n      content.position = popover.position;\n      content.offset = popover.offset;\n      content.width = popover.width;\n      content.height = popover.height;\n      content.title = popover.title;\n      content.body = popover.body;\n      content.callout = popover.callout;\n      content.animation = popover.animation;\n      content.contextData = popover.templateData(_anchor);\n      content.titleTemplate = popover.titleTemplate;\n      content.bodyTemplate = popover.bodyTemplate;\n      content.actionsTemplate = popover.actionsTemplate;\n      this.popupRef.content.changeDetectorRef.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    initializeEvents(popoverComp, eventArgs, show, anchorElement) {\n      if (show) {\n        eventArgs = new PopoverShowEvent(anchorElement);\n\n        if (this.shouldEmitEvent(!!this.popupRef, 'show', popoverComp)) {\n          this.ngZone.run(() => popoverComp.show.emit(eventArgs));\n        }\n      } else {\n        eventArgs = new PopoverHideEvent(anchorElement, this.popupRef);\n\n        if (this.shouldEmitEvent(!!this.popupRef, 'hide', popoverComp)) {\n          this.ngZone.run(() => popoverComp.hide.emit(eventArgs));\n        }\n      }\n\n      return eventArgs;\n    }\n\n    initializeCompletionEvents(popoverComp, _anchor) {\n      if (this.shouldEmitCompletionEvents('shown', popoverComp)) {\n        this.popupRef.popupOpen.subscribe(() => {\n          const eventArgs = new PopoverShownEvent(_anchor, this.popupRef);\n          popoverComp.shown.emit(eventArgs);\n        });\n      }\n\n      if (this.shouldEmitCompletionEvents('hidden', popoverComp)) {\n        this.popupRef.popupClose.subscribe(() => {\n          this.ngZone.run(_ => {\n            const eventArgs = new PopoverHiddenEvent(_anchor);\n            popoverComp.hidden.emit(eventArgs);\n          });\n        });\n      }\n    }\n\n    shouldEmitEvent(hasPopup, event, popoverComp) {\n      if (event === 'show' && !hasPopup && hasObservers(popoverComp[event]) || event === 'hide' && hasPopup && hasObservers(popoverComp[event])) {\n        return true;\n      }\n\n      return false;\n    }\n\n    shouldEmitCompletionEvents(event, popoverComp) {\n      if (hasObservers(popoverComp[event]) && !this._popupOpenSub || hasObservers(popoverComp[event]) && !this._popupCloseSub) {\n        return true;\n      }\n\n      return false;\n    }\n\n  }\n\n  PopoverDirectivesBase.ɵfac = function PopoverDirectivesBase_Factory(t) {\n    return new (t || PopoverDirectivesBase)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$1.PopupService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  PopoverDirectivesBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverDirectivesBase,\n    inputs: {\n      popover: \"popover\",\n      showOn: \"showOn\"\n    }\n  });\n  return PopoverDirectivesBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet PopoverService = /*#__PURE__*/(() => {\n  class PopoverService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this._pointerOverPopup = new BehaviorSubject(null);\n      this._pointerOverAnchor = new BehaviorSubject(null);\n      this._focusInsidePopover = new BehaviorSubject(null);\n      this._hidePopover = new Subject();\n      this.subs = new Subscription();\n      this.monitor();\n    }\n\n    ngOnDestroy() {\n      this.subs.unsubscribe();\n    }\n\n    get isPopoverHovered() {\n      return this._pointerOverPopup.asObservable();\n    }\n\n    emitPopoverState(isHovered) {\n      this.ngZone.run(_ => this._pointerOverPopup.next(isHovered));\n    }\n\n    get isAnchorHovered() {\n      return this._pointerOverAnchor.asObservable();\n    }\n\n    emitAnchorState(isHovered, anchor) {\n      this._isOrigin = this.originAnchor === anchor;\n      this.currentAnchor = anchor;\n\n      if (isHovered) {\n        this.originAnchor = anchor;\n      }\n\n      this.ngZone.run(_ => this._pointerOverAnchor.next(isHovered));\n    }\n\n    get isFocusInsidePopover() {\n      return this._focusInsidePopover.asObservable();\n    }\n\n    emitFocusInsidePopover(isFocused) {\n      this.ngZone.run(_ => this._focusInsidePopover.next(isFocused));\n\n      this._focusInsidePopover.next(null);\n    }\n\n    get hidePopover() {\n      return this._hidePopover.asObservable();\n    }\n\n    monitor() {\n      this.subs.add(combineLatest(this.isPopoverHovered, this.isAnchorHovered).pipe( // `auditTime` is used because the `mouseleave` event is emitted before `mouseenter`\n      // i.e. there is a millisecond in which the pointer leaves the first target (e.g. anchor) and hasn't reached the second one (e.g. popup)\n      // resulting in both observables emitting `false`\n      auditTime(20)).subscribe(val => {\n        const [isPopoverHovered, isAnchorHovered] = val;\n\n        this._hidePopover.next([isPopoverHovered, isAnchorHovered, this._isOrigin, this.currentAnchor]);\n      }));\n    }\n\n  }\n\n  PopoverService.ɵfac = function PopoverService_Factory(t) {\n    return new (t || PopoverService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  PopoverService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PopoverService,\n    factory: PopoverService.ɵfac\n  });\n  return PopoverService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [`kendoPopoverContainer`]({% slug configuration_popover %}#toc-containerdirective) directive.\n * It is used to filter and target multiple elements, which should display a popover on interaction.\n *\n * @example\n * ```ts-no-run\n * <div kendoPopoverContainer [popover]=\"myPopover\" filter=\".has-popover\">\n *     <button class=\"has-popover\">Show Popover</button>\n *     <button>Button Without Popover</button>\n *     <button class=\"has-popover\">Show Popover</button>\n * </div>\n * ```\n */\n\n\nlet PopoverContainerDirective = /*#__PURE__*/(() => {\n  class PopoverContainerDirective extends PopoverDirectivesBase {\n    constructor(wrapperEl, ngZone, popupService, renderer, popoverService) {\n      super(ngZone, popupService, renderer);\n      this.wrapperEl = wrapperEl;\n      this.ngZone = ngZone;\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.popoverService = popoverService;\n\n      this.mouseenterHandler = anchor => {\n        this.controlVisibility(anchor, true);\n      };\n\n      this.mouseleaveHandler = args => {\n        const anchor = args.anchor;\n\n        if (this.isPrevented(anchor, false)) {\n          return;\n        }\n\n        if (!this._hideSub) {\n          this._hideSub = this.popoverService.hidePopover.subscribe(val => {\n            const [isPopoverHovered,, isOriginAnchor, currentAnchor] = val;\n\n            if (!isPopoverHovered && !isOriginAnchor) {\n              this.hide();\n\n              if (!isOriginAnchor && currentAnchor) {\n                this.show(currentAnchor);\n              }\n            }\n          });\n        }\n      };\n\n      this.focusHandler = anchor => {\n        this.controlVisibility(anchor, true);\n      };\n\n      this.blurHandler = args => {\n        const anchor = args.anchor;\n        const event = args.domEvent;\n\n        if (this.isPrevented(anchor, false)) {\n          return;\n        } // from anchor to popup focus check\n\n\n        const isFocusInside = !!closest(event.relatedTarget, node => node.classList && node.classList.contains('k-popover'));\n\n        if (!isFocusInside) {\n          this.hide();\n        }\n\n        if (!this._focusInsideSub) {\n          // inside popup focus check\n          this._focusInsideSub = this.popoverService.isFocusInsidePopover.pipe(filter(v => v !== null)).subscribe(val => {\n            if (!val && !isFocusInside) {\n              this.hide();\n            }\n          });\n        }\n      };\n\n      this._popoverService = this.popoverService;\n    }\n    /**\n     * Shows the Popover.\n     *\n     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element. [See example]({% slug programmaticcontrol_popover %})\n     */\n\n\n    show(anchor) {\n      if (this.popupRef) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.openPopup(anchor);\n      });\n      this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());\n    }\n    /**\n     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})\n     *\n     * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element.\n     */\n\n\n    toggle(anchor) {\n      const previousAnchor = this.popupRef && this.popupRef.content.instance.anchor;\n\n      if (this.popupRef) {\n        this.hide();\n\n        if (previousAnchor !== anchor) {\n          this.show(anchor);\n        }\n      } else {\n        this.show(anchor);\n      }\n    }\n\n    subscribeClick() {\n      if (this.disposeClickListener) {\n        this.disposeClickListener();\n      }\n\n      this.disposeClickListener = this.renderer.listen(document, 'click', e => {\n        const filterElement = closestBySelector(e.target, this.filter);\n        this.clickHandler(filterElement, e);\n      });\n    }\n\n    subscribeToEvents(arr) {\n      const filteredElements = Array.from(document.querySelectorAll(this.filter));\n      filteredElements.forEach(el => {\n        this.subs.add(this.renderer.listen(el, arr[0].name, () => {\n          this.popoverService.emitAnchorState(true, el);\n          arr[0].handler(el);\n        }));\n        this.subs.add(this.renderer.listen(el, arr[1].name, e => {\n          this.popoverService.emitAnchorState(false, null);\n          arr[1].handler({\n            anchor: el,\n            domEvent: e\n          });\n        }));\n      });\n    }\n\n    clickHandler(anchor, event) {\n      const isInsidePopup = !!closest(event.target, node => node.classList && node.classList.contains('k-popup'));\n      const popupRefAnchor = this.popupRef && this.popupRef.content.instance.anchor;\n      let isOriginAnchor = !!closest(event.target, node => node === (popupRefAnchor ? popupRefAnchor : anchor));\n\n      if (this.showOn !== 'click' || isInsidePopup || this.popupRef && isOriginAnchor) {\n        return;\n      }\n\n      if (!anchor && this.popupRef) {\n        this.controlVisibility(anchor, false);\n        return;\n      }\n\n      if (isOriginAnchor) {\n        this.controlVisibility(anchor, true);\n      } else if (this.popupRef) {\n        this.controlVisibility(anchor, false);\n        this.controlVisibility(anchor, true);\n      }\n    }\n\n    controlVisibility(anchor, show) {\n      if (this.isPrevented(anchor, show)) {\n        return;\n      }\n\n      if (show) {\n        this.show(anchor);\n      } else {\n        this.hide();\n      }\n    }\n\n  }\n\n  PopoverContainerDirective.ɵfac = function PopoverContainerDirective_Factory(t) {\n    return new (t || PopoverContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$1.PopupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PopoverService));\n  };\n\n  PopoverContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverContainerDirective,\n    selectors: [[\"\", \"kendoPopoverContainer\", \"\"]],\n    inputs: {\n      filter: \"filter\"\n    },\n    exportAs: [\"kendoPopoverContainer\"],\n    features: [i0.ɵɵProvidersFeature([PopoverService]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return PopoverContainerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [`kendoPopoverAnchor`]({% slug configuration_popover %}#toc-anchordirective) directive.\n * It is used to target an element, which should display a popover on interaction.\n *\n * @example\n * ```ts-no-run\n * <button kendoPopoverAnchor [popover]=\"myPopover\">Show Popover</button>\n * ```\n */\n\n\nlet PopoverAnchorDirective = /*#__PURE__*/(() => {\n  class PopoverAnchorDirective extends PopoverDirectivesBase {\n    constructor(hostEl, ngZone, popupService, renderer, popoverService) {\n      super(ngZone, popupService, renderer);\n      this.hostEl = hostEl;\n      this.ngZone = ngZone;\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.popoverService = popoverService;\n\n      this.mouseenterHandler = () => {\n        this.controlVisibility(this.hostEl.nativeElement, true);\n      };\n\n      this.mouseleaveHandler = () => {\n        if (this.isPrevented(this.hostEl.nativeElement, false)) {\n          return;\n        }\n\n        if (!this._hideSub) {\n          this._hideSub = this.popoverService.hidePopover.subscribe(val => {\n            const [isPopoverHovered, isAnchorHovered] = val;\n\n            if (!isPopoverHovered && !isAnchorHovered) {\n              this.hide();\n            }\n          });\n        }\n      };\n\n      this.focusHandler = () => {\n        this.controlVisibility(this.hostEl.nativeElement, true);\n      };\n\n      this.blurHandler = args => {\n        const event = args.domEvent;\n\n        if (this.isPrevented(this.hostEl.nativeElement, false)) {\n          return;\n        } // from anchor to popup focus check\n\n\n        const isFocusInside = !!closest(event.relatedTarget, node => node.classList && node.classList.contains('k-popover'));\n\n        if (!isFocusInside) {\n          this.hide();\n        }\n\n        if (!this._focusInsideSub) {\n          // inside popup focus check\n          this._focusInsideSub = this.popoverService.isFocusInsidePopover.pipe(filter(v => v !== null)).subscribe(val => {\n            if (!val) {\n              this.hide();\n            }\n          });\n        }\n      };\n\n      this._popoverService = this.popoverService;\n    }\n    /**\n     * Shows the Popover. [See example]({% slug programmaticcontrol_popover %})\n     */\n\n\n    show() {\n      if (this.popupRef) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.openPopup(this.hostEl);\n      });\n      this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());\n    }\n    /**\n     * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})\n     */\n\n\n    toggle() {\n      if (this.popupRef) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    subscribeToEvents(arr) {\n      this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[0].name, () => {\n        this.popoverService.emitAnchorState(true, this.hostEl.nativeElement);\n        arr[0].handler();\n      }));\n      this.subs.add(this.renderer.listen(this.hostEl.nativeElement, arr[1].name, e => {\n        this.popoverService.emitAnchorState(false, null);\n        arr[1].handler({\n          domEvent: e\n        });\n      }));\n    }\n\n    subscribeClick() {\n      if (this.disposeClickListener) {\n        this.disposeClickListener();\n      }\n\n      this.disposeClickListener = this.renderer.listen(document, 'click', e => {\n        this.onClick(e);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick(event) {\n      const isInsidePopup = !!closest(event.target, node => node.classList && node.classList.contains('k-popup'));\n      let isAnchor = !!closest(event.target, node => node === this.hostEl.nativeElement);\n\n      if (isInsidePopup || this.popupRef && isAnchor) {\n        return;\n      }\n\n      if (isAnchor) {\n        // on opening\n        this.controlVisibility(this.hostEl.nativeElement, true);\n      } else {\n        // on closing\n        this.controlVisibility(this.hostEl.nativeElement, false);\n      }\n    }\n\n    controlVisibility(anchor, show) {\n      if (this.isPrevented(anchor, show)) {\n        return;\n      }\n\n      if (show) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    }\n\n  }\n\n  PopoverAnchorDirective.ɵfac = function PopoverAnchorDirective_Factory(t) {\n    return new (t || PopoverAnchorDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$1.PopupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PopoverService));\n  };\n\n  PopoverAnchorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PopoverAnchorDirective,\n    selectors: [[\"\", \"kendoPopoverAnchor\", \"\"]],\n    exportAs: [\"kendoPopoverAnchor\"],\n    features: [i0.ɵɵProvidersFeature([PopoverService]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return PopoverAnchorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective];\nconst COMPONENT_MODULES = [PopupModule];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Tooltip component.\n *\n * The package exports:\n * - `KendoTooltipDirective`&mdash;The Tooltip directive class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Tooltip module\n * import { TooltipModule } from '@progress/kendo-angular-tooltip';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * _@NgModule{{\n *    declarations: [AppComponent], // declare app component\n *    imports:      [BrowserModule, TooltipModule], // import TooltipModule module\n *    bootstrap:    [AppComponent]\n * }}\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\n\nlet TooltipModule = /*#__PURE__*/(() => {\n  class TooltipModule {}\n\n  TooltipModule.ɵfac = function TooltipModule_Factory(t) {\n    return new (t || TooltipModule)();\n  };\n\n  TooltipModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TooltipModule\n  });\n  TooltipModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ...COMPONENT_MODULES]]\n  });\n  return TooltipModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DIRECTIVES = [PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popover component.\n *\n * @example\n *\n * ```ts-no-run\n * import { PopoverModule } from '@progress/kendo-angular-tooltip';\n *\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { NgModule } from '@angular/core';\n *\n * import { AppComponent } from './app.component';\n *\n * _@NgModule({\n *     declarations: [AppComponent],\n *     imports:      [BrowserModule, PopoverModule],\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet PopoverModule = /*#__PURE__*/(() => {\n  class PopoverModule {}\n\n  PopoverModule.ɵfac = function PopoverModule_Factory(t) {\n    return new (t || PopoverModule)();\n  };\n\n  PopoverModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PopoverModule\n  });\n  PopoverModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, PopupModule]]\n  });\n  return PopoverModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Tooltips components.\n *\n * @example\n *\n * ```ts-no-run\n * import { TooltipsModule } from '@progress/kendo-angular-tooltip';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * _@NgModule{{\n *    declarations: [AppComponent], // declare app component\n *    imports:      [BrowserModule, TooltipsModule], // import TooltipsModule module\n *    bootstrap:    [AppComponent]\n * }}\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\n\n\nlet TooltipsModule = /*#__PURE__*/(() => {\n  class TooltipsModule {}\n\n  TooltipsModule.ɵfac = function TooltipsModule_Factory(t) {\n    return new (t || TooltipsModule)();\n  };\n\n  TooltipsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TooltipsModule\n  });\n  TooltipsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TooltipModule, PopoverModule]\n  });\n  return TooltipsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Tooltip\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LocalizedMessagesDirective, PopoverActionsTemplateDirective, PopoverAnchorDirective, PopoverBodyTemplateDirective, PopoverComponent, PopoverContainerDirective, PopoverHiddenEvent, PopoverHideEvent, PopoverModule, PopoverShowEvent, PopoverShownEvent, PopoverTitleTemplateDirective, TOOLTIP_SETTINGS, TooltipContentComponent, TooltipDirective, TooltipModule, TooltipSettings, TooltipsModule };","map":null,"metadata":{},"sourceType":"module"}