{"ast":null,"code":"import CategoryAxis from './category-axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport { CENTER, DATE, DEFAULT_PRECISION, MAX_VALUE, OBJECT, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, last, limitValue, round, setDefaultOptions, sparseArrayLimits } from '../common';\nimport { MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS, TIME_PER_MINUTE, TIME_PER_HOUR, TIME_PER_DAY, TIME_PER_WEEK, TIME_PER_MONTH, TIME_PER_YEAR, TIME_PER_UNIT } from '../date-utils/constants';\nimport { dateComparer, toDate, addTicks, addDuration, dateDiff, absoluteDateDiff, dateIndex, dateEquals, toTime, parseDate, parseDates, firstDay } from '../date-utils';\nimport { DateLabelFormats } from './constants';\nconst AUTO = \"auto\";\nconst BASE_UNITS = [MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS];\nconst FIT = \"fit\";\n\nfunction categoryRange(categories) {\n  let range = categories._range;\n\n  if (!range) {\n    range = categories._range = sparseArrayLimits(categories);\n    range.min = toDate(range.min);\n    range.max = toDate(range.max);\n  }\n\n  return range;\n}\n\nclass EmptyDateRange {\n  constructor(options) {\n    this.options = options;\n  }\n\n  displayIndices() {\n    return {\n      min: 0,\n      max: 1\n    };\n  }\n\n  displayRange() {\n    return {};\n  }\n\n  total() {\n    return {};\n  }\n\n  valueRange() {\n    return {};\n  }\n\n  valueIndex() {\n    return -1;\n  }\n\n  values() {\n    return [];\n  }\n\n  totalIndex() {\n    return -1;\n  }\n\n  valuesCount() {\n    return 0;\n  }\n\n  totalCount() {\n    return 0;\n  }\n\n  dateAt() {\n    return null;\n  }\n\n}\n\nclass DateRange {\n  constructor(start, end, options) {\n    this.options = options;\n    options.baseUnitStep = options.baseUnitStep || 1;\n    const {\n      roundToBaseUnit,\n      justified\n    } = options;\n    this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n    const lowerEnd = this.roundToTotalStep(end);\n    const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n    this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n    const min = options.min || start;\n    this.valueStart = this.roundToTotalStep(min);\n    this.displayStart = roundToBaseUnit ? this.valueStart : min;\n    const max = options.max;\n\n    if (!max) {\n      this.valueEnd = lowerEnd;\n      this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n    } else {\n      const next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n      this.valueEnd = this.roundToTotalStep(max, false, next);\n      this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n    }\n\n    if (this.valueEnd < this.valueStart) {\n      this.valueEnd = this.valueStart;\n    }\n\n    if (this.displayEnd <= this.displayStart) {\n      this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n    }\n  }\n\n  displayRange() {\n    return {\n      min: this.displayStart,\n      max: this.displayEnd\n    };\n  }\n\n  displayIndices() {\n    if (!this._indices) {\n      const options = this.options;\n      const {\n        baseUnit,\n        baseUnitStep\n      } = options;\n      const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n      const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n      this._indices = {\n        min: minIdx,\n        max: maxIdx\n      };\n    }\n\n    return this._indices;\n  }\n\n  total() {\n    return {\n      min: this.start,\n      max: this.end\n    };\n  }\n\n  totalCount() {\n    const last = this.totalIndex(this.end);\n    return last + (this.options.justified ? 1 : 0);\n  }\n\n  valueRange() {\n    return {\n      min: this.valueStart,\n      max: this.valueEnd\n    };\n  }\n\n  valueIndex(value) {\n    const options = this.options;\n    return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n  }\n\n  totalIndex(value) {\n    const options = this.options;\n    return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n  }\n\n  dateIndex(value) {\n    const options = this.options;\n    return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n  }\n\n  valuesCount() {\n    const maxIdx = this.valueIndex(this.valueEnd);\n    return maxIdx + 1;\n  }\n\n  values() {\n    let values = this._values;\n\n    if (!values) {\n      const options = this.options;\n      const range = this.valueRange();\n      this._values = values = [];\n\n      for (let date = range.min; date <= range.max;) {\n        values.push(date);\n        date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n      }\n    }\n\n    return values;\n  }\n\n  dateAt(index, total) {\n    const options = this.options;\n    return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n  }\n\n  roundToTotalStep(value, upper, next) {\n    const {\n      baseUnit,\n      baseUnitStep,\n      weekStartDay\n    } = this.options;\n    const start = this.start;\n    const step = dateIndex(value, start, baseUnit, baseUnitStep);\n    let roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n    if (next) {\n      roundedStep += next;\n    }\n\n    return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n  }\n\n}\n\nfunction autoBaseUnit(options, startUnit, startStep) {\n  const categoryLimits = categoryRange(options.categories);\n  const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n  const {\n    autoBaseUnitSteps,\n    maxDateGroups\n  } = options;\n  const autoUnit = options.baseUnit === FIT;\n  let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n  let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n  let units = span / TIME_PER_UNIT[baseUnit];\n  let totalUnits = units;\n  let unitSteps, step, nextStep;\n\n  while (!step || units >= maxDateGroups) {\n    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n    do {\n      nextStep = unitSteps.shift();\n    } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n    if (nextStep) {\n      step = nextStep;\n      units = totalUnits / step;\n    } else if (baseUnit === last(BASE_UNITS)) {\n      step = Math.ceil(totalUnits / maxDateGroups);\n      break;\n    } else if (autoUnit) {\n      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n      totalUnits = span / TIME_PER_UNIT[baseUnit];\n      unitSteps = null;\n    } else {\n      if (units > maxDateGroups) {\n        step = Math.ceil(totalUnits / maxDateGroups);\n      }\n\n      break;\n    }\n  }\n\n  options.baseUnitStep = step;\n  options.baseUnit = baseUnit;\n}\n\nfunction defaultBaseUnit(options) {\n  const categories = options.categories;\n  const count = defined(categories) ? categories.length : 0;\n  let minDiff = MAX_VALUE;\n  let lastCategory, unit;\n\n  for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n    const category = categories[categoryIx];\n\n    if (category && lastCategory) {\n      const diff = absoluteDateDiff(category, lastCategory);\n\n      if (diff > 0) {\n        minDiff = Math.min(minDiff, diff);\n\n        if (minDiff >= TIME_PER_YEAR) {\n          unit = YEARS;\n        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n          unit = MONTHS;\n        } else if (minDiff >= TIME_PER_WEEK) {\n          unit = WEEKS;\n        } else if (minDiff >= TIME_PER_DAY) {\n          unit = DAYS;\n        } else if (minDiff >= TIME_PER_HOUR) {\n          unit = HOURS;\n        } else if (minDiff >= TIME_PER_MINUTE) {\n          unit = MINUTES;\n        } else {\n          unit = SECONDS;\n        }\n      }\n    }\n\n    lastCategory = category;\n  }\n\n  options.baseUnit = unit || DAYS;\n}\n\nfunction initUnit(options) {\n  const baseUnit = (options.baseUnit || \"\").toLowerCase();\n  const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n  if (useDefault) {\n    defaultBaseUnit(options);\n  }\n\n  if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n    autoBaseUnit(options);\n  }\n\n  return options;\n}\n\nclass DateCategoryAxis extends CategoryAxis {\n  clone() {\n    const copy = new DateCategoryAxis(Object.assign({}, this.options), this.chartService);\n    copy.createLabels();\n    return copy;\n  }\n\n  categoriesHash() {\n    const start = this.dataRange.total().min;\n    return this.options.baseUnit + this.options.baseUnitStep + start;\n  }\n\n  initUserOptions(options) {\n    return options;\n  }\n\n  initFields() {\n    super.initFields();\n    const chartService = this.chartService;\n    const intlService = chartService.intl;\n    let options = this.options;\n    let categories = options.categories || [];\n\n    if (!categories._parsed) {\n      categories = parseDates(intlService, categories);\n      categories._parsed = true;\n    }\n\n    options = deepExtend({\n      roundToBaseUnit: true\n    }, options, {\n      categories: categories,\n      min: parseDate(intlService, options.min),\n      max: parseDate(intlService, options.max),\n      weekStartDay: firstDay(options, intlService)\n    });\n\n    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n      options.roundToBaseUnit = false;\n    }\n\n    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n    this.options = options;\n    options.srcCategories = categories;\n\n    if (categories.length > 0) {\n      const range = categoryRange(categories);\n      const maxDivisions = options.maxDivisions;\n      this.dataRange = new DateRange(range.min, range.max, initUnit(options));\n\n      if (maxDivisions) {\n        const dataRange = this.dataRange.displayRange();\n        const divisionOptions = Object.assign({}, options, {\n          justified: true,\n          roundToBaseUnit: false,\n          baseUnit: 'fit',\n          min: dataRange.min,\n          max: dataRange.max,\n          maxDateGroups: maxDivisions\n        });\n        const dataRangeOptions = this.dataRange.options;\n        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n      } else {\n        this.divisionRange = this.dataRange;\n      }\n    } else {\n      options.baseUnit = options.baseUnit || DAYS;\n      this.dataRange = this.divisionRange = new EmptyDateRange(options);\n    }\n\n    this.rangeLabels = [];\n  }\n\n  tickIndices(stepSize) {\n    const {\n      dataRange,\n      divisionRange\n    } = this;\n    const valuesCount = divisionRange.valuesCount();\n\n    if (!this.options.maxDivisions || !valuesCount) {\n      return super.tickIndices(stepSize);\n    }\n\n    const indices = [];\n    let values = divisionRange.values();\n    let offset = 0;\n\n    if (!this.options.justified) {\n      values = values.concat(divisionRange.dateAt(valuesCount));\n      offset = 0.5; //align ticks to the center of not justified categories\n    }\n\n    for (let idx = 0; idx < values.length; idx++) {\n      indices.push(dataRange.dateIndex(values[idx]) + offset);\n\n      if (stepSize !== 1 && idx >= 1) {\n        const last = indices.length - 1;\n        indices.splice(idx, 0, indices[last - 1] + (indices[last] - indices[last - 1]) * stepSize);\n      }\n    }\n\n    return indices;\n  }\n\n  shouldRenderNote(value) {\n    const range = this.range();\n    const categories = this.options.categories || [];\n    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n  }\n\n  parseNoteValue(value) {\n    return parseDate(this.chartService.intl, value);\n  }\n\n  noteSlot(value) {\n    return this.getSlot(value);\n  }\n\n  translateRange(delta) {\n    const options = this.options;\n    const {\n      baseUnit,\n      weekStartDay,\n      vertical\n    } = options;\n    const lineBox = this.lineBox();\n    const size = vertical ? lineBox.height() : lineBox.width();\n    let range = this.range();\n    const scale = size / (range.max - range.min);\n    const offset = round(delta / scale, DEFAULT_PRECISION);\n\n    if (range.min && range.max) {\n      const from = addTicks(options.min || range.min, offset);\n      const to = addTicks(options.max || range.max, offset);\n      range = {\n        min: addDuration(from, 0, baseUnit, weekStartDay),\n        max: addDuration(to, 0, baseUnit, weekStartDay)\n      };\n    }\n\n    return range;\n  }\n\n  labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.divisionRange.valuesCount()\n    };\n  }\n\n  pan(delta) {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const options = this.options;\n    const lineBox = this.lineBox();\n    const size = options.vertical ? lineBox.height() : lineBox.width();\n    const {\n      min,\n      max\n    } = this.dataRange.displayRange();\n    const totalLimits = this.dataRange.total();\n    const scale = size / (max - min);\n    const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n    const from = addTicks(min, offset);\n    const to = addTicks(max, offset);\n    const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n    if (panRange) {\n      panRange.min = toDate(panRange.min);\n      panRange.max = toDate(panRange.max);\n      panRange.baseUnit = options.baseUnit;\n      panRange.baseUnitStep = options.baseUnitStep || 1;\n      panRange.userSetBaseUnit = options.userSetBaseUnit;\n      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n      return panRange;\n    }\n  }\n\n  pointsRange(start, end) {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const pointsRange = super.pointsRange(start, end);\n    const datesRange = this.dataRange.displayRange();\n    const indicesRange = this.dataRange.displayIndices();\n    const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n    const options = this.options;\n    const min = addTicks(datesRange.min, pointsRange.min * scale);\n    const max = addTicks(datesRange.min, pointsRange.max * scale);\n    return {\n      min: min,\n      max: max,\n      baseUnit: options.userSetBaseUnit || options.baseUnit,\n      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n    };\n  }\n\n  scaleRange(scale, cursor) {\n    if (this.isEmpty()) {\n      return {};\n    }\n\n    const options = this.options;\n    const fit = options.userSetBaseUnit === FIT;\n    const totalLimits = this.dataRange.total();\n    const {\n      min: rangeMin,\n      max: rangeMax\n    } = this.dataRange.displayRange();\n    const position = Math.abs(this.pointOffset(cursor));\n    const range = rangeMax - rangeMin;\n    const delta = this.scaleToDelta(scale, range);\n    const minDelta = Math.round(position * delta);\n    const maxDelta = Math.round((1 - position) * delta);\n    let {\n      baseUnit\n    } = this.dataRange.options;\n    let min = new Date(rangeMin.getTime() + minDelta);\n    let max = new Date(rangeMax.getTime() - maxDelta);\n\n    if (fit) {\n      const {\n        autoBaseUnitSteps,\n        maxDateGroups\n      } = options;\n      const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n      const rangeDiff = dateDiff(rangeMax, rangeMin);\n      const diff = dateDiff(max, min);\n      let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n      let autoBaseUnitStep, ticks;\n\n      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n        baseUnit = BASE_UNITS[baseUnitIndex - 1];\n        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n        min = addTicks(rangeMin, ticks);\n        max = addTicks(rangeMax, -ticks);\n      } else if (diff > maxDiff && baseUnit !== YEARS) {\n        let stepIndex = 0;\n\n        do {\n          baseUnitIndex++;\n          baseUnit = BASE_UNITS[baseUnitIndex];\n          stepIndex = 0;\n          ticks = 2 * TIME_PER_UNIT[baseUnit];\n\n          do {\n            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n            stepIndex++;\n          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n\n        if (ticks > 0) {\n          min = addTicks(rangeMin, -ticks);\n          max = addTicks(rangeMax, ticks);\n          min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n          max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n        }\n      }\n    }\n\n    if (min && max && dateDiff(max, min) > 0) {\n      return {\n        min: min,\n        max: max,\n        baseUnit: options.userSetBaseUnit || options.baseUnit,\n        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n      };\n    }\n  }\n\n  zoomRange(scale, cursor) {\n    const totalLimits = this.dataRange.total();\n    const range = this.scaleRange(scale, cursor);\n\n    if (range) {\n      if (range.min < totalLimits.min) {\n        range.min = totalLimits.min;\n      }\n\n      if (range.max > totalLimits.max) {\n        range.max = totalLimits.max;\n      }\n    }\n\n    return range;\n  }\n\n  range() {\n    return this.dataRange.displayRange();\n  }\n\n  createLabels() {\n    super.createLabels();\n    this.createRangeLabels();\n  }\n\n  clearLabels() {\n    super.clearLabels();\n    this.rangeLabels = [];\n  }\n\n  arrangeLabels() {\n    this.arrangeRangeLabels();\n    super.arrangeLabels();\n  }\n\n  arrangeRangeLabels() {\n    const {\n      options,\n      rangeLabels\n    } = this;\n\n    if (rangeLabels.length === 0) {\n      return;\n    }\n\n    const lineBox = this.lineBox();\n    const vertical = options.vertical;\n    const mirror = options.rangeLabels.mirror || options.labels.mirror;\n    const firstLabel = rangeLabels[0];\n\n    if (firstLabel) {\n      const position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;\n      this.positionLabel(firstLabel, mirror, position);\n    }\n\n    const lastLabel = rangeLabels[1];\n\n    if (lastLabel) {\n      const position = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;\n      this.positionLabel(lastLabel, mirror, position);\n    }\n  }\n\n  autoRotateLabels() {\n    super.autoRotateLabels();\n    this.autoRotateRangeLabels();\n  }\n\n  hideOutOfRangeLabels() {\n    super.hideOutOfRangeLabels();\n    this.hideOverlappingLabels();\n  }\n\n  hideOverlappingLabels() {\n    const {\n      rangeLabels,\n      labels\n    } = this;\n\n    if (rangeLabels.length === 0) {\n      return;\n    }\n\n    function clip(rangeLabel, label) {\n      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n        label.options.visible = false;\n        return true;\n      }\n\n      return false;\n    }\n\n    const firstRangeLabel = rangeLabels[0];\n\n    if (firstRangeLabel && firstRangeLabel.options.visible) {\n      for (let i = 0; i < labels.length; i++) {\n        const overlaps = clip(firstRangeLabel, labels[i]);\n\n        if (!overlaps) {\n          break;\n        }\n      }\n    }\n\n    const lastRangeLabel = rangeLabels[1];\n\n    if (lastRangeLabel && lastRangeLabel.options.visible) {\n      for (let i = labels.length - 1; i > 0; --i) {\n        const overlaps = clip(lastRangeLabel, labels[i]);\n\n        if (!overlaps) {\n          break;\n        }\n      }\n    }\n  }\n\n  contentBox() {\n    const box = super.contentBox();\n    const rangeLabels = this.rangeLabels;\n\n    for (let i = 0; i < rangeLabels.length; i++) {\n      const label = rangeLabels[i];\n\n      if (label.options.visible) {\n        box.wrap(label.box);\n      }\n    }\n\n    return box;\n  }\n\n  createAxisLabel(index, labelOptions, labelContext = {}) {\n    const options = this.options;\n    const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n    const date = this.divisionRange.dateAt(index);\n    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    labelContext.dataItem = dataItem;\n    const text = this.axisLabelText(date, labelOptions, labelContext);\n\n    if (text) {\n      return new AxisLabel(date, text, index, dataItem, labelOptions);\n    }\n  }\n\n  createRangeLabels() {\n    const {\n      displayStart,\n      displayEnd\n    } = this.divisionRange;\n    const options = this.options;\n    const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {\n      align: CENTER,\n      zIndex: options.zIndex\n    });\n\n    if (labelOptions.visible !== true) {\n      return;\n    }\n\n    this.normalizeLabelRotation(labelOptions);\n    labelOptions.alignRotation = CENTER;\n\n    if (labelOptions.rotation === \"auto\") {\n      labelOptions.rotation = 0;\n      options.autoRotateRangeLabels = true;\n    }\n\n    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n\n    const createLabel = (index, date, text) => {\n      if (text) {\n        const label = new AxisLabel(date, text, index, null, labelOptions);\n        this.append(label);\n        this.rangeLabels.push(label);\n      }\n    };\n\n    const startText = this.axisLabelText(displayStart, labelOptions, {\n      index: 0,\n      count: 2\n    });\n    createLabel(0, displayStart, startText);\n    const endText = this.axisLabelText(displayEnd, labelOptions, {\n      index: 1,\n      count: 2\n    });\n    createLabel(1, displayEnd, endText);\n  }\n\n  autoRotateRangeLabels() {\n    const labels = this.rangeLabels;\n\n    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n      return;\n    }\n\n    const rotateLabel = (label, tickPositions, index) => {\n      const width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n      const angle = this.autoRotateLabelAngle(label.box, width);\n\n      if (angle !== 0) {\n        label.options.rotation = angle;\n        label.reflow(new Box());\n      }\n    };\n\n    const tickPositions = this.getMajorTickPositions();\n    rotateLabel(labels[0], tickPositions, 0);\n    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n  }\n\n  categoryIndex(value) {\n    return this.dataRange.valueIndex(value);\n  }\n\n  slot(from, to, limit) {\n    const dateRange = this.dataRange;\n    let start = from;\n    let end = to;\n\n    if (start instanceof Date) {\n      start = dateRange.dateIndex(start);\n    }\n\n    if (end instanceof Date) {\n      end = dateRange.dateIndex(end);\n    }\n\n    const slot = this.getSlot(start, end, limit);\n\n    if (slot) {\n      return slot.toRect();\n    }\n  }\n\n  getSlot(a, b, limit) {\n    let start = a;\n    let end = b;\n\n    if (typeof start === OBJECT) {\n      start = this.categoryIndex(start);\n    }\n\n    if (typeof end === OBJECT) {\n      end = this.categoryIndex(end);\n    }\n\n    return super.getSlot(start, end, limit);\n  }\n\n  valueRange() {\n    const options = this.options;\n    const range = categoryRange(options.srcCategories);\n    return {\n      min: toDate(range.min),\n      max: toDate(range.max)\n    };\n  }\n\n  categoryAt(index, total) {\n    return this.dataRange.dateAt(index, total);\n  }\n\n  categoriesCount() {\n    return this.dataRange.valuesCount();\n  }\n\n  rangeIndices() {\n    return this.dataRange.displayIndices();\n  }\n\n  labelsBetweenTicks() {\n    return !this.divisionRange.options.justified;\n  }\n\n  prepareUserOptions() {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    this.options.categories = this.dataRange.values();\n  }\n\n  getCategory(point) {\n    const index = this.pointCategoryIndex(point);\n\n    if (index === null) {\n      return null;\n    }\n\n    return this.dataRange.dateAt(index);\n  }\n\n  totalIndex(value) {\n    return this.dataRange.totalIndex(value);\n  }\n\n  currentRangeIndices() {\n    const range = this.dataRange.valueRange();\n    return {\n      min: this.dataRange.totalIndex(range.min),\n      max: this.dataRange.totalIndex(range.max)\n    };\n  }\n\n  totalRange() {\n    return this.dataRange.total();\n  }\n\n  totalCount() {\n    return this.dataRange.totalCount();\n  }\n\n  isEmpty() {\n    return !this.options.srcCategories.length;\n  }\n\n  roundedRange() {\n    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n      return this.range();\n    }\n\n    const options = this.options;\n    const datesRange = categoryRange(options.srcCategories);\n    const dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {\n      justified: false,\n      roundToBaseUnit: true,\n      justifyEnd: false\n    }));\n    return dateRange.displayRange();\n  }\n\n}\n\nsetDefaultOptions(DateCategoryAxis, {\n  type: DATE,\n  labels: {\n    dateFormats: DateLabelFormats\n  },\n  rangeLabels: {\n    visible: false\n  },\n  autoBaseUnitSteps: {\n    milliseconds: [1, 10, 100],\n    seconds: [1, 2, 5, 15, 30],\n    minutes: [1, 2, 5, 15, 30],\n    hours: [1, 2, 3],\n    days: [1, 2, 3],\n    weeks: [1, 2],\n    months: [1, 2, 3, 6],\n    years: [1, 2, 3, 5, 10, 25, 50]\n  },\n  maxDateGroups: 10\n});\nexport default DateCategoryAxis;","map":null,"metadata":{},"sourceType":"module"}