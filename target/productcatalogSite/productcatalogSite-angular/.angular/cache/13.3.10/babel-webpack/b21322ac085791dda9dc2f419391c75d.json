{"ast":null,"code":"import { deepExtend, defined, isFunction, setDefaultOptions } from '../../common';\nimport { MAX_VALUE, MIN_VALUE } from '../../common/constants';\nimport { Box, ChartElement } from '../../core';\nimport CategoricalChart from '../categorical-chart';\nimport evalOptions from '../utils/eval-options';\nimport colorScale from './color-scale';\nimport HeatmapPoint from './heatmap-point';\n\nclass HeatmapChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n\n    this._initFields();\n\n    this.render();\n  }\n\n  _initFields() {\n    this.points = [];\n    this.seriesOptions = [];\n    this.valueRange = {\n      min: MAX_VALUE,\n      max: MIN_VALUE\n    };\n    this._evalSeries = [];\n  }\n\n  render() {\n    this.setRange();\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n\n  setRange() {\n    const {\n      options: {\n        series\n      }\n    } = this;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n\n      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n        const {\n          valueFields\n        } = this._bindPoint(currentSeries, seriesIx, pointIx);\n\n        if (defined(valueFields.value) && valueFields.value !== null) {\n          this.valueRange.min = Math.min(this.valueRange.min, valueFields.value);\n          this.valueRange.max = Math.max(this.valueRange.max, valueFields.value);\n        }\n      }\n    }\n  }\n\n  addValue(value, fields) {\n    let point;\n\n    if (value && defined(value.value) && value.value !== null) {\n      point = this.createPoint(value, fields);\n\n      if (point) {\n        Object.assign(point, fields);\n      }\n    }\n\n    this.points.push(point);\n  }\n\n  evalPointOptions(options, value, fields) {\n    const {\n      series,\n      seriesIx\n    } = fields;\n    const state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\"]\n    };\n    let doEval = this._evalSeries[seriesIx];\n\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n\n    let pointOptions = options;\n\n    if (doEval) {\n      pointOptions = deepExtend({}, options);\n      evalOptions(pointOptions, {\n        value: value,\n        series: series,\n        dataItem: fields.dataItem,\n        min: this.valueRange.min,\n        max: this.valueRange.max\n      }, state);\n    }\n\n    return pointOptions;\n  }\n\n  pointType() {\n    return HeatmapPoint;\n  }\n\n  pointOptions(series, seriesIx) {\n    let options = this.seriesOptions[seriesIx];\n\n    if (!options) {\n      const defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        markers: {\n          opacity: series.opacity\n        },\n        tooltip: {\n          format: this.options.tooltip.format\n        },\n        labels: {\n          format: this.options.labels.format\n        }\n      }, series);\n    }\n\n    return options;\n  }\n\n  createPoint(value, fields) {\n    const series = fields.series;\n    let pointOptions = this.pointOptions(series, fields.seriesIx);\n    let color = fields.color || series.color;\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    } else if (this.valueRange.max !== 0) {\n      const scale = colorScale(color);\n      color = scale(value.value / this.valueRange.max);\n    }\n\n    const point = new HeatmapPoint(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  }\n\n  seriesAxes(series) {\n    const {\n      xAxis: xAxisName,\n      yAxis: yAxisName\n    } = series;\n    const plotArea = this.plotArea;\n    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n    if (!xAxis) {\n      throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n    }\n\n    if (!yAxis) {\n      throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n    }\n\n    return {\n      xAxis,\n      yAxis\n    };\n  }\n\n  reflow(targetBox) {\n    const chartPoints = this.points;\n    const limit = !this.options.clip;\n    let pointIx = 0;\n    this.traverseDataPoints((value, fields) => {\n      const point = chartPoints[pointIx++];\n      const {\n        xAxis,\n        yAxis\n      } = this.seriesAxes(fields.series);\n      const indexX = xAxis.categoryIndex(value.x);\n      const indexY = yAxis.categoryIndex(value.y);\n      const slotX = xAxis.getSlot(indexX, indexX, limit);\n      const slotY = yAxis.getSlot(indexY, indexY, limit);\n\n      if (point) {\n        if (slotX && slotY) {\n          const pointSlot = this.pointSlot(slotX, slotY);\n          point.reflow(pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.box = targetBox;\n  }\n\n  pointSlot(slotX, slotY) {\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  }\n\n  traverseDataPoints(callback) {\n    const {\n      options: {\n        series\n      }\n    } = this;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const {\n        xAxis,\n        yAxis\n      } = this.seriesAxes(currentSeries);\n      const xRange = xAxis.currentRangeIndices();\n      const yRange = yAxis.currentRangeIndices();\n\n      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n        const {\n          valueFields: value,\n          fields\n        } = this._bindPoint(currentSeries, seriesIx, pointIx);\n\n        const xIndex = xAxis.totalIndex(value.x);\n        const yIndex = yAxis.totalIndex(value.y);\n        const xIn = xRange.min <= xIndex && xIndex <= xRange.max;\n        const yIn = yRange.min <= yIndex && yIndex <= yRange.max;\n\n        if (xIn && yIn) {\n          callback(value, deepExtend({\n            pointIx: pointIx,\n            series: currentSeries,\n            seriesIx: seriesIx,\n            dataItem: currentSeries.data[pointIx],\n            owner: this\n          }, fields));\n        }\n      }\n    }\n  }\n\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.x, value.y, value.value);\n  }\n\n  animationPoints() {\n    const points = this.points;\n    const result = [];\n\n    for (let idx = 0; idx < points.length; idx++) {\n      result.push((points[idx] || {}).marker);\n    }\n\n    return result;\n  }\n\n}\n\nsetDefaultOptions(HeatmapChart, {\n  series: [],\n  tooltip: {\n    format: \"{0}, {1}: {2}\"\n  },\n  labels: {\n    format: \"{2}\"\n  },\n  clip: true\n});\ndeepExtend(HeatmapChart.prototype, {\n  _bindPoint: CategoricalChart.prototype._bindPoint\n});\nexport default HeatmapChart;","map":null,"metadata":{},"sourceType":"module"}