{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1084);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1063:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data\");\n    /***/\n  },\n\n  /***/\n  1084:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051), __webpack_require__(1063)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"binder\",\n        name: \"MVVM\",\n        category: \"framework\",\n        description: \"Model View ViewModel (MVVM) is a design pattern which helps developers separate the Model (the data) from the View (the UI).\",\n        depends: [\"core\", \"data\"]\n      };\n      /*jshint eqnull: true */\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            Observable = kendo.Observable,\n            ObservableObject = kendo.data.ObservableObject,\n            ObservableArray = kendo.data.ObservableArray,\n            toString = {}.toString,\n            binders = {},\n            Class = kendo.Class,\n            VALUE = \"value\",\n            SOURCE = \"source\",\n            EVENTS = \"events\",\n            CHECKED = \"checked\",\n            CSS = \"css\",\n            deleteExpando = true,\n            FUNCTION = \"function\",\n            CHANGE = \"change\";\n\n        (function () {\n          var a = document.createElement(\"a\");\n\n          try {\n            delete a.test;\n          } catch (e) {\n            deleteExpando = false;\n          }\n        })();\n\n        var Binding = Observable.extend({\n          init: function (parents, path) {\n            var that = this;\n            Observable.fn.init.call(that);\n            that.source = parents[0];\n            that.parents = parents;\n            that.path = path;\n            that.dependencies = {};\n            that.dependencies[path] = true;\n            that.observable = that.source instanceof Observable;\n\n            that._access = function (e) {\n              that.dependencies[e.field] = true;\n            };\n\n            if (that.observable) {\n              that._change = function (e) {\n                that.change(e);\n              };\n\n              that.source.bind(CHANGE, that._change);\n            }\n          },\n          _parents: function () {\n            var parents = this.parents;\n            var value = this.get();\n\n            if (value && typeof value.parent == \"function\") {\n              var parent = value.parent();\n\n              if ($.inArray(parent, parents) < 0) {\n                parents = [parent].concat(parents);\n              }\n            }\n\n            return parents;\n          },\n          change: function (e) {\n            var dependency,\n                ch,\n                field = e.field,\n                that = this;\n\n            if (that.path === \"this\") {\n              that.trigger(CHANGE, e);\n            } else {\n              for (dependency in that.dependencies) {\n                if (dependency.indexOf(field) === 0) {\n                  ch = dependency.charAt(field.length);\n\n                  if (!ch || ch === \".\" || ch === \"[\") {\n                    that.trigger(CHANGE, e);\n                    break;\n                  }\n                }\n              }\n            }\n          },\n          start: function (source) {\n            source.bind(\"get\", this._access);\n          },\n          stop: function (source) {\n            source.unbind(\"get\", this._access);\n          },\n          get: function () {\n            var that = this,\n                source = that.source,\n                index = 0,\n                path = that.path,\n                result = source;\n\n            if (!that.observable) {\n              return result;\n            }\n\n            that.start(that.source);\n            result = source.get(path); // Traverse the observable hierarchy if the binding is not resolved at the current level.\n\n            while (result === undefined && source) {\n              source = that.parents[++index];\n\n              if (source instanceof ObservableObject) {\n                result = source.get(path);\n              }\n            } // second pass try to get the parent from the object hierarchy\n\n\n            if (result === undefined) {\n              source = that.source; //get the initial source\n\n              while (result === undefined && source) {\n                source = source.parent();\n\n                if (source instanceof ObservableObject) {\n                  result = source.get(path);\n                }\n              }\n            } // If the result is a function - invoke it\n\n\n            if (typeof result === \"function\") {\n              index = path.lastIndexOf(\".\"); // If the function is a member of a nested observable object make that nested observable the context (this) of the function\n\n              if (index > 0) {\n                source = source.get(path.substring(0, index));\n              } // Invoke the function\n\n\n              that.start(source);\n\n              if (source !== that.source) {\n                result = result.call(source, that.source);\n              } else {\n                result = result.call(source);\n              }\n\n              that.stop(source);\n            } // If the binding is resolved by a parent object\n\n\n            if (source && source !== that.source) {\n              that.currentSource = source; // save parent object\n              // Listen for changes in the parent object\n\n              source.unbind(CHANGE, that._change).bind(CHANGE, that._change);\n            }\n\n            that.stop(that.source);\n            return result;\n          },\n          set: function (value) {\n            var source = this.currentSource || this.source;\n            var field = kendo.getter(this.path)(source);\n\n            if (typeof field === \"function\") {\n              if (source !== this.source) {\n                field.call(source, this.source, value);\n              } else {\n                field.call(source, value);\n              }\n            } else {\n              source.set(this.path, value);\n            }\n          },\n          destroy: function () {\n            if (this.observable) {\n              this.source.unbind(CHANGE, this._change);\n\n              if (this.currentSource) {\n                this.currentSource.unbind(CHANGE, this._change);\n              }\n            }\n\n            this.unbind();\n          }\n        });\n        var EventBinding = Binding.extend({\n          get: function () {\n            var source = this.source,\n                path = this.path,\n                index = 0,\n                handler;\n            handler = source.get(path);\n\n            while (!handler && source) {\n              source = this.parents[++index];\n\n              if (source instanceof ObservableObject) {\n                handler = source.get(path);\n              }\n            }\n\n            if (!handler) {\n              return;\n            }\n\n            return handler.bind(source);\n          }\n        });\n        var TemplateBinding = Binding.extend({\n          init: function (source, path, template) {\n            var that = this;\n            Binding.fn.init.call(that, source, path);\n            that.template = template;\n          },\n          render: function (value) {\n            var html;\n            this.start(this.source);\n            html = kendo.render(this.template, value);\n            this.stop(this.source);\n            return html;\n          }\n        });\n        var Binder = Class.extend({\n          init: function (element, bindings, options) {\n            this.element = element;\n            this.bindings = bindings;\n            this.options = options;\n          },\n          bind: function (binding, attribute) {\n            var that = this;\n            binding = attribute ? binding[attribute] : binding;\n            binding.bind(CHANGE, function (e) {\n              that.refresh(attribute || e);\n            });\n            that.refresh(attribute);\n          },\n          destroy: function () {}\n        });\n        var TypedBinder = Binder.extend({\n          dataType: function () {\n            var dataType = this.element.getAttribute(\"data-\" + kendo.ns + \"type\") || this.element.type || \"text\";\n            return dataType.toLowerCase();\n          },\n          parsedValue: function () {\n            return this._parseValue(this.element.value, this.dataType());\n          },\n          _parseValue: function (value, dataType) {\n            if (dataType == \"date\") {\n              value = kendo.parseDate(value, \"yyyy-MM-dd\");\n            } else if (dataType == \"datetime-local\") {\n              value = kendo.parseDate(value, [\"yyyy-MM-ddTHH:mm:ss\", \"yyyy-MM-ddTHH:mm\"]);\n            } else if (dataType == \"number\") {\n              value = kendo.parseFloat(value);\n            } else if (dataType == \"boolean\") {\n              value = value.toLowerCase();\n\n              if (kendo.parseFloat(value) !== null) {\n                value = Boolean(kendo.parseFloat(value));\n              } else {\n                value = value.toLowerCase() === \"true\";\n              }\n            }\n\n            return value;\n          }\n        });\n        binders.attr = Binder.extend({\n          refresh: function (key) {\n            this.element.setAttribute(key, this.bindings.attr[key].get());\n          }\n        });\n        binders.css = Binder.extend({\n          init: function (element, bindings, options) {\n            Binder.fn.init.call(this, element, bindings, options);\n            this.classes = {};\n          },\n          refresh: function (className) {\n            var element = $(this.element),\n                binding = this.bindings.css[className],\n                hasClass = this.classes[className] = binding.get();\n\n            if (hasClass) {\n              element.addClass(className);\n            } else {\n              element.removeClass(className);\n            }\n          }\n        });\n        binders.style = Binder.extend({\n          refresh: function (key) {\n            this.element.style[key] = this.bindings.style[key].get() || \"\";\n          }\n        });\n        binders.enabled = Binder.extend({\n          refresh: function () {\n            if (this.bindings.enabled.get()) {\n              this.element.removeAttribute(\"disabled\");\n            } else {\n              this.element.setAttribute(\"disabled\", \"disabled\");\n            }\n          }\n        });\n        binders.readonly = Binder.extend({\n          refresh: function () {\n            if (this.bindings.readonly.get()) {\n              this.element.setAttribute(\"readonly\", \"readonly\");\n            } else {\n              this.element.removeAttribute(\"readonly\");\n            }\n          }\n        });\n        binders.disabled = Binder.extend({\n          refresh: function () {\n            if (this.bindings.disabled.get()) {\n              this.element.setAttribute(\"disabled\", \"disabled\");\n            } else {\n              this.element.removeAttribute(\"disabled\");\n            }\n          }\n        });\n        binders.events = Binder.extend({\n          init: function (element, bindings, options) {\n            Binder.fn.init.call(this, element, bindings, options);\n            this.handlers = {};\n          },\n          refresh: function (key) {\n            var element = $(this.element),\n                binding = this.bindings.events[key],\n                handler = this.handlers[key];\n\n            if (handler) {\n              element.off(key, handler);\n            }\n\n            handler = this.handlers[key] = binding.get();\n            element.on(key, binding.source, handler);\n          },\n          destroy: function () {\n            var element = $(this.element),\n                handler;\n\n            for (handler in this.handlers) {\n              element.off(handler, this.handlers[handler]);\n            }\n          }\n        });\n        binders.text = Binder.extend({\n          refresh: function () {\n            var text = this.bindings.text.get();\n            var dataFormat = this.element.getAttribute(\"data-\" + kendo.ns + \"format\") || \"\";\n\n            if (text == null) {\n              text = \"\";\n            }\n\n            $(this.element).text(kendo.toString(text, dataFormat));\n          }\n        });\n        binders.visible = Binder.extend({\n          refresh: function () {\n            if (this.bindings.visible.get()) {\n              this.element.style.display = \"\";\n            } else {\n              this.element.style.display = \"none\";\n            }\n          }\n        });\n        binders.invisible = Binder.extend({\n          refresh: function () {\n            if (!this.bindings.invisible.get()) {\n              this.element.style.display = \"\";\n            } else {\n              this.element.style.display = \"none\";\n            }\n          }\n        });\n        binders.html = Binder.extend({\n          refresh: function () {\n            this.element.innerHTML = this.bindings.html.get();\n          }\n        });\n        binders.value = TypedBinder.extend({\n          init: function (element, bindings, options) {\n            TypedBinder.fn.init.call(this, element, bindings, options);\n            this._change = this.change.bind(this);\n            this.eventName = options.valueUpdate || CHANGE;\n            $(this.element).on(this.eventName, this._change);\n            this._initChange = false;\n          },\n          change: function () {\n            this._initChange = this.eventName != CHANGE;\n            this.bindings[VALUE].set(this.parsedValue());\n            this._initChange = false;\n          },\n          refresh: function () {\n            if (!this._initChange) {\n              var value = this.bindings[VALUE].get();\n\n              if (value == null) {\n                value = \"\";\n              }\n\n              var type = this.dataType();\n\n              if (type == \"date\") {\n                value = kendo.toString(value, \"yyyy-MM-dd\");\n              } else if (type == \"datetime-local\") {\n                value = kendo.toString(value, \"yyyy-MM-ddTHH:mm:ss\");\n              }\n\n              this.element.value = value;\n            }\n\n            this._initChange = false;\n          },\n          destroy: function () {\n            $(this.element).off(this.eventName, this._change);\n          }\n        });\n        binders.source = Binder.extend({\n          init: function (element, bindings, options) {\n            Binder.fn.init.call(this, element, bindings, options);\n            var source = this.bindings.source.get();\n\n            if (source instanceof kendo.data.DataSource && options.autoBind !== false) {\n              source.fetch();\n            }\n          },\n          refresh: function (e) {\n            var that = this,\n                source = that.bindings.source.get();\n\n            if (source instanceof ObservableArray || source instanceof kendo.data.DataSource) {\n              e = e || {};\n\n              if (e.action == \"add\") {\n                that.add(e.index, e.items);\n              } else if (e.action == \"remove\") {\n                that.remove(e.index, e.items);\n              } else if (e.action != \"itemchange\") {\n                that.render();\n              }\n            } else {\n              that.render();\n            }\n          },\n          container: function () {\n            var element = this.element;\n\n            if (element.nodeName.toLowerCase() == \"table\") {\n              if (!element.tBodies[0]) {\n                element.appendChild(document.createElement(\"tbody\"));\n              }\n\n              element = element.tBodies[0];\n            }\n\n            return element;\n          },\n          template: function () {\n            var options = this.options,\n                template = options.template,\n                nodeName = this.container().nodeName.toLowerCase();\n\n            if (!template) {\n              if (nodeName == \"select\") {\n                if (options.valueField || options.textField) {\n                  template = kendo.format('<option value=\"#:{0}#\">#:{1}#</option>', options.valueField || options.textField, options.textField || options.valueField);\n                } else {\n                  template = \"<option>#:data#</option>\";\n                }\n              } else if (nodeName == \"tbody\") {\n                template = \"<tr><td>#:data#</td></tr>\";\n              } else if (nodeName == \"ul\" || nodeName == \"ol\") {\n                template = \"<li>#:data#</li>\";\n              } else {\n                template = \"#:data#\";\n              }\n\n              template = kendo.template(template);\n            }\n\n            return template;\n          },\n          add: function (index, items) {\n            var element = this.container(),\n                parents,\n                idx,\n                length,\n                child,\n                clone = element.cloneNode(false),\n                reference = element.children[index];\n            $(clone).html(kendo.render(this.template(), items));\n\n            if (clone.children.length) {\n              parents = this.bindings.source._parents();\n\n              for (idx = 0, length = items.length; idx < length; idx++) {\n                child = clone.children[0];\n                element.insertBefore(child, reference || null);\n                bindElement(child, items[idx], this.options.roles, [items[idx]].concat(parents));\n              }\n            }\n          },\n          remove: function (index, items) {\n            var idx,\n                element = this.container();\n\n            for (idx = 0; idx < items.length; idx++) {\n              var child = element.children[index];\n              unbindElementTree(child, true);\n\n              if (child.parentNode == element) {\n                element.removeChild(child);\n              }\n            }\n          },\n          render: function () {\n            var source = this.bindings.source.get(),\n                parents,\n                idx,\n                length,\n                element = this.container(),\n                template = this.template();\n\n            if (source == null) {\n              return;\n            }\n\n            if (source instanceof kendo.data.DataSource) {\n              source = source.view();\n            }\n\n            if (!(source instanceof ObservableArray) && toString.call(source) !== \"[object Array]\") {\n              source = [source];\n            }\n\n            if (this.bindings.template) {\n              unbindElementChildren(element, true);\n              $(element).html(this.bindings.template.render(source));\n\n              if (element.children.length) {\n                parents = this.bindings.source._parents();\n\n                for (idx = 0, length = source.length; idx < length; idx++) {\n                  bindElement(element.children[idx], source[idx], this.options.roles, [source[idx]].concat(parents));\n                }\n              }\n            } else {\n              $(element).html(kendo.render(template, source));\n            }\n          }\n        });\n        binders.input = {\n          checked: TypedBinder.extend({\n            init: function (element, bindings, options) {\n              TypedBinder.fn.init.call(this, element, bindings, options);\n              this._change = this.change.bind(this);\n              $(this.element).change(this._change);\n            },\n            change: function () {\n              var element = this.element;\n              var value = this.value();\n\n              if (element.type == \"radio\") {\n                value = this.parsedValue();\n                this.bindings[CHECKED].set(value);\n              } else if (element.type == \"checkbox\") {\n                var source = this.bindings[CHECKED].get();\n                var index;\n\n                if (source instanceof ObservableArray) {\n                  value = this.parsedValue();\n\n                  if (value instanceof Date) {\n                    for (var i = 0; i < source.length; i++) {\n                      if (source[i] instanceof Date && +source[i] === +value) {\n                        index = i;\n                        break;\n                      }\n                    }\n                  } else {\n                    index = source.indexOf(value);\n                  }\n\n                  if (index > -1) {\n                    source.splice(index, 1);\n                  } else {\n                    source.push(value);\n                  }\n                } else {\n                  this.bindings[CHECKED].set(value);\n                }\n              }\n            },\n            refresh: function () {\n              var value = this.bindings[CHECKED].get(),\n                  source = value,\n                  type = this.dataType(),\n                  element = this.element;\n\n              if (element.type == \"checkbox\") {\n                if (source instanceof ObservableArray) {\n                  var index = -1;\n                  value = this.parsedValue();\n\n                  if (value instanceof Date) {\n                    for (var i = 0; i < source.length; i++) {\n                      if (source[i] instanceof Date && +source[i] === +value) {\n                        index = i;\n                        break;\n                      }\n                    }\n                  } else {\n                    index = source.indexOf(value);\n                  }\n\n                  element.checked = index >= 0;\n                } else {\n                  element.checked = source;\n                }\n              } else if (element.type == \"radio\") {\n                if (type == \"date\") {\n                  value = kendo.toString(value, \"yyyy-MM-dd\");\n                } else if (type == \"datetime-local\") {\n                  value = kendo.toString(value, \"yyyy-MM-ddTHH:mm:ss\");\n                }\n\n                if (value !== null && typeof value !== \"undefined\" && element.value === value.toString()) {\n                  element.checked = true;\n                } else {\n                  element.checked = false;\n                }\n              }\n            },\n            value: function () {\n              var element = this.element,\n                  value = element.value;\n\n              if (element.type == \"checkbox\") {\n                value = element.checked;\n              }\n\n              return value;\n            },\n            destroy: function () {\n              $(this.element).off(CHANGE, this._change);\n            }\n          })\n        };\n        binders.select = {\n          source: binders.source.extend({\n            refresh: function (e) {\n              var that = this,\n                  source = that.bindings.source.get();\n\n              if (source instanceof ObservableArray || source instanceof kendo.data.DataSource) {\n                e = e || {};\n\n                if (e.action == \"add\") {\n                  that.add(e.index, e.items);\n                } else if (e.action == \"remove\") {\n                  that.remove(e.index, e.items);\n                } else if (e.action == \"itemchange\" || e.action === undefined) {\n                  that.render();\n\n                  if (that.bindings.value) {\n                    if (that.bindings.value) {\n                      var val = retrievePrimitiveValues(that.bindings.value.get(), $(that.element).data(\"valueField\"));\n\n                      if (val === null) {\n                        that.element.selectedIndex = -1;\n                      } else {\n                        that.element.value = val;\n                      }\n                    }\n                  }\n                }\n              } else {\n                that.render();\n              }\n            }\n          }),\n          value: TypedBinder.extend({\n            init: function (target, bindings, options) {\n              TypedBinder.fn.init.call(this, target, bindings, options);\n              this._change = this.change.bind(this);\n              $(this.element).change(this._change);\n            },\n            parsedValue: function () {\n              var dataType = this.dataType();\n              var values = [];\n              var value, option, idx, length;\n\n              for (idx = 0, length = this.element.options.length; idx < length; idx++) {\n                option = this.element.options[idx];\n\n                if (option.selected) {\n                  value = option.attributes.value;\n\n                  if (value && value.specified) {\n                    value = option.value;\n                  } else {\n                    value = option.text;\n                  }\n\n                  values.push(this._parseValue(value, dataType));\n                }\n              }\n\n              return values;\n            },\n            change: function () {\n              var values = [],\n                  element = this.element,\n                  source,\n                  field = this.options.valueField || this.options.textField,\n                  valuePrimitive = this.options.valuePrimitive,\n                  option,\n                  valueIndex,\n                  value,\n                  idx,\n                  length;\n\n              for (idx = 0, length = element.options.length; idx < length; idx++) {\n                option = element.options[idx];\n\n                if (option.selected) {\n                  value = option.attributes.value;\n\n                  if (value && value.specified) {\n                    value = option.value;\n                  } else {\n                    value = option.text;\n                  }\n\n                  if (field) {\n                    values.push(value);\n                  } else {\n                    values.push(this._parseValue(value, this.dataType()));\n                  }\n                }\n              }\n\n              if (field) {\n                source = this.bindings.source.get();\n\n                if (source instanceof kendo.data.DataSource) {\n                  source = source.view();\n                }\n\n                for (valueIndex = 0; valueIndex < values.length; valueIndex++) {\n                  for (idx = 0, length = source.length; idx < length; idx++) {\n                    var sourceValue = source[idx].get(field);\n                    var match = String(sourceValue) === values[valueIndex];\n\n                    if (match) {\n                      values[valueIndex] = source[idx];\n                      break;\n                    }\n                  }\n                }\n              }\n\n              value = this.bindings[VALUE].get();\n\n              if (value instanceof ObservableArray) {\n                value.splice.apply(value, [0, value.length].concat(values));\n              } else if (!valuePrimitive && (value instanceof ObservableObject || value === null || value === undefined || !field)) {\n                this.bindings[VALUE].set(values[0]);\n              } else {\n                this.bindings[VALUE].set(values[0].get(field));\n              }\n            },\n            refresh: function () {\n              var optionIndex,\n                  element = this.element,\n                  options = element.options,\n                  value = this.bindings[VALUE].get(),\n                  values = value,\n                  field = this.options.valueField || this.options.textField,\n                  found = false,\n                  type = this.dataType(),\n                  optionValue;\n\n              if (!(values instanceof ObservableArray)) {\n                values = new ObservableArray([value]);\n              }\n\n              element.selectedIndex = -1;\n\n              for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {\n                value = values[valueIndex];\n\n                if (field && value instanceof ObservableObject) {\n                  value = value.get(field);\n                }\n\n                if (type == \"date\") {\n                  value = kendo.toString(values[valueIndex], \"yyyy-MM-dd\");\n                } else if (type == \"datetime-local\") {\n                  value = kendo.toString(values[valueIndex], \"yyyy-MM-ddTHH:mm:ss\");\n                }\n\n                for (optionIndex = 0; optionIndex < options.length; optionIndex++) {\n                  optionValue = options[optionIndex].value;\n\n                  if (optionValue === \"\" && value !== \"\") {\n                    optionValue = options[optionIndex].text;\n                  }\n\n                  if (value != null && optionValue == value.toString()) {\n                    options[optionIndex].selected = true;\n                    found = true;\n                  }\n                }\n              }\n            },\n            destroy: function () {\n              $(this.element).off(CHANGE, this._change);\n            }\n          })\n        };\n\n        function dataSourceBinding(bindingName, fieldName, setter) {\n          return Binder.extend({\n            init: function (widget, bindings, options) {\n              var that = this;\n              Binder.fn.init.call(that, widget.element[0], bindings, options);\n              that.widget = widget;\n              that._dataBinding = that.dataBinding.bind(that);\n              that._dataBound = that.dataBound.bind(that);\n              that._itemChange = that.itemChange.bind(that);\n            },\n            itemChange: function (e) {\n              bindElement(e.item[0], e.data, this._ns(e.ns), [e.data].concat(this.bindings[bindingName]._parents()));\n            },\n            dataBinding: function (e) {\n              var idx,\n                  length,\n                  widget = this.widget,\n                  items = e.removedItems || widget.items();\n\n              for (idx = 0, length = items.length; idx < length; idx++) {\n                unbindElementTree(items[idx], false);\n              }\n            },\n            _ns: function (ns) {\n              ns = ns || kendo.ui;\n              var all = [kendo.ui, kendo.dataviz.ui, kendo.mobile.ui];\n              all.splice($.inArray(ns, all), 1);\n              all.unshift(ns);\n              return kendo.rolesFromNamespaces(all);\n            },\n            dataBound: function (e) {\n              var idx,\n                  length,\n                  widget = this.widget,\n                  items = e.addedItems || widget.items(),\n                  dataSource = widget[fieldName],\n                  view,\n                  parents,\n                  hds = kendo.data.HierarchicalDataSource;\n\n              if (hds && dataSource instanceof hds) {\n                // suppress binding of HDS items, because calling view() on root\n                // will return only root items, and widget.items() returns all items\n                return;\n              }\n\n              if (items.length) {\n                view = e.addedDataItems || dataSource.flatView();\n                parents = this.bindings[bindingName]._parents();\n\n                for (idx = 0, length = view.length; idx < length; idx++) {\n                  if (items[idx]) {\n                    bindElement(items[idx], view[idx], this._ns(e.ns), [view[idx]].concat(parents));\n                  }\n                }\n              }\n            },\n            refresh: function (e) {\n              var that = this,\n                  source,\n                  widget = that.widget,\n                  select,\n                  multiselect,\n                  dropdowntree;\n              e = e || {};\n\n              if (!e.action) {\n                that.destroy();\n                widget.bind(\"dataBinding\", that._dataBinding);\n                widget.bind(\"dataBound\", that._dataBound);\n                widget.bind(\"itemChange\", that._itemChange);\n                source = that.bindings[bindingName].get();\n\n                if (widget[fieldName] instanceof kendo.data.DataSource && widget[fieldName] != source) {\n                  if (source instanceof kendo.data.DataSource) {\n                    widget[setter](source);\n                  } else if (source && source._dataSource) {\n                    widget[setter](source._dataSource);\n                  } else {\n                    select = kendo.ui.Select && widget instanceof kendo.ui.Select;\n                    multiselect = kendo.ui.MultiSelect && widget instanceof kendo.ui.MultiSelect;\n                    dropdowntree = kendo.ui.DropDownTree && widget instanceof kendo.ui.DropDownTree;\n\n                    if (!dropdowntree) {\n                      widget[fieldName].data(source);\n                    } else {\n                      widget.treeview[fieldName].data(source);\n                    }\n\n                    if (that.bindings.value && (select || multiselect)) {\n                      widget.value(retrievePrimitiveValues(that.bindings.value.get(), widget.options.dataValueField));\n                    }\n                  }\n                }\n              }\n            },\n            destroy: function () {\n              var widget = this.widget;\n              widget.unbind(\"dataBinding\", this._dataBinding);\n              widget.unbind(\"dataBound\", this._dataBound);\n              widget.unbind(\"itemChange\", this._itemChange);\n            }\n          });\n        }\n\n        binders.widget = {\n          events: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n              this.handlers = {};\n            },\n            refresh: function (key) {\n              var binding = this.bindings.events[key],\n                  handler = this.handlers[key];\n\n              if (handler) {\n                this.widget.unbind(key, handler);\n              }\n\n              handler = binding.get();\n\n              this.handlers[key] = function (e) {\n                e.data = binding.source;\n                handler(e);\n\n                if (e.data === binding.source) {\n                  delete e.data;\n                }\n              };\n\n              this.widget.bind(key, this.handlers[key]);\n            },\n            destroy: function () {\n              var handler;\n\n              for (handler in this.handlers) {\n                this.widget.unbind(handler, this.handlers[handler]);\n              }\n            }\n          }),\n          checked: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n              this._change = this.change.bind(this);\n              this.widget.bind(CHANGE, this._change);\n            },\n            change: function () {\n              this.bindings[CHECKED].set(this.value());\n            },\n            refresh: function () {\n              if (this.element.type === \"radio\") {\n                this.widget.check(this.bindings[CHECKED].get().toString() === this.value());\n              } else {\n                this.widget.check(this.bindings[CHECKED].get() === true);\n              }\n            },\n            value: function () {\n              var element = this.element,\n                  value = element.value;\n\n              if (value == \"on\" || value == \"off\" || this.element.type == \"checkbox\") {\n                value = element.checked;\n              }\n\n              return value;\n            },\n            destroy: function () {\n              this.widget.unbind(CHANGE, this._change);\n            }\n          }),\n          start: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this._change = this.change.bind(this);\n              this.widget = widget;\n              this.widget.bind(CHANGE, this._change);\n            },\n            change: function () {\n              this.bindings.start.set(this.widget.range().start);\n            },\n            refresh: function () {\n              var that = this;\n              var start = this.bindings.start.get();\n              var end = that.widget._range ? that.widget._range.end : null;\n              this.widget.range({\n                start: start,\n                end: end\n              });\n            },\n            destroy: function () {\n              this.widget.unbind(CHANGE, this._change);\n            }\n          }),\n          end: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this._change = this.change.bind(this);\n              this.widget = widget;\n              this.widget.bind(CHANGE, this._change);\n            },\n            change: function () {\n              this.bindings.end.set(this.widget.range().end);\n            },\n            refresh: function () {\n              var that = this;\n              var end = this.bindings.end.get();\n              var start = that.widget._range ? that.widget._range.start : null;\n              this.widget.range({\n                start: start,\n                end: end\n              });\n            },\n            destroy: function () {\n              this.widget.unbind(CHANGE, this._change);\n            }\n          }),\n          visible: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n            },\n            refresh: function () {\n              var visible = this.bindings.visible.get();\n              this.widget.wrapper[0].style.display = visible ? \"\" : \"none\";\n            }\n          }),\n          invisible: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n            },\n            refresh: function () {\n              var invisible = this.bindings.invisible.get();\n              this.widget.wrapper[0].style.display = invisible ? \"none\" : \"\";\n            }\n          }),\n          floatingLabel: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n\n              if (!widget.floatingLabel) {\n                return;\n              }\n\n              widget.floatingLabel.refresh();\n            }\n          }),\n          enabled: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n            },\n            refresh: function () {\n              if (this.widget.enable) {\n                this.widget.enable(this.bindings.enabled.get());\n              }\n            }\n          }),\n          disabled: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n            },\n            refresh: function () {\n              if (this.widget.enable) {\n                this.widget.enable(!this.bindings.disabled.get());\n              }\n            }\n          }),\n          source: dataSourceBinding(\"source\", \"dataSource\", \"setDataSource\"),\n          value: Binder.extend({\n            init: function (widget, bindings, options) {\n              Binder.fn.init.call(this, widget.element[0], bindings, options);\n              this.widget = widget;\n              this._change = this.change.bind(this);\n              this.widget.first(CHANGE, this._change);\n              var value = this.bindings.value.get();\n              this._valueIsObservableObject = !options.valuePrimitive && (value == null || value instanceof ObservableObject);\n              this._valueIsObservableArray = value instanceof ObservableArray;\n              this._initChange = false;\n            },\n            _source: function () {\n              var source;\n\n              if (this.widget.dataItem) {\n                source = this.widget.dataItem();\n\n                if (source && source instanceof ObservableObject) {\n                  return [source];\n                }\n              }\n\n              if (this.bindings.source) {\n                source = this.bindings.source.get();\n              }\n\n              if (!source || source instanceof kendo.data.DataSource) {\n                source = this.widget.dataSource.flatView();\n              }\n\n              return source;\n            },\n            change: function () {\n              var value = this.widget.value(),\n                  field = this.options.dataValueField || this.options.dataTextField,\n                  isArray = toString.call(value) === \"[object Array]\",\n                  isObservableObject = this._valueIsObservableObject,\n                  valueIndex,\n                  valueLength,\n                  values = [],\n                  sourceItem,\n                  sourceValue,\n                  idx,\n                  length,\n                  source;\n              this._initChange = true;\n\n              if (field) {\n                if (value === \"\" && (isObservableObject || this.options.valuePrimitive)) {\n                  value = null;\n                } else {\n                  source = this._source();\n\n                  if (isArray) {\n                    valueLength = value.length;\n                    values = value.slice(0);\n                  }\n\n                  for (idx = 0, length = source.length; idx < length; idx++) {\n                    sourceItem = source[idx];\n                    sourceValue = sourceItem.get(field);\n\n                    if (isArray) {\n                      for (valueIndex = 0; valueIndex < valueLength; valueIndex++) {\n                        if (sourceValue == values[valueIndex]) {\n                          values[valueIndex] = sourceItem;\n                          break;\n                        }\n                      }\n                    } else if (sourceValue == value) {\n                      value = isObservableObject ? sourceItem : sourceValue;\n                      break;\n                    }\n                  }\n\n                  if (values[0]) {\n                    if (this._valueIsObservableArray) {\n                      value = values;\n                    } else if (isObservableObject || !field) {\n                      value = values[0];\n                    } else {\n                      value = values[0].get(field);\n                    }\n                  }\n                }\n              }\n\n              this.bindings.value.set(value);\n              this._initChange = false;\n            },\n            refresh: function () {\n              if (!this._initChange) {\n                var widget = this.widget;\n                var options = widget.options;\n                var textField = options.dataTextField;\n                var valueField = options.dataValueField || textField;\n                var value = this.bindings.value.get();\n                var text = options.text || \"\";\n                var idx = 0,\n                    length;\n                var values = [];\n\n                if (value === undefined) {\n                  value = null;\n                }\n\n                if (valueField) {\n                  if (value instanceof ObservableArray) {\n                    for (length = value.length; idx < length; idx++) {\n                      values[idx] = value[idx].get(valueField);\n                    }\n\n                    value = values;\n                  } else if (value instanceof ObservableObject) {\n                    text = value.get(textField);\n                    value = value.get(valueField);\n                  }\n                }\n\n                if (options.autoBind === false && !options.cascadeFrom && widget.listView && !widget.listView.bound()) {\n                  if (textField === valueField && !text) {\n                    text = value;\n                  }\n\n                  if (!text && (value || value === 0) && options.valuePrimitive) {\n                    widget.value(value);\n                  } else {\n                    widget._preselect(value, text);\n                  }\n                } else {\n                  widget.value(value);\n                }\n              }\n\n              this._initChange = false;\n            },\n            destroy: function () {\n              this.widget.unbind(CHANGE, this._change);\n            }\n          }),\n          dropdowntree: {\n            value: Binder.extend({\n              init: function (widget, bindings, options) {\n                Binder.fn.init.call(this, widget.element[0], bindings, options);\n                this.widget = widget;\n                this._change = this.change.bind(this);\n                this.widget.first(CHANGE, this._change);\n                this._initChange = false;\n              },\n              change: function () {\n                var that = this,\n                    oldValues = that.bindings[VALUE].get(),\n                    valuePrimitive = that.options.valuePrimitive,\n                    selectedNode = that.widget.treeview.select(),\n                    nonPrimitiveValues = that.widget._isMultipleSelection() ? that.widget._getAllChecked() : that.widget.treeview.dataItem(selectedNode) || that.widget.value(),\n                    newValues = valuePrimitive || that.widget.options.autoBind === false ? that.widget.value() : nonPrimitiveValues;\n                var field = this.options.dataValueField || this.options.dataTextField;\n                newValues = newValues.slice ? newValues.slice(0) : newValues;\n                that._initChange = true;\n\n                if (oldValues instanceof ObservableArray) {\n                  var remove = [];\n                  var newLength = newValues.length;\n                  var i = 0,\n                      j = 0;\n                  var old = oldValues[i];\n                  var same = false;\n                  var removeIndex;\n                  var newValue;\n                  var found;\n\n                  while (old !== undefined) {\n                    found = false;\n\n                    for (j = 0; j < newLength; j++) {\n                      if (valuePrimitive) {\n                        same = newValues[j] == old;\n                      } else {\n                        newValue = newValues[j];\n                        newValue = newValue.get ? newValue.get(field) : newValue;\n                        same = newValue == (old.get ? old.get(field) : old);\n                      }\n\n                      if (same) {\n                        newValues.splice(j, 1);\n                        newLength -= 1;\n                        found = true;\n                        break;\n                      }\n                    }\n\n                    if (!found) {\n                      remove.push(old);\n                      arraySplice(oldValues, i, 1);\n                      removeIndex = i;\n                    } else {\n                      i += 1;\n                    }\n\n                    old = oldValues[i];\n                  }\n\n                  arraySplice(oldValues, oldValues.length, 0, newValues);\n\n                  if (remove.length) {\n                    oldValues.trigger(\"change\", {\n                      action: \"remove\",\n                      items: remove,\n                      index: removeIndex\n                    });\n                  }\n\n                  if (newValues.length) {\n                    oldValues.trigger(\"change\", {\n                      action: \"add\",\n                      items: newValues,\n                      index: oldValues.length - 1\n                    });\n                  }\n                } else {\n                  that.bindings[VALUE].set(newValues);\n                }\n\n                that._initChange = false;\n              },\n              refresh: function () {\n                if (!this._initChange) {\n                  var options = this.options,\n                      widget = this.widget,\n                      field = options.dataValueField || options.dataTextField,\n                      value = this.bindings.value.get(),\n                      data = value,\n                      idx = 0,\n                      length,\n                      values = [],\n                      selectedValue;\n\n                  if (field) {\n                    if (value instanceof ObservableArray) {\n                      for (length = value.length; idx < length; idx++) {\n                        selectedValue = value[idx];\n                        values[idx] = selectedValue.get ? selectedValue.get(field) : selectedValue;\n                      }\n\n                      value = values;\n                    } else if (value instanceof ObservableObject) {\n                      value = value.get(field);\n                    }\n                  }\n\n                  if (options.autoBind === false && options.valuePrimitive !== true) {\n                    widget._preselect(data, value);\n                  } else {\n                    widget.value(value);\n                  }\n                }\n              },\n              destroy: function () {\n                this.widget.unbind(CHANGE, this._change);\n              }\n            })\n          },\n          gantt: {\n            dependencies: dataSourceBinding(\"dependencies\", \"dependencies\", \"setDependenciesDataSource\")\n          },\n          multiselect: {\n            value: Binder.extend({\n              init: function (widget, bindings, options) {\n                Binder.fn.init.call(this, widget.element[0], bindings, options);\n                this.widget = widget;\n                this._change = this.change.bind(this);\n                this.widget.first(CHANGE, this._change);\n                this._initChange = false;\n              },\n              change: function () {\n                var that = this,\n                    oldValues = that.bindings[VALUE].get(),\n                    valuePrimitive = that.options.valuePrimitive,\n                    newValues = valuePrimitive ? that.widget.value() : that.widget.dataItems();\n                var field = this.options.dataValueField || this.options.dataTextField;\n                newValues = newValues.slice(0);\n                that._initChange = true;\n\n                if (oldValues instanceof ObservableArray) {\n                  var remove = [];\n                  var newLength = newValues.length;\n                  var i = 0,\n                      j = 0;\n                  var old = oldValues[i];\n                  var same = false;\n                  var removeIndex;\n                  var newValue;\n                  var found;\n\n                  while (old !== undefined) {\n                    found = false;\n\n                    for (j = 0; j < newLength; j++) {\n                      if (valuePrimitive) {\n                        same = newValues[j] == old;\n                      } else {\n                        newValue = newValues[j];\n                        newValue = newValue.get ? newValue.get(field) : newValue;\n                        same = newValue == (old.get ? old.get(field) : old);\n                      }\n\n                      if (same) {\n                        newValues.splice(j, 1);\n                        newLength -= 1;\n                        found = true;\n                        break;\n                      }\n                    }\n\n                    if (!found) {\n                      remove.push(old);\n                      arraySplice(oldValues, i, 1);\n                      removeIndex = i;\n                    } else {\n                      i += 1;\n                    }\n\n                    old = oldValues[i];\n                  }\n\n                  arraySplice(oldValues, oldValues.length, 0, newValues);\n\n                  if (remove.length) {\n                    oldValues.trigger(\"change\", {\n                      action: \"remove\",\n                      items: remove,\n                      index: removeIndex\n                    });\n                  }\n\n                  if (newValues.length) {\n                    oldValues.trigger(\"change\", {\n                      action: \"add\",\n                      items: newValues,\n                      index: oldValues.length - 1\n                    });\n                  }\n                } else {\n                  that.bindings[VALUE].set(newValues);\n                }\n\n                that._initChange = false;\n              },\n              refresh: function () {\n                if (!this._initChange) {\n                  var options = this.options,\n                      widget = this.widget,\n                      field = options.dataValueField || options.dataTextField,\n                      value = this.bindings.value.get(),\n                      data = value,\n                      idx = 0,\n                      length,\n                      values = [],\n                      selectedValue;\n\n                  if (value === undefined) {\n                    value = null;\n                  }\n\n                  if (field) {\n                    if (value instanceof ObservableArray) {\n                      for (length = value.length; idx < length; idx++) {\n                        selectedValue = value[idx];\n                        values[idx] = selectedValue.get ? selectedValue.get(field) : selectedValue;\n                      }\n\n                      value = values;\n                    } else if (value instanceof ObservableObject) {\n                      value = value.get(field);\n                    }\n                  }\n\n                  if (options.autoBind === false && options.valuePrimitive !== true && !widget._isBound()) {\n                    widget._preselect(data, value);\n                  } else {\n                    widget.value(value);\n                  }\n                }\n              },\n              destroy: function () {\n                this.widget.unbind(CHANGE, this._change);\n              }\n            })\n          },\n          scheduler: {\n            source: dataSourceBinding(\"source\", \"dataSource\", \"setDataSource\").extend({\n              dataBound: function (e) {\n                var idx;\n                var length;\n                var widget = this.widget;\n                var elements = e.addedItems || widget.items();\n                var data, parents;\n\n                if (elements.length) {\n                  data = e.addedDataItems || widget.dataItems();\n                  parents = this.bindings.source._parents();\n\n                  for (idx = 0, length = data.length; idx < length; idx++) {\n                    bindElement(elements[idx], data[idx], this._ns(e.ns), [data[idx]].concat(parents));\n                  }\n                }\n              }\n            })\n          },\n          grid: {\n            source: dataSourceBinding(\"source\", \"dataSource\", \"setDataSource\").extend({\n              dataBound: function (e) {\n                var idx,\n                    length,\n                    widget = this.widget,\n                    elements = e.addedItems || widget.items(),\n                    parents,\n                    data;\n\n                if (elements.length) {\n                  data = e.addedDataItems || widget.dataItems();\n                  parents = this.bindings.source._parents();\n\n                  for (idx = 0, length = data.length; idx < length; idx++) {\n                    bindElement(elements[idx], data[idx], this._ns(e.ns), [data[idx]].concat(parents));\n                  }\n                }\n              }\n            })\n          },\n          badge: {\n            text: Binder.extend({\n              init: function (widget, bindings, options) {\n                Binder.fn.init.call(this, widget.element[0], bindings, options);\n                this.widget = widget;\n              },\n              refresh: function () {\n                var text = this.bindings.text.get();\n\n                if (text == null) {\n                  text = \"\";\n                }\n\n                this.widget.text(text);\n              }\n            })\n          }\n        };\n\n        var arraySplice = function (arr, idx, remove, add) {\n          add = add || [];\n          remove = remove || 0;\n          var addLength = add.length;\n          var oldLength = arr.length;\n          var shifted = [].slice.call(arr, idx + remove);\n          var shiftedLength = shifted.length;\n          var index;\n\n          if (addLength) {\n            addLength = idx + addLength;\n            index = 0;\n\n            for (; idx < addLength; idx++) {\n              arr[idx] = add[index];\n              index++;\n            }\n\n            arr.length = addLength;\n          } else if (remove) {\n            arr.length = idx;\n            remove += idx;\n\n            while (idx < remove) {\n              delete arr[--remove];\n            }\n          }\n\n          if (shiftedLength) {\n            shiftedLength = idx + shiftedLength;\n            index = 0;\n\n            for (; idx < shiftedLength; idx++) {\n              arr[idx] = shifted[index];\n              index++;\n            }\n\n            arr.length = shiftedLength;\n          }\n\n          idx = arr.length;\n\n          while (idx < oldLength) {\n            delete arr[idx];\n            idx++;\n          }\n        };\n\n        var BindingTarget = Class.extend({\n          init: function (target, options) {\n            this.target = target;\n            this.options = options;\n            this.toDestroy = [];\n          },\n          bind: function (bindings) {\n            var key,\n                hasValue,\n                hasSource,\n                hasEvents,\n                hasChecked,\n                hasCss,\n                widgetBinding = this instanceof WidgetBindingTarget,\n                specificBinders = this.binders();\n\n            for (key in bindings) {\n              if (key == VALUE) {\n                hasValue = true;\n              } else if (key == SOURCE) {\n                hasSource = true;\n              } else if (key == EVENTS && !widgetBinding) {\n                hasEvents = true;\n              } else if (key == CHECKED) {\n                hasChecked = true;\n              } else if (key == CSS) {\n                hasCss = true;\n              } else {\n                this.applyBinding(key, bindings, specificBinders);\n              }\n            }\n\n            if (hasSource) {\n              this.applyBinding(SOURCE, bindings, specificBinders);\n            }\n\n            if (hasValue) {\n              this.applyBinding(VALUE, bindings, specificBinders);\n            }\n\n            if (hasChecked) {\n              this.applyBinding(CHECKED, bindings, specificBinders);\n            }\n\n            if (hasEvents && !widgetBinding) {\n              this.applyBinding(EVENTS, bindings, specificBinders);\n            }\n\n            if (hasCss && !widgetBinding) {\n              this.applyBinding(CSS, bindings, specificBinders);\n            }\n\n            if (widgetBinding && this.target && this.target.floatingLabel) {\n              this.applyBinding(\"floatingLabel\", bindings, specificBinders);\n            }\n          },\n          binders: function () {\n            return binders[this.target.nodeName.toLowerCase()] || {};\n          },\n          applyBinding: function (name, bindings, specificBinders) {\n            var binder = specificBinders[name] || binders[name],\n                toDestroy = this.toDestroy,\n                attribute,\n                binding = bindings[name];\n\n            if (binder) {\n              binder = new binder(this.target, bindings, this.options);\n              toDestroy.push(binder);\n\n              if (binding instanceof Binding) {\n                binder.bind(binding);\n                toDestroy.push(binding);\n              } else {\n                for (attribute in binding) {\n                  binder.bind(binding, attribute);\n                  toDestroy.push(binding[attribute]);\n                }\n              }\n            } else if (name !== \"template\") {\n              throw new Error(\"The \" + name + \" binding is not supported by the \" + this.target.nodeName.toLowerCase() + \" element\");\n            }\n          },\n          destroy: function () {\n            var idx,\n                length,\n                toDestroy = this.toDestroy;\n\n            for (idx = 0, length = toDestroy.length; idx < length; idx++) {\n              toDestroy[idx].destroy();\n            }\n          }\n        });\n        var WidgetBindingTarget = BindingTarget.extend({\n          binders: function () {\n            return binders.widget[this.target.options.name.toLowerCase()] || {};\n          },\n          applyBinding: function (name, bindings, specificBinders) {\n            var binder = specificBinders[name] || binders.widget[name],\n                toDestroy = this.toDestroy,\n                attribute,\n                binding = bindings[name];\n\n            if (binder) {\n              binder = new binder(this.target, bindings, this.target.options);\n              toDestroy.push(binder);\n\n              if (binding instanceof Binding) {\n                binder.bind(binding);\n                toDestroy.push(binding);\n              } else {\n                for (attribute in binding) {\n                  binder.bind(binding, attribute);\n                  toDestroy.push(binding[attribute]);\n                }\n              }\n            } else {\n              throw new Error(\"The \" + name + \" binding is not supported by the \" + this.target.options.name + \" widget\");\n            }\n          }\n        });\n\n        function bindingTargetForRole(element, roles) {\n          var widget = kendo.initWidget(element, {}, roles);\n\n          if (widget) {\n            return new WidgetBindingTarget(widget);\n          }\n        }\n\n        var keyValueRegExp = /[A-Za-z0-9_\\-]+:(\\{([^}]*)\\}|[^,}]+)/g,\n            whiteSpaceRegExp = /\\s/g;\n\n        function parseBindings(bind) {\n          var result = {},\n              idx,\n              length,\n              token,\n              colonIndex,\n              key,\n              value,\n              tokens;\n          tokens = bind.match(keyValueRegExp);\n\n          for (idx = 0, length = tokens.length; idx < length; idx++) {\n            token = tokens[idx];\n            colonIndex = token.indexOf(\":\");\n            key = token.substring(0, colonIndex);\n            value = token.substring(colonIndex + 1);\n\n            if (value.charAt(0) == \"{\") {\n              value = parseBindings(value);\n            }\n\n            result[key] = value;\n          }\n\n          return result;\n        }\n\n        function createBindings(bindings, source, type) {\n          var binding,\n              result = {};\n\n          for (binding in bindings) {\n            result[binding] = new type(source, bindings[binding]);\n          }\n\n          return result;\n        }\n\n        function bindElement(element, source, roles, parents) {\n          if (!element || element.getAttribute(\"data-\" + kendo.ns + \"stop\")) {\n            return;\n          }\n\n          var role = element.getAttribute(\"data-\" + kendo.ns + \"role\"),\n              idx,\n              bind = element.getAttribute(\"data-\" + kendo.ns + \"bind\"),\n              childrenCopy = [],\n              deep = true,\n              bindings,\n              options = {},\n              target;\n          parents = parents || [source];\n\n          if (role || bind) {\n            unbindElement(element, false);\n          }\n\n          if (role) {\n            target = bindingTargetForRole(element, roles);\n          }\n\n          if (bind) {\n            bind = parseBindings(bind.replace(whiteSpaceRegExp, \"\"));\n\n            if (!target) {\n              options = kendo.parseOptions(element, {\n                textField: \"\",\n                valueField: \"\",\n                template: \"\",\n                valueUpdate: CHANGE,\n                valuePrimitive: false,\n                autoBind: true\n              }, source);\n              options.roles = roles;\n              target = new BindingTarget(element, options);\n            }\n\n            target.source = source;\n            bindings = createBindings(bind, parents, Binding);\n\n            if (options.template) {\n              bindings.template = new TemplateBinding(parents, \"\", options.template);\n            }\n\n            if (bindings.click) {\n              bind.events = bind.events || {};\n              bind.events.click = bind.click;\n              bindings.click.destroy();\n              delete bindings.click;\n            }\n\n            if (bindings.source) {\n              deep = false;\n            }\n\n            if (bind.attr) {\n              bindings.attr = createBindings(bind.attr, parents, Binding);\n            }\n\n            if (bind.style) {\n              bindings.style = createBindings(bind.style, parents, Binding);\n            }\n\n            if (bind.events) {\n              bindings.events = createBindings(bind.events, parents, EventBinding);\n            }\n\n            if (bind.css) {\n              bindings.css = createBindings(bind.css, parents, Binding);\n            }\n\n            target.bind(bindings);\n          }\n\n          if (target) {\n            element.kendoBindingTarget = target;\n          }\n\n          var children = element.children;\n\n          if (deep && children && !element.getAttribute(\"data-\" + kendo.ns + \"stop\")) {\n            // https://github.com/telerik/kendo/issues/1240 for the weirdness.\n            for (idx = 0; idx < children.length; idx++) {\n              childrenCopy[idx] = children[idx];\n            }\n\n            for (idx = 0; idx < childrenCopy.length; idx++) {\n              bindElement(childrenCopy[idx], source, roles, parents);\n            }\n          }\n        }\n\n        function bind(dom, object) {\n          var idx,\n              length,\n              node,\n              roles = kendo.rolesFromNamespaces([].slice.call(arguments, 2));\n          object = kendo.observable(object);\n          dom = $(dom);\n\n          for (idx = 0, length = dom.length; idx < length; idx++) {\n            node = dom[idx];\n\n            if (node.nodeType === 1) {\n              bindElement(node, object, roles);\n            }\n          }\n        }\n\n        function unbindElement(element, destroyWidget) {\n          var bindingTarget = element.kendoBindingTarget;\n\n          if (bindingTarget) {\n            bindingTarget.destroy();\n\n            if (deleteExpando) {\n              delete element.kendoBindingTarget;\n            } else if (element.removeAttribute) {\n              element.removeAttribute(\"kendoBindingTarget\");\n            } else {\n              element.kendoBindingTarget = null;\n            }\n          }\n\n          if (destroyWidget) {\n            var widget = kendo.widgetInstance($(element));\n\n            if (widget && typeof widget.destroy === FUNCTION) {\n              widget.destroy();\n            }\n          }\n        }\n\n        function unbindElementTree(element, destroyWidgets) {\n          unbindElement(element, destroyWidgets);\n          unbindElementChildren(element, destroyWidgets);\n        }\n\n        function unbindElementChildren(element, destroyWidgets) {\n          var children = element.children;\n\n          if (children) {\n            for (var idx = 0, length = children.length; idx < length; idx++) {\n              unbindElementTree(children[idx], destroyWidgets);\n            }\n          }\n        }\n\n        function unbind(dom) {\n          var idx, length;\n          dom = $(dom);\n\n          for (idx = 0, length = dom.length; idx < length; idx++) {\n            unbindElementTree(dom[idx], false);\n          }\n        }\n\n        function notify(widget, namespace) {\n          var element = widget.element,\n              bindingTarget = element[0].kendoBindingTarget;\n\n          if (bindingTarget) {\n            bind(element, bindingTarget.source, namespace);\n          }\n        }\n\n        function retrievePrimitiveValues(value, valueField) {\n          var values = [];\n          var idx = 0;\n          var length;\n          var item;\n\n          if (!valueField) {\n            return value;\n          }\n\n          if (value instanceof ObservableArray) {\n            for (length = value.length; idx < length; idx++) {\n              item = value[idx];\n              values[idx] = item.get ? item.get(valueField) : item[valueField];\n            }\n\n            value = values;\n          } else if (value instanceof ObservableObject) {\n            value = value.get(valueField);\n          }\n\n          return value;\n        }\n\n        kendo.unbind = unbind;\n        kendo.bind = bind;\n        kendo.data.binders = binders;\n        kendo.data.Binder = Binder;\n        kendo.notify = notify;\n\n        kendo.observable = function (object) {\n          if (!(object instanceof ObservableObject)) {\n            object = new ObservableObject(object);\n          }\n\n          return object;\n        };\n\n        kendo.observableHierarchy = function (array) {\n          var dataSource = kendo.data.HierarchicalDataSource.create(array);\n\n          function recursiveRead(data) {\n            var i, children;\n\n            for (i = 0; i < data.length; i++) {\n              data[i]._initChildren();\n\n              children = data[i].children;\n              children.fetch();\n              data[i].items = children.data();\n              recursiveRead(data[i].items);\n            }\n          }\n\n          dataSource.fetch();\n          recursiveRead(dataSource.data());\n          dataSource._data._dataSource = dataSource;\n          return dataSource._data;\n        };\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}