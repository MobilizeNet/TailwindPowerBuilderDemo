{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1671);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1671:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1672)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"pdfjs-processor\",\n        name: \"PDFJS-Processor\",\n        category: \"framework\",\n        depends: [\"core\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            atob = window.atob,\n            PDFJS;\n        var PDFJSProcessor = Class.extend({\n          init: function (options, viewer) {\n            var that = this;\n\n            if (kendo.pdfviewer.pdfjs.isLoaded()) {\n              PDFJS = kendo.pdfviewer.pdfjs.lib;\n            }\n\n            that.file = options.file;\n            that.viewer = viewer;\n          },\n          fetchDocument: function () {\n            var that = this,\n                deferred = $.Deferred(),\n                messages = that.viewer.options.messages.errorMessages;\n\n            if (!that.file) {\n              return deferred.resolve();\n            }\n\n            if (that._isBase64Data() && atob) {\n              that.file.data = atob(that.file.data);\n            }\n\n            PDFJS.getDocument(this.file).promise.then(function (pdf) {\n              var pageSizes = [];\n              that.pdf = pdf;\n              that.pagePromises = [];\n              that._downloadData = $.Deferred();\n              pdf.getData().then(function (data) {\n                var blob = new Blob([data], {\n                  type: 'application/pdf'\n                });\n\n                that._downloadData.resolve({\n                  file: blob\n                });\n              });\n\n              for (var i = 1; i <= pdf.numPages; i++) {\n                that.pagePromises.push(pdf.getPage(i));\n              }\n\n              Promise.all(that.pagePromises).then(function (pagePromises) {\n                pageSizes = pagePromises.map(function (pagePromise) {\n                  var viewport = pagePromise.getViewport({\n                    scale: 4 / 3\n                  });\n                  return {\n                    width: viewport.width,\n                    height: viewport.height\n                  };\n                });\n                deferred.resolve({\n                  total: pdf.numPages,\n                  pages: pageSizes\n                });\n              }).catch(function (e) {\n                // jshint ignore:line\n                that.viewer._triggerError({\n                  error: e.message,\n                  message: messages.parseError\n                });\n              });\n            }).catch(function (e) {\n              // jshint ignore:line\n              var notFoundError = e.name.includes(\"Missing\");\n              var alertMessage = notFoundError ? messages.notFound : messages.parseError;\n\n              that.viewer._triggerError({\n                error: e.message,\n                message: alertMessage\n              });\n\n              if (notFoundError) {\n                that.viewer._renderBlankPage();\n              }\n            });\n            return deferred;\n          },\n          fetchPageData: function (number) {\n            return this.pagePromises[number - 1];\n          },\n          downloadFile: function (fileName) {\n            var that = this;\n            kendo.ui.progress(that.viewer.pageContainer, true);\n\n            that._downloadData.done(function (result) {\n              kendo.ui.progress(that.viewer.pageContainer, false);\n              var reader = new FileReader();\n              reader.readAsDataURL(result.file);\n\n              reader.onload = function () {\n                kendo.saveAs({\n                  dataURI: reader.result,\n                  fileName: fileName + \".pdf\",\n                  proxyURL: function () {\n                    return reader.result;\n                  }\n                });\n              };\n            });\n          },\n          _updateDocument: function (file) {\n            if (this.pdf && this.pdf.loadingTask) {\n              this.pdf.loadingTask.destroy();\n            }\n\n            this.file = file;\n          },\n          _isBase64Data: function () {\n            var data = this.file.data,\n                notBase64 = /[^A-Z0-9+\\/=]/i,\n                length = data && data.length,\n                equalSign;\n\n            if (!length || length % 4 !== 0 || notBase64.test(data)) {\n              return false;\n            }\n\n            equalSign = data.indexOf('=');\n            return equalSign === -1 || equalSign === length - 1 || equalSign === length - 2 && data[length - 1] === '=';\n          },\n          renderTextLayer: function (params) {\n            PDFJS.renderTextLayer(params);\n          }\n        });\n        extend(kendo.pdfviewer.pdfjs, {\n          processor: PDFJSProcessor\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1672:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../pdfjs\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}