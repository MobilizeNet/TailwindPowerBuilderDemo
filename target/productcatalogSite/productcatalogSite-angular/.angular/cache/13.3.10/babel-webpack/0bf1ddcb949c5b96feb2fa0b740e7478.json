{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(970);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  970:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(971)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        var kendo = window.kendo,\n            map = $.map,\n            extend = $.extend,\n            browser = kendo.support.browser,\n            STYLE = \"style\",\n            FLOAT = \"float\",\n            CSSFLOAT = \"cssFloat\",\n            STYLEFLOAT = \"styleFloat\",\n            CLASS = \"class\",\n            KMARKER = \"k-marker\";\n\n        function makeMap(items) {\n          var obj = {},\n              i,\n              len;\n\n          for (i = 0, len = items.length; i < len; i++) {\n            obj[items[i]] = true;\n          }\n\n          return obj;\n        }\n\n        var empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\".split(\",\")),\n            nonListBlockElements = \"p,div,h1,h2,h3,h4,h5,h6,address,applet,blockquote,button,center,dd,dir,dl,dt,fieldset,form,frameset,hr,iframe,isindex,map,menu,noframes,noscript,object,pre,script,table,tbody,td,tfoot,th,thead,tr,header,article,nav,footer,section,aside,main,figure,figcaption\".split(\",\"),\n            blockElements = nonListBlockElements.concat([\"ul\", \"ol\", \"li\"]),\n            block = makeMap(blockElements),\n            selfClosing = makeMap(\"area,base,br,col,command,embed,hr,img,input,keygen,link,menuitem,meta,param,source,track,wbr\".split(\",\")),\n            inlineElements = \"span,em,a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,strike,strong,sub,sup,textarea,tt,u,var,data,time,mark,ruby\".split(\",\"),\n            inline = makeMap(inlineElements),\n            fillAttrs = makeMap(\"checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected\".split(\",\")),\n            nonEmptyNonTextContentElements = [\"hgroup\", \"ol\", \"ul\", \"dl\", \"object\", \"video\", \"audio\", \"table\", \"colgroup\", \"tbody\", \"thead\", \"tfoot\", \"tr\", \"select\", \"optgroup\"];\n\n        var normalize = function (node) {\n          if (node.nodeType == 1) {\n            node.normalize();\n          }\n        };\n\n        if (browser.msie && browser.version >= 8) {\n          normalize = function (parent) {\n            if (parent.nodeType == 1 && parent.firstChild) {\n              var prev = parent.firstChild,\n                  node = prev;\n              normalize(node);\n\n              while (true) {\n                node = node.nextSibling;\n\n                if (!node) {\n                  break;\n                }\n\n                normalize(node);\n\n                if (node.nodeType == 3 && prev.nodeType == 3) {\n                  node.nodeValue = prev.nodeValue + node.nodeValue;\n                  Dom.remove(prev);\n                }\n\n                prev = node;\n              }\n            }\n          };\n        }\n\n        var whitespace = /^\\s+$/,\n            emptyspace = /^[\\n\\r\\t]+$/,\n            rgb = /rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i,\n            bom = /\\ufeff/g,\n            whitespaceOrBom = /^(\\s+|\\ufeff)$/,\n            persistedScrollTop,\n            cssAttributes = (\"color,padding-left,padding-right,padding-top,padding-bottom,\" + \"background-color,background-attachment,background-image,background-position,background-repeat,\" + \"border-top-style,border-top-width,border-top-color,\" + \"border-bottom-style,border-bottom-width,border-bottom-color,\" + \"border-left-style,border-left-width,border-left-color,\" + \"border-right-style,border-right-width,border-right-color,\" + \"font-family,font-size,font-style,font-variant,font-weight,line-height\").split(\",\"),\n            htmlRe = /[<>\\&]/g,\n            entityRe = /[\\u00A0-\\u2666<>\\&]/g,\n            entityTable = {\n          34: 'quot',\n          38: 'amp',\n          39: 'apos',\n          60: 'lt',\n          62: 'gt',\n          160: 'nbsp',\n          161: 'iexcl',\n          162: 'cent',\n          163: 'pound',\n          164: 'curren',\n          165: 'yen',\n          166: 'brvbar',\n          167: 'sect',\n          168: 'uml',\n          169: 'copy',\n          170: 'ordf',\n          171: 'laquo',\n          172: 'not',\n          173: 'shy',\n          174: 'reg',\n          175: 'macr',\n          176: 'deg',\n          177: 'plusmn',\n          178: 'sup2',\n          179: 'sup3',\n          180: 'acute',\n          181: 'micro',\n          182: 'para',\n          183: 'middot',\n          184: 'cedil',\n          185: 'sup1',\n          186: 'ordm',\n          187: 'raquo',\n          188: 'frac14',\n          189: 'frac12',\n          190: 'frac34',\n          191: 'iquest',\n          192: 'Agrave',\n          193: 'Aacute',\n          194: 'Acirc',\n          195: 'Atilde',\n          196: 'Auml',\n          197: 'Aring',\n          198: 'AElig',\n          199: 'Ccedil',\n          200: 'Egrave',\n          201: 'Eacute',\n          202: 'Ecirc',\n          203: 'Euml',\n          204: 'Igrave',\n          205: 'Iacute',\n          206: 'Icirc',\n          207: 'Iuml',\n          208: 'ETH',\n          209: 'Ntilde',\n          210: 'Ograve',\n          211: 'Oacute',\n          212: 'Ocirc',\n          213: 'Otilde',\n          214: 'Ouml',\n          215: 'times',\n          216: 'Oslash',\n          217: 'Ugrave',\n          218: 'Uacute',\n          219: 'Ucirc',\n          220: 'Uuml',\n          221: 'Yacute',\n          222: 'THORN',\n          223: 'szlig',\n          224: 'agrave',\n          225: 'aacute',\n          226: 'acirc',\n          227: 'atilde',\n          228: 'auml',\n          229: 'aring',\n          230: 'aelig',\n          231: 'ccedil',\n          232: 'egrave',\n          233: 'eacute',\n          234: 'ecirc',\n          235: 'euml',\n          236: 'igrave',\n          237: 'iacute',\n          238: 'icirc',\n          239: 'iuml',\n          240: 'eth',\n          241: 'ntilde',\n          242: 'ograve',\n          243: 'oacute',\n          244: 'ocirc',\n          245: 'otilde',\n          246: 'ouml',\n          247: 'divide',\n          248: 'oslash',\n          249: 'ugrave',\n          250: 'uacute',\n          251: 'ucirc',\n          252: 'uuml',\n          253: 'yacute',\n          254: 'thorn',\n          255: 'yuml',\n          402: 'fnof',\n          913: 'Alpha',\n          914: 'Beta',\n          915: 'Gamma',\n          916: 'Delta',\n          917: 'Epsilon',\n          918: 'Zeta',\n          919: 'Eta',\n          920: 'Theta',\n          921: 'Iota',\n          922: 'Kappa',\n          923: 'Lambda',\n          924: 'Mu',\n          925: 'Nu',\n          926: 'Xi',\n          927: 'Omicron',\n          928: 'Pi',\n          929: 'Rho',\n          931: 'Sigma',\n          932: 'Tau',\n          933: 'Upsilon',\n          934: 'Phi',\n          935: 'Chi',\n          936: 'Psi',\n          937: 'Omega',\n          945: 'alpha',\n          946: 'beta',\n          947: 'gamma',\n          948: 'delta',\n          949: 'epsilon',\n          950: 'zeta',\n          951: 'eta',\n          952: 'theta',\n          953: 'iota',\n          954: 'kappa',\n          955: 'lambda',\n          956: 'mu',\n          957: 'nu',\n          958: 'xi',\n          959: 'omicron',\n          960: 'pi',\n          961: 'rho',\n          962: 'sigmaf',\n          963: 'sigma',\n          964: 'tau',\n          965: 'upsilon',\n          966: 'phi',\n          967: 'chi',\n          968: 'psi',\n          969: 'omega',\n          977: 'thetasym',\n          978: 'upsih',\n          982: 'piv',\n          8226: 'bull',\n          8230: 'hellip',\n          8242: 'prime',\n          8243: 'Prime',\n          8254: 'oline',\n          8260: 'frasl',\n          8472: 'weierp',\n          8465: 'image',\n          8476: 'real',\n          8482: 'trade',\n          8501: 'alefsym',\n          8592: 'larr',\n          8593: 'uarr',\n          8594: 'rarr',\n          8595: 'darr',\n          8596: 'harr',\n          8629: 'crarr',\n          8656: 'lArr',\n          8657: 'uArr',\n          8658: 'rArr',\n          8659: 'dArr',\n          8660: 'hArr',\n          8704: 'forall',\n          8706: 'part',\n          8707: 'exist',\n          8709: 'empty',\n          8711: 'nabla',\n          8712: 'isin',\n          8713: 'notin',\n          8715: 'ni',\n          8719: 'prod',\n          8721: 'sum',\n          8722: 'minus',\n          8727: 'lowast',\n          8730: 'radic',\n          8733: 'prop',\n          8734: 'infin',\n          8736: 'ang',\n          8743: 'and',\n          8744: 'or',\n          8745: 'cap',\n          8746: 'cup',\n          8747: 'int',\n          8756: 'there4',\n          8764: 'sim',\n          8773: 'cong',\n          8776: 'asymp',\n          8800: 'ne',\n          8801: 'equiv',\n          8804: 'le',\n          8805: 'ge',\n          8834: 'sub',\n          8835: 'sup',\n          8836: 'nsub',\n          8838: 'sube',\n          8839: 'supe',\n          8853: 'oplus',\n          8855: 'otimes',\n          8869: 'perp',\n          8901: 'sdot',\n          8968: 'lceil',\n          8969: 'rceil',\n          8970: 'lfloor',\n          8971: 'rfloor',\n          9001: 'lang',\n          9002: 'rang',\n          9674: 'loz',\n          9824: 'spades',\n          9827: 'clubs',\n          9829: 'hearts',\n          9830: 'diams',\n          338: 'OElig',\n          339: 'oelig',\n          352: 'Scaron',\n          353: 'scaron',\n          376: 'Yuml',\n          710: 'circ',\n          732: 'tilde',\n          8194: 'ensp',\n          8195: 'emsp',\n          8201: 'thinsp',\n          8204: 'zwnj',\n          8205: 'zwj',\n          8206: 'lrm',\n          8207: 'rlm',\n          8211: 'ndash',\n          8212: 'mdash',\n          8216: 'lsquo',\n          8217: 'rsquo',\n          8218: 'sbquo',\n          8220: 'ldquo',\n          8221: 'rdquo',\n          8222: 'bdquo',\n          8224: 'dagger',\n          8225: 'Dagger',\n          8240: 'permil',\n          8249: 'lsaquo',\n          8250: 'rsaquo',\n          8364: 'euro'\n        };\n        var Dom = {\n          block: block,\n          inline: inline,\n          findNodeIndex: function (node, skipText) {\n            var i = 0;\n\n            if (!node) {\n              return -1;\n            }\n\n            while (true) {\n              node = node.previousSibling;\n\n              if (!node) {\n                break;\n              }\n\n              if (!(skipText && node.nodeType == 3)) {\n                i++;\n              }\n            }\n\n            return i;\n          },\n          isDataNode: function (node) {\n            return node && node.nodeValue !== null && node.data !== null;\n          },\n          isAncestorOf: function (parent, node) {\n            try {\n              return !Dom.isDataNode(parent) && ($.contains(parent, Dom.isDataNode(node) ? node.parentNode : node) || node.parentNode == parent);\n            } catch (e) {\n              return false;\n            }\n          },\n          isAncestorOrSelf: function (root, node) {\n            return Dom.isAncestorOf(root, node) || root == node;\n          },\n          findClosestAncestor: function (root, node) {\n            if (Dom.isAncestorOf(root, node)) {\n              while (node && node.parentNode != root) {\n                node = node.parentNode;\n              }\n            }\n\n            return node;\n          },\n          getAllComments: function (rootElem) {\n            var comments = []; // Fourth argument, which is actually obsolete according to the DOM4 standard, is required in IE 11\n\n            var iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, function () {\n              return NodeFilter.FILTER_ACCEPT;\n            }, false);\n            var curNode = iterator.nextNode();\n\n            while (curNode) {\n              comments.push(curNode.nodeValue);\n              curNode = iterator.nextNode();\n            }\n\n            return comments;\n          },\n          getNodeLength: function (node) {\n            return Dom.isDataNode(node) ? node.length : node.childNodes.length;\n          },\n          splitDataNode: function (node, offset) {\n            var newNode = node.cloneNode(false);\n            var denormalizedText = \"\";\n            var iterator = node.nextSibling;\n            var temp;\n\n            while (iterator && iterator.nodeType == 3 && iterator.nodeValue) {\n              denormalizedText += iterator.nodeValue;\n              temp = iterator;\n              iterator = iterator.nextSibling;\n              Dom.remove(temp);\n            }\n\n            node.deleteData(offset, node.length);\n            newNode.deleteData(0, offset);\n            newNode.nodeValue += denormalizedText;\n            Dom.insertAfter(newNode, node);\n          },\n          attrEquals: function (node, attributes) {\n            for (var key in attributes) {\n              var value = node[key];\n\n              if (key == FLOAT) {\n                value = node[kendo.support.cssFloat ? CSSFLOAT : STYLEFLOAT];\n              }\n\n              if (typeof value == \"object\") {\n                if (!Dom.attrEquals(value, attributes[key])) {\n                  return false;\n                }\n              } else if (value != attributes[key]) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          blockParentOrBody: function (node) {\n            return Dom.parentOfType(node, blockElements) || node.ownerDocument.body;\n          },\n          blockParents: function (nodes) {\n            var blocks = [],\n                i,\n                len;\n\n            for (i = 0, len = nodes.length; i < len; i++) {\n              var block = Dom.parentOfType(nodes[i], Dom.blockElements);\n\n              if (block && $.inArray(block, blocks) < 0) {\n                blocks.push(block);\n              }\n            }\n\n            return blocks;\n          },\n          windowFromDocument: function (document) {\n            return document.defaultView || document.parentWindow;\n          },\n          normalize: normalize,\n          blockElements: blockElements,\n          nonListBlockElements: nonListBlockElements,\n          inlineElements: inlineElements,\n          empty: empty,\n          fillAttrs: fillAttrs,\n          nodeTypes: {\n            ELEMENT_NODE: 1,\n            ATTRIBUTE_NODE: 2,\n            TEXT_NODE: 3,\n            CDATA_SECTION_NODE: 4,\n            ENTITY_REFERENCE_NODE: 5,\n            ENTITY_NODE: 6,\n            PROCESSING_INSTRUCTION_NODE: 7,\n            COMMENT_NODE: 8,\n            DOCUMENT_NODE: 9,\n            DOCUMENT_TYPE_NODE: 10,\n            DOCUMENT_FRAGMENT_NODE: 11,\n            NOTATION_NODE: 12\n          },\n          toHex: function (color) {\n            var matches = rgb.exec(color);\n\n            if (!matches) {\n              return color;\n            }\n\n            return \"#\" + map(matches.slice(1), function (x) {\n              x = parseInt(x, 10).toString(16);\n              return x.length > 1 ? x : \"0\" + x;\n            }).join(\"\");\n          },\n          encode: function (value, options) {\n            var encodableChars = !options || options.entities ? entityRe : htmlRe;\n            return value.replace(encodableChars, function (c) {\n              var charCode = c.charCodeAt(0);\n              var entity = entityTable[charCode];\n              return entity ? '&' + entity + ';' : c;\n            });\n          },\n          isBom: function (node) {\n            return node && node.nodeType === 3 && /^[\\ufeff]+$/.test(node.nodeValue);\n          },\n          stripBom: function (text) {\n            return (text || \"\").replace(bom, \"\");\n          },\n          stripBomNode: function (node) {\n            if (Dom.isBom(node)) {\n              node.parentNode.removeChild(node);\n            }\n          },\n          insignificant: function (node) {\n            var attr = node.attributes;\n            return node.className == \"k-marker\" || Dom.is(node, 'br') && (node.className == \"k-br\" || attr._moz_dirty || attr._moz_editor_bogus_node) || Dom.is(node, 'span') && node.className == \"k-br\";\n          },\n          tableCell: function (node) {\n            return Dom.is(node, \"td\") || Dom.is(node, \"th\");\n          },\n          significantNodes: function (nodes) {\n            return $.grep(nodes, function (child) {\n              var name = Dom.name(child);\n\n              if (name == 'br') {\n                return false;\n              } else if (Dom.insignificant(child)) {\n                return false;\n              } else if (Dom.emptyTextNode(child)) {\n                return false;\n              } else if (child.nodeType == 1 && !empty[name] && Dom.emptyNode(child)) {\n                return false;\n              }\n\n              return true;\n            });\n          },\n          emptyTextNode: function (node) {\n            return node && node.nodeType == 3 && whitespaceOrBom.test(node.nodeValue);\n          },\n          emptyNode: function (node) {\n            return node.nodeType == 1 && !Dom.significantNodes(node.childNodes).length;\n          },\n          name: function (node) {\n            return node.nodeName.toLowerCase();\n          },\n          significantChildNodes: function (node) {\n            return $.grep(node.childNodes, function (child) {\n              return child.nodeType != 3 || !Dom.isWhitespace(child);\n            });\n          },\n          lastTextNode: function (node) {\n            var result = null;\n\n            if (node.nodeType == 3) {\n              return node;\n            }\n\n            for (var child = node.lastChild; child; child = child.previousSibling) {\n              result = Dom.lastTextNode(child);\n\n              if (result) {\n                return result;\n              }\n            }\n\n            return result;\n          },\n          is: function (node, nodeName) {\n            return node && Dom.name(node) == nodeName;\n          },\n          isMarker: function (node) {\n            return node.className == KMARKER;\n          },\n          isWhitespace: function (node) {\n            return whitespace.test(node.nodeValue);\n          },\n          allowsTextContent: function (node) {\n            var result = true;\n            nonEmptyNonTextContentElements.every(function (name) {\n              if (Dom.is(node, name)) {\n                result = false;\n                return false;\n              } else {\n                return true;\n              }\n            });\n            return result;\n          },\n          allWhitespaceContent: function (node) {\n            var child = node.firstChild;\n\n            while (child && Dom.isWhitespace(child)) {\n              child = child.nextSibling;\n            }\n\n            return !child;\n          },\n          isEmptyspace: function (node) {\n            return emptyspace.test(node.nodeValue);\n          },\n          htmlIndentSpace: function (node) {\n            if (!(Dom.isDataNode(node) && Dom.isWhitespace(node))) {\n              return false;\n            }\n\n            if (emptyspace.test(node.nodeValue)) {\n              return true;\n            }\n\n            var sibling = function (el, direction) {\n              while (el[direction]) {\n                el = el[direction];\n\n                if (Dom.significantNodes([el]).length > 0) {\n                  return el;\n                }\n              }\n            };\n\n            var parent = node.parentNode;\n            var prev = sibling(node, \"previousSibling\");\n            var next = sibling(node, \"nextSibling\");\n\n            if (bom.test(node.nodeValue)) {\n              return !!(prev || next);\n            }\n\n            if ($(parent).is(\"tr,tbody,thead,tfoot,table,ol,ul\")) {\n              return true;\n            }\n\n            if (Dom.isBlock(parent) || Dom.is(parent, \"body\")) {\n              var isPrevBlock = prev && Dom.isBlock(prev);\n              var isNextBlock = next && Dom.isBlock(next);\n\n              if (!next && isPrevBlock || !prev && isNextBlock || isPrevBlock && isNextBlock) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          isBlock: function (node) {\n            return block[Dom.name(node)];\n          },\n          isSelfClosing: function (node) {\n            return selfClosing[Dom.name(node)];\n          },\n          isEmpty: function (node) {\n            return empty[Dom.name(node)];\n          },\n          isInline: function (node) {\n            return inline[Dom.name(node)];\n          },\n          isBr: function (node) {\n            return Dom.name(node) == \"br\";\n          },\n          list: function (node) {\n            var name = node ? Dom.name(node) : \"\";\n            return name == \"ul\" || name == \"ol\" || name == \"dl\";\n          },\n          scrollContainer: function (doc) {\n            var wnd = Dom.windowFromDocument(doc),\n                scrollContainer = (wnd.contentWindow || wnd).document || wnd.ownerDocument || wnd;\n\n            if (scrollContainer.compatMode == 'BackCompat') {\n              scrollContainer = scrollContainer.body;\n            } else {\n              scrollContainer = scrollContainer.scrollingElement || scrollContainer.documentElement;\n            }\n\n            return scrollContainer;\n          },\n          scrollTo: function (node, toStart) {\n            var doc = node.ownerDocument;\n            var wnd = Dom.windowFromDocument(doc);\n            var windowHeight = wnd.innerHeight;\n            var scrollContainer = Dom.scrollContainer(doc);\n            var element, elementTop, elementHeight, marker;\n\n            if (Dom.isDataNode(node)) {\n              if (toStart) {\n                marker = Dom.create(doc, \"span\", {\n                  \"innerHTML\": \"&#xfeff;\"\n                });\n                Dom.insertBefore(marker, node);\n                element = $(marker);\n              } else {\n                element = $(node.parentNode);\n              }\n            } else {\n              element = $(node);\n            }\n\n            elementTop = element.offset().top;\n            elementHeight = element[0].offsetHeight;\n\n            if (toStart || !elementHeight) {\n              elementHeight = parseInt(element.css(\"line-height\"), 10) || Math.ceil(1.2 * parseInt(element.css(\"font-size\"), 10)) || 15;\n            }\n\n            if (marker) {\n              Dom.remove(marker);\n            }\n\n            if (elementHeight + elementTop > scrollContainer.scrollTop + windowHeight) {\n              scrollContainer.scrollTop = elementHeight + elementTop - windowHeight;\n            }\n          },\n          persistScrollTop: function (doc) {\n            persistedScrollTop = Dom.scrollContainer(doc).scrollTop;\n          },\n          offset: function (target, offsetParent) {\n            var result = {\n              top: target.offsetTop,\n              left: target.offsetLeft\n            };\n            var parent = target.offsetParent;\n\n            while (parent && (!offsetParent || Dom.isAncestorOf(offsetParent, parent))) {\n              result.top += parent.offsetTop;\n              result.left += parent.offsetLeft;\n              parent = parent.offsetParent;\n            }\n\n            return result;\n          },\n          restoreScrollTop: function (doc) {\n            if (typeof persistedScrollTop == \"number\") {\n              Dom.scrollContainer(doc).scrollTop = persistedScrollTop;\n              persistedScrollTop = undefined;\n            }\n          },\n          insertAt: function (parent, newElement, position) {\n            parent.insertBefore(newElement, parent.childNodes[position] || null);\n          },\n          insertBefore: function (newElement, referenceElement) {\n            if (referenceElement.parentNode) {\n              return referenceElement.parentNode.insertBefore(newElement, referenceElement);\n            } else {\n              return referenceElement;\n            }\n          },\n          insertAfter: function (newElement, referenceElement) {\n            return referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);\n          },\n          remove: function (node) {\n            if (node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          },\n          removeChildren: function (node) {\n            while (node.firstChild) {\n              node.removeChild(node.firstChild);\n            }\n          },\n          removeTextSiblings: function (node) {\n            var parentNode = node.parentNode;\n\n            while (node.nextSibling && node.nextSibling.nodeType == 3) {\n              parentNode.removeChild(node.nextSibling);\n            }\n\n            while (node.previousSibling && node.previousSibling.nodeType == 3) {\n              parentNode.removeChild(node.previousSibling);\n            }\n          },\n          trim: function (parent) {\n            for (var i = parent.childNodes.length - 1; i >= 0; i--) {\n              var node = parent.childNodes[i];\n\n              if (Dom.isDataNode(node)) {\n                if (!Dom.stripBom(node.nodeValue).length) {\n                  Dom.remove(node);\n                }\n              } else if (node.className != KMARKER) {\n                Dom.trim(node);\n\n                if (!Dom.isEmpty(node) && node.childNodes.length === 0 || Dom.isBlock(node) && Dom.allWhitespaceContent(node)) {\n                  Dom.remove(node);\n                }\n              }\n            }\n\n            return parent;\n          },\n          closest: function (node, tags) {\n            if (typeof tags === \"string\") {\n              tags = [tags];\n            }\n\n            while (node && tags.indexOf(Dom.name(node)) < 0) {\n              node = node.parentNode;\n            }\n\n            return node;\n          },\n          closestBy: function (node, condition, rootCondition) {\n            while (node && !condition(node)) {\n              if (rootCondition && rootCondition(node)) {\n                return null;\n              }\n\n              node = node.parentNode;\n            }\n\n            return node;\n          },\n          sibling: function (node, direction) {\n            do {\n              node = node[direction];\n            } while (node && node.nodeType != 1);\n\n            return node;\n          },\n          next: function (node) {\n            return Dom.sibling(node, \"nextSibling\");\n          },\n          prev: function (node) {\n            return Dom.sibling(node, \"previousSibling\");\n          },\n          parentOfType: function (node, tags) {\n            do {\n              node = node.parentNode;\n            } while (node && !Dom.ofType(node, tags));\n\n            return node;\n          },\n          ofType: function (node, tags) {\n            return $.inArray(Dom.name(node), tags) >= 0;\n          },\n          changeTag: function (referenceElement, tagName, skipAttributes) {\n            var newElement = Dom.create(referenceElement.ownerDocument, tagName),\n                attributes = referenceElement.attributes,\n                i,\n                len,\n                name,\n                value,\n                attribute;\n\n            if (!skipAttributes) {\n              for (i = 0, len = attributes.length; i < len; i++) {\n                attribute = attributes[i];\n\n                if (attribute.specified) {\n                  // IE < 8 cannot set class or style via setAttribute\n                  name = attribute.nodeName;\n                  value = attribute.nodeValue;\n\n                  if (name == CLASS) {\n                    newElement.className = value;\n                  } else if (name == STYLE) {\n                    newElement.style.cssText = referenceElement.style.cssText;\n                  } else {\n                    newElement.setAttribute(name, value);\n                  }\n                }\n              }\n            }\n\n            while (referenceElement.firstChild) {\n              newElement.appendChild(referenceElement.firstChild);\n            }\n\n            Dom.insertBefore(newElement, referenceElement);\n            Dom.remove(referenceElement);\n            return newElement;\n          },\n          editableParent: function (node) {\n            while (node && (node.nodeType == 3 || node.contentEditable !== 'true')) {\n              node = node.parentNode;\n            }\n\n            return node;\n          },\n          wrap: function (node, wrapper) {\n            Dom.insertBefore(wrapper, node);\n            wrapper.appendChild(node);\n            return wrapper;\n          },\n          unwrap: function (node) {\n            var parent = node.parentNode;\n\n            while (node.firstChild) {\n              parent.insertBefore(node.firstChild, node);\n            }\n\n            parent.removeChild(node);\n          },\n          wrapper: function (node) {\n            var wrapper = Dom.closestBy(node, function (el) {\n              return el.parentNode && Dom.significantNodes(el.parentNode.childNodes).length > 1;\n            });\n            return $(wrapper).is(\"body,.k-editor\") ? undefined : wrapper;\n          },\n          create: function (document, tagName, attributes) {\n            return Dom.attr(document.createElement(tagName), attributes);\n          },\n          createEmptyNode: function (document, tagName, attributes) {\n            var node = Dom.attr(document.createElement(tagName), attributes);\n            node.innerHTML = \"\\ufeff\";\n            return node;\n          },\n          attr: function (element, attributes) {\n            attributes = extend({}, attributes);\n\n            if (attributes && STYLE in attributes) {\n              Dom.style(element, attributes.style);\n              delete attributes.style;\n            }\n\n            for (var attr in attributes) {\n              if (attributes[attr] === null) {\n                element.removeAttribute(attr);\n                delete attributes[attr];\n              } else if (attr == \"className\") {\n                element[attr] = attributes[attr];\n              }\n            }\n\n            return extend(element, attributes);\n          },\n          mergeAttributes: function (origin, target, traverseCss) {\n            if (!origin.attributes.length) {\n              return;\n            }\n\n            $.each(origin.attributes, function () {\n              if (this.name !== \"contenteditable\" && (!traverseCss || this.name !== STYLE)) {\n                $(target).attr(this.name, this.value);\n              }\n\n              if (traverseCss && this.name === STYLE) {\n                $.each(origin.style, function () {\n                  target.style[this] = origin.style[this];\n                });\n              }\n            });\n          },\n          style: function (node, value) {\n            $(node).css(value || {});\n          },\n          unstyle: function (node, value) {\n            for (var key in value) {\n              if (key == FLOAT) {\n                key = kendo.support.cssFloat ? CSSFLOAT : STYLEFLOAT;\n              }\n\n              node.style[key] = \"\";\n            }\n\n            if (node.style.cssText === \"\") {\n              node.removeAttribute(STYLE);\n            }\n          },\n          inlineStyle: function (body, name, attributes) {\n            var span = $(Dom.create(body.ownerDocument, name, attributes)),\n                style;\n            body.appendChild(span[0]);\n            style = map(cssAttributes, function (value) {\n              if (browser.msie && value == \"line-height\" && span.css(value) == \"1px\") {\n                return \"line-height:1.5\";\n              } else {\n                return value + \":\" + span.css(value);\n              }\n            }).join(\";\");\n            span.remove();\n            return style;\n          },\n          getEffectiveBackground: function (element) {\n            var backgroundStyle = element.css(\"background-color\") || \"\";\n\n            if (backgroundStyle.indexOf(\"rgba(0, 0, 0, 0\") < 0 && backgroundStyle !== \"transparent\") {\n              return backgroundStyle;\n            } else if (element[0].tagName.toLowerCase() === \"html\") {\n              return \"Window\";\n            } else {\n              return Dom.getEffectiveBackground(element.parent());\n            }\n          },\n          innerText: function (node) {\n            var text = node.innerHTML;\n            text = text.replace(/<!--(.|\\s)*?-->/gi, \"\");\n            text = text.replace(/<\\/?[^>]+?\\/?>/gm, \"\");\n            return text;\n          },\n          removeClass: function (node, classNames) {\n            var className = \" \" + node.className + \" \",\n                classes = classNames.split(\" \"),\n                i,\n                len;\n\n            for (i = 0, len = classes.length; i < len; i++) {\n              className = className.replace(\" \" + classes[i] + \" \", \" \");\n            }\n\n            className = kendo.trim(className);\n\n            if (className.length) {\n              node.className = className;\n            } else {\n              node.removeAttribute(CLASS);\n            }\n          },\n          commonAncestor: function () {\n            var count = arguments.length,\n                paths = [],\n                minPathLength = Infinity,\n                output = null,\n                i,\n                ancestors,\n                node,\n                first,\n                j;\n\n            if (!count) {\n              return null;\n            }\n\n            if (count == 1) {\n              return arguments[0];\n            }\n\n            for (i = 0; i < count; i++) {\n              ancestors = [];\n              node = arguments[i];\n\n              while (node) {\n                ancestors.push(node);\n                node = node.parentNode;\n              }\n\n              paths.push(ancestors.reverse());\n              minPathLength = Math.min(minPathLength, ancestors.length);\n            }\n\n            if (count == 1) {\n              return paths[0][0];\n            }\n\n            for (i = 0; i < minPathLength; i++) {\n              first = paths[0][i];\n\n              for (j = 1; j < count; j++) {\n                if (first != paths[j][i]) {\n                  return output;\n                }\n              }\n\n              output = first;\n            }\n\n            return output;\n          },\n          closestSplittableParent: function (nodes) {\n            var result;\n\n            if (nodes.length == 1) {\n              result = Dom.parentOfType(nodes[0], [\"ul\", \"ol\"]);\n            } else {\n              result = Dom.commonAncestor.apply(null, nodes);\n            }\n\n            if (!result) {\n              result = Dom.parentOfType(nodes[0], [\"p\", \"td\"]) || nodes[0].ownerDocument.body;\n            }\n\n            if (Dom.isInline(result)) {\n              result = Dom.blockParentOrBody(result);\n            }\n\n            var editableParents = map(nodes, Dom.editableParent);\n            var editableAncestor = Dom.commonAncestor(editableParents)[0];\n\n            if ($.contains(result, editableAncestor)) {\n              result = editableAncestor;\n            }\n\n            return result;\n          },\n          closestEditable: function (node, types) {\n            var closest;\n            var editable = Dom.editableParent(node);\n\n            if (Dom.ofType(node, types)) {\n              closest = node;\n            } else {\n              closest = Dom.parentOfType(node, types);\n            }\n\n            if (closest && editable && $.contains(closest, editable)) {\n              closest = editable;\n            } else if (!closest && editable) {\n              closest = editable;\n            }\n\n            return closest;\n          },\n          closestEditableOfType: function (node, types) {\n            var editable = Dom.closestEditable(node, types);\n\n            if (editable && Dom.ofType(editable, types) && !$(editable).is(\".k-editor\")) {\n              return editable;\n            }\n          },\n          filter: function (tagName, nodes, invert) {\n            var filterFn = function (node) {\n              return Dom.name(node) == tagName;\n            };\n\n            return Dom.filterBy(nodes, filterFn, invert);\n          },\n          filterBy: function (nodes, condition, invert) {\n            var i = 0;\n            var len = nodes.length;\n            var result = [];\n            var match;\n\n            for (; i < len; i++) {\n              match = condition(nodes[i]);\n\n              if (match && !invert || !match && invert) {\n                result.push(nodes[i]);\n              }\n            }\n\n            return result;\n          },\n          ensureTrailingBreaks: function (node) {\n            var elements = $(node).find(\"p,td,th\");\n            var length = elements.length;\n            var i = 0;\n\n            if (length) {\n              for (; i < length; i++) {\n                Dom.ensureTrailingBreak(elements[i]);\n              }\n            } else {\n              Dom.ensureTrailingBreak(node);\n            }\n          },\n          removeTrailingBreak: function (node) {\n            $(node).find(\"br[type=_moz],.k-br\").remove();\n          },\n          ensureTrailingBreak: function (node) {\n            Dom.removeTrailingBreak(node);\n            var lastChild = node.lastChild;\n            var name = lastChild && Dom.name(lastChild);\n            var br;\n\n            if (!name || name != \"br\" && name != \"img\" || name == \"br\" && lastChild.className != \"k-br\") {\n              br = node.ownerDocument.createElement(\"br\");\n              br.className = \"k-br\";\n              node.appendChild(br);\n            }\n          },\n          // Start: Table Utilities\n          reMapTableColumns: function (table, colAttr) {\n            Dom._mapColIndices(table, colAttr);\n          },\n          clearTableMappings: function (table, colAttr) {\n            $(table).find(\"[\" + colAttr + \"]\").removeAttr(colAttr);\n          },\n          _mapColIndices: function (table, colAttr) {\n            var registeredColumns = {};\n\n            for (var rowIndex = 0; rowIndex < table.rows.length; rowIndex++) {\n              var cells = table.rows[rowIndex].cells;\n              var colIndex = 0;\n\n              for (var cellIndex = 0; cellIndex < cells.length; cellIndex++, colIndex++) {\n                var cell = cells[cellIndex];\n\n                if (cell.rowSpan > 1) {\n                  this._mapColspan(cell, rowIndex, colIndex, registeredColumns);\n                }\n\n                if (registeredColumns[rowIndex]) {\n                  while (registeredColumns[rowIndex][colIndex]) {\n                    colIndex++;\n                  }\n                }\n\n                cell.setAttribute(colAttr, colIndex);\n\n                if (cell.colSpan > 1) {\n                  colIndex = colIndex + cell.colSpan - 1;\n                }\n              }\n            }\n          },\n          _mapColspan: function (cell, rowIndex, colIndex, registeredColumns) {\n            var rowSpan = cell.rowSpan,\n                colSpan = cell.colSpan,\n                index;\n\n            for (var ci = 0; ci < colSpan; ci++) {\n              index = colIndex + ci;\n\n              for (var ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {\n                if (!registeredColumns[ri]) {\n                  registeredColumns[ri] = {};\n                  registeredColumns[ri].length = 0;\n                }\n\n                if (registeredColumns[rowIndex]) {\n                  while (registeredColumns[rowIndex][index]) {\n                    index++;\n                  }\n                }\n\n                registeredColumns[ri][index] = true;\n                registeredColumns[ri].length++;\n              }\n            }\n          },\n          associateWithIds: function (table) {\n            var that = this;\n            var numberOfTheadRows = 0;\n            var tableRows = table.rows;\n            var numberOfTableRows = tableRows.length;\n            var theadMatrix = [];\n            var tbodyMatrix = [];\n            var theadRows, i;\n\n            if (table.tHead) {\n              theadRows = table.tHead.rows;\n              numberOfTheadRows = theadRows.length;\n            } else {\n              numberOfTheadRows = that._getNumberOfHeaderRows(table);\n              theadRows = [];\n\n              for (i = 0; i < numberOfTheadRows; i++) {\n                theadRows.push(tableRows[i]);\n              }\n            }\n\n            for (i = 0; i < numberOfTheadRows; i++) {\n              theadMatrix.push([]);\n            }\n\n            for (i = 0; i < numberOfTableRows; i++) {\n              tbodyMatrix.push([]);\n            }\n\n            that._generateIdsForColumns(theadMatrix, theadRows);\n\n            that._generateIdsForRows(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows);\n\n            that._assignIds(theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows);\n          },\n          _generateIdsForColumns: function (theadMatrix, theadRows) {\n            var timestamp = new Date().getTime();\n            var numberOfTheadRows = theadRows ? theadRows.length : 0;\n            var row, cells, cell, col, id, colspan, rowspan, i, j, k, l;\n\n            for (i = 0; i < numberOfTheadRows; i++) {\n              row = theadRows[i];\n              cells = row.cells;\n              col = 0;\n\n              for (j = 0; j < cells.length; j++) {\n                cell = cells[j];\n                id = \"table\" + i + j + ++timestamp;\n                cell.setAttribute(\"id\", id);\n                colspan = cell.getAttribute(\"colspan\") || 1;\n                rowspan = cell.getAttribute(\"rowspan\") || 1;\n\n                while (theadMatrix[i][j + col]) {\n                  col += 1;\n                }\n\n                for (k = 0; k < rowspan; k++) {\n                  for (l = 0; l < colspan; l++) {\n                    theadMatrix[i + k][j + col + l] = id;\n                  }\n                }\n              }\n            }\n          },\n          _generateIdsForRows: function (theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows) {\n            var that = this;\n            var timestamp = new Date().getTime();\n            var numberOfTableRows = tableRows.length;\n            var row, cells, cell, col, id, colspan, rowspan, i, j, k, l, colIndex, headers;\n\n            var pushHeaderId = function (row) {\n              headers.push(row[colIndex]);\n            };\n\n            for (i = numberOfTheadRows; i < numberOfTableRows; i++) {\n              row = tableRows[i];\n              cells = $(row.cells).filter(\"th\");\n              col = 0;\n\n              for (j = 0; j < cells.length; j++) {\n                cell = cells[j];\n                id = \"table\" + i + j + ++timestamp;\n                cell.setAttribute(\"id\", id);\n                colspan = cell.getAttribute(\"colspan\") || 1;\n                rowspan = cell.getAttribute(\"rowspan\") || 1;\n\n                while (tbodyMatrix[i][j + col]) {\n                  col += 1;\n                }\n\n                for (k = 0; k < rowspan; k++) {\n                  for (l = 0; l < colspan; l++) {\n                    tbodyMatrix[i + k][j + col + l] = id;\n                  }\n                }\n\n                colIndex = cell.getAttribute(\"col-index\");\n                headers = [];\n                theadMatrix.forEach(pushHeaderId);\n                headers = headers.filter(that._onlyUnique);\n                cell.setAttribute(\"headers\", headers.join(\" \").trim());\n              }\n            }\n          },\n          _assignIds: function (theadMatrix, tbodyMatrix, numberOfTheadRows, tableRows) {\n            var that = this;\n            var numberOfTableRows = tableRows.length;\n            var row, cells, cell, i, j, colIndex, headers;\n\n            var pushHeaderId = function (row) {\n              headers.push(row[colIndex]);\n            };\n\n            for (i = numberOfTheadRows; i < numberOfTableRows; i++) {\n              row = tableRows[i];\n              cells = $(row.cells).filter(\"td\");\n\n              for (j = 0; j < cells.length; j++) {\n                cell = cells[j];\n                colIndex = cell.getAttribute(\"col-index\");\n                headers = tbodyMatrix[i].slice();\n                theadMatrix.forEach(pushHeaderId);\n                headers = headers.filter(that._onlyUnique);\n                cell.setAttribute(\"headers\", headers.join(\" \").trim());\n              }\n            }\n          },\n          _getNumberOfColumns: function (table) {\n            var cells = $(table).find(\"th, td\");\n            var numberOfCols = 0;\n            var cell, i, currentIndex;\n\n            for (i = 0; i < cells.length; i++) {\n              cell = cells[i];\n              currentIndex = Number(cell.getAttribute(\"col-index\")) + 1;\n\n              if (currentIndex > numberOfCols) {\n                numberOfCols = currentIndex;\n              }\n            }\n\n            return numberOfCols;\n          },\n          _getNumberOfHeaderColumns: function (table, numberOfHeaderRows) {\n            var rows = table.rows;\n            var numberOfCols = 0;\n            var currentIndex, row, i, j, cell;\n\n            for (i = numberOfHeaderRows; i < rows.length; i++) {\n              row = rows[i];\n\n              for (j = 0; j < row.cells.length; j++) {\n                cell = row.cells[j];\n\n                if (this.is(cell, \"th\")) {\n                  currentIndex = Number(cell.getAttribute(\"col-index\")) + 1;\n\n                  if (currentIndex > numberOfCols) {\n                    numberOfCols = currentIndex;\n                  }\n                }\n              }\n            }\n\n            return numberOfCols;\n          },\n          _getNumberOfHeaderRows: function (table) {\n            var rows = table.rows;\n            var thead = table.tHead;\n            var number = thead && table.tHead.rows ? table.tHead.rows.length : 0;\n            var j, row, cell, length;\n\n            if (number === 0) {\n              row = rows[0];\n              length = row.cells && row.cells.length;\n\n              while (row && length && this.is(row.cells[0], \"th\")) {\n                for (j = 0; j < length; j++) {\n                  cell = row ? row.cells[j] : null;\n\n                  if (!this.is(cell, \"th\")) {\n                    row = null;\n                  }\n                }\n\n                if (row) {\n                  number += 1;\n                  row = this.next(row);\n                  length = row && row.cells && row.cells.length;\n                }\n              }\n            }\n\n            return number;\n          },\n          // End: Table Utilities\n          _onlyUnique: function (value, index, self) {\n            return self.indexOf(value) === index;\n          }\n        };\n        kendo.ui.editor.Dom = Dom;\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  971:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./main\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}