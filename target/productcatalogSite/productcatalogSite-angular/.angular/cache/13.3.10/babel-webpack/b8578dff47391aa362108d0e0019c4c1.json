{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport { Class, addClass, setDefaultOptions, deepExtend, defaultErrorHandler } from '../common';\nimport { Box } from '../core';\nimport { encodeData } from './encodings/encoding';\nimport { extend } from './utils';\nimport { surfaceSize } from '../barcode/surface-size';\nconst round = Math.round;\nconst crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];\nconst squarePattern = [[0, 1], [1, 1], [1, 0]];\nconst QRCodeDefaults = {\n  DEFAULT_SIZE: 200,\n  QUIET_ZONE_LENGTH: 4,\n  DEFAULT_ERROR_CORRECTION_LEVEL: \"L\",\n  DEFAULT_BACKGROUND: \"#fff\",\n  DEFAULT_DARK_MODULE_COLOR: \"#000\",\n  MIN_BASE_UNIT_SIZE: 1,\n  DEFAULT_LOGO_SIZE: 7\n};\n\nclass QRCode extends Class {\n  constructor(element, options, errorHandler = defaultErrorHandler) {\n    super();\n    this.options = deepExtend({}, this.options, options);\n    this.element = element;\n    this.wrapper = this.element;\n    this.onError = errorHandler;\n\n    this._initElement();\n\n    this._initSurface();\n\n    this.setOptions(options);\n  }\n\n  destroy() {\n    this._destroySurface();\n  }\n\n  _initElement() {\n    addClass(this.element, \"k-qrcode\");\n  }\n\n  _initSurface() {\n    const {\n      options,\n      surface\n    } = this;\n\n    if (!surface || surface.options.type !== options.renderAs) {\n      this._destroySurface();\n\n      this._initSurfaceElement();\n\n      this.surface = this._createSurface();\n    }\n  }\n\n  _createSurface() {\n    return draw.Surface.create(this.surfaceElement, {\n      type: this.options.renderAs\n    });\n  }\n\n  _destroySurface() {\n    if (this.surface) {\n      this.surface.destroy();\n      this.surface = null;\n\n      this._destroySurfaceElement();\n    }\n  }\n\n  _initSurfaceElement() {\n    if (!this.surfaceElement) {\n      this.surfaceElement = document.createElement('div');\n      this.surfaceElement.style.position = \"relative\";\n      this.element.appendChild(this.surfaceElement);\n    }\n  }\n\n  _destroySurfaceElement() {\n    if (this.surfaceElement && this.surfaceElement.parentNode) {\n      this.surfaceElement.parentNode.removeChild(this.surfaceElement);\n      this.surfaceElement = null;\n    }\n  }\n\n  redraw() {\n    let size = this._getSize();\n\n    this.surface.clear();\n    this.surface.setSize({\n      width: size,\n      height: size\n    });\n    this.createVisual();\n    this.surface.draw(this.visual);\n  }\n\n  getSize() {\n    const element = this.element;\n    const elementWidth = element.clientWidth;\n    const elementHeight = element.clientHeight;\n    const size = {\n      width: 0,\n      height: 0\n    };\n\n    if (elementWidth > 0) {\n      size.width = elementWidth;\n    }\n\n    if (elementHeight) {\n      size.height = elementHeight;\n    }\n\n    return size;\n  }\n\n  _resize() {\n    this.redraw();\n  }\n\n  createVisual() {\n    this.visual = this._render();\n  }\n\n  exportVisual() {\n    return this._render();\n  }\n\n  _render() {\n    let value = this._value,\n        baseUnit,\n        border = this.options.border || {},\n        padding = this.options.padding || 0,\n        borderWidth = border.width || 0,\n        quietZoneSize,\n        matrix,\n        size,\n        dataSize,\n        contentSize;\n    border.width = borderWidth;\n    let visual = new draw.Group();\n\n    try {\n      if (value) {\n        matrix = encodeData(value, this.options.errorCorrection, this.options.encoding);\n        size = this._getSize();\n        contentSize = size - 2 * (borderWidth + padding);\n        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);\n        dataSize = matrix.length * baseUnit;\n        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;\n        visual.append(this._renderBackground(size, border));\n        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));\n\n        if (this._hasCustomLogo()) {\n          visual.append(this._renderLogo(size, baseUnit));\n        } else if (this._isSwiss()) {\n          visual.append(this._renderSwissCode(size, baseUnit));\n        }\n      }\n    } catch (error) {\n      this.onError(error);\n    }\n\n    return visual;\n  }\n\n  _renderLogo(qrSize, baseUnit) {\n    let image;\n    let imageRect;\n    let center = round(qrSize / 2);\n\n    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n\n    let logoUrl = this.options.overlay.imageUrl;\n    let position = {\n      x: center - logoSize.width / 2,\n      y: center - logoSize.height / 2\n    };\n    imageRect = new geom.Rect(new geom.Point(position.x, position.y), new geom.Size(logoSize.width, logoSize.height));\n    image = new draw.Image(logoUrl, imageRect);\n    return image;\n  }\n\n  _renderSwissCode(qrSize, baseUnit) {\n    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n\n    logoSize = Math.max(logoSize.width, logoSize.height);\n    let crossSize = logoSize / 4;\n    let crossOffset = crossSize / 2;\n    let center = qrSize / 2;\n    let start = {};\n    let visual = new draw.Group();\n    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);\n    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, \"#fff\"));\n    start.x = start.y = center - logoSize / 2;\n    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));\n    start.x = center + crossOffset - logoSize / 2;\n    start.y = center + crossOffset + crossSize - logoSize / 2;\n    visual.append(this._renderShape(start, crossSize, crossPattern, \"#fff\"));\n    return visual;\n  }\n\n  _renderShape(start, step, pattern, color) {\n    let path = new draw.MultiPath({\n      fill: {\n        color: color\n      },\n      stroke: null\n    });\n    path.moveTo(start.x, start.y);\n\n    for (let i = 0; i < pattern.length; i++) {\n      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);\n    }\n\n    path.close();\n    return path;\n  }\n\n  _getSize() {\n    let size;\n\n    if (this.options.size) {\n      size = parseInt(this.options.size, 10);\n    } else {\n      const element = this.element;\n      const elementSize = surfaceSize(element, this.options.renderAs);\n      const min = Math.min(elementSize.width, elementSize.height);\n\n      if (min > 0) {\n        size = min;\n      } else {\n        size = QRCodeDefaults.DEFAULT_SIZE;\n      }\n    }\n\n    return size;\n  }\n\n  _calculateBaseUnit(size, matrixSize) {\n    let baseUnit = Math.floor(size / matrixSize);\n\n    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n      const minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);\n      this.onError(new Error(`Insufficient size for QR Code: the current size is ${size}px and the minimum size is ${minSize}px.`));\n    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n      baseUnit--;\n    }\n\n    return baseUnit;\n  }\n\n  _renderMatrix(matrix, baseUnit, quietZoneSize) {\n    let path = new draw.MultiPath({\n      fill: {\n        color: this.options.color\n      },\n      stroke: null\n    });\n\n    for (let row = 0; row < matrix.length; row++) {\n      let y = quietZoneSize + row * baseUnit;\n      let column = 0;\n\n      while (column < matrix.length) {\n        while (matrix[row][column] === 0 && column < matrix.length) {\n          column++;\n        }\n\n        if (column < matrix.length) {\n          let x = column;\n\n          while (matrix[row][column] === 1) {\n            column++;\n          }\n\n          let x1 = round(quietZoneSize + x * baseUnit);\n          let y1 = round(y);\n          let x2 = round(quietZoneSize + column * baseUnit);\n          let y2 = round(y + baseUnit);\n          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _renderBackground(size, border) {\n    const box = new Box(0, 0, size, size).unpad(border.width / 2);\n    const background = draw.Path.fromRect(box.toRect(), {\n      fill: {\n        color: this.options.background\n      },\n      stroke: {\n        color: border.color,\n        width: border.width\n      }\n    });\n    return background;\n  }\n\n  setOptions(options) {\n    let newOptions = options || {};\n    this.options = extend(this.options, newOptions);\n\n    if (options.value !== undefined) {\n      this._value = String(this.options.value);\n    }\n\n    this._initSurface();\n\n    this.redraw();\n  }\n\n  value(value) {\n    if (value === undefined) {\n      return this._value;\n    }\n\n    this._value = String(value);\n    this.redraw();\n  }\n\n  _hasCustomLogo() {\n    return Boolean(this.options.overlay.imageUrl);\n  }\n\n  _isSwiss() {\n    return this.options.overlay.type === \"swiss\";\n  }\n\n  _getLogoSize(defautLogoSize) {\n    let width = this.options.overlay.width;\n    let height = this.options.overlay.height;\n\n    if (!width && !height) {\n      width = height = defautLogoSize;\n    } else if (width && !height) {\n      height = width;\n    } else if (!width && height) {\n      width = height;\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  }\n\n}\n\nsetDefaultOptions(QRCode, {\n  name: \"QRCode\",\n  renderAs: \"svg\",\n  encoding: \"ISO_8859_1\",\n  value: \"\",\n  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,\n  background: QRCodeDefaults.DEFAULT_BACKGROUND,\n  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,\n  size: \"\",\n  padding: 0,\n  border: {\n    color: \"\",\n    width: 0\n  },\n  overlay: {\n    type: \"image\",\n    imageUrl: \"\",\n    width: 0,\n    height: 0\n  }\n});\nexport default QRCode;","map":null,"metadata":{},"sourceType":"module"}