{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { WHITE } from '../common/constants';\nimport { Class, deepExtend, defined, valueOrDefault } from '../common';\n\nclass ChartElement extends Class {\n  constructor(options) {\n    super();\n    this.children = [];\n    this.options = deepExtend({}, this.options, this.initUserOptions(options));\n  }\n\n  initUserOptions(options) {\n    return options;\n  }\n\n  reflow(targetBox) {\n    const children = this.children;\n    let box;\n\n    for (let i = 0; i < children.length; i++) {\n      let currentChild = children[i];\n      currentChild.reflow(targetBox);\n      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n    }\n\n    this.box = box || targetBox;\n  }\n\n  destroy() {\n    const children = this.children;\n\n    if (this.animation) {\n      this.animation.destroy();\n    }\n\n    for (let i = 0; i < children.length; i++) {\n      children[i].destroy();\n    }\n  }\n\n  getRoot() {\n    const parent = this.parent;\n    return parent ? parent.getRoot() : null;\n  }\n\n  getSender() {\n    const service = this.getService();\n\n    if (service) {\n      return service.sender;\n    }\n  }\n\n  getService() {\n    let element = this;\n\n    while (element) {\n      if (element.chartService) {\n        return element.chartService;\n      }\n\n      element = element.parent;\n    }\n  }\n\n  translateChildren(dx, dy) {\n    const children = this.children;\n    const childrenCount = children.length;\n\n    for (let i = 0; i < childrenCount; i++) {\n      children[i].box.translate(dx, dy);\n    }\n  }\n\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      let item = arguments[i];\n      this.children.push(item);\n      item.parent = this;\n    }\n  }\n\n  renderVisual() {\n    if (this.options.visible === false) {\n      return;\n    }\n\n    this.createVisual();\n    this.addVisual();\n    this.renderChildren();\n    this.createAnimation();\n    this.renderComplete();\n  }\n\n  addVisual() {\n    if (this.visual) {\n      this.visual.chartElement = this;\n\n      if (this.parent) {\n        this.parent.appendVisual(this.visual);\n      }\n    }\n  }\n\n  renderChildren() {\n    const children = this.children;\n    const length = children.length;\n\n    for (let i = 0; i < length; i++) {\n      children[i].renderVisual();\n    }\n  }\n\n  createVisual() {\n    this.visual = new draw.Group({\n      zIndex: this.options.zIndex,\n      visible: valueOrDefault(this.options.visible, true)\n    });\n  }\n\n  createAnimation() {\n    if (this.visual && this.options.animation) {\n      this.animation = draw.Animation.create(this.visual, this.options.animation);\n    }\n  }\n\n  appendVisual(childVisual) {\n    if (!childVisual.chartElement) {\n      childVisual.chartElement = this;\n    }\n\n    if (childVisual.options.noclip) {\n      this.clipRoot().visual.append(childVisual);\n    } else if (defined(childVisual.options.zIndex)) {\n      this.stackRoot().stackVisual(childVisual);\n    } else if (this.isStackRoot) {\n      this.stackVisual(childVisual);\n    } else if (this.visual) {\n      this.visual.append(childVisual);\n    } else {\n      // Allow chart elements without visuals to\n      // pass through child visuals\n      this.parent.appendVisual(childVisual);\n    }\n  }\n\n  clipRoot() {\n    if (this.parent) {\n      return this.parent.clipRoot();\n    }\n\n    return this;\n  }\n\n  stackRoot() {\n    if (this.parent) {\n      return this.parent.stackRoot();\n    }\n\n    return this;\n  }\n\n  stackVisual(childVisual) {\n    const zIndex = childVisual.options.zIndex || 0;\n    const visuals = this.visual.children;\n    const length = visuals.length;\n    let pos;\n\n    for (pos = 0; pos < length; pos++) {\n      let sibling = visuals[pos];\n      let here = valueOrDefault(sibling.options.zIndex, 0);\n\n      if (here > zIndex) {\n        break;\n      }\n    }\n\n    this.visual.insert(pos, childVisual);\n  }\n\n  traverse(callback) {\n    const children = this.children;\n    const length = children.length;\n\n    for (let i = 0; i < length; i++) {\n      let child = children[i];\n      callback(child);\n\n      if (child.traverse) {\n        child.traverse(callback);\n      }\n    }\n  }\n\n  closest(match) {\n    let element = this;\n    let matched = false;\n\n    while (element && !matched) {\n      matched = match(element);\n\n      if (!matched) {\n        element = element.parent;\n      }\n    }\n\n    if (matched) {\n      return element;\n    }\n  }\n\n  renderComplete() {}\n\n  hasHighlight() {\n    const options = (this.options || {}).highlight;\n    return !(!this.createHighlight || options && options.visible === false);\n  }\n\n  toggleHighlight(show, opacity) {\n    const options = (this.options || {}).highlight || {};\n    const customVisual = options.visual;\n    let highlight = this._highlight;\n\n    if (!highlight) {\n      const highlightOptions = {\n        fill: {\n          color: WHITE,\n          opacity: opacity || 0.2\n        },\n        stroke: {\n          color: WHITE,\n          width: 1,\n          opacity: opacity || 0.2\n        }\n      };\n\n      if (customVisual) {\n        highlight = this._highlight = customVisual(Object.assign(this.highlightVisualArgs(), {\n          createVisual: () => this.createHighlight(highlightOptions),\n          sender: this.getSender(),\n          series: this.series,\n          dataItem: this.dataItem,\n          category: this.category,\n          value: this.value,\n          percentage: this.percentage,\n          runningTotal: this.runningTotal,\n          total: this.total\n        }));\n\n        if (!highlight) {\n          return;\n        }\n      } else {\n        highlight = this._highlight = this.createHighlight(highlightOptions);\n      }\n\n      if (!defined(highlight.options.zIndex)) {\n        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n      }\n\n      this.appendVisual(highlight);\n    }\n\n    highlight.visible(show);\n  }\n\n  createGradientOverlay(element, options, gradientOptions) {\n    const overlay = new draw.Path(Object.assign({\n      stroke: {\n        color: \"none\"\n      },\n      fill: this.createGradient(gradientOptions),\n      closed: element.options.closed\n    }, options));\n    overlay.segments.elements(element.segments.elements());\n    return overlay;\n  }\n\n  createGradient(options) {\n    if (this.parent) {\n      return this.parent.createGradient(options);\n    }\n  }\n\n  supportsPointInactiveOpacity() {\n    return true;\n  }\n\n}\n\nChartElement.prototype.options = {};\nexport default ChartElement;","map":null,"metadata":{},"sourceType":"module"}