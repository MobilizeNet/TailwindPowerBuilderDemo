{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport Box from './box';\nimport { BLACK, LEFT, TOP, X, Y } from '../common/constants';\nimport { getSpacing, setDefaultOptions, valueOrDefault } from '../common';\n\nclass BoxElement extends ChartElement {\n  constructor(options) {\n    super(options);\n    this.options.margin = getSpacing(this.options.margin);\n    this.options.padding = getSpacing(this.options.padding);\n  }\n\n  reflow(targetBox) {\n    const options = this.options;\n    const {\n      width,\n      height,\n      shrinkToFit\n    } = options;\n    const hasSetSize = width && height;\n    const margin = options.margin;\n    const padding = options.padding;\n    const borderWidth = options.border.width;\n    let box;\n\n    const reflowPaddingBox = () => {\n      this.align(targetBox, X, options.align);\n      this.align(targetBox, Y, options.vAlign);\n      this.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n    };\n\n    let contentBox = targetBox.clone();\n\n    if (hasSetSize) {\n      contentBox.x2 = contentBox.x1 + width;\n      contentBox.y2 = contentBox.y1 + height;\n    }\n\n    if (shrinkToFit) {\n      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n    }\n\n    super.reflow(contentBox);\n\n    if (hasSetSize) {\n      box = this.box = new Box(0, 0, width, height);\n    } else {\n      box = this.box;\n    }\n\n    if (shrinkToFit && hasSetSize) {\n      reflowPaddingBox();\n      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n    } else {\n      contentBox = this.contentBox = box.clone();\n      box.pad(padding).pad(borderWidth).pad(margin);\n      reflowPaddingBox();\n    }\n\n    this.translateChildren(box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left, box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top);\n    const children = this.children;\n\n    for (let i = 0; i < children.length; i++) {\n      let item = children[i];\n      item.reflow(item.box);\n    }\n  }\n\n  align(targetBox, axis, alignment) {\n    this.box.align(targetBox, axis, alignment);\n  }\n\n  hasBox() {\n    const options = this.options;\n    return options.border.width || options.background;\n  }\n\n  createVisual() {\n    super.createVisual();\n    const options = this.options;\n\n    if (options.visible && this.hasBox()) {\n      this.visual.append(draw.Path.fromRect(this.paddingBox.toRect(), this.visualStyle()));\n    }\n  }\n\n  visualStyle() {\n    const options = this.options;\n    const border = options.border || {};\n    return {\n      stroke: {\n        width: border.width,\n        color: border.color,\n        opacity: valueOrDefault(border.opacity, options.opacity),\n        dashType: border.dashType\n      },\n      fill: {\n        color: options.background,\n        opacity: options.opacity\n      },\n      cursor: options.cursor\n    };\n  }\n\n}\n\nsetDefaultOptions(BoxElement, {\n  align: LEFT,\n  vAlign: TOP,\n  margin: {},\n  padding: {},\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  background: \"\",\n  shrinkToFit: false,\n  width: 0,\n  height: 0,\n  visible: true\n});\nexport default BoxElement;","map":null,"metadata":{},"sourceType":"module"}