{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1191);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1191:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"dateinput\",\n        name: \"DateInput\",\n        category: \"web\",\n        description: \"The DateInput widget allows to edit date by typing.\",\n        depends: [\"core\"]\n      };\n\n      (function ($, undefined) {\n        var global = window;\n        var kendo = global.kendo;\n        var caret = kendo.caret;\n        var ui = kendo.ui;\n        var Widget = ui.Widget;\n        var keys = kendo.keys;\n        var ns = \".kendoDateInput\";\n        var objectToString = {}.toString;\n        var INPUT_EVENT_NAME = (kendo.support.propertyChangeEvent ? \"propertychange.kendoDateInput input\" : \"input\") + ns;\n        var FOCUSED = \"k-focus\";\n        var STATEDISABLED = \"k-disabled\";\n        var STATEINVALID = \"k-invalid\";\n        var DISABLED = \"disabled\";\n        var READONLY = \"readonly\";\n        var CHANGE = \"change\";\n        var knownSymbols = \"dMyHhmftsz\";\n        var DateInput = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            element = that.element;\n            options = that.options;\n            options.format = kendo._extractFormat(options.format || kendo.getCulture(options.culture).calendars.standard.patterns.d);\n            options.min = kendo.parseDate(element.attr(\"min\")) || kendo.parseDate(options.min);\n            options.max = kendo.parseDate(element.attr(\"max\")) || kendo.parseDate(options.max);\n            var wrapperClass = element.parent().attr(\"class\") || \"\";\n            var skipWrapping = wrapperClass.indexOf(\"picker\") >= 0 && wrapperClass.indexOf(\"rangepicker\") < 0;\n\n            if (skipWrapping) {\n              that.wrapper = element.parent();\n            } else {\n              that.wrapper = element.wrap(\"<span class='k-dateinput k-input'></span>\").parent();\n              that.wrapper.addClass(element[0].className).removeClass('input-validation-error');\n              that.wrapper[0].style.cssText = element[0].style.cssText;\n              element.css({\n                height: element[0].style.height\n              });\n            }\n\n            that._validationIcon = $(\"<span class='k-input-validation-icon k-icon k-i-warning k-hidden'></span>\").insertAfter(element);\n\n            that._form();\n\n            that.element.addClass(skipWrapping ? \" \" : \"k-input-inner\").attr(\"autocomplete\", \"off\").on(\"focus\" + ns, function () {\n              that.wrapper.addClass(FOCUSED);\n            }).on(\"focusout\" + ns, function () {\n              that.wrapper.removeClass(FOCUSED);\n\n              that._change();\n            });\n\n            try {\n              element[0].setAttribute(\"type\", \"text\");\n            } catch (e) {\n              element[0].type = \"text\";\n            }\n\n            var disabled = element.is(\"[disabled]\") || $(that.element).parents(\"fieldset\").is(':disabled');\n\n            if (disabled) {\n              that.enable(false);\n            } else {\n              that.readonly(element.is(\"[readonly]\"));\n            }\n\n            that.value(that.options.value || element.val());\n\n            that._applyCssClasses();\n\n            kendo.notify(that);\n          },\n          options: {\n            name: \"DateInput\",\n            culture: \"\",\n            value: \"\",\n            format: \"\",\n            min: new Date(1900, 0, 1),\n            max: new Date(2099, 11, 31),\n            messages: {\n              \"year\": \"year\",\n              \"month\": \"month\",\n              \"day\": \"day\",\n              \"weekday\": \"day of the week\",\n              \"hour\": \"hours\",\n              \"minute\": \"minutes\",\n              \"second\": \"seconds\",\n              \"dayperiod\": \"AM/PM\"\n            },\n            size: \"medium\",\n            fillMode: \"solid\",\n            rounded: \"medium\"\n          },\n          events: [CHANGE],\n          min: function (value) {\n            if (value !== undefined) {\n              this.options.min = value;\n            } else {\n              return this.options.min;\n            }\n          },\n          max: function (value) {\n            if (value !== undefined) {\n              this.options.max = value;\n            } else {\n              return this.options.max;\n            }\n          },\n          setOptions: function (options) {\n            var that = this;\n            Widget.fn.setOptions.call(that, options);\n\n            this._unbindInput();\n\n            this._bindInput();\n\n            this._updateElementValue();\n          },\n          destroy: function () {\n            var that = this;\n            that.element.off(ns);\n\n            if (that._formElement) {\n              that._formElement.off(\"reset\", that._resetHandler);\n            }\n\n            Widget.fn.destroy.call(that);\n          },\n          value: function (value) {\n            if (value === undefined) {\n              return this._dateTime.getDateObject();\n            }\n\n            if (value === null) {\n              value = \"\";\n            }\n\n            if (objectToString.call(value) !== \"[object Date]\") {\n              value = kendo.parseDate(value, this.options.format, this.options.culture);\n            }\n\n            if (value && !value.getTime()) {\n              value = null;\n            }\n\n            this._dateTime = new customDateTime(value, this.options.format, this.options.culture, this.options.messages);\n\n            this._updateElementValue();\n\n            this._oldValue = value;\n          },\n          _updateElementValue: function () {\n            var stringAndFromat = this._dateTime.toPair(this.options.format, this.options.culture, this.options.messages);\n\n            this.element.val(stringAndFromat[0]);\n            this._oldText = stringAndFromat[0];\n            this._format = stringAndFromat[1];\n          },\n          readonly: function (readonly) {\n            this._editable({\n              readonly: readonly === undefined ? true : readonly,\n              disable: false\n            });\n          },\n          enable: function (enable) {\n            this._editable({\n              readonly: false,\n              disable: !(enable = enable === undefined ? true : enable)\n            });\n          },\n          _bindInput: function () {\n            var that = this;\n            that.element.on(\"focus\" + ns, function () {\n              that.wrapper.addClass(FOCUSED);\n            }).on(\"focusout\" + ns, function () {\n              that.wrapper.removeClass(FOCUSED);\n\n              that._change();\n            }).on(\"paste\" + ns, that._paste.bind(that)).on(\"keydown\" + ns, that._keydown.bind(that)).on(INPUT_EVENT_NAME, that._input.bind(that)).on(\"mouseup\" + ns, that._mouseUp.bind(that)).on(\"DOMMouseScroll\" + ns + \" mousewheel\" + ns, that._scroll.bind(that));\n          },\n          _unbindInput: function () {\n            this.element.off(\"keydown\" + ns).off(\"paste\" + ns).off(\"focus\" + ns).off(\"focusout\" + ns).off(INPUT_EVENT_NAME).off(\"mouseup\" + ns).off(\"DOMMouseScroll\" + ns + \" mousewheel\" + ns);\n          },\n          _editable: function (options) {\n            var that = this;\n            var element = that.element;\n            var disable = options.disable;\n            var readonly = options.readonly;\n            var wrapper = that.wrapper;\n\n            that._unbindInput();\n\n            if (!readonly && !disable) {\n              wrapper.removeClass(STATEDISABLED);\n\n              if (element && element.length) {\n                element[0].removeAttribute(DISABLED);\n                element[0].removeAttribute(READONLY);\n              }\n\n              that._bindInput();\n            } else {\n              if (disable) {\n                wrapper.addClass(STATEDISABLED);\n                element.attr(DISABLED, disable);\n\n                if (element && element.length) {\n                  element[0].removeAttribute(READONLY);\n                }\n              }\n\n              if (readonly) {\n                element.attr(READONLY, readonly);\n              }\n            }\n          },\n          _change: function () {\n            var that = this;\n            var oldValue = that._oldValue;\n            var value = that.value();\n\n            if (value && that.min() && value < that.min()) {\n              that.value(that.min());\n              value = that.value();\n            }\n\n            if (value && that.max() && value > that.max()) {\n              that.value(that.max());\n              value = that.value();\n            }\n\n            if (oldValue && value && value.getTime() !== oldValue.getTime() || oldValue && !value || !oldValue && value) {\n              that._oldValue = value;\n              that.trigger(CHANGE);\n              that.element.trigger(CHANGE);\n            }\n          },\n          _input: function () {\n            var that = this;\n            var element = that.element[0];\n            var blinkInvalid = false;\n\n            if (kendo._activeElement() !== element) {\n              return;\n            }\n\n            var diff = approximateStringMatching(this._oldText, this._format, this.element[0].value, caret(this.element[0])[0]);\n            var navigationOnly = diff.length === 1 && diff[0][1] === \" \";\n\n            if (!navigationOnly) {\n              for (var i = 0; i < diff.length; i++) {\n                var valid = this._dateTime.parsePart(diff[i][0], diff[i][1]);\n\n                blinkInvalid = blinkInvalid || !valid;\n              }\n            }\n\n            this._updateElementValue();\n\n            if (diff.length && diff[0][0] !== \" \") {\n              this._selectSegment(diff[0][0]); //android fix\n\n\n              if (!navigationOnly) {\n                var difSym = diff[0][0];\n                setTimeout(function () {\n                  that._selectSegment(difSym);\n                });\n              }\n            }\n\n            if (navigationOnly) {\n              var newEvent = {\n                keyCode: 39,\n                preventDefault: function () {}\n              };\n\n              this._keydown(newEvent);\n            }\n\n            if (blinkInvalid) {\n              that._blinkInvalidState();\n            }\n          },\n          _blinkInvalidState: function () {\n            var that = this;\n\n            that._addInvalidState();\n\n            clearTimeout(that._invalidStateTimeout);\n            that._invalidStateTimeout = setTimeout(that._removeInvalidState.bind(that), 100);\n          },\n          _addInvalidState: function () {\n            var that = this;\n            that.wrapper.addClass(STATEINVALID);\n\n            that._validationIcon.removeClass(\"k-hidden\");\n          },\n          _removeInvalidState: function () {\n            var that = this;\n            that.wrapper.removeClass(STATEINVALID);\n\n            that._validationIcon.addClass(\"k-hidden\");\n\n            that._invalidStateTimeout = null;\n          },\n          _mouseUp: function () {\n            var selection = caret(this.element[0]);\n\n            if (selection[0] === selection[1]) {\n              this._selectNearestSegment();\n            }\n          },\n          _scroll: function (e) {\n            if (kendo._activeElement() !== this.element[0] || this.element.is(\"[readonly]\")) {\n              return;\n            }\n\n            e = window.event || e;\n            var newEvent = {\n              keyCode: 37,\n              preventDefault: function () {}\n            };\n\n            if (e.shiftKey) {\n              newEvent.keyCode = (e.wheelDelta || -e.detail) > 0 ? 37 : 39;\n            } else {\n              newEvent.keyCode = (e.wheelDelta || -e.detail) > 0 ? 38 : 40;\n            }\n\n            this._keydown(newEvent);\n\n            e.returnValue = false;\n\n            if (e.preventDefault) {\n              e.preventDefault();\n            }\n\n            if (e.stopPropagation) {\n              e.stopPropagation();\n            }\n          },\n          _form: function () {\n            var that = this;\n            var element = that.element;\n            var formId = element.attr(\"form\");\n            var form = formId ? $(\"#\" + formId) : element.closest(\"form\");\n            var initialValue = element[0].value;\n\n            if (!initialValue && that.options.value) {\n              initialValue = that.options.value;\n            }\n\n            if (form[0]) {\n              that._resetHandler = function () {\n                setTimeout(function () {\n                  that.value(initialValue);\n                });\n              };\n\n              that._formElement = form.on(\"reset\", that._resetHandler);\n            }\n          },\n          _paste: function (e) {\n            e.preventDefault();\n          },\n          _keydown: function (e) {\n            var key = e.keyCode;\n            var selection;\n\n            if (key == 37 || key == 39) {\n              //left/right\n              e.preventDefault();\n              selection = caret(this.element[0]);\n\n              if (selection[0] != selection[1]) {\n                this._selectNearestSegment();\n              }\n\n              var dir = key == 37 ? -1 : 1;\n              var index = dir == -1 ? caret(this.element[0])[0] - 1 : caret(this.element[0])[1] + 1;\n\n              while (index >= 0 && index < this._format.length) {\n                if (knownSymbols.indexOf(this._format[index]) >= 0) {\n                  this._selectSegment(this._format[index]);\n\n                  break;\n                }\n\n                index += dir;\n              }\n            }\n\n            if (key == 38 || key == 40) {\n              //up/down\n              e.preventDefault();\n              selection = caret(this.element[0]);\n              var symbol = this._format[selection[0]];\n\n              if (knownSymbols.indexOf(symbol) >= 0) {\n                var interval = 1;\n\n                if (symbol == 'm') {\n                  interval = this.options.interval || 1;\n                }\n\n                this._dateTime.modifyPart(symbol, key == 38 ? interval * 1 : interval * -1);\n\n                this._updateElementValue();\n\n                this._selectSegment(symbol);\n\n                this.element.trigger(CHANGE);\n              }\n            }\n\n            if (kendo.support.browser.msie && kendo.support.browser.version < 10) {\n              var keycode = e.keyCode ? e.keyCode : e.which;\n\n              if (keycode === 8 || keycode === 46) {\n                var that = this;\n                setTimeout(function () {\n                  that._input();\n                }, 0);\n              }\n            }\n\n            if (key === keys.ENTER) {\n              this._change();\n            }\n          },\n          _selectNearestSegment: function () {\n            var selection = caret(this.element[0]);\n            var start = selection[0];\n\n            for (var i = start, j = start - 1; i < this._format.length || j >= 0; i++, j--) {\n              if (i < this._format.length && knownSymbols.indexOf(this._format[i]) !== -1) {\n                this._selectSegment(this._format[i]);\n\n                return;\n              }\n\n              if (j >= 0 && knownSymbols.indexOf(this._format[j]) !== -1) {\n                this._selectSegment(this._format[j]);\n\n                return;\n              }\n            }\n          },\n          _selectSegment: function (symbol) {\n            var begin = -1,\n                end = 0;\n\n            for (var i = 0; i < this._format.length; i++) {\n              if (this._format[i] === symbol) {\n                end = i + 1;\n\n                if (begin === -1) {\n                  begin = i;\n                }\n              }\n            }\n\n            if (begin < 0) {\n              begin = 0;\n            }\n\n            caret(this.element, begin, end);\n          }\n        });\n        kendo.cssProperties.registerPrefix(\"DateInput\", \"k-input-\");\n        kendo.cssProperties.registerValues(\"DateInput\", [{\n          prop: \"rounded\",\n          values: kendo.cssProperties.roundedValues.concat([['full', 'full']])\n        }]);\n        ui.plugin(DateInput);\n\n        var customDateTime = function (initDate, initFormat, initCulture, initMessages) {\n          var value = null;\n          var year = true,\n              month = true,\n              date = true,\n              hours = true,\n              minutes = true,\n              seconds = true,\n              milliseconds = true;\n          var typedMonthPart = \"\";\n          var typedDayPeriodPart = \"\";\n          var placeholders = {}; //TODO: rewrite pad method\n\n          var zeros = [\"\", \"0\", \"00\", \"000\", \"0000\"];\n\n          function pad(number, digits, end) {\n            number = number + \"\";\n            digits = digits || 2;\n            end = digits - number.length;\n\n            if (end) {\n              return zeros[digits].substring(0, end) + number;\n            }\n\n            return number;\n          }\n\n          var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|\"[^\"]*\"|'[^']*'/g;\n          var months = null,\n              calendar = null,\n              days = null,\n              returnsFormat = false;\n\n          var matcher = function (match) {\n            var mins, sign;\n            var result;\n\n            switch (match) {\n              case \"d\":\n                result = date ? value.getDate() : placeholders.day;\n                break;\n\n              case \"dd\":\n                result = date ? pad(value.getDate()) : placeholders.day;\n                break;\n\n              case \"ddd\":\n                result = date && month && year ? days.namesAbbr[value.getDay()] : placeholders.weekday;\n                break;\n\n              case \"dddd\":\n                result = date && month && year ? days.names[value.getDay()] : placeholders.weekday;\n                break;\n\n              case \"M\":\n                result = month ? value.getMonth() + 1 : placeholders.month;\n                break;\n\n              case \"MM\":\n                result = month ? pad(value.getMonth() + 1) : placeholders.month;\n                break;\n\n              case \"MMM\":\n                result = month ? months.namesAbbr[value.getMonth()] : placeholders.month;\n                break;\n\n              case \"MMMM\":\n                result = month ? months.names[value.getMonth()] : placeholders.month;\n                break;\n\n              case \"yy\":\n                result = year ? pad(value.getFullYear() % 100) : placeholders.year;\n                break;\n\n              case \"yyyy\":\n                result = year ? pad(value.getFullYear(), 4) : placeholders.year;\n                break;\n\n              case \"h\":\n                result = hours ? value.getHours() % 12 || 12 : placeholders.hour;\n                break;\n\n              case \"hh\":\n                result = hours ? pad(value.getHours() % 12 || 12) : placeholders.hour;\n                break;\n\n              case \"H\":\n                result = hours ? value.getHours() : placeholders.hour;\n                break;\n\n              case \"HH\":\n                result = hours ? pad(value.getHours()) : placeholders.hour;\n                break;\n\n              case \"m\":\n                result = minutes ? value.getMinutes() : placeholders.minute;\n                break;\n\n              case \"mm\":\n                result = minutes ? pad(value.getMinutes()) : placeholders.minute;\n                break;\n\n              case \"s\":\n                result = seconds ? value.getSeconds() : placeholders.second;\n                break;\n\n              case \"ss\":\n                result = seconds ? pad(value.getSeconds()) : placeholders.second;\n                break;\n\n              case \"f\":\n                result = milliseconds ? Math.floor(value.getMilliseconds() / 100) : milliseconds;\n                break;\n\n              case \"ff\":\n                result = value.getMilliseconds();\n\n                if (result > 99) {\n                  result = Math.floor(result / 10);\n                }\n\n                result = milliseconds ? pad(result) : match;\n                break;\n\n              case \"fff\":\n                result = milliseconds ? pad(value.getMilliseconds(), 3) : match;\n                break;\n\n              case \"tt\":\n                result = hours ? value.getHours() < 12 ? calendar.AM[0] : calendar.PM[0] : placeholders.dayperiod;\n                break;\n\n              case \"zzz\":\n                mins = value.getTimezoneOffset();\n                sign = mins < 0;\n                result = Math.abs(mins / 60).toString().split(\".\")[0];\n                mins = Math.abs(mins) - result * 60;\n                result = (sign ? \"+\" : \"-\") + pad(result);\n                result += \":\" + pad(mins);\n                break;\n\n              case \"z\":\n              case \"zz\":\n                result = value.getTimezoneOffset() / 60;\n                sign = result < 0;\n                result = Math.abs(result).toString().split(\".\")[0];\n                result = (sign ? \"+\" : \"-\") + (match === \"zz\" ? pad(result) : result);\n                break;\n            }\n\n            result = result !== undefined ? result : match.slice(1, match.length - 1);\n\n            if (returnsFormat) {\n              result = \"\" + result;\n              var formatResult = \"\";\n\n              if (match == \"ddd\") {\n                match = \"EEE\";\n              }\n\n              if (match == \"dddd\") {\n                match = \"EEEE\";\n              }\n\n              for (var i = 0; i < result.length; i++) {\n                formatResult += match[0];\n              }\n\n              return formatResult;\n            } else {\n              return result;\n            }\n          };\n\n          function generateMatcher(retFormat) {\n            returnsFormat = retFormat;\n            return matcher;\n          }\n\n          function setExisting(symbol, val) {\n            switch (symbol) {\n              case \"y\":\n                year = val;\n                break;\n\n              case \"M\":\n                month = val;\n\n                if (!val) {\n                  value.setMonth(0);\n                  typedMonthPart = \"\";\n                }\n\n                break;\n\n              case \"d\":\n                date = val;\n                break;\n\n              case \"H\":\n              case \"h\":\n                hours = val;\n\n                if (!val) {\n                  typedDayPeriodPart = \"\";\n                }\n\n                break;\n\n              case \"m\":\n                minutes = val;\n                break;\n\n              case \"s\":\n                seconds = val;\n                break;\n\n              default:\n                return;\n            }\n          }\n\n          this.setValue = function (val) {\n            date = val;\n          };\n\n          this.getValue = function () {\n            return date;\n          };\n\n          this.modifyPart = function (symbol, offset) {\n            var newValue = new Date(value && value.getTime ? value.getTime() : value);\n\n            switch (symbol) {\n              case \"y\":\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n\n              case \"M\":\n                var newMonth = newValue.getMonth() + offset;\n                newValue.setMonth(newMonth);\n\n                if (newValue.getMonth() % 12 !== (newMonth + 12) % 12) {\n                  //handle case when new month does not have such date\n                  newValue.setDate(1);\n                  newValue.setMonth(newMonth);\n                }\n\n                break;\n\n              case \"d\":\n              case \"E\":\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n\n              case \"H\":\n              case \"h\":\n                newValue.setHours(newValue.getHours() + offset);\n                break;\n\n              case \"m\":\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                break;\n\n              case \"s\":\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                break;\n\n              case \"t\":\n                newValue.setHours((newValue.getHours() + 12) % 24);\n                break;\n\n              default:\n                break;\n            }\n\n            if (newValue.getFullYear() > 0) {\n              setExisting(symbol, true);\n              value = newValue;\n            }\n          };\n\n          this.parsePart = function (symbol, currentChar) {\n            if (!currentChar) {\n              setExisting(symbol, false);\n              return true;\n            }\n\n            var newValue = new Date(value && value.getTime ? value.getTime() : value);\n            var lastDateOfMonth = new Date(newValue.getFullYear(), newValue.getMonth() + 1, 0).getDate();\n            var newHours;\n\n            switch (symbol) {\n              case \"d\":\n                var newDate = (date ? newValue.getDate() * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newDate)) {\n                  return;\n                }\n\n                while (newDate > lastDateOfMonth) {\n                  newDate = parseInt(newDate.toString().slice(1), 10);\n                }\n\n                if (newDate < 1) {\n                  date = false;\n                } else {\n                  newValue.setDate(newDate);\n\n                  if (newValue.getMonth() !== value.getMonth()) {\n                    return;\n                  }\n\n                  date = true;\n                }\n\n                break;\n\n              case \"M\":\n                var newMonth = (month ? (newValue.getMonth() + 1) * 10 : 0) + parseInt(currentChar, 10);\n\n                if (!isNaN(newMonth)) {\n                  while (newMonth > 12) {\n                    newMonth = parseInt(newMonth.toString().slice(1), 10);\n                  }\n\n                  if (newMonth < 1) {\n                    month = false;\n                  } else {\n                    newValue.setMonth(newMonth - 1);\n\n                    if (newValue.getMonth() !== newMonth - 1) {\n                      newValue.setDate(1);\n                      newValue.setMonth(newMonth - 1);\n                    }\n\n                    month = true;\n                  }\n                } else {\n                  var monthNames = calendar.months.names;\n                  typedMonthPart += currentChar.toLowerCase();\n\n                  while (typedMonthPart.length > 0) {\n                    for (var i = 0; i < monthNames.length; i++) {\n                      if (monthNames[i].toLowerCase().indexOf(typedMonthPart) === 0) {\n                        newValue.setMonth(i);\n                        month = true;\n                        value = newValue;\n                        return true;\n                      }\n                    }\n\n                    typedMonthPart = typedMonthPart.substring(1, typedMonthPart.length);\n                  }\n\n                  return false;\n                }\n\n                break;\n\n              case \"y\":\n                var newYear = (year ? newValue.getFullYear() * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newYear)) {\n                  return;\n                }\n\n                while (newYear > 9999) {\n                  newYear = parseInt(newYear.toString().slice(1), 10);\n                }\n\n                if (newYear < 1) {\n                  year = false;\n                } else {\n                  newValue.setFullYear(newYear);\n                  year = true;\n                }\n\n                break;\n\n              case \"h\":\n                newHours = (hours ? (newValue.getHours() % 12 || 12) * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newHours)) {\n                  return;\n                }\n\n                while (newHours > 12) {\n                  newHours = parseInt(newHours.toString().slice(1), 10);\n                }\n\n                newValue.setHours(Math.floor(newValue.getHours() / 12) * 12 + newHours % 12);\n                hours = true;\n                break;\n\n              case \"H\":\n                newHours = (hours ? newValue.getHours() * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newHours)) {\n                  return;\n                }\n\n                while (newHours > 23) {\n                  newHours = parseInt(newHours.toString().slice(1), 10);\n                }\n\n                newValue.setHours(newHours);\n                hours = true;\n                break;\n\n              case \"m\":\n                var newMinutes = (minutes ? newValue.getMinutes() * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newMinutes)) {\n                  return;\n                }\n\n                while (newMinutes > 59) {\n                  newMinutes = parseInt(newMinutes.toString().slice(1), 10);\n                }\n\n                newValue.setMinutes(newMinutes);\n                minutes = true;\n                break;\n\n              case \"s\":\n                var newSeconds = (seconds ? newValue.getSeconds() * 10 : 0) + parseInt(currentChar, 10);\n\n                if (isNaN(newSeconds)) {\n                  return;\n                }\n\n                while (newSeconds > 59) {\n                  newSeconds = parseInt(newSeconds.toString().slice(1), 10);\n                }\n\n                newValue.setSeconds(newSeconds);\n                seconds = true;\n                break;\n\n              case \"t\":\n                if (hours) {\n                  typedDayPeriodPart += currentChar.toLowerCase();\n\n                  while (typedDayPeriodPart.length > 0) {\n                    if (calendar.AM[0].toLowerCase().indexOf(typedDayPeriodPart) === 0 && newValue.getHours() >= 12 || calendar.PM[0].toLowerCase().indexOf(typedDayPeriodPart) === 0 && newValue.getHours() < 12) {\n                      newValue.setHours((newValue.getHours() + 12) % 24);\n                      value = newValue;\n                      return true;\n                    }\n\n                    typedDayPeriodPart = typedDayPeriodPart.substring(1, typedDayPeriodPart.length);\n                  }\n\n                  return false;\n                }\n\n                break;\n\n              default:\n                break;\n            }\n\n            value = newValue;\n            return true;\n          };\n\n          this.toPair = function (format, culture, messages) {\n            if (!format) {\n              return [\"\", \"\"];\n            }\n\n            culture = kendo.getCulture(culture);\n            calendar = culture.calendars.standard;\n            format = calendar.patterns[format] || format;\n            days = calendar.days;\n            months = calendar.months;\n            placeholders = messages;\n            return [format.replace(dateFormatRegExp, generateMatcher(false)), format.replace(dateFormatRegExp, generateMatcher(true))];\n          };\n\n          this.getDateObject = function () {\n            return year && month && date && hours && minutes && seconds && milliseconds ? new Date(value.getTime()) : null;\n          };\n\n          if (!initDate) {\n            value = new Date();\n            var sampleFormat = this.toPair(initFormat, initCulture, initMessages)[1];\n\n            for (var i = 0; i < sampleFormat.length; i++) {\n              setExisting(sampleFormat[i], false);\n            }\n          } else {\n            value = new Date(initDate.getTime());\n          }\n        };\n\n        function approximateStringMatching(oldText, oldFormat, newText, caret) {\n          var oldTextSeparator = oldText[caret + oldText.length - newText.length];\n          oldText = oldText.substring(0, caret + oldText.length - newText.length);\n          newText = newText.substring(0, caret);\n          var diff = [];\n          var i; //handle typing single character over the same selection\n\n          if (oldText === newText && caret > 0) {\n            diff.push([oldFormat[caret - 1], newText[caret - 1]]);\n            return diff;\n          }\n\n          if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {\n            //handle delete/backspace\n            var deletedSymbol = \"\";\n\n            for (i = newText.length; i < oldText.length; i++) {\n              if (oldFormat[i] !== deletedSymbol && knownSymbols.indexOf(oldFormat[i]) >= 0) {\n                deletedSymbol = oldFormat[i];\n                diff.push([deletedSymbol, \"\"]);\n              }\n            }\n\n            return diff;\n          } //handle entering space or separator, for nagivation to next item\n\n\n          if (newText[newText.length - 1] === \" \" || newText[newText.length - 1] === oldTextSeparator) {\n            return [[oldFormat[caret - 1], \" \"]];\n          } //handle inserting text (new text is longer than previous)\n          //handle typing over literal as well\n\n\n          if (newText.indexOf(oldText) === 0 || knownSymbols.indexOf(oldFormat[caret - 1]) === -1) {\n            var symbol = oldFormat[0];\n\n            for (i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {\n              if (knownSymbols.indexOf(oldFormat[i]) >= 0) {\n                symbol = oldFormat[i];\n                break;\n              }\n            }\n\n            return [[symbol, newText[caret - 1]]];\n          } //handle typing over correctly selected part\n\n\n          return [[oldFormat[caret - 1], newText[caret - 1]]];\n        }\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}