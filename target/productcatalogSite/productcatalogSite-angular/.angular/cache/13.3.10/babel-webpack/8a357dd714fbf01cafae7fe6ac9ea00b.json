{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1744);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  971:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./main\");\n    /***/\n  },\n\n  /***/\n  1744:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(971)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\"; // SAX-style XML parser ====================================================\n\n      var STRING = String.fromCharCode; // XXX: add more here?\n\n      var ENTITIES = {\n        \"amp\": 38,\n        \"lt\": 60,\n        \"gt\": 62,\n        \"quot\": 34,\n        \"apos\": 39,\n        \"nbsp\": 160\n      };\n\n      function CODE(str) {\n        var out = [];\n\n        for (var i = 0; i < str.length; ++i) {\n          out.push(str.charCodeAt(i));\n        }\n\n        return out;\n      }\n\n      function UCS2(out, code) {\n        if (code > 0xFFFF) {\n          code -= 0x10000;\n          out.push(code >>> 10 & 0x3FF | 0xD800, 0xDC00 | code & 0x3FF);\n        } else {\n          out.push(code);\n        }\n      }\n\n      var START_CDATA = CODE(\"<![CDATA[\");\n      var END_CDATA = CODE(\"]]>\");\n      var END_COMMENT = CODE(\"-->\");\n      var START_COMMENT = CODE(\"!--\");\n      var END_SHORT_TAG = CODE(\"/>\");\n      var END_TAG = CODE(\"</\");\n      var END_DECLARATION = CODE(\"?>\");\n      var QUESTION_MARK = CODE(\"?\");\n      var LESS_THAN = CODE(\"<\");\n      var GREATER_THAN = CODE(\">\");\n      var SEMICOLON = CODE(\";\");\n      var EQUAL = CODE(\"=\");\n      var AMPERSAND = CODE(\"&\");\n      var QUOTE = CODE('\"');\n      var APOSTROPHE = CODE(\"'\");\n      var SHARP = CODE(\"#\");\n      var LOWERCASE_X = CODE(\"x\");\n      var UPPERCASE_X = CODE(\"X\");\n      var EXIT = {};\n\n      function parse(data, callbacks) {\n        var index = 0;\n        var stack = [];\n        var object = {\n          is: function (selector) {\n            var i = stack.length,\n                j = selector.length;\n\n            while (--i >= 0 && --j >= 0) {\n              if (stack[i].$tag != selector[j] && selector[j] != \"*\") {\n                return false;\n              }\n            }\n\n            return j < 0 ? stack[stack.length - 1] : null;\n          },\n          exit: function () {\n            throw EXIT;\n          },\n          stack: stack\n        };\n\n        function readChar(body) {\n          var code = data[index++];\n\n          if (!(code & 0xF0 ^ 0xF0)) {\n            // 4 bytes\n            UCS2(body, (code & 0x03) << 18 | (data[index++] & 0x3F) << 12 | (data[index++] & 0x3F) << 6 | data[index++] & 0x3F);\n          } else if (!(code & 0xE0 ^ 0xE0)) {\n            // 3 bytes\n            UCS2(body, (code & 0x0F) << 12 | (data[index++] & 0x3F) << 6 | data[index++] & 0x3F);\n          } else if (!(code & 0xC0 ^ 0xC0)) {\n            // 2 bytes\n            UCS2(body, (code & 0x1F) << 6 | data[index++] & 0x3F);\n          } else {\n            body.push(code);\n          }\n        }\n\n        function croak(msg) {\n          throw new Error(msg + \", at \" + index);\n        }\n\n        function readWhile(pred) {\n          var a = [];\n\n          while (index < data.length && pred(data[index])) {\n            a.push(data[index++]);\n          }\n\n          return a;\n        }\n\n        function readAsciiWhile(pred) {\n          return STRING.apply(0, readWhile(pred));\n        }\n\n        function skipWhitespace() {\n          readWhile(isWhitespace);\n        }\n\n        function eat(a) {\n          var save = index;\n\n          for (var i = 0; i < a.length; ++i) {\n            if (data[index++] != a[i]) {\n              index = save;\n              return false;\n            }\n          }\n\n          return a;\n        }\n\n        function skip(code) {\n          if (!eat(code)) {\n            croak(\"Expecting \" + code.join(\", \"));\n          }\n        }\n\n        function isWhitespace(code) {\n          return code == 9 || code == 10 || code == 13 || code == 32;\n        }\n\n        function isDigit(code) {\n          return code >= 48 && code <= 57;\n        }\n\n        function isHexDigit(code) {\n          return code >= 48 && code <= 57 || (code |= 32) >= 97 && code <= 102; // a..f or A..F\n        }\n\n        function isNameStart(code) {\n          return code == 58 || // :\n          code == 95 || // _\n          (code |= 32) >= 97 && code <= 122; // a..z or A..Z\n        }\n\n        function isName(code) {\n          return code == 45 || // -\n          isDigit(code) || isNameStart(code);\n        }\n\n        function xmlComment() {\n          var body = [];\n\n          while (index < data.length) {\n            if (eat(END_COMMENT)) {\n              return call(\"comment\", STRING.apply(0, body));\n            }\n\n            readChar(body);\n          }\n        }\n\n        function xmlTag() {\n          var name, attrs;\n\n          if (eat(QUESTION_MARK)) {\n            xmlDecl();\n          } else if (eat(START_COMMENT)) {\n            xmlComment();\n          } else {\n            name = xmlName();\n            attrs = xmlAttrs(name);\n            stack.push(attrs);\n\n            if (eat(END_SHORT_TAG)) {\n              call(\"enter\", name, attrs, true);\n            } else {\n              skip(GREATER_THAN);\n              call(\"enter\", name, attrs);\n              xmlContent(name);\n\n              if (name != xmlName()) {\n                croak(\"Bad closing tag\");\n              }\n\n              call(\"leave\", name, attrs);\n              skipWhitespace();\n              skip(GREATER_THAN);\n            }\n\n            stack.pop();\n          }\n        }\n\n        function xmlContent(name) {\n          var body = [];\n\n          while (index < data.length) {\n            if (eat(END_TAG)) {\n              return body.length && call(\"text\", STRING.apply(0, body));\n            } else if (eat(START_CDATA)) {\n              while (index < data.length && !eat(END_CDATA)) {\n                readChar(body);\n              }\n            } else if (eat(LESS_THAN)) {\n              if (body.length) {\n                call(\"text\", STRING.apply(0, body));\n              }\n\n              xmlTag();\n              body = [];\n            } else if (eat(AMPERSAND)) {\n              xmlEntity(body);\n            } else {\n              readChar(body);\n            }\n          }\n\n          croak(\"Unclosed tag \" + name);\n        }\n\n        function xmlName() {\n          if (!isNameStart(data[index])) {\n            croak(\"Expecting XML name\");\n          }\n\n          return readAsciiWhile(isName);\n        }\n\n        function xmlString() {\n          var quote = eat(QUOTE) || eat(APOSTROPHE);\n\n          if (!quote) {\n            croak(\"Expecting string\");\n          }\n\n          var body = [];\n\n          while (index < data.length) {\n            if (eat(quote)) {\n              return STRING.apply(0, body);\n            } else if (eat(AMPERSAND)) {\n              xmlEntity(body);\n            } else {\n              readChar(body);\n            }\n          }\n\n          croak(\"Unfinished string\");\n        }\n\n        function xmlEntity(body) {\n          var code;\n\n          if (eat(SHARP)) {\n            if (eat(LOWERCASE_X) || eat(UPPERCASE_X)) {\n              code = parseInt(readAsciiWhile(isHexDigit), 16);\n            } else {\n              code = parseInt(readAsciiWhile(isDigit), 10);\n            }\n\n            if (isNaN(code)) {\n              croak(\"Bad numeric entity\");\n            }\n          } else {\n            var name = xmlName();\n            code = ENTITIES[name];\n\n            if (code === undefined) {\n              croak(\"Unknown entity \" + name);\n            }\n          }\n\n          UCS2(body, code);\n          skip(SEMICOLON);\n        }\n\n        function xmlDecl() {\n          call(\"decl\", xmlName(), xmlAttrs());\n          skip(END_DECLARATION);\n        }\n\n        function xmlAttrs(name) {\n          var map = {\n            $tag: name\n          };\n\n          while (index < data.length) {\n            skipWhitespace();\n            var code = data[index];\n\n            if (code == 63 || code == 62 || code == 47) {\n              // ?, > or /\n              break;\n            }\n\n            map[xmlName()] = (skip(EQUAL), xmlString());\n          }\n\n          return map;\n        }\n\n        function call(what, thing, arg1, arg2) {\n          var f = callbacks && callbacks[what];\n\n          if (f) {\n            f.call(object, thing, arg1, arg2);\n          }\n        } // skip BOM\n\n\n        var tmp = [];\n        readChar(tmp);\n\n        if (tmp[0] != 65279) {\n          index = 0;\n        }\n\n        while (index < data.length) {\n          skipWhitespace();\n          skip(LESS_THAN);\n          xmlTag();\n          skipWhitespace();\n        }\n      } // Exports ================================================================\n\n\n      kendo.util.parseXML = function parseXML() {\n        try {\n          return parse.apply(this, arguments);\n        } catch (ex) {\n          if (ex !== EXIT) {\n            throw ex;\n          }\n        }\n      };\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}