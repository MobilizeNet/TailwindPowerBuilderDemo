{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1003);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  997:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./formatblock\");\n    /***/\n  },\n\n  /***/\n  1003:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(997)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            extend = $.extend,\n            Editor = kendo.ui.editor,\n            dom = Editor.Dom,\n            RangeUtils = Editor.RangeUtils,\n            EditorUtils = Editor.EditorUtils,\n            Command = Editor.Command,\n            ToolTemplate = Editor.ToolTemplate,\n            FormatTool = Editor.FormatTool,\n            BlockFormatFinder = Editor.BlockFormatFinder,\n            textNodes = RangeUtils.textNodes,\n            registerTool = Editor.EditorUtils.registerTool;\n        var ListFormatFinder = BlockFormatFinder.extend({\n          init: function (options) {\n            this.tag = options.tag;\n            this.attr = options.attr;\n            this.altAttr = options.altAttr;\n            var tags = this.tags = [this.tag == 'ul' ? 'ol' : 'ul', this.tag];\n            var format = [{\n              tags: tags,\n              attr: this.attr\n            }];\n\n            if (this.altAttr) {\n              format.push({\n                tags: tags,\n                attr: this.altAttr\n              });\n            }\n\n            BlockFormatFinder.fn.init.call(this, format);\n          },\n          matchesType: function (node) {\n            return dom.attrEquals(node, this.attr) || this.altAttr && dom.attrEquals(node, this.altAttr);\n          },\n          isList: function (node) {\n            return dom.list(node);\n          },\n          isFormatted: function (nodes) {\n            var formatNodes = [];\n            var formatNode, i;\n\n            for (i = 0; i < nodes.length; i++) {\n              formatNode = this.findFormat(nodes[i], this.isList);\n\n              if (formatNode && dom.name(formatNode) == this.tag && this.matchesType(formatNode)) {\n                formatNodes.push(formatNode);\n              }\n            }\n\n            if (formatNodes.length < 1) {\n              return false;\n            }\n\n            if (formatNodes.length != nodes.length) {\n              return false;\n            } // check if sequential lists are selected\n\n\n            for (i = 0; i < formatNodes.length; i++) {\n              if (formatNodes[i].parentNode != formatNode.parentNode) {\n                break;\n              }\n\n              if (formatNodes[i] != formatNode) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          findSuitable: function (nodes) {\n            var candidate = this.findFormat(nodes[0], this.isList);\n\n            if (candidate && dom.name(candidate) == this.tag) {\n              return candidate;\n            }\n\n            return null;\n          }\n        });\n        var ListFormatter = Class.extend({\n          init: function (options, unwrapTag) {\n            var that = this;\n            options = $.isPlainObject(options) ? options : {\n              tag: options,\n              attr: null\n            };\n            that.tag = options.tag;\n            that.attr = options.attr;\n            that.finder = new ListFormatFinder(options);\n            that.unwrapTag = unwrapTag;\n          },\n          isList: function (node) {\n            return dom.list(node);\n          },\n          immutables: function () {\n            return this.editor && !!this.editor.options.immutables;\n          },\n          wrap: function (list, nodes) {\n            var li = dom.create(list.ownerDocument, \"li\"),\n                i,\n                node,\n                isImmutable = this.immutables() ? Editor.Immutables.immutable : $.noop;\n\n            for (i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n\n              if (dom.is(node, 'li')) {\n                list.appendChild(node);\n                continue;\n              }\n\n              if (this.isList(node)) {\n                while (node.firstChild) {\n                  list.appendChild(node.firstChild);\n                }\n\n                continue;\n              }\n\n              if (dom.is(node, \"td\")) {\n                while (node.firstChild) {\n                  li.appendChild(node.firstChild);\n                }\n\n                list.appendChild(li);\n                node.appendChild(list);\n                list = list.cloneNode(false);\n                li = li.cloneNode(false);\n                continue;\n              }\n\n              li.appendChild(node);\n\n              if (dom.isBlock(node)) {\n                list.appendChild(li);\n\n                if (!isImmutable(node)) {\n                  dom.unwrap(node);\n                }\n\n                li = li.cloneNode(false);\n              }\n            }\n\n            if (li.firstChild) {\n              list.appendChild(li);\n            }\n          },\n          containsAny: function (parent, nodes) {\n            for (var i = 0; i < nodes.length; i++) {\n              if (dom.isAncestorOrSelf(parent, nodes[i])) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          suitable: function (candidate, nodes) {\n            if (candidate.className == \"k-marker\") {\n              var sibling = candidate.nextSibling;\n\n              if (sibling && dom.isBlock(sibling)) {\n                return false;\n              }\n\n              sibling = candidate.previousSibling;\n\n              if (sibling && dom.isBlock(sibling)) {\n                return false;\n              }\n            }\n\n            return this.containsAny(candidate, nodes) || dom.isInline(candidate) || candidate.nodeType == 3;\n          },\n          _parentLists: function (node) {\n            var editable = dom.closestEditable(node);\n            return $(node).parentsUntil(editable, \"ul,ol\");\n          },\n          split: function (range) {\n            var nodes = textNodes(range);\n            var start, end, parents;\n\n            if (nodes.length) {\n              start = dom.parentOfType(nodes[0], ['li']);\n              end = dom.parentOfType(nodes[nodes.length - 1], ['li']);\n              range.setStartBefore(start);\n              range.setEndAfter(end);\n\n              for (var i = 0, l = nodes.length; i < l; i++) {\n                var formatNode = this.finder.findFormat(nodes[i]);\n\n                if (formatNode) {\n                  parents = this._parentLists(formatNode);\n\n                  if (parents.length) {\n                    RangeUtils.split(range, parents.last()[0], true);\n                  } else {\n                    RangeUtils.split(range, formatNode, true);\n                  }\n                }\n              }\n            }\n          },\n          merge: function (tag, formatNode) {\n            var prev = formatNode.previousSibling,\n                next;\n\n            while (prev && (prev.className == \"k-marker\" || prev.nodeType == 3 && dom.isWhitespace(prev))) {\n              prev = prev.previousSibling;\n            } // merge with previous list\n\n\n            if (prev && dom.name(prev) == tag && this.finder.matchesType(prev)) {\n              while (formatNode.firstChild) {\n                prev.appendChild(formatNode.firstChild);\n              }\n\n              dom.remove(formatNode);\n              formatNode = prev;\n            }\n\n            next = formatNode.nextSibling;\n\n            while (next && (next.className == \"k-marker\" || next.nodeType == 3 && dom.isWhitespace(next))) {\n              next = next.nextSibling;\n            } // merge with next list\n\n\n            if (next && dom.name(next) == tag && this.finder.matchesType(next)) {\n              while (formatNode.lastChild) {\n                next.insertBefore(formatNode.lastChild, next.firstChild);\n              }\n\n              dom.remove(formatNode);\n            }\n          },\n          breakable: function (node) {\n            return node != node.ownerDocument.body && !/table|tbody|thead|tr|td/.test(dom.name(node)) && !node.attributes.contentEditable;\n          },\n          findSuitableNode: function (nodes) {\n            var that = this,\n                finder = that.finder,\n                tag = that.tag,\n                formatNode;\n            formatNode = finder.findSuitable(nodes);\n\n            if (!formatNode) {\n              // Find the opposite tag\n              finder = new ListFormatFinder({\n                tag: tag == \"ul\" ? \"ol\" : \"ul\"\n              });\n              formatNode = finder.findSuitable(nodes);\n            }\n\n            if (!formatNode) {\n              // Find the same tag\n              finder = new ListFormatFinder({\n                tag: tag\n              });\n              formatNode = finder.findSuitable(nodes);\n              formatNode = formatNode && that.finder.matchesType(formatNode) ? null : formatNode;\n            }\n\n            return formatNode;\n          },\n          applyOnSection: function (section, nodes) {\n            var tag = this.tag;\n            var attr = this.attr;\n            var commonAncestor = dom.closestSplittableParent(nodes);\n            var ancestors = [];\n            var formatNode = this.findSuitableNode(nodes);\n            var childNodes;\n\n            if (/table|tbody|thead/.test(dom.name(commonAncestor))) {\n              childNodes = $.map(nodes, function (node) {\n                return dom.parentOfType(node, [\"td\"]);\n              });\n            } else {\n              childNodes = dom.significantChildNodes(commonAncestor);\n\n              if ($.grep(childNodes, dom.isBlock).length) {\n                childNodes = $.grep(childNodes, function (node) {\n                  return this.containsAny(node, nodes);\n                }.bind(this));\n              }\n\n              if (!childNodes.length) {\n                childNodes = nodes;\n              }\n            }\n\n            function pushAncestor() {\n              ancestors.push(this);\n            }\n\n            for (var i = 0; i < childNodes.length; i++) {\n              var child = childNodes[i];\n              var suitable = (!formatNode || !dom.isAncestorOrSelf(formatNode, child)) && this.suitable(child, nodes);\n\n              if (!suitable) {\n                continue;\n              }\n\n              if (formatNode && this.isList(child)) {\n                // merging lists\n                $.each(child.children, pushAncestor);\n                dom.remove(child);\n              } else {\n                ancestors.push(child);\n              }\n            }\n\n            if (ancestors.length == childNodes.length && this.breakable(commonAncestor)) {\n              ancestors = [commonAncestor];\n            }\n\n            if (!formatNode) {\n              formatNode = dom.create(commonAncestor.ownerDocument, tag, attr);\n\n              if (dom.isBlock(ancestors[0])) {\n                dom.mergeAttributes(ancestors[0], formatNode);\n              }\n\n              dom.insertBefore(formatNode, ancestors[0]);\n            }\n\n            this.wrap(formatNode, ancestors);\n\n            while (dom.isBom(formatNode.nextSibling)) {\n              dom.remove(formatNode.nextSibling);\n            }\n\n            if (!this.finder.matchesType(formatNode)) {\n              formatNode.removeAttribute(\"type\");\n              formatNode.style.listStyleType = \"\";\n              dom.mergeAttributes(dom.create(commonAncestor.ownerDocument, tag, attr), formatNode, true);\n            }\n\n            if (formatNode && formatNode.getAttribute(\"type\") === \"\") {\n              formatNode.removeAttribute(\"type\");\n            }\n\n            if (!dom.is(formatNode, tag)) {\n              dom.changeTag(formatNode, tag);\n            }\n\n            this.merge(tag, formatNode);\n          },\n          apply: function (nodes) {\n            var i = 0,\n                sections = [],\n                lastSection,\n                lastNodes,\n                section,\n                node,\n                l = nodes.length,\n                immutableParent = this.immutables() ? Editor.Immutables.immutableParent : $.noop;\n\n            function addLastSection() {\n              if (lastSection) {\n                sections.push({\n                  section: lastSection,\n                  nodes: lastNodes\n                });\n              }\n            } // split nodes into sections that need to be different lists\n\n\n            for (i = 0; i < l; i++) {\n              node = immutableParent(nodes[i]) || nodes[i];\n              section = dom.closestEditable(node, [\"td\", \"th\", \"body\"]);\n\n              if (!lastSection || section != lastSection) {\n                addLastSection();\n                lastNodes = [node];\n                lastSection = section;\n              } else {\n                lastNodes.push(node);\n              }\n            }\n\n            addLastSection();\n\n            for (i = 0; i < sections.length; i++) {\n              this.applyOnSection(sections[i].section, sections[i].nodes);\n            }\n          },\n          unwrap: function (ul) {\n            var fragment = ul.ownerDocument.createDocumentFragment(),\n                unwrapTag = this.unwrapTag,\n                parents,\n                li,\n                p,\n                child;\n\n            for (li = ul.firstChild; li; li = li.nextSibling) {\n              p = dom.create(ul.ownerDocument, unwrapTag || 'p');\n\n              while (li.firstChild) {\n                child = li.firstChild;\n\n                if (dom.isBlock(child)) {\n                  if (p.firstChild) {\n                    fragment.appendChild(p);\n                    p = dom.create(ul.ownerDocument, unwrapTag || 'p');\n                  }\n\n                  fragment.appendChild(child);\n                } else {\n                  p.appendChild(child);\n                }\n              }\n\n              if (p.firstChild) {\n                fragment.appendChild(p);\n              }\n            }\n\n            parents = this._parentLists(ul);\n\n            if (parents[0]) {\n              dom.insertAfter(fragment, parents.last()[0]);\n              parents.last().remove();\n            } else {\n              dom.insertAfter(fragment, ul);\n            }\n\n            dom.remove(ul);\n          },\n          remove: function (nodes) {\n            var formatNode;\n\n            for (var i = 0, l = nodes.length; i < l; i++) {\n              formatNode = this.finder.findFormat(nodes[i]);\n\n              if (formatNode) {\n                this.unwrap(formatNode);\n              }\n            }\n          },\n          toggle: function (range) {\n            var that = this,\n                nodes = textNodes(range),\n                ancestor = range.commonAncestorContainer;\n\n            if (!nodes.length) {\n              range.selectNodeContents(ancestor);\n              nodes = textNodes(range);\n\n              if (!nodes.length) {\n                var text = ancestor.ownerDocument.createTextNode(\"\");\n                range.startContainer.appendChild(text);\n                nodes = [text];\n                range.selectNode(text.parentNode);\n              }\n            }\n\n            nodes = dom.filterBy(nodes, dom.htmlIndentSpace, true);\n\n            if (that.finder.isFormatted(nodes)) {\n              that.split(range);\n              that.remove(nodes);\n            } else {\n              that.apply(nodes);\n            }\n          }\n        });\n        var ListCommand = Command.extend({\n          init: function (options) {\n            options.formatter = new ListFormatter({\n              tag: options.tag,\n              attr: options.attr\n            });\n            Command.fn.init.call(this, options);\n          }\n        });\n        var ListTool = FormatTool.extend({\n          init: function (options) {\n            this.options = options;\n            FormatTool.fn.init.call(this, extend(options, {\n              finder: new ListFormatFinder(options)\n            }));\n          },\n          command: function (commandArguments) {\n            return new ListCommand(extend(commandArguments, {\n              tag: this.options.tag,\n              attr: this.options.attr\n            }));\n          }\n        });\n        extend(Editor, {\n          ListFormatFinder: ListFormatFinder,\n          ListFormatter: ListFormatter,\n          ListCommand: ListCommand,\n          ListTool: ListTool\n        });\n        registerTool(\"insertUnorderedList\", new ListTool({\n          tag: 'ul',\n          attr: {\n            style: {\n              listStyleType: \"\"\n            },\n            type: \"\"\n          },\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Insert unordered list\"\n          })\n        }));\n        registerTool(\"insertOrderedList\", new ListTool({\n          tag: 'ol',\n          attr: {\n            style: {\n              listStyleType: \"\"\n            },\n            type: \"\"\n          },\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Insert ordered list\"\n          })\n        }));\n        registerTool(\"insertUpperRomanList\", new ListTool({\n          tag: 'ol',\n          attr: {\n            style: {\n              listStyleType: \"upper-roman\"\n            }\n          },\n          altAttr: {\n            type: \"I\"\n          },\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Insert upper roman list\"\n          })\n        }));\n        registerTool(\"insertLowerRomanList\", new ListTool({\n          tag: 'ol',\n          attr: {\n            style: {\n              listStyleType: \"lower-roman\"\n            }\n          },\n          altAttr: {\n            type: \"i\"\n          },\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Insert lower roman list\"\n          })\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}