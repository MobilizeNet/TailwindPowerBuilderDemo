{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(915);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  911:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./math\");\n    /***/\n  },\n\n  /***/\n  915:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(893), __webpack_require__(911)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            Point = diagram.Point,\n            Rect = diagram.Rect,\n            Matrix = diagram.Matrix,\n            Utils = diagram.Utils,\n            isNumber = Utils.isNumber,\n            isString = Utils.isString,\n            MatrixVector = diagram.MatrixVector,\n            g = kendo.geometry,\n            d = kendo.drawing,\n            defined = d.util.defined,\n            inArray = $.inArray; // Constants ==============================================================\n\n        var TRANSPARENT = \"transparent\",\n            Markers = {\n          none: \"none\",\n          arrowStart: \"ArrowStart\",\n          filledCircle: \"FilledCircle\",\n          arrowEnd: \"ArrowEnd\"\n        },\n            FULL_CIRCLE_ANGLE = 360,\n            START = \"start\",\n            END = \"end\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            X = \"x\",\n            Y = \"y\";\n        diagram.Markers = Markers;\n\n        function diffNumericOptions(options, fields) {\n          var elementOptions = this.options;\n          var hasChanges = false;\n          var value, field;\n\n          for (var i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n\n            if (isNumber(value) && elementOptions[field] !== value) {\n              elementOptions[field] = value;\n              hasChanges = true;\n            }\n          }\n\n          return hasChanges;\n        }\n\n        var Scale = Class.extend({\n          init: function (x, y) {\n            this.x = x;\n            this.y = y;\n          },\n          toMatrix: function () {\n            return Matrix.scaling(this.x, this.y);\n          },\n          toString: function () {\n            return kendo.format(\"scale({0},{1})\", this.x, this.y);\n          },\n          invert: function () {\n            return new Scale(1 / this.x, 1 / this.y);\n          }\n        });\n        var Translation = Class.extend({\n          init: function (x, y) {\n            this.x = x;\n            this.y = y;\n          },\n          toMatrixVector: function () {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n          },\n          toMatrix: function () {\n            return Matrix.translation(this.x, this.y);\n          },\n          toString: function () {\n            return kendo.format(\"translate({0},{1})\", this.x, this.y);\n          },\n          plus: function (delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n          },\n          times: function (factor) {\n            this.x *= factor;\n            this.y *= factor;\n          },\n          length: function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n          },\n          normalize: function () {\n            if (this.Length === 0) {\n              return;\n            }\n\n            this.times(1 / this.length());\n          },\n          invert: function () {\n            return new Translation(-this.x, -this.y);\n          }\n        });\n        var Rotation = Class.extend({\n          init: function (angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n          },\n          toString: function () {\n            if (this.x && this.y) {\n              return kendo.format(\"rotate({0},{1},{2})\", this.angle, this.x, this.y);\n            } else {\n              return kendo.format(\"rotate({0})\", this.angle);\n            }\n          },\n          toMatrix: function () {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n          },\n          center: function () {\n            return new Point(this.x, this.y);\n          },\n          invert: function () {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n          }\n        });\n        Rotation.ZERO = new Rotation(0);\n\n        Rotation.create = function (rotation) {\n          return new Rotation(rotation.angle, rotation.x, rotation.y);\n        };\n\n        Rotation.parse = function (str) {\n          var values = str.slice(1, str.length - 1).split(\",\"),\n              angle = values[0],\n              x = values[1],\n              y = values[2];\n          var rotation = new Rotation(angle, x, y);\n          return rotation;\n        };\n\n        var CompositeTransform = Class.extend({\n          init: function (x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n\n            if (scaleX !== undefined && scaleY !== undefined) {\n              this.scale = new Scale(scaleX, scaleY);\n            }\n\n            if (angle !== undefined) {\n              this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n          },\n          toString: function () {\n            var toString = function (transform) {\n              return transform ? transform.toString() : \"\";\n            };\n\n            return toString(this.translate) + toString(this.rotate) + toString(this.scale);\n          },\n          render: function (visual) {\n            visual._transform = this;\n\n            visual._renderTransform();\n          },\n          toMatrix: function () {\n            var m = Matrix.unit();\n\n            if (this.translate) {\n              m = m.times(this.translate.toMatrix());\n            }\n\n            if (this.rotate) {\n              m = m.times(this.rotate.toMatrix());\n            }\n\n            if (this.scale) {\n              m = m.times(this.scale.toMatrix());\n            }\n\n            return m;\n          },\n          invert: function () {\n            var rotate = this.rotate ? this.rotate.invert() : undefined,\n                rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(),\n                scale = this.scale ? this.scale.invert() : undefined,\n                scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n            var translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            var translate = new Translation(translatePoint.x, translatePoint.y);\n            var transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n            return transform;\n          }\n        });\n        var AutoSizeableMixin = {\n          _setScale: function () {\n            var options = this.options;\n            var originWidth = this._originWidth;\n            var originHeight = this._originHeight;\n            var scaleX = options.width / originWidth;\n            var scaleY = options.height / originHeight;\n\n            if (!isNumber(scaleX)) {\n              scaleX = 1;\n            }\n\n            if (!isNumber(scaleY)) {\n              scaleY = 1;\n            }\n\n            this._transform.scale = new Scale(scaleX, scaleY);\n          },\n          _setTranslate: function () {\n            var options = this.options;\n            var x = options.x || 0;\n            var y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n          },\n          _initSize: function () {\n            var options = this.options;\n            var transform = false;\n\n            if (options.autoSize !== false && (defined(options.width) || defined(options.height))) {\n              this._measure(true);\n\n              this._setScale();\n\n              transform = true;\n            }\n\n            if (defined(options.x) || defined(options.y)) {\n              this._setTranslate();\n\n              transform = true;\n            }\n\n            if (transform) {\n              this._renderTransform();\n            }\n          },\n          _updateSize: function (options) {\n            var update = false;\n\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n              update = true;\n\n              this._measure(true);\n\n              this._setScale();\n            }\n\n            if (this._diffNumericOptions(options, [X, Y])) {\n              update = true;\n\n              this._setTranslate();\n            }\n\n            if (update) {\n              this._renderTransform();\n            }\n\n            return update;\n          }\n        };\n        var Element = Class.extend({\n          init: function (options) {\n            var element = this;\n            element.options = deepExtend({}, element.options, options);\n            element.id = element.options.id;\n            element._originSize = Rect.empty();\n            element._transform = new CompositeTransform();\n          },\n          visible: function (value) {\n            return this.drawingContainer().visible(value);\n          },\n          redraw: function (options) {\n            if (options && options.id) {\n              this.id = options.id;\n            }\n          },\n          position: function (x, y) {\n            var options = this.options;\n\n            if (!defined(x)) {\n              return new Point(options.x, options.y);\n            }\n\n            if (defined(y)) {\n              options.x = x;\n              options.y = y;\n            } else if (x instanceof Point) {\n              options.x = x.x;\n              options.y = x.y;\n            }\n\n            this._transform.translate = new Translation(options.x, options.y);\n\n            this._renderTransform();\n          },\n          rotate: function (angle, center) {\n            if (defined(angle)) {\n              this._transform.rotate = new Rotation(angle, center.x, center.y);\n\n              this._renderTransform();\n            }\n\n            return this._transform.rotate || Rotation.ZERO;\n          },\n          drawingContainer: function () {\n            return this.drawingElement;\n          },\n          _renderTransform: function () {\n            var matrix = this._transform.toMatrix();\n\n            this.drawingContainer().transform(new g.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n          },\n          _hover: function () {},\n          _diffNumericOptions: diffNumericOptions,\n          _measure: function (force) {\n            var rect;\n\n            if (!this._measured || force) {\n              var box = this._boundingBox() || new g.Rect();\n              var startPoint = box.topLeft();\n              rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n              this._originSize = rect;\n              this._originWidth = rect.width;\n              this._originHeight = rect.height;\n              this._measured = true;\n            } else {\n              rect = this._originSize;\n            }\n\n            return rect;\n          },\n          _boundingBox: function () {\n            return this.drawingElement.rawBBox();\n          }\n        });\n        var VisualBase = Element.extend({\n          init: function (options) {\n            Element.fn.init.call(this, options);\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n          },\n          options: {\n            stroke: {\n              color: \"gray\",\n              width: 1\n            },\n            fill: {\n              color: TRANSPARENT\n            }\n          },\n          fill: function (color, opacity) {\n            this._fill({\n              color: getColor(color),\n              opacity: opacity\n            });\n          },\n          stroke: function (color, width, opacity) {\n            this._stroke({\n              color: getColor(color),\n              width: width,\n              opacity: opacity\n            });\n          },\n          redraw: function (options) {\n            if (options) {\n              var stroke = options.stroke;\n              var fill = options.fill;\n\n              if (stroke) {\n                this._stroke(normalizeDrawingOptions(stroke));\n              }\n\n              if (fill) {\n                this._fill(normalizeDrawingOptions(fill));\n              }\n\n              Element.fn.redraw.call(this, options);\n            }\n          },\n          _hover: function (show) {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var hover = options.hover;\n\n            if (hover && hover.fill) {\n              var fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n              drawingElement.fill(fill.color, fill.opacity);\n            }\n          },\n          _stroke: function (strokeOptions) {\n            var options = this.options;\n            deepExtend(options, {\n              stroke: strokeOptions\n            });\n            strokeOptions = options.stroke;\n            var stroke = null;\n\n            if (strokeOptions.width > 0) {\n              stroke = {\n                color: strokeOptions.color,\n                width: strokeOptions.width,\n                opacity: strokeOptions.opacity,\n                dashType: strokeOptions.dashType\n              };\n            }\n\n            this.drawingElement.options.set(\"stroke\", stroke);\n          },\n          _fill: function (fillOptions) {\n            var options = this.options;\n            deepExtend(options, {\n              fill: fillOptions || {}\n            });\n            var fill = options.fill;\n\n            if (fill.gradient) {\n              var gradient = fill.gradient;\n              var GradientClass = gradient.type === \"radial\" ? d.RadialGradient : d.LinearGradient;\n              this.drawingElement.fill(new GradientClass(gradient));\n            } else {\n              this.drawingElement.fill(fill.color, fill.opacity);\n            }\n          }\n        });\n        var TextBlock = VisualBase.extend({\n          init: function (options) {\n            options = this._textColor(options);\n            VisualBase.fn.init.call(this, options);\n\n            this._font();\n\n            this._initText();\n\n            this._initSize();\n          },\n          options: {\n            fontSize: 15,\n            fontFamily: \"sans-serif\",\n            stroke: {\n              width: 0\n            },\n            fill: {\n              color: \"black\"\n            },\n            autoSize: true\n          },\n          _initText: function () {\n            var options = this.options;\n            this.drawingElement = new d.Text(defined(options.text) ? options.text : \"\", new g.Point(), {\n              font: options.font\n            });\n\n            this._fill();\n\n            this._stroke();\n          },\n          _textColor: function (options) {\n            if (options && options.color) {\n              options = deepExtend({}, options, {\n                fill: {\n                  color: options.color\n                }\n              });\n            }\n\n            return options;\n          },\n          _font: function () {\n            var options = this.options;\n\n            if (options.fontFamily && defined(options.fontSize)) {\n              var fontOptions = [];\n\n              if (options.fontStyle) {\n                fontOptions.push(options.fontStyle);\n              }\n\n              if (options.fontWeight) {\n                fontOptions.push(options.fontWeight);\n              }\n\n              fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? \"px\" : \"\"));\n              fontOptions.push(options.fontFamily);\n              options.font = fontOptions.join(\" \");\n            } else {\n              delete options.font;\n            }\n          },\n          content: function (text) {\n            return this.drawingElement.content(text);\n          },\n          redraw: function (options) {\n            if (options) {\n              var sizeChanged = false;\n              var textOptions = this.options;\n              options = this._textColor(options);\n              VisualBase.fn.redraw.call(this, options);\n\n              if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                deepExtend(textOptions, {\n                  fontFamily: options.fontFamily,\n                  fontSize: options.fontSize,\n                  fontStyle: options.fontStyle,\n                  fontWeight: options.fontWeight\n                });\n\n                this._font();\n\n                this.drawingElement.options.set(\"font\", textOptions.font);\n                sizeChanged = true;\n              }\n\n              if (options.text) {\n                this.content(options.text);\n                sizeChanged = true;\n              }\n\n              if (!this._updateSize(options) && sizeChanged) {\n                this._initSize();\n              }\n            }\n          }\n        });\n        deepExtend(TextBlock.fn, AutoSizeableMixin);\n        var Rectangle = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n\n            this._initPath();\n\n            this._setPosition();\n          },\n          _setPosition: function () {\n            var options = this.options;\n            var x = options.x;\n            var y = options.y;\n\n            if (defined(x) || defined(y)) {\n              this.position(x || 0, y || 0);\n            }\n          },\n          redraw: function (options) {\n            if (options) {\n              VisualBase.fn.redraw.call(this, options);\n\n              if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                this._drawPath();\n              }\n\n              if (this._diffNumericOptions(options, [X, Y])) {\n                this._setPosition();\n              }\n            }\n          },\n          _initPath: function () {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n              stroke: options.stroke,\n              closed: true\n            });\n\n            this._fill();\n\n            this._drawPath();\n          },\n          _drawPath: function () {\n            var drawingElement = this.drawingElement;\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var width = sizeOptions.width;\n            var height = sizeOptions.height;\n            drawingElement.segments.elements([createSegment(0, 0), createSegment(width, 0), createSegment(width, height), createSegment(0, height)]);\n          }\n        });\n        var MarkerBase = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n            var anchor = this.options.anchor;\n            this.anchor = new g.Point(anchor.x, anchor.y);\n            this.createElement();\n          },\n          options: {\n            stroke: {\n              color: TRANSPARENT,\n              width: 0\n            },\n            fill: {\n              color: \"black\"\n            }\n          },\n          _transformToPath: function (point, path) {\n            var transform = path.transform();\n\n            if (point && transform) {\n              point = point.transformCopy(transform);\n            }\n\n            return point;\n          },\n          redraw: function (options) {\n            if (options) {\n              if (options.position) {\n                this.options.position = options.position;\n              }\n\n              VisualBase.fn.redraw.call(this, options);\n            }\n          }\n        });\n        var CircleMarker = MarkerBase.extend({\n          options: {\n            radius: 4,\n            anchor: {\n              x: 0,\n              y: 0\n            }\n          },\n          createElement: function () {\n            var options = this.options;\n            this.drawingElement = new d.Circle(new g.Circle(this.anchor, options.radius), {\n              fill: options.fill,\n              stroke: options.stroke\n            });\n          },\n          positionMarker: function (path) {\n            var options = this.options;\n            var position = options.position;\n            var segments = path.segments;\n            var targetSegment;\n            var point;\n\n            if (position == START) {\n              targetSegment = segments[0];\n            } else {\n              targetSegment = segments[segments.length - 1];\n            }\n\n            if (targetSegment) {\n              point = this._transformToPath(targetSegment.anchor(), path);\n              this.drawingElement.transform(g.transform().translate(point.x, point.y));\n            }\n          }\n        });\n        var ArrowMarker = MarkerBase.extend({\n          options: {\n            path: \"M 0 0 L 10 5 L 0 10 L 3 5 z\",\n            anchor: {\n              x: 10,\n              y: 5\n            }\n          },\n          createElement: function () {\n            var options = this.options;\n            this.drawingElement = d.Path.parse(options.path, {\n              fill: options.fill,\n              stroke: options.stroke\n            });\n          },\n          positionMarker: function (path) {\n            var points = this._linePoints(path);\n\n            var start = points.start;\n            var end = points.end;\n            var transform = g.transform();\n\n            if (start) {\n              transform.rotate(lineAngle(start, end), end);\n            }\n\n            if (end) {\n              var anchor = this.anchor;\n              var translate = end.clone().translate(-anchor.x, -anchor.y);\n              transform.translate(translate.x, translate.y);\n            }\n\n            this.drawingElement.transform(transform);\n          },\n          _linePoints: function (path) {\n            var options = this.options;\n            var segments = path.segments;\n            var startPoint, endPoint, targetSegment;\n\n            if (options.position == START) {\n              targetSegment = segments[0];\n\n              if (targetSegment) {\n                endPoint = targetSegment.anchor();\n                startPoint = targetSegment.controlOut();\n                var nextSegment = segments[1];\n\n                if (!startPoint && nextSegment) {\n                  startPoint = nextSegment.anchor();\n                }\n              }\n            } else {\n              targetSegment = segments[segments.length - 1];\n\n              if (targetSegment) {\n                endPoint = targetSegment.anchor();\n                startPoint = targetSegment.controlIn();\n                var prevSegment = segments[segments.length - 2];\n\n                if (!startPoint && prevSegment) {\n                  startPoint = prevSegment.anchor();\n                }\n              }\n            }\n\n            if (endPoint) {\n              return {\n                start: this._transformToPath(startPoint, path),\n                end: this._transformToPath(endPoint, path)\n              };\n            }\n          }\n        });\n        var MarkerPathMixin = {\n          _getPath: function (position) {\n            var path = this.drawingElement;\n\n            if (path instanceof d.MultiPath) {\n              if (position == START) {\n                path = path.paths[0];\n              } else {\n                path = path.paths[path.paths.length - 1];\n              }\n            }\n\n            if (path && path.segments.length) {\n              return path;\n            }\n          },\n          _normalizeMarkerOptions: function (options) {\n            var startCap = options.startCap;\n            var endCap = options.endCap;\n\n            if (isString(startCap)) {\n              options.startCap = {\n                type: startCap\n              };\n            }\n\n            if (isString(endCap)) {\n              options.endCap = {\n                type: endCap\n              };\n            }\n          },\n          _removeMarker: function (position) {\n            var marker = this._markers[position];\n\n            if (marker) {\n              this.drawingContainer().remove(marker.drawingElement);\n              delete this._markers[position];\n            }\n          },\n          _createMarkers: function () {\n            var options = this.options;\n\n            this._normalizeMarkerOptions(options);\n\n            this._markers = {};\n            this._markers[START] = this._createMarker(options.startCap, START);\n            this._markers[END] = this._createMarker(options.endCap, END);\n          },\n          _createMarker: function (options, position) {\n            var type = (options || {}).type;\n\n            var path = this._getPath(position);\n\n            var markerType, marker;\n\n            if (!path) {\n              this._removeMarker(position);\n\n              return;\n            }\n\n            if (type == Markers.filledCircle) {\n              markerType = CircleMarker;\n            } else if (type == Markers.arrowStart || type == Markers.arrowEnd) {\n              markerType = ArrowMarker;\n            } else {\n              this._removeMarker(position);\n            }\n\n            if (markerType) {\n              marker = new markerType(deepExtend({}, options, {\n                position: position\n              }));\n              marker.positionMarker(path);\n              this.drawingContainer().append(marker.drawingElement);\n              return marker;\n            }\n          },\n          _positionMarker: function (position) {\n            var marker = this._markers[position];\n\n            if (marker) {\n              var path = this._getPath(position);\n\n              if (path) {\n                marker.positionMarker(path);\n              } else {\n                this._removeMarker(position);\n              }\n            }\n          },\n          _capMap: {\n            start: \"startCap\",\n            end: \"endCap\"\n          },\n          _redrawMarker: function (pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n\n            var pathOptions = this.options;\n            var cap = this._capMap[position];\n            var pathCapType = (pathOptions[cap] || {}).type;\n            var optionsCap = options[cap];\n            var created = false;\n\n            if (optionsCap) {\n              pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n\n              if (optionsCap.type && pathCapType != optionsCap.type) {\n                this._removeMarker(position);\n\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n              } else if (this._markers[position]) {\n                this._markers[position].redraw(optionsCap);\n              }\n            } else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n              this._markers[position] = this._createMarker(pathOptions[cap], position);\n              created = true;\n            }\n\n            return created;\n          },\n          _redrawMarkers: function (pathChange, options) {\n            if (!this._redrawMarker(pathChange, START, options) && pathChange) {\n              this._positionMarker(START);\n            }\n\n            if (!this._redrawMarker(pathChange, END, options) && pathChange) {\n              this._positionMarker(END);\n            }\n          }\n        };\n        var Path = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n\n            this._createElements();\n\n            this._initSize();\n          },\n          options: {\n            autoSize: true\n          },\n          drawingContainer: function () {\n            return this.container;\n          },\n          data: function (value) {\n            var options = this.options;\n\n            if (value) {\n              if (options.data != value) {\n                options.data = value;\n\n                this._setData(value);\n\n                this._initSize();\n\n                this._redrawMarkers(true, {});\n              }\n            } else {\n              return options.data;\n            }\n          },\n          redraw: function (options) {\n            if (options) {\n              VisualBase.fn.redraw.call(this, options);\n              var pathOptions = this.options;\n              var data = options.data;\n\n              if (defined(data) && pathOptions.data != data) {\n                pathOptions.data = data;\n\n                this._setData(data);\n\n                if (!this._updateSize(options)) {\n                  this._initSize();\n                }\n\n                this._redrawMarkers(true, options);\n              } else {\n                this._updateSize(options);\n\n                this._redrawMarkers(false, options);\n              }\n            }\n          },\n          _createElements: function () {\n            var options = this.options;\n            this.drawingElement = d.Path.parse(options.data || \"\", {\n              stroke: options.stroke\n            });\n\n            this._fill();\n\n            this.container.append(this.drawingElement);\n\n            this._createMarkers();\n          },\n          _setData: function (data) {\n            var drawingElement = this.drawingElement;\n            var multipath = d.Path.parse(data || \"\");\n            var paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n          }\n        });\n        deepExtend(Path.fn, AutoSizeableMixin);\n        deepExtend(Path.fn, MarkerPathMixin);\n        var Line = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n\n            this._initPath();\n\n            this._createMarkers();\n          },\n          drawingContainer: function () {\n            return this.container;\n          },\n          redraw: function (options) {\n            if (options) {\n              options = options || {};\n              var from = options.from;\n              var to = options.to;\n\n              if (from) {\n                this.options.from = from;\n              }\n\n              if (to) {\n                this.options.to = to;\n              }\n\n              if (from || to) {\n                this._drawPath();\n\n                this._redrawMarkers(true, options);\n              } else {\n                this._redrawMarkers(false, options);\n              }\n\n              VisualBase.fn.redraw.call(this, options);\n            }\n          },\n          _initPath: function () {\n            var options = this.options;\n            var drawingElement = this.drawingElement = new d.Path({\n              stroke: options.stroke\n            });\n\n            this._fill();\n\n            this._drawPath();\n\n            this.container.append(drawingElement);\n          },\n          _drawPath: function () {\n            var options = this.options;\n            var drawingElement = this.drawingElement;\n            var from = options.from || new Point();\n            var to = options.to || new Point();\n            drawingElement.segments.elements([createSegment(from.x, from.y), createSegment(to.x, to.y)]);\n          }\n        });\n        deepExtend(Line.fn, MarkerPathMixin);\n        var Polyline = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n\n            this._initPath();\n\n            this._createMarkers();\n          },\n          drawingContainer: function () {\n            return this.container;\n          },\n          points: function (points) {\n            var options = this.options;\n\n            if (points) {\n              options.points = points;\n\n              this._updatePath();\n            } else {\n              return options.points;\n            }\n          },\n          redraw: function (options) {\n            if (options) {\n              var points = options.points;\n              VisualBase.fn.redraw.call(this, options);\n\n              if (points && this._pointsDiffer(points)) {\n                this.points(points);\n\n                this._redrawMarkers(true, options);\n              } else {\n                this._redrawMarkers(false, options);\n              }\n            }\n          },\n          _initPath: function () {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n              stroke: options.stroke\n            });\n\n            this._fill();\n\n            this.container.append(this.drawingElement);\n\n            if (options.points) {\n              this._updatePath();\n            }\n          },\n          _pointsDiffer: function (points) {\n            var currentPoints = this.options.points;\n            var differ = currentPoints.length !== points.length;\n\n            if (!differ) {\n              for (var i = 0; i < points.length; i++) {\n                if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                  differ = true;\n                  break;\n                }\n              }\n            }\n\n            return differ;\n          },\n          _updatePath: function () {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var points = options.points;\n            var segments = [];\n            var point;\n\n            for (var i = 0; i < points.length; i++) {\n              point = points[i];\n              segments.push(createSegment(point.x, point.y));\n            }\n\n            drawingElement.segments.elements(segments);\n          },\n          options: {\n            points: []\n          }\n        });\n        deepExtend(Polyline.fn, MarkerPathMixin);\n        var Image = Element.extend({\n          init: function (options) {\n            Element.fn.init.call(this, options);\n\n            this._initImage();\n          },\n          redraw: function (options) {\n            if (options) {\n              if (options.source) {\n                this.drawingElement.src(options.source);\n              }\n\n              if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                this.drawingElement.rect(this._rect());\n              }\n\n              Element.fn.redraw.call(this, options);\n            }\n          },\n          _initImage: function () {\n            var options = this.options;\n\n            var rect = this._rect();\n\n            this.drawingElement = new d.Image(options.source, rect, {});\n          },\n          _rect: function () {\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var origin = new g.Point(sizeOptions.x, sizeOptions.y);\n            var size = new g.Size(sizeOptions.width, sizeOptions.height);\n            return new g.Rect(origin, size);\n          }\n        });\n        var Group = Element.extend({\n          init: function (options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Group();\n\n            this._initSize();\n          },\n          options: {\n            autoSize: false\n          },\n          append: function (visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n          },\n          remove: function (visual) {\n            if (this._remove(visual)) {\n              this._childrenChange = true;\n            }\n          },\n          _remove: function (visual) {\n            var index = inArray(visual, this.children);\n\n            if (index >= 0) {\n              this.drawingElement.removeAt(index);\n              this.children.splice(index, 1);\n              return true;\n            }\n          },\n          clear: function () {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n          },\n          toFront: function (visuals) {\n            var visual;\n\n            for (var i = 0; i < visuals.length; i++) {\n              visual = visuals[i];\n\n              if (this._remove(visual)) {\n                this.append(visual);\n              }\n            }\n          },\n          //TO DO: add drawing group support for moving and inserting children\n          toBack: function (visuals) {\n            this._reorderChildren(visuals, 0);\n          },\n          toIndex: function (visuals, indices) {\n            this._reorderChildren(visuals, indices);\n          },\n          _reorderChildren: function (visuals, indices) {\n            var group = this.drawingElement;\n            var drawingChildren = group.children.slice(0);\n            var children = this.children;\n            var fixedPosition = isNumber(indices);\n            var i, index, toIndex, drawingElement, visual;\n\n            for (i = 0; i < visuals.length; i++) {\n              visual = visuals[i];\n              drawingElement = visual.drawingContainer();\n              index = inArray(visual, children);\n\n              if (index >= 0) {\n                drawingChildren.splice(index, 1);\n                children.splice(index, 1);\n                toIndex = fixedPosition ? indices : indices[i];\n                drawingChildren.splice(toIndex, 0, drawingElement);\n                children.splice(toIndex, 0, visual);\n              }\n            }\n\n            group.clear();\n            group.append.apply(group, drawingChildren);\n          },\n          redraw: function (options) {\n            if (options) {\n              if (this._childrenChange) {\n                this._childrenChange = false;\n\n                if (!this._updateSize(options)) {\n                  this._initSize();\n                }\n              } else {\n                this._updateSize(options);\n              }\n\n              Element.fn.redraw.call(this, options);\n            }\n          },\n          _boundingBox: function () {\n            var children = this.children;\n            var boundingBox;\n            var visual, childBoundingBox;\n\n            for (var i = 0; i < children.length; i++) {\n              visual = children[i];\n\n              if (visual.visible() && visual._includeInBBox !== false) {\n                childBoundingBox = visual.drawingContainer().clippedBBox(null);\n\n                if (childBoundingBox) {\n                  if (boundingBox) {\n                    boundingBox = g.Rect.union(boundingBox, childBoundingBox);\n                  } else {\n                    boundingBox = childBoundingBox;\n                  }\n                }\n              }\n            }\n\n            return boundingBox;\n          }\n        });\n        deepExtend(Group.fn, AutoSizeableMixin);\n        var Layout = Group.extend({\n          init: function (rect, options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Layout(toDrawingRect(rect), options);\n\n            this._initSize();\n          },\n          rect: function (rect) {\n            if (rect) {\n              this.drawingElement.rect(toDrawingRect(rect));\n            } else {\n              var drawingRect = this.drawingElement.rect();\n\n              if (drawingRect) {\n                return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n              }\n            }\n          },\n          reflow: function () {\n            this.drawingElement.reflow();\n          },\n          redraw: function (options) {\n            kendo.deepExtend(this.drawingElement.options, options);\n            Group.fn.redraw.call(this, options);\n          }\n        });\n        var Circle = VisualBase.extend({\n          init: function (options) {\n            VisualBase.fn.init.call(this, options);\n\n            this._initCircle();\n\n            this._initSize();\n          },\n          redraw: function (options) {\n            if (options) {\n              var circleOptions = this.options;\n\n              if (options.center) {\n                deepExtend(circleOptions, {\n                  center: options.center\n                });\n\n                this._center.move(circleOptions.center.x, circleOptions.center.y);\n              }\n\n              if (this._diffNumericOptions(options, [\"radius\"])) {\n                this._circle.setRadius(circleOptions.radius);\n              }\n\n              this._updateSize(options);\n\n              VisualBase.fn.redraw.call(this, options);\n            }\n          },\n          _initCircle: function () {\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var radius = options.radius;\n\n            if (!defined(radius)) {\n              if (!defined(width)) {\n                width = height;\n              }\n\n              if (!defined(height)) {\n                height = width;\n              }\n\n              options.radius = radius = Math.min(width, height) / 2;\n            }\n\n            var center = options.center || {\n              x: radius,\n              y: radius\n            };\n            this._center = new g.Point(center.x, center.y);\n            this._circle = new g.Circle(this._center, radius);\n            this.drawingElement = new d.Circle(this._circle, {\n              stroke: options.stroke\n            });\n\n            this._fill();\n          }\n        });\n        deepExtend(Circle.fn, AutoSizeableMixin);\n        var Canvas = Class.extend({\n          init: function (element, options) {\n            options = options || {};\n            this.element = element;\n            this.surface = d.Surface.create(element, options);\n\n            if (kendo.isFunction(this.surface.translate)) {\n              this.translate = this._translate;\n            }\n\n            this.drawingElement = new d.Group();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n          },\n          bounds: function () {\n            var box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n          },\n          size: function (size) {\n            var viewBox = this._viewBox;\n\n            if (defined(size)) {\n              viewBox.width = size.width;\n              viewBox.height = size.height;\n              this.surface.setSize(size);\n            }\n\n            return {\n              width: viewBox.width,\n              height: viewBox.height\n            };\n          },\n          _translate: function (x, y) {\n            var viewBox = this._viewBox;\n\n            if (defined(x) && defined(y)) {\n              viewBox.x = x;\n              viewBox.y = y;\n              this.surface.translate({\n                x: x,\n                y: y\n              });\n            }\n\n            return {\n              x: viewBox.x,\n              y: viewBox.y\n            };\n          },\n          draw: function () {\n            this.surface.draw(this.drawingElement);\n          },\n          append: function (visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n          },\n          remove: function (visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n          },\n          insertBefore: function () {},\n          clear: function () {\n            this.drawingElement.clear();\n          },\n          destroy: function (clearHtml) {\n            this.surface.destroy();\n\n            if (clearHtml) {\n              $(this.element).remove();\n            }\n          }\n        }); // Helper functions ===========================================\n\n        function sizeOptionsOrDefault(options) {\n          return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n          };\n        }\n\n        function normalizeDrawingOptions(options) {\n          if (options) {\n            var drawingOptions = options;\n\n            if (isString(drawingOptions)) {\n              drawingOptions = {\n                color: drawingOptions\n              };\n            }\n\n            if (drawingOptions.color) {\n              drawingOptions.color = getColor(drawingOptions.color);\n            }\n\n            return drawingOptions;\n          }\n        }\n\n        function getColor(value) {\n          var color;\n\n          if (value != TRANSPARENT) {\n            color = new d.Color(value).toHex();\n          } else {\n            color = value;\n          }\n\n          return color;\n        }\n\n        function lineAngle(p1, p2) {\n          var xDiff = p2.x - p1.x;\n          var yDiff = p2.y - p1.y;\n          var angle = d.util.deg(Math.atan2(yDiff, xDiff));\n          return angle;\n        }\n\n        function createSegment(x, y) {\n          return new d.Segment(new g.Point(x, y));\n        }\n\n        function toDrawingRect(rect) {\n          if (rect) {\n            return new g.Rect([rect.x, rect.y], [rect.width, rect.height]);\n          }\n        } // Exports ================================================================\n\n\n        kendo.deepExtend(diagram, {\n          init: function (element) {\n            kendo.init(element, diagram.ui);\n          },\n          diffNumericOptions: diffNumericOptions,\n          Element: Element,\n          Scale: Scale,\n          Translation: Translation,\n          Rotation: Rotation,\n          Circle: Circle,\n          Group: Group,\n          Rectangle: Rectangle,\n          Canvas: Canvas,\n          Path: Path,\n          Layout: Layout,\n          Line: Line,\n          MarkerBase: MarkerBase,\n          ArrowMarker: ArrowMarker,\n          CircleMarker: CircleMarker,\n          Polyline: Polyline,\n          CompositeTransform: CompositeTransform,\n          TextBlock: TextBlock,\n          Image: Image,\n          VisualBase: VisualBase\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}