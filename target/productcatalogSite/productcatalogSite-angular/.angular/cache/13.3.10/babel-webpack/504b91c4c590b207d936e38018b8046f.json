{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1511);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1511:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"userevents\",\n        name: \"User Events\",\n        category: \"framework\",\n        depends: [\"core\"],\n        hidden: true\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            support = kendo.support,\n            Class = kendo.Class,\n            Observable = kendo.Observable,\n            now = Date.now,\n            extend = $.extend,\n            OS = support.mobileOS,\n            invalidZeroEvents = OS && OS.android,\n            DEFAULT_MIN_HOLD = 800,\n            CLICK_DELAY = 300,\n            DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0,\n            // WP8 and W8 are very sensitive and always report move.\n        // UserEvents events\n        PRESS = \"press\",\n            HOLD = \"hold\",\n            SELECT = \"select\",\n            START = \"start\",\n            MOVE = \"move\",\n            END = \"end\",\n            CANCEL = \"cancel\",\n            TAP = \"tap\",\n            DOUBLETAP = \"doubleTap\",\n            RELEASE = \"release\",\n            GESTURESTART = \"gesturestart\",\n            GESTURECHANGE = \"gesturechange\",\n            GESTUREEND = \"gestureend\",\n            GESTURETAP = \"gesturetap\";\n        var THRESHOLD = {\n          \"api\": 0,\n          \"touch\": 0,\n          \"mouse\": 9,\n          \"pointer\": 9\n        };\n        var ENABLE_GLOBAL_SURFACE = !support.touch || support.mouseAndTouchPresent;\n\n        function touchDelta(touch1, touch2) {\n          var x1 = touch1.x.location,\n              y1 = touch1.y.location,\n              x2 = touch2.x.location,\n              y2 = touch2.y.location,\n              dx = x1 - x2,\n              dy = y1 - y2;\n          return {\n            center: {\n              x: (x1 + x2) / 2,\n              y: (y1 + y2) / 2\n            },\n            distance: Math.sqrt(dx * dx + dy * dy)\n          };\n        }\n\n        function getTouches(e) {\n          var touches = [],\n              originalEvent = e.originalEvent,\n              currentTarget = e.currentTarget,\n              idx = 0,\n              length,\n              changedTouches,\n              touch;\n\n          if (e.api) {\n            touches.push({\n              id: 2,\n              // hardcoded ID for API call;\n              event: e,\n              target: e.target,\n              currentTarget: e.target,\n              location: e,\n              type: \"api\"\n            });\n          } else if (e.type.match(/touch/)) {\n            changedTouches = originalEvent ? originalEvent.changedTouches : [];\n\n            for (length = changedTouches.length; idx < length; idx++) {\n              touch = changedTouches[idx];\n              touches.push({\n                location: touch,\n                event: e,\n                target: touch.target,\n                currentTarget: currentTarget,\n                id: touch.identifier,\n                type: \"touch\"\n              });\n            }\n          } else if (support.pointers || support.msPointers) {\n            touches.push({\n              location: originalEvent,\n              event: e,\n              target: e.target,\n              currentTarget: currentTarget,\n              id: originalEvent.pointerId,\n              type: \"pointer\"\n            });\n          } else {\n            touches.push({\n              id: 1,\n              // hardcoded ID for mouse event;\n              event: e,\n              target: e.target,\n              currentTarget: currentTarget,\n              location: e,\n              type: \"mouse\"\n            });\n          }\n\n          return touches;\n        }\n\n        var TouchAxis = Class.extend({\n          init: function (axis, location) {\n            var that = this;\n            that.axis = axis;\n\n            that._updateLocationData(location);\n\n            that.startLocation = that.location;\n            that.velocity = that.delta = 0;\n            that.timeStamp = now();\n          },\n          move: function (location) {\n            var that = this,\n                offset = location[\"page\" + that.axis],\n                timeStamp = now(),\n                timeDelta = timeStamp - that.timeStamp || 1; // Firing manually events in tests can make this 0;\n\n            if (!offset && invalidZeroEvents) {\n              return;\n            }\n\n            that.delta = offset - that.location;\n\n            that._updateLocationData(location);\n\n            that.initialDelta = offset - that.startLocation;\n            that.velocity = that.delta / timeDelta;\n            that.timeStamp = timeStamp;\n          },\n          _updateLocationData: function (location) {\n            var that = this,\n                axis = that.axis;\n            that.location = location[\"page\" + axis];\n            that.client = location[\"client\" + axis];\n            that.screen = location[\"screen\" + axis];\n          }\n        });\n        var Touch = Class.extend({\n          init: function (userEvents, target, touchInfo) {\n            extend(this, {\n              x: new TouchAxis(\"X\", touchInfo.location),\n              y: new TouchAxis(\"Y\", touchInfo.location),\n              type: touchInfo.type,\n              useClickAsTap: userEvents.useClickAsTap,\n              threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n              userEvents: userEvents,\n              target: target,\n              currentTarget: touchInfo.currentTarget,\n              initialTouch: touchInfo.target,\n              id: touchInfo.id,\n              pressEvent: touchInfo,\n              _clicks: userEvents._clicks,\n              supportDoubleTap: userEvents.supportDoubleTap,\n              _moved: false,\n              _finished: false\n            });\n          },\n          press: function () {\n            this._holdTimeout = setTimeout(this._hold.bind(this), this.userEvents.minHold);\n\n            this._trigger(PRESS, this.pressEvent);\n          },\n          _tap: function (touchInfo) {\n            var that = this;\n            that.userEvents._clicks++;\n\n            if (that.userEvents._clicks == 1) {\n              that._clickTimeout = setTimeout(function () {\n                if (that.userEvents._clicks == 1) {\n                  that._trigger(TAP, touchInfo);\n                } else {\n                  that._trigger(DOUBLETAP, touchInfo);\n                }\n\n                that.userEvents._clicks = 0;\n              }, CLICK_DELAY);\n            }\n          },\n          _hold: function () {\n            this._trigger(HOLD, this.pressEvent);\n          },\n          move: function (touchInfo) {\n            var that = this;\n            var preventMove = touchInfo.type !== \"api\" && that.userEvents._shouldNotMove;\n\n            if (that._finished || preventMove) {\n              return;\n            }\n\n            that.x.move(touchInfo.location);\n            that.y.move(touchInfo.location);\n\n            if (!that._moved) {\n              if (that._withinIgnoreThreshold()) {\n                return;\n              }\n\n              if (!UserEvents.current || UserEvents.current === that.userEvents) {\n                that._start(touchInfo);\n              } else {\n                return that.dispose();\n              }\n            } // Event handlers may cancel the drag in the START event handler, hence the double check for pressed.\n\n\n            if (!that._finished) {\n              that._trigger(MOVE, touchInfo);\n            }\n          },\n          end: function (touchInfo) {\n            this.endTime = now();\n\n            if (this._finished) {\n              return;\n            } // Mark the object as finished if there are blocking operations in the event handlers (alert/confirm)\n\n\n            this._finished = true;\n\n            this._trigger(RELEASE, touchInfo); // Release should be fired before TAP (as click is after mouseup/touchend)\n\n\n            if (this._moved) {\n              this._trigger(END, touchInfo);\n            } else {\n              if (!this.useClickAsTap) {\n                if (this.supportDoubleTap) {\n                  this._tap(touchInfo);\n                } else {\n                  this._trigger(TAP, touchInfo);\n                }\n              }\n            }\n\n            clearTimeout(this._holdTimeout);\n            this.dispose();\n          },\n          dispose: function () {\n            var userEvents = this.userEvents,\n                activeTouches = userEvents.touches;\n            this._finished = true;\n            this.pressEvent = null;\n            clearTimeout(this._holdTimeout);\n            activeTouches.splice($.inArray(this, activeTouches), 1);\n          },\n          skip: function () {\n            this.dispose();\n          },\n          cancel: function () {\n            this.dispose();\n          },\n          isMoved: function () {\n            return this._moved;\n          },\n          _start: function (touchInfo) {\n            clearTimeout(this._holdTimeout);\n            this.startTime = now();\n            this._moved = true;\n\n            this._trigger(START, touchInfo);\n          },\n          _trigger: function (name, touchInfo) {\n            var that = this,\n                jQueryEvent = touchInfo.event,\n                data = {\n              touch: that,\n              x: that.x,\n              y: that.y,\n              target: that.target,\n              event: jQueryEvent\n            };\n\n            if (that.userEvents.notify(name, data)) {\n              jQueryEvent.preventDefault();\n            }\n          },\n          _withinIgnoreThreshold: function () {\n            var xDelta = this.x.initialDelta,\n                yDelta = this.y.initialDelta;\n            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n          }\n        });\n\n        function withEachUpEvent(callback) {\n          var downEvents = kendo.eventMap.up.split(\" \"),\n              idx = 0,\n              length = downEvents.length;\n\n          for (; idx < length; idx++) {\n            callback(downEvents[idx]);\n          }\n        }\n\n        var UserEvents = Observable.extend({\n          init: function (element, options) {\n            var that = this,\n                filter,\n                ns = kendo.guid();\n            options = options || {};\n            filter = that.filter = options.filter;\n            that.threshold = options.threshold || DEFAULT_THRESHOLD;\n            that.minHold = options.minHold || DEFAULT_MIN_HOLD;\n            that.touches = [];\n            that._maxTouches = options.multiTouch ? 2 : 1;\n            that.allowSelection = options.allowSelection;\n            that.captureUpIfMoved = options.captureUpIfMoved;\n            that.useClickAsTap = !options.fastTap && !support.delayedClick();\n            that.eventNS = ns;\n            that._clicks = 0;\n            that.supportDoubleTap = options.supportDoubleTap;\n            element = $(element).handler(that);\n            Observable.fn.init.call(that);\n            extend(that, {\n              element: element,\n              // the touch events lock to the element anyway, so no need for the global setting\n              surface: options.global && ENABLE_GLOBAL_SURFACE ? $(element[0].ownerDocument.documentElement) : $(options.surface || element),\n              stopPropagation: options.stopPropagation,\n              pressed: false\n            });\n            that.surface.handler(that).on(kendo.applyEventMap(\"move\", ns), \"_move\").on(kendo.applyEventMap(\"up cancel\", ns), \"_end\");\n            element.on(kendo.applyEventMap(\"down\", ns), filter, \"_start\");\n\n            if (that.useClickAsTap) {\n              element.on(kendo.applyEventMap(\"click\", ns), filter, \"_click\");\n            }\n\n            if (support.pointers || support.msPointers) {\n              //touch-action:none will not work for IE10\n              if (support.browser.version < 11) {\n                var defaultAction = \"pinch-zoom double-tap-zoom\";\n                element.css(\"-ms-touch-action\", options.touchAction && options.touchAction != \"none\" ? defaultAction + \" \" + options.touchAction : defaultAction);\n              } else {\n                element.css(\"touch-action\", options.touchAction || \"none\");\n              }\n            }\n\n            if (options.preventDragEvent) {\n              element.on(kendo.applyEventMap(\"dragstart\", ns), kendo.preventDefault);\n            }\n\n            element.on(kendo.applyEventMap(\"mousedown\", ns), filter, {\n              root: element\n            }, \"_select\");\n\n            if (that.captureUpIfMoved && support.eventCapture) {\n              var surfaceElement = that.surface[0],\n                  preventIfMovingProxy = that.preventIfMoving.bind(that);\n              withEachUpEvent(function (eventName) {\n                surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\n              });\n            }\n\n            that.bind([PRESS, HOLD, TAP, DOUBLETAP, START, MOVE, END, RELEASE, CANCEL, GESTURESTART, GESTURECHANGE, GESTUREEND, GESTURETAP, SELECT], options);\n          },\n          preventIfMoving: function (e) {\n            if (this._isMoved()) {\n              e.preventDefault();\n            }\n          },\n          destroy: function () {\n            var that = this;\n\n            if (that._destroyed) {\n              return;\n            }\n\n            that._destroyed = true;\n\n            if (that.captureUpIfMoved && support.eventCapture) {\n              var surfaceElement = that.surface[0];\n              withEachUpEvent(function (eventName) {\n                surfaceElement.removeEventListener(eventName, that.preventIfMoving);\n              });\n            }\n\n            that.element.kendoDestroy(that.eventNS);\n            that.surface.kendoDestroy(that.eventNS);\n            that.element.removeData(\"handler\");\n            that.surface.removeData(\"handler\");\n\n            that._disposeAll();\n\n            that.unbind();\n            delete that.surface;\n            delete that.element;\n            delete that.currentTarget;\n          },\n          capture: function () {\n            UserEvents.current = this;\n          },\n          cancel: function () {\n            this._disposeAll();\n\n            this.trigger(CANCEL);\n          },\n          notify: function (eventName, data) {\n            var that = this,\n                touches = that.touches;\n\n            if (this._isMultiTouch()) {\n              switch (eventName) {\n                case MOVE:\n                  eventName = GESTURECHANGE;\n                  break;\n\n                case END:\n                  eventName = GESTUREEND;\n                  break;\n\n                case TAP:\n                  eventName = GESTURETAP;\n                  break;\n              }\n\n              extend(data, {\n                touches: touches\n              }, touchDelta(touches[0], touches[1]));\n            }\n\n            return this.trigger(eventName, extend(data, {\n              type: eventName\n            }));\n          },\n          // API\n          press: function (x, y, target) {\n            this._apiCall(\"_start\", x, y, target);\n          },\n          move: function (x, y) {\n            this._apiCall(\"_move\", x, y);\n          },\n          end: function (x, y) {\n            this._apiCall(\"_end\", x, y);\n          },\n          _isMultiTouch: function () {\n            return this.touches.length > 1;\n          },\n          _maxTouchesReached: function () {\n            return this.touches.length >= this._maxTouches;\n          },\n          _disposeAll: function () {\n            var touches = this.touches;\n\n            while (touches.length > 0) {\n              touches.pop().dispose();\n            }\n          },\n          _isMoved: function () {\n            return $.grep(this.touches, function (touch) {\n              return touch.isMoved();\n            }).length;\n          },\n          _select: function (e) {\n            if (!this.allowSelection || this.trigger(SELECT, {\n              event: e\n            })) {\n              e.preventDefault();\n            }\n          },\n          _start: function (e) {\n            var that = this,\n                idx = 0,\n                filter = that.filter,\n                target,\n                touches = getTouches(e),\n                length = touches.length,\n                touch,\n                which = e.which;\n\n            if (which && which > 1 || that._maxTouchesReached()) {\n              return;\n            }\n\n            UserEvents.current = null;\n            that.currentTarget = e.currentTarget;\n\n            if (that.stopPropagation) {\n              e.stopPropagation();\n            }\n\n            for (; idx < length; idx++) {\n              if (that._maxTouchesReached()) {\n                break;\n              }\n\n              touch = touches[idx];\n\n              if (filter) {\n                target = $(touch.currentTarget); // target.is(filter) ? target : target.closest(filter, that.element);\n              } else {\n                target = that.element;\n              }\n\n              if (!target.length) {\n                continue;\n              }\n\n              touch = new Touch(that, target, touch);\n              that.touches.push(touch);\n              touch.press();\n\n              if (that._isMultiTouch()) {\n                that.notify(\"gesturestart\", {});\n              }\n            }\n          },\n          _move: function (e) {\n            this._eachTouch(\"move\", e);\n          },\n          _end: function (e) {\n            this._eachTouch(\"end\", e);\n          },\n          _click: function (e) {\n            var data = {\n              touch: {\n                initialTouch: e.target,\n                target: $(e.currentTarget),\n                endTime: now(),\n                x: {\n                  location: e.pageX,\n                  client: e.clientX\n                },\n                y: {\n                  location: e.pageY,\n                  client: e.clientY\n                }\n              },\n              x: e.pageX,\n              y: e.pageY,\n              target: $(e.currentTarget),\n              event: e,\n              type: \"tap\"\n            };\n\n            if (this.trigger(\"tap\", data)) {\n              e.preventDefault();\n            }\n          },\n          _eachTouch: function (methodName, e) {\n            var that = this,\n                dict = {},\n                touches = getTouches(e),\n                activeTouches = that.touches,\n                idx,\n                touch,\n                touchInfo,\n                matchingTouch;\n\n            for (idx = 0; idx < activeTouches.length; idx++) {\n              touch = activeTouches[idx];\n              dict[touch.id] = touch;\n            }\n\n            for (idx = 0; idx < touches.length; idx++) {\n              touchInfo = touches[idx];\n              matchingTouch = dict[touchInfo.id];\n\n              if (matchingTouch) {\n                matchingTouch[methodName](touchInfo);\n              }\n            }\n          },\n          _apiCall: function (type, x, y, target) {\n            this[type]({\n              api: true,\n              pageX: x,\n              pageY: y,\n              clientX: x,\n              clientY: y,\n              target: $(target || this.element)[0],\n              stopPropagation: $.noop,\n              preventDefault: $.noop\n            });\n          }\n        });\n\n        UserEvents.defaultThreshold = function (value) {\n          DEFAULT_THRESHOLD = value;\n        };\n\n        UserEvents.minHold = function (value) {\n          DEFAULT_MIN_HOLD = value;\n        };\n\n        kendo.getTouches = getTouches;\n        kendo.touchDelta = touchDelta;\n        kendo.UserEvents = UserEvents;\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}