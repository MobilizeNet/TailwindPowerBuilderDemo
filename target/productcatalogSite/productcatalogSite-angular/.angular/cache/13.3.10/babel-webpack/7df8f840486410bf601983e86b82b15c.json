{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, isDevMode, Directive, Input, Component, Output, ChangeDetectionStrategy, HostBinding, forwardRef, ElementRef, ContentChild, ViewChild, HostListener, InjectionToken, Inject, NgZone, Optional, ViewContainerRef, ViewChildren, TemplateRef, ContentChildren, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, NgControl } from '@angular/forms';\nimport * as i1$1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX, RTL } from '@progress/kendo-angular-l10n';\nimport { cloneDate, addDays, getDate, isEqual, addDecades, addCenturies, firstDecadeOfCentury, lastDecadeOfCentury, firstYearOfDecade, createDate, lastYearOfDecade, lastMonthOfYear, lastDayOfMonth, durationInCenturies, addYears, durationInDecades, addWeeks, addMonths, firstDayOfMonth, dayOfWeek, durationInMonths, firstMonthOfYear, durationInYears, weekInYear } from '@progress/kendo-date-math';\nimport * as i5 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, guid, Keys, hasObservers, KendoInput, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport * as i1 from '@progress/kendo-angular-intl';\nimport { IntlModule } from '@progress/kendo-angular-intl';\nimport { Subject, Subscription, ReplaySubject, Observable, combineLatest, of, interval, animationFrameScheduler, fromEvent, EMPTY, from, BehaviorSubject, merge } from 'rxjs';\nimport * as i7 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { map, scan, takeWhile, debounceTime, tap, filter } from 'rxjs/operators';\nimport * as i2 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport { touchEnabled } from '@progress/kendo-common';\n/**\n * @hidden\n */\n\nconst _c0 = [\"kendoCalendarView\", \"\"];\n\nfunction ViewComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 3);\n    i0.ɵɵtext(1, \"\\xA0\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction ViewComponent_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 4)(1, \"th\", 5);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"colSpan\", ctx_r2.colSpan);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.title);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const row_r4 = i0.ɵɵnextContext(3).$implicit;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.getWeekNumber(ctx_r9.firstDate(row_r4)), \" \");\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template(rf, ctx) {}\n\nconst _c1 = function (a0) {\n  return {\n    click: a0\n  };\n};\n\nconst _c2 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    cellContext: a1\n  };\n};\n\nfunction ViewComponent_tr_3_ng_template_1_td_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 9);\n    i0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template, 1, 1, \"ng-template\", 6);\n    i0.ɵɵtemplate(2, ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template, 0, 0, \"ng-template\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r4 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(5, _c1, ctx_r8.handleWeekNumberClick.bind(ctx_r8, row_r4)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r8.weekNumberTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.weekNumberTemplateRef)(\"ngTemplateOutlet\", ctx_r8.weekNumberTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(7, _c2, ctx_r8.firstDate(row_r4), ctx_r8.getWeekNumberContext(row_r4)));\n  }\n}\n\nfunction ViewComponent_tr_3_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ViewComponent_tr_3_ng_template_1_td_0_Template, 3, 10, \"td\", 8);\n  }\n\n  if (rf & 2) {\n    const row_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.firstDate(row_r4))(\"ngIfElse\", _r0);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const cell_r14 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵtextInterpolate(cell_r14.formattedValue);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template(rf, ctx) {}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const cell_r14 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c2, cell_r14.value, cell_r14));\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 12)(1, \"span\", 13);\n    i0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template, 1, 1, \"ng-template\", 6);\n    i0.ɵɵtemplate(3, ViewComponent_tr_3_ng_container_2_td_1_3_Template, 1, 5, null, 14);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext();\n    const cell_r14 = ctx_r22.$implicit;\n    const cellIndex_r15 = ctx_r22.index;\n    const rowIndex_r5 = i0.ɵɵnextContext().index;\n    const ctx_r16 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r16.getStyles(cell_r14))(\"title\", cell_r14.title);\n    i0.ɵɵattribute(\"id\", cell_r14.id)(\"data-cell-index\", ctx_r16.tableCellIndex(rowIndex_r5, cellIndex_r15))(\"aria-selected\", cell_r14.isSelected || cell_r14.isRangeStart || cell_r14.isRangeMid || cell_r14.isRangeEnd)(\"aria-disabled\", cell_r14.isDisabled);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r16.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r16.templateRef);\n  }\n}\n\nfunction ViewComponent_tr_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ViewComponent_tr_3_ng_container_2_td_1_Template, 4, 8, \"td\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const cell_r14 = ctx.$implicit;\n    const ctx_r7 = i0.ɵɵnextContext(2);\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.shouldRenderCellContent(cell_r14))(\"ngIfElse\", _r0);\n  }\n}\n\nfunction ViewComponent_tr_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 4);\n    i0.ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_Template, 1, 2, \"ng-template\", 6);\n    i0.ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_Template, 2, 2, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r4 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.weekNumber);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kForOf\", row_r4);\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_caption_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"caption\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r5 = i0.ɵɵnextContext().date;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r7.getCaptionClass());\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.getCaptionTitle(date_r5));\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const name_r11 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(name_r11);\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_thead_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"thead\", 8)(1, \"tr\", 9);\n    i0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template, 2, 1, \"th\", 10);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r8.weekNames);\n  }\n}\n\nfunction HorizontalViewListComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"table\", 3);\n    i0.ɵɵtemplate(1, HorizontalViewListComponent_ng_template_0_caption_1_Template, 2, 2, \"caption\", 4);\n    i0.ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_Template, 3, 1, \"thead\", 5);\n    i0.ɵɵelementStart(3, \"tbody\", 6);\n    i0.ɵɵlistener(\"cellClick\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.cellClick.emit($event);\n    })(\"weekNumberCellClick\", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.weekNumberCellClick.emit($event);\n    })(\"cellEnter\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.cellEnter.emit($event);\n    })(\"cellLeave\", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.cellLeave.emit($event);\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const date_r5 = ctx.date;\n    const class_r6 = ctx.className;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", class_r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.showViewHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isMonthView());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"activeView\", ctx_r1.activeView)(\"isActive\", ctx_r1.isActive)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"cellUID\", ctx_r1.cellUID)(\"focusedDate\", ctx_r1.focusedDate)(\"selectedDates\", ctx_r1.selectedDates)(\"selectionRange\", ctx_r1.selectionRange)(\"activeRangeEnd\", ctx_r1.activeRangeEnd)(\"weekNumber\", ctx_r1.weekNumber)(\"templateRef\", ctx_r1.cellTemplateRef)(\"weekNumberTemplateRef\", ctx_r1.weekNumberTemplateRef)(\"viewDate\", date_r5);\n  }\n}\n\nfunction HorizontalViewListComponent_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c3 = function (a0) {\n  return {\n    date: a0,\n    className: \"k-pointer-events-none\"\n  };\n};\n\nfunction HorizontalViewListComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, HorizontalViewListComponent_2_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c3, ctx_r2.nextAnimationDate));\n  }\n}\n\nfunction HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) {}\n\nconst _c4 = function (a0) {\n  return {\n    date: a0\n  };\n};\n\nfunction HorizontalViewListComponent_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const date_r18 = ctx.$implicit;\n    i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c4, date_r18));\n  }\n}\n\nfunction HorizontalViewListComponent_4_ng_template_0_Template(rf, ctx) {}\n\nfunction HorizontalViewListComponent_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, HorizontalViewListComponent_4_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c3, ctx_r4.prevAnimationDate));\n  }\n}\n\nfunction HeaderComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\n\nfunction HeaderComponent_ng_template_2_Template(rf, ctx) {}\n\nfunction HeaderComponent_button_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function HeaderComponent_button_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.prevButtonClick.emit();\n    });\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"disabled\", ctx_r2.isPrevDisabled)(\"title\", ctx_r2.prevButtonTitle);\n    i0.ɵɵattribute(\"aria-disabled\", ctx_r2.isPrevDisabled);\n  }\n}\n\nfunction HeaderComponent_button_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 10);\n    i0.ɵɵlistener(\"click\", function HeaderComponent_button_8_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.nextButtonClick.emit();\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"disabled\", ctx_r3.isNextDisabled)(\"title\", ctx_r3.nextButtonTitle);\n    i0.ɵɵattribute(\"aria-disabled\", ctx_r3.isNextDisabled);\n  }\n}\n\nconst _c5 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    activeView: a1,\n    date: a2\n  };\n};\n\nconst _c12 = function (a0) {\n  return {\n    focusin: a0\n  };\n};\n\nconst _c13 = [\"*\"];\nconst _c14 = [\"list\"];\n\nfunction NavigationComponent_li_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const date_r2 = i0.ɵɵnextContext().$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r4.service.navigationTitle(date_r2));\n  }\n}\n\nfunction NavigationComponent_li_4_ng_template_3_Template(rf, ctx) {}\n\nfunction NavigationComponent_li_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\")(1, \"span\");\n    i0.ɵɵtemplate(2, NavigationComponent_li_4_ng_template_2_Template, 1, 1, \"ng-template\", 5);\n    i0.ɵɵtemplate(3, NavigationComponent_li_4_ng_template_3_Template, 0, 0, \"ng-template\", 6);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const date_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"data-date-index\", index_r3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-calendar-navigation-marker\", ctx_r1.service.isRangeStart(date_r2));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.templateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.templateRef)(\"ngTemplateOutlet\", ctx_r1.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(7, _c5, ctx_r1.service.navigationTitle(date_r2), ctx_r1.activeViewValue, date_r2));\n  }\n}\n\nfunction ViewListComponent_table_1_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const name_r5 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r4.colWidth, \"%\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(name_r5);\n  }\n}\n\nfunction ViewListComponent_table_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"table\", 7)(1, \"thead\", 8)(2, \"tr\", 9);\n    i0.ɵɵtemplate(3, ViewListComponent_table_1_th_3_Template, 2, 3, \"th\", 10);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.weekNames);\n  }\n}\n\nfunction ViewListComponent_col_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n}\n\nfunction ViewListComponent_tbody_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"tbody\", 12);\n    i0.ɵɵlistener(\"cellClick\", function ViewListComponent_tbody_7_Template_tbody_cellClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.cellClick.emit($event);\n    })(\"weekNumberCellClick\", function ViewListComponent_tbody_7_Template_tbody_weekNumberCellClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.weekNumberCellClick.emit($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const date_r7 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"activeView\", ctx_r3.activeView)(\"isActive\", ctx_r3.isActive)(\"min\", ctx_r3.min)(\"max\", ctx_r3.max)(\"cellUID\", ctx_r3.cellUID)(\"focusedDate\", ctx_r3.focusedDate)(\"selectedDates\", ctx_r3.selectedDates)(\"weekNumber\", ctx_r3.weekNumber)(\"templateRef\", ctx_r3.cellTemplateRef)(\"weekNumberTemplateRef\", ctx_r3.weekNumberTemplateRef)(\"viewDate\", date_r7);\n  }\n}\n\nfunction CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-calendar-navigation\", 5);\n    i0.ɵɵlistener(\"valueChange\", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext(2);\n      return ctx_r3.handleNavigation($event);\n    })(\"pageChange\", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_pageChange_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.onPageChange();\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"activeView\", ctx_r2.activeViewEnum)(\"focusedDate\", ctx_r2.focusedDate)(\"min\", ctx_r2.min)(\"max\", ctx_r2.max)(\"templateRef\", ctx_r2.navigationItemTemplateRef == null ? null : ctx_r2.navigationItemTemplateRef.templateRef);\n  }\n}\n\nfunction CalendarComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template, 1, 5, \"kendo-calendar-navigation\", 2);\n    i0.ɵɵelementStart(2, \"kendo-calendar-viewlist\", 3);\n    i0.ɵɵlistener(\"todayButtonClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_todayButtonClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleDateChange({\n        selectedDates: [$event],\n        focusedDate: $event\n      });\n    })(\"cellClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.handleCellClick($event);\n    })(\"weekNumberCellClick\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_weekNumberCellClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.handleWeekNumberClick($event);\n    })(\"activeDateChange\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_activeDateChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.handleActiveDateChange($event);\n    })(\"pageChange\", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_pageChange_2_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.onPageChange();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"kendo-resize-sensor\", 4);\n    i0.ɵɵlistener(\"resize\", function CalendarComponent_ng_container_1_Template_kendo_resize_sensor_resize_3_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.onResize();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    let tmp_3_0;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.navigation);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"activeView\", ctx_r0.activeViewEnum)(\"isActive\", ctx_r0.isActive)(\"cellTemplateRef\", (tmp_3_0 = ctx_r0.activeCellTemplate()) == null ? null : tmp_3_0.templateRef)(\"headerTitleTemplateRef\", ctx_r0.headerTitleTemplateRef == null ? null : ctx_r0.headerTitleTemplateRef.templateRef)(\"weekNumberTemplateRef\", ctx_r0.weekNumberTemplateRef == null ? null : ctx_r0.weekNumberTemplateRef.templateRef)(\"cellUID\", ctx_r0.cellUID)(\"min\", ctx_r0.min)(\"max\", ctx_r0.max)(\"focusedDate\", ctx_r0.focusedDate)(\"weekNumber\", ctx_r0.weekNumber)(\"selectedDates\", ctx_r0.selectedDates);\n  }\n}\n\nfunction CalendarComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"kendo-multiviewcalendar\", 6, 7);\n    i0.ɵɵlistener(\"activeViewChange\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_activeViewChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.handleActiveViewChange($event);\n    })(\"navigate\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_navigate_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.handleNavigate($event);\n    })(\"valueChange\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n\n      const _r13 = i0.ɵɵreference(2);\n\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.handleMultiViewCalendarValueChange($event, _r13.focusedDate);\n    })(\"focus\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_focus_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.handleFocus();\n    })(\"blur\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blur_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.handleBlur($event);\n    })(\"keydown\", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.handleMultiViewCalendarKeydown($event);\n    });\n    i0.ɵɵelement(3, \"kendo-multiviewcalendar-messages\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"views\", 1)(\"min\", ctx_r1.min)(\"max\", ctx_r1.max)(\"isActive\", ctx_r1.isActive)(\"activeView\", ctx_r1.activeView)(\"bottomView\", ctx_r1.bottomView)(\"topView\", ctx_r1.topView)(\"weekNumber\", ctx_r1.weekNumber)(\"animateNavigation\", ctx_r1.animateNavigation)(\"cellTemplate\", ctx_r1.activeCellTemplate())(\"monthCellTemplate\", ctx_r1.monthCellTemplateRef)(\"yearCellTemplate\", ctx_r1.yearCellTemplateRef)(\"decadeCellTemplate\", ctx_r1.decadeCellTemplateRef)(\"centuryCellTemplate\", ctx_r1.centuryCellTemplateRef)(\"headerTitleTemplate\", ctx_r1.headerTitleTemplateRef)(\"weekNumberTemplate\", ctx_r1.weekNumberTemplateRef)(\"focusedDate\", ctx_r1.focusedDate)(\"selection\", ctx_r1.selection)(\"value\", ctx_r1.value)(\"disabledDates\", ctx_r1.disabledDates);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"today\", ctx_r1.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r1.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r1.localization.get(\"nextButtonTitle\"));\n  }\n}\n\nconst _c21 = [\"dateInput\"];\nconst _c22 = [\"spinup\"];\nconst _c23 = [\"spindown\"];\n\nfunction DateInputComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 4);\n    i0.ɵɵlistener(\"mousedown\", function DateInputComponent_span_3_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelementStart(1, \"button\", 5, 6);\n    i0.ɵɵlistener(\"mousedown\", function DateInputComponent_span_3_Template_button_mousedown_1_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.arrowDirection = ctx_r5.arrow.Up;\n    })(\"mouseleave\", function DateInputComponent_span_3_Template_button_mouseleave_1_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.arrowDirection = ctx_r7.arrow.None;\n    })(\"click\", function DateInputComponent_span_3_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.handleButtonClick(1);\n    });\n    i0.ɵɵelement(3, \"span\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"button\", 8, 9);\n    i0.ɵɵlistener(\"click\", function DateInputComponent_span_3_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.handleButtonClick(-1);\n    })(\"mousedown\", function DateInputComponent_span_3_Template_button_mousedown_4_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.arrowDirection = ctx_r10.arrow.Down;\n    })(\"mouseleave\", function DateInputComponent_span_3_Template_button_mouseleave_4_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.arrowDirection = ctx_r11.arrow.None;\n    });\n    i0.ɵɵelement(6, \"span\", 10);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-active\", ctx_r1.arrowDirection === ctx_r1.arrow.Up);\n    i0.ɵɵproperty(\"title\", ctx_r1.localization.get(\"increment\"));\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.localization.get(\"increment\"));\n    i0.ɵɵadvance(3);\n    i0.ɵɵclassProp(\"k-active\", ctx_r1.arrowDirection === ctx_r1.arrow.Down);\n    i0.ɵɵproperty(\"title\", ctx_r1.localization.get(\"decrement\"));\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.localization.get(\"decrement\"));\n  }\n}\n\nconst _c28 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    click: a0,\n    focus: a1,\n    mousedown: a2,\n    touchstart: a3,\n    dragstart: a4,\n    drop: a5,\n    blur: a6\n  };\n};\n\nconst _c29 = [\"container\"];\nconst _c30 = [\"popupTemplate\"];\nconst _c31 = [\"toggleButton\"];\n\nfunction DatePickerComponent_ng_template_8_ng_template_3_Template(rf, ctx) {}\n\nconst _c40 = function (a0) {\n  return {\n    keydown: a0\n  };\n};\n\nfunction DatePickerComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-calendar\", 8, 9);\n    i0.ɵɵlistener(\"valueChange\", function DatePickerComponent_ng_template_8_Template_kendo_calendar_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.handleChange(ctx_r7.mergeTime($event));\n    });\n    i0.ɵɵelement(2, \"kendo-calendar-messages\", 10);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, DatePickerComponent_ng_template_8_ng_template_3_Template, 0, 0, \"ng-template\");\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"type\", ctx_r4.calendarType)(\"min\", ctx_r4.min)(\"max\", ctx_r4.max)(\"navigation\", ctx_r4.navigation)(\"animateNavigation\", ctx_r4.animateCalendarNavigation)(\"activeView\", ctx_r4.activeView)(\"bottomView\", ctx_r4.bottomView)(\"topView\", ctx_r4.topView)(\"weekNumber\", ctx_r4.weekNumber)(\"cellTemplate\", ctx_r4.cellTemplate)(\"monthCellTemplate\", ctx_r4.monthCellTemplate)(\"yearCellTemplate\", ctx_r4.yearCellTemplate)(\"decadeCellTemplate\", ctx_r4.decadeCellTemplate)(\"centuryCellTemplate\", ctx_r4.centuryCellTemplate)(\"weekNumberTemplate\", ctx_r4.weekNumberTemplate)(\"headerTitleTemplate\", ctx_r4.headerTitleTemplate)(\"navigationItemTemplate\", ctx_r4.navigationItemTemplate)(\"focusedDate\", ctx_r4.focusedDate)(\"value\", ctx_r4.value)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(25, _c40, ctx_r4.handleKeydown))(\"scope\", ctx_r4)(\"disabledDates\", ctx_r4.disabledDates);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"today\", ctx_r4.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r4.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r4.localization.get(\"nextButtonTitle\"));\n  }\n}\n\nconst _c41 = function (a0, a1) {\n  return {\n    click: a0,\n    mousedown: a1\n  };\n};\n\nfunction TimeListComponent_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 3)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n    i0.ɵɵattribute(\"data-timelist-item-index\", index_r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r1.text);\n  }\n}\n\nconst _c42 = [\"accept\"];\nconst _c43 = [\"cancel\"];\nconst _c44 = [\"now\"];\nconst _c45 = [\"listWrapper\"];\n\nconst _c58 = function (a0, a1, a2) {\n  return {\n    click: a0,\n    focus: a1,\n    blur: a2\n  };\n};\n\nfunction TimeSelectorComponent_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 8, 9);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(6, _c58, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur))(\"scope\", ctx_r0)(\"disabled\", ctx_r0.disabled);\n    i0.ɵɵattribute(\"title\", ctx_r0.localization.get(\"nowLabel\"))(\"aria-label\", ctx_r0.localization.get(\"nowLabel\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.localization.get(\"now\"));\n  }\n}\n\nconst _c59 = function (a0, a1) {\n  return {\n    focus: a0,\n    blur: a1\n  };\n};\n\nfunction TimeSelectorComponent_ng_template_7_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 12, 13)(2, \"span\", 2);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"kendo-timelist\", 14);\n    i0.ɵɵlistener(\"valueChange\", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_valueChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return ctx_r9.current = $event;\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    const part_r4 = ctx_r11.$implicit;\n    const idx_r5 = ctx_r11.index;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r6.intl.dateFieldName(part_r4));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"min\", ctx_r6.min)(\"max\", ctx_r6.max)(\"part\", part_r4)(\"step\", ctx_r6.partStep(part_r4))(\"disabled\", ctx_r6.disabled)(\"value\", ctx_r6.current)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(10, _c59, ctx_r6.handleListFocus, ctx_r6.handleBlur))(\"scope\", ctx_r6);\n    i0.ɵɵattribute(\"data-timelist-index\", idx_r5);\n  }\n}\n\nfunction TimeSelectorComponent_ng_template_7_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const part_r4 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", part_r4.pattern, \" \");\n  }\n}\n\nfunction TimeSelectorComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TimeSelectorComponent_ng_template_7_div_0_Template, 5, 13, \"div\", 10);\n    i0.ɵɵtemplate(1, TimeSelectorComponent_ng_template_7_div_1_Template, 2, 1, \"div\", 11);\n  }\n\n  if (rf & 2) {\n    const part_r4 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", part_r4.type !== \"literal\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", part_r4.type === \"literal\");\n  }\n}\n\nfunction TimeSelectorComponent_div_8_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 19, 20);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(6, _c58, ctx_r13.handleReject, ctx_r13.handleFocus, ctx_r13.handleBlur))(\"scope\", ctx_r13)(\"disabled\", ctx_r13.disabled);\n    i0.ɵɵattribute(\"title\", ctx_r13.localization.get(\"cancelLabel\"))(\"aria-label\", ctx_r13.localization.get(\"cancelLabel\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r13.localization.get(\"cancel\"));\n  }\n}\n\nfunction TimeSelectorComponent_div_8_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 21, 22);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(6, _c58, ctx_r14.handleAccept, ctx_r14.handleFocus, ctx_r14.handleBlur))(\"scope\", ctx_r14)(\"disabled\", ctx_r14.disabled);\n    i0.ɵɵattribute(\"title\", ctx_r14.localization.get(\"acceptLabel\"))(\"aria-label\", ctx_r14.localization.get(\"acceptLabel\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r14.localization.get(\"accept\"));\n  }\n}\n\nfunction TimeSelectorComponent_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵtemplate(1, TimeSelectorComponent_div_8_button_1_Template, 3, 10, \"button\", 17);\n    i0.ɵɵtemplate(2, TimeSelectorComponent_div_8_button_2_Template, 3, 10, \"button\", 18);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.cancelButton);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.setButton);\n  }\n}\n\nconst _c74 = function (a0, a1) {\n  return {\n    keydown: a0,\n    mousedown: a1\n  };\n};\n\nfunction TimePickerComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-timeselector\", 8, 9);\n    i0.ɵɵlistener(\"valueChange\", function TimePickerComponent_ng_template_6_Template_kendo_timeselector_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleChange($event);\n    })(\"valueReject\", function TimePickerComponent_ng_template_6_Template_kendo_timeselector_valueReject_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.handleReject();\n    });\n    i0.ɵɵelement(2, \"kendo-timeselector-messages\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"cancelButton\", ctx_r3.cancelButton)(\"nowButton\", ctx_r3.nowButton)(\"format\", ctx_r3.format)(\"min\", ctx_r3.min)(\"max\", ctx_r3.max)(\"steps\", ctx_r3.steps)(\"value\", ctx_r3.value)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(15, _c74, ctx_r3.handleKeydown, ctx_r3.handleMousedown))(\"scope\", ctx_r3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"acceptLabel\", ctx_r3.localization.get(\"acceptLabel\"))(\"accept\", ctx_r3.localization.get(\"accept\"))(\"cancelLabel\", ctx_r3.localization.get(\"cancelLabel\"))(\"cancel\", ctx_r3.localization.get(\"cancel\"))(\"nowLabel\", ctx_r3.localization.get(\"nowLabel\"))(\"now\", ctx_r3.localization.get(\"now\"));\n  }\n}\n\nfunction DateTimePickerComponent_ng_template_7_button_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 23);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r5.popupButtonsClasses())(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(6, _c1, ctx_r5.handleCancel))(\"scope\", ctx_r5);\n    i0.ɵɵattribute(\"title\", ctx_r5.localization.get(\"cancelLabel\"))(\"aria-label\", ctx_r5.localization.get(\"cancelLabel\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.localization.get(\"cancel\"), \" \");\n  }\n}\n\nconst _c103 = function (a0, a1) {\n  return {\n    mousedown: a0,\n    keydown: a1\n  };\n};\n\nconst _c104 = function (a0, a1) {\n  return {\n    focusin: a0,\n    focusout: a1\n  };\n};\n\nconst _c105 = function (a0, a1) {\n  return {\n    click: a0,\n    keydown: a1\n  };\n};\n\nconst _c106 = function (a0) {\n  return {\n    transitionend: a0\n  };\n};\n\nconst _c107 = function (a0, a1, a2) {\n  return {\n    keydown: a0,\n    focusin: a1,\n    focusout: a2\n  };\n};\n\nfunction DateTimePickerComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 7)(1, \"div\", 8)(2, \"div\", 9)(3, \"button\", 10);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"button\", 11);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(7, \"div\", 12, 13)(9, \"div\", 14)(10, \"kendo-calendar\", 15);\n    i0.ɵɵlistener(\"valueChange\", function DateTimePickerComponent_ng_template_7_Template_kendo_calendar_valueChange_10_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.calendarValue = $event;\n    })(\"valueChange\", function DateTimePickerComponent_ng_template_7_Template_kendo_calendar_valueChange_10_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.handleCalendarValueChange();\n    });\n    i0.ɵɵelement(11, \"kendo-calendar-messages\", 16);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(12, \"div\", 17)(13, \"kendo-timeselector\", 18);\n    i0.ɵɵelement(14, \"kendo-timeselector-messages\", 19);\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(15, \"div\", 20);\n    i0.ɵɵtemplate(16, DateTimePickerComponent_ng_template_7_button_16_Template, 2, 8, \"button\", 21);\n    i0.ɵɵelementStart(17, \"button\", 22);\n    i0.ɵɵtext(18);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const _r4 = i0.ɵɵreference(8);\n\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"k-datetime-wrap k-\", ctx_r3.activeTab, \"-tab\");\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(65, _c103, ctx_r3.preventMouseDown, ctx_r3.handleKeyDown))(\"scope\", ctx_r3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(68, _c104, ctx_r3.handleFocus, ctx_r3.handleBlur))(\"scope\", ctx_r3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"k-active\", ctx_r3.activeTab === \"date\");\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.popupButtonsClasses())(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(71, _c105, ctx_r3.changeActiveTab.bind(ctx_r3, \"date\"), ctx_r3.handleBackTabOut))(\"scope\", ctx_r3);\n    i0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"dateTabLabel\"))(\"aria-label\", ctx_r3.localization.get(\"dateTabLabel\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"dateTab\"), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-active\", ctx_r3.activeTab === \"time\");\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.popupButtonsClasses())(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(74, _c1, ctx_r3.changeActiveTab.bind(ctx_r3, \"time\")));\n    i0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"timeTabLabel\"))(\"aria-label\", ctx_r3.localization.get(\"timeTabLabel\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"timeTab\"), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"transition\", ctx_r3.tabSwitchTransition);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(76, _c106, ctx_r3.handleTabChangeTransitionEnd.bind(ctx_r3, _r4)));\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"focusedDate\", ctx_r3.focusedDate)(\"value\", ctx_r3.calendarValue)(\"type\", ctx_r3.calendarType)(\"min\", ctx_r3.calendarMin)(\"max\", ctx_r3.calendarMax)(\"weekNumber\", ctx_r3.weekNumber)(\"navigation\", false)(\"animateNavigation\", ctx_r3.animateCalendarNavigation)(\"cellTemplate\", ctx_r3.cellTemplate)(\"monthCellTemplate\", ctx_r3.monthCellTemplate)(\"yearCellTemplate\", ctx_r3.yearCellTemplate)(\"decadeCellTemplate\", ctx_r3.decadeCellTemplate)(\"centuryCellTemplate\", ctx_r3.centuryCellTemplate)(\"weekNumberTemplate\", ctx_r3.weekNumberTemplate)(\"headerTitleTemplate\", ctx_r3.headerTitleTemplate)(\"disabled\", ctx_r3.disableCalendar)(\"disabledDates\", ctx_r3.disabledDates);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"today\", ctx_r3.localization.get(\"today\"))(\"prevButtonTitle\", ctx_r3.localization.get(\"prevButtonTitle\"))(\"nextButtonTitle\", ctx_r3.localization.get(\"nextButtonTitle\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"value\", ctx_r3.value)(\"format\", ctx_r3.timeSelectorFormat)(\"min\", ctx_r3.timeSelectorMin)(\"max\", ctx_r3.timeSelectorMax)(\"setButton\", false)(\"cancelButton\", false)(\"steps\", ctx_r3.steps)(\"disabled\", ctx_r3.disableTimeSelector);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"now\", ctx_r3.localization.get(\"now\"))(\"nowLabel\", ctx_r3.localization.get(\"nowLabel\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction3(78, _c107, ctx_r3.handleTabOut, ctx_r3.handleFocus, ctx_r3.handleBlur))(\"scope\", ctx_r3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.cancelButton);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.popupButtonsClasses(\"primary\"))(\"disabled\", !ctx_r3.calendarValue)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(82, _c1, ctx_r3.handleAccept))(\"scope\", ctx_r3);\n    i0.ɵɵattribute(\"title\", ctx_r3.localization.get(\"acceptLabel\"))(\"aria-label\", ctx_r3.localization.get(\"acceptLabel\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.localization.get(\"accept\"), \" \");\n  }\n}\n\nconst _c108 = function (a0, a1) {\n  return {\n    mousedown: a0,\n    click: a1\n  };\n};\n\nconst _c109 = function (a0, a1) {\n  return {\n    \"k-i-calendar\": a0,\n    \"k-i-clock\": a1\n  };\n};\n\nconst _c110 = [\"defaultTemplate\"];\n\nfunction DateRangePopupComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-multiviewcalendar\", 2);\n  }\n}\n\nfunction DateRangeComponent_kendo_daterange_popup_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-daterange-popup\");\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dateinputs',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1652250169,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nvar Action = /*#__PURE__*/(() => {\n  (function (Action) {\n    Action[Action[\"Left\"] = 0] = \"Left\";\n    Action[Action[\"Right\"] = 1] = \"Right\";\n    Action[Action[\"Up\"] = 2] = \"Up\";\n    Action[Action[\"Down\"] = 3] = \"Down\";\n    Action[Action[\"PrevView\"] = 4] = \"PrevView\";\n    Action[Action[\"NextView\"] = 5] = \"NextView\";\n    Action[Action[\"FirstInView\"] = 6] = \"FirstInView\";\n    Action[Action[\"LastInView\"] = 7] = \"LastInView\";\n    Action[Action[\"LowerView\"] = 8] = \"LowerView\";\n    Action[Action[\"UpperView\"] = 9] = \"UpperView\";\n  })(Action || (Action = {}));\n\n  return Action;\n})();\n\n/**\n * @hidden\n *\n * The Enum which defines all possible Calendar view types.\n */\nvar CalendarViewEnum = /*#__PURE__*/(() => {\n  (function (CalendarViewEnum) {\n    CalendarViewEnum[CalendarViewEnum[\"month\"] = 0] = \"month\";\n    CalendarViewEnum[CalendarViewEnum[\"year\"] = 1] = \"year\";\n    CalendarViewEnum[CalendarViewEnum[\"decade\"] = 2] = \"decade\";\n    CalendarViewEnum[CalendarViewEnum[\"century\"] = 3] = \"century\";\n  })(CalendarViewEnum || (CalendarViewEnum = {}));\n\n  return CalendarViewEnum;\n})();\n\n/**\n * @hidden\n */\nconst MIDNIGHT_DATE = new Date(1980, 0, 1);\n/**\n * @hidden\n */\n\nconst MIN_DATE = new Date(1900, 0, 1);\n/**\n * @hidden\n */\n\nconst MAX_DATE = new Date(2099, 11, 31);\n/**\n * @hidden\n */\n\nconst MIN_TIME = new Date(1980, 0, 1);\n/**\n * @hidden\n */\n\nconst MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);\n/**\n * @hidden\n */\n\nconst EMPTY_SELECTIONRANGE = {\n  start: null,\n  end: null\n};\n/**\n * @hidden\n */\n\nconst requiresZoneOnBlur = ngControl => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === 'blur');\n/**\n * @hidden\n */\n\n\nconst preventDefault = args => args.preventDefault();\n/**\n * @hidden\n */\n\n\nconst currentFocusTarget = blurArgs => blurArgs.relatedTarget || document.activeElement;\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== undefined && value !== null;\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are numbers, returns `true.\n */\n\n\nconst isNumberArray = value => Array.isArray(value) && value.length > 0 && value.every(item => typeof item === 'number');\n/**\n * @hidden\n *\n * If the provided parameter is an array with at least one item\n * and all items in the array are dates, returns `true`.\n */\n\n\nconst isDateArray = value => Array.isArray(value) && value.length > 0 && value.every(item => item instanceof Date);\n\nconst isSet = value => value !== null && value !== undefined;\n\nconst setter = method => (date, value) => {\n  const clone = cloneDate(date);\n  clone[method](value);\n  return clone;\n};\n/**\n * @hidden\n */\n\n\nconst setTime = (origin, candidate) => {\n  const date = cloneDate(origin);\n  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());\n  return date;\n};\n\nconst normalizeTimes = (candidate, min, max) => ({\n  candidateValue: setTime(MIDNIGHT_DATE, candidate),\n  maxValue: addDays(setTime(MIDNIGHT_DATE, max), min.getHours() < max.getHours() || min.getHours() === max.getHours() && min.getMinutes() < max.getMinutes() ? 0 : 1),\n  minValue: setTime(MIDNIGHT_DATE, min)\n});\n/**\n * @hidden\n */\n\n\nconst setYears = setter('setFullYear');\n/**\n * @hidden\n */\n\nconst setHours$1 = setter('setHours');\n/**\n * @hidden\n */\n\nconst setMinutes = setter('setMinutes');\n/**\n * @hidden\n */\n\nconst setSeconds = setter('setSeconds');\n/**\n * @hidden\n */\n\nconst setMilliseconds = setter('setMilliseconds');\n/**\n * @hidden\n */\n\nconst range = (start, end, step = 1) => {\n  const result = [];\n\n  for (let i = start; i < end; i = i + step) {\n    result.push(i);\n  }\n\n  return result;\n};\n/**\n * @hidden\n */\n\n\nconst isInRange = (candidate, min, max) => !candidate || !(min && min > candidate || max && max < candidate);\n/**\n * @hidden\n */\n\n\nconst isInTimeRange = (candidate, min, max) => {\n  if (!candidate || !min || !max) {\n    return true;\n  }\n\n  const {\n    candidateValue,\n    minValue,\n    maxValue\n  } = normalizeTimes(candidate, min, max);\n  return minValue <= candidateValue && candidateValue <= maxValue;\n};\n/**\n * @hidden\n */\n\n\nconst isValidRange = (min, max) => !isSet(min) || !isSet(max) || min <= max;\n/**\n * @hidden\n */\n\n\nconst dateInRange = (candidate, min, max) => {\n  if (!candidate) {\n    return candidate;\n  }\n\n  if (min && candidate < min) {\n    return cloneDate(min);\n  }\n\n  if (max && candidate > max) {\n    return cloneDate(max);\n  }\n\n  return candidate;\n};\n/**\n * @hidden\n */\n\n\nconst timeInRange = (candidate, min, max) => {\n  if (!candidate || !min || !max) {\n    return candidate;\n  }\n\n  const {\n    candidateValue,\n    minValue,\n    maxValue\n  } = normalizeTimes(candidate, min, max);\n\n  if (candidateValue < minValue) {\n    return setTime(candidate, min);\n  }\n\n  if (candidateValue > maxValue) {\n    return setTime(candidate, max);\n  }\n\n  return candidate;\n};\n/**\n * @hidden\n */\n\n\nconst getNow = () => new Date();\n/**\n * @hidden\n */\n\n\nconst getToday = () => getDate(new Date());\n/**\n * @hidden\n */\n\n\nconst noop$2 = _ => {}; // eslint-disable-line no-empty\n\n/**\n * @hidden\n */\n\n\nconst isWindowAvailable = () => {\n  return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n\nconst stringifyClassObject = classes => {\n  const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;\n\n  return Object.keys(classes).reduce(pushToAcc, []).join(' ');\n};\n/**\n * @hidden\n */\n\n\nconst shiftWeekNames = (names, offset) => names.slice(offset).concat(names.slice(0, offset));\n/**\n * @hidden\n */\n\n\nconst approximateStringMatching = (oldTextOrigin, oldFormat, newTextOrigin, caret) => {\n  // Remove the right part of the cursor.\n  //oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n  const oldIndex = caret + oldTextOrigin.length - newTextOrigin.length;\n  const oldTextSeparator = oldTextOrigin[oldIndex];\n  const oldText = oldTextOrigin.substring(0, caret + oldTextOrigin.length - newTextOrigin.length);\n  const newText = newTextOrigin.substring(0, caret);\n  const diff = []; // Handle typing a single character over the same selection.\n\n  if (oldText === newText && caret > 0) {\n    diff.push([oldFormat[caret - 1], newText[caret - 1]]);\n    return diff;\n  }\n\n  if (oldText.indexOf(newText) === 0 && (newText.length === 0 || oldFormat[newText.length - 1] !== oldFormat[newText.length])) {\n    // Handle Delete/Backspace.\n    let deletedSymbol = \"\"; //XXX:\n    // Whole text is replaced with a same char\n    // Nasty patch required to keep the selection in the first segment\n\n    if (newText.length === 1) {\n      diff.push([oldFormat[0], newText[0]]);\n    }\n\n    for (let i = newText.length; i < oldText.length; i++) {\n      if (oldFormat[i] !== deletedSymbol && oldFormat[i] !== \"_\") {\n        deletedSymbol = oldFormat[i];\n        diff.push([deletedSymbol, \"\"]);\n      }\n    }\n\n    return diff;\n  } // Handle inserting text (the new text is longer than the previous one).\n  // Handle typing over a literal as well.\n\n\n  if (newText.indexOf(oldText) === 0 || oldFormat[caret - 1] === \"_\") {\n    let symbol = oldFormat[0];\n\n    for (let i = Math.max(0, oldText.length - 1); i < oldFormat.length; i++) {\n      if (oldFormat[i] !== \"_\") {\n        symbol = oldFormat[i];\n        break;\n      }\n    }\n\n    return [[symbol, newText[caret - 1]]];\n  } // Handle entering a space or a separator, for navigation to the next item.\n\n\n  if (newText[newText.length - 1] === \" \" || newText[newText.length - 1] === oldTextSeparator && oldFormat[oldIndex] === '_') {\n    return [[oldFormat[caret - 1], \"_\"]];\n  } // Handle typing over a correctly selected part.\n\n\n  return [[oldFormat[caret - 1], newText[caret - 1]]];\n};\n/**\n * @hidden\n */\n\n\nconst domContainerFactory = type => (children, classes = \"\", styles = {}) => {\n  const container = document.createElement(type);\n  container.className = classes;\n  Object.keys(styles).map(key => container.style[key] = styles[key]);\n\n  if (typeof children === 'string') {\n    container.innerHTML = children || '';\n  } else {\n    (children || []).forEach(child => child && container.appendChild(child));\n  }\n\n  return container;\n};\n/**\n * @hidden\n */\n\n\nconst hasChange = (changes, field) => changes[field] !== undefined;\n/**\n * @hidden\n */\n\n\nconst hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== undefined && changes[field].currentValue !== null;\n/**\n * @hidden\n */\n\n\nconst last = (list = []) => list && list[list.length - 1];\n/**\n * @hidden\n */\n\n\nconst isInSelectionRange = (value, selectionRange) => {\n  const {\n    start,\n    end\n  } = selectionRange || EMPTY_SELECTIONRANGE;\n\n  if (!start || !end) {\n    return false;\n  }\n\n  return start < value && value < end;\n};\n/**\n * @hidden\n */\n\n\nconst either = (value1, value2) => value1 || value2;\n/**\n * @hidden\n */\n\n\nconst clampRange = value => ({\n  start: value,\n  end: value\n});\n/**\n * @hidden\n */\n\n\nconst isEqualRange = (initial, updated) => {\n  const {\n    start: initialStart,\n    end: initialEnd\n  } = initial || EMPTY_SELECTIONRANGE;\n  const {\n    start: updatedStart,\n    end: updatedEnd\n  } = updated || EMPTY_SELECTIONRANGE;\n  return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);\n};\n/**\n * @hidden\n */\n\n\nconst areDatesEqual = (first, second) => {\n  first = first || [];\n  second = second || [];\n  return first.length === second.length && first.every((date, index) => isEqual(date, second[index]));\n};\n/**\n * @hidden\n */\n\n\nconst sortDates = dates => {\n  return dates.filter(date => isPresent(date)).sort((a, b) => a.getTime() - b.getTime());\n};\n/**\n * @hidden\n *\n * Creates a new date based on the date information from the specified date portion\n * and the time information from the time portion.\n * If a parameter is not provided, returns `null`.\n */\n\n\nconst mergeDateAndTime = (date, time) => {\n  if (!(date && time)) {\n    return null;\n  }\n\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n};\n/**\n * @hidden\n */\n\n\nconst lastMillisecondOfDate = date => {\n  if (!date) {\n    return null;\n  }\n\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);\n};\n/**\n * @hidden\n *\n * Returns an array with dates ranging between and including the specified start and\n * end dates that are evaluated as disabled.\n */\n\n\nconst disabledDatesInRange = (start, end, isDateDisabled) => {\n  if (!(start && end && isDateDisabled) || start > end) {\n    return [];\n  }\n\n  const dates = [];\n  let current = start;\n\n  while (current <= end) {\n    if (isDateDisabled(current)) {\n      dates.push(current);\n    }\n\n    current = addDays(current, 1);\n  }\n\n  return dates;\n};\n/**\n * @hidden\n *\n * Crops the last two digits from the year of the provided date value.\n */\n\n\nconst cropTwoDigitYear = date => {\n  if (!isPresent(date) || isNaN(date.getTime())) {\n    return 0;\n  }\n\n  return Number(date.getFullYear().toString().slice(-2));\n};\n/**\n * @hidden\n *\n * Used when resetting millisecond segment value in the DateInput\n */\n\n\nconst msPaddingFromFormat = format => {\n  return Array(format.match(/S+(\\1)/)[0].length).join(\"0\");\n};\n/**\n * @hidden\n */\n\n\nconst millisecondDigitsInFormat = format => {\n  const result = format && format.match(/S+(\\1)/);\n  return result ? result[0].length : 0;\n};\n/**\n * @hidden\n */\n\n\nconst millisecondStepFor = digits => {\n  return Math.pow(10, 3 - digits);\n};\n/**\n * @hidden\n *\n * Checks if a tab keydown would would move the focus outside of the calendar.\n */\n\n\nconst isTabExitingCalendar = (calendarType, focusedElement, shiftKey) => {\n  if (!isPresent(focusedElement)) {\n    return false;\n  }\n\n  return calendarType === 'infinite' || // infinte calendar is always exited on first tab keydown\n  calendarType === 'classic' && shiftKey && focusedElement.classList.contains('k-calendar') || // exited on main calendar element focused and back-tab\n  !shiftKey && focusedElement.classList.contains('k-next-view') // exited on next button focused and regular tab\n  ;\n};\n/**\n * @hidden\n * Returns the size class based on the component and size input.\n */\n\n\nconst getSizeClass = (component, size) => {\n  const SIZE_CLASSES = {\n    'small': `k-${component}-sm`,\n    'medium': `k-${component}-md`,\n    'large': `k-${component}-lg`\n  };\n  return SIZE_CLASSES[size];\n};\n/**\n * @hidden\n * Returns the rounded class based on the rounded input.\n */\n\n\nconst getRoundedClass = rounded => {\n  const ROUNDED_CLASSES = {\n    'small': 'k-rounded-sm',\n    'medium': 'k-rounded-md',\n    'large': 'k-rounded-lg',\n    'full': 'k-rounded-full'\n  };\n  return ROUNDED_CLASSES[rounded];\n};\n/**\n * @hidden\n * Return the fillMode class based on the component and fillMode input.\n */\n\n\nconst getFillModeClass = (component, fillMode) => {\n  const FILLMODE_CLASSES = {\n    'solid': `k-${component}-solid`,\n    'flat': `k-${component}-flat`,\n    'outline': `k-${component}-outline`\n  };\n  return FILLMODE_CLASSES[fillMode];\n};\n/**\n * @hidden\n */\n\n\nconst DEFAULT_ROUNDED = 'medium';\n/**\n * @hidden\n */\n\nconst DEFAULT_SIZE = 'medium';\n/**\n * @hidden\n */\n\nconst DEFAULT_FILL_MODE = 'solid';\nconst EMPTY_DATA$3 = [[]];\nconst CELLS_LENGTH$3 = 4;\nconst ROWS_LENGTH$3 = 3;\nconst ACTIONS$3 = {\n  [Action.Left]: date => addDecades(date, -1),\n  [Action.Up]: date => addDecades(date, -5),\n  [Action.Right]: date => addDecades(date, 1),\n  [Action.Down]: date => addDecades(date, 5),\n  [Action.PrevView]: date => addCenturies(date, -1),\n  [Action.NextView]: date => addCenturies(date, 1),\n  [Action.FirstInView]: date => firstDecadeOfCentury(date),\n  [Action.LastInView]: date => lastDecadeOfCentury(date)\n};\n/**\n * @hidden\n */\n\nlet CenturyViewService = /*#__PURE__*/(() => {\n  class CenturyViewService {\n    constructor() {\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addDecades(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addCenturies(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addCenturies(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$3;\n      }\n\n      const cells = range(0, CELLS_LENGTH$3);\n      const firstDate = firstDecadeOfCentury(viewDate);\n      const lastDate = lastDecadeOfCentury(viewDate);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$3).map(rowOffset => {\n        const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH$3);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);\n          const nextCentury = cellDate.getFullYear() > lastDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || nextCentury) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 99;\n    }\n\n    isInRange(candidate, min, max) {\n      const year = firstYearOfDecade(candidate).getFullYear();\n      const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;\n      const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));\n      return createDate(firstYear.getFullYear(), 0, 1);\n    }\n\n    lastDayOfPeriod(date) {\n      const decade = lastDecadeOfCentury(date);\n      const year = lastYearOfDecade(decade);\n      const month = lastMonthOfYear(year);\n      return lastDayOfMonth(month);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 1000 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$3[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return firstYearOfDecade(value).getFullYear().toString();\n    }\n\n    navigationTitle(value) {\n      return value ? firstDecadeOfCentury(value).getFullYear().toString() : '';\n    }\n\n    title(value) {\n      if (!value) {\n        return '';\n      }\n\n      return `${firstDecadeOfCentury(value).getFullYear()} - ${lastDecadeOfCentury(value).getFullYear()}`;\n    }\n\n    rowLength() {\n      return CELLS_LENGTH$3;\n    }\n\n    skip(value, min) {\n      return durationInCenturies(min, value);\n    }\n\n    total(min, max) {\n      return durationInCenturies(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? firstYearOfDecade(current).getFullYear().toString() : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const centuriesToSubtract = viewsCount - viewsInRange;\n        return addCenturies(date, -1 * centuriesToSubtract);\n      }\n\n      return date;\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  }\n\n  CenturyViewService.ɵfac = function CenturyViewService_Factory(t) {\n    return new (t || CenturyViewService)();\n  };\n\n  CenturyViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CenturyViewService,\n    factory: CenturyViewService.ɵfac\n  });\n  return CenturyViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EMPTY_DATA$2 = [[]];\nconst CELLS_LENGTH$2 = 4;\nconst ROWS_LENGTH$2 = 3;\nconst ACTIONS$2 = {\n  [Action.Left]: date => addYears(date, -1),\n  [Action.Up]: date => addYears(date, -5),\n  [Action.Right]: date => addYears(date, 1),\n  [Action.Down]: date => addYears(date, 5),\n  [Action.PrevView]: date => addDecades(date, -1),\n  [Action.NextView]: date => addDecades(date, 1),\n  [Action.FirstInView]: date => firstYearOfDecade(date),\n  [Action.LastInView]: date => lastYearOfDecade(date)\n};\n/**\n * @hidden\n */\n\nlet DecadeViewService = /*#__PURE__*/(() => {\n  class DecadeViewService {\n    constructor() {\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addYears(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addDecades(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addDecades(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$2;\n      }\n\n      const cells = range(0, CELLS_LENGTH$2);\n      const firstDate = firstYearOfDecade(viewDate);\n      const lastDate = lastYearOfDecade(viewDate);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$2).map(rowOffset => {\n        const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$2);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);\n          const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || nextDecade) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return candidate.getFullYear() === expected.getFullYear();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 9;\n    }\n\n    isInRange(candidate, min, max) {\n      const year = candidate.getFullYear();\n      const aboveMin = !min || min.getFullYear() <= year;\n      const belowMax = !max || year <= max.getFullYear();\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      const firstYear = firstYearOfDecade(date);\n      return createDate(firstYear.getFullYear(), 0, 1);\n    }\n\n    lastDayOfPeriod(date) {\n      const year = lastYearOfDecade(date);\n      const month = lastMonthOfYear(year);\n      return lastDayOfMonth(month);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 100 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$2[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return value.getFullYear().toString();\n    }\n\n    navigationTitle(value) {\n      return value ? firstYearOfDecade(value).getFullYear().toString() : '';\n    }\n\n    title(value) {\n      if (!value) {\n        return '';\n      }\n\n      return `${firstYearOfDecade(value).getFullYear()} - ${lastYearOfDecade(value).getFullYear()}`;\n    }\n\n    rowLength() {\n      return CELLS_LENGTH$2;\n    }\n\n    skip(value, min) {\n      return durationInDecades(min, value);\n    }\n\n    total(min, max) {\n      return durationInDecades(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? current.getFullYear().toString() : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const decadesToSubtract = viewsCount - viewsInRange;\n        return addDecades(date, -1 * decadesToSubtract);\n      }\n\n      return date;\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  }\n\n  DecadeViewService.ɵfac = function DecadeViewService_Factory(t) {\n    return new (t || DecadeViewService)();\n  };\n\n  DecadeViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DecadeViewService,\n    factory: DecadeViewService.ɵfac\n  });\n  return DecadeViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EMPTY_DATA$1 = [[]];\nconst CELLS_LENGTH$1 = 7;\nconst ROWS_LENGTH$1 = 6;\nconst ACTIONS$1 = {\n  [Action.Left]: date => addDays(date, -1),\n  [Action.Up]: date => addWeeks(date, -1),\n  [Action.Right]: date => addDays(date, 1),\n  [Action.Down]: date => addWeeks(date, 1),\n  [Action.PrevView]: date => addMonths(date, -1),\n  [Action.NextView]: date => addMonths(date, 1),\n  [Action.FirstInView]: date => firstDayOfMonth(date),\n  [Action.LastInView]: date => lastDayOfMonth(date)\n};\n/**\n * @hidden\n */\n\nlet MonthViewService = /*#__PURE__*/(() => {\n  class MonthViewService {\n    constructor(_intlService) {\n      this._intlService = _intlService;\n\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addDays(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addMonths(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addMonths(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate,\n        isDateDisabled = () => false\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA$1;\n      }\n\n      const firstMonthDate = firstDayOfMonth(viewDate);\n      const firstMonthDay = getDate(firstMonthDate);\n      const lastMonthDate = lastDayOfMonth(viewDate);\n      const lastMonthDay = getDate(lastMonthDate);\n      const backward = -1;\n      const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);\n      const cells = range(0, CELLS_LENGTH$1);\n      const today = getToday();\n      return range(0, ROWS_LENGTH$1).map(rowOffset => {\n        const baseDate = addDays(date, rowOffset * CELLS_LENGTH$1);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);\n          const cellDay = getDate(cellDate);\n          const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;\n          const outOfRange = cellDate < min || cellDate > max;\n\n          if (outOfRange) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: this.value(cellDate),\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: this.isWeekend(cellDate),\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate,\n            isDisabled: isDateDisabled(cellDate),\n            isOtherMonth: otherMonth\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return getDate(candidate).getTime() === getDate(expected).getTime();\n    }\n\n    isInArray(date, dates) {\n      if (dates.length === 0) {\n        return false;\n      }\n\n      const lowerBound = this.beginningOfPeriod(dates[0]);\n      const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));\n      return lowerBound <= date && date < upperBound;\n    }\n\n    isInRange(candidate, min, max) {\n      const value = getDate(candidate);\n      const aboveMin = !min || getDate(min) <= value;\n      const belowMax = !max || value <= getDate(max);\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      return createDate(date.getFullYear(), date.getMonth(), 1);\n    }\n\n    lastDayOfPeriod(date) {\n      return lastDayOfMonth(date);\n    }\n\n    isRangeStart(value) {\n      return !value.getMonth();\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS$1[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return this._intlService.formatDate(value, 'D');\n    }\n\n    navigationTitle(value) {\n      if (!value) {\n        return '';\n      }\n\n      return this.isRangeStart(value) ? value.getFullYear().toString() : this.abbrMonthNames()[value.getMonth()];\n    }\n\n    title(current) {\n      return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;\n    }\n\n    rowLength(options = {}) {\n      return CELLS_LENGTH$1 + (options.prependCell ? 1 : 0);\n    }\n\n    skip(value, min) {\n      return durationInMonths(min, value);\n    }\n\n    total(min, max) {\n      return durationInMonths(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? current.getDate().toString() : \"\";\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const monthsToSubtract = viewsCount - viewsInRange;\n        return addMonths(date, -1 * monthsToSubtract);\n      }\n\n      return date;\n    }\n\n    isWeekend(date) {\n      const {\n        start,\n        end\n      } = this._intlService.weekendRange();\n\n      const day = date.getDay();\n\n      if (end < start) {\n        return day <= end || start <= day;\n      }\n\n      return start <= day && day <= end;\n    }\n\n    abbrMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'abbreviated',\n        type: 'months'\n      });\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n    wideMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'wide',\n        type: 'months'\n      });\n    }\n\n  }\n\n  MonthViewService.ɵfac = function MonthViewService_Factory(t) {\n    return new (t || MonthViewService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  MonthViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MonthViewService,\n    factory: MonthViewService.ɵfac\n  });\n  return MonthViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EMPTY_DATA = [[]];\nconst CELLS_LENGTH = 4;\nconst ROWS_LENGTH = 3;\n\nconst upStep = month => {\n  if (month > 4) {\n    return -5;\n  }\n\n  if (month < 2) {\n    return -2;\n  }\n\n  return -7;\n};\n\nconst downStep = month => {\n  if (month < 7) {\n    return 5;\n  }\n\n  if (month < 10) {\n    return 7;\n  }\n\n  return 2;\n};\n\nconst ACTIONS = {\n  [Action.Left]: date => addMonths(date, -1),\n  [Action.Up]: date => addMonths(date, upStep(date.getMonth())),\n  [Action.Right]: date => addMonths(date, 1),\n  [Action.Down]: date => addMonths(date, downStep(date.getMonth())),\n  [Action.PrevView]: date => addYears(date, -1),\n  [Action.NextView]: date => addYears(date, 1),\n  [Action.FirstInView]: date => firstMonthOfYear(date),\n  [Action.LastInView]: date => lastMonthOfYear(date)\n};\n/**\n * @hidden\n */\n\nlet YearViewService = /*#__PURE__*/(() => {\n  class YearViewService {\n    constructor(_intlService) {\n      this._intlService = _intlService;\n\n      this.dateRange = (start, end) => {\n        if (!isPresent(start) || !isPresent(end)) {\n          return [];\n        }\n\n        const result = [];\n        let current = start;\n\n        while (current <= end) {\n          result.push(current);\n          current = addMonths(current, 1);\n        }\n\n        return result;\n      };\n    }\n\n    addToDate(min, skip) {\n      return addYears(min, skip);\n    }\n\n    datesList(start, count) {\n      return range(0, count).map(i => addYears(start, i));\n    }\n\n    data(options) {\n      const {\n        cellUID,\n        focusedDate,\n        isActiveView,\n        max,\n        min,\n        selectedDates,\n        selectionRange = EMPTY_SELECTIONRANGE,\n        viewDate\n      } = options;\n\n      if (!viewDate) {\n        return EMPTY_DATA;\n      }\n\n      const months = this.abbrMonthNames();\n      const firstDate = firstMonthOfYear(viewDate);\n      const lastDate = lastMonthOfYear(viewDate);\n      const currentYear = firstDate.getFullYear();\n      const cells = range(0, CELLS_LENGTH);\n      const today = getToday();\n      return range(0, ROWS_LENGTH).map(rowOffset => {\n        const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH);\n        return cells.map(cellOffset => {\n          const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);\n          const changedYear = currentYear < cellDate.getFullYear();\n\n          if (!this.isInRange(cellDate, min, max) || changedYear) {\n            return null;\n          }\n\n          const isRangeStart = this.isEqual(cellDate, selectionRange.start);\n          const isRangeEnd = this.isEqual(cellDate, selectionRange.end);\n          const isInMiddle = !isRangeStart && !isRangeEnd;\n          const isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);\n          return {\n            formattedValue: months[cellDate.getMonth()],\n            id: `${cellUID}${cellDate.getTime()}`,\n            isFocused: this.isEqual(cellDate, focusedDate),\n            isSelected: isActiveView && selectedDates.some(date => this.isEqual(cellDate, date)),\n            isWeekend: false,\n            isRangeStart: isRangeStart,\n            isRangeMid: isRangeMid,\n            isRangeEnd: isRangeEnd,\n            isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),\n            isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),\n            isToday: this.isEqual(cellDate, today),\n            title: this.cellTitle(cellDate),\n            value: cellDate\n          };\n        });\n      });\n    }\n\n    isEqual(candidate, expected) {\n      if (!candidate || !expected) {\n        return false;\n      }\n\n      return candidate.getFullYear() === expected.getFullYear() && candidate.getMonth() === expected.getMonth();\n    }\n\n    isInArray(date, dates) {\n      if (!dates.length) {\n        return false;\n      }\n\n      const year = date.getFullYear();\n      return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();\n    }\n\n    isInRange(candidate, min, max) {\n      const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);\n      const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;\n      const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);\n      return aboveMin && belowMax;\n    }\n\n    beginningOfPeriod(date) {\n      if (!date) {\n        return date;\n      }\n\n      return createDate(date.getFullYear(), 0, 1);\n    }\n\n    lastDayOfPeriod(date) {\n      const month = lastMonthOfYear(date);\n      return lastDayOfMonth(month);\n    }\n\n    isRangeStart(value) {\n      return value.getFullYear() % 10 === 0;\n    }\n\n    move(value, action) {\n      const modifier = ACTIONS[action];\n\n      if (!modifier) {\n        return value;\n      }\n\n      return modifier(value);\n    }\n\n    cellTitle(value) {\n      return `${value.getFullYear()} ${this.value(value)}`;\n    }\n\n    navigationTitle(value) {\n      return this.title(value);\n    }\n\n    title(current) {\n      return current ? current.getFullYear().toString() : '';\n    }\n\n    rowLength() {\n      return CELLS_LENGTH;\n    }\n\n    skip(value, min) {\n      return durationInYears(min, value);\n    }\n\n    total(min, max) {\n      return durationInYears(min, max) + 1;\n    }\n\n    value(current) {\n      return current ? this.abbrMonthNames()[current.getMonth()] : '';\n    }\n\n    viewDate(date, max, viewsCount = 1) {\n      const viewsInRange = this.total(date, max);\n\n      if (viewsInRange < viewsCount) {\n        const yearsToSubtract = viewsCount - viewsInRange;\n        return addYears(date, -1 * yearsToSubtract);\n      }\n\n      return date;\n    }\n\n    abbrMonthNames() {\n      return this._intlService.dateFormatNames({\n        nameType: 'abbreviated',\n        type: 'months'\n      });\n    }\n\n    normalize(cellDate, min, max) {\n      if (cellDate < min && this.isEqual(cellDate, min)) {\n        return cloneDate(min);\n      }\n\n      if (cellDate > max && this.isEqual(cellDate, max)) {\n        return cloneDate(max);\n      }\n\n      return cellDate;\n    }\n\n  }\n\n  YearViewService.ɵfac = function YearViewService_Factory(t) {\n    return new (t || YearViewService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  YearViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: YearViewService,\n    factory: YearViewService.ɵfac\n  });\n  return YearViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst services$1 = {\n  [CalendarViewEnum.month]: MonthViewService,\n  [CalendarViewEnum.year]: YearViewService,\n  [CalendarViewEnum.decade]: DecadeViewService,\n  [CalendarViewEnum.century]: CenturyViewService\n};\n\nconst viewOffset = (view, offset) => {\n  const candidate = CalendarViewEnum[CalendarViewEnum[view + offset]];\n  return candidate !== undefined ? candidate : view;\n};\n/**\n * @hidden\n */\n\n\nlet BusViewService = /*#__PURE__*/(() => {\n  class BusViewService {\n    constructor(injector) {\n      this.injector = injector;\n      this.viewChanged = new EventEmitter();\n      this.bottom = CalendarViewEnum.month;\n      this.top = CalendarViewEnum.century;\n    }\n\n    configure(bottom, top) {\n      this.bottom = bottom;\n      this.top = top;\n    }\n\n    service(view) {\n      const serviceType = services$1[view];\n      return serviceType ? this.injector.get(serviceType) : null;\n    }\n\n    moveDown(view) {\n      this.move(view, -1);\n    }\n\n    moveUp(view) {\n      this.move(view, 1);\n    }\n\n    moveToBottom(activeView) {\n      if (activeView === this.bottom) {\n        return;\n      }\n\n      this.viewChanged.emit({\n        view: this.bottom\n      });\n    }\n\n    canMoveDown(view) {\n      return this.bottom < view;\n    }\n\n    canMoveUp(view) {\n      return view < this.top;\n    }\n\n    clamp(view) {\n      if (view < this.bottom) {\n        return this.bottom;\n      }\n\n      if (view > this.top) {\n        return this.top;\n      }\n\n      return view;\n    }\n\n    move(view, offset) {\n      const candidate = this.clamp(viewOffset(view, offset));\n\n      if (candidate === view) {\n        return;\n      }\n\n      this.viewChanged.emit({\n        view: candidate\n      });\n    }\n\n  }\n\n  BusViewService.ɵfac = function BusViewService_Factory(t) {\n    return new (t || BusViewService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  BusViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BusViewService,\n    factory: BusViewService.ɵfac\n  });\n  return BusViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet WeekNamesService = /*#__PURE__*/(() => {\n  class WeekNamesService {\n    constructor(intl) {\n      this.intl = intl;\n    }\n\n    getWeekNames(includeWeekNumber = false) {\n      const weekNames = shiftWeekNames(this.intl.dateFormatNames({\n        nameType: 'short',\n        type: 'days'\n      }), this.intl.firstDay());\n      return includeWeekNumber ? [''].concat(weekNames) : weekNames;\n    }\n\n  }\n\n  WeekNamesService.ɵfac = function WeekNamesService_Factory(t) {\n    return new (t || WeekNamesService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  WeekNamesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WeekNamesService,\n    factory: WeekNamesService.ɵfac\n  });\n  return WeekNamesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n\nconst noop$1 = () => false;\n\nconst DISABLED_DATES_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/';\n/**\n * @hidden\n */\n\nlet DisabledDatesService = /*#__PURE__*/(() => {\n  class DisabledDatesService {\n    constructor() {\n      /**\n       * Emits every time the `isDateDisabled` method changes.\n       */\n      this.changes = new Subject();\n      /**\n       * Based on the user-defined `disabledDates` input evaluates if the date is disabled.\n       * If not set, returns `false`.\n       */\n\n      this.isDateDisabled = noop$1;\n    }\n    /**\n     * Configures the `isDateDisabled` function.\n     *\n     * * If a function is provided, uses it as-is and passes each date to it for evaluation.\n     * The time part is set to `midnight`.\n     * * If a `Date[]` is provided, creates a function that checks the targeted date against\n     * the listed dates and, if the targeted date is listed, marks it as disabled.\n     * * If a `Day[]` is provided, creates a function that evaluates the provided days of the\n     * week as disabled.\n     */\n\n\n    initialize(disabledDates) {\n      if (typeof disabledDates === 'function') {\n        this.isDateDisabled = date => disabledDates(getDate(date));\n      } else if (isNumberArray(disabledDates)) {\n        const disabledWeekDays = new Set(disabledDates);\n\n        this.isDateDisabled = date => disabledWeekDays.has(date.getDay());\n      } else if (isDateArray(disabledDates)) {\n        const normalizedDisabledDates = new Set(disabledDates.map(date => getDate(date).getTime()));\n\n        this.isDateDisabled = date => normalizedDisabledDates.has(getDate(date).getTime());\n      } else {\n        this.isDateDisabled = noop$1;\n        this.notifyInvalidInput(disabledDates);\n      }\n\n      this.notifyServiceChange();\n    }\n\n    notifyInvalidInput(disabledDates) {\n      if (isPresent(disabledDates) && isDevMode()) {\n        throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);\n      }\n    }\n\n    notifyServiceChange() {\n      this.changes.next();\n    }\n\n  }\n\n  DisabledDatesService.ɵfac = function DisabledDatesService_Factory(t) {\n    return new (t || DisabledDatesService)();\n  };\n\n  DisabledDatesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DisabledDatesService,\n    factory: DisabledDatesService.ɵfac\n  });\n  return DisabledDatesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass KForOfContext {\n  constructor($implicit, kForOf, index, count) {\n    this.$implicit = $implicit;\n    this.kForOf = kForOf;\n    this.index = index;\n    this.count = count;\n  }\n\n  get first() {\n    return this.index === 0;\n  }\n\n  get last() {\n    return this.index === this.count - 1;\n  }\n\n  get even() {\n    return this.index % 2 === 0;\n  }\n\n  get odd() {\n    return !this.even;\n  }\n\n}\n/**\n * @hidden\n */\n// eslint-disable-next-line\n\n\nlet KForOf = /*#__PURE__*/(() => {\n  class KForOf {\n    constructor(_viewContainer, _template, _differs) {\n      this._viewContainer = _viewContainer;\n      this._template = _template;\n      this._differs = _differs;\n      this._differ = null;\n    }\n\n    set kForTemplate(value) {\n      if (value) {\n        this._template = value;\n      }\n    }\n\n    ngOnChanges(changes) {\n      if ('kForOf' in changes) {\n        const value = changes.kForOf.currentValue;\n\n        if (this._differ || !value) {\n          return;\n        }\n\n        try {\n          this._differ = this._differs.find(value).create(this.kForTrackBy);\n        } catch (e) {\n          throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging(value)}'.`);\n        }\n      }\n    }\n\n    ngDoCheck() {\n      if (this._differ) {\n        const changes = this._differ.diff(this.kForOf);\n\n        if (changes) {\n          this._applyChanges(changes);\n        }\n      }\n    }\n\n    _applyChanges(changes) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const viewContainerLength = this._viewContainer.length;\n      const dataLength = this.kForOf.length;\n      const tuples = {};\n      changes.forEachOperation((record, _, currentIndex) => {\n        if (currentIndex !== null) {\n          tuples[currentIndex] = record.item;\n        }\n      });\n\n      for (let i = viewContainerLength; i < dataLength; i++) {\n        this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);\n      }\n\n      for (let i = this._viewContainer.length; i > dataLength; i--) {\n        this._viewContainer.remove(i - 1);\n      }\n\n      for (let i = 0; i < this._viewContainer.length; i++) {\n        const view = this._viewContainer.get(i);\n\n        view.context.index = i;\n        view.context.count = length;\n        view.context.$implicit = tuples[i] || null;\n      }\n    }\n\n  }\n\n  KForOf.ɵfac = function KForOf_Factory(t) {\n    return new (t || KForOf)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  KForOf.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: KForOf,\n    selectors: [[\"\", \"kFor\", \"\", \"kForOf\", \"\"]],\n    inputs: {\n      kForOf: \"kForOf\",\n      kForTrackBy: \"kForTrackBy\",\n      kForTemplate: \"kForTemplate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return KForOf;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction getTypeNameForDebugging(type) {\n  return type.name || typeof type;\n}\n/**\n * @hidden\n */\n\n\nlet ViewComponent = /*#__PURE__*/(() => {\n  class ViewComponent {\n    constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {\n      this.bus = bus;\n      this.intl = intl;\n      this.cdr = cdr;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.disabledDatesService = disabledDatesService;\n      this.direction = 'vertical';\n      this.isActive = true;\n      this.selectedDates = [];\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.cellEnter = new EventEmitter();\n      this.cellLeave = new EventEmitter();\n      this.colSpan = 0;\n      this.subscriptions = new Subscription();\n      this.domEvents = [];\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n      this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    ngOnInit() {\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.colSpan = this.service.rowLength({\n        prependCell: this.weekNumber\n      });\n      this.title = this.service.title(this.viewDate);\n      this.updateData();\n\n      if (changes.activeView) {\n        this.currentCellIndex = null;\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.domEvents.forEach(unsubscribeCallback => unsubscribeCallback());\n    }\n\n    isHorizontal() {\n      return this.direction === 'horizontal';\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    shouldRenderCellContent(cellCtx) {\n      return isPresent(cellCtx) && !(!this.isHorizontal() && cellCtx.isOtherMonth);\n    }\n\n    firstDate(rowCtx) {\n      const ctx = this.firstWeekDateContext(rowCtx);\n      return ctx ? ctx.value : null;\n    }\n\n    getWeekNumber(date) {\n      if (!this.weekNumber) {\n        return null;\n      }\n\n      return weekInYear(date, this.intl.firstDay());\n    }\n\n    getWeekNumberContext(rowCtx) {\n      const ctx = this.firstWeekDateContext(rowCtx);\n\n      if (!this.weekNumber || !ctx) {\n        return null;\n      }\n\n      const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();\n      return {\n        formattedValue: weekNumber,\n        id: null,\n        isFocused: false,\n        isSelected: false,\n        isWeekend: false,\n        title: weekNumber,\n        value: cloneDate(ctx.value)\n      };\n    }\n\n    getStyles(context) {\n      const {\n        isRangeEnd,\n        isRangeStart\n      } = context;\n      const isEndActive = this.activeRangeEnd === 'end' && isRangeEnd;\n      const isStartActive = this.activeRangeEnd === 'start' && isRangeStart;\n      return stringifyClassObject({\n        'k-range-end': !context.isOtherMonth && isRangeEnd,\n        'k-range-mid': !context.isOtherMonth && context.isRangeMid,\n        'k-range-split-end': !context.isOtherMonth && context.isRangeSplitEnd,\n        'k-range-split-start': !context.isOtherMonth && context.isRangeSplitStart,\n        'k-range-start': !context.isOtherMonth && isRangeStart,\n        'k-state-active': isStartActive || isEndActive,\n        'k-state-focused': !context.isOtherMonth && this.isActive && context.isFocused,\n        'k-state-selected': !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),\n        'k-today': !context.isOtherMonth && context.isToday,\n        'k-weekend': context.isWeekend,\n        'k-disabled': context.isDisabled,\n        'k-other-month': context.isOtherMonth\n      });\n    }\n\n    tableCellIndex(rowIndex, cellIndex) {\n      return `${rowIndex}:${cellIndex}`;\n    }\n\n    handleWeekNumberClick(week) {\n      const availableDates = week.map(item => item.value).filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.weekNumberCellClick.emit(availableDates);\n    }\n\n    firstWeekDateContext(rowCtx) {\n      if (!this.weekNumber) {\n        return null;\n      }\n\n      let idx = 0;\n      let ctx = this.shouldRenderCellContent(rowCtx[idx]) ? rowCtx[idx] : null;\n\n      while (!ctx && idx < rowCtx.length) {\n        const cellCtx = rowCtx[++idx];\n        ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;\n      }\n\n      return ctx;\n    }\n\n    updateData() {\n      const time = last(this.selectedDates) || getToday();\n      const viewDate = setTime(this.viewDate, time);\n      this.data = this.service.data({\n        cellUID: this.cellUID,\n        focusedDate: this.focusedDate,\n        isActiveView: !this.bus.canMoveDown(this.activeView),\n        max: this.max,\n        min: this.min,\n        selectedDates: this.selectedDates,\n        selectionRange: this.selectionRange,\n        viewDate: viewDate,\n        isDateDisabled: this.disabledDatesService.isDateDisabled,\n        direction: this.direction\n      });\n    }\n\n    intlChange() {\n      this.updateData();\n      this.cdr.markForCheck();\n    }\n\n    disabledDatesChange() {\n      this.updateData();\n      this.cdr.markForCheck();\n    }\n\n    bindEvents() {\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'mouseover', this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, 'mouseleave', this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, 'click', this.clickHandler.bind(this)));\n    }\n\n    clickHandler(args) {\n      const cell = this.closestCell(args);\n\n      if (!cell) {\n        return;\n      }\n\n      const index = cell.getAttribute('data-cell-index');\n      const cellContext = this.cellByIndex(index);\n\n      if (!cellContext.isDisabled) {\n        const {\n          ctrlKey,\n          metaKey,\n          shiftKey\n        } = args;\n        this.cellClick.emit({\n          date: cellContext.value,\n          modifiers: {\n            ctrlKey,\n            metaKey,\n            shiftKey\n          }\n        });\n      }\n    }\n\n    mouseLeaveHandler() {\n      if (this.currentCellIndex) {\n        this.emitCellLeave();\n      }\n    }\n\n    cellMouseoverHandler(args) {\n      const cell = this.closestCell(args);\n\n      if (cell) {\n        const index = cell.getAttribute('data-cell-index');\n\n        if (this.currentCellIndex && this.currentCellIndex !== index) {\n          this.emitCellLeave();\n        }\n\n        const value = this.cellByIndex(index).value;\n        this.cellEnter.emit(value);\n        this.currentCellIndex = index;\n      } else if (this.currentCellIndex) {\n        this.emitCellLeave();\n      }\n    }\n\n    closestCell(eventArgs) {\n      return closestInScope(eventArgs.target, node => node.hasAttribute('data-cell-index'), this.element.nativeElement);\n    }\n\n    emitCellLeave() {\n      const item = this.cellByIndex(this.currentCellIndex);\n\n      if (item) {\n        this.cellLeave.emit(item.value);\n      }\n\n      this.currentCellIndex = null;\n    }\n\n    cellByIndex(index) {\n      const [rowIndex, cellIndex] = index.split(':');\n      return this.data[rowIndex][cellIndex];\n    }\n\n  }\n\n  ViewComponent.ɵfac = function ViewComponent_Factory(t) {\n    return new (t || ViewComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DisabledDatesService));\n  };\n\n  ViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ViewComponent,\n    selectors: [[\"\", \"kendoCalendarView\", \"\"]],\n    inputs: {\n      direction: \"direction\",\n      isActive: \"isActive\",\n      activeView: \"activeView\",\n      cellUID: \"cellUID\",\n      focusedDate: \"focusedDate\",\n      viewDate: \"viewDate\",\n      activeRangeEnd: \"activeRangeEnd\",\n      selectionRange: \"selectionRange\",\n      min: \"min\",\n      max: \"max\",\n      selectedDates: \"selectedDates\",\n      weekNumber: \"weekNumber\",\n      viewIndex: \"viewIndex\",\n      templateRef: \"templateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c0,\n    decls: 4,\n    vars: 2,\n    consts: [[\"emptyCell\", \"\"], [\"class\", \"k-calendar-tr\", \"role\", \"row\", 4, \"ngIf\"], [\"class\", \"k-calendar-tr\", \"role\", \"row\", 4, \"kFor\", \"kForOf\"], [1, \"k-empty\", \"k-calendar-td\"], [\"role\", \"row\", 1, \"k-calendar-tr\"], [\"scope\", \"col\", 1, \"k-calendar-caption\", 3, \"colSpan\"], [3, \"ngIf\"], [4, \"kFor\", \"kForOf\"], [\"class\", \"k-alt k-calendar-td\", 3, \"kendoEventsOutsideAngular\", 4, \"ngIf\", \"ngIfElse\"], [1, \"k-alt\", \"k-calendar-td\", 3, \"kendoEventsOutsideAngular\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"k-calendar-td\", \"role\", \"gridcell\", 3, \"ngClass\", \"title\", 4, \"ngIf\", \"ngIfElse\"], [\"role\", \"gridcell\", 1, \"k-calendar-td\", 3, \"ngClass\", \"title\"], [1, \"k-link\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function ViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ViewComponent_ng_template_0_Template, 2, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, ViewComponent_tr_2_Template, 3, 2, \"tr\", 1);\n        i0.ɵɵtemplate(3, ViewComponent_tr_3_Template, 3, 2, \"tr\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHorizontal());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kForOf\", ctx.data);\n      }\n    },\n    directives: [i7.NgIf, KForOf, i5.EventsOutsideAngularDirective, i7.NgTemplateOutlet, i7.NgClass],\n    encapsulation: 2\n  });\n  return ViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/component-selector */\n\n\nconst DEFAULT_VIEWS_LENGTH = 2;\n/**\n * @hidden\n */\n\nlet HorizontalViewListComponent = /*#__PURE__*/(() => {\n  class HorizontalViewListComponent {\n    constructor(bus, intl, weekService, cdr, element, renderer) {\n      this.bus = bus;\n      this.intl = intl;\n      this.weekService = weekService;\n      this.cdr = cdr;\n      this.element = element;\n      this.renderer = renderer;\n      this.activeView = CalendarViewEnum.month;\n      this.isActive = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.selectedDates = [];\n      this.views = DEFAULT_VIEWS_LENGTH;\n      this.showViewHeader = false;\n      this.animateNavigation = false;\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.cellEnter = new EventEmitter();\n      this.cellLeave = new EventEmitter();\n      this.activeDateChange = new EventEmitter();\n      this.getComponentClass = true;\n      this.weekNames = [];\n      this.dates = [];\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.isMonthView();\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    get getComponentMonthClass() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    get getComponentYearClass() {\n      return this.activeView === CalendarViewEnum.year;\n    }\n\n    get getComponentDecadeClass() {\n      return this.activeView === CalendarViewEnum.decade;\n    }\n\n    get getComponentCenturyClass() {\n      return this.activeView === CalendarViewEnum.century;\n    }\n\n    ngOnChanges(changes) {\n      this.initService();\n\n      if (this.weekNames.length === 0 || changes.weekNumber) {\n        this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n      }\n\n      if (!this.service) {\n        return;\n      }\n\n      this.views = this.views || DEFAULT_VIEWS_LENGTH;\n      const focusedDate = this.focusedDate;\n      const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = this.service.total(this.min, this.max);\n      const activeViewChanged = hasChange(changes, 'activeView');\n      const viewsHasChanged = this.views > 0 && hasChange(changes, 'views');\n\n      if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n        this.activeDate = cloneDate(this.dates[0]);\n        this.activeDateChange.emit(this.activeDate);\n      }\n    }\n\n    ngAfterViewInit() {\n      // make the calendar look the same in the different browsers\n      // which also smoothens the navigation animation\n      if (this.views === 1) {\n        this.setTableMinWidth();\n      }\n    }\n\n    ngOnDestroy() {\n      this.intlSubscription.unsubscribe();\n    }\n\n    initService() {\n      this.service = this.bus.service(this.activeView);\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    getCaptionTitle(date) {\n      return this.service.title(date);\n    }\n\n    getCaptionClass() {\n      return this.isMonthView() ? 'k-month-header' : 'k-meta-header';\n    }\n\n    animateView(action) {\n      const container = this.element.nativeElement;\n      const table = container.querySelector('table'); // the whole width excluding padding/margin\n\n      const initialContainerWidth = parseFloat(getComputedStyle(container).width); // table width\n\n      const tableWidth = parseFloat(getComputedStyle(table).width);\n      this.renderer.setStyle(container, 'width', `${initialContainerWidth}px`);\n      this.renderer.setStyle(container, 'overflow', 'visible'); // initialize an additional view for the animation\n\n      if (action === Action.NextView) {\n        // animating Action.NextView requires adding an additional view before the rendered views\n        this.nextAnimationDate = cloneDate(this.dates[0]);\n      } else {\n        // animating Action.PrevView requires adding an additional view after the rendered views\n        this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);\n      } // run cdr to render the additional view\n\n\n      this.cdr.detectChanges();\n      container.querySelectorAll('table').forEach(table => {\n        this.renderer.setStyle(table, 'width', `${tableWidth}px`);\n\n        if (this.views === 1) {\n          this.renderer.setStyle(table, 'min-width', `${initialContainerWidth}px`);\n        }\n      }); // we always slide by the width of 1 table\n      // cross-browser compatibility is ensured by measuring the client rectangle and substracting the gap\n\n      const tabRect = table.getBoundingClientRect();\n      const containerGap = parseFloat(getComputedStyle(container).columnGap);\n      const start = action === Action.NextView ? 'translateX(0)' : `translateX(-${tabRect.width + containerGap}px)`;\n      const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : 'translateX(0)';\n\n      if (!this.animation) {\n        this.animation = container.animate([{\n          transform: start\n        }, {\n          transform: end\n        }], {\n          duration: 500,\n          easing: 'ease-out'\n        });\n\n        this.animation.oncancel = this.animation.onfinish = () => {\n          // clear all inline styles\n          this.renderer.removeStyle(container, 'width');\n          this.renderer.removeStyle(container, 'overflow');\n          container.querySelectorAll('table').forEach(table => {\n            this.renderer.removeStyle(table, 'width');\n          }); // clear the animation and the animation view\n\n          this.animation = null;\n          this.nextAnimationDate = null;\n          this.prevAnimationDate = null; // run cdr to remove additional animation view from the markup\n\n          this.cdr.detectChanges();\n        };\n      } else {\n        // if animation is already running, cancel it and show the end navigation result on multiple prev/next button clicks\n        this.animation.cancel();\n      }\n    }\n\n    navigate(action) {\n      if (this.animateNavigation && isDocumentAvailable() && isPresent(this.element.nativeElement.animate)) {\n        this.animateView(action);\n      }\n\n      const candidate = this.move(action);\n      const list = this.service.datesList(candidate, this.getTake(this.skip));\n\n      if (this.isListInRange(list)) {\n        this.dates = list;\n      }\n\n      this.activeDate = cloneDate(this.dates[0]);\n      this.focusedDate = cloneDate(candidate);\n      this.cdr.markForCheck();\n      this.activeDateChange.emit(this.activeDate);\n      return cloneDate(candidate);\n    }\n\n    canNavigate(action) {\n      if (!this.service) {\n        return false;\n      }\n\n      return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));\n    }\n\n    setTableMinWidth() {\n      const container = this.element.nativeElement;\n      const table = container.querySelector('table');\n\n      if (table) {\n        const containerWidth = parseFloat(getComputedStyle(container).width);\n        this.renderer.setStyle(table, 'min-width', `${containerWidth}px`);\n      }\n    }\n\n    intlChange() {\n      this.weekNames = this.weekService.getWeekNames(this.weekNumber);\n      this.cdr.markForCheck();\n    }\n\n    clampDate(value) {\n      return dateInRange(value, this.min, this.max);\n    }\n\n    move(action) {\n      return this.service.move(this.dates[0] || this.focusedDate, action);\n    }\n\n    isListInRange(list) {\n      const lowerBound = this.service.beginningOfPeriod(this.min);\n      const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));\n      return lowerBound <= list[0] && list[list.length - 1] < upperBound;\n    }\n\n    isInDates(value) {\n      return this.service.isInArray(value, this.dates);\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.views);\n    }\n\n  }\n\n  HorizontalViewListComponent.ɵfac = function HorizontalViewListComponent_Factory(t) {\n    return new (t || HorizontalViewListComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(WeekNamesService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  HorizontalViewListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HorizontalViewListComponent,\n    selectors: [[\"kendo-calendar-horizontal\"]],\n    hostVars: 16,\n    hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-calendar-view\", ctx.getComponentClass)(\"k-hstack\", ctx.getComponentClass)(\"k-align-items-start\", ctx.getComponentClass)(\"k-justify-content-center\", ctx.getComponentClass)(\"k-calendar-monthview\", ctx.getComponentMonthClass)(\"k-calendar-yearview\", ctx.getComponentYearClass)(\"k-calendar-decadeview\", ctx.getComponentDecadeClass)(\"k-calendar-centuryview\", ctx.getComponentCenturyClass);\n      }\n    },\n    inputs: {\n      cellTemplateRef: \"cellTemplateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\",\n      activeRangeEnd: \"activeRangeEnd\",\n      activeView: \"activeView\",\n      cellUID: \"cellUID\",\n      focusedDate: \"focusedDate\",\n      isActive: \"isActive\",\n      min: \"min\",\n      max: \"max\",\n      selectionRange: \"selectionRange\",\n      selectedDates: \"selectedDates\",\n      views: \"views\",\n      showViewHeader: \"showViewHeader\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\",\n      activeDateChange: \"activeDateChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 3,\n    consts: [[\"tableTemplate\", \"\"], [4, \"ngIf\"], [4, \"kFor\", \"kForOf\"], [\"role\", \"grid\", 1, \"k-content\", \"k-calendar-content\", \"k-calendar-table\", 3, \"ngClass\"], [3, \"ngClass\", 4, \"ngIf\"], [\"class\", \"k-calendar-thead\", 4, \"ngIf\"], [\"kendoCalendarView\", \"\", \"role\", \"rowgroup\", \"direction\", \"horizontal\", 1, \"k-calendar-tbody\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"selectionRange\", \"activeRangeEnd\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\", \"cellEnter\", \"cellLeave\"], [3, \"ngClass\"], [1, \"k-calendar-thead\"], [\"role\", \"row\", 1, \"k-calendar-tr\"], [\"class\", \"k-calendar-th\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-calendar-th\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function HorizontalViewListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 16, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, HorizontalViewListComponent_2_Template, 1, 4, null, 1);\n        i0.ɵɵtemplate(3, HorizontalViewListComponent_3_Template, 1, 4, null, 2);\n        i0.ɵɵtemplate(4, HorizontalViewListComponent_4_Template, 1, 4, null, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.nextAnimationDate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kForOf\", ctx.dates);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.prevAnimationDate);\n      }\n    },\n    directives: [ViewComponent, i7.NgClass, i7.NgIf, i7.NgForOf, i7.NgTemplateOutlet, KForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return HorizontalViewListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet HeaderComponent = /*#__PURE__*/(() => {\n  class HeaderComponent {\n    constructor(bus, cdr, localization, intl, disabledDatesService) {\n      this.bus = bus;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.intl = intl;\n      this.disabledDatesService = disabledDatesService;\n      this.navigate = true;\n      this.todayAvailable = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.rangeLength = 1;\n      this.isPrevDisabled = true;\n      this.isNextDisabled = true;\n      this.showNavigationButtons = false;\n      this.todayButtonClick = new EventEmitter();\n      this.prevButtonClick = new EventEmitter();\n      this.nextButtonClick = new EventEmitter();\n      this.getComponentClass = true;\n      this.subscriptions = new Subscription();\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));\n      this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));\n      this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));\n    }\n\n    ngOnChanges(_) {\n      const service = this.bus.service(this.activeView);\n\n      if (!service) {\n        return;\n      }\n\n      this.activeViewValue = CalendarViewEnum[this.activeView];\n      this.todayMessage = this.localization.get('today');\n      this.setTodayAvailability();\n      this.navigate = this.bus.canMoveUp(this.activeView);\n      this.title = this.getTitle();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    handleTodayClick() {\n      if (!this.todayAvailable) {\n        return;\n      }\n\n      this.bus.moveToBottom(this.activeView);\n      this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));\n    }\n\n    handleNavigation() {\n      if (!this.navigate) {\n        return;\n      }\n\n      this.bus.moveUp(this.activeView);\n    }\n\n    intlChange() {\n      if (this.currentDate && this.bus.service(this.activeView)) {\n        this.title = this.getTitle();\n        this.cdr.markForCheck();\n      }\n    }\n\n    l10nChange() {\n      this.prevButtonTitle = this.localization.get('prevButtonTitle');\n      this.nextButtonTitle = this.localization.get('nextButtonTitle');\n      this.todayMessage = this.localization.get('today');\n      this.cdr.markForCheck();\n    }\n\n    getTitle() {\n      if (!this.currentDate) {\n        return '';\n      }\n\n      const service = this.bus.service(this.activeView);\n      const take = this.rangeLength - 1;\n      const title = service.title(this.currentDate);\n      const nextDate = service.addToDate(this.currentDate, take);\n\n      if (take < 1 || !service.isInRange(nextDate, this.min, this.max)) {\n        return title;\n      }\n\n      return `${title} - ${service.title(nextDate)}`;\n    }\n\n    setTodayAvailability() {\n      const today = getToday();\n      const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));\n      const isDisabled = this.disabledDatesService.isDateDisabled(today);\n      this.todayAvailable = isTodayInRange && !isDisabled;\n      this.cdr.markForCheck();\n    }\n\n  }\n\n  HeaderComponent.ɵfac = function HeaderComponent_Factory(t) {\n    return new (t || HeaderComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(DisabledDatesService));\n  };\n\n  HeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HeaderComponent,\n    selectors: [[\"kendo-calendar-header\"]],\n    hostVars: 4,\n    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-calendar-header\", ctx.getComponentClass)(\"k-hstack\", ctx.getComponentClass);\n      }\n    },\n    inputs: {\n      activeView: \"activeView\",\n      currentDate: \"currentDate\",\n      min: \"min\",\n      max: \"max\",\n      rangeLength: \"rangeLength\",\n      templateRef: \"templateRef\",\n      isPrevDisabled: \"isPrevDisabled\",\n      isNextDisabled: \"isNextDisabled\",\n      showNavigationButtons: \"showNavigationButtons\"\n    },\n    outputs: {\n      todayButtonClick: \"todayButtonClick\",\n      prevButtonClick: \"prevButtonClick\",\n      nextButtonClick: \"nextButtonClick\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 23,\n    consts: [[1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-calendar-title\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [3, \"ngIf\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"k-spacer\"], [1, \"k-calendar-nav\", \"k-hstack\"], [\"class\", \"k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-prev-view\", \"type\", \"button\", 3, \"disabled\", \"title\", \"click\", 4, \"ngIf\"], [1, \"k-today\", \"k-nav-today\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"class\", \"k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button k-next-view\", \"type\", \"button\", 3, \"disabled\", \"title\", \"click\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\", \"k-prev-view\", 3, \"disabled\", \"title\", \"click\"], [1, \"k-icon\", \"k-i-arrow-60-left\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-icon-button\", \"k-next-view\", 3, \"disabled\", \"title\", \"click\"], [1, \"k-icon\", \"k-i-arrow-60-right\"]],\n    template: function HeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtemplate(1, HeaderComponent_ng_template_1_Template, 1, 1, \"ng-template\", 1);\n        i0.ɵɵtemplate(2, HeaderComponent_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(3, \"span\", 3);\n        i0.ɵɵelementStart(4, \"span\", 4);\n        i0.ɵɵtemplate(5, HeaderComponent_button_5_Template, 2, 3, \"button\", 5);\n        i0.ɵɵelementStart(6, \"span\", 6);\n        i0.ɵɵtext(7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, HeaderComponent_button_8_Template, 2, 3, \"button\", 7);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-disabled\", !ctx.navigate);\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(15, _c1, ctx.handleNavigation))(\"scope\", ctx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.templateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.templateRef)(\"ngTemplateOutlet\", ctx.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(17, _c5, ctx.title, ctx.activeViewValue, ctx.currentDate));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.showNavigationButtons);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-disabled\", !ctx.todayAvailable);\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(21, _c1, ctx.handleTodayClick))(\"scope\", ctx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.todayMessage, \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showNavigationButtons);\n      }\n    },\n    directives: [i5.EventsOutsideAngularDirective, i7.NgIf, i7.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return HeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst KEY_TO_ACTION = {\n  '33': Action.PrevView,\n  '34': Action.NextView,\n  '35': Action.LastInView,\n  '36': Action.FirstInView,\n  '37': Action.Left,\n  '38': Action.Up,\n  '39': Action.Right,\n  '40': Action.Down,\n  'meta+38': Action.UpperView,\n  'meta+40': Action.LowerView\n};\n/**\n * @hidden\n */\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(bus) {\n      this.bus = bus;\n    }\n\n    action(event) {\n      const action = `${event.ctrlKey || event.metaKey ? 'meta+' : ''}${event.keyCode}`;\n      return KEY_TO_ACTION[action];\n    }\n\n    move(value, action, activeView) {\n      const service = this.bus.service(activeView);\n\n      if (!service) {\n        return value;\n      }\n\n      if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {\n        this.bus.moveUp(activeView);\n        return value;\n      }\n\n      if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {\n        this.bus.moveDown(activeView);\n        return value;\n      }\n\n      return service.move(value, action);\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(BusViewService));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SelectionService = /*#__PURE__*/(() => {\n  class SelectionService {\n    constructor(bus) {\n      this.bus = bus;\n    }\n\n    performSelection(args) {\n      let {\n        date,\n        modifiers,\n        selectionMode,\n        activeViewEnum,\n        rangePivot\n      } = args;\n      let selectedDates = args.selectedDates.slice();\n\n      if (selectionMode === 'multiple') {\n        if (modifiers.ctrlKey || modifiers.metaKey) {\n          if (this.isDateSelected(selectedDates, date)) {\n            selectedDates = selectedDates.filter(item => !isEqual(item, date));\n          } else {\n            selectedDates.push(date);\n          }\n\n          rangePivot = date;\n        } else if (modifiers.shiftKey) {\n          const [start, end] = sortDates([rangePivot || date, date]);\n          selectedDates = this.bus.service(activeViewEnum).dateRange(start, end);\n          rangePivot = date > selectedDates[0] ? selectedDates[0] : last(selectedDates);\n        } else {\n          selectedDates = [date];\n          rangePivot = date;\n        }\n      } else {\n        selectedDates = [date];\n        rangePivot = date;\n      }\n\n      return {\n        selectedDates,\n        rangePivot\n      };\n    }\n\n    isDateSelected(selectedDates, date) {\n      return selectedDates.some(item => isEqual(item, date));\n    }\n\n  }\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)(i0.ɵɵinject(BusViewService));\n  };\n\n  SelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: SelectionService.ɵfac\n  });\n  return SelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the cell content of the Calendar. To define the cell template, nest an `<ng-template>` tag\n * with the `kendoCalendarCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details\n * about the current cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * > `kendoCalendarCellTemplate` is equivalent to\n * > [`kendoCalendarMonthCellTemplate`]({% slug api_dateinputs_monthcelltemplatedirective %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarCellTemplate let-date>\n *      <span class=\"custom\">{{date.getDate()}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\n\nlet CellTemplateDirective = /*#__PURE__*/(() => {\n  class CellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) {\n    return new (t || CellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  CellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarCellTemplate\", \"\"]]\n  });\n  return CellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the month cell content of the Calendar. To define the month cell template, nest an `<ng-template>` tag\n * with the `kendoCalendarMonthCellTemplate` directive inside the component tag. The template context is set to the current\n * component. To get a reference to the current date, use the `let-date` directive. To provide more details about the current\n * month cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarMonthCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\n\nlet MonthCellTemplateDirective = /*#__PURE__*/(() => {\n  class MonthCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  MonthCellTemplateDirective.ɵfac = function MonthCellTemplateDirective_Factory(t) {\n    return new (t || MonthCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  MonthCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MonthCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarMonthCellTemplate\", \"\"]]\n  });\n  return MonthCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the year cell content of the Calendar. To define the year cell template, nest an\n * `<ng-template>` tag with the `kendoCalendarYearCellTemplate` directive inside the component tag.\n * The template context is set to the current component. To get a reference to the current date, use\n * the `let-date` directive. To provide more details about the current year cell, get a reference to the\n * current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarYearCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent {\n *  public activeView: CalendarView = 'year';\n * }\n * ```\n */\n\n\nlet YearCellTemplateDirective = /*#__PURE__*/(() => {\n  class YearCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  YearCellTemplateDirective.ɵfac = function YearCellTemplateDirective_Factory(t) {\n    return new (t || YearCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  YearCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: YearCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarYearCellTemplate\", \"\"]]\n  });\n  return YearCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the decade cell content of the Calendar. To define the decade cell template, nest an `<ng-template>`\n * tag with the `kendoCalendarDecadeCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n * the current decade cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarDecadeCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent {\n *  public activeView: CalendarView = 'decade';\n * }\n * ```\n */\n\n\nlet DecadeCellTemplateDirective = /*#__PURE__*/(() => {\n  class DecadeCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DecadeCellTemplateDirective.ɵfac = function DecadeCellTemplateDirective_Factory(t) {\n    return new (t || DecadeCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  DecadeCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DecadeCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarDecadeCellTemplate\", \"\"]]\n  });\n  return DecadeCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the century cell content of the Calendar. To define the century cell template, nest an `<ng-template>`\n * tag with the `kendoCalendarCenturyCellTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current date, use the `let-date` directive. To provide more details about\n * the current century cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [activeView]=\"activeView\">\n *    <ng-template kendoCalendarCenturyCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent {\n *  public activeView: CalendarView = 'century';\n * }\n * ```\n */\n\n\nlet CenturyCellTemplateDirective = /*#__PURE__*/(() => {\n  class CenturyCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  CenturyCellTemplateDirective.ɵfac = function CenturyCellTemplateDirective_Factory(t) {\n    return new (t || CenturyCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  CenturyCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CenturyCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarCenturyCellTemplate\", \"\"]]\n  });\n  return CenturyCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the week number cell content in the month view of the Calendar. To define the month week number cell template,\n * nest an `<ng-template>` tag with the `kendoCalendarWeekNumberCellTemplate` directive inside the component tag. The template\n * context is set to the current component. To get a reference to the current date, use the `let-date` directive. To provide more\n * details about the current week number cell, get a reference to the current `cellContext` by using the `let-cellContext` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar [weekNumber]=\"true\">\n *    <ng-template kendoCalendarWeekNumberCellTemplate let-context=\"cellContext\">\n *      <span class=\"custom\">{{context.formattedValue}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\n\nlet WeekNumberCellTemplateDirective = /*#__PURE__*/(() => {\n  class WeekNumberCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  WeekNumberCellTemplateDirective.ɵfac = function WeekNumberCellTemplateDirective_Factory(t) {\n    return new (t || WeekNumberCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  WeekNumberCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: WeekNumberCellTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarWeekNumberCellTemplate\", \"\"]]\n  });\n  return WeekNumberCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the header title of the Calendar. To define the header title template, nest an `<ng-template>` tag\n * with the `kendoCalendarHeaderTitleTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current title, use the `let-title` directive. To provide more details about\n * the current title, get a reference to the current `date` by using the `let-date` directive or get a reference to the\n * current active view  by using the `let-activeView` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarHeaderTitleTemplate let-title>\n *      <span class=\"custom\">{{title}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\n\nlet HeaderTitleTemplateDirective = /*#__PURE__*/(() => {\n  class HeaderTitleTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  HeaderTitleTemplateDirective.ɵfac = function HeaderTitleTemplateDirective_Factory(t) {\n    return new (t || HeaderTitleTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  HeaderTitleTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HeaderTitleTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarHeaderTitleTemplate\", \"\"]]\n  });\n  return HeaderTitleTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst minValidator = minValue => {\n  return control => {\n    const err = {\n      minError: {\n        minValue: minValue,\n        value: control.value\n      }\n    };\n\n    if (!minValue || !control.value) {\n      return null;\n    }\n\n    return control.value < minValue ? err : null;\n  };\n};\n/**\n * @hidden\n */\n\n\nconst maxValidator = maxValue => {\n  return control => {\n    const err = {\n      maxError: {\n        maxValue: maxValue,\n        value: control.value\n      }\n    };\n\n    if (!maxValue || !control.value) {\n      return null;\n    }\n\n    return control.value > maxValue ? err : null;\n  };\n};\n\nconst noop = () => null;\n/**\n * @hidden\n */\n\n\nconst disabledDatesRangeValidator = isDateDisabled => {\n  if (!isPresent(isDateDisabled)) {\n    return noop;\n  }\n\n  return selectedRange => {\n    const isRangeComplete = isPresent(selectedRange) && isPresent(selectedRange.start) && isPresent(selectedRange.end);\n\n    if (!isRangeComplete || selectedRange.start > selectedRange.end) {\n      return null;\n    }\n\n    const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);\n    const error = {\n      disabledDatesInRange: disabledDates\n    };\n    return disabledDates.length ? error : null;\n  };\n};\n/**\n * @hidden\n */\n\n\nlet Messages$1 = /*#__PURE__*/(() => {\n  class Messages$1 extends ComponentMessages {}\n\n  Messages$1.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages$1_BaseFactory;\n    return function Messages$1_Factory(t) {\n      return (ɵMessages$1_BaseFactory || (ɵMessages$1_BaseFactory = i0.ɵɵgetInheritedFactory(Messages$1)))(t || Messages$1);\n    };\n  }();\n\n  Messages$1.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages$1,\n    selectors: [[\"kendo-multiview-calendar-messages-base\"]],\n    inputs: {\n      today: \"today\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages$1;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet MultiViewCalendarLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class MultiViewCalendarLocalizedMessagesDirective extends Messages$1 {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  MultiViewCalendarLocalizedMessagesDirective.ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(t) {\n    return new (t || MultiViewCalendarLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  MultiViewCalendarLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MultiViewCalendarLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoMultiViewCalendarLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages$1,\n      useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return MultiViewCalendarLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst BOTTOM_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK$5 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\n/**\n * @hidden\n */\n\nconst RANGE_CALENDAR_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MultiViewCalendarComponent)\n};\n/**\n * @hidden\n */\n\nconst RANGE_CALENDAR_RANGE_VALIDATORS = {\n  multi: true,\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MultiViewCalendarComponent)\n};\n/**\n * Represents the Kendo UI MultiViewCalendar component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiviewcalendar></kendo-multiviewcalendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\nlet MultiViewCalendarComponent = /*#__PURE__*/(() => {\n  class MultiViewCalendarComponent {\n    constructor(bus, element, navigator, renderer, cdr, zone, disabledDatesService, selectionService) {\n      this.bus = bus;\n      this.element = element;\n      this.navigator = navigator;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.zone = zone;\n      this.disabledDatesService = disabledDatesService;\n      this.selectionService = selectionService;\n      /**\n       * @hidden\n       */\n\n      this.id = guid();\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form.\n       */\n\n      this.rangeValidation = false;\n      /**\n       * Determines whether the built-in validator for disabled\n       * date ranges is enforced when validating a form\n       * ([see example]({% slug disabled_dates_multiviewcalendar %}#toc-validation)).\n       */\n\n      this.disabledDatesRangeValidation = false;\n      /**\n       * Sets the Calendar selection mode\n       * ([see example]({% slug multiple_selection_multiviewcalendar %})).\n       *\n       * The available values are:\n       * * `single` (default)\n       * * `multiple`\n       */\n\n      this.selection = 'single';\n      /**\n       * Sets or gets the `disabled` property of the Calendar and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_multiviewcalendar %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets or gets the `tabindex` property of the Calendar. Based on the\n       * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n       * it determines whether the component is focusable.\n       */\n\n      this.tabindex = 0;\n      /**\n       * @hidden\n       */\n\n      this.isActive = false;\n      /**\n       * @hidden\n       */\n\n      this.isHeaderActive = false;\n      /**\n       * Defines the active view that the Calendar initially renders\n       * ([see example]({% slug activeview_multiviewcalendar %})).\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the bottommost view, to which the user can navigate\n       * ([see example]({% slug dates_multiviewcalendar %}#toc-partial-dates)).\n       */\n\n      this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the topmost view, to which the user can navigate.\n       */\n\n      this.topView = CalendarViewEnum[CalendarViewEnum.century];\n      /**\n       * Determines whether to display a header for every view (for example the month name).\n       */\n\n      this.showViewHeader = false;\n      /**\n       * Determines whether to enable animation when navigating to previous/next view.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateNavigation = false;\n      /**\n       * Determines whether to display a week number column in the `month` view\n       * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Sets or gets the `views` property of the Calendar and\n       * defines the number of rendered months.\n       */\n\n      this.views = 2;\n      /**\n       * Fires when the active view is changed\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * Fires when navigating in the currently active view\n       * ([more information and example]({% slug events_multiviewcalendar %})).\n       */\n\n      this.navigate = new EventEmitter();\n      /**\n       * Fires when a view cell is entered\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.cellEnter = new EventEmitter();\n      /**\n       * Fires when a view cell is leaved\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.cellLeave = new EventEmitter();\n      /**\n       * Fires when the value is changed\n       * ([more information and example]({% slug overview_multiviewcalendar %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.blurEvent = new EventEmitter();\n      this.cellUID = guid();\n      this.isHovered = false;\n      this.isPrevDisabled = true;\n      this.isNextDisabled = true;\n      this.prevView = Action.PrevView;\n      this.nextView = Action.NextView;\n      this.selectedDates = [];\n      this._min = new Date(MIN_DATE);\n      this._max = new Date(MAX_DATE);\n      this._focusedDate = getToday();\n      this.resolvedPromise = Promise.resolve();\n      this.onControlChange = noop$2;\n      this.onControlTouched = noop$2;\n      this.onValidatorChange = noop$2;\n      this.minValidateFn = noop$2;\n      this.maxValidateFn = noop$2;\n      this.disabledDatesRangeValidateFn = noop$2;\n      this.subscriptions = new Subscription();\n      this.setClasses(element.nativeElement);\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n\n\n    set focusedDate(focusedDate) {\n      this._focusedDate = focusedDate || getToday();\n    }\n\n    get focusedDate() {\n      return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value.\n     * By default, the `min` value is `1900-1-1`.\n     */\n\n\n    set min(min) {\n      this._min = min || new Date(MIN_DATE);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value.\n     * By default, the `max` value is `2099-12-31`.\n     */\n\n\n    set max(max) {\n      this._max = max || new Date(MAX_DATE);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)\n     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(candidate) {\n      this.verifyValue(candidate);\n      this._value = Array.isArray(candidate) ? candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) : cloneDate(candidate);\n      const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));\n\n      if (!areDatesEqual(selection, this.selectedDates)) {\n        const lastSelected = last(selection);\n        this.rangePivot = cloneDate(lastSelected);\n        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;\n        this.selectedDates = selection;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the dates of the MultiViewCalendar that will be disabled\n     * ([see example]({% slug disabled_dates_multiviewcalendar %})).\n     */\n\n\n    set disabledDates(value) {\n      this.disabledDatesService.initialize(value);\n    }\n    /**\n     * Sets or gets the `selectionRange` property of the Calendar and\n     * defines the selection range of the component\n     * ([see example]({% slug dates_multiviewcalendar %}#toc-selection-range)).\n     */\n\n\n    set selectionRange(range) {\n      this._selectionRange = range;\n\n      if (this.disabledDatesRangeValidation) {\n        this.onValidatorChange();\n      }\n    }\n\n    get selectionRange() {\n      return this._selectionRange;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set cellTemplateRef(template) {\n      this._cellTemplateRef = template;\n    }\n\n    get cellTemplateRef() {\n      return this._cellTemplateRef || this.cellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each month cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set monthCellTemplateRef(template) {\n      this._monthCellTemplateRef = template;\n    }\n\n    get monthCellTemplateRef() {\n      return this._monthCellTemplateRef || this.monthCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each year cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set yearCellTemplateRef(template) {\n      this._yearCellTemplateRef = template;\n    }\n\n    get yearCellTemplateRef() {\n      return this._yearCellTemplateRef || this.yearCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each decade cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set decadeCellTemplateRef(template) {\n      this._decadeCellTemplateRef = template;\n    }\n\n    get decadeCellTemplateRef() {\n      return this._decadeCellTemplateRef || this.decadeCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each century cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set centuryCellTemplateRef(template) {\n      this._centuryCellTemplateRef = template;\n    }\n\n    get centuryCellTemplateRef() {\n      return this._centuryCellTemplateRef || this.centuryCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for the week cell.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set weekNumberTemplateRef(template) {\n      this._weekNumberTemplateRef = template;\n    }\n\n    get weekNumberTemplateRef() {\n      return this._weekNumberTemplateRef || this.weekNumberTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for the header title.\n     * Takes precedence over nested templates in the KendoMultiViewCalendar tag.\n     */\n\n\n    set headerTitleTemplateRef(template) {\n      this._headerTitleTemplateRef = template;\n    }\n\n    get headerTitleTemplateRef() {\n      return this._headerTitleTemplateRef || this.headerTitleTemplate;\n    }\n\n    get activeViewEnum() {\n      const activeView = CalendarViewEnum[this.activeView];\n      return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n\n    get bottomViewEnum() {\n      return CalendarViewEnum[this.bottomView];\n    }\n\n    get topViewEnum() {\n      return CalendarViewEnum[this.topView];\n    }\n\n    get widgetId() {\n      return this.id;\n    }\n\n    get calendarTabIndex() {\n      return this.disabled ? undefined : this.tabIndex;\n    }\n\n    get ariaDisabled() {\n      return this.disabled;\n    }\n\n    get ariaActivedescendant() {\n      return this.cellUID + this.focusedDate.getTime();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocusout(event) {\n      const relatedTarget = event.relatedTarget;\n\n      if (!this.element.nativeElement.contains(relatedTarget)) {\n        this.blurEvent.emit(event);\n        this.onControlTouched();\n      }\n\n      this.isActive = false;\n      this.isHovered = false; //ensure that hovered is also not active\n\n      this.isHeaderActive = this.headerElement.nativeElement.contains(relatedTarget);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      this.isActive = true;\n      this.isHeaderActive = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMouseEnter() {\n      this.isHovered = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMouseLeave() {\n      this.isHovered = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMousedown(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleClick() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    keydown(event) {\n      if (this.isHeaderActive) {\n        return;\n      }\n\n      if (event.keyCode === Keys.Enter) {\n        this.performSelection(this.focusedDate, event);\n      }\n\n      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event), this.activeViewEnum), this.min, this.max);\n\n      if (isEqual(this.focusedDate, candidate)) {\n        return;\n      }\n\n      this.focusedDate = candidate;\n      event.preventDefault();\n      const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);\n\n      if (!isSameView) {\n        this.emitNavigate(this.focusedDate);\n      }\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.bus.viewChanged.subscribe(({\n        view\n      }) => {\n        this.activeView = CalendarViewEnum[view];\n        this.activeViewChange.emit(this.activeView);\n        this.cdr.detectChanges();\n        this.updateButtonState();\n      }));\n    }\n\n    ngOnChanges(changes) {\n      this.verifyChanges();\n      this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n\n      if (hasExistingValue(changes, 'focusedDate')) {\n        const focusedDate = changes.focusedDate.currentValue;\n        this.focusedDate = dateInRange(focusedDate, this.min, this.max);\n      }\n\n      if (changes.min || changes.max || changes.rangeValidation || changes.disabledDates || changes.disabledDatesRangeValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;\n        this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop$2;\n        this.onValidatorChange();\n      }\n\n      if (changes.min || changes.max || changes.focusedDate || changes.activeView) {\n        this.updateButtonState();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    ngAfterViewInit() {\n      this.updateButtonState();\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"multiviewcalendar.focus()\">Focus calendar</button>\n     *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n\n\n    blur() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleHeaderFocus() {\n      this.isHeaderActive = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDateChange(args) {\n      const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n      const availableDates = args.selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.focusedDate = args.focusedDate || this.focusedDate;\n      const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);\n\n      if (this.disabled || sameDates) {\n        return;\n      }\n\n      if (canNavigateDown) {\n        this.bus.moveDown(this.activeViewEnum);\n        return;\n      }\n\n      if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {\n        return;\n      }\n\n      this.selectedDates = availableDates.map(date => cloneDate(date));\n      this.value = this.parseSelectionToValue(availableDates);\n      this.onControlChange(this.parseSelectionToValue(availableDates));\n      this.valueChange.emit(this.parseSelectionToValue(availableDates));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleTodayButtonClick(args) {\n      const todayDate = args.focusedDate;\n      const isSameView = this.bus.service(this.activeViewEnum).isInArray(todayDate, this.viewList.dates);\n      const isBottomView = !this.bus.canMoveDown(this.activeViewEnum);\n\n      if (!isSameView && isBottomView) {\n        this.emitNavigate(todayDate);\n      }\n\n      this.handleDateChange(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    setActiveDate(date) {\n      this.activeDate = cloneDate(date);\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(candidate) {\n      this.verifyValue(candidate);\n      this.value = candidate;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeCellTemplate() {\n      switch (this.activeViewEnum) {\n        case CalendarViewEnum.month:\n          return this.monthCellTemplateRef || this.cellTemplateRef;\n\n        case CalendarViewEnum.year:\n          return this.yearCellTemplateRef;\n\n        case CalendarViewEnum.decade:\n          return this.decadeCellTemplateRef;\n\n        case CalendarViewEnum.century:\n          return this.centuryCellTemplateRef;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    navigateView(action) {\n      this.focusedDate = this.viewList.navigate(action);\n      this.updateButtonState();\n      this.emitNavigate(this.focusedDate);\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitNavigate(focusedDate) {\n      const activeView = CalendarViewEnum[this.activeViewEnum];\n      this.navigate.emit({\n        activeView,\n        focusedDate\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitCellEvent(emitter, args) {\n      if (hasObservers(emitter)) {\n        this.zone.run(() => {\n          emitter.emit(args);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCellClick({\n      date,\n      modifiers\n    }) {\n      this.performSelection(date, modifiers);\n      const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);\n\n      if (!isSameView) {\n        this.emitNavigate(this.focusedDate);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWeekNumberClick(dates) {\n      if (this.selection === 'single') {\n        return;\n      }\n\n      this.zone.run(() => {\n        this.handleDateChange({\n          selectedDates: dates,\n          focusedDate: last(dates)\n        });\n      });\n    }\n\n    setClasses(element) {\n      this.renderer.addClass(element, 'k-widget');\n      this.renderer.addClass(element, 'k-calendar');\n      this.renderer.addClass(element, 'k-calendar-range');\n    }\n\n    verifyChanges() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);\n      }\n\n      if (this.bottomViewEnum > this.topViewEnum) {\n        throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);\n      }\n    }\n\n    verifyValue(candidate) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);\n      } else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {\n        const onlyDates = candidate.every(value => value instanceof Date);\n\n        if (!onlyDates) {\n          throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);\n        }\n      }\n    }\n\n    updateButtonState() {\n      this.resolvedPromise.then(() => {\n        this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);\n        this.isNextDisabled = !this.viewList.canNavigate(this.nextView);\n        this.cdr.markForCheck();\n      });\n    }\n\n    parseSelectionToValue(selection) {\n      selection = selection || [];\n      return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));\n    }\n\n    performSelection(date, selectionModifiers) {\n      const selection = this.selectionService.performSelection({\n        date: date,\n        modifiers: selectionModifiers,\n        selectionMode: this.selection,\n        activeViewEnum: this.activeViewEnum,\n        rangePivot: this.rangePivot,\n        selectedDates: this.selectedDates\n      });\n      this.rangePivot = selection.rangePivot;\n      this.handleDateChange({\n        selectedDates: selection.selectedDates,\n        focusedDate: date\n      });\n    }\n\n  }\n\n  MultiViewCalendarComponent.ɵfac = function MultiViewCalendarComponent_Factory(t) {\n    return new (t || MultiViewCalendarComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DisabledDatesService), i0.ɵɵdirectiveInject(SelectionService));\n  };\n\n  MultiViewCalendarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MultiViewCalendarComponent,\n    selectors: [[\"kendo-multiviewcalendar\"]],\n    contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n      }\n    },\n    viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(HeaderComponent, 5, ElementRef);\n        i0.ɵɵviewQuery(HorizontalViewListComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewList = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusout\", function MultiViewCalendarComponent_focusout_HostBindingHandler($event) {\n          return ctx.handleFocusout($event);\n        })(\"focus\", function MultiViewCalendarComponent_focus_HostBindingHandler() {\n          return ctx.handleFocus();\n        })(\"mouseenter\", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() {\n          return ctx.handleMouseEnter();\n        })(\"mouseleave\", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() {\n          return ctx.handleMouseLeave();\n        })(\"mousedown\", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) {\n          return ctx.handleMousedown($event);\n        })(\"click\", function MultiViewCalendarComponent_click_HostBindingHandler() {\n          return ctx.handleClick();\n        })(\"keydown\", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.widgetId)(\"tabindex\", ctx.calendarTabIndex)(\"aria-disabled\", ctx.ariaDisabled)(\"aria-activedescendant\", ctx.ariaActivedescendant);\n        i0.ɵɵclassProp(\"k-disabled\", ctx.ariaDisabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      focusedDate: \"focusedDate\",\n      min: \"min\",\n      max: \"max\",\n      rangeValidation: \"rangeValidation\",\n      disabledDatesRangeValidation: \"disabledDatesRangeValidation\",\n      selection: \"selection\",\n      value: \"value\",\n      disabled: \"disabled\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      isActive: \"isActive\",\n      disabledDates: \"disabledDates\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      showViewHeader: \"showViewHeader\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\",\n      activeRangeEnd: \"activeRangeEnd\",\n      selectionRange: \"selectionRange\",\n      views: \"views\",\n      cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n      monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n      yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n      decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n      centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n      weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n      headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"]\n    },\n    outputs: {\n      activeViewChange: \"activeViewChange\",\n      navigate: \"navigate\",\n      cellEnter: \"cellEnter\",\n      cellLeave: \"cellLeave\",\n      valueChange: \"valueChange\",\n      blurEvent: \"blur\"\n    },\n    exportAs: [\"kendo-multiviewcalendar\"],\n    features: [i0.ɵɵProvidersFeature([BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiviewcalendar'\n    }, NavigationService, SelectionService]), i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 28,\n    consts: function () {\n      let i18n_6;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.multiviewcalendar.today\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_7 = goog.getMsg(\"Today\");\n        i18n_6 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_7;\n      } else {\n        i18n_6 = $localize`:kendo.multiviewcalendar.today|The label for the today button in the calendar header:Today`;\n      }\n\n      let i18n_8;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the previous button in the Multiview calendar\n         * @meaning kendo.multiviewcalendar.prevButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_9 = goog.getMsg(\"Navigate to previous view\");\n        i18n_8 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_9;\n      } else {\n        i18n_8 = $localize`:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar:Navigate to previous view`;\n      }\n\n      let i18n_10;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the next button in the Multiview calendar\n         * @meaning kendo.multiviewcalendar.nextButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_11 = goog.getMsg(\"Navigate to next view\");\n        i18n_10 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_11;\n      } else {\n        i18n_10 = $localize`:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar:Navigate to next view`;\n      }\n\n      return [[\"kendoMultiViewCalendarLocalizedMessages\", \"\", \"today\", i18n_6, \"prevButtonTitle\", i18n_8, \"nextButtonTitle\", i18n_10], [3, \"activeView\", \"currentDate\", \"min\", \"max\", \"rangeLength\", \"templateRef\", \"isPrevDisabled\", \"isNextDisabled\", \"showNavigationButtons\", \"kendoEventsOutsideAngular\", \"scope\", \"todayButtonClick\", \"prevButtonClick\", \"nextButtonClick\"], [3, \"activeView\", \"isActive\", \"cellTemplateRef\", \"weekNumberTemplateRef\", \"cellUID\", \"views\", \"min\", \"max\", \"focusedDate\", \"animateNavigation\", \"showViewHeader\", \"weekNumber\", \"activeRangeEnd\", \"selectionRange\", \"selectedDates\", \"cellClick\", \"weekNumberCellClick\", \"cellEnter\", \"cellLeave\", \"activeDateChange\"]];\n    },\n    template: function MultiViewCalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-calendar-header\", 1);\n        i0.ɵɵlistener(\"todayButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_todayButtonClick_1_listener($event) {\n          return ctx.handleTodayButtonClick({\n            selectedDates: [$event],\n            focusedDate: $event\n          });\n        })(\"prevButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_prevButtonClick_1_listener() {\n          return ctx.navigateView(ctx.prevView);\n        })(\"nextButtonClick\", function MultiViewCalendarComponent_Template_kendo_calendar_header_nextButtonClick_1_listener() {\n          return ctx.navigateView(ctx.nextView);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"kendo-calendar-horizontal\", 2);\n        i0.ɵɵlistener(\"cellClick\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) {\n          return ctx.handleCellClick($event);\n        })(\"weekNumberCellClick\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) {\n          return ctx.handleWeekNumberClick($event);\n        })(\"cellEnter\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) {\n          return ctx.emitCellEvent(ctx.cellEnter, $event);\n        })(\"cellLeave\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) {\n          return ctx.emitCellEvent(ctx.cellLeave, $event);\n        })(\"activeDateChange\", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) {\n          return ctx.setActiveDate($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        let tmp_13_0;\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"activeView\", ctx.activeViewEnum)(\"currentDate\", ctx.activeDate)(\"min\", ctx.min)(\"max\", ctx.max)(\"rangeLength\", ctx.views)(\"templateRef\", ctx.headerTitleTemplateRef == null ? null : ctx.headerTitleTemplateRef.templateRef)(\"isPrevDisabled\", ctx.isPrevDisabled)(\"isNextDisabled\", ctx.isNextDisabled)(\"showNavigationButtons\", true)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(26, _c12, ctx.handleHeaderFocus))(\"scope\", ctx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"activeView\", ctx.activeViewEnum)(\"isActive\", ctx.isActive || ctx.isHovered && !ctx.isHeaderActive)(\"cellTemplateRef\", (tmp_13_0 = ctx.activeCellTemplate()) == null ? null : tmp_13_0.templateRef)(\"weekNumberTemplateRef\", ctx.weekNumberTemplateRef == null ? null : ctx.weekNumberTemplateRef.templateRef)(\"cellUID\", ctx.cellUID)(\"views\", ctx.views)(\"min\", ctx.min)(\"max\", ctx.max)(\"focusedDate\", ctx.focusedDate)(\"animateNavigation\", ctx.animateNavigation)(\"showViewHeader\", ctx.showViewHeader)(\"weekNumber\", ctx.weekNumber)(\"activeRangeEnd\", ctx.activeRangeEnd)(\"selectionRange\", ctx.selectionRange)(\"selectedDates\", ctx.selectedDates);\n      }\n    },\n    directives: [HeaderComponent, HorizontalViewListComponent, MultiViewCalendarLocalizedMessagesDirective, i5.EventsOutsideAngularDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MultiViewCalendarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst update = (arr, idx, value) => [...arr.slice(0, idx + 1), ...arr.slice(idx + 1).map(x => x + value)];\n/**\n * @hidden\n */\n\n\nclass RowHeightService {\n  constructor(total = 0, rowHeight, detailRowHeight) {\n    this.total = total;\n    this.rowHeight = rowHeight;\n    this.detailRowHeight = detailRowHeight;\n    this.offsets = [];\n    this.heights = [];\n    let agg = 0;\n\n    for (let idx = 0; idx < total; idx++) {\n      this.offsets.push(agg);\n      agg += rowHeight;\n      this.heights.push(rowHeight);\n    }\n  }\n\n  height(rowIndex) {\n    return this.heights[rowIndex];\n  }\n\n  expandDetail(rowIndex) {\n    if (this.height(rowIndex) === this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight);\n    }\n  }\n\n  collapseDetail(rowIndex) {\n    if (this.height(rowIndex) > this.rowHeight) {\n      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);\n    }\n  }\n\n  index(position) {\n    if (position < 0) {\n      return undefined;\n    }\n\n    const result = this.offsets.reduce((prev, current, idx) => {\n      if (prev !== undefined) {\n        return prev;\n      } else if (current === position) {\n        return idx;\n      } else if (current > position) {\n        return idx - 1;\n      }\n\n      return undefined;\n    }, undefined);\n    return result === undefined ? this.total - 1 : result;\n  }\n\n  offset(rowIndex) {\n    return this.offsets[rowIndex];\n  }\n\n  totalHeight() {\n    return this.heights.reduce((prev, curr) => prev + curr, 0);\n  }\n\n  updateRowHeight(rowIndex, value) {\n    this.heights[rowIndex] += value;\n    this.offsets = update(this.offsets, rowIndex, value);\n  }\n\n}\n\nconst normalize = x => Math.max(x, 0);\n/**\n * @hidden\n */\n\n\nclass ScrollAction {\n  constructor(offset) {\n    this.offset = offset;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass PageAction {\n  constructor(skip) {\n    this.skip = skip;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ScrollerService {\n  constructor(scrollObservable) {\n    this.scrollObservable = scrollObservable;\n    this.firstLoaded = 0;\n    this.bottomOffset = 0;\n    this.topOffset = 0;\n  }\n\n  create(rowHeightService, skip, take, total, topOffset = 0, bottomOffset = 0, direction = 'vertical') {\n    this.rowHeightService = rowHeightService;\n    this.firstLoaded = skip;\n    this.lastLoaded = skip + take;\n    this.take = take;\n    this.total = total;\n    this.lastScroll = 0;\n    this.topOffset = topOffset;\n    this.bottomOffset = bottomOffset;\n    this.direction = direction;\n    const subject = new ReplaySubject(2);\n    const offsetBufferRows = this.rowsForHeight(topOffset);\n    const skipWithOffset = normalize(skip - offsetBufferRows);\n    subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));\n\n    if (offsetBufferRows) {\n      subject.next(new PageAction(skipWithOffset));\n    }\n\n    this.subscription = new Observable(observer => {\n      this.unsubscribe();\n      this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));\n    }).subscribe(x => subject.next(x));\n    return subject;\n  }\n\n  destroy() {\n    this.unsubscribe();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  onScroll({\n    scrollLeft,\n    scrollTop,\n    offsetHeight,\n    offsetWidth\n  }, observer) {\n    const scrollPosition = this.direction === 'vertical' ? scrollTop : scrollLeft;\n    const offsetSize = this.direction === 'vertical' ? offsetHeight : offsetWidth;\n\n    if (this.lastScroll === scrollPosition) {\n      return;\n    }\n\n    const up = this.lastScroll >= scrollPosition;\n    this.lastScroll = scrollPosition;\n    const firstItemIndex = this.rowHeightService.index(normalize(scrollPosition - this.topOffset));\n    const lastItemIndex = this.rowHeightService.index(normalize(scrollPosition + offsetSize - this.bottomOffset));\n\n    if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {\n      this.firstLoaded = firstItemIndex;\n      observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded));\n    }\n\n    if (up && firstItemIndex <= this.firstLoaded) {\n      const nonVisibleBuffer = Math.floor(this.take * 0.3);\n      this.firstLoaded = normalize(firstItemIndex - nonVisibleBuffer);\n      observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));\n      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);\n      observer.next(new PageAction(this.firstLoaded));\n    }\n  }\n\n  rowOffset(index) {\n    return this.rowHeightService.offset(index) + this.topOffset;\n  }\n\n  rowsForHeight(height) {\n    return Math.ceil(height / this.rowHeightService.height(0));\n  }\n\n  unsubscribe() {\n    if (this.scrollSubscription) {\n      this.scrollSubscription.unsubscribe();\n      this.scrollSubscription = null;\n    }\n  }\n\n}\n/* eslint-disable @angular-eslint/component-selector */\n\n/**\n * @hidden\n */\n\n\nconst SCROLLER_FACTORY_TOKEN = new InjectionToken('dateinputs-scroll-service-factory');\n/**\n * @hidden\n */\n\nfunction DEFAULT_SCROLLER_FACTORY(observable) {\n  return new ScrollerService(observable);\n}\n/**\n * @hidden\n */\n\n\nvar ScrollDirection = /*#__PURE__*/(() => {\n  (function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Backward\"] = 0] = \"Backward\";\n    ScrollDirection[ScrollDirection[\"Forward\"] = 1] = \"Forward\";\n  })(ScrollDirection || (ScrollDirection = {}));\n\n  return ScrollDirection;\n})();\nconst FRAME_DURATION = 17;\nconst scrollModifiers = {\n  [ScrollDirection.Forward]: step => value => value + step,\n  [ScrollDirection.Backward]: step => value => value - step\n};\nconst scrollNormalizers = {\n  [ScrollDirection.Forward]: end => value => Math.min(value, end),\n  [ScrollDirection.Backward]: end => value => Math.max(value, end)\n};\nconst scrollValidators = {\n  [ScrollDirection.Forward]: end => start => start < end,\n  [ScrollDirection.Backward]: end => start => start > end\n};\n\nconst differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {\n  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);\n};\n/**\n * @hidden\n */\n\n\nlet VirtualizationComponent = /*#__PURE__*/(() => {\n  class VirtualizationComponent {\n    constructor(scrollerFactory, container, renderer, zone) {\n      this.container = container;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.direction = 'vertical';\n      this.itemHeight = 1;\n      this.itemWidth = 1;\n      this.topOffset = 0;\n      this.bottomOffset = 0;\n      this.maxScrollDifference = 100;\n      this.scrollOffsetSize = 0;\n      this.scrollDuration = 150;\n      this.activeIndexChange = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.scrollChange = new EventEmitter();\n      this.wrapperClasses = true;\n      this.resolvedPromise = Promise.resolve(null);\n      this.dispatcher = new Subject();\n      this.scroller = scrollerFactory(this.dispatcher);\n    }\n\n    get horizontalClass() {\n      return this.direction === 'horizontal';\n    }\n\n    get totalVertexLength() {\n      const value = `${this.totalSize}px`;\n      return this.direction === 'vertical' ? {\n        height: value\n      } : {\n        width: value\n      };\n    }\n\n    get containerOffsetSize() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'offsetHeight' : 'offsetWidth');\n    }\n\n    get containerScrollSize() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth');\n    }\n\n    get containerScrollPosition() {\n      return this.getContainerProperty(this.direction === 'vertical' ? 'scrollTop' : 'scrollLeft');\n    }\n\n    ngOnChanges(changes) {\n      if (changes.direction || changes.take || changes.total) {\n        this.initServices();\n        this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;\n      }\n    }\n\n    ngOnInit() {\n      if (!this.rowHeightService) {\n        this.rowHeightService = this.createRowHeightService();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.zone.runOutsideAngular(() => {\n        this.containerScrollSubscription = this.scroll$().pipe(map(event => event.target)).subscribe(t => {\n          this.dispatcher.next(t);\n          this.emitActiveIndex();\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.containerScrollSubscription) {\n        this.containerScrollSubscription.unsubscribe();\n      }\n\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n\n      if (this.animationSubscription) {\n        this.animationSubscription.unsubscribe();\n      }\n    }\n\n    getContainerProperty(propertyName) {\n      return this.container.nativeElement[propertyName];\n    }\n\n    activeIndex() {\n      return this.itemIndex(Math.ceil(this.containerScrollPosition)); //handle subpixeling\n    }\n\n    itemIndex(offset) {\n      return this.rowHeightService.index(offset);\n    }\n\n    itemOffset(index) {\n      return this.rowHeightService.offset(index);\n    }\n\n    isIndexVisible(index) {\n      if (!this.rowHeightService) {\n        return false;\n      }\n\n      const containerTop = this.containerScrollPosition;\n      const containerBottom = containerTop + this.containerOffsetSize;\n      const top = this.rowHeightService.offset(index);\n      const bottom = top + this.rowHeightService.height(index);\n      return top >= containerTop && bottom <= containerBottom;\n    }\n\n    isListScrolled(index) {\n      return this.containerScrollPosition !== this.rowHeightService.offset(index);\n    }\n\n    scrollTo(value) {\n      const scrollProperty = this.direction === \"vertical\" ? 'scrollTop' : 'scrollLeft';\n      this.renderer.setProperty(this.container.nativeElement, scrollProperty, value);\n    }\n\n    scrollToIndex(index) {\n      //XXX: scrolling with tick is required to prevent list jump in Chrome.\n      //Original issue: focus first day in the month and press LEFT arrow.\n      //Notice how the view jumps on every day change.\n      //\n      this.zone.runOutsideAngular(() => {\n        this.resolvedPromise.then(() => {\n          this.scrollTo(this.rowHeightService.offset(index));\n        });\n      });\n    }\n\n    scrollToBottom() {\n      this.scrollTo(this.totalSize);\n    }\n\n    animateToIndex(index) {\n      if (this.animationSubscription) {\n        this.animationSubscription.unsubscribe();\n      }\n\n      const indexOffset = this.rowHeightService.offset(index);\n      const direction = this.getContainerScrollDirection(indexOffset);\n      const {\n        start,\n        end\n      } = this.scrollRange(indexOffset, direction);\n\n      if (start === end) {\n        return;\n      }\n\n      const step = this.scrollStep(start, end);\n      const modifyScroll = scrollModifiers[direction](step);\n      const normalizeScroll = scrollNormalizers[direction](end);\n      const isScrollValid = scrollValidators[direction](modifyScroll(end));\n      this.zone.runOutsideAngular(() => {\n        this.animationSubscription = combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map(stream => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe(x => this.scrollTo(x));\n      });\n    }\n\n    scrollRange(indexOffset, direction) {\n      const containerScroll = this.containerScrollPosition;\n\n      if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {\n        return {\n          start: indexOffset,\n          end: indexOffset\n        };\n      }\n\n      const maxScroll = this.containerMaxScroll();\n      const sign = direction === ScrollDirection.Backward ? 1 : -1;\n      const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);\n      const end = Math.min(indexOffset, maxScroll);\n      const start = Math.min(Math.max(end + sign * difference, 0), maxScroll);\n      return {\n        start,\n        end\n      };\n    }\n\n    scrollStep(start, end) {\n      return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);\n    }\n\n    scroll$() {\n      return isDocumentAvailable() ? fromEvent(this.container.nativeElement, 'scroll') : EMPTY;\n    }\n\n    initServices() {\n      this.rowHeightService = this.createRowHeightService();\n\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n\n      this.scrollSubscription = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction).subscribe(x => {\n        if (x instanceof PageAction) {\n          this.pageChange.emit(x);\n        } else {\n          this.scrollChange.emit(x);\n        }\n      });\n    }\n\n    createRowHeightService() {\n      const dimension = this.direction === 'vertical' ? this.itemHeight : this.itemWidth;\n      return new RowHeightService(this.total, dimension, 0);\n    }\n\n    emitActiveIndex() {\n      const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);\n\n      if (this.lastActiveIndex !== index) {\n        this.lastActiveIndex = index;\n        this.activeIndexChange.emit(index);\n      }\n    }\n\n    containerMaxScroll() {\n      return this.containerScrollSize - this.containerOffsetSize;\n    }\n\n    getContainerScrollDirection(indexOffset) {\n      return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;\n    }\n\n  }\n\n  VirtualizationComponent.ɵfac = function VirtualizationComponent_Factory(t) {\n    return new (t || VirtualizationComponent)(i0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  VirtualizationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VirtualizationComponent,\n    selectors: [[\"kendo-virtualization\"]],\n    hostVars: 10,\n    hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-flex\", ctx.wrapperClasses)(\"k-content\", ctx.wrapperClasses)(\"k-calendar-content\", ctx.wrapperClasses)(\"k-scrollable\", ctx.wrapperClasses)(\"k-scrollable-horizontal\", ctx.horizontalClass);\n      }\n    },\n    inputs: {\n      direction: \"direction\",\n      itemHeight: \"itemHeight\",\n      itemWidth: \"itemWidth\",\n      topOffset: \"topOffset\",\n      bottomOffset: \"bottomOffset\",\n      maxScrollDifference: \"maxScrollDifference\",\n      scrollOffsetSize: \"scrollOffsetSize\",\n      scrollDuration: \"scrollDuration\",\n      skip: \"skip\",\n      take: \"take\",\n      total: \"total\"\n    },\n    outputs: {\n      activeIndexChange: \"activeIndexChange\",\n      pageChange: \"pageChange\",\n      scrollChange: \"scrollChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SCROLLER_FACTORY_TOKEN,\n      useValue: DEFAULT_SCROLLER_FACTORY\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c13,\n    decls: 2,\n    vars: 3,\n    consts: [[1, \"k-scrollable-placeholder\", 3, \"ngStyle\"]],\n    template: function VirtualizationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelement(1, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"k-scrollable-horizontal-placeholder\", ctx.direction === \"horizontal\");\n        i0.ɵɵproperty(\"ngStyle\", ctx.totalVertexLength);\n      }\n    },\n    directives: [i7.NgStyle],\n    encapsulation: 2\n  });\n  return VirtualizationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst div$1 = domContainerFactory('div');\nconst ul$1 = domContainerFactory('ul');\nconst li$1 = domContainerFactory('li');\nconst td = domContainerFactory('td');\nconst th = domContainerFactory('th');\nconst tr = domContainerFactory('tr');\nconst tbody = domContainerFactory('tbody');\nconst thead = domContainerFactory('thead');\nconst table = domContainerFactory('table');\n\nconst monthHeader = () => div$1(`\n            <span class=\"k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title\">March 2017</span>\n            <span class=\"k-spacer\"></span>\n            <span class=\"k-calendar-nav k-hstack\">\n                <span class=\"k-today k-nav-today\">TODAY</span>\n            </span>\n        `, 'k-calendar-header k-hstack');\n\nconst monthWeekHeader = () => table([thead([tr([th('MO', 'k-calendar-th')], 'k-calendar-tr')], 'k-calendar-thead')], 'k-calendar-weekdays k-calendar-table');\n\nconst repeat = (count, mapper) => new Array(count).fill('1').map(mapper);\n\nconst content = (rows, cells = 1) => table([tbody([tr([th('1', 'k-calendar-th')], 'k-calendar-tr')].concat(repeat(rows, () => tr(repeat(cells, c => td(`<span class=\"k-link\">${c}</span>`, 'k-calendar-td')), 'k-calendar-tr'))), 'k-calendar-tbody')], 'k-calendar-table');\n\nconst scrollable$1 = children => div$1(children, 'k-flex k-content k-calendar-content k-scrollable');\n\nconst view = (contentElement, className, renderWeekHeader) => div$1([monthHeader(), renderWeekHeader ? monthWeekHeader() : null, scrollable$1([contentElement, contentElement])], className, {\n  left: '-10000px',\n  position: 'absolute'\n});\n\nconst navigationList = (() => {\n  let navElement;\n  return () => {\n    if (!isDocumentAvailable) {\n      return null;\n    }\n\n    if (!navElement) {\n      navElement = div$1([scrollable$1([ul$1([li$1('<span>FEB</span>')])])], 'k-calendar-navigation', {\n        left: '0px',\n        position: 'absolute'\n      });\n    }\n\n    return navElement;\n  };\n})();\n\nconst viewFactory = ({\n  cells,\n  rows\n}, className, renderWeekHeader) => {\n  let viewElement;\n  return () => {\n    if (!isDocumentAvailable) {\n      return null;\n    }\n\n    if (!viewElement) {\n      viewElement = view(content(rows, cells), className, renderWeekHeader);\n    }\n\n    return viewElement;\n  };\n};\n\nconst getScrollable = element => element.querySelector('.k-scrollable');\n\nconst horizontal = element => {\n  const scrollableElement = getScrollable(element);\n  scrollableElement.classList.add('k-scrollable-horizontal');\n  return element;\n};\n\nconst monthView = viewFactory({\n  cells: 7,\n  rows: 6\n}, 'k-vstack k-calendar-view k-calendar-monthview', true);\nconst yearView = viewFactory({\n  cells: 4,\n  rows: 3\n}, 'k-vstack k-calendar-view k-calendar-yearview', false);\nconst decadeView = viewFactory({\n  cells: 4,\n  rows: 3\n}, 'k-vstack k-calendar-view k-calendar-decadeview', false);\n\nconst horzMonthView = () => horizontal(monthView());\n\nconst horzYearView = () => horizontal(yearView());\n\nconst horzDecadeView = () => horizontal(decadeView());\n\nconst height = element => parseFloat(window.getComputedStyle(element).height) || element.offsetHeight;\n\nconst width = element => {\n  const styles = window.getComputedStyle(element);\n  const computed = parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);\n  return computed || element.offsetWidth;\n};\n\nconst getBody = element => element.querySelector('tbody');\n/**\n * @hidden\n */\n\n\nlet CalendarDOMService = /*#__PURE__*/(() => {\n  class CalendarDOMService {\n    ensureHeights() {\n      if (this.calendarHeight !== undefined) {\n        return;\n      }\n\n      this.calculateHeights();\n    }\n\n    calculateHeights(container) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.hostContainer = container;\n      this.batch(monthView(), contentElement => {\n        const viewElement = getBody(contentElement);\n        this.calendarHeight = height(contentElement);\n        this.monthViewHeight = height(viewElement);\n        this.headerHeight = height(viewElement.children[0]);\n        this.scrollableContentHeight = height(getScrollable(contentElement));\n      });\n      this.batch(horzMonthView(), contentElement => {\n        const viewElement = getBody(contentElement);\n        this.calendarWidth = width(contentElement);\n        this.monthViewWidth = width(viewElement);\n        this.scrollableContentWidth = width(getScrollable(contentElement));\n      });\n      this.batch(yearView(), contentElement => {\n        this.yearViewHeight = height(getBody(contentElement));\n        this.scrollableYearContentHeight = height(getScrollable(contentElement));\n      });\n      this.batch(horzYearView(), contentElement => {\n        this.yearViewWidth = width(getBody(contentElement));\n      });\n      this.batch(decadeView(), contentElement => {\n        this.decadeViewHeight = height(getBody(contentElement));\n        this.centuryViewHeight = this.decadeViewHeight;\n      });\n      this.batch(horzDecadeView(), contentElement => {\n        this.decadeViewWidth = width(getBody(contentElement));\n        this.centuryViewWidth = this.decadeViewWidth;\n      });\n      this.batch(navigationList(), contentElement => {\n        this.navigationItemHeight = height(contentElement.querySelector('li'));\n      });\n    }\n\n    viewHeight(viewType) {\n      return this.viewDimension(viewType, 'height');\n    }\n\n    viewWidth(viewType) {\n      return this.viewDimension(viewType, 'width');\n    }\n\n    viewDimension(viewType, dimension) {\n      const viewProp = dimension === 'height' ? 'ViewHeight' : 'ViewWidth';\n\n      switch (viewType) {\n        case CalendarViewEnum.month:\n          return this[`month${viewProp}`];\n\n        case CalendarViewEnum.year:\n          return this[`year${viewProp}`];\n\n        case CalendarViewEnum.decade:\n          return this[`decade${viewProp}`];\n\n        case CalendarViewEnum.century:\n          return this[`century${viewProp}`];\n\n        default:\n          return 1;\n      }\n    }\n\n    batch(contentElement, action) {\n      if (!isPresent(this.hostContainer)) {\n        return;\n      }\n\n      const hostClone = this.hostContainer.cloneNode();\n      document.body.appendChild(hostClone);\n\n      try {\n        const appendedContent = hostClone.appendChild(contentElement);\n        action(appendedContent);\n      } catch (error) {\n        throw error;\n      } finally {\n        document.body.removeChild(hostClone);\n      }\n    }\n\n  }\n\n  CalendarDOMService.ɵfac = function CalendarDOMService_Factory(t) {\n    return new (t || CalendarDOMService)();\n  };\n\n  CalendarDOMService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CalendarDOMService,\n    factory: CalendarDOMService.ɵfac\n  });\n  return CalendarDOMService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/component-selector */\n\n\nconst ITEMS_COUNT = 30;\n/**\n * @hidden\n */\n\nlet NavigationComponent = /*#__PURE__*/(() => {\n  class NavigationComponent {\n    constructor(bus, dom, intl, cdr, renderer) {\n      this.bus = bus;\n      this.dom = dom;\n      this.intl = intl;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.focusedDate = new Date();\n      this.valueChange = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.dates = [];\n      this.take = ITEMS_COUNT;\n      this.indexToScroll = -1;\n    }\n\n    get getComponentClass() {\n      return true;\n    }\n\n    ngOnInit() {\n      this.dom.ensureHeights();\n      const calendarHeight = this.dom.calendarHeight;\n      this.itemHeight = this.dom.navigationItemHeight;\n      this.maxViewHeight = this.dom.monthViewHeight;\n      this.topOffset = (calendarHeight - this.itemHeight) / 2;\n      this.bottomOffset = calendarHeight - this.itemHeight;\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.activeViewValue = CalendarViewEnum[this.activeView];\n      const viewDate = dateInRange(this.focusedDate, this.min, this.max);\n      const total = this.service.total(this.min, this.max);\n      const totalChanged = this.total && this.total !== total;\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = total;\n\n      if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n      }\n\n      if (!!changes.focusedDate || totalChanged) {\n        this.indexToScroll = this.service.skip(this.focusedDate, this.min);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    ngAfterViewChecked() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    onPageChange({\n      skip\n    }) {\n      this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n      this.pageChange.emit();\n    }\n\n    scrollChange({\n      offset\n    }) {\n      const el = this.list.nativeElement;\n      const translate = `translateY(${offset}px)`;\n      this.renderer.setStyle(el, 'transform', translate);\n      this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n\n    handleDateChange(args) {\n      const item = closestInScope(args.target, node => node.hasAttribute('data-date-index'), this.list.nativeElement);\n\n      if (item) {\n        const index = parseInt(item.getAttribute('data-date-index'), 10);\n        const candidate = this.dates[index];\n        this.valueChange.emit(cloneDate(candidate));\n      }\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.take);\n    }\n\n    intlChange() {\n      if (this.activeView === CalendarViewEnum.month) {\n        this.cdr.markForCheck();\n      }\n    }\n\n  }\n\n  NavigationComponent.ɵfac = function NavigationComponent_Factory(t) {\n    return new (t || NavigationComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(CalendarDOMService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  NavigationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NavigationComponent,\n    selectors: [[\"kendo-calendar-navigation\"]],\n    viewQuery: function NavigationComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(VirtualizationComponent, 5);\n        i0.ɵɵviewQuery(_c14, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function NavigationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-calendar-navigation\", ctx.getComponentClass);\n      }\n    },\n    inputs: {\n      activeView: \"activeView\",\n      min: \"min\",\n      max: \"max\",\n      focusedDate: \"focusedDate\",\n      templateRef: \"templateRef\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      pageChange: \"pageChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 12,\n    consts: [[1, \"k-calendar-navigation-highlight\"], [3, \"skip\", \"take\", \"total\", \"itemHeight\", \"topOffset\", \"bottomOffset\", \"maxScrollDifference\", \"pageChange\", \"scrollChange\"], [1, \"k-reset\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"list\", \"\"], [4, \"kFor\", \"kForOf\"], [3, \"ngIf\"], [3, \"ngIf\", \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function NavigationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"span\", 0);\n        i0.ɵɵelementStart(1, \"kendo-virtualization\", 1);\n        i0.ɵɵlistener(\"pageChange\", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) {\n          return ctx.onPageChange($event);\n        })(\"scrollChange\", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) {\n          return ctx.scrollChange($event);\n        });\n        i0.ɵɵelementStart(2, \"ul\", 2, 3);\n        i0.ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 11, \"li\", 4);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"skip\", ctx.skip)(\"take\", ctx.take)(\"total\", ctx.total)(\"itemHeight\", ctx.itemHeight)(\"topOffset\", ctx.topOffset)(\"bottomOffset\", ctx.bottomOffset)(\"maxScrollDifference\", ctx.maxViewHeight);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(10, _c1, ctx.handleDateChange))(\"scope\", ctx);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"kForOf\", ctx.dates);\n      }\n    },\n    directives: [VirtualizationComponent, i5.EventsOutsideAngularDirective, KForOf, i7.NgIf, i7.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NavigationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst VIEWS_COUNT = 5;\n\nconst isEqualMonthYear = (date1, date2) => date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();\n/**\n * @hidden\n */\n\n\nlet ViewListComponent = /*#__PURE__*/(() => {\n  class ViewListComponent {\n    constructor(bus, cdr, intl, dom, renderer) {\n      this.bus = bus;\n      this.cdr = cdr;\n      this.intl = intl;\n      this.dom = dom;\n      this.renderer = renderer;\n      this.isActive = true;\n      this.min = new Date(MIN_DATE);\n      this.max = new Date(MAX_DATE);\n      this.selectedDates = [];\n      this.cellClick = new EventEmitter();\n      this.weekNumberCellClick = new EventEmitter();\n      this.activeDateChange = new EventEmitter();\n      this.todayButtonClick = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.getComponentClass = true;\n      this.dates = [];\n      this.cols = [];\n      this.weekNames = [];\n      this.take = VIEWS_COUNT;\n      this.animateToIndex = true;\n      this.indexToScroll = -1;\n      this.minViewsToRender = 1;\n    }\n\n    get weekNumber() {\n      return this.showWeekNumbers && this.isMonthView();\n    }\n\n    set weekNumber(showWeekNumbers) {\n      this.showWeekNumbers = showWeekNumbers;\n    }\n\n    get getComponentMonthClass() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    get getComponentYearClass() {\n      return this.activeView === CalendarViewEnum.year;\n    }\n\n    get getComponentDecadeClass() {\n      return this.activeView === CalendarViewEnum.decade;\n    }\n\n    get getComponentCenturyClass() {\n      return this.activeView === CalendarViewEnum.century;\n    }\n\n    ngOnInit() {\n      this.weekNames = this.getWeekNames();\n      this.bottomOffset = this.getBottomOffset();\n      this.viewOffset = -1 * this.dom.headerHeight;\n      this.viewHeight = this.dom.viewHeight(this.activeView);\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    }\n\n    ngOnChanges(changes) {\n      this.service = this.bus.service(this.activeView);\n\n      if (!this.service) {\n        return;\n      }\n\n      this.cols = new Array(this.service.rowLength({\n        prependCell: this.weekNumber\n      })).fill('');\n      this.colWidth = Math.round(100 / this.cols.length);\n      this.weekNames = hasChange(changes, 'weekNumber') && this.weekNumber ? this.getWeekNames() : this.weekNames;\n      const activeViewChanged = hasChange(changes, 'activeView');\n      const focusedDate = this.focusedDate;\n      const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);\n      const total = this.service.total(this.min, this.max);\n      const totalChanged = this.total && this.total !== total;\n      const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);\n      this.skip = this.service.skip(viewDate, this.min);\n      this.total = total;\n      this.animateToIndex = !activeViewChanged;\n      this.bottomOffset = this.getBottomOffset();\n      this.viewHeight = this.dom.viewHeight(this.activeView);\n\n      if (generateDates) {\n        this.dates = this.service.datesList(viewDate, this.getTake(this.skip));\n      }\n\n      if (!isEqualMonthYear(this.activeDate, focusedDate)) {\n        this.activeDate = cloneDate(focusedDate);\n      }\n\n      const updateIndex = hasChange(changes, 'focusedDate') || activeViewChanged;\n\n      if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {\n        this.indexToScroll = this.service.skip(focusedDate, this.min);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization.scrollToIndex(this.indexToScroll);\n      this.indexToScroll = -1;\n    }\n\n    ngAfterViewChecked() {\n      if (this.indexToScroll === -1) {\n        return;\n      }\n\n      this.virtualization[this.animateToIndex ? 'animateToIndex' : 'scrollToIndex'](this.indexToScroll);\n      this.animateToIndex = true;\n      this.indexToScroll = -1;\n    }\n\n    onPageChange({\n      skip\n    }) {\n      this.dates = this.service.datesList(this.service.addToDate(this.min, skip), this.getTake(skip));\n      this.pageChange.emit();\n    }\n\n    scrollChange({\n      offset\n    }) {\n      const el = this.list.nativeElement;\n      const translate = `translateY(${offset}px)`;\n      this.renderer.setStyle(el, 'transform', translate);\n      this.renderer.setStyle(el, '-ms-transform', translate);\n    }\n\n    setActiveDate(index) {\n      const candidate = this.service.addToDate(this.min, index);\n      this.activeDate = candidate;\n      this.activeDateChange.emit(candidate);\n      this.cdr.detectChanges();\n    }\n\n    isMonthView() {\n      return this.activeView === CalendarViewEnum.month;\n    }\n\n    isScrolled() {\n      return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));\n    }\n\n    getBottomOffset() {\n      return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);\n    }\n\n    getScrollableHeight() {\n      return this.activeView === CalendarViewEnum.month ? this.dom.scrollableContentHeight : this.dom.scrollableYearContentHeight;\n    }\n\n    getTake(skip) {\n      return Math.min(this.total - skip, this.take);\n    }\n\n    getWeekNames() {\n      const weekNames = shiftWeekNames(this.intl.dateFormatNames({\n        nameType: 'short',\n        type: 'days'\n      }), this.intl.firstDay());\n      return this.weekNumber ? [''].concat(weekNames) : weekNames;\n    }\n\n    intlChange() {\n      this.weekNames = this.getWeekNames();\n\n      if (this.isMonthView()) {\n        this.cdr.markForCheck();\n      }\n    }\n\n  }\n\n  ViewListComponent.ɵfac = function ViewListComponent_Factory(t) {\n    return new (t || ViewListComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(CalendarDOMService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ViewListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ViewListComponent,\n    selectors: [[\"kendo-calendar-viewlist\"]],\n    viewQuery: function ViewListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(VirtualizationComponent, 5);\n        i0.ɵɵviewQuery(_c14, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);\n      }\n    },\n    hostVars: 12,\n    hostBindings: function ViewListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-vstack\", ctx.getComponentClass)(\"k-calendar-view\", ctx.getComponentClass)(\"k-calendar-monthview\", ctx.getComponentMonthClass)(\"k-calendar-yearview\", ctx.getComponentYearClass)(\"k-calendar-decadeview\", ctx.getComponentDecadeClass)(\"k-calendar-centuryview\", ctx.getComponentCenturyClass);\n      }\n    },\n    inputs: {\n      cellTemplateRef: \"cellTemplateRef\",\n      weekNumberTemplateRef: \"weekNumberTemplateRef\",\n      headerTitleTemplateRef: \"headerTitleTemplateRef\",\n      activeView: \"activeView\",\n      cellUID: \"cellUID\",\n      focusedDate: \"focusedDate\",\n      isActive: \"isActive\",\n      min: \"min\",\n      max: \"max\",\n      selectedDates: \"selectedDates\",\n      weekNumber: \"weekNumber\"\n    },\n    outputs: {\n      cellClick: \"cellClick\",\n      weekNumberCellClick: \"weekNumberCellClick\",\n      activeDateChange: \"activeDateChange\",\n      todayButtonClick: \"todayButtonClick\",\n      pageChange: \"pageChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 17,\n    consts: [[3, \"currentDate\", \"min\", \"max\", \"activeView\", \"templateRef\", \"todayButtonClick\"], [\"class\", \"k-calendar-weekdays k-calendar-table\", \"style\", \"table-layout: auto;\", 4, \"ngIf\"], [3, \"tabindex\", \"skip\", \"take\", \"total\", \"itemHeight\", \"topOffset\", \"bottomOffset\", \"scrollOffsetSize\", \"maxScrollDifference\", \"pageChange\", \"scrollChange\", \"activeIndexChange\"], [\"role\", \"grid\", 1, \"k-calendar-table\"], [\"list\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"k-calendar-tbody\", \"kendoCalendarView\", \"\", \"role\", \"rowgroup\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\", 4, \"kFor\", \"kForOf\"], [1, \"k-calendar-weekdays\", \"k-calendar-table\", 2, \"table-layout\", \"auto\"], [1, \"k-calendar-thead\"], [1, \"k-calendar-tr\"], [\"class\", \"k-calendar-th\", 3, \"width\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-calendar-th\"], [\"kendoCalendarView\", \"\", \"role\", \"rowgroup\", 1, \"k-calendar-tbody\", 3, \"activeView\", \"isActive\", \"min\", \"max\", \"cellUID\", \"focusedDate\", \"selectedDates\", \"weekNumber\", \"templateRef\", \"weekNumberTemplateRef\", \"viewDate\", \"cellClick\", \"weekNumberCellClick\"]],\n    template: function ViewListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-calendar-header\", 0);\n        i0.ɵɵlistener(\"todayButtonClick\", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {\n          return ctx.todayButtonClick.emit($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(1, ViewListComponent_table_1_Template, 4, 1, \"table\", 1);\n        i0.ɵɵelementStart(2, \"kendo-virtualization\", 2);\n        i0.ɵɵlistener(\"pageChange\", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) {\n          return ctx.onPageChange($event);\n        })(\"scrollChange\", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) {\n          return ctx.scrollChange($event);\n        })(\"activeIndexChange\", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) {\n          return ctx.setActiveDate($event);\n        });\n        i0.ɵɵelementStart(3, \"table\", 3, 4)(5, \"colgroup\");\n        i0.ɵɵtemplate(6, ViewListComponent_col_6_Template, 1, 0, \"col\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, ViewListComponent_tbody_7_Template, 1, 11, \"tbody\", 6);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"currentDate\", ctx.activeDate)(\"min\", ctx.min)(\"max\", ctx.max)(\"activeView\", ctx.activeView)(\"templateRef\", ctx.headerTitleTemplateRef);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isMonthView());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"tabindex\", -1)(\"skip\", ctx.skip)(\"take\", ctx.take)(\"total\", ctx.total)(\"itemHeight\", ctx.viewHeight)(\"topOffset\", ctx.viewOffset)(\"bottomOffset\", ctx.bottomOffset)(\"scrollOffsetSize\", ctx.viewOffset)(\"maxScrollDifference\", ctx.viewHeight);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngForOf\", ctx.cols);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"kForOf\", ctx.dates);\n      }\n    },\n    directives: [HeaderComponent, VirtualizationComponent, ViewComponent, i7.NgIf, i7.NgForOf, KForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ViewListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst divideByMagnitude = magnitude => x => Math.floor(x / magnitude);\n\nconst powerByMagnitude = magnitude => x => x * magnitude;\n/**\n * @hidden\n */\n\n\nlet ScrollSyncService = /*#__PURE__*/(() => {\n  class ScrollSyncService {\n    constructor(dom, zone) {\n      this.dom = dom;\n      this.zone = zone;\n    }\n\n    configure(activeView) {\n      const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);\n      this.divideByMagnitude = divideByMagnitude(magnitude);\n      this.powerByMagnitude = powerByMagnitude(magnitude);\n    }\n\n    sync(navigator, view) {\n      this.unsubscribe();\n\n      if (!navigator || !view) {\n        return;\n      }\n\n      this.navigator = navigator;\n      this.view = view;\n      this.zone.runOutsideAngular(() => {\n        let navScrolled, monthScrolled;\n        this.navSubscription = navigator.scroll$().subscribe(e => {\n          if (monthScrolled) {\n            monthScrolled = false;\n            return;\n          }\n\n          navScrolled = true;\n          this.scrollSiblingOf(e.target);\n        });\n        this.viewSubscription = view.scroll$().subscribe(e => {\n          if (navScrolled) {\n            navScrolled = false;\n            return;\n          }\n\n          monthScrolled = true;\n          this.scrollSiblingOf(e.target);\n        });\n      });\n    }\n\n    scrollSiblingOf(scrolledElement) {\n      const component = this.siblingComponent(scrolledElement);\n      const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);\n      component.scrollTo(scrollTop);\n    }\n\n    siblingComponent(scrollableElement) {\n      return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;\n    }\n\n    calculateScroll(component, scrollTop) {\n      const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;\n      return modifier(scrollTop);\n    }\n\n    destroy() {\n      this.unsubscribe();\n    }\n\n    unsubscribe() {\n      if (this.navSubscription) {\n        this.navSubscription.unsubscribe();\n      }\n\n      if (this.viewSubscription) {\n        this.viewSubscription.unsubscribe();\n      }\n    }\n\n  }\n\n  ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) {\n    return new (t || ScrollSyncService)(i0.ɵɵinject(CalendarDOMService), i0.ɵɵinject(i0.NgZone));\n  };\n\n  ScrollSyncService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollSyncService,\n    factory: ScrollSyncService.ɵfac\n  });\n  return ScrollSyncService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Used for rendering the navigation item of the Calendar. To define the navigation item template, nest an `<ng-template>`\n * tag with the `kendoCalendarNavigationItemTemplate` directive inside the component tag. The template context is set to the\n * current component. To get a reference to the current item value, use the `let-title` directive. To provide more details\n * about the current title, get a reference to the current `date` by using the `let-date='date'` directive or get a reference\n * to the current active view by using the `let-activeView='activeView'` directive.\n *\n * For more examples, refer to the article on [templates]({% slug templates_calendar %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * styles: ['.custom { color: red; }'],\n * template: `\n *  <kendo-calendar>\n *    <ng-template kendoCalendarNavigationItemTemplate let-title>\n *      <span class=\"custom\">{{title}}</span>\n *    </ng-template>\n *  </kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\n\nlet NavigationItemTemplateDirective = /*#__PURE__*/(() => {\n  class NavigationItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  NavigationItemTemplateDirective.ɵfac = function NavigationItemTemplateDirective_Factory(t) {\n    return new (t || NavigationItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  NavigationItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NavigationItemTemplateDirective,\n    selectors: [[\"\", \"kendoCalendarNavigationItemTemplate\", \"\"]]\n  });\n  return NavigationItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PickerService {\n  constructor() {\n    this.onFocus = new EventEmitter();\n    this.onBlur = new EventEmitter();\n    this.sameDateSelected = new EventEmitter();\n    this.dateCompletenessChange = new EventEmitter();\n  }\n\n}\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet MultiViewCalendarCustomMessagesComponent = /*#__PURE__*/(() => {\n  class MultiViewCalendarCustomMessagesComponent extends Messages$1 {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  MultiViewCalendarCustomMessagesComponent.ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(t) {\n    return new (t || MultiViewCalendarCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  MultiViewCalendarCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MultiViewCalendarCustomMessagesComponent,\n    selectors: [[\"kendo-multiviewcalendar-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages$1,\n      useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MultiViewCalendarCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet CalendarMessages = /*#__PURE__*/(() => {\n  class CalendarMessages extends ComponentMessages {}\n\n  CalendarMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵCalendarMessages_BaseFactory;\n    return function CalendarMessages_Factory(t) {\n      return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = i0.ɵɵgetInheritedFactory(CalendarMessages)))(t || CalendarMessages);\n    };\n  }();\n\n  CalendarMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CalendarMessages,\n    selectors: [[\"kendo-calendar-messages-base\"]],\n    inputs: {\n      today: \"today\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return CalendarMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet CalendarLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class CalendarLocalizedMessagesDirective extends CalendarMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  CalendarLocalizedMessagesDirective.ɵfac = function CalendarLocalizedMessagesDirective_Factory(t) {\n    return new (t || CalendarLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  CalendarLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CalendarLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoCalendarLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CalendarMessages,\n      useExisting: forwardRef(() => CalendarLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return CalendarLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst BOTTOM_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview';\nconst TOP_VIEW_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview';\nconst MIN_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min';\nconst MAX_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max';\nconst VALUE_DOC_LINK$4 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json';\n\nconst virtualizationProp = x => x ? x.virtualization : null;\n/**\n * @hidden\n */\n\n\nconst CALENDAR_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CalendarComponent)\n};\n/**\n * @hidden\n */\n\nconst CALENDAR_RANGE_VALIDATORS = {\n  multi: true,\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => CalendarComponent)\n};\n/**\n * @hidden\n */\n\nconst KENDO_INPUT_PROVIDER = {\n  provide: KendoInput,\n  useExisting: forwardRef(() => CalendarComponent)\n};\n/**\n * Represents the [Kendo UI Calendar component for Angular]({% slug overview_calendar %}#toc-basic-usage).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-calendar></kendo-calendar>\n * `\n * })\n * export class AppComponent { }\n * ```\n */\n\nlet CalendarComponent = /*#__PURE__*/(() => {\n  class CalendarComponent {\n    constructor(bus, dom, element, navigator, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {\n      this.bus = bus;\n      this.dom = dom;\n      this.element = element;\n      this.navigator = navigator;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.scrollSyncService = scrollSyncService;\n      this.disabledDatesService = disabledDatesService;\n      this.localization = localization;\n      this.selectionService = selectionService;\n      this.pickerService = pickerService;\n      /**\n       * @hidden\n       */\n\n      this.id = guid();\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form.\n       */\n\n      this.rangeValidation = false;\n      /**\n       * Sets the Calendar selection mode\n       * ([see example]({% slug multiple_selection_calendar %})).\n       *\n       * The available values are:\n       * * `single` (default)\n       * * `multiple`\n       */\n\n      this.selection = 'single';\n      /**\n       * Sets or gets the `disabled` property of the Calendar and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_calendar %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets or gets the `tabindex` property of the Calendar. Based on the\n       * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,\n       * it determines whether the component is focusable.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Sets or gets the `navigation` property of the Calendar\n       * and determines whether the navigation side-bar will be displayed\n       * ([see example]({% slug sidebar_calendar %})).\n       * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       */\n\n      this.navigation = true;\n      /**\n       * Defines the active view that the Calendar initially renders\n       * ([see example]({% slug activeview_calendar %})).\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the bottommost view to which the user can navigate\n       * ([see example]({% slug dates_calendar %}#toc-partial-dates)).\n       */\n\n      this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the topmost view to which the user can navigate\n       * ([see example]({% slug sidebar_calendar %}#toc-partial-dates)).\n       */\n\n      this.topView = CalendarViewEnum[CalendarViewEnum.century];\n      /**\n       * Determines whether to enable animation when navigating to previous/next view.\n       * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateNavigation = false;\n      /**\n       * Determines whether to display a week number column in the `month` view\n       * ([see example]({% slug weeknumcolumn_calendar %})).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Fires when the active view is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       */\n\n      this.activeViewChange = new EventEmitter();\n      /**\n       * Fires when navigating in the currently active view\n       * ([more information and example]({% slug events_calendar %})).\n       */\n\n      this.navigate = new EventEmitter();\n      /**\n       * Fires when the active view date is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.\n       */\n\n      this.activeViewDateChange = new EventEmitter();\n      /**\n       * Fires when the value is changed\n       * ([more information and example]({% slug overview_calendar %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      this.isActive = false;\n      this.cellUID = guid();\n      this.selectedDates = [];\n      this._min = new Date(MIN_DATE);\n      this._max = new Date(MAX_DATE);\n      this._focusedDate = getToday();\n      this.onControlChange = noop$2;\n      this.onControlTouched = noop$2;\n      this.onValidatorChange = noop$2;\n      this.minValidateFn = noop$2;\n      this.maxValidateFn = noop$2;\n      this.syncNavigation = true;\n      this._type = 'infinite';\n      this.domEvents = [];\n      this.resolvedPromise = Promise.resolve(null);\n      this.destroyed = false;\n      validatePackage(packageMetadata);\n      this.setClasses(element.nativeElement);\n\n      if (this.pickerService) {\n        this.pickerService.calendar = this;\n      }\n    }\n    /**\n     * Sets or gets the `focusedDate` property of the Calendar and\n     * defines the focused date of the component\n     * ([see example]({% slug dates_calendar %}#toc-focused-dates)).\n     *\n     * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.\n     */\n\n\n    set focusedDate(focusedDate) {\n      if (this.activeViewDate && !isEqual(this._focusedDate, focusedDate)) {\n        const service = this.bus.service(this.activeViewEnum);\n        const lastDayInPeriod = service.lastDayOfPeriod(this.activeViewDate);\n        const isFocusedDateInRange = service.isInRange(focusedDate, this.activeViewDate, lastDayInPeriod);\n\n        if (!isFocusedDateInRange) {\n          this.emitNavigate(focusedDate);\n        }\n      }\n\n      this._focusedDate = focusedDate || getToday();\n      this.setAriaActivedescendant();\n    }\n\n    get focusedDate() {\n      return this._focusedDate;\n    }\n    /**\n     * Sets or gets the `min` property of the Calendar and\n     * defines the minimum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `min` value is `1900-1-1`.\n     */\n\n\n    set min(min) {\n      this._min = min || new Date(MIN_DATE);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Sets or gets the `max` property of the Calendar and\n     * defines the maximum allowed date value\n     * ([see example]({% slug dateranges_calendar %})).\n     * By default, the `max` value is `2099-12-31`.\n     */\n\n\n    set max(max) {\n      this._max = max || new Date(MAX_DATE);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Sets or gets the `value` property of the Calendar and defines the selected value of the component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)\n     * instance when in `single` selection mode or an array of valid JavaScript Date instances when in `multiple` selection mode.\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(candidate) {\n      this.verifyValue(candidate);\n      this._value = Array.isArray(candidate) ? candidate.filter(date => isPresent(date)).map(element => cloneDate(element)) : cloneDate(candidate);\n      const selection = [].concat(candidate).filter(date => isPresent(date)).map(date => cloneDate(date));\n\n      if (!areDatesEqual(selection, this.selectedDates)) {\n        const lastSelected = last(selection);\n        this.rangePivot = cloneDate(lastSelected);\n        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;\n        this.selectedDates = selection;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the dates of the Calendar that will be disabled\n     * ([see example]({% slug disabled_dates_calendar %})).\n     */\n\n\n    set disabledDates(value) {\n      this.disabledDatesService.initialize(value);\n      this._disabledDates = value;\n    }\n\n    get disabledDates() {\n      return this._disabledDates;\n    }\n    /**\n     * Specifies the Calendar type.\n     *\n     * The possible values are:\n     * - `infinite` (default)\n     * - `classic`\n     *\n     */\n\n\n    set type(type) {\n      this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);\n      this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);\n      this._type = type;\n    }\n\n    get type() {\n      return this._type;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set cellTemplateRef(template) {\n      this._cellTemplateRef = template;\n    }\n\n    get cellTemplateRef() {\n      return this._cellTemplateRef || this.cellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each month cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set monthCellTemplateRef(template) {\n      this._monthCellTemplateRef = template;\n    }\n\n    get monthCellTemplateRef() {\n      return this._monthCellTemplateRef || this.monthCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each year cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set yearCellTemplateRef(template) {\n      this._yearCellTemplateRef = template;\n    }\n\n    get yearCellTemplateRef() {\n      return this._yearCellTemplateRef || this.yearCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each decade cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set decadeCellTemplateRef(template) {\n      this._decadeCellTemplateRef = template;\n    }\n\n    get decadeCellTemplateRef() {\n      return this._decadeCellTemplateRef || this.decadeCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each century cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set centuryCellTemplateRef(template) {\n      this._centuryCellTemplateRef = template;\n    }\n\n    get centuryCellTemplateRef() {\n      return this._centuryCellTemplateRef || this.centuryCellTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for the week cell.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set weekNumberTemplateRef(template) {\n      this._weekNumberTemplateRef = template;\n    }\n\n    get weekNumberTemplateRef() {\n      return this._weekNumberTemplateRef || this.weekNumberTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for the header title.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set headerTitleTemplateRef(template) {\n      this._headerTitleTemplateRef = template;\n    }\n\n    get headerTitleTemplateRef() {\n      return this._headerTitleTemplateRef || this.headerTitleTemplate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for the navigation item.\n     * Takes precedence over nested templates in the KendoCalendar tag.\n     */\n\n\n    set navigationItemTemplateRef(template) {\n      this._navigationItemTemplateRef = template;\n    }\n\n    get navigationItemTemplateRef() {\n      return this._navigationItemTemplateRef || this.navigationItemTemplate;\n    }\n\n    get activeViewEnum() {\n      const activeView = CalendarViewEnum[this.activeView];\n      return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;\n    }\n\n    get bottomViewEnum() {\n      return CalendarViewEnum[this.bottomView];\n    }\n\n    get topViewEnum() {\n      return CalendarViewEnum[this.topView];\n    }\n\n    get widgetId() {\n      return this.id;\n    }\n\n    get calendarTabIndex() {\n      // in Classic mode, the inner MultiViewCalendar is the focusable element\n      return this.disabled || this.type === 'classic' ? undefined : this.tabIndex;\n    }\n\n    get ariaDisabled() {\n      // in Classic mode, the inner MultiViewCalendar should handle the disabled class and aria attr\n      return this.type === 'classic' ? undefined : this.disabled;\n    }\n\n    ngOnInit() {\n      this.dom.calculateHeights(this.element.nativeElement);\n      this.scrollSyncService.configure(this.activeViewEnum);\n      this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n      this.viewChangeSubscription = this.bus.viewChanged.subscribe(({\n        view\n      }) => this.handleActiveViewChange(CalendarViewEnum[view]));\n      this.control = this.injector.get(NgControl, null);\n\n      if (this.element) {\n        this.ngZone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnChanges(changes) {\n      this.verifyChanges();\n      this.bus.configure(this.bottomViewEnum, this.topViewEnum);\n      this.scrollSyncService.configure(this.activeViewEnum);\n\n      if (hasExistingValue(changes, 'focusedDate')) {\n        const focusedDate = changes.focusedDate.currentValue;\n        this.focusedDate = dateInRange(focusedDate, this.min, this.max);\n      }\n\n      if (changes.navigation) {\n        this.syncNavigation = true;\n      }\n\n      if (changes.min || changes.max || changes.rangeValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;\n        this.onValidatorChange();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setAriaActivedescendant();\n    }\n\n    ngAfterViewChecked() {\n      if (!this.syncNavigation) {\n        return;\n      }\n\n      this.syncNavigation = false;\n      this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));\n    }\n\n    ngOnDestroy() {\n      this.scrollSyncService.destroy();\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n\n      if (this.pickerService) {\n        this.pickerService.calendar = null;\n      }\n\n      if (this.viewChangeSubscription) {\n        this.viewChangeSubscription.unsubscribe();\n      }\n\n      if (this.pageChangeSubscription) {\n        this.pageChangeSubscription.unsubscribe();\n      }\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      this.destroyed = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      this.focusedDate = new Date(this.focusedDate);\n      this.cdr.detectChanges();\n    }\n    /**\n     * Focuses the host element of the Calendar.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"calendar.focus()\">Focus calendar</button>\n     *  <kendo-calendar #calendar></kendo-calendar>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      const focusTarget = this.type === 'infinite' ? this.element && this.element.nativeElement : this.multiViewCalendar;\n\n      if (isPresent(focusTarget)) {\n        focusTarget.focus();\n      }\n    }\n    /**\n     * Blurs the Calendar component.\n     */\n\n\n    blur() {\n      const blurTarget = this.type === 'infinite' ? this.element && this.element.nativeElement : this.multiViewCalendar;\n\n      if (isPresent(blurTarget)) {\n        blurTarget.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    containsElement(element) {\n      return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigation(candidate) {\n      if (this.disabled) {\n        return;\n      }\n\n      const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;\n      this.focusedDate = dateInRange(focusTarget, this.min, this.max);\n      this.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPageChange() {\n      if (!NgZone.isInAngularZone()) {\n        if (this.pageChangeSubscription) {\n          this.pageChangeSubscription.unsubscribe();\n        }\n\n        this.pageChangeSubscription = from(this.resolvedPromise).subscribe(() => {\n          this.detectChanges(); // requires zone if templates\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMultiViewCalendarValueChange(date, focusedDate) {\n      const selectedDates = Array.isArray(date) ? date : [date];\n      this.handleDateChange({\n        selectedDates,\n        focusedDate\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDateChange(args) {\n      const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];\n      const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);\n      const availableDates = selectedDates.filter(date => !this.disabledDatesService.isDateDisabled(date));\n      this.focusedDate = args.focusedDate || this.focusedDate;\n\n      if (this.disabled) {\n        return;\n      }\n\n      if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {\n        this.emitSameDate();\n        return;\n      }\n\n      if (canNavigateDown) {\n        this.bus.moveDown(this.activeViewEnum);\n        return;\n      }\n\n      if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.selectedDates = availableDates.map(date => cloneDate(date));\n        this.value = this.parseSelectionToValue(availableDates);\n        this.onControlChange(this.parseSelectionToValue(availableDates));\n        this.valueChange.emit(this.parseSelectionToValue(availableDates));\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(candidate) {\n      this.verifyValue(candidate);\n      this.value = candidate;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeCellTemplate() {\n      switch (this.activeViewEnum) {\n        case CalendarViewEnum.month:\n          return this.monthCellTemplateRef || this.cellTemplateRef;\n\n        case CalendarViewEnum.year:\n          return this.yearCellTemplateRef;\n\n        case CalendarViewEnum.decade:\n          return this.decadeCellTemplateRef;\n\n        case CalendarViewEnum.century:\n          return this.centuryCellTemplateRef;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigate(event) {\n      this.focusedDate = event.focusedDate;\n      this.activeView = event.activeView;\n      this.emitNavigate(this.focusedDate);\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitNavigate(focusedDate) {\n      const activeView = CalendarViewEnum[this.activeViewEnum];\n      this.navigate.emit({\n        activeView,\n        focusedDate\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    emitEvent(emitter, args) {\n      if (hasObservers(emitter)) {\n        this.ngZone.run(() => {\n          emitter.emit(args);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleActiveDateChange(date) {\n      this.activeViewDate = date;\n      this.emitEvent(this.activeViewDateChange, date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleActiveViewChange(view) {\n      this.activeView = view;\n      this.emitEvent(this.activeViewChange, view);\n\n      if (this.type === 'infinite') {\n        this.scrollSyncService.configure(this.activeViewEnum);\n      }\n\n      this.detectChanges(); // requires zone if templates\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCellClick({\n      date,\n      modifiers\n    }) {\n      this.performSelection(date, modifiers);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleWeekNumberClick(dates) {\n      if (this.selection === 'single') {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        this.handleDateChange({\n          selectedDates: dates,\n          focusedDate: last(dates)\n        });\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(args) {\n      if (this.element.nativeElement.contains(args.relatedTarget)) {\n        return;\n      }\n\n      this.isActive = false; // the injector can get the NgControl instance of the parent component (for example, the DateTimePicker)\n      // and enters the zone for no reason because the parent component is still untouched\n\n      if (!this.pickerService && requiresZoneOnBlur(this.control)) {\n        this.ngZone.run(() => {\n          this.onControlTouched();\n          this.emitBlur(args);\n          this.cdr.markForCheck();\n        });\n      } else {\n        this.emitBlur(args);\n        this.detectChanges();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      this.isActive = true;\n\n      if (!NgZone.isInAngularZone()) {\n        this.detectChanges();\n      }\n\n      this.emitFocus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMultiViewCalendarKeydown(args) {\n      // Prevent form from submitting on enter if used in datepicker (classic view)\n      if (isPresent(this.pickerService) && args.keyCode === Keys.Enter) {\n        args.preventDefault();\n      }\n    }\n\n    setClasses(element) {\n      this.renderer.addClass(element, 'k-widget');\n      this.renderer.addClass(element, 'k-calendar');\n      this.renderer.addClass(element, `k-calendar-${this.type}`);\n    }\n\n    verifyChanges() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.min > this.max) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);\n      }\n\n      if (this.bottomViewEnum > this.topViewEnum) {\n        throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);\n      }\n    }\n\n    verifyValue(candidate) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.selection === 'single' && candidate && !(candidate instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);\n      } else if (this.selection === 'multiple' && candidate && Array.isArray(candidate)) {\n        const onlyDates = candidate.every(value => value instanceof Date);\n\n        if (!onlyDates) {\n          throw new Error(`The 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);\n        }\n      }\n    }\n\n    bindEvents() {\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'blur', this.handleBlur.bind(this)), this.renderer.listen(element, 'focus', this.handleFocus.bind(this)), this.renderer.listen(element, 'mousedown', preventDefault), this.renderer.listen(element, 'click', this.handleComponentClick.bind(this)), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n    }\n\n    emitBlur(args) {\n      if (this.pickerService) {\n        this.pickerService.onBlur.emit(args);\n      }\n    }\n\n    emitFocus() {\n      if (this.pickerService) {\n        this.pickerService.onFocus.emit();\n      }\n    }\n\n    handleComponentClick() {\n      if (!this.isActive) {\n        if (this.type === 'infinite' && this.monthView.isScrolled()) {\n          this.focusedDate = cloneDate(this.focusedDate); //XXX: forces change detect\n\n          this.detectChanges();\n        }\n\n        this.focus();\n      }\n    }\n\n    handleKeydown(args) {\n      const headerActive = this.type === 'classic' && this.multiViewCalendar.isHeaderActive;\n\n      if (headerActive) {\n        return;\n      } // reserve the alt + arrow key commands for the picker\n\n\n      const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;\n\n      if (isPresent(this.pickerService) && arrowKeyPressed && args.altKey) {\n        return;\n      } // Prevent form from submitting on enter if used in datepicker (infinite view)\n\n\n      if (isPresent(this.pickerService) && args.keyCode === Keys.Enter) {\n        args.preventDefault();\n      }\n\n      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);\n\n      if (!isEqual(this.focusedDate, candidate)) {\n        this.focusedDate = candidate;\n        this.detectChanges();\n        args.preventDefault();\n      }\n\n      if (args.keyCode === Keys.Enter) {\n        this.performSelection(this.focusedDate, args);\n      }\n    }\n\n    detectChanges() {\n      if (!this.destroyed) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    emitSameDate() {\n      if (this.pickerService) {\n        this.pickerService.sameDateSelected.emit();\n      }\n    }\n\n    setAriaActivedescendant() {\n      // in Classic mode, the inner MultiViewCalendar handles the activedescendant\n      if (!isPresent(this.element) || this.type === 'classic' && !this.element.nativeElement.hasAttribute('aria-activedescendant')) {\n        return;\n      }\n\n      if (this.type === 'classic') {\n        this.renderer.removeAttribute(this.element.nativeElement, 'aria-activedescendant');\n        return;\n      }\n\n      const focusedCellId = this.cellUID + this.focusedDate.getTime();\n      this.renderer.setAttribute(this.element.nativeElement, 'aria-activedescendant', focusedCellId);\n    }\n\n    parseSelectionToValue(selection) {\n      selection = selection || [];\n      return this.selection === 'single' ? cloneDate(last(selection)) : selection.map(date => cloneDate(date));\n    }\n\n    performSelection(date, selectionModifiers) {\n      const selection = this.selectionService.performSelection({\n        date: date,\n        modifiers: selectionModifiers,\n        selectionMode: this.selection,\n        activeViewEnum: this.activeViewEnum,\n        rangePivot: this.rangePivot,\n        selectedDates: this.selectedDates\n      });\n      this.rangePivot = selection.rangePivot;\n      this.handleDateChange({\n        selectedDates: selection.selectedDates,\n        focusedDate: date\n      });\n    }\n\n  }\n\n  CalendarComponent.ɵfac = function CalendarComponent_Factory(t) {\n    return new (t || CalendarComponent)(i0.ɵɵdirectiveInject(BusViewService), i0.ɵɵdirectiveInject(CalendarDOMService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(ScrollSyncService), i0.ɵɵdirectiveInject(DisabledDatesService), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(PickerService, 8));\n  };\n\n  CalendarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CalendarComponent,\n    selectors: [[\"kendo-calendar\"]],\n    contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);\n      }\n    },\n    viewQuery: function CalendarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NavigationComponent, 5);\n        i0.ɵɵviewQuery(ViewListComponent, 5);\n        i0.ɵɵviewQuery(MultiViewCalendarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.navigationView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.multiViewCalendar = _t.first);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function CalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.widgetId)(\"tabindex\", ctx.calendarTabIndex)(\"aria-disabled\", ctx.ariaDisabled);\n        i0.ɵɵclassProp(\"k-week-number\", ctx.weekNumber)(\"k-disabled\", ctx.ariaDisabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      focusedDate: \"focusedDate\",\n      min: \"min\",\n      max: \"max\",\n      rangeValidation: \"rangeValidation\",\n      selection: \"selection\",\n      value: \"value\",\n      disabled: \"disabled\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      disabledDates: \"disabledDates\",\n      navigation: \"navigation\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      type: \"type\",\n      animateNavigation: \"animateNavigation\",\n      weekNumber: \"weekNumber\",\n      cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n      monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n      yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n      decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n      centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n      weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n      headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"],\n      navigationItemTemplateRef: [\"navigationItemTemplate\", \"navigationItemTemplateRef\"]\n    },\n    outputs: {\n      activeViewChange: \"activeViewChange\",\n      navigate: \"navigate\",\n      activeViewDateChange: \"activeViewDateChange\",\n      valueChange: \"valueChange\"\n    },\n    exportAs: [\"kendo-calendar\"],\n    features: [i0.ɵɵProvidersFeature([BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.calendar'\n    }, NavigationService, ScrollSyncService, SelectionService]), i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 2,\n    consts: function () {\n      let i18n_15;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.calendar.today\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_16 = goog.getMsg(\"Today\");\n        i18n_15 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_16;\n      } else {\n        i18n_15 = $localize`:kendo.calendar.today|The label for the today button in the calendar header:Today`;\n      }\n\n      let i18n_17;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the previous button in the Classic calendar\n         * @meaning kendo.calendar.prevButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_18 = goog.getMsg(\"Navigate to previous view\");\n        i18n_17 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_18;\n      } else {\n        i18n_17 = $localize`:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;\n      }\n\n      let i18n_19;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the next button in the Classic calendar\n         * @meaning kendo.calendar.nextButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_20 = goog.getMsg(\"Navigate to next view\");\n        i18n_19 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_20;\n      } else {\n        i18n_19 = $localize`:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;\n      }\n\n      return [[\"kendoCalendarLocalizedMessages\", \"\", \"today\", i18n_15, \"prevButtonTitle\", i18n_17, \"nextButtonTitle\", i18n_19], [4, \"ngIf\"], [3, \"activeView\", \"focusedDate\", \"min\", \"max\", \"templateRef\", \"valueChange\", \"pageChange\", 4, \"ngIf\"], [3, \"activeView\", \"isActive\", \"cellTemplateRef\", \"headerTitleTemplateRef\", \"weekNumberTemplateRef\", \"cellUID\", \"min\", \"max\", \"focusedDate\", \"weekNumber\", \"selectedDates\", \"todayButtonClick\", \"cellClick\", \"weekNumberCellClick\", \"activeDateChange\", \"pageChange\"], [3, \"resize\"], [3, \"activeView\", \"focusedDate\", \"min\", \"max\", \"templateRef\", \"valueChange\", \"pageChange\"], [3, \"views\", \"min\", \"max\", \"isActive\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"animateNavigation\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"headerTitleTemplate\", \"weekNumberTemplate\", \"focusedDate\", \"selection\", \"value\", \"disabledDates\", \"activeViewChange\", \"navigate\", \"valueChange\", \"focus\", \"blur\", \"keydown\"], [\"multiviewcalendar\", \"\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"]];\n    },\n    template: function CalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, CalendarComponent_ng_container_1_Template, 4, 12, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, CalendarComponent_ng_container_2_Template, 4, 23, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.type === \"infinite\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.type === \"classic\");\n      }\n    },\n    directives: [NavigationComponent, ViewListComponent, i5.ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, i7.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return CalendarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst incompleteDateValidator = () => {\n  return (control, incomplete) => {\n    if (!isPresent(control.value) && incomplete) {\n      return {\n        incompleteDate: true\n      };\n    } else {\n      return null;\n    }\n  };\n};\n/**\n * @hidden\n */\n\n\nvar Arrow = /*#__PURE__*/(() => {\n  (function (Arrow) {\n    Arrow[Arrow[\"Up\"] = 0] = \"Up\";\n    Arrow[Arrow[\"Down\"] = 1] = \"Down\";\n    Arrow[Arrow[\"None\"] = 2] = \"None\";\n  })(Arrow || (Arrow = {}));\n\n  return Arrow;\n})();\n\n/**\n * @hidden\n */\nlet DateInputMessages = /*#__PURE__*/(() => {\n  class DateInputMessages extends ComponentMessages {}\n\n  DateInputMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵDateInputMessages_BaseFactory;\n    return function DateInputMessages_Factory(t) {\n      return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = i0.ɵɵgetInheritedFactory(DateInputMessages)))(t || DateInputMessages);\n    };\n  }();\n\n  DateInputMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateInputMessages,\n    selectors: [[\"kendo-dateinput-messages-base\"]],\n    inputs: {\n      decrement: \"decrement\",\n      increment: \"increment\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DateInputMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DateInputLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class DateInputLocalizedMessagesDirective extends DateInputMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  DateInputLocalizedMessagesDirective.ɵfac = function DateInputLocalizedMessagesDirective_Factory(t) {\n    return new (t || DateInputLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  DateInputLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateInputLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoDateInputLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DateInputMessages,\n      useExisting: forwardRef(() => DateInputLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DateInputLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MIN_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';\nconst MAX_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';\nconst VALUE_DOC_LINK$3 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';\nconst DATE_PART_REGEXP = /year|month|<day>/;\nconst TIME_PART_REGEXP = /hour|minute|second|millisecond/;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst TWO_DIGIT_YEAR_MAX$2 = 68;\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst DEFAULT_FORMAT$1 = 'd';\n\nconst padZero = length => new Array(Math.max(length, 0)).fill('0').join('');\n\nconst unpadZero = value => value.replace(/^0*/, '');\n\nclass Mask {\n  constructor() {\n    this.symbols = \"\";\n  }\n\n}\n\nclass KendoDate {\n  constructor(intl, formatPlaceholder, format, value, twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2) {\n    this.intl = intl;\n    this.formatPlaceholder = formatPlaceholder;\n    this.format = format;\n    this.twoDigitYearMax = twoDigitYearMax;\n    this.year = true;\n    this.month = true;\n    this.date = true;\n    this.hours = true;\n    this.minutes = true;\n    this.seconds = true;\n    this.milliseconds = true;\n    this.leadingZero = null;\n    this.monthNames = null;\n    this.typedMonthPart = \"\";\n    this.value = getDate(new Date());\n    this.knownParts = \"adHhmMsSEy\";\n    this.symbols = {\n      \"E\": \"E\",\n      \"H\": \"H\",\n      \"M\": \"M\",\n      \"a\": \"a\",\n      \"d\": \"d\",\n      \"h\": \"h\",\n      \"m\": \"m\",\n      \"s\": \"s\",\n      \"S\": \"S\",\n      \"y\": \"y\"\n    };\n    validatePackage(packageMetadata);\n    this.monthNames = this.allFormatedMonths();\n    this.dayPeriods = this.allDayPeriods();\n\n    if (!value) {\n      this.value = getDate(new Date());\n      const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n\n      for (let i = 0; i < sampleFormat.length; i++) {\n        this.setExisting(sampleFormat[i], false);\n      }\n    } else {\n      this.value = cloneDate(value);\n    }\n  }\n\n  hasValue() {\n    const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n\n    return this.intl.splitDateFormat(this.format).reduce(pred, false);\n  }\n\n  shouldNormalizeCentury() {\n    return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n  }\n\n  getDateObject() {\n    for (let i = 0; i < this.knownParts.length; i++) {\n      if (!this.getExisting(this.knownParts[i])) {\n        return null;\n      }\n    }\n\n    return cloneDate(this.value);\n  }\n\n  getTextAndFormat(format) {\n    return this.merge(this.intl.formatDate(this.value, format), this.dateFormatString(this.value, format));\n  }\n\n  getExisting(symbol) {\n    switch (symbol) {\n      case \"y\":\n        return this.year;\n\n      case \"M\":\n      case \"L\":\n        return this.month;\n\n      case \"d\":\n        return this.date;\n\n      case \"E\":\n        return this.date && this.month && this.year;\n\n      case \"h\":\n      case \"H\":\n        return this.hours;\n\n      case \"m\":\n        return this.minutes;\n\n      case \"s\":\n        return this.seconds;\n\n      case \"S\":\n        return this.milliseconds;\n\n      default:\n        return true;\n    }\n  }\n\n  setExisting(symbol, value) {\n    switch (symbol) {\n      case \"y\":\n        this.year = value;\n\n        if (value === false) {\n          this.value.setFullYear(2000);\n        }\n\n        break;\n      //allow 2/29 dates\n\n      case \"M\":\n        this.month = value;\n\n        if (value === false) {\n          this.value.setMonth(0);\n        }\n\n        break;\n      //make sure you can type 31 at day part\n\n      case \"d\":\n        this.date = value;\n        break;\n\n      case \"h\":\n      case \"H\":\n        this.hours = value;\n        break;\n\n      case \"m\":\n        this.minutes = value;\n        break;\n\n      case \"s\":\n        this.seconds = value;\n        break;\n\n      case \"S\":\n        this.milliseconds = value;\n        break;\n\n      default:\n        return;\n    }\n  }\n\n  modifyPart(symbol, offset) {\n    let newValue = cloneDate(this.value);\n\n    switch (symbol) {\n      case \"y\":\n        newValue.setFullYear(newValue.getFullYear() + offset);\n        break;\n\n      case \"M\":\n        newValue = addMonths(this.value, offset);\n        break;\n\n      case \"d\":\n      case \"E\":\n        newValue.setDate(newValue.getDate() + offset);\n        break;\n\n      case \"h\":\n      case \"H\":\n        newValue.setHours(newValue.getHours() + offset);\n        break;\n\n      case \"m\":\n        newValue.setMinutes(newValue.getMinutes() + offset);\n        break;\n\n      case \"s\":\n        newValue.setSeconds(newValue.getSeconds() + offset);\n        break;\n\n      case \"S\":\n        newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n        break;\n\n      case \"a\":\n        newValue.setHours(newValue.getHours() + 12 * offset);\n        break;\n\n      default:\n        break;\n    }\n\n    if (this.shouldNormalizeCentury()) {\n      newValue = this.normalizeCentury(newValue);\n    }\n\n    if (newValue.getFullYear() > 0) {\n      this.setExisting(symbol, true);\n      this.value = newValue;\n    }\n  }\n\n  parsePart(symbol, currentChar, resetSegmentValue) {\n    if (!currentChar) {\n      this.resetLeadingZero();\n      this.setExisting(symbol, false);\n      return {\n        value: null,\n        switchToNext: false\n      };\n    }\n\n    let baseDate = this.intl.formatDate(this.value, this.format);\n    let dateParts = this.dateFormatString(this.value, this.format);\n    let baseFormat = dateParts.symbols;\n    let replaced = false;\n    let prefix = \"\";\n    let current = \"\";\n    let suffix = \"\";\n\n    for (let i = 0; i < baseDate.length; i++) {\n      if (baseFormat[i] === symbol) {\n        current += this.getExisting(symbol) ? baseDate[i] : \"0\";\n        replaced = true;\n      } else if (!replaced) {\n        prefix += baseDate[i];\n      } else {\n        suffix += baseDate[i];\n      }\n    }\n\n    let currentMaxLength = current.length - 3;\n    let parsedDate = null;\n    const month = this.matchMonth(currentChar);\n    const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n    const isZeroCurrentChar = currentChar === '0';\n    const leadingZero = (this.leadingZero || {})[symbol] || 0;\n\n    if (isZeroCurrentChar) {\n      let valueNumber = parseInt(resetSegmentValue ? currentChar : current + currentChar, 10);\n\n      if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {\n        this.incrementLeadingZero(symbol);\n      }\n    } else {\n      this.resetLeadingZero();\n    }\n\n    for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n      let middle = resetSegmentValue ? currentChar : current.substring(i) + currentChar;\n\n      if (symbol === \"S\" && resetSegmentValue) {\n        // The \"S\" parser in intl parses \"1\" as 100ms in order to handle ISOString dates correctly, so to get 1ms, we need to pass \"001\"\n        const padding = msPaddingFromFormat(baseFormat);\n        middle = padding + middle;\n      }\n\n      let middleNumber = parseInt(middle, 10);\n      parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n\n      if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n        if (symbol === 'M' && !month) {\n          const monthNumber = middleNumber - 1;\n\n          if (monthNumber > -1 && monthNumber < 12) {\n            parsedDate = cloneDate(this.value);\n            parsedDate.setMonth(monthNumber);\n\n            if (parsedDate.getMonth() !== monthNumber) {\n              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n            }\n          }\n        }\n\n        if (symbol === 'y') {\n          parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n\n          if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n          }\n        }\n      }\n\n      if (parsedDate) {\n        //move to next segment if the part will overflow with next char\n        //when start from empty date (01, then 010), padded zeros should be trimmed\n        const patternValue = this.partPattern(dateParts.partMap, symbol).pattern;\n        const peekDate = this.intl.parseDate(`${prefix}${this.peek(middle, patternValue)}${suffix}`, this.format);\n        const patternLength = this.patternLength(patternValue) || patternValue.length;\n        const patternSatisfied = leadingZero + (unpadZero(middle) || currentChar).length >= patternLength;\n        const switchToNext = peekDate === null || patternSatisfied;\n\n        if (this.shouldNormalizeCentury()) {\n          parsedDate = this.normalizeCentury(parsedDate);\n        }\n\n        this.value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value,\n          switchToNext: switchToNext\n        };\n      }\n    }\n\n    if (month) {\n      parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n\n      if (parsedDate) {\n        this.value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value,\n          switchToNext: false\n        };\n      }\n    }\n\n    if (dayPeriod) {\n      parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);\n\n      if (parsedDate) {\n        this.value = parsedDate;\n        return {\n          value: this.value,\n          switchToNext: true\n        };\n      }\n    }\n\n    if (isZeroCurrentChar) {\n      this.setExisting(symbol, false);\n    }\n\n    return {\n      value: null,\n      switchToNext: false\n    };\n  }\n\n  resetLeadingZero() {\n    const hasLeadingZero = this.leadingZero !== null;\n    this.setLeadingZero(null);\n    return hasLeadingZero;\n  }\n\n  setLeadingZero(leadingZero) {\n    this.leadingZero = leadingZero;\n  }\n\n  normalizeCentury(date) {\n    if (!isPresent(date)) {\n      return date;\n    }\n\n    const twoDigitYear = cropTwoDigitYear(date);\n    const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n    const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n    return normalizedDate;\n  }\n\n  incrementLeadingZero(symbol) {\n    const leadingZero = this.leadingZero || {};\n    leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n    this.leadingZero = leadingZero;\n  }\n\n  isAbbrMonth(parts, symbol) {\n    const pattern = this.partPattern(parts, symbol);\n    return pattern.type === 'month' && pattern.names;\n  }\n\n  partPattern(parts, symbol) {\n    return parts.filter(part => part.pattern.indexOf(symbol) !== -1)[0];\n  }\n\n  peek(value, pattern) {\n    const peekValue = unpadZero(value) + '0';\n    return padZero(pattern.length - peekValue.length) + peekValue;\n  }\n\n  matchMonth(typedChar) {\n    this.typedMonthPart += typedChar.toLowerCase();\n\n    if (!this.monthNames) {\n      return \"\";\n    }\n\n    while (this.typedMonthPart.length > 0) {\n      for (let i = 0; i < this.monthNames.length; i++) {\n        if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n          return this.monthNames[i];\n        }\n      }\n\n      const monthAsNum = parseInt(this.typedMonthPart, 10);\n\n      if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart\n      /*ensure they exact match*/\n      ) {\n        return this.monthNames[monthAsNum - 1];\n      }\n\n      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n    }\n\n    return \"\";\n  }\n\n  matchDayPeriod(typedChar, symbol) {\n    const lowerChart = String(typedChar).toLowerCase();\n\n    if (symbol === 'a' && this.dayPeriods) {\n      if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.am;\n      } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.pm;\n      }\n    }\n\n    return '';\n  }\n\n  allFormatedMonths() {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"month\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(dateFormatParts[i].names);\n      }\n    }\n\n    return null;\n  }\n\n  allDayPeriods() {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(dateFormatParts[i].names);\n      }\n    }\n\n    return null;\n  }\n\n  patternLength(pattern) {\n    if (pattern[0] === 'y') {\n      return 4;\n    }\n\n    if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n      return 2;\n    }\n\n    return 0;\n  } //TODO: REMOVE!\n\n\n  dateFormatString(date, format) {\n    const dateFormatParts = this.intl.splitDateFormat(format);\n    const parts = [];\n    const partMap = [];\n\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      let partLength = this.intl.formatDate(date, {\n        pattern: dateFormatParts[i].pattern\n      }).length;\n\n      while (partLength > 0) {\n        parts.push(this.symbols[dateFormatParts[i].pattern[0]] || \"_\");\n        partMap.push(dateFormatParts[i]);\n        partLength--;\n      }\n    }\n\n    const returnValue = new Mask();\n    returnValue.symbols = parts.join(\"\");\n    returnValue.partMap = partMap;\n    return returnValue;\n  }\n\n  merge(text, mask) {\n    // Important: right to left.\n    let resultText = \"\";\n    let resultFormat = \"\";\n    let format = mask.symbols;\n\n    for (let r = format.length - 1; r >= 0; r--) {\n      if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n        resultText = text[r] + resultText;\n        resultFormat = format[r] + resultFormat;\n      } else {\n        const currentSymbol = format[r];\n\n        while (r >= 0 && currentSymbol === format[r]) {\n          r--;\n        }\n\n        r++;\n\n        if (this.leadingZero && this.leadingZero[currentSymbol]) {\n          resultText = '0' + resultText;\n        } else {\n          resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n        }\n\n        while (resultFormat.length < resultText.length) {\n          resultFormat = format[r] + resultFormat;\n        }\n      }\n    }\n\n    return [resultText, resultFormat];\n  }\n\n  dateFieldName(part) {\n    const formatPlaceholder = this.formatPlaceholder || 'wide';\n\n    if (formatPlaceholder[part.type]) {\n      return formatPlaceholder[part.type];\n    }\n\n    if (formatPlaceholder === 'formatPattern') {\n      return part.pattern;\n    }\n\n    return this.intl.dateFieldName(Object.assign(part, {\n      nameType: formatPlaceholder\n    }));\n  }\n\n  getNormalizedCenturyBase(twoDigitYear) {\n    return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;\n  }\n\n}\n/**\n * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).\n */\n\n\nlet DateInputComponent = /*#__PURE__*/(() => {\n  class DateInputComponent {\n    constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {\n      this.cdr = cdr;\n      this.intl = intl;\n      this.renderer = renderer;\n      this.wrapper = wrapper;\n      this.ngZone = ngZone;\n      this.injector = injector;\n      this.localization = localization;\n      this.pickerService = pickerService;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Sets or gets the `disabled` property of the DateInput and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_dateinput %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets or gets the read-only state of the DateInput\n       * ([see example]({% slug readonly_dateinput %})).\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the title of the input element of the DateInput.\n       */\n\n      this.title = \"\";\n      /**\n       * Sets or gets the `tabIndex` property of the DateInput.\n       * .\n       */\n\n      this.tabindex = 0;\n      /**\n       * @hidden\n       */\n\n      this.role = 'spinbutton';\n      /**\n       * @hidden\n       */\n\n      this.ariaReadOnly = false;\n      /**\n       * Specifies the date format that is used to display the input value\n       * ([see example]({% slug formats_dateinput %})).\n       *\n       * Format value options:\n       * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n       * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n       */\n\n      this.format = DEFAULT_FORMAT$1;\n      /**\n       * Specifies the hint the DateInput displays when its value is `null`.\n       * For more information, refer to the article on\n       * [placeholders]({% slug placeholders_dateinput %}).\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-dateinput placeholder=\"Enter birth date...\"></kendo-dateinput>\n       * `\n       * })\n       * export class AppComponent { }\n       * ```\n       */\n\n      this.placeholder = null;\n      /**\n       * Configures the incremental steps of the DateInput.\n       * For more information, refer to the article on\n       * [incremental steps]({% slug incrementalsteps_dateinput %}).\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-dateinput [steps]=\"steps\"></kendo-dateinput>\n       * `\n       * })\n       * export class AppComponent {\n       *   public steps = { year: 10, month: 1, day: 5 };\n       * }\n       * ```\n       */\n\n      this.steps = {};\n      /**\n       * Determines whether the built-in min or max validators are to be enforced when a form is being validated.\n       */\n\n      this.rangeValidation = true;\n      /**\n       * @hidden\n       * Based on the min and max values, specifies whether the value will be auto-corrected while typing.\n       */\n\n      this.autoCorrect = false;\n      /**\n       * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n       */\n\n      this.incompleteDateValidation = false;\n      /**\n       * The maximum year to assume to be from the current century when typing two-digit year value\n       * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).\n       *\n       * The default value is 68, indicating that typing any value less than 69\n       * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n       */\n\n      this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;\n      /**\n       * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n       * For more information, refer to the article on\n       * [spinner buttons]({% slug spinbuttons_dateinput %}).\n       */\n\n      this.spinners = false;\n      /**\n       * @hidden\n       */\n\n      this.isPopupOpen = false;\n      /**\n       * @hidden\n       */\n\n      this.hasPopup = false;\n      /**\n       * Fires each time the user selects a new value.\n       * For more information, refer to the section on\n       * [events]({% slug overview_dateinput %}#toc-events).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * @hidden\n       * Fires each time the user selects a new value.\n       * For more information, refer to the section on\n       * [events]({% slug overview_dateinput %}#toc-events).\n       */\n\n      this.valueUpdate = new EventEmitter();\n      /**\n       * Fires each time the user focuses the input element.\n       * For more information, refer to the section on\n       * [events]({% slug overview_dateinput %}#toc-events).\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-dateinput (focus)=\"handleFocus()\"></kendo-dateinput>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log(\"Component is focused\");\n       *   }\n       * }\n       * ```\n       *\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the input element gets blurred.\n       * For more information, refer to the section on\n       * [events]({% slug overview_dateinput %}#toc-events).\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-dateinput (blur)=\"handleBlur()\"></kendo-dateinput>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log(\"Component is blurred\");\n       *   }\n       * }\n       * ```\n       *\n       */\n\n      this.onBlur = new EventEmitter();\n      this.arrow = Arrow;\n      this.arrowDirection = Arrow.None;\n      this.formatSections = {\n        date: false,\n        time: false\n      };\n      this.hasMousedown = false;\n      this.focusedPriorToMousedown = false;\n      /**\n       * @hidden\n       */\n\n      this.isDateIncomplete = false;\n      this.currentValue = \"\";\n      this.currentFormat = \"\";\n      this.backspace = false;\n      this.resetSegmentValue = true;\n      this.minValidator = noop$2;\n      this.maxValidator = noop$2;\n      this.incompleteValidator = noop$2;\n      this._value = null;\n      this._active = false;\n      this.kendoDate = null;\n      this.paste = false;\n      this.domEvents = [];\n      this.onControlChange = noop$2;\n      this.onControlTouched = noop$2;\n      this.onValidatorChange = noop$2;\n      this._size = DEFAULT_SIZE;\n      this._rounded = DEFAULT_ROUNDED;\n      this._fillMode = DEFAULT_FILL_MODE;\n      this.symbolsMap = this.dateSymbolMap();\n      this.updateFormatSections();\n\n      if (this.pickerService) {\n        this.pickerService.input = this;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Specifies the value of the DateInput component.\n     *\n     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n\n\n    set value(value) {\n      this.verifyValue(value);\n\n      if (this.autoCorrect && !isInRange(value, this.min, this.max)) {\n        return;\n      }\n\n      this._value = cloneDate(value);\n      this.valueUpdate.emit(cloneDate(value));\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      const newSize = size ? size : DEFAULT_SIZE;\n\n      if (newSize !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n\n      if (newRounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `flat`\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n\n      if (newFillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n\n        if (this.spinners && this.spinup && this.spindown) {\n          this.setSpinnerFill(this.spinup.nativeElement, newFillMode, this.fillMode);\n          this.setSpinnerFill(this.spindown.nativeElement, newFillMode, this.fillMode);\n        }\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    get wrapperClass() {\n      return true;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get inputElement() {\n      return this.dateInput ? this.dateInput.nativeElement : null;\n    }\n\n    get inputValue() {\n      return (this.inputElement || {}).value || '';\n    }\n\n    get isActive() {\n      return this._active;\n    }\n\n    set isActive(value) {\n      this._active = value;\n\n      if (!this.wrapper) {\n        return;\n      }\n\n      if (!isPresent(this.pickerService)) {\n        const element = this.wrapper.nativeElement;\n\n        if (value) {\n          this.renderer.addClass(element, 'k-focus');\n        } else {\n          this.renderer.removeClass(element, 'k-focus');\n        }\n      }\n    }\n\n    get inputFormat() {\n      if (!this.format) {\n        return DEFAULT_FORMAT$1;\n      }\n\n      if (typeof this.format === 'string') {\n        return this.format;\n      } else {\n        return this.format.inputFormat;\n      }\n    }\n\n    get displayFormat() {\n      if (!this.format) {\n        return DEFAULT_FORMAT$1;\n      }\n\n      if (typeof this.format === 'string') {\n        return this.format;\n      } else {\n        return this.format.displayFormat;\n      }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty\n     */\n\n\n    isEmpty() {\n      return !this.currentValue || !String(this.currentValue).trim();\n    }\n    /**\n     * @hidden\n     */\n\n\n    containsElement(element) {\n      return Boolean(closest(element, node => node === this.wrapper.nativeElement));\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      this.verifyRange();\n\n      if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {\n        this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;\n        this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;\n        this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;\n        this.onValidatorChange();\n      }\n\n      if (changes.format) {\n        this.symbolsMap = this.dateSymbolMap();\n        this.updateFormatSections();\n      }\n\n      const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.getDateObject());\n\n      if (changes.format || !isEqualToKendoDate || changes.placeholder) {\n        this.kendoDate = this.getKendoDate(this.value);\n        this.updateElementValue(this.isActive);\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n      }\n\n      if (this.pickerService) {\n        this.pickerService.input = null;\n      }\n\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.kendoDate = this.getKendoDate(this.value);\n      this.updateElementValue();\n      this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n      this.ngControl = this.injector.get(NgControl, null);\n\n      if (this.wrapper) {\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n        this.ngZone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    } //ngModel binding\n\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.verifyValue(value);\n      this.kendoDate = this.getKendoDate(value);\n      this.value = cloneDate(value);\n      this.updateElementValue(this.isActive);\n    }\n    /**\n     * @hidden\n     */\n\n\n    triggerChange() {\n      const value = this.kendoDate.getDateObject();\n\n      if (+value !== +this.value) {\n        this.value = cloneDate(value);\n        this.notify();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    notify() {\n      this.ngZone.run(() => {\n        this.onControlChange(cloneDate(this.value));\n        this.valueChange.emit(cloneDate(this.value));\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * Focuses the DateInput component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"dateinput.focus()\">Focus date input</button>\n     *  <kendo-dateinput #dateinput></kendo-dateinput>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      const input = this.inputElement;\n\n      if (input) {\n        input.focus();\n        this.selectDateSegment(this.currentFormat[0]);\n      }\n    }\n    /**\n     * Blurs the DateInput component.\n     */\n\n\n    blur() {\n      const input = this.inputElement;\n\n      if (input) {\n        input.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleButtonClick(offset) {\n      this.arrowDirection = Arrow.None;\n      this.modifyDateSegmentValue(offset);\n    }\n    /**\n     * @hidden\n     */\n\n\n    modifyDateSegmentValue(offset) {\n      const caret = this.caret();\n      const symbol = this.currentFormat[caret[0]];\n      let step = (this.steps || {})[this.symbolsMap[symbol]] || 1;\n\n      if (symbol === \"S\" && !this.steps.millisecond) {\n        const msDigits = millisecondDigitsInFormat(this.inputFormat);\n        step = millisecondStepFor(msDigits);\n      }\n\n      this.kendoDate.modifyPart(symbol, offset * step);\n      this.putDateInRange();\n      this.updateElementValue(this.isActive);\n      this.triggerChange();\n      this.selectDateSegment(symbol);\n      this.updateIncompleteValidationStatus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    switchDateSegment(offset) {\n      const caret = this.caret();\n\n      if (this.kendoDate.resetLeadingZero()) {\n        this.updateElementValue(this.isActive);\n      }\n\n      if (caret[0] < caret[1] && this.currentFormat[caret[0]] !== this.currentFormat[caret[1] - 1]) {\n        this.selectNearestSegment(offset > 0 ? caret[0] : caret[1] - 1);\n        this.resetSegmentValue = true;\n        return true;\n      }\n\n      const previousFormatSymbol = this.currentFormat[caret[0]];\n      let a = caret[0] + offset;\n\n      while (a > 0 && a < this.currentFormat.length) {\n        if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== \"_\") {\n          break;\n        }\n\n        a += offset;\n      }\n\n      if (this.currentFormat[a] === \"_\") {\n        //there is not known symbol found\n        return false;\n      }\n\n      let b = a;\n\n      while (b >= 0 && b < this.currentFormat.length) {\n        if (this.currentFormat[b] !== this.currentFormat[a]) {\n          break;\n        }\n\n        b += offset;\n      }\n\n      if (a > b && (b + 1 !== caret[0] || a + 1 !== caret[1])) {\n        this.caret(b + 1, a + 1);\n        this.resetSegmentValue = true;\n        return true;\n      } else if (a < b && (a !== caret[0] || b !== caret[1])) {\n        this.caret(a, b);\n        this.resetSegmentValue = true;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectDateSegment(symbol) {\n      let begin = -1;\n      let end = 0;\n\n      for (let i = 0; i < this.currentFormat.length; i++) {\n        if (this.currentFormat[i] === symbol) {\n          end = i + 1;\n\n          if (begin === -1) {\n            begin = i;\n          }\n        }\n      }\n\n      if (begin < 0) {\n        begin = 0;\n      }\n\n      this.caret(0, 0);\n      this.caret(begin, end);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleClick() {\n      this.hasMousedown = false;\n\n      if (this.isActive) {\n        const selectionPresent = this.inputElement.selectionStart !== this.inputElement.selectionEnd;\n        const placeholderToggled = isPresent(this.placeholder) && !this.kendoDate.hasValue() && !this.focusedPriorToMousedown; // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n\n        const selectFirstSegment = !selectionPresent && placeholderToggled;\n        const index = selectFirstSegment ? 0 : this.caret()[0];\n        this.selectNearestSegment(index);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDragAndDrop(args) {\n      args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMousedown() {\n      this.hasMousedown = true;\n      this.focusedPriorToMousedown = this.isActive;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus(args) {\n      this.isActive = true;\n      this.updateElementValue();\n\n      if (!this.hasMousedown) {\n        this.caret(0, this.inputValue.length);\n      }\n\n      this.hasMousedown = false;\n\n      if (hasObservers(this.onFocus)) {\n        this.ngZone.run(() => {\n          this.emitFocus(args);\n        });\n      } else {\n        this.emitFocus(args);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(args) {\n      this.isActive = false;\n      this.resetSegmentValue = true;\n      this.kendoDate.resetLeadingZero();\n      this.updateElementValue();\n\n      if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {\n        this.ngZone.run(() => {\n          this.onControlTouched();\n          this.emitBlur(args);\n          this.cdr.markForCheck();\n        });\n      } else {\n        this.emitBlur(args);\n      }\n    }\n\n    getKendoDate(value) {\n      const {\n        leadingZero\n      } = this.kendoDate || {} || null;\n      const kendoDate = new KendoDate(this.intl, this.formatPlaceholder, this.inputFormat, value, this.twoDigitYearMax);\n      kendoDate.setLeadingZero(this.isActive ? leadingZero : null);\n      return kendoDate;\n    }\n\n    dateSymbolMap() {\n      const reducer = (map, part) => {\n        map[part.pattern[0]] = part.type;\n        return map;\n      };\n\n      return this.intl.splitDateFormat(this.inputFormat).reduce(reducer, {});\n    }\n\n    updateElementValue(isActive) {\n      const start = this.caret()[0]; //XXX: get caret position before input is updated\n\n      const format = this.isActive ? this.inputFormat : this.displayFormat;\n      const texts = this.kendoDate.getTextAndFormat(format);\n      const showPlaceholder = !this.isActive && isPresent(this.placeholder) && !this.kendoDate.hasValue();\n      const input = this.inputElement;\n      this.currentFormat = texts[1];\n      this.currentValue = !showPlaceholder ? texts[0] : '';\n      this.renderer.setProperty(input, \"value\", this.currentValue);\n\n      if (input.placeholder !== this.placeholder) {\n        this.renderer.setProperty(input, \"placeholder\", this.placeholder);\n      }\n\n      if (isActive) {\n        this.selectNearestSegment(start);\n      }\n    }\n\n    caret(start, end = start) {\n      const isPosition = start !== undefined;\n      let returnValue = [start, start];\n      const element = this.inputElement;\n\n      if (isPosition && (this.disabled || this.readonly)) {\n        return undefined;\n      }\n\n      try {\n        if (element.selectionStart !== undefined) {\n          if (isPosition) {\n            if (isDocumentAvailable() && document.activeElement !== element) {\n              element.focus();\n            }\n\n            element.setSelectionRange(start, end);\n          }\n\n          returnValue = [element.selectionStart, element.selectionEnd];\n        }\n      } catch (e) {\n        returnValue = [];\n      }\n\n      return returnValue;\n    }\n\n    selectNearestSegment(index) {\n      // Finds the nearest (in both directions) known part.\n      for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n        if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n          this.selectDateSegment(this.currentFormat[i]);\n          return;\n        }\n\n        if (j >= 0 && this.currentFormat[j] !== \"_\") {\n          this.selectDateSegment(this.currentFormat[j]);\n          return;\n        }\n      }\n    }\n\n    verifyRange() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isValidRange(this.min, this.max)) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);\n      }\n    }\n\n    verifyValue(value) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (value && !(value instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$3} for possible resolution.`);\n      }\n    }\n\n    putDateInRange() {\n      const currentDate = this.kendoDate.getDateObject();\n      const candidate = dateInRange(currentDate, this.min, this.max);\n\n      if (this.autoCorrect && !isEqual(currentDate, candidate)) {\n        this.kendoDate = this.getKendoDate(candidate);\n      }\n    }\n\n    updateFormatSections() {\n      this.formatSections = this.intl.splitDateFormat(this.inputFormat).reduce(({\n        date,\n        time\n      }, p) => {\n        return {\n          date: date || DATE_PART_REGEXP.test(p.type),\n          time: time || TIME_PART_REGEXP.test(p.type)\n        };\n      }, {\n        date: false,\n        time: false\n      });\n    }\n\n    intlChange() {\n      this.updateFormatSections();\n      this.kendoDate = this.getKendoDate(this.value);\n      this.updateElementValue(this.isActive);\n    }\n\n    updateOnPaste() {\n      let value = this.intl.parseDate(this.inputValue, this.inputFormat) || this.value;\n\n      if (isPresent(value) && this.kendoDate.shouldNormalizeCentury()) {\n        value = this.kendoDate.normalizeCentury(value);\n      }\n\n      const notify = +value !== +this.value;\n      this.writeValue(value);\n\n      if (notify) {\n        this.notify();\n      }\n    }\n\n    bindEvents() {\n      const element = this.wrapper.nativeElement;\n      const mousewheelHandler = this.handleMouseWheel.bind(this);\n      this.domEvents.push(this.renderer.listen(element, 'DOMMouseScroll', mousewheelHandler), this.renderer.listen(element, 'mousewheel', mousewheelHandler), this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)), this.renderer.listen(element, 'paste', this.handlePaste.bind(this)), this.renderer.listen(element, 'input', this.handleInput.bind(this)));\n    }\n\n    handleMouseWheel(event) {\n      if (this.disabled || this.readonly || !this.isActive) {\n        return;\n      }\n\n      event = window.event || event;\n\n      if (event.shiftKey) {\n        this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n      } else {\n        this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n      }\n\n      event.returnValue = false;\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n\n    handlePaste() {\n      this.paste = true;\n    }\n\n    handleKeydown(event) {\n      if (this.disabled || this.readonly || event.altKey || event.ctrlKey || event.metaKey) {\n        return;\n      }\n\n      if (event.keyCode === Keys.Tab) {\n        const moved = this.switchDateSegment(event.shiftKey ? -1 : 1);\n\n        if (moved) {\n          event.preventDefault();\n        }\n\n        return;\n      }\n\n      if (event.keyCode === Keys.Backspace) {\n        this.backspace = true;\n        return;\n      }\n\n      switch (event.keyCode) {\n        case Keys.ArrowDown:\n          this.modifyDateSegmentValue(-1);\n          break;\n\n        case Keys.ArrowUp:\n          this.modifyDateSegmentValue(1);\n          break;\n\n        case Keys.ArrowRight:\n          this.switchDateSegment(1);\n          break;\n\n        case Keys.ArrowLeft:\n          this.switchDateSegment(-1);\n          break;\n\n        case Keys.Home:\n          this.selectNearestSegment(0);\n          break;\n\n        case Keys.End:\n          this.selectNearestSegment(this.inputValue.length);\n          break;\n\n        default:\n          return;\n        //skip the preventDefault if we didn't handled the keyCode\n      }\n\n      event.preventDefault();\n    }\n\n    handleInput() {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      if (this.paste) {\n        this.updateOnPaste();\n        this.paste = false;\n        return;\n      }\n\n      const diff = approximateStringMatching(this.currentValue, this.currentFormat, this.inputValue, this.caret()[0]);\n      const navigationOnly = diff.length === 1 && diff[0][1] === \"_\";\n      let switchPart = false;\n\n      if (!navigationOnly) {\n        let parsedPart;\n\n        for (let i = 0; i < diff.length; i++) {\n          parsedPart = this.kendoDate.parsePart(diff[i][0], diff[i][1], this.resetSegmentValue);\n          switchPart = parsedPart.switchToNext;\n        }\n\n        const candidate = this.kendoDate.getDateObject();\n\n        if (this.value && candidate && !this.formatSections.date) {\n          this.kendoDate = this.getKendoDate(setTime(this.value, candidate));\n        }\n      }\n\n      this.resetSegmentValue = false;\n      this.putDateInRange();\n      this.updateElementValue(this.isActive);\n      this.triggerChange();\n      this.updateIncompleteValidationStatus();\n\n      if (diff.length && diff[0][0] !== \"_\") {\n        this.selectDateSegment(diff[0][0]);\n      }\n\n      if (switchPart || navigationOnly) {\n        this.switchDateSegment(1);\n      }\n\n      if (this.backspace) {\n        this.switchDateSegment(-1);\n      }\n\n      this.backspace = false;\n    }\n\n    emitFocus(args) {\n      this.onFocus.emit();\n\n      if (this.pickerService) {\n        this.pickerService.onFocus.emit(args);\n      }\n    }\n\n    emitBlur(args) {\n      this.onBlur.emit();\n\n      if (this.pickerService) {\n        this.pickerService.onBlur.emit(args);\n      }\n    }\n\n    updateIncompleteValidationStatus() {\n      const previousValue = this.isDateIncomplete;\n      this.isDateIncomplete = this.kendoDate.hasValue() && this.value === null;\n\n      if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {\n        return;\n      }\n\n      if (isPresent(this.ngControl) && !isPresent(this.pickerService)) {\n        this.cdr.markForCheck();\n        this.ngZone.run(() => this.onValidatorChange());\n      } else if (isPresent(this.pickerService)) {\n        this.pickerService.dateCompletenessChange.emit();\n      }\n    }\n\n    setSpinnerFill(spinner, fill, oldFill) {\n      if (oldFill !== 'none') {\n        this.renderer.removeClass(spinner, `k-button-${oldFill}`);\n        this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);\n      }\n\n      this.renderer.addClass(spinner, `k-button-${fill}`);\n      this.renderer.addClass(spinner, `k-button-${fill}-base`);\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n\n      if (this.spinners && this.fillMode !== 'none') {\n        this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);\n        this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);\n      }\n    }\n\n  }\n\n  DateInputComponent.ɵfac = function DateInputComponent_Factory(t) {\n    return new (t || DateInputComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(PickerService, 8));\n  };\n\n  DateInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateInputComponent,\n    selectors: [[\"kendo-dateinput\"]],\n    viewQuery: function DateInputComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c21, 7);\n        i0.ɵɵviewQuery(_c22, 5);\n        i0.ɵɵviewQuery(_c23, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.spinup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.spindown = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function DateInputComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-input\", ctx.wrapperClass)(\"k-dateinput\", ctx.wrapperClass)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      title: \"title\",\n      tabindex: \"tabindex\",\n      role: \"role\",\n      ariaReadOnly: \"ariaReadOnly\",\n      tabIndex: \"tabIndex\",\n      format: \"format\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      steps: \"steps\",\n      max: \"max\",\n      min: \"min\",\n      rangeValidation: \"rangeValidation\",\n      autoCorrect: \"autoCorrect\",\n      incompleteDateValidation: \"incompleteDateValidation\",\n      twoDigitYearMax: \"twoDigitYearMax\",\n      value: \"value\",\n      spinners: \"spinners\",\n      isPopupOpen: \"isPopupOpen\",\n      hasPopup: \"hasPopup\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      valueUpdate: \"valueUpdate\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendo-dateinput\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => DateInputComponent),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => DateInputComponent),\n      multi: true\n    }, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dateinput'\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => DateInputComponent)\n    }, LocalizationService]), i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 21,\n    consts: function () {\n      let i18n_24;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the **Increment** button in the DateInput\n         * @meaning kendo.dateinput.increment\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_25 = goog.getMsg(\"Increase value\");\n        i18n_24 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_25;\n      } else {\n        i18n_24 = $localize`:kendo.dateinput.increment|The label for the **Increment** button in the DateInput:Increase value`;\n      }\n\n      let i18n_26;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the **Decrement** button in the DateInput\n         * @meaning kendo.dateinput.decrement\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_27 = goog.getMsg(\"Decrease value\");\n        i18n_26 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_27;\n      } else {\n        i18n_26 = $localize`:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput:Decrease value`;\n      }\n\n      return [[\"kendoDateInputLocalizedMessages\", \"\", \"increment\", i18n_24, \"decrement\", i18n_26], [\"autocomplete\", \"off\", \"autocorrect\", \"off\", \"autocapitalize\", \"off\", \"spellcheck\", \"false\", 1, \"k-input-inner\", 3, \"id\", \"title\", \"tabindex\", \"disabled\", \"readonly\", \"placeholder\", \"kendoEventsOutsideAngular\", \"scope\"], [\"dateInput\", \"\"], [\"class\", \"k-input-spinner k-spin-button\", 3, \"mousedown\", 4, \"ngIf\"], [1, \"k-input-spinner\", \"k-spin-button\", 3, \"mousedown\"], [\"tabindex\", \"-1\", 1, \"k-spinner-increase\", \"k-button\", \"k-icon-button\", 3, \"title\", \"mousedown\", \"mouseleave\", \"click\"], [\"spinup\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrow-n\"], [\"tabindex\", \"-1\", 1, \"k-spinner-decrease\", \"k-button\", \"k-icon-button\", 3, \"title\", \"click\", \"mousedown\", \"mouseleave\"], [\"spindown\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-arrow-s\"]];\n    },\n    template: function DateInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelement(1, \"input\", 1, 2);\n        i0.ɵɵtemplate(3, DateInputComponent_span_3_Template, 7, 8, \"span\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"title\", ctx.title)(\"tabindex\", ctx.tabindex)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"placeholder\", ctx.placeholder)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction7(13, _c28, ctx.handleClick, ctx.handleFocus, ctx.handleMousedown, ctx.handleMousedown, ctx.handleDragAndDrop, ctx.handleDragAndDrop, ctx.handleBlur))(\"scope\", ctx);\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-readonly\", ctx.ariaReadOnly)(\"aria-expanded\", ctx.isPopupOpen)(\"aria-haspopup\", ctx.hasPopup);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.spinners);\n      }\n    },\n    directives: [DateInputLocalizedMessagesDirective, i5.EventsOutsideAngularDirective, i7.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DateInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A preventable event instance which is triggered by the `open` and `close` events.\n */\n\n\nclass PreventableEvent {\n  /** @hidden */\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst TOUCH_ENABLED = new InjectionToken('dateinputs-touch-enabled');\n/**\n * @hidden\n */\n\nconst disabledDatesValidator = isDateDisabled => {\n  return control => {\n    if (!isDateDisabled || !control.value) {\n      return null;\n    }\n\n    const error = {\n      disabledDate: true\n    };\n    return isDateDisabled(control.value) ? error : null;\n  };\n};\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet CalendarCustomMessagesComponent = /*#__PURE__*/(() => {\n  class CalendarCustomMessagesComponent extends CalendarMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  CalendarCustomMessagesComponent.ɵfac = function CalendarCustomMessagesComponent_Factory(t) {\n    return new (t || CalendarCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  CalendarCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CalendarCustomMessagesComponent,\n    selectors: [[\"kendo-calendar-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CalendarMessages,\n      useExisting: forwardRef(() => CalendarCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CalendarCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CalendarCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DatePickerMessages = /*#__PURE__*/(() => {\n  class DatePickerMessages extends ComponentMessages {}\n\n  DatePickerMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵDatePickerMessages_BaseFactory;\n    return function DatePickerMessages_Factory(t) {\n      return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = i0.ɵɵgetInheritedFactory(DatePickerMessages)))(t || DatePickerMessages);\n    };\n  }();\n\n  DatePickerMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DatePickerMessages,\n    selectors: [[\"kendo-datepicker-messages-base\"]],\n    inputs: {\n      today: \"today\",\n      toggle: \"toggle\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DatePickerMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DatePickerLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class DatePickerLocalizedMessagesDirective extends DatePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  DatePickerLocalizedMessagesDirective.ɵfac = function DatePickerLocalizedMessagesDirective_Factory(t) {\n    return new (t || DatePickerLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  DatePickerLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DatePickerLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoDatePickerLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DatePickerMessages,\n      useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DatePickerLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min';\nconst MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max';\nconst VALUE_DOC_LINK$2 = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json';\nconst DEFAULT_FORMAT = 'd';\nconst TWO_DIGIT_YEAR_MAX$1 = 68;\n/**\n * Represents the [Kendo UI DatePicker component for Angular]({% slug overview_datepicker %}#toc-basic-usage).\n */\n\nlet DatePickerComponent = /*#__PURE__*/(() => {\n  class DatePickerComponent {\n    constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, disabledDatesService, touchEnabled) {\n      this.zone = zone;\n      this.localization = localization;\n      this.cdr = cdr;\n      this.popupService = popupService;\n      this.wrapper = wrapper;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.pickerService = pickerService;\n      this.disabledDatesService = disabledDatesService;\n      this.touchEnabled = touchEnabled;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Defines the active view that the Calendar initially renders\n       * ([see example]({% slug calendar_type_datepicker %}#toc-active-view)).\n       * By default, the active view is `month`.\n       *\n       * > You have to set `activeView` within the `topView`-`bottomView` range.\n       */\n\n      this.activeView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the bottommost Calendar view to which the user can navigate\n       * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n       */\n\n      this.bottomView = CalendarViewEnum[CalendarViewEnum.month];\n      /**\n       * Defines the topmost Calendar view to which the user can navigate\n       * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n       */\n\n      this.topView = CalendarViewEnum[CalendarViewEnum.century];\n      /**\n       * Specifies the Calendar type.\n       *\n       * The possible values are:\n       * - `infinite` (default)\n       * - `classic`\n       *\n       */\n\n      this.calendarType = 'infinite';\n      /**\n       * Determines whether to enable animation when navigating to previous/next Calendar view.\n       * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateCalendarNavigation = false;\n      /**\n       * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active\n       * ([see example]({% slug disabled_datepicker %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the DatePicker\n       * ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the read-only state of the DatePicker input field\n       * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).\n       *\n       * > Note that if you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,\n       * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n       */\n\n      this.readOnlyInput = false;\n      /**\n       * Sets or gets the `navigation` property of the Calendar\n       * and determines whether the navigation side-bar is displayed.\n       * ([see example]({% slug sidebar_datepicker %})).\n       */\n\n      this.navigation = true;\n      /**\n       * Specifies the smallest valid date\n       * ([see example]({% slug dateranges_datepicker %})).\n       * By default, the `min` value is `1900-1-1`.\n       */\n\n      this.min = cloneDate(MIN_DATE);\n      /**\n       * Specifies the biggest valid date\n       * ([see example]({% slug dateranges_datepicker %})).\n       * By default, the `max` value is `2099-12-31`.\n       */\n\n      this.max = cloneDate(MAX_DATE);\n      /**\n       * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n       */\n\n      this.incompleteDateValidation = false;\n      /**\n       * Specifies the focused date of the Calendar component\n       * ([see example]({% slug calendar_type_datepicker %}#toc-focused-dates)).\n       */\n\n      this.focusedDate = null;\n      /**\n       * Specifies the date format that is used to display the input value\n       * ([see example]({% slug formats_datepicker %})).\n       *\n       * Format value options:\n       * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n       * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n       */\n\n      this.format = DEFAULT_FORMAT;\n      /**\n       * The maximum year to assume to be from the current century when typing two-digit year value\n       * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).\n       *\n       * The default value is 68, indicating that typing any value less than 69\n       * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n       */\n\n      this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;\n      /**\n       * Specifies the hint the DatePicker displays when its value is `null`.\n       * ([more information and exaples]({% slug placeholders_datepicker %})).\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-datepicker placeholder=\"Enter birth date...\"></kendo-datepicker>\n       * `\n       * })\n       * export class AppComponent { }\n       * ```\n       */\n\n      this.placeholder = null;\n      /**\n       * Sets or gets the `tabindex` property of the DatePicker.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Sets the title of the input element of the DatePicker.\n       */\n\n      this.title = \"\";\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form.\n       */\n\n      this.rangeValidation = true;\n      /**\n       * Determines whether the built-in validator for disabled\n       * date ranges is enforced when validating a form\n       * ([see example]({% slug disabled_dates_datepicker %}#toc-validation)).\n       */\n\n      this.disabledDatesValidation = true;\n      /**\n       * Determines whether to display a week number column in the `month` view of the Calendar\n       * ([see example]({% slug calendar_type_datepicker %}#toc-week-number-column)).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Fires each time the user selects a new value\n       * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user focuses the input element\n       * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-datepicker (focus)=\"handleFocus()\"></kendo-datepicker>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log(\"Component is focused\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the input element gets blurred\n       * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-datepicker (blur)=\"handleBlur()\"></kendo-datepicker>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log(\"Component is blurred\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed\n       * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open\n       * ([more information and example]({% slug overview_datepicker %}#toc-events)).\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.wrapperClasses = true;\n      this.popupUID = guid();\n      this._popupSettings = {\n        animate: true\n      };\n      this._show = false;\n      this._value = null;\n      this._active = false;\n      this.onControlChange = noop$2;\n      this.onControlTouched = noop$2;\n      this.onValidatorChange = noop$2;\n      this.minValidateFn = noop$2;\n      this.maxValidateFn = noop$2;\n      this.disabledDatesValidateFn = noop$2;\n      this.incompleteValidator = noop$2;\n      this.resolvedPromise = Promise.resolve(null);\n      this.domEvents = [];\n      this._size = DEFAULT_SIZE;\n      this._rounded = DEFAULT_ROUNDED;\n      this._fillMode = DEFAULT_FILL_MODE;\n      validatePackage(packageMetadata);\n      this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n      this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n      this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));\n      this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n    }\n    /**\n     * @hidden\n     */\n\n\n    set cellTemplateRef(template) {\n      this.cellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set monthCellTemplateRef(template) {\n      this.monthCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set yearCellTemplateRef(template) {\n      this.yearCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set decadeCellTemplateRef(template) {\n      this.decadeCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set centuryCellTemplateRef(template) {\n      this.centuryCellTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set weekNumberTemplateRef(template) {\n      this.weekNumberTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set headerTitleTemplateRef(template) {\n      this.headerTitleTemplate = template;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set navigationItemTemplateRef(template) {\n      this.navigationItemTemplate = template;\n    }\n    /**\n     * Configures the popup options of the DatePicker.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, {\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Specifies the value of the DatePicker component.\n     *\n     * > The `value` has to be a valid\n     * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n\n\n    set value(value) {\n      this.verifyValue(value);\n      this._value = cloneDate(value);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the dates of the DatePicker that will be disabled\n     * ([see example]({% slug disabled_dates_datepicker %})).\n     */\n\n\n    set disabledDates(value) {\n      this._disabledDates = value;\n      this.disabledDatesService.initialize(value);\n    }\n\n    get disabledDates() {\n      return this._disabledDates;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));\n      const newSize = size ? size : DEFAULT_SIZE;\n\n      if (newSize !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n\n      if (newRounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `flat`\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n\n      if (newFillMode !== 'none') {\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', newFillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get inputRole() {\n      return this.readOnlyInput ? 'listbox' : 'spinbutton';\n    }\n\n    get isActive() {\n      return this._active;\n    }\n\n    set isActive(value) {\n      this._active = value;\n\n      if (!this.wrapper) {\n        return;\n      }\n\n      const element = this.wrapper.nativeElement;\n\n      if (value) {\n        this.renderer.addClass(element, 'k-focus');\n      } else {\n        this.renderer.removeClass(element, 'k-focus');\n      }\n    }\n\n    get show() {\n      return this._show;\n    }\n\n    set show(show) {\n      if (show && (this.disabled || this.readonly)) {\n        return;\n      }\n\n      const skipZone = !show && (!this._show || !hasObservers(this.close));\n\n      if (!skipZone) {\n        this.zone.run(() => {\n          this.togglePopup(show);\n        });\n      } else {\n        this.togglePopup(show);\n      }\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      return !this.value && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n      this.control = this.injector.get(NgControl, null);\n\n      if (this.wrapper) {\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      this.verifySettings();\n\n      if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;\n        this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;\n        this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;\n        this.onValidatorChange();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.isActive = false;\n      this.show = false;\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      if (this.windowBlurSubscription) {\n        this.windowBlurSubscription.unsubscribe();\n      }\n\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n      this.pickerSubscriptions.unsubscribe();\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this.show;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.verifyValue(value);\n      this.value = cloneDate(value);\n      this.cdr.markForCheck();\n\n      if (!value && this.input) {\n        this.input.placeholder = this.placeholder;\n        this.input.writeValue(value);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * Focuses the DatePicker component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"datepicker.focus()\">Focus date picker</button>\n     *  <kendo-datepicker #datepicker></kendo-datepicker>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      this.input.focus();\n    }\n    /**\n     * Blurs the DatePicker component.\n     */\n\n\n    blur() {\n      (this.calendar || this.input)['blur']();\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show - The state of the popup.\n     */\n\n\n    toggle(show) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.resolvedPromise.then(() => {\n        this._toggle(show === undefined ? !this.show : show);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleIconClick(event) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      event.preventDefault();\n      this.focusInput(); //XXX: explicitly call the handleFocus handler here\n      //due to async IE focus event\n\n      this.handleFocus();\n      this.show = !this.show;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMousedown(args) {\n      args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleChange(value) {\n      this.cdr.markForCheck();\n      this.focusInput();\n      this.value = value;\n      this.show = false;\n      this.onControlChange(cloneDate(value));\n      this.valueChange.emit(cloneDate(value));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleInputChange(value) {\n      this.handleChange(this.input.formatSections.time ? value : this.mergeTime(value));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get popupClasses() {\n      return ['k-calendar-container', 'k-group', 'k-reset'].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    get input() {\n      return this.pickerService.input;\n    }\n\n    get calendar() {\n      return this.pickerService.calendar;\n    }\n    /**\n     * @hidden\n     */\n\n\n    mergeTime(value) {\n      return this.value && value ? setTime(value, this.value) : value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeydown(e) {\n      const {\n        altKey,\n        shiftKey,\n        keyCode,\n        target\n      } = e;\n\n      if (keyCode === Keys.Escape) {\n        this.show = false;\n      }\n\n      if (altKey) {\n        if (keyCode === Keys.ArrowDown && !this.show) {\n          this.show = true;\n        }\n\n        if (keyCode === Keys.ArrowUp) {\n          this.show = false;\n        }\n      }\n\n      if (keyCode === Keys.Tab && this.show && this.calendar.isActive && isTabExitingCalendar(this.calendarType, target, shiftKey)) {\n        this.input.focus();\n        this.show = false;\n      }\n    }\n\n    togglePopup(show) {\n      const event = new PreventableEvent();\n\n      if (!this._show && show) {\n        this.open.emit(event);\n      } else if (this._show && !show) {\n        this.close.emit(event);\n      }\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      this._toggle(show);\n\n      this.toggleFocus();\n    }\n\n    _toggle(show) {\n      if (show === this._show) {\n        return;\n      }\n\n      this._show = show;\n\n      if (show) {\n        const direction = this.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: this.wrapper,\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          animate: this.popupSettings.animate,\n          appendTo: this.appendTo,\n          content: this.popupTemplate,\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          },\n          popupClass: this.popupClasses,\n          positionMode: 'absolute'\n        });\n        this.popupRef.popupElement.setAttribute('id', this.popupUID);\n        this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n      } else {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.subscription.unsubscribe();\n      }\n    }\n\n    focusInput() {\n      if (this.touchEnabled) {\n        return;\n      }\n\n      this.input.focus();\n    }\n\n    toggleFocus() {\n      if (!this.isActive) {\n        return;\n      }\n\n      if (this.show) {\n        if (!this.calendar) {\n          this.cdr.detectChanges();\n        }\n\n        if (this.calendar) {\n          this.calendar.focus();\n        }\n      } else if (!this.touchEnabled) {\n        this.input.focus();\n      } else if (!this.input.isActive) {\n        this.handleBlur();\n      }\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isValidRange(this.min, this.max)) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);\n      }\n    }\n\n    verifyValue(value) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (value && !(value instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$2} for possible resolution.`);\n      }\n    }\n\n    bindEvents() {\n      const element = this.wrapper.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n\n      if (isWindowAvailable()) {\n        this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n      }\n    }\n\n    handleFocus() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n\n      if (hasObservers(this.onFocus)) {\n        this.zone.run(() => {\n          this.onFocus.emit();\n        });\n      }\n    }\n\n    handleWindowBlur() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.show = false;\n    }\n\n    handleBlur(args) {\n      const currentTarget = args && currentFocusTarget(args);\n\n      if (currentTarget && (this.input.containsElement(currentTarget) || this.calendar && this.calendar.containsElement(currentTarget))) {\n        return;\n      }\n\n      if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {\n        this.zone.run(() => {\n          this.blurComponent();\n          this.cdr.markForCheck();\n        });\n      } else {\n        this.blurComponent();\n      }\n    }\n\n    blurComponent() {\n      this.isActive = false; // order is important ¯\\_(ツ)_/¯\n\n      this.show = false;\n      this.cdr.detectChanges();\n      this.onControlTouched();\n      this.onBlur.emit();\n    }\n\n    handleSameSelection() {\n      if (this.show) {\n        this.focusInput();\n        this.show = false;\n      }\n    }\n\n    handleDateCompletenessChange() {\n      this.cdr.markForCheck();\n      this.zone.run(() => this.onValidatorChange());\n    }\n\n    setComponentClasses() {\n      if (this.size) {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));\n      }\n\n      if (this.rounded) {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode) {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      }\n    }\n\n  }\n\n  DatePickerComponent.ɵfac = function DatePickerComponent_Factory(t) {\n    return new (t || DatePickerComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(PickerService), i0.ɵɵdirectiveInject(DisabledDatesService), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  DatePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DatePickerComponent,\n    selectors: [[\"kendo-datepicker\"]],\n    contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);\n      }\n    },\n    viewQuery: function DatePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c29, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c30, 7);\n        i0.ɵɵviewQuery(_c31, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function DatePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-datepicker\", ctx.wrapperClasses)(\"k-input\", ctx.wrapperClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      cellTemplateRef: [\"cellTemplate\", \"cellTemplateRef\"],\n      monthCellTemplateRef: [\"monthCellTemplate\", \"monthCellTemplateRef\"],\n      yearCellTemplateRef: [\"yearCellTemplate\", \"yearCellTemplateRef\"],\n      decadeCellTemplateRef: [\"decadeCellTemplate\", \"decadeCellTemplateRef\"],\n      centuryCellTemplateRef: [\"centuryCellTemplate\", \"centuryCellTemplateRef\"],\n      weekNumberTemplateRef: [\"weekNumberTemplate\", \"weekNumberTemplateRef\"],\n      headerTitleTemplateRef: [\"headerTitleTemplate\", \"headerTitleTemplateRef\"],\n      navigationItemTemplateRef: [\"navigationItemTemplate\", \"navigationItemTemplateRef\"],\n      focusableId: \"focusableId\",\n      activeView: \"activeView\",\n      bottomView: \"bottomView\",\n      topView: \"topView\",\n      calendarType: \"calendarType\",\n      animateCalendarNavigation: \"animateCalendarNavigation\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      readOnlyInput: \"readOnlyInput\",\n      popupSettings: \"popupSettings\",\n      navigation: \"navigation\",\n      min: \"min\",\n      max: \"max\",\n      incompleteDateValidation: \"incompleteDateValidation\",\n      focusedDate: \"focusedDate\",\n      value: \"value\",\n      format: \"format\",\n      twoDigitYearMax: \"twoDigitYearMax\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      disabledDates: \"disabledDates\",\n      title: \"title\",\n      rangeValidation: \"rangeValidation\",\n      disabledDatesValidation: \"disabledDatesValidation\",\n      weekNumber: \"weekNumber\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendo-datepicker\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => DatePickerComponent),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => DatePickerComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => DatePickerComponent)\n    }, LocalizationService, PickerService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.datepicker'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 25,\n    consts: function () {\n      let i18n_32;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.datepicker.today\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_33 = goog.getMsg(\"Today\");\n        i18n_32 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_33;\n      } else {\n        i18n_32 = $localize`:kendo.datepicker.today|The label for the today button in the calendar header:Today`;\n      }\n\n      let i18n_34;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the toggle button in the datepicker component\n         * @meaning kendo.datepicker.toggle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_35 = goog.getMsg(\"Toggle calendar\");\n        i18n_34 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_35;\n      } else {\n        i18n_34 = $localize`:kendo.datepicker.toggle|The title of the toggle button in the datepicker component:Toggle calendar`;\n      }\n\n      let i18n_36;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the previous button in the Classic calendar\n         * @meaning kendo.datepicker.prevButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_37 = goog.getMsg(\"Navigate to previous view\");\n        i18n_36 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_37;\n      } else {\n        i18n_36 = $localize`:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;\n      }\n\n      let i18n_38;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the next button in the Classic calendar\n         * @meaning kendo.datepicker.nextButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_39 = goog.getMsg(\"Navigate to next view\");\n        i18n_38 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_39;\n      } else {\n        i18n_38 = $localize`:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;\n      }\n\n      return [[\"kendoDatePickerLocalizedMessages\", \"\", \"today\", i18n_32, \"toggle\", i18n_34, \"prevButtonTitle\", i18n_36, \"nextButtonTitle\", i18n_38], [\"fillMode\", \"none\", \"rounded\", \"none\", \"size\", \"none\", 3, \"role\", \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"disabled\", \"readonly\", \"ariaReadOnly\", \"tabindex\", \"title\", \"format\", \"twoDigitYearMax\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"incompleteDateValidation\", \"value\", \"valueChange\"], [\"input\", \"\"], [\"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"tabindex\", \"kendoEventsOutsideAngular\", \"scope\"], [\"toggleButton\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-calendar\"], [\"container\", \"\"], [\"popupTemplate\", \"\"], [3, \"type\", \"min\", \"max\", \"navigation\", \"animateNavigation\", \"activeView\", \"bottomView\", \"topView\", \"weekNumber\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"weekNumberTemplate\", \"headerTitleTemplate\", \"navigationItemTemplate\", \"focusedDate\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"disabledDates\", \"valueChange\"], [\"calendar\", \"\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"]];\n    },\n    template: function DatePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-dateinput\", 1, 2);\n        i0.ɵɵlistener(\"valueChange\", function DatePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {\n          return ctx.handleInputChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"button\", 3, 4);\n        i0.ɵɵelement(5, \"span\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainer(6, null, 6);\n        i0.ɵɵtemplate(8, DatePickerComponent_ng_template_8_Template, 4, 27, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"role\", ctx.inputRole)(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.show)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"ariaReadOnly\", ctx.readonly)(\"tabindex\", ctx.tabindex)(\"title\", ctx.title)(\"format\", ctx.format)(\"twoDigitYearMax\", ctx.twoDigitYearMax)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.min)(\"max\", ctx.max)(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"value\", ctx.value);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"tabindex\", -1)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(22, _c41, ctx.handleIconClick, ctx.handleMousedown))(\"scope\", ctx);\n        i0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n      }\n    },\n    directives: [DateInputComponent, CalendarComponent, CalendarCustomMessagesComponent, DatePickerLocalizedMessagesDirective, i5.EventsOutsideAngularDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DatePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst TIME_PART = {\n  dayperiod: 'dayperiod',\n  hour: 'hour',\n  millisecond: 'millisecond',\n  minute: 'minute',\n  second: 'second'\n};\n/**\n * @hidden\n */\n\nconst timeRangeValidator = (min, max) => {\n  return control => {\n    if (!min || !max || !control.value) {\n      return null;\n    }\n\n    const err = {\n      timeRangeError: {\n        maxValue: max,\n        minValue: min,\n        value: control.value\n      }\n    };\n    return isInTimeRange(control.value, min, max) ? null : err;\n  };\n};\n\nconst HOURS_IN_DAY = 24;\n\nconst clampToRange$3 = rangeValue => value => value % rangeValue;\n\nconst clamp$3 = clampToRange$3(HOURS_IN_DAY);\n\nconst stepper$3 = (start, step) => idx => clamp$3(start + idx * step);\n\nconst distanceFromMin$3 = (value, min) => clamp$3(HOURS_IN_DAY + value - min);\n\nconst limit$3 = borderValue => (barrier, value) => {\n  const useBarrier = !value || getDate(barrier).getTime() === getDate(value).getTime();\n  return useBarrier ? barrier : setHours$1(barrier, borderValue);\n};\n\nconst limitDown$3 = limit$3(0);\nconst limitUp$3 = limit$3(HOURS_IN_DAY - 1);\n/**\n * @hidden\n */\n\nlet HoursService = /*#__PURE__*/(() => {\n  class HoursService {\n    constructor(intl) {\n      this.intl = intl;\n      this.boundRange = false;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setHours$1(value, candidate.getHours());\n    }\n\n    configure(settings) {\n      const {\n        boundRange = this.boundRange,\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.boundRange = boundRange;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = hour => {\n        const date = setHours$1(MIDNIGHT_DATE, hour);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getHour = stepper$3(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getHour(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return this.boundRange ? [limitDown$3(min, value), limitUp$3(max, value)] : [min, max];\n    }\n\n    total(value) {\n      const last = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastHour(value) === value.getHours();\n      return matchMax || !this.isMissing(value);\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastHour(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getHours());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$3(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setHours$1(this.max, this.lastHour(value)));\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$3(value.getHours(), this.min.getHours()) / this.step;\n    }\n\n    lastHour(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getHours(), max.getHours()];\n    }\n\n  }\n\n  HoursService.ɵfac = function HoursService_Factory(t) {\n    return new (t || HoursService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  HoursService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HoursService,\n    factory: HoursService.ɵfac\n  });\n  return HoursService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MINUTES_IN_HOUR = 60;\n\nconst clampToRange$2 = rangeValue => value => value % rangeValue;\n\nconst clamp$2 = clampToRange$2(MINUTES_IN_HOUR);\n\nconst stepper$2 = (start, step) => idx => clamp$2(start + idx * step);\n\nconst distanceFromMin$2 = (value, min) => clamp$2(MINUTES_IN_HOUR + value - min);\n\nconst limit$2 = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours();\n  return useBarrier ? barrier : setMinutes(barrier, borderValue);\n};\n\nconst limitDown$2 = limit$2(0);\nconst limitUp$2 = limit$2(MINUTES_IN_HOUR - 1);\n/**\n * @hidden\n */\n\nlet MinutesService = /*#__PURE__*/(() => {\n  class MinutesService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setMinutes(value, candidate.getMinutes());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = minute => {\n        const date = setMinutes(MIDNIGHT_DATE, minute);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getMinute = stepper$2(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getMinute(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown$2(min, value), limitUp$2(max, value)];\n    }\n\n    total(value) {\n      const last = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastMinute(value) === value.getMinutes();\n      return matchMax || !this.isMissing(value);\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastMinute(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getMinutes());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$2(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setMinutes(this.max, this.lastMinute(value)));\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$2(value.getMinutes(), this.min.getMinutes()) / this.step;\n    }\n\n    lastMinute(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getMinutes(), max.getMinutes()];\n    }\n\n  }\n\n  MinutesService.ɵfac = function MinutesService_Factory(t) {\n    return new (t || MinutesService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  MinutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MinutesService,\n    factory: MinutesService.ɵfac\n  });\n  return MinutesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SECONDS_IN_HOUR = 60;\n\nconst clampToRange$1 = rangeValue => value => value % rangeValue;\n\nconst clamp$1 = clampToRange$1(SECONDS_IN_HOUR);\n\nconst stepper$1 = (start, step) => idx => clamp$1(start + idx * step);\n\nconst distanceFromMin$1 = (value, min) => clamp$1(SECONDS_IN_HOUR + value - min);\n\nconst limit$1 = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes();\n  return useBarrier ? barrier : setSeconds(barrier, borderValue);\n};\n\nconst limitDown$1 = limit$1(0);\nconst limitUp$1 = limit$1(SECONDS_IN_HOUR - 1);\n/**\n * @hidden\n */\n\nlet SecondsService = /*#__PURE__*/(() => {\n  class SecondsService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setSeconds(value, candidate.getSeconds());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        part,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = second => {\n        const date = setSeconds(MIDNIGHT_DATE, second);\n        return {\n          text: this.intl.formatDate(date, part.pattern),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getSecond = stepper$1(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getSecond(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown$1(min, value), limitUp$1(max, value)];\n    }\n\n    total(value) {\n      const last = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastSecond(value) === value.getSeconds();\n      return matchMax || !this.isMissing(value);\n    }\n\n    divideByStep(value) {\n      return distanceFromMin$1(value.getSeconds(), this.min.getSeconds()) / this.step;\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastSecond(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getSeconds());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin$1(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setSeconds(this.max, this.lastSecond(value)));\n    }\n\n    lastSecond(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getSeconds(), max.getSeconds()];\n    }\n\n  }\n\n  SecondsService.ɵfac = function SecondsService_Factory(t) {\n    return new (t || SecondsService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  SecondsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SecondsService,\n    factory: SecondsService.ɵfac\n  });\n  return SecondsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MILLISECONDS_IN_SECOND = 1000;\n\nconst clampToRange = rangeValue => value => value % rangeValue;\n\nconst clamp = clampToRange(MILLISECONDS_IN_SECOND);\n\nconst stepper = (start, step) => idx => clamp(start + idx * step);\n\nconst distanceFromMin = (value, min) => clamp(MILLISECONDS_IN_SECOND + value - min);\n\nconst limit = borderValue => (barrier, value) => {\n  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes() && barrier.getSeconds() === value.getSeconds();\n  return useBarrier ? barrier : setMilliseconds(barrier, borderValue);\n};\n\nconst limitDown = limit(0);\nconst limitUp = limit(MILLISECONDS_IN_SECOND - 1);\n/**\n * @hidden\n */\n\nlet MillisecondsService = /*#__PURE__*/(() => {\n  class MillisecondsService {\n    constructor(intl) {\n      this.intl = intl;\n      this.insertUndividedMax = false;\n    }\n\n    apply(value, candidate) {\n      return setMilliseconds(value, candidate.getMilliseconds());\n    }\n\n    configure(settings) {\n      const {\n        insertUndividedMax = this.insertUndividedMax,\n        min = this.min,\n        max = this.max,\n        step = this.step\n      } = settings;\n      this.insertUndividedMax = insertUndividedMax;\n\n      this.toListItem = millisecond => {\n        const date = setMilliseconds(MIDNIGHT_DATE, millisecond);\n        return {\n          text: this.intl.formatDate(date, \"SSS\"),\n          value: date\n        };\n      };\n\n      this.min = min;\n      this.max = max;\n      this.step = step;\n    }\n\n    data(selectedValue) {\n      const [min] = this.range(selectedValue);\n      const getMillisecond = stepper(min, this.step);\n\n      const convertToItem = idx => this.toListItem(getMillisecond(idx));\n\n      const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);\n      this.addLast(data);\n      this.addMissing(data, selectedValue);\n      return data;\n    }\n\n    isRangeChanged(min, max) {\n      return !isEqual(this.min, min) || !isEqual(this.max, max);\n    }\n\n    limitRange(min, max, value) {\n      return [limitDown(min, value), limitUp(max, value)];\n    }\n\n    total(value) {\n      const last = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;\n      const missing = this.isMissing(value) ? 1 : 0;\n      return this.countFromMin(value) + missing + last;\n    }\n\n    selectedIndex(value) {\n      return Math.ceil(this.divideByStep(value));\n    }\n\n    valueInList(value) {\n      if (!value) {\n        return true;\n      }\n\n      const matchMax = this.insertUndividedMax && this.lastMillisecond(value) === value.getMilliseconds();\n      return matchMax || !this.isMissing(value);\n    }\n\n    divideByStep(value) {\n      return distanceFromMin(value.getMilliseconds(), this.min.getMilliseconds()) / this.step;\n    }\n\n    addLast(data, value) {\n      if (this.insertUndividedMax && this.isLastMissing(value)) {\n        data.push(this.toListItem(this.lastMillisecond(value)));\n      }\n\n      return data;\n    }\n\n    addMissing(data, value) {\n      if (this.valueInList(value)) {\n        return data;\n      }\n\n      const missingItem = this.toListItem(value.getMilliseconds());\n      data.splice(this.selectedIndex(value), 0, missingItem);\n      return data;\n    }\n\n    countFromMin(value) {\n      const [min, max] = this.range(value);\n      return Math.floor(distanceFromMin(max, min) / this.step) + 1;\n      /* include min */\n    }\n\n    isMissing(value) {\n      if (!value) {\n        return false;\n      }\n\n      return this.selectedIndex(value) !== this.divideByStep(value);\n    }\n\n    isLastMissing(value) {\n      return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value)));\n    }\n\n    lastMillisecond(value) {\n      return this.range(value)[1];\n    }\n\n    range(value) {\n      const [min, max] = this.limitRange(this.min, this.max, value);\n      return [min.getMilliseconds(), max.getMilliseconds()];\n    }\n\n  }\n\n  MillisecondsService.ɵfac = function MillisecondsService_Factory(t) {\n    return new (t || MillisecondsService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  MillisecondsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MillisecondsService,\n    factory: MillisecondsService.ɵfac\n  });\n  return MillisecondsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst setHours = (date, hours) => {\n  const clone = cloneDate(date);\n  clone.setHours(hours);\n  return clone;\n};\n\nconst isAM = value => value !== null && value < 12;\n\nconst isPM = value => value !== null && (!value || value > 11);\n\nconst inRange = (value, min, max) => !min && !max || value >= min && value <= max;\n\nconst inReverseRange = (value, min, max) => !min && !max || value >= min || value <= max;\n/**\n * @hidden\n */\n\n\nlet DayPeriodService = /*#__PURE__*/(() => {\n  class DayPeriodService {\n    constructor(intl) {\n      this.intl = intl;\n    }\n    /**\n     * @hidden\n     */\n\n\n    apply(value, candidate) {\n      const hour = value.getHours();\n      const hourAM = isAM(hour);\n      const candidateAM = isAM(candidate.getHours());\n\n      if (hourAM && candidateAM || !hourAM && !candidateAM) {\n        return value;\n      }\n\n      const [min, max = 24] = this.normalizedRange();\n      const result = hour + (candidateAM ? -12 : 12);\n      return setHours(value, Math.min(Math.max(min, result), max || 24));\n    }\n    /**\n     * @hidden\n     */\n\n\n    configure(settings) {\n      const {\n        min = this.min,\n        max = this.max,\n        part = this.part\n      } = settings;\n      this.min = min;\n      this.max = max;\n      this.part = part;\n    }\n    /**\n     * @hidden\n     */\n\n\n    data(_) {\n      const names = this.part.names;\n\n      if (!names) {\n        return [];\n      }\n\n      const data = [];\n      const [min, max] = this.normalizedRange();\n      const dayPeriod = this.intl.dateFormatNames(names);\n\n      if (isAM(min)) {\n        data.push({\n          text: dayPeriod.am,\n          value: setHours(this.min, min)\n        });\n      }\n\n      if (isPM(max)) {\n        data.push({\n          text: dayPeriod.pm,\n          value: setHours(this.min, Math.max(12, max))\n        });\n      }\n\n      return this.min.getHours() !== min ? data.reverse() : data;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isRangeChanged(_, __) {\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    limitRange(min, max, _) {\n      return [min, max];\n    }\n    /**\n     * @hidden\n     */\n\n\n    total() {\n      const [min, max] = this.normalizedRange();\n\n      if (!min && !max) {\n        return 2;\n      }\n\n      if (min > 11 || max < 12) {\n        return 1;\n      }\n\n      return 2;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectedIndex(value) {\n      if (!this.valueInList(value)) {\n        return -1;\n      }\n\n      const index = Math.floor(value.getHours() / 12);\n      return this.min.getHours() === this.normalizedRange()[0] ? index : index === 0 ? 1 : 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    valueInList(value) {\n      const reverse = this.min.getHours() !== this.normalizedRange()[0];\n      const isInRange = reverse ? inReverseRange : inRange;\n      return isInRange(value.getHours(), this.min.getHours(), this.max.getHours());\n    }\n\n    normalizedRange() {\n      const minHour = this.min.getHours();\n      const maxHour = this.max.getHours();\n      return [Math.min(minHour, maxHour), Math.max(minHour, maxHour)];\n    }\n\n  }\n\n  DayPeriodService.ɵfac = function DayPeriodService_Factory(t) {\n    return new (t || DayPeriodService)(i0.ɵɵinject(i1.IntlService));\n  };\n\n  DayPeriodService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DayPeriodService,\n    factory: DayPeriodService.ɵfac\n  });\n  return DayPeriodService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst div = domContainerFactory('div');\nconst ul = domContainerFactory('ul');\nconst li = domContainerFactory('li');\nconst span = domContainerFactory('span');\n\nconst listTitle = () => span('hour', 'k-title k-timeselector-title');\n\nconst listItem = () => li('<span>02</span>', 'k-item');\n\nconst list = () => ul([listItem()], 'k-reset');\n\nconst scrollable = () => div([list()], 'k-time-container k-flex k-content k-calendar-content k-scrollable');\n\nconst timeListWrapper = () => {\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  return div([listTitle(), div([scrollable()], 'k-time-list')], 'k-time-list-wrapper', {\n    left: '-10000px',\n    position: 'absolute'\n  });\n};\n\nconst TIMELIST_WRAPPER = timeListWrapper();\n/**\n * @hidden\n */\n\nlet TimePickerDOMService = /*#__PURE__*/(() => {\n  class TimePickerDOMService {\n    ensureHeights() {\n      if (this.timeListHeight !== undefined) {\n        return;\n      }\n\n      this.calculateHeights();\n    }\n\n    calculateHeights(container) {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const listContainer = container && container.querySelector('.k-time-list-container');\n      const hostContainer = listContainer || document.body;\n      const wrapper = hostContainer.appendChild(TIMELIST_WRAPPER);\n      this.timeListHeight = wrapper.querySelector('.k-scrollable').getBoundingClientRect().height;\n      this.itemHeight = wrapper.querySelector('li').getBoundingClientRect().height;\n      hostContainer.removeChild(wrapper);\n    }\n\n    isActive(element) {\n      if (!isDocumentAvailable() || !element) {\n        return false;\n      }\n\n      return (element.nativeElement || element) === document.activeElement;\n    }\n\n  }\n\n  TimePickerDOMService.ɵfac = function TimePickerDOMService_Factory(t) {\n    return new (t || TimePickerDOMService)();\n  };\n\n  TimePickerDOMService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TimePickerDOMService,\n    factory: TimePickerDOMService.ɵfac\n  });\n  return TimePickerDOMService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/component-selector */\n\n\nconst SNAP_THRESHOLD = 0.05; //% of the item height\n\nconst SCROLL_THRESHOLD = 2; //< 2px threshold\n\nconst nil = () => null;\n\nconst getters = {\n  35: (data, _) => data[data.length - 1],\n  36: (data, _) => data[0],\n  38: (data, index) => data[index - 1],\n  40: (data, index) => data[index + 1]\n};\nconst services = {\n  [TIME_PART.dayperiod]: DayPeriodService,\n  [TIME_PART.hour]: HoursService,\n  [TIME_PART.minute]: MinutesService,\n  [TIME_PART.second]: SecondsService,\n  [TIME_PART.millisecond]: MillisecondsService\n};\n/**\n * @hidden\n */\n\nlet TimeListComponent = /*#__PURE__*/(() => {\n  class TimeListComponent {\n    constructor(element, injector, dom, renderer, zone) {\n      this.element = element;\n      this.injector = injector;\n      this.dom = dom;\n      this.renderer = renderer;\n      this.zone = zone;\n      this.min = cloneDate(MIDNIGHT_DATE);\n      this.max = cloneDate(MAX_TIME);\n      this.step = 1;\n      this.disabled = false;\n      this.valueChange = new EventEmitter();\n      this.componentClass = true;\n      this.animateToIndex = true;\n      this.isActive = false;\n      this.skip = 0;\n      this.total = 60;\n      this.data = [];\n      this.indexToScroll = -1;\n      this.domEvents = [];\n    }\n\n    get tabIndex() {\n      return this.disabled ? undefined : 0;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.part) {\n        this.service = this.injector.get(services[this.part.type]);\n        this.service.configure(this.serviceSettings());\n      }\n\n      const value = this.value;\n      const valueChanges = changes.value || {};\n      const [min, max] = this.service.limitRange(this.min, this.max, value);\n\n      if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {\n        this.data = [];\n        this.service.configure(this.serviceSettings({\n          min,\n          max\n        }));\n      } // Skip the rendering of the list whenever possible\n\n\n      if (!this.data.length || this.hasMissingValue(valueChanges)) {\n        this.animateToIndex = false;\n        this.data = this.service.data(value);\n      }\n\n      this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);\n      this.total = this.service.total(value);\n      this.indexToScroll = this.selectedIndex(value);\n    }\n\n    ngOnInit() {\n      this.animateToIndex = true;\n      this.dom.ensureHeights();\n      this.itemHeight = this.dom.itemHeight;\n      this.listHeight = this.dom.timeListHeight;\n      this.topOffset = (this.listHeight - this.itemHeight) / 2;\n      this.bottomOffset = this.listHeight - this.itemHeight;\n      this.topThreshold = this.itemHeight * SNAP_THRESHOLD;\n      this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);\n      const translate = `translateY(${this.topOffset}px)`;\n      this.style = {\n        transform: translate,\n        '-ms-transform': translate\n      };\n\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this.scrollSubscription.unsubscribe();\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n\n    ngAfterViewInit() {\n      this.scrollOnce(index => this.virtualization.scrollToIndex(index));\n    }\n\n    ngAfterViewChecked() {\n      this.scrollOnce(index => {\n        const action = this.animateToIndex ? 'animateToIndex' : 'scrollToIndex';\n        this.virtualization[action](index);\n        this.animateToIndex = true;\n      });\n    }\n\n    handleChange(dataItem) {\n      const candidate = this.service.apply(this.value, dataItem.value);\n\n      if (this.value.getTime() === candidate.getTime()) {\n        return;\n      }\n\n      this.indexToScroll = this.data.indexOf(dataItem);\n      this.value = candidate;\n      this.valueChange.emit(candidate);\n    }\n\n    handleItemClick(args) {\n      const item = closestInScope(args.target, node => node.hasAttribute('data-timelist-item-index'), this.element.nativeElement);\n\n      if (item) {\n        const index = item.getAttribute('data-timelist-item-index');\n        this.handleChange(this.data[index]);\n      }\n    }\n    /**\n     * Focuses the host element of the TimeList.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timelist.focus()\">Focus TimeList</button>\n     *  <kendo-timelist #timelist></kendo-timelist>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.focus();\n    }\n    /**\n     * Blurs the TimeList component.\n     */\n\n\n    blur() {\n      if (!this.element) {\n        return;\n      }\n\n      this.element.nativeElement.blur();\n    }\n\n    itemOffset(scrollTop) {\n      const valueIndex = this.selectedIndex(this.value);\n      const activeIndex = this.virtualization.activeIndex();\n      const offset = this.virtualization.itemOffset(activeIndex);\n      const distance = Math.abs(Math.ceil(scrollTop) - offset);\n\n      if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {\n        return offset;\n      }\n\n      const scrollUp = valueIndex > activeIndex;\n      const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;\n      return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset;\n    }\n\n    hasMissingValue({\n      previousValue,\n      currentValue\n    }) {\n      const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);\n      const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);\n      return isPreviousMissing || isCurrentMissing;\n    }\n\n    scrollOnce(action) {\n      if (this.indexToScroll !== -1) {\n        action(this.indexToScroll);\n        this.indexToScroll = -1;\n      }\n    }\n\n    serviceSettings(settings) {\n      const defaults = {\n        boundRange: false,\n        insertUndividedMax: false,\n        max: this.max,\n        min: this.min,\n        part: this.part,\n        step: this.step\n      };\n      const result = Object.assign({}, defaults, settings);\n      result.boundRange = result.part.type !== 'hour';\n      return result;\n    }\n\n    selectedIndex(value) {\n      if (!value) {\n        return -1;\n      }\n\n      return this.service.selectedIndex(value);\n    }\n\n    textHasChanged({\n      previousValue,\n      currentValue\n    }) {\n      if (!previousValue || !currentValue) {\n        return false;\n      }\n\n      const oldData = this.data[this.selectedIndex(previousValue)];\n      const newData = this.data[this.selectedIndex(currentValue)];\n      return oldData && newData && oldData.text !== newData.text;\n    }\n\n    handleKeyDown(e) {\n      const getter = getters[e.keyCode] || nil;\n      const dataItem = getter(this.data, this.service.selectedIndex(this.value));\n\n      if (dataItem) {\n        this.handleChange(dataItem);\n        e.preventDefault();\n      }\n    }\n\n    bindEvents() {\n      this.scrollSubscription = this.virtualization.scroll$().pipe(debounceTime(100), map(e => e.target.scrollTop), map(top => this.itemOffset(top)), map(itemOffset => this.virtualization.itemIndex(itemOffset))).subscribe(index => {\n        this.virtualization.scrollToIndex(index);\n        this.handleChange(this.data[index]);\n      });\n      const element = this.element.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'mouseover', () => !this.isActive && this.focus()), this.renderer.listen(element, 'click', () => this.focus()), this.renderer.listen(element, 'blur', () => this.isActive = false), this.renderer.listen(element, 'focus', () => this.isActive = true), this.renderer.listen(element, 'keydown', this.handleKeyDown.bind(this)));\n    }\n\n  }\n\n  TimeListComponent.ɵfac = function TimeListComponent_Factory(t) {\n    return new (t || TimeListComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(TimePickerDOMService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  TimeListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TimeListComponent,\n    selectors: [[\"kendo-timelist\"]],\n    viewQuery: function TimeListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(VirtualizationComponent, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualization = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function TimeListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"k-time-list\", ctx.componentClass);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      part: \"part\",\n      step: \"step\",\n      disabled: \"disabled\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 13,\n    consts: [[\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-time-container\", 3, \"skip\", \"take\", \"total\", \"itemHeight\", \"maxScrollDifference\", \"topOffset\", \"bottomOffset\"], [1, \"k-reset\", 3, \"ngStyle\", \"kendoEventsOutsideAngular\", \"scope\"], [\"class\", \"k-item\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-item\"]],\n    template: function TimeListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"kendo-virtualization\", 0)(1, \"ul\", 1);\n        i0.ɵɵtemplate(2, TimeListComponent_li_2_Template, 3, 2, \"li\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"skip\", ctx.skip)(\"take\", ctx.total)(\"total\", ctx.total)(\"itemHeight\", ctx.itemHeight)(\"maxScrollDifference\", ctx.listHeight)(\"topOffset\", ctx.topOffset)(\"bottomOffset\", ctx.bottomOffset);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngStyle\", ctx.style)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(11, _c1, ctx.handleItemClick))(\"scope\", ctx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    directives: [VirtualizationComponent, i7.NgStyle, i5.EventsOutsideAngularDirective, i7.NgForOf],\n    encapsulation: 2\n  });\n  return TimeListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isEqualTillMinute = (value, min) => value.getHours() === min.getHours() && value.getMinutes() === min.getMinutes();\n\nconst isEqualTillSecond = (value, min) => isEqualTillMinute(value, min) && value.getSeconds() === min.getSeconds();\n\nconst isEqualTillMillisecond = (value, min) => isEqualTillSecond(value, min) && value.getMilliseconds() === min.getMilliseconds();\n\nconst defaultGetters = [{\n  type: TIME_PART.hour,\n  getter: value => value.getHours(),\n  minGetter: (_, min) => min.getHours()\n}, {\n  type: TIME_PART.minute,\n  getter: value => value.getMinutes(),\n  minGetter: (value, min) => isEqualTillMinute(value, min) ? min.getMinutes() : 0\n}, {\n  type: TIME_PART.second,\n  getter: value => value.getSeconds(),\n  minGetter: (value, min) => isEqualTillSecond(value, min) ? min.getSeconds() : 0\n}, {\n  type: TIME_PART.millisecond,\n  getter: value => value.getMilliseconds(),\n  minGetter: (value, min) => isEqualTillMillisecond(value, min) ? min.getMilliseconds() : 0\n}];\n\nconst left = getter => (origin, _) => getter(origin);\n\nconst right = getter => (_, candidate) => getter(candidate);\n\nconst convertToObject = parts => parts.reduce((obj, p) => {\n  obj[p.type] = p.type;\n  return obj;\n}, {});\n\nconst getterByPart = parts => g => parts[g.type] ? right(g.getter) : left(g.getter);\n\nconst gettersFactory = getters => parts => getters.map(getterByPart(convertToObject(parts)));\n\nconst snapValue = (getter, minGetter, step) => (date, min) => {\n  const value = getter(date);\n  const minValue = minGetter(date, min);\n  const rest = value - minValue;\n\n  if (rest < 0) {\n    return minValue;\n  }\n\n  const mod = rest % step;\n  return value - mod + (mod > step / 2 ? step : 0);\n};\n\nconst snappersFactory = getters => steps => getters.map(g => {\n  const step = steps[g.type];\n  return step ? snapValue(g.getter, g.minGetter, step) : g.getter;\n});\n/**\n * @hidden\n */\n\n\nconst generateGetters = gettersFactory(defaultGetters);\n/**\n * @hidden\n */\n\nconst generateSnappers = snappersFactory(defaultGetters);\n/**\n * @hidden\n */\n\nconst valueMerger = getters => (origin, candidate) => {\n  origin.setHours(...getters.map(g => g(origin, candidate)));\n  return origin;\n};\n/**\n * @hidden\n */\n\n\nconst snapTime = snappers => (candidate, min) => {\n  const date = cloneDate(candidate);\n  date.setHours(...snappers.map(s => s(date, min)));\n  return date;\n};\n/**\n * @hidden\n */\n\n\nlet TimePickerMessages = /*#__PURE__*/(() => {\n  class TimePickerMessages extends ComponentMessages {}\n\n  TimePickerMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵTimePickerMessages_BaseFactory;\n    return function TimePickerMessages_Factory(t) {\n      return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = i0.ɵɵgetInheritedFactory(TimePickerMessages)))(t || TimePickerMessages);\n    };\n  }();\n\n  TimePickerMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TimePickerMessages,\n    selectors: [[\"kendo-timepicker-messages-base\"]],\n    inputs: {\n      accept: \"accept\",\n      acceptLabel: \"acceptLabel\",\n      cancel: \"cancel\",\n      cancelLabel: \"cancelLabel\",\n      now: \"now\",\n      nowLabel: \"nowLabel\",\n      toggle: \"toggle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TimePickerMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TimeSelectorLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  TimeSelectorLocalizedMessagesDirective.ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(t) {\n    return new (t || TimeSelectorLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  TimeSelectorLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TimeSelectorLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoTimeSelectorLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimePickerMessages,\n      useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TimeSelectorLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst listReducer = (state, list, idx, all) => {\n  if (state.length || !list.isActive) {\n    return state;\n  }\n\n  return [{\n    next: all[idx + 1] || list,\n    prev: all[idx - 1] || list\n  }];\n};\n\nvar Direction = /*#__PURE__*/(() => {\n  (function (Direction) {\n    Direction[Direction[\"Left\"] = 0] = \"Left\";\n    Direction[Direction[\"Right\"] = 1] = \"Right\";\n  })(Direction || (Direction = {}));\n\n  return Direction;\n})();\n\n/**\n * @hidden\n *\n * Represents the Kendo UI TimeSelector component for Angular.\n */\nlet TimeSelectorComponent = /*#__PURE__*/(() => {\n  class TimeSelectorComponent {\n    constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {\n      this.localization = localization;\n      this.cdr = cdr;\n      this.element = element;\n      this.intl = intl;\n      this.dom = dom;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.pickerService = pickerService;\n      /**\n       * Specifies the time format used to display the time list columns.\n       */\n\n      this.format = 't';\n      /**\n       * Specifies the smallest valid time value.\n       */\n\n      this.min = cloneDate(MIN_TIME);\n      /**\n       * Specifies the biggest valid time value.\n       */\n\n      this.max = cloneDate(MAX_TIME);\n      /**\n       * Determines whether to display the **Cancel** button in the popup.\n       */\n\n      this.cancelButton = true;\n      /**\n       * Determines whether to display the **Set** button in the popup.\n       */\n\n      this.setButton = true;\n      /**\n       * Determines whether to display the **Now** button in the popup.\n       *\n       * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n       */\n\n      this.nowButton = true;\n      /**\n       * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.\n       */\n\n      this.disabled = false;\n      /**\n       * Specifies the value of the TimeSelector component.\n       */\n\n      this.value = null;\n      /**\n       * Fires each time the user selects a new value.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user cancels the selected value.\n       */\n\n      this.valueReject = new EventEmitter();\n      this.isActive = false;\n      this.showNowButton = true;\n      this._activeListIndex = -1;\n      this._steps = {};\n      this.domEvents = [];\n\n      if (this.pickerService) {\n        this.pickerService.timeSelector = this;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * Configures the incremental steps of the TimeSelector.\n     *\n     * The available options are:\n     * - `hour: Number`&mdash;Controls the incremental step of the hour value.\n     * - `minute: Number`&mdash;Controls the incremental step of the minute value.\n     * - `second: Number`&mdash;Controls the incremental step of the second value.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timeselector format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timeselector>\n     * `\n     * })\n     * export class AppComponent {\n     *   public steps = { hour: 2, minute: 15, second: 15 };\n     * }\n     * ```\n     *\n     * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n     */\n\n\n    set steps(steps) {\n      this._steps = steps || {};\n    }\n\n    get steps() {\n      return this._steps;\n    }\n\n    set current(value) {\n      this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);\n\n      if (!NgZone.isInAngularZone()) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    get current() {\n      return this._current;\n    }\n\n    get activeListIndex() {\n      return this._activeListIndex;\n    }\n\n    set activeListIndex(value) {\n      this._activeListIndex = value;\n\n      if (!this.timeListWrappers || !this.timeListWrappers.length) {\n        return;\n      }\n\n      this.timeListWrappers.forEach(listWrapper => {\n        this.renderer.removeClass(listWrapper.nativeElement, 'k-state-focused');\n      });\n\n      if (value >= 0) {\n        const listIndex = this.listIndex(value);\n        const focusedWrapper = this.timeListWrappers.toArray()[listIndex];\n\n        if (focusedWrapper) {\n          this.renderer.addClass(focusedWrapper.nativeElement, 'k-state-focused');\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));\n\n      if (this.localization) {\n        this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));\n      }\n\n      this.renderer.addClass(this.element.nativeElement, 'k-timeselector');\n      this.dom.calculateHeights(this.element.nativeElement);\n      this.init();\n      this.bindEvents();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(_) {\n      this.init();\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        this.subscriptions.unsubscribe();\n      }\n\n      if (this.pickerService) {\n        this.pickerService.timeSelector = null;\n      }\n\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n    }\n    /**\n     * Focuses the TimeSelector component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timeselector.focus()\">Focus time picker</button>\n     *  <kendo-timeselector #timeselector></kendo-timeselector>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      const list = this.timeLists.first;\n\n      if (!list) {\n        return;\n      }\n\n      list.focus();\n    }\n    /**\n     * Blurs the TimeSelector component.\n     */\n\n\n    blur() {\n      const list = this.timeLists.first;\n\n      if (!list) {\n        return;\n      }\n\n      list.blur();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleAccept() {\n      this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNow() {\n      this.current = getNow();\n      this.handleChange(this.current);\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleReject() {\n      this.current = this.value;\n      this.valueReject.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus(args) {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n      this.emitFocus(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleListFocus(args) {\n      const index = parseInt(args.target.getAttribute('data-timelist-index'), 10);\n      this.activeListIndex = index;\n      this.handleFocus(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(args) {\n      const currentTarget = currentFocusTarget(args);\n\n      if (currentTarget && this.containsElement(currentTarget)) {\n        return;\n      }\n\n      this.activeListIndex = -1;\n      this.isActive = false;\n      this.emitBlur(args);\n    }\n    /**\n     * @hidden\n     */\n\n\n    containsElement(element) {\n      return Boolean(closest(element, node => node === this.element.nativeElement));\n    }\n\n    partStep(part) {\n      return this.steps[part.type] || 1;\n    }\n\n    init(changes) {\n      if (!changes || hasChange(changes, 'format')) {\n        this.dateFormatParts = this.intl.splitDateFormat(this.format);\n        this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n      }\n\n      if (!changes || hasChange(changes, 'steps')) {\n        this.snapTime = snapTime(generateSnappers(this.steps));\n      }\n\n      if (!changes || hasChange(changes, 'value')) {\n        this.current = this.value;\n      }\n\n      this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);\n    }\n\n    focusList(dir) {\n      if (!this.timeLists.length) {\n        return;\n      }\n\n      this.timeLists.reduce(listReducer, []).map(state => dir === Direction.Right ? state.next : state.prev).map(list => list && list.focus());\n    }\n\n    handleChange(value) {\n      this.value = value;\n      this.valueChange.emit(cloneDate(value));\n    }\n\n    hasActiveButton() {\n      if (!this.accept) {\n        return false;\n      }\n\n      return [this.accept, this.cancel, this.now].reduce((isActive, el) => isActive || this.dom.isActive(el), false);\n    }\n\n    hasSteps() {\n      const keys = Object.keys(this.steps);\n      return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);\n    }\n\n    intlChange() {\n      this.dateFormatParts = this.intl.splitDateFormat(this.format);\n      this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));\n      this.cdr.markForCheck();\n    }\n\n    bindEvents() {\n      if (this.element) {\n        this.zone.runOutsideAngular(() => {\n          this.domEvents.push(this.renderer.listen(this.element.nativeElement, 'keydown', this.handleKeydown.bind(this)));\n        });\n      }\n    }\n\n    handleKeydown(args) {\n      const {\n        keyCode,\n        altKey\n      } = args; // reserve the alt + arrow key commands for the picker\n\n      const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;\n\n      if (isPresent(this.pickerService) && arrowKeyPressed && altKey) {\n        return;\n      }\n\n      if (keyCode === Keys.Enter && !this.hasActiveButton()) {\n        this.handleAccept();\n      } else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {\n        this.focusList(keyCode === Keys.ArrowLeft ? Direction.Left : Direction.Right);\n      }\n    }\n\n    emitBlur(args) {\n      if (this.pickerService) {\n        this.pickerService.onBlur.emit(args);\n      }\n    }\n\n    emitFocus(args) {\n      if (this.pickerService) {\n        this.pickerService.onFocus.emit(args);\n      }\n    }\n\n    listIndex(partIndex) {\n      let listIdx = 0;\n      let partIdx = 0;\n\n      while (partIdx < partIndex) {\n        if (this.dateFormatParts[partIdx].type !== 'literal') {\n          listIdx++;\n        }\n\n        partIdx++;\n      }\n\n      return listIdx;\n    }\n\n  }\n\n  TimeSelectorComponent.ɵfac = function TimeSelectorComponent_Factory(t) {\n    return new (t || TimeSelectorComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(TimePickerDOMService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PickerService, 8));\n  };\n\n  TimeSelectorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TimeSelectorComponent,\n    selectors: [[\"kendo-timeselector\"]],\n    viewQuery: function TimeSelectorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c42, 5);\n        i0.ɵɵviewQuery(_c43, 5);\n        i0.ɵɵviewQuery(_c44, 5);\n        i0.ɵɵviewQuery(TimeListComponent, 5);\n        i0.ɵɵviewQuery(_c45, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.accept = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancel = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.now = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timeLists = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timeListWrappers = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      format: \"format\",\n      min: \"min\",\n      max: \"max\",\n      cancelButton: \"cancelButton\",\n      setButton: \"setButton\",\n      nowButton: \"nowButton\",\n      disabled: \"disabled\",\n      steps: \"steps\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      valueReject: \"valueReject\"\n    },\n    exportAs: [\"kendo-timeselector\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.timeselector'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 4,\n    consts: function () {\n      let i18n_46;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Accept button text in the timeselector component\n         * @meaning kendo.timeselector.accept\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_47 = goog.getMsg(\"Set\");\n        i18n_46 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_47;\n      } else {\n        i18n_46 = $localize`:kendo.timeselector.accept|The Accept button text in the timeselector component:Set`;\n      }\n\n      let i18n_48;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Accept button in the timeselector component\n         * @meaning kendo.timeselector.acceptLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_49 = goog.getMsg(\"Set time\");\n        i18n_48 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_49;\n      } else {\n        i18n_48 = $localize`:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component:Set time`;\n      }\n\n      let i18n_50;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Cancel button text in the timeselector component\n         * @meaning kendo.timeselector.cancel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_51 = goog.getMsg(\"Cancel\");\n        i18n_50 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_51;\n      } else {\n        i18n_50 = $localize`:kendo.timeselector.cancel|The Cancel button text in the timeselector component:Cancel`;\n      }\n\n      let i18n_52;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Cancel button in the timeselector component\n         * @meaning kendo.timeselector.cancelLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_53 = goog.getMsg(\"Cancel changes\");\n        i18n_52 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_53;\n      } else {\n        i18n_52 = $localize`:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component:Cancel changes`;\n      }\n\n      let i18n_54;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Now button text in the timeselector component\n         * @meaning kendo.timeselector.now\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_55 = goog.getMsg(\"Now\");\n        i18n_54 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_55;\n      } else {\n        i18n_54 = $localize`:kendo.timeselector.now|The Now button text in the timeselector component:Now`;\n      }\n\n      let i18n_56;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Now button in the timeselector component\n         * @meaning kendo.timeselector.nowLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_57 = goog.getMsg(\"Select now\");\n        i18n_56 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_57;\n      } else {\n        i18n_56 = $localize`:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component:Select now`;\n      }\n\n      return [[\"kendoTimeSelectorLocalizedMessages\", \"\", \"accept\", i18n_46, \"acceptLabel\", i18n_48, \"cancel\", i18n_50, \"cancelLabel\", i18n_52, \"now\", i18n_54, \"nowLabel\", i18n_56], [1, \"k-time-header\"], [1, \"k-title\", \"k-timeselector-title\"], [\"type\", \"button\", \"class\", \"k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-time-now\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [1, \"k-time-list-container\"], [1, \"k-time-highlight\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"k-time-footer k-action-buttons k-actions k-hstack k-justify-content-stretch\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-button-md\", \"k-rounded-md\", \"k-button-flat\", \"k-button-flat-base\", \"k-time-now\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"now\", \"\"], [\"class\", \"k-time-list-wrapper\", \"role\", \"presentation\", \"tabindex\", \"-1\", 4, \"ngIf\"], [\"class\", \"k-time-separator\", 4, \"ngIf\"], [\"role\", \"presentation\", \"tabindex\", \"-1\", 1, \"k-time-list-wrapper\"], [\"listWrapper\", \"\"], [3, \"min\", \"max\", \"part\", \"step\", \"disabled\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"valueChange\"], [1, \"k-time-separator\"], [1, \"k-time-footer\", \"k-action-buttons\", \"k-actions\", \"k-hstack\", \"k-justify-content-stretch\"], [\"class\", \"k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base\", \"type\", \"button\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [\"type\", \"button\", \"class\", \"k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-cancel\", \"k-button-md\", \"k-rounded-md\", \"k-button-solid\", \"k-button-solid-base\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"cancel\", \"\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-accept\", \"k-button-md\", \"k-rounded-md\", \"k-button-solid\", \"k-button-solid-primary\", 3, \"kendoEventsOutsideAngular\", \"scope\", \"disabled\"], [\"accept\", \"\"]];\n    },\n    template: function TimeSelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"span\", 2);\n        i0.ɵɵtext(3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, TimeSelectorComponent_button_4_Template, 3, 10, \"button\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"div\", 4);\n        i0.ɵɵelement(6, \"span\", 5);\n        i0.ɵɵtemplate(7, TimeSelectorComponent_ng_template_7_Template, 2, 2, \"ng-template\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, TimeSelectorComponent_div_8_Template, 3, 2, \"div\", 7);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate1(\" \", ctx.intl.formatDate(ctx.current, ctx.format), \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showNowButton);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.dateFormatParts);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.setButton || ctx.cancelButton);\n      }\n    },\n    directives: [TimeListComponent, TimeSelectorLocalizedMessagesDirective, i7.NgIf, i5.EventsOutsideAngularDirective, i7.NgForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return TimeSelectorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * Custom component messages override default component messages.\n */\n\n\nlet TimeSelectorCustomMessagesComponent = /*#__PURE__*/(() => {\n  class TimeSelectorCustomMessagesComponent extends TimePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  TimeSelectorCustomMessagesComponent.ɵfac = function TimeSelectorCustomMessagesComponent_Factory(t) {\n    return new (t || TimeSelectorCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  TimeSelectorCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TimeSelectorCustomMessagesComponent,\n    selectors: [[\"kendo-timeselector-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimePickerMessages,\n      useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TimeSelectorCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TimePickerLocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class TimePickerLocalizedMessagesDirective extends TimePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  TimePickerLocalizedMessagesDirective.ɵfac = function TimePickerLocalizedMessagesDirective_Factory(t) {\n    return new (t || TimePickerLocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  TimePickerLocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TimePickerLocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoTimePickerLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimePickerMessages,\n      useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TimePickerLocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst VALUE_DOC_LINK$1 = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json';\nconst INTL_DATE_FORMAT = 'https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md';\nconst formatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);\n/**\n * Represents the [Kendo UI TimePicker component for Angular]({% slug overview_timepicker %}#toc-basic-usage).\n */\n\nlet TimePickerComponent = /*#__PURE__*/(() => {\n  class TimePickerComponent {\n    constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, intl, touchEnabled) {\n      this.zone = zone;\n      this.localization = localization;\n      this.cdr = cdr;\n      this.popupService = popupService;\n      this.wrapper = wrapper;\n      this.renderer = renderer;\n      this.injector = injector;\n      this.pickerService = pickerService;\n      this.intl = intl;\n      this.touchEnabled = touchEnabled;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Sets or gets the `disabled` property of the TimePicker and\n       * determines whether the component is active\n       * ([see example]({% slug disabled_timepicker %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the TimePicker\n       * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the read-only state of the TimePicker input field\n       * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).\n       *\n       * > Note that if you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,\n       * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n       */\n\n      this.readOnlyInput = false;\n      /**\n       * Specifies the time format that is used to display the input value\n       * ([see example]({% slug formats_timepicker %})).\n       */\n\n      this.format = 't';\n      /**\n       * Specifies the hint the TimePicker displays when its value is `null`.\n       * For more information, refer to the article on\n       * [placeholders]({% slug placeholders_timepicker %}).\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-timepicker placeholder=\"Enter start...\"></kendo-timepicker>\n       * `\n       * })\n       * export class AppComponent { }\n       * ```\n       */\n\n      this.placeholder = null;\n      /**\n       * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n       */\n\n      this.incompleteDateValidation = false;\n      /**\n       * Determines whether to display the **Cancel** button in the popup.\n       */\n\n      this.cancelButton = true;\n      /**\n       * Determines whether to display the **Now** button in the popup.\n       *\n       * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.\n       */\n\n      this.nowButton = true;\n      /**\n       * Sets or gets the `tabindex` property of the TimePicker.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Sets the title of the input element of the TimePicker.\n       */\n\n      this.title = \"\";\n      /**\n       * Determines whether the built-in min or max validators are enforced when a form is being validated.\n       */\n\n      this.rangeValidation = true;\n      /**\n       * Fires each time the user selects a new value.\n       * For more information, refer to the section on\n       * [events]({% slug overview_timepicker %}#toc-events).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user focuses the input element.\n       * For more information, refer to the section on\n       * [events]({% slug overview_timepicker %}#toc-events).\n       *\n       * > To wire the event programmatically, use the `onFocus` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-timepicker (focus)=\"handleFocus()\"></kendo-timepicker>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleFocus(): void {\n       *      console.log(\"Component is focused\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the input element gets blurred.\n       * For more information, refer to the section on\n       * [events]({% slug overview_timepicker %}#toc-events).\n       *\n       * > To wire the event programmatically, use the `onBlur` property.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <kendo-timepicker (blur)=\"handleBlur()\"></kendo-timepicker>\n       * `\n       * })\n       * export class AppComponent {\n       *   public handleBlur(): void {\n       *      console.log(\"Component is blurred\");\n       *   }\n       * }\n       * ```\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       * For more information, refer to the section on\n       * [events]({% slug overview_timepicker %}#toc-events).\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       * For more information, refer to the section on\n       * [events]({% slug overview_timepicker %}#toc-events).\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.wrapperClasses = true;\n      this.popupUID = guid();\n      this.onControlChange = noop$2;\n      this.onControlTouched = noop$2;\n      this.onValidatorChange = noop$2;\n      this.resolvedPromise = Promise.resolve(null);\n      this.timeRangeValidateFn = noop$2;\n      this.incompleteValidator = noop$2;\n      this._min = cloneDate(MIN_TIME);\n      this._max = cloneDate(MAX_TIME);\n      this._popupSettings = {\n        animate: true\n      };\n      this._show = false;\n      this._steps = {};\n      this._value = null;\n      this._active = false;\n      this.domEvents = [];\n      this._size = DEFAULT_SIZE;\n      this._rounded = DEFAULT_ROUNDED;\n      this._fillMode = DEFAULT_FILL_MODE;\n      validatePackage(packageMetadata);\n      this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));\n      this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n      this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n    }\n    /**\n     * Specifies the smallest valid time value\n     * ([see example]({% slug timeranges_timepicker %})).\n     */\n\n\n    set min(min) {\n      this._min = cloneDate(min || MIN_TIME);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Specifies the biggest valid time value\n     * ([see example]({% slug timeranges_timepicker %})).\n     */\n\n\n    set max(max) {\n      this._max = cloneDate(max || MAX_TIME);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Configures the incremental steps of the TimePicker.\n     * For more information, refer to the article on\n     * [incremental steps]({% slug incrementalsteps_timepicker %}).\n     *\n     * > If the incremental step is greater than `1`, the **Now** button will be hidden.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <kendo-timepicker format=\"HH:mm:ss\" [steps]=\"steps\"></kendo-timepicker>\n     * `\n     * })\n     * class AppComponent {\n     *   public steps = { hour: 2, minute: 15, second: 15, millisecond: 10 };\n     * }\n     * ```\n     *\n     */\n\n\n    set steps(steps) {\n      this._steps = steps || {};\n    }\n\n    get steps() {\n      return this._steps;\n    }\n    /**\n     * Configures the popup of the TimePicker.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, {\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Specifies the value of the TimePicker component.\n     */\n\n\n    set value(value) {\n      this.verifyValue(value);\n      this._value = cloneDate(value);\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));\n      const newSize = size ? size : DEFAULT_SIZE;\n\n      if (newSize !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n\n      if (newRounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `flat`\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n\n      if (newFillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', newFillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get inputRole() {\n      return this.readOnlyInput ? 'listbox' : 'spinbutton';\n    }\n\n    get isActive() {\n      return this._active;\n    }\n\n    set isActive(value) {\n      this._active = value;\n\n      if (!this.wrapper) {\n        return;\n      }\n\n      const element = this.wrapper.nativeElement;\n\n      if (value) {\n        this.renderer.addClass(element, 'k-focus');\n      } else {\n        this.renderer.removeClass(element, 'k-focus');\n      }\n    }\n\n    get show() {\n      return this._show;\n    }\n\n    set show(show) {\n      if (show && (this.disabled || this.readonly)) {\n        return;\n      }\n\n      const skipZone = !show && (!this._show || !hasObservers(this.close));\n\n      if (!skipZone) {\n        this.zone.run(() => {\n          this.togglePopup(show);\n        });\n      } else {\n        this.togglePopup(show);\n      }\n    }\n\n    get input() {\n      return this.pickerService.input;\n    }\n\n    get timeSelector() {\n      return this.pickerService.timeSelector;\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty\n     */\n\n\n    isEmpty() {\n      return !this.value && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());\n      this.control = this.injector.get(NgControl, null);\n\n      if (this.wrapper) {\n        this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n        this.zone.runOutsideAngular(() => {\n          this.bindEvents();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {\n        this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop$2;\n        this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;\n        this.onValidatorChange();\n      }\n\n      if (changes.format) {\n        this.verifyFormat();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.isActive = false;\n      this.show = false;\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      if (this.windowBlurSubscription) {\n        this.windowBlurSubscription.unsubscribe();\n      }\n\n      this.domEvents.forEach(unbindCallback => unbindCallback());\n      this.pickerSubscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeydown(event) {\n      const {\n        altKey,\n        keyCode\n      } = event;\n\n      if (keyCode === Keys.Escape) {\n        this.show = false;\n        return;\n      }\n\n      if (altKey) {\n        if (keyCode === Keys.ArrowUp) {\n          this.show = false;\n        }\n\n        if (keyCode === Keys.ArrowDown && !this.show) {\n          this.show = true;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.verifyValue(value);\n      this.value = cloneDate(value);\n      this.cdr.markForCheck();\n\n      if (!value && this.input) {\n        this.input.placeholder = this.placeholder;\n        this.input.writeValue(value);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * Focuses the TimePicker component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"timepicker.focus()\">Focus time picker</button>\n     *  <kendo-timepicker #timepicker></kendo-timepicker>\n     * `\n     * })\n     * export class AppComponent { }\n     * ```\n     */\n\n\n    focus() {\n      this.input.focus();\n    }\n    /**\n     * Blurs the TimePicker component.\n     */\n\n\n    blur() {\n      (this.timeSelector || this.input)['blur']();\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show - The state of the popup.\n     */\n\n\n    toggle(show) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.resolvedPromise.then(() => {\n        this._toggle(show === undefined ? !this.show : show);\n      });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this.show;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleChange(value) {\n      if (isEqual(this.value, value)) {\n        this.focusInput();\n        this.show = false;\n        return;\n      }\n\n      this.value = cloneDate(value);\n      this.zone.run(() => {\n        this.focusInput();\n        this.show = false;\n        this.onControlChange(cloneDate(value));\n        this.valueChange.emit(cloneDate(value));\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleReject() {\n      this.show = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleInputChange(value) {\n      const val = this.input.formatSections.date ? value : this.mergeTime(value);\n      this.handleChange(val);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleMousedown(args) {\n      args.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleIconClick(event) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      event.preventDefault();\n      this.focusInput(); //XXX: explicit call handleFocus handler here\n      //due to async IE focus event\n\n      this.handleFocus();\n      this.show = !this.show;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get popupClasses() {\n      return ['k-group', 'k-reset'].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n\n\n    normalizeTime(date) {\n      return setTime(MIDNIGHT_DATE, date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    mergeTime(value) {\n      return this.value && value ? setTime(this.value, value) : value;\n    }\n\n    togglePopup(show) {\n      const event = new PreventableEvent();\n\n      if (!this._show && show) {\n        this.open.emit(event);\n      } else if (this._show && !show) {\n        this.close.emit(event);\n      }\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      this._toggle(show);\n\n      this.toggleFocus();\n    }\n\n    _toggle(show) {\n      if (show === this.isOpen) {\n        return;\n      }\n\n      this._show = show;\n      this.cdr.markForCheck();\n\n      if (show) {\n        const direction = this.localization.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: this.wrapper,\n          anchorAlign: {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          animate: this.popupSettings.animate,\n          appendTo: this.appendTo,\n          content: this.popupTemplate,\n          popupAlign: {\n            vertical: 'top',\n            horizontal: direction\n          },\n          popupClass: this.popupClasses,\n          positionMode: 'absolute'\n        });\n        this.popupRef.popupElement.setAttribute('id', this.popupUID);\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);\n      } else {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    focusInput() {\n      if (this.touchEnabled) {\n        return;\n      }\n\n      this.input.focus();\n    }\n\n    toggleFocus() {\n      if (!this.isActive) {\n        return;\n      }\n\n      if (this.show) {\n        if (!this.timeSelector) {\n          this.cdr.detectChanges();\n        }\n\n        if (this.isActive) {\n          this.timeSelector.focus();\n        }\n      } else if (!this.touchEnabled) {\n        this.input.focus();\n      } else if (!this.input.isActive) {\n        this.handleBlur();\n      }\n    }\n\n    verifyValue(value) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (value && !(value instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$1} for possible resolution.`);\n      }\n    }\n\n    verifyFormat() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      const formatContainsDateParts = this.intl.splitDateFormat(this.format).some(part => !formatRegExp.test(part.type));\n\n      if (formatContainsDateParts) {\n        throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);\n      }\n    }\n\n    bindEvents() {\n      const element = this.wrapper.nativeElement;\n      this.domEvents.push(this.renderer.listen(element, 'keydown', this.handleKeydown.bind(this)));\n\n      if (isWindowAvailable()) {\n        this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this));\n      }\n    }\n\n    handleWindowBlur() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.show = false;\n    }\n\n    handleFocus() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n\n      if (hasObservers(this.onFocus)) {\n        this.zone.run(() => {\n          this.onFocus.emit();\n        });\n      }\n    }\n\n    handleBlur(args) {\n      const currentTarget = args && currentFocusTarget(args);\n\n      if (currentTarget && (this.input.containsElement(currentTarget) || this.timeSelector && this.timeSelector.containsElement(currentTarget))) {\n        return;\n      }\n\n      if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {\n        this.zone.run(() => {\n          this.blurComponent();\n          this.cdr.markForCheck();\n        });\n      } else {\n        this.blurComponent();\n      }\n    }\n\n    blurComponent() {\n      this.isActive = false; // order is important ¯\\_(ツ)_/¯\n\n      this.show = false;\n      this.onControlTouched();\n      this.onBlur.emit();\n    }\n\n    handleDateCompletenessChange() {\n      this.cdr.markForCheck();\n      this.zone.run(() => this.onValidatorChange());\n    }\n\n    setComponentClasses() {\n      if (this.size) {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));\n      }\n\n      if (this.rounded) {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode) {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      }\n    }\n\n  }\n\n  TimePickerComponent.ɵfac = function TimePickerComponent_Factory(t) {\n    return new (t || TimePickerComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(PickerService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  TimePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TimePickerComponent,\n    selectors: [[\"kendo-timepicker\"]],\n    viewQuery: function TimePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c29, 5, ViewContainerRef);\n        i0.ɵɵviewQuery(_c30, 5);\n        i0.ɵɵviewQuery(_c31, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function TimePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-timepicker\", ctx.wrapperClasses)(\"k-input\", ctx.wrapperClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      readOnlyInput: \"readOnlyInput\",\n      format: \"format\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      min: \"min\",\n      max: \"max\",\n      incompleteDateValidation: \"incompleteDateValidation\",\n      cancelButton: \"cancelButton\",\n      nowButton: \"nowButton\",\n      steps: \"steps\",\n      popupSettings: \"popupSettings\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      title: \"title\",\n      rangeValidation: \"rangeValidation\",\n      value: \"value\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendo-timepicker\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TimePickerComponent),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => TimePickerComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => TimePickerComponent)\n    }, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.timepicker'\n    }, PickerService]), i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 27,\n    consts: function () {\n      let i18n_60;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Accept button text in the timepicker component\n         * @meaning kendo.timepicker.accept\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_61 = goog.getMsg(\"Set\");\n        i18n_60 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_61;\n      } else {\n        i18n_60 = $localize`:kendo.timepicker.accept|The Accept button text in the timepicker component:Set`;\n      }\n\n      let i18n_62;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Accept button in the timepicker component\n         * @meaning kendo.timepicker.acceptLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_63 = goog.getMsg(\"Set time\");\n        i18n_62 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_63;\n      } else {\n        i18n_62 = $localize`:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component:Set time`;\n      }\n\n      let i18n_64;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Cancel button text in the timepicker component\n         * @meaning kendo.timepicker.cancel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_65 = goog.getMsg(\"Cancel\");\n        i18n_64 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_65;\n      } else {\n        i18n_64 = $localize`:kendo.timepicker.cancel|The Cancel button text in the timepicker component:Cancel`;\n      }\n\n      let i18n_66;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Cancel button in the timepicker component\n         * @meaning kendo.timepicker.cancelLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_67 = goog.getMsg(\"Cancel changes\");\n        i18n_66 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_67;\n      } else {\n        i18n_66 = $localize`:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;\n      }\n\n      let i18n_68;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Now button text in the timepicker component\n         * @meaning kendo.timepicker.now\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_69 = goog.getMsg(\"Now\");\n        i18n_68 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_69;\n      } else {\n        i18n_68 = $localize`:kendo.timepicker.now|The Now button text in the timepicker component:Now`;\n      }\n\n      let i18n_70;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Now button in the timepicker component\n         * @meaning kendo.timepicker.nowLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_71 = goog.getMsg(\"Select now\");\n        i18n_70 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_71;\n      } else {\n        i18n_70 = $localize`:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;\n      }\n\n      let i18n_72;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the toggle button in the timepicker component\n         * @meaning kendo.timepicker.toggle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_73 = goog.getMsg(\"Toggle time list\");\n        i18n_72 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_73;\n      } else {\n        i18n_72 = $localize`:kendo.timepicker.toggle|The label for the toggle button in the timepicker component:Toggle time list`;\n      }\n\n      return [[\"kendoTimePickerLocalizedMessages\", \"\", \"accept\", i18n_60, \"acceptLabel\", i18n_62, \"cancel\", i18n_64, \"cancelLabel\", i18n_66, \"now\", i18n_68, \"nowLabel\", i18n_70, \"toggle\", i18n_72], [3, \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"disabled\", \"readonly\", \"role\", \"ariaReadOnly\", \"format\", \"formatPlaceholder\", \"placeholder\", \"min\", \"max\", \"incompleteDateValidation\", \"fillMode\", \"rounded\", \"size\", \"steps\", \"tabindex\", \"title\", \"value\", \"valueChange\"], [\"input\", \"\"], [\"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"toggleButton\", \"\"], [1, \"k-button-icon\", \"k-icon\", \"k-i-clock\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"cancelButton\", \"nowButton\", \"format\", \"min\", \"max\", \"steps\", \"value\", \"kendoEventsOutsideAngular\", \"scope\", \"valueChange\", \"valueReject\"], [\"timeSelector\", \"\"], [3, \"acceptLabel\", \"accept\", \"cancelLabel\", \"cancel\", \"nowLabel\", \"now\"]];\n    },\n    template: function TimePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-dateinput\", 1, 2);\n        i0.ɵɵlistener(\"valueChange\", function TimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {\n          return ctx.handleInputChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"button\", 3, 4);\n        i0.ɵɵelement(5, \"span\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, TimePickerComponent_ng_template_6_Template, 3, 18, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(8, null, 7);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.show)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"role\", ctx.inputRole)(\"ariaReadOnly\", ctx.readonly)(\"format\", ctx.format)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"min\", ctx.normalizeTime(ctx.min))(\"max\", ctx.normalizeTime(ctx.max))(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"fillMode\", ctx.fillMode)(\"rounded\", ctx.rounded)(\"size\", ctx.size)(\"steps\", ctx.steps)(\"tabindex\", !ctx.show ? ctx.tabindex : -1)(\"title\", ctx.title)(\"value\", ctx.value);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(24, _c41, ctx.handleIconClick, ctx.handleMousedown))(\"scope\", ctx);\n        i0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n      }\n    },\n    directives: [DateInputComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent, TimePickerLocalizedMessagesDirective, i5.EventsOutsideAngularDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return TimePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n\n  Messages.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = i0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n\n  Messages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages,\n    selectors: [[\"kendo-datetimepicker-messages-base\"]],\n    inputs: {\n      toggle: \"toggle\",\n      dateTab: \"dateTab\",\n      dateTabLabel: \"dateTabLabel\",\n      timeTab: \"timeTab\",\n      timeTabLabel: \"timeTabLabel\",\n      accept: \"accept\",\n      acceptLabel: \"acceptLabel\",\n      cancel: \"cancel\",\n      cancelLabel: \"cancelLabel\",\n      today: \"today\",\n      now: \"now\",\n      nowLabel: \"nowLabel\",\n      prevButtonTitle: \"prevButtonTitle\",\n      nextButtonTitle: \"nextButtonTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n    return new (t || LocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  LocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoDateTimePickerLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => LocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);\nconst VALUE_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/';\nconst MIN_MAX_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/';\nconst DEFAULT_ACTIVE_TAB = 'date';\nconst DEFAULT_DATEINPUT_FORMAT = 'g';\nconst DEFAULT_TIMESELECTOR_FORMAT = 't';\nconst TWO_DIGIT_YEAR_MAX = 68;\n/**\n * Represents the [Kendo UI DateTimePicker component for Angular]({% slug overview_datetimepicker %}).\n */\n\nlet DateTimePickerComponent = /*#__PURE__*/(() => {\n  class DateTimePickerComponent {\n    constructor(popupService, intl, cdr, pickerService, ngZone, wrapper, touchEnabled, localization, disabledDatesService, renderer) {\n      this.popupService = popupService;\n      this.intl = intl;\n      this.cdr = cdr;\n      this.pickerService = pickerService;\n      this.ngZone = ngZone;\n      this.wrapper = wrapper;\n      this.touchEnabled = touchEnabled;\n      this.localization = localization;\n      this.disabledDatesService = disabledDatesService;\n      this.renderer = renderer;\n      /**\n       * @hidden\n       */\n\n      this.hostClasses = true;\n      /**\n       * The maximum year to assume to be from the current century when typing two-digit year value\n       * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).\n       *\n       * The default value is 68, indicating that typing any value less than 69\n       * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.\n       */\n\n      this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Sets the title of the input element of the DateTimePicker.\n       */\n\n      this.title = '';\n      /**\n       * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active\n       * ([see example]({% slug disabled_datetimepicker %})).\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the DateTimePicker\n       * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).\n       */\n\n      this.readonly = false;\n      /**\n       * Sets the read-only state of the DateTimePicker input field\n       * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).\n       *\n       * > Note that if you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,\n       * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.\n       */\n\n      this.readOnlyInput = false;\n      /**\n       * Determines whether to display the **Cancel** button in the popup\n       * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).\n       */\n\n      this.cancelButton = true;\n      /**\n       * Configures the incremental steps of the DateInput and the popup component of the TimePicker\n       * ([see example]({% slug incrementalsteps_datetimepicker %})).\n       */\n\n      this.steps = {};\n      /**\n       * Specifies the Calendar type.\n       *\n       * The possible values are:\n       * - `infinite` (default)\n       * - `classic`\n       *\n       */\n\n      this.calendarType = 'infinite';\n      /**\n       * Determines whether to enable animation when navigating to previous/next Calendar view.\n       * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.\n       *\n       * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.\n       *\n       * @default false\n       */\n\n      this.animateCalendarNavigation = false;\n      /**\n       * Determines whether to display a week number column in the `month` view of the popup Calendar\n       * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).\n       */\n\n      this.weekNumber = false;\n      /**\n       * Determines whether the built-in min or max validators are enforced when validating a form\n       * ([see example]({% slug dateranges_datetimepicker %}#toc-prevent-invalid-input)).\n       */\n\n      this.rangeValidation = true;\n      /**\n       * Determines whether the built-in validator for disabled\n       * date ranges is enforced when validating a form\n       * ([see example]({% slug disabled_dates_datetimepicker %}#toc-validation)).\n       */\n\n      this.disabledDatesValidation = true;\n      /**\n       * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.\n       */\n\n      this.incompleteDateValidation = false;\n      /**\n       * Fires each time the user selects a new value.\n       * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.\n       * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.\n       * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires each time the user focuses the component.\n       * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the user blurs the component.\n       * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * @hidden\n       *\n       * Controls whether the Calendar or the TimeSelector will be displayed.\n       */\n\n      this.activeTab = DEFAULT_ACTIVE_TAB;\n      /**\n       * @hidden\n       *\n       * Specifies the stripped time-related format that is used in the TimeSelector.\n       * Updates each time the `format` property value changes.\n       */\n\n      this.timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;\n      /**\n       * @hidden\n       */\n\n      this.timeSelectorMin = cloneDate(MIN_TIME);\n      /**\n       * @hidden\n       */\n\n      this.timeSelectorMax = cloneDate(MAX_TIME);\n      /**\n       * @hidden\n       */\n\n      this.calendarValue = null;\n      /**\n       * @hidden\n       */\n\n      this.calendarMin = cloneDate(MIN_DATE);\n      /**\n       * @hidden\n       */\n\n      this.calendarMax = lastMillisecondOfDate(MAX_DATE);\n      this._popupSettings = {\n        animate: true\n      };\n      this._value = null;\n      this._format = DEFAULT_DATEINPUT_FORMAT;\n      this._tabindex = 0;\n      this._defaultTab = DEFAULT_ACTIVE_TAB;\n      this._min = mergeDateAndTime(MIN_DATE, MIN_TIME);\n      this._max = mergeDateAndTime(MAX_DATE, MAX_TIME);\n      this._isActive = false;\n      this.onControlTouched = noop$2;\n      this.onControlChange = noop$2;\n      this.onValidatorChange = noop$2;\n      this.minValidateFn = noop$2;\n      this.maxValidateFn = noop$2;\n      this.disabledDatesValidateFn = noop$2;\n      this.incompleteValidator = noop$2;\n      this.subscriptions = new Subscription();\n      this._size = DEFAULT_SIZE;\n      this._rounded = DEFAULT_ROUNDED;\n      this._fillMode = DEFAULT_FILL_MODE;\n      validatePackage(packageMetadata);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get input() {\n      return this.pickerService.input;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get calendar() {\n      return this.pickerService.calendar;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get timeSelector() {\n      return this.pickerService.timeSelector;\n    }\n    /**\n     * Specifies the value of the DateTimePicker component.\n     *\n     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     */\n\n\n    set value(value) {\n      this.verifyValue(value);\n      this._value = cloneDate(value);\n      this.setCalendarValue(value);\n      this.cdr.markForCheck();\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the date format for displaying the input value\n     * ([see example]({% slug formats_datetimepicker %}))\n     *\n     * Format value options:\n     * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.\n     * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.\n     *\n     * > If a [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) object is provided, the `displayFormat` value will be used for the popup TimePicker.\n     */\n\n\n    set format(format) {\n      this._format = format;\n      const displayFormat = this.getDisplayFormat(format);\n      this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);\n    }\n\n    get format() {\n      return this._format;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.\n     */\n\n\n    set tabindex(value) {\n      const tabindex = Number(value);\n      const defaultValue = 0;\n      this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;\n    }\n\n    get tabindex() {\n      return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the dates of the DateTimePicker that will be disabled\n     * ([see example]({% slug disabled_dates_datetimepicker %})).\n     */\n\n\n    set disabledDates(value) {\n      this._disabledDates = value;\n      this.disabledDatesService.initialize(value);\n    }\n\n    get disabledDates() {\n      return this._disabledDates;\n    }\n    /**\n     * Configures the popup settings of the DateTimePicker\n     * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, {\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Specifies the smallest valid date.\n     * The Calendar will not display dates before this value.\n     * If the `min` value of the Calendar is selected, the TimePicker will not display\n     * time entries before the specified time portion of this value\n     * ([see example]({% slug dateranges_datetimepicker %})).\n     */\n\n\n    set min(value) {\n      if (!isPresent(value)) {\n        return;\n      }\n\n      this._min = cloneDate(value);\n      this.calendarMin = getDate(value);\n    }\n\n    get min() {\n      return this._min;\n    }\n    /**\n     * Specifies the biggest valid date.\n     * The Calendar will not display dates after this value.\n     * If the `max` value of the Calendar is selected, the TimePicker will not display\n     * time entries after the specified time portion of this value\n     * ([see example]({% slug dateranges_datetimepicker %})).\n     */\n\n\n    set max(value) {\n      if (!isPresent(value)) {\n        return;\n      }\n\n      this._max = cloneDate(value);\n      this.calendarMax = lastMillisecondOfDate(value);\n    }\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Indicates whether the component is currently open.\n     */\n\n\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n    /**\n     * Indicates whether the component or its popup content is focused.\n     */\n\n\n    get isActive() {\n      return this._isActive;\n    }\n\n    set isActive(value) {\n      if (value) {\n        this.renderer.addClass(this.wrapper.nativeElement, 'k-focus');\n      } else {\n        this.renderer.removeClass(this.wrapper.nativeElement, 'k-focus');\n      }\n\n      this._isActive = value;\n    }\n    /**\n     * Sets the active tab on opening the popup\n     * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).\n     */\n\n\n    set defaultTab(tab) {\n      this._defaultTab = tab || DEFAULT_ACTIVE_TAB;\n      this.activeTab = this.defaultTab;\n    }\n\n    get defaultTab() {\n      return this._defaultTab;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass('input', this.size));\n      const newSize = size ? size : DEFAULT_SIZE;\n\n      if (newSize !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (Default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n\n      if (newRounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `solid` (Default)\n     * * `flat`\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n      this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n\n      if (newFillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', newFillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tabSwitchTransition() {\n      /*\n       When the popup is opening, disables the set transition in the themes. When `defaultTab` is set to `time`,\n       the popup opens with an active **Time** tab and the animation of the initial transition is undesired.\n       Setting the inline transition style to `none` overrides the set animation in the themes.\n       Setting the inline transition style to `null` does not apply any inline styles or override the themes CSS.\n      */\n      return this.isOpen ? null : 'none';\n    }\n    /**\n     * @hidden\n     *\n     * Indicates whether the Calendar will be disabled.\n     * The inactive tab component gets disabled and becomes inaccessible on tab click.\n     */\n\n\n    get disableCalendar() {\n      return this.activeTab !== 'date' && !this.calendar.isActive;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get inputRole() {\n      return this.readOnlyInput ? 'listbox' : 'spinbutton';\n    }\n    /**\n     * @hidden\n     *\n     * Indicates whether the TimeSelector will be disabled.\n     * The inactive tab component gets disabled and becomes inaccessible on tab click.\n     */\n\n\n    get disableTimeSelector() {\n      return this.activeTab !== 'time' && !this.timeSelector.isActive;\n    }\n\n    get activeTabComponent() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      if (!(isPresent(this.calendar) || isPresent(this.timeSelector))) {\n        this.cdr.detectChanges();\n      }\n\n      return this.activeTab === 'date' ? this.calendar : this.timeSelector;\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!isPresent(appendTo) || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.pickerService.onFocus // detect popup changes to disable the inactive view mark-up when the popup is open\n      .pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)));\n      this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));\n      this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));\n      this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));\n      this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));\n\n      if (isWindowAvailable()) {\n        this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, 'blur').subscribe(this.handleCancel.bind(this))));\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setComponentClasses();\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.min) || isPresent(changes.max)) {\n        this.verifyMinMaxRange();\n      }\n\n      if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {\n        this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;\n        this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;\n        this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;\n        this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;\n        this.onValidatorChange();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.isOpen) {\n        this.closePopup();\n      }\n\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * * If the popup is closed, focuses the DateTimePicker input.\n     * * If the popup is open, the focus is moved to its content.\n     */\n\n\n    focus() {\n      if (this.disabled) {\n        return;\n      }\n\n      if (this.isOpen) {\n        this.activeTabComponent.focus();\n      } else {\n        this.input.focus();\n      }\n    }\n    /**\n     * Blurs the DateTimePicker.\n     */\n\n\n    blur() {\n      if (this.isOpen && this.activeTabComponent.isActive) {\n        this.activeTabComponent.blur();\n      } else {\n        this.input.blur();\n      }\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     * ([more information and example]({% slug overview_datetimepicker %}#toc-methods-and-events)).\n     *\n     * @param show - The state of the popup.\n     */\n\n\n    toggle(show) {\n      if (this.disabled || this.readonly || show === this.isOpen) {\n        return;\n      }\n\n      const shouldOpen = isPresent(show) ? show : !this.isOpen;\n\n      if (shouldOpen) {\n        this.openPopup();\n      } else {\n        this.closePopup(); // Changes the tab and the calendar or clock icon to the designated default.\n\n        if (this.activeTab !== this.defaultTab) {\n          this.activeTab = this.defaultTab;\n          this.cdr.detectChanges();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onControlChange = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onControlTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(disabled) {\n      this.disabled = disabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    validate(control) {\n      return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.input && this.input.isDateIncomplete);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /**\n     * @hidden\n     *\n     * Used by the TextBoxContainer to determine if the floating label will render in the input.\n     */\n\n\n    isEmpty() {\n      return !isPresent(this.value) && this.input.isEmpty();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleIconClick(event) {\n      if (this.disabled || this.readonly) {\n        return;\n      } // prevents the event default to evade focusing the DateInput input when placed inside a label (FF/IE/Edge)\n\n\n      event.preventDefault();\n      const runInZone = !this.isOpen || hasObservers(this.close);\n      this.run(runInZone, () => {\n        const shouldOpen = !this.isOpen; // handle focus first to maintain correct event order `focus` => `open`\n\n        this.handleFocus();\n        this.togglePopup(shouldOpen);\n        this.switchFocus();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      if (this.isActive) {\n        return;\n      }\n\n      this.isActive = true;\n\n      if (hasObservers(this.onFocus)) {\n        this.ngZone.run(() => this.onFocus.emit());\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(event) {\n      if (!this.isActive || this.focusTargetInComponent(event)) {\n        return;\n      }\n\n      this.isActive = false;\n      const isNgControlUntouched = this.wrapper.nativeElement.classList.contains('ng-untouched');\n      const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || this.isOpen && hasObservers(this.close);\n      this.run(runInZone, () => {\n        this.onBlur.emit();\n        this.onControlTouched();\n        this.togglePopup(false);\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    changeActiveTab(tab) {\n      if (!this.isOpen || this.activeTab === tab) {\n        return;\n      } // persists the Tcurrent value of the TimeSelector when switching between tabs\n\n\n      if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {\n        this.timeSelector.handleAccept();\n      }\n\n      this.activeTab = tab;\n      this.cdr.detectChanges();\n      this.detectPopupChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleTabChangeTransitionEnd(dateTimeSelector, event) {\n      // handle only the .k-datetime-selector element transition, ignore any child element transitions\n      if (event.target !== dateTimeSelector) {\n        return;\n      }\n\n      this.activeTabComponent.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleAccept() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);\n      const valueChangePresent = !isEqual(this.value, candidate);\n      const runInZone = valueChangePresent || hasObservers(this.close);\n      this.run(runInZone, () => {\n        this.handleValueChange(candidate);\n        this.togglePopup(false);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCancel() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      const runInZone = hasObservers(this.close);\n      this.run(runInZone, () => this.togglePopup(false));\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleInputValueChange(value) {\n      this.handleValueChange(value);\n\n      if (this.isOpen) {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCalendarValueChange() {\n      this.setTimeSelectorMinMax(this.calendar.value);\n      this.changeActiveTab('time');\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeyDown(event) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      const {\n        keyCode,\n        altKey\n      } = event;\n\n      switch (keyCode) {\n        case altKey && Keys.ArrowUp:\n        case Keys.Escape:\n          this.handleCancel();\n          break;\n\n        case !this.isOpen && altKey && Keys.ArrowDown:\n          this.ngZone.run(() => this.togglePopup(true));\n          break;\n\n        case altKey && Keys.ArrowRight:\n          this.changeActiveTab('time');\n          break;\n\n        case altKey && Keys.ArrowLeft:\n          this.changeActiveTab('date');\n          break;\n\n        case this.isOpen && this.timeSelector.isActive && isPresent(this.calendarValue) && Keys.Enter:\n          this.handleAccept();\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleTabOut(event) {\n      const {\n        keyCode,\n        shiftKey,\n        target\n      } = event; // if no focusable next sibling elements exist in the controls sections, the user is tabbing out of the popup\n\n      const focusableSiblingAvailable = isPresent(target.nextElementSibling) && !target.nextElementSibling.disabled;\n\n      if (keyCode === Keys.Tab && !shiftKey && !focusableSiblingAvailable) {\n        this.input.focus();\n        this.handleCancel();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBackTabOut(event) {\n      const {\n        keyCode,\n        shiftKey\n      } = event;\n\n      if (keyCode === Keys.Tab && shiftKey) {\n        this.input.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    popupButtonsClasses(type) {\n      const buttonType = type ? type : 'base';\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''} ${this.fillMode ? 'k-button-' + this.fillMode + ' ' + 'k-button-' + this.fillMode + '-' + buttonType : ''}`;\n    }\n    /**\n     * @hidden\n     *\n     * Prevents the diversion of the focus from the currently active element in the component.\n     */\n\n\n    preventMouseDown(event) {\n      event.preventDefault();\n    }\n\n    verifyValue(value) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (isPresent(value) && !(value instanceof Date)) {\n        throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK} for possible resolution.`);\n      }\n    }\n\n    verifyMinMaxRange() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isValidRange(this.min, this.max)) {\n        throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);\n      }\n    }\n    /**\n     * Extracts the time slots and the literals that are not preceded by date parts\n     * and concatenates the resulting parts into a string.\n     * If the provided format value does not contain any time parts,\n     * returns the designated format of the default popup component of the TimePicker.\n     */\n\n\n    getTimeSelectorFormat(format) {\n      const timeSelectorFormat = this.intl.splitDateFormat(format).filter(this.timeFormatPartFilter).reduce((format, part) => format += part.pattern, '');\n      return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;\n    }\n    /**\n     * Extracts the `displayFormat` from the provided `string | FormatSettings` value.\n     * Fallbacks to the default input value, if a falsy value param is passed.\n     */\n\n\n    getDisplayFormat(format) {\n      if (!format) {\n        return DEFAULT_DATEINPUT_FORMAT;\n      }\n\n      if (typeof format === 'string') {\n        return format;\n      } else {\n        return format.displayFormat;\n      }\n    }\n    /**\n     * The filter expression that filters out all format parts\n     * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.\n     * Literals will be left only if they are not preceded by date parts.\n     */\n\n\n    timeFormatPartFilter(part, index, parts) {\n      const previousPart = index >= 1 && parts[index - 1];\n\n      if (previousPart && part.type === 'literal') {\n        return timeFormatRegExp.test(previousPart.type);\n      }\n\n      return timeFormatRegExp.test(part.type);\n    }\n\n    togglePopup(open) {\n      if (open === this.isOpen) {\n        return;\n      }\n\n      const event = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(event);\n      } else {\n        this.close.emit(event);\n      }\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      this.toggle(open);\n      this.switchFocus();\n    }\n\n    switchFocus() {\n      if (!this.isActive) {\n        return;\n      }\n\n      if (this.isOpen) {\n        this.activeTabComponent.focus();\n      } else if (!this.touchEnabled) {\n        this.input.focus();\n      } else if (!this.input.isActive) {\n        this.handleBlur();\n      }\n    }\n\n    openPopup() {\n      this.setCalendarValue(this.value);\n      this.setTimeSelectorMinMax(this.value);\n      const direction = this.localization.rtl ? 'right' : 'left';\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        content: this.popupTemplate,\n        positionMode: 'absolute',\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        popupClass: `k-datetime-container ${this.popupSettings.popupClass || ''}`,\n        anchorAlign: {\n          vertical: 'bottom',\n          horizontal: direction\n        },\n        popupAlign: {\n          vertical: 'top',\n          horizontal: direction\n        }\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());\n    }\n\n    closePopup() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.popupRef.close();\n      this.popupRef = null;\n    }\n\n    handleValueChange(value) {\n      if (isEqual(this.value, value)) {\n        return;\n      }\n\n      this.value = cloneDate(value);\n      this.onControlChange(cloneDate(value));\n      this.valueChange.emit(cloneDate(value));\n    }\n    /**\n     * Indicates whether the focus target is part of this component,\n     * that is, whether the focus target is inside the component or in the popup.\n     */\n\n\n    focusTargetInComponent(event) {\n      if (!isPresent(event)) {\n        return false;\n      }\n\n      const relatedTarget = event.relatedTarget || document.activeElement;\n      const focusInPopup = isPresent(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);\n      const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);\n      return focusInPopup || focusInWrapper;\n    }\n\n    setTimeSelectorMinMax(selectedDate) {\n      const minDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.min));\n      this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);\n      const maxDateSelected = isPresent(selectedDate) && isEqual(getDate(selectedDate), getDate(this.max));\n      this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);\n    }\n\n    setCalendarValue(value) {\n      const isInCalendarRange = isPresent(value) && isInRange(value, this.calendarMin, this.calendarMax);\n      this.calendarValue = isInCalendarRange ? getDate(value) : null;\n    }\n    /**\n     * If the popup is available, runs a popup change detection.\n     */\n\n\n    detectPopupChanges() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.popupRef.popup.changeDetectorRef.detectChanges();\n    }\n    /**\n     * Depending on the predicate `runInZone` value that is passed,\n     * runs the provided function either in the Angular or in the current zone.\n     */\n\n\n    run(runInZone, fn) {\n      if (runInZone) {\n        this.ngZone.run(() => fn());\n      } else {\n        fn();\n      }\n    }\n\n    handleDateCompletenessChange() {\n      this.cdr.markForCheck();\n      this.ngZone.run(() => this.onValidatorChange());\n    }\n\n    setComponentClasses() {\n      if (this.size) {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n        this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass('button', this.size));\n      }\n\n      if (this.rounded) {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode) {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass('button', this.fillMode));\n        this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);\n      }\n    }\n\n  }\n\n  DateTimePickerComponent.ɵfac = function DateTimePickerComponent_Factory(t) {\n    return new (t || DateTimePickerComponent)(i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(i1.IntlService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PickerService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TOUCH_ENABLED), i0.ɵɵdirectiveInject(i1$1.LocalizationService), i0.ɵɵdirectiveInject(DisabledDatesService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  DateTimePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateTimePickerComponent,\n    selectors: [[\"kendo-datetimepicker\"]],\n    contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);\n      }\n    },\n    viewQuery: function DateTimePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c31, 7);\n        i0.ɵɵviewQuery(_c29, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c30, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-datetimepicker\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      format: \"format\",\n      twoDigitYearMax: \"twoDigitYearMax\",\n      tabindex: \"tabindex\",\n      disabledDates: \"disabledDates\",\n      popupSettings: \"popupSettings\",\n      focusableId: \"focusableId\",\n      title: \"title\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      readOnlyInput: \"readOnlyInput\",\n      cancelButton: \"cancelButton\",\n      formatPlaceholder: \"formatPlaceholder\",\n      placeholder: \"placeholder\",\n      steps: \"steps\",\n      focusedDate: \"focusedDate\",\n      calendarType: \"calendarType\",\n      animateCalendarNavigation: \"animateCalendarNavigation\",\n      weekNumber: \"weekNumber\",\n      min: \"min\",\n      max: \"max\",\n      rangeValidation: \"rangeValidation\",\n      disabledDatesValidation: \"disabledDatesValidation\",\n      incompleteDateValidation: \"incompleteDateValidation\",\n      defaultTab: \"defaultTab\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      open: \"open\",\n      close: \"close\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendo-datetimepicker\"],\n    features: [i0.ɵɵProvidersFeature([PickerService, LocalizationService, DisabledDatesService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.datetimepicker'\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => DateTimePickerComponent),\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => DateTimePickerComponent),\n      multi: true\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => DateTimePickerComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 37,\n    consts: function () {\n      let i18n_75;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Date tab text in the datetimepicker popup header\n         * @meaning kendo.datetimepicker.dateTab\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_76 = goog.getMsg(\"Date\");\n        i18n_75 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_76;\n      } else {\n        i18n_75 = $localize`:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header:Date`;\n      }\n\n      let i18n_77;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Date tab in the datetimepicker popup header\n         * @meaning kendo.datetimepicker.dateTabLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_78 = goog.getMsg(\"Date tab\");\n        i18n_77 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_78;\n      } else {\n        i18n_77 = $localize`:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header:Date tab`;\n      }\n\n      let i18n_79;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Time tab text in the datetimepicker popup header\n         * @meaning kendo.datetimepicker.timeTab\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_80 = goog.getMsg(\"Time\");\n        i18n_79 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_80;\n      } else {\n        i18n_79 = $localize`:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header:Time`;\n      }\n\n      let i18n_81;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Time tab in the datetimepicker popup header\n         * @meaning kendo.datetimepicker.timeTabLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_82 = goog.getMsg(\"Time tab\");\n        i18n_81 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_82;\n      } else {\n        i18n_81 = $localize`:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header:Time tab`;\n      }\n\n      let i18n_83;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the toggle button in the datetimepicker component\n         * @meaning kendo.datetimepicker.toggle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_84 = goog.getMsg(\"Toggle popup\");\n        i18n_83 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_84;\n      } else {\n        i18n_83 = $localize`:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component:Toggle popup`;\n      }\n\n      let i18n_85;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Accept button text in the datetimepicker component\n         * @meaning kendo.datetimepicker.accept\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_86 = goog.getMsg(\"Set\");\n        i18n_85 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_86;\n      } else {\n        i18n_85 = $localize`:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component:Set`;\n      }\n\n      let i18n_87;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Accept button in the datetimepicker component\n         * @meaning kendo.datetimepicker.acceptLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_88 = goog.getMsg(\"Set\");\n        i18n_87 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_88;\n      } else {\n        i18n_87 = $localize`:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component:Set`;\n      }\n\n      let i18n_89;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Cancel button text in the datetimepicker component\n         * @meaning kendo.datetimepicker.cancel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_90 = goog.getMsg(\"Cancel\");\n        i18n_89 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_90;\n      } else {\n        i18n_89 = $localize`:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component:Cancel`;\n      }\n\n      let i18n_91;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Cancel button in the datetimepicker component\n         * @meaning kendo.datetimepicker.cancelLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_92 = goog.getMsg(\"Cancel\");\n        i18n_91 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_92;\n      } else {\n        i18n_91 = $localize`:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component:Cancel`;\n      }\n\n      let i18n_93;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The Now button text in the timepicker component\n         * @meaning kendo.datetimepicker.now\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_94 = goog.getMsg(\"NOW\");\n        i18n_93 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_94;\n      } else {\n        i18n_93 = $localize`:kendo.datetimepicker.now|The Now button text in the timepicker component:NOW`;\n      }\n\n      let i18n_95;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the Now button in the timepicker component\n         * @meaning kendo.datetimepicker.nowLabel\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_96 = goog.getMsg(\"Select now\");\n        i18n_95 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_96;\n      } else {\n        i18n_95 = $localize`:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;\n      }\n\n      let i18n_97;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The label for the today button in the calendar header\n         * @meaning kendo.datetimepicker.today\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_98 = goog.getMsg(\"Today\");\n        i18n_97 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_98;\n      } else {\n        i18n_97 = $localize`:kendo.datetimepicker.today|The label for the today button in the calendar header:Today`;\n      }\n\n      let i18n_99;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the previous button in the Classic calendar\n         * @meaning kendo.datetimepicker.prevButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_100 = goog.getMsg(\"Navigate to previous view\");\n        i18n_99 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_100;\n      } else {\n        i18n_99 = $localize`:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;\n      }\n\n      let i18n_101;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the next button in the Classic calendar\n         * @meaning kendo.datetimepicker.nextButtonTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_102 = goog.getMsg(\"Navigate to next view\");\n        i18n_101 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2015_KENDO_ANGULAR_DATEINPUTS_JS_102;\n      } else {\n        i18n_101 = $localize`:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;\n      }\n\n      return [[\"kendoDateTimePickerLocalizedMessages\", \"\", \"dateTab\", i18n_75, \"dateTabLabel\", i18n_77, \"timeTab\", i18n_79, \"timeTabLabel\", i18n_81, \"toggle\", i18n_83, \"accept\", i18n_85, \"acceptLabel\", i18n_87, \"cancel\", i18n_89, \"cancelLabel\", i18n_91, \"now\", i18n_93, \"nowLabel\", i18n_95, \"today\", i18n_97, \"prevButtonTitle\", i18n_99, \"nextButtonTitle\", i18n_101], [3, \"value\", \"format\", \"twoDigitYearMax\", \"min\", \"max\", \"incompleteDateValidation\", \"formatPlaceholder\", \"placeholder\", \"disabled\", \"readonly\", \"role\", \"ariaReadOnly\", \"steps\", \"tabindex\", \"title\", \"focusableId\", \"hasPopup\", \"isPopupOpen\", \"kendoEventsOutsideAngular\", \"scope\", \"fillMode\", \"rounded\", \"size\", \"valueChange\"], [\"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"tabindex\", \"kendoEventsOutsideAngular\", \"scope\"], [\"toggleButton\", \"\"], [1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"container\", \"\"], [\"popupTemplate\", \"\"], [3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-datetime-buttongroup\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [1, \"k-button-group\", \"k-button-group-stretched\"], [\"type\", \"button\", 1, \"k-button\", \"k-group-start\", \"k-date-tab\", 3, \"ngClass\", \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", 1, \"k-button\", \"k-group-end\", \"k-time-tab\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [1, \"k-datetime-selector\", 3, \"kendoEventsOutsideAngular\"], [\"dateTimeSelector\", \"\"], [1, \"k-datetime-calendar-wrap\"], [3, \"focusedDate\", \"value\", \"type\", \"min\", \"max\", \"weekNumber\", \"navigation\", \"animateNavigation\", \"cellTemplate\", \"monthCellTemplate\", \"yearCellTemplate\", \"decadeCellTemplate\", \"centuryCellTemplate\", \"weekNumberTemplate\", \"headerTitleTemplate\", \"disabled\", \"disabledDates\", \"valueChange\"], [3, \"today\", \"prevButtonTitle\", \"nextButtonTitle\"], [1, \"k-datetime-time-wrap\"], [3, \"value\", \"format\", \"min\", \"max\", \"setButton\", \"cancelButton\", \"steps\", \"disabled\"], [3, \"now\", \"nowLabel\"], [1, \"k-datetime-footer\", \"k-action-buttons\", \"k-actions\", \"k-hstack\", \"k-justify-content-stretch\", 3, \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", \"class\", \"k-button k-time-cancel\", 3, \"ngClass\", \"kendoEventsOutsideAngular\", \"scope\", 4, \"ngIf\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-accept\", 3, \"ngClass\", \"disabled\", \"kendoEventsOutsideAngular\", \"scope\"], [\"type\", \"button\", 1, \"k-button\", \"k-time-cancel\", 3, \"ngClass\", \"kendoEventsOutsideAngular\", \"scope\"]];\n    },\n    template: function DateTimePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-dateinput\", 1);\n        i0.ɵɵlistener(\"valueChange\", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {\n          return ctx.handleInputValueChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"button\", 2, 3);\n        i0.ɵɵelement(4, \"span\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainer(5, null, 5);\n        i0.ɵɵtemplate(7, DateTimePickerComponent_ng_template_7_Template, 19, 84, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"format\", ctx.format)(\"twoDigitYearMax\", ctx.twoDigitYearMax)(\"min\", ctx.min)(\"max\", ctx.max)(\"incompleteDateValidation\", ctx.incompleteDateValidation)(\"formatPlaceholder\", ctx.formatPlaceholder)(\"placeholder\", ctx.placeholder)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly || ctx.readOnlyInput)(\"role\", ctx.inputRole)(\"ariaReadOnly\", ctx.readonly)(\"steps\", ctx.steps)(\"tabindex\", ctx.tabindex)(\"title\", ctx.title)(\"focusableId\", ctx.focusableId)(\"hasPopup\", true)(\"isPopupOpen\", ctx.isOpen)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(29, _c40, ctx.handleKeyDown))(\"scope\", ctx)(\"fillMode\", ctx.fillMode)(\"rounded\", ctx.rounded)(\"size\", ctx.size);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"tabindex\", -1)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(31, _c108, ctx.preventMouseDown, ctx.handleIconClick))(\"scope\", ctx);\n        i0.ɵɵattribute(\"title\", ctx.localization.get(\"toggle\"))(\"aria-label\", ctx.localization.get(\"toggle\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(34, _c109, ctx.activeTab === \"date\", ctx.activeTab === \"time\"));\n      }\n    },\n    directives: [DateInputComponent, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent, LocalizedMessagesDirective, i5.EventsOutsideAngularDirective, i7.NgClass, i7.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DateTimePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which renders the content of the DateRange Popup. To define the cell template, nest an\n * `<ng-template>` tag with the `kendoRangePopupTemplate` directive inside the component tag.\n */\n\n\nlet DateRangePopupTemplateDirective = /*#__PURE__*/(() => {\n  class DateRangePopupTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DateRangePopupTemplateDirective.ɵfac = function DateRangePopupTemplateDirective_Factory(t) {\n    return new (t || DateRangePopupTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  DateRangePopupTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateRangePopupTemplateDirective,\n    selectors: [[\"\", \"kendoDateRangePopupTemplate\", \"\"]]\n  });\n  return DateRangePopupTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst isActive = cmp => cmp && cmp.isActive || false;\n\nconst hasActiveContent = popup => popup && popup.hasActiveContent();\n/**\n * A service that handles the communication between the components that are placed inside the DateRangeComponent.\n * For example, the start and end `DateInput` and `DateRangePopup` components.\n */\n\n\nlet DateRangeService = /*#__PURE__*/(() => {\n  class DateRangeService {\n    /** @hidden */\n    constructor() {\n      /**\n       * An Observable instance that notifies when the `activeRangeEnd` state is changed.\n       */\n      this.activeRangeEnd$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the `focusedDate` is changed.\n       */\n\n      this.focusedDate$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the end `DateInput` component is changed.\n       * For example, when a new end `DateInput` is attached or when the old one is detached.\n       */\n\n      this.endInput$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the start `DateInput` component is changed.\n       * For example, when a new start `DateInput` is attached or the old one is detached.\n       */\n\n      this.startInput$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the `DateRangePopup` component is changed.\n       */\n\n      this.dateRangePopup$ = new BehaviorSubject(null);\n      /**\n       * An Observable instance that notifies when the state of the selection range is changed.\n       */\n\n      this.range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);\n    }\n    /**\n     * Gets the current `activeRangeEnd` value.\n     */\n\n\n    get activeRangeEnd() {\n      return this.activeRangeEnd$.value;\n    }\n    /**\n     * Gets the current `focusedDate` value.\n     */\n\n\n    get focusedDate() {\n      return this.focusedDate$.value;\n    }\n    /**\n     * Gets the `min` range value.\n     * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.\n     */\n\n\n    get min() {\n      return (this.startInput$.value || {}).min || null;\n    }\n    /**\n     * Gets the `max` range value.\n     * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.\n     */\n\n\n    get max() {\n      return (this.endInput$.value || {}).max || null;\n    }\n    /**\n     * Gets the current `selectionRange` value.\n     */\n\n\n    get selectionRange() {\n      return this.range$.value;\n    }\n    /**\n     * Activates the registered `DateRangePopup` component.\n     * The method opens the popup and focuses the calendar.\n     */\n\n\n    activatePopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!dateRangePopup) {\n        return;\n      }\n\n      dateRangePopup.activate();\n    }\n    /**\n     * Deactivates the registered `DateRangePopup` component.\n     * The method closes the popup.\n     */\n\n\n    deactivatePopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!(dateRangePopup && dateRangePopup.show)) {\n        return;\n      }\n\n      dateRangePopup.show = false;\n    }\n    /**\n     * @hidden\n     *\n     * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.\n     * The method closes the popup.\n     */\n\n\n    cancelPopup() {\n      const dateRangePopup = this.dateRangePopup$.value;\n\n      if (!(dateRangePopup && dateRangePopup.show)) {\n        return;\n      }\n\n      dateRangePopup.cancelPopup();\n    }\n    /**\n     * Completes all observables to mitigate possible memory leaks.\n     * Calls the method when a component that uses it is destroyed.\n     */\n\n\n    destroy() {\n      this.activeRangeEnd$.complete();\n      this.dateRangePopup$.complete();\n      this.focusedDate$.complete();\n      this.endInput$.complete();\n      this.startInput$.complete();\n      this.range$.complete();\n    }\n    /**\n     * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.\n     * For example, the opened popup or the focused DateInput.\n     *\n     * @returns `true` if an active component is present.\n     */\n\n\n    hasActiveComponent() {\n      const popup = this.dateRangePopup$.value;\n      const isPopup = isActive(popup);\n      const isStart = isActive(this.startInput$.value);\n      const isEnd = isActive(this.endInput$.value);\n      return isPopup || isStart || isEnd || hasActiveContent(popup) || false;\n    }\n    /**\n     * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.\n     */\n\n\n    registerStartInput(startInput) {\n      this.startInput$.next(startInput);\n    }\n    /**\n     * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.\n     */\n\n\n    registerEndInput(endInput) {\n      this.endInput$.next(endInput);\n    }\n    /**\n     * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.\n     */\n\n\n    registerPopup(dateRangePopup) {\n      this.dateRangePopup$.next(dateRangePopup);\n    }\n    /**\n     * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.\n     */\n\n\n    setActiveRangeEnd(activeRange) {\n      if (!activeRange || this.activeRangeEnd === activeRange) {\n        return;\n      }\n\n      this.activeRangeEnd$.next(activeRange);\n    }\n    /**\n     * Updates the focused date. Notifies all `focusedDate$` listeners.\n     */\n\n\n    setFocusedDate(value) {\n      if (isEqual(this.focusedDate$.value, value)) {\n        return;\n      }\n\n      this.focusedDate$.next(value);\n    }\n    /**\n     * Updates the selection range. Notifies all `range$` listeners.\n     */\n\n\n    setRange(range = EMPTY_SELECTIONRANGE) {\n      this.range$.next(range);\n    }\n\n  }\n\n  DateRangeService.ɵfac = function DateRangeService_Factory(t) {\n    return new (t || DateRangeService)();\n  };\n\n  DateRangeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DateRangeService,\n    factory: DateRangeService.ɵfac\n  });\n  return DateRangeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which manages the MultiViewCalendar range selection.\n */\n\n\nlet DateRangeSelectionDirective = /*#__PURE__*/(() => {\n  class DateRangeSelectionDirective {\n    constructor(calendar, cdr, element, renderer, dateRangeService) {\n      this.calendar = calendar;\n      this.cdr = cdr;\n      this.element = element;\n      this.dateRangeService = dateRangeService;\n      /**\n       * Specifies the auto-correction behavior. If the start date is greater than the end date,\n       * the directive fixes the date range to a single date either on input change or on blur\n       * ([see example]({% slug autocorrect_daterange %}#toc-configuring-the-calendar-selection-directive)).\n       *\n       * By default, the auto-correction is triggered on change.\n       * To disable this behavior, set the `autoCorrectOn` property to `none`.\n       */\n\n      this.autoCorrectOn = 'change';\n      /**\n       * Fires when the active range end is changed. For more information, refer to\n       * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n       */\n\n      this.activeRangeEndChange = new EventEmitter();\n      /**\n       * Fires when the selection range is changed. For more information, refer to\n       * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).\n       */\n\n      this.selectionRangeChange = new EventEmitter();\n      this.calendarSubscriptions = new Subscription();\n      this.dateRangeService = this.dateRangeService || new DateRangeService();\n      renderer.setAttribute(element.nativeElement, 'aria-multiselectable', 'true');\n    }\n    /**\n     * Gets or sets the selection range of the calendar. When a new range is set,\n     * the connected DateRangeService notifies all related parties.\n     */\n\n\n    get selectionRange() {\n      return this.calendar ? this.calendar.selectionRange : null;\n    }\n\n    set selectionRange(range) {\n      if (!this.isEqualCalendarRange(range)) {\n        this.setSelectionRange(range);\n      }\n\n      if (!isEqualRange(this.dateRangeService.selectionRange, range)) {\n        this.dateRangeService.setRange(range);\n      }\n\n      this.updateFocusedDate(range);\n    }\n    /**\n     * Gets or sets the active end of the selection range. This option determines which range end will be updated on\n     * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.\n     */\n\n    /**\n     * Specifies which end of the selection range will be marked as active. The active end gets modified upon user\n     * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For\n     * example, the start and end DateInput components.\n     *\n     * > If the selection range is undefined, the value is ignored.\n     */\n\n\n    get activeRangeEnd() {\n      return this.calendar.activeRangeEnd;\n    }\n\n    set activeRangeEnd(activeRange) {\n      if (this.dateRangeService.activeRangeEnd === activeRange) {\n        return;\n      }\n\n      this.calendar.activeRangeEnd = activeRange;\n      this.dateRangeService.setActiveRangeEnd(activeRange);\n    }\n\n    get calendarRange() {\n      return this.selectionRange || EMPTY_SELECTIONRANGE;\n    }\n\n    ngOnInit() {\n      const calendar = this.calendar;\n      const dateRangeService = this.dateRangeService;\n      calendar.min = either(dateRangeService.min, calendar.min);\n      calendar.max = either(dateRangeService.max, calendar.max);\n      this.addSubscriptions(calendar.cellEnter.subscribe(value => this.handleHover(value)), calendar.valueChange.subscribe(value => this.handleChange(value)), dateRangeService.focusedDate$.subscribe(focusedDate => {\n        if (!isEqual(calendar.focusedDate, focusedDate)) {\n          calendar.focusedDate = focusedDate;\n        }\n      }), dateRangeService.activeRangeEnd$.subscribe(rangeEnd => {\n        if (calendar.activeRangeEnd === rangeEnd) {\n          return;\n        }\n\n        calendar.activeRangeEnd = rangeEnd;\n        this.activeRangeEndChange.emit(rangeEnd);\n        this.cdr.markForCheck();\n      }), dateRangeService.range$.subscribe(range => {\n        if (!this.isEqualCalendarRange(range)) {\n          this.acceptAndEmit(range);\n        }\n\n        this.updateFocusedDate(range);\n      }), fromEvent(this.element.nativeElement, 'blur').subscribe(() => this.handleBlur()));\n    }\n\n    ngOnDestroy() {\n      this.calendarSubscriptions.unsubscribe();\n    }\n\n    addSubscriptions(...subscriptions) {\n      subscriptions.map(s => this.calendarSubscriptions.add(s));\n    }\n\n    isEqualCalendarRange(range) {\n      return isEqualRange(this.calendar.selectionRange, range);\n    }\n\n    handleBlur() {\n      const {\n        start,\n        end\n      } = this.calendarRange;\n      const autoCorrect = this.autoCorrectOn === 'blur' && start !== null && end !== null && end < start;\n\n      if (autoCorrect) {\n        this.dateRangeService.setRange(clampRange(start));\n      }\n    }\n\n    handleChange(value) {\n      const service = this.dateRangeService;\n      const autoCorrect = this.autoCorrectOn === 'change' && this.shouldAutoCorrect(value);\n      const activeEnd = this.calendar.activeRangeEnd !== 'end' ? 'end' : autoCorrect ? 'end' : 'start';\n      const range = autoCorrect ? clampRange(value) : this.updateRange(value);\n\n      if (!isEqualRange(service.selectionRange, range)) {\n        this.acceptAndEmit(range);\n        service.setActiveRangeEnd(activeEnd);\n        service.setRange(range);\n      }\n    }\n\n    handleHover(value) {\n      if (this.hasCompleteRange()) {\n        return;\n      }\n\n      const {\n        start,\n        end\n      } = this.calendarRange;\n      const activeRangeEnd = this.calendar.activeRangeEnd;\n      const updateRange = start && activeRangeEnd === 'end' || end && activeRangeEnd === 'start';\n\n      if (updateRange) {\n        this.setSelectionRange(this.updateRange(value));\n      }\n    }\n\n    hasCompleteRange() {\n      const {\n        start,\n        end\n      } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      return Boolean(start) && Boolean(end);\n    }\n\n    shouldAutoCorrect(value) {\n      const {\n        end,\n        start\n      } = this.calendarRange;\n\n      if (this.calendar.activeRangeEnd !== 'end') {\n        return end !== null && value > end;\n      } else {\n        return start !== null && value < start;\n      }\n    }\n\n    updateFocusedDate(range) {\n      if (!range || this.dateRangeService.focusedDate) {\n        return;\n      }\n\n      this.dateRangeService.setFocusedDate(range.start || range.end);\n    }\n\n    updateRange(value) {\n      const {\n        end,\n        start\n      } = this.calendarRange;\n      return this.calendar.activeRangeEnd !== 'end' ? {\n        start: value,\n        end\n      } : {\n        start,\n        end: value\n      };\n    }\n\n    setSelectionRange(range) {\n      this.calendar.selectionRange = range;\n      this.calendar.writeValue(null);\n    }\n\n    acceptAndEmit(range) {\n      this.setSelectionRange(range);\n      this.selectionRangeChange.emit(range);\n    }\n\n  }\n\n  DateRangeSelectionDirective.ɵfac = function DateRangeSelectionDirective_Factory(t) {\n    return new (t || DateRangeSelectionDirective)(i0.ɵɵdirectiveInject(MultiViewCalendarComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DateRangeService, 8));\n  };\n\n  DateRangeSelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateRangeSelectionDirective,\n    selectors: [[\"\", \"kendoDateRangeSelection\", \"\"]],\n    inputs: {\n      autoCorrectOn: \"autoCorrectOn\",\n      selectionRange: \"selectionRange\",\n      activeRangeEnd: \"activeRangeEnd\"\n    },\n    outputs: {\n      activeRangeEndChange: \"activeRangeEndChange\",\n      selectionRangeChange: \"selectionRangeChange\"\n    }\n  });\n  return DateRangeSelectionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the Kendo UI DateRangePopup component for Angular.\n *\n * @example\n * ```ts\n * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';\n *\n * _@Component({\n * providers: [DateRangeService],\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"popup.toggle()\">Toggle</button>\n *  <kendo-daterange-popup [anchor]=\"anchor\" #popup></kendo-daterange-popup>\n * `\n * })\n * export class AppComponent {\n * }\n * ```\n */\n\n\nlet DateRangePopupComponent = /*#__PURE__*/(() => {\n  class DateRangePopupComponent {\n    constructor(popupService, dateRangeService, ref, zone, rtl) {\n      this.popupService = popupService;\n      this.dateRangeService = dateRangeService;\n      this.ref = ref;\n      this.zone = zone;\n      this.rtl = rtl;\n      /**\n       * Controls the popup animation.\n       * By default, the opening and closing animations are enabled.\n       * For more information about controlling the popup animations,\n       * refer to the article on [animations]({% slug animations_popup %}).\n       */\n\n      this.animate = true;\n      /**\n       * Configures the collision behavior of the popup.\n       * For more information, refer to the article on\n       * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).\n       */\n\n      this.collision = {\n        horizontal: 'fit',\n        vertical: 'flip'\n      };\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       * For more information, refer to the section on\n       * [events]({% slug overview_datepicker %}#toc-events).\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       * For more information, refer to the section on\n       * [events]({% slug overview_datepicker %}#toc-events).\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires each time the calendar element is blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the calendar element is focused.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.\n       */\n\n      this.cancel = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.popupUID = guid();\n      this.calendarSubscriptions = new Subscription();\n      this.popupSubscriptions = new Subscription();\n      this.resolvedPromise = Promise.resolve();\n    }\n    /**\n     * The active calendar that is visible in the popup.\n     *\n     * > When the popup is closed, the property returns `null`.\n     */\n\n\n    get calendar() {\n      return this._calendar;\n    }\n\n    set calendar(calendar) {\n      this._calendar = calendar;\n      this.subscribeFocusBlur(calendar);\n    }\n    /**\n     * Gets the active state of the component.\n     * When the opened calendar is active, returns `true`.\n     */\n\n\n    get isActive() {\n      return this.calendar && this.calendar.isActive;\n    }\n    /**\n     * Gets or sets the visibility state of the component.\n     */\n\n\n    set show(show) {\n      if (this._show === show) {\n        return;\n      }\n\n      const event = new PreventableEvent();\n\n      if (show) {\n        this.open.emit(event);\n      } else {\n        this.close.emit(event);\n      }\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n\n      this._toggle(show);\n    }\n\n    get show() {\n      return this._show;\n    }\n\n    ngOnInit() {\n      this.dateRangeService.registerPopup(this);\n    }\n\n    ngAfterViewInit() {\n      this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe(changes => this.calendar = changes.first));\n      this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe(changes => this.calendar = changes.first));\n\n      if (isWindowAvailable()) {\n        this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this)));\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.calendarSubscriptions.unsubscribe();\n\n      if (this.activateSubscription) {\n        this.activateSubscription.unsubscribe();\n      }\n\n      if (this.blurSubscription) {\n        this.blurSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n      }\n\n      if (this.windowBlurSubscription) {\n        this.windowBlurSubscription.unsubscribe();\n      }\n    }\n    /**\n     *  Opens the popup component and focuses the calendar.\n     */\n\n\n    activate() {\n      if (this.show === true) {\n        return;\n      }\n\n      if (this.activateSubscription) {\n        this.activateSubscription.unsubscribe();\n      }\n\n      this.show = true;\n      this.ref.markForCheck();\n      this.zone.runOutsideAngular(() => {\n        this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes).pipe(filter(changes => changes && changes.first), map(changes => changes.first)).subscribe(calendar => setTimeout(() => calendar.focus()));\n      });\n    }\n    /**\n     *  Focuses the calendar (if available).\n     */\n\n\n    focus() {\n      if (this.calendar) {\n        this.calendar.focus();\n      }\n    }\n    /**\n     * Checks if a focused element ids placed inside the popup.\n     *\n     * @return boolean;\n     */\n\n\n    hasActiveContent() {\n      if (!isDocumentAvailable() || !this.popupRef) {\n        return false;\n      }\n\n      return this.popupRef.popupElement.contains(document.activeElement);\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If you use the `toggle` method to show or hide the popup,\n     * the `open` and `close` events do not fire.\n     *\n     * @param show The state of the popup.\n     */\n\n\n    toggle(show) {\n      this.resolvedPromise.then(() => {\n        this._toggle(show === undefined ? !this.show : show);\n      });\n    }\n    /**\n     * @hidden\n     *\n     * Closes the popup and triggers the `cancel` event.\n     */\n\n\n    cancelPopup() {\n      this.show = false;\n      this.cancel.emit();\n    }\n\n    handleWindowBlur() {\n      if (!this.show) {\n        return;\n      }\n\n      if (hasObservers(this.close)) {\n        this.zone.run(() => this.show = false);\n      } else {\n        this.show = false;\n      }\n    }\n\n    handleMouseLeave() {\n      this.dateRangeService.setRange(this.dateRangeService.selectionRange);\n    }\n\n    handleKeydown(event) {\n      const {\n        altKey,\n        keyCode\n      } = event;\n\n      if (keyCode === Keys.Escape || altKey && keyCode === Keys.ArrowUp) {\n        this.zone.run(() => this.cancelPopup());\n      }\n    }\n\n    subscribeFocusBlur(calendar) {\n      if (this.blurSubscription) {\n        this.blurSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n      }\n\n      if (!calendar) {\n        return;\n      }\n\n      const nativeElement = calendar.element.nativeElement;\n      this.blurSubscription = fromEvent(nativeElement, 'blur').subscribe(() => this.onBlur.emit());\n      this.focusSubscription = fromEvent(nativeElement, 'focus').subscribe(() => this.onFocus.emit());\n    }\n\n    addPopupSubscriptions(...subscriptions) {\n      if (!isPresent(this.popupSubscriptions)) {\n        this.popupSubscriptions = new Subscription();\n      }\n\n      subscriptions.map(s => this.popupSubscriptions.add(s));\n    }\n\n    get _appendTo() {\n      const appendTo = this.appendTo;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    _toggle(show) {\n      this._show = show;\n\n      if (this.popupRef) {\n        this.destroyPopup();\n      }\n\n      if (this._show) {\n        const direction = this.rtl ? 'right' : 'left';\n        this.popupRef = this.popupService.open({\n          anchor: this.anchor,\n          anchorAlign: this.anchorAlign || {\n            vertical: 'bottom',\n            horizontal: direction\n          },\n          animate: this.animate,\n          appendTo: this._appendTo,\n          collision: this.collision,\n          content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,\n          margin: this.margin,\n          popupAlign: this.popupAlign || {\n            vertical: 'top',\n            horizontal: direction\n          },\n          positionMode: 'absolute'\n        });\n        const {\n          popupElement,\n          popupAnchorViewportLeave\n        } = this.popupRef;\n        popupElement.setAttribute('id', this.popupUID);\n        this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, 'keydown').subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, 'mouseleave').subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));\n      }\n    }\n\n    destroyPopup() {\n      if (isPresent(this.popupRef)) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n\n      if (isPresent(this.popupSubscriptions)) {\n        this.popupSubscriptions.unsubscribe();\n      }\n    }\n\n  }\n\n  DateRangePopupComponent.ɵfac = function DateRangePopupComponent_Factory(t) {\n    return new (t || DateRangePopupComponent)(i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(DateRangeService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(RTL, 8));\n  };\n\n  DateRangePopupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateRangePopupComponent,\n    selectors: [[\"kendo-daterange-popup\"]],\n    contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MultiViewCalendarComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentCalendar = _t);\n      }\n    },\n    viewQuery: function DateRangePopupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c29, 5, ViewContainerRef);\n        i0.ɵɵviewQuery(_c110, 5);\n        i0.ɵɵviewQuery(MultiViewCalendarComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewCalendar = _t);\n      }\n    },\n    inputs: {\n      animate: \"animate\",\n      anchor: \"anchor\",\n      anchorAlign: \"anchorAlign\",\n      appendTo: \"appendTo\",\n      collision: \"collision\",\n      popupAlign: \"popupAlign\",\n      margin: \"margin\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\",\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      cancel: \"cancel\"\n    },\n    exportAs: [\"kendo-daterange-popup\"],\n    decls: 4,\n    vars: 0,\n    consts: [[\"container\", \"\"], [\"defaultTemplate\", \"\"], [\"kendoDateRangeSelection\", \"\"]],\n    template: function DateRangePopupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, null, 0);\n        i0.ɵɵtemplate(2, DateRangePopupComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [MultiViewCalendarComponent, DateRangeSelectionDirective],\n    encapsulation: 2\n  });\n  return DateRangePopupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the Kendo UI DateRange component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-daterange>\n *      <kendo-dateinput kendoDateRangeStartInput [(value)]=\"dateRange.start\"></kendo-dateinput>\n *      <kendo-dateinput kendoDateRangeEndInput [(value)]=\"dateRange.end\"></kendo-dateinput>\n *  </kendo-daterange>\n * `\n * })\n * export class AppComponent {\n *   public dateRange: any = { start: null, end: null };\n * }\n * ```\n */\n\n\nlet DateRangeComponent = /*#__PURE__*/(() => {\n  class DateRangeComponent {\n    constructor() {\n      this.wrapperClass = true;\n      /**\n       * @hidden\n       */\n\n      this.showDefault = false;\n      validatePackage(packageMetadata);\n    }\n\n    get hasContentPopup() {\n      return this.contentPopup.length > 0;\n    }\n\n    ngAfterContentInit() {\n      this.showDefault = !this.hasContentPopup;\n      this.subscription = this.contentPopup.changes.subscribe(() => {\n        this.showDefault = !this.hasContentPopup;\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n\n  }\n\n  DateRangeComponent.ɵfac = function DateRangeComponent_Factory(t) {\n    return new (t || DateRangeComponent)();\n  };\n\n  DateRangeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateRangeComponent,\n    selectors: [[\"kendo-daterange\"]],\n    contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentPopup = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function DateRangeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-daterangepicker\", ctx.wrapperClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([DateRangeService])],\n    ngContentSelectors: _c13,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function DateRangeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, DateRangeComponent_kendo_daterange_popup_1_Template, 1, 0, \"kendo-daterange-popup\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showDefault);\n      }\n    },\n    directives: [DateRangePopupComponent, i7.NgIf],\n    encapsulation: 2\n  });\n  return DateRangeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass DateRangeInput {\n  constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {\n    this.activeRangeEnd = activeRangeEnd;\n    this.dateRangeService = dateRangeService;\n    this.input = input;\n    this.element = element;\n    this.renderer = renderer;\n    this.zone = zone;\n    this.navigateCalendarOnFocus = false;\n    this.popupSubscriptions = new Subscription();\n    this.subscriptions = new Subscription();\n  }\n\n  get isActiveEnd() {\n    return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;\n  }\n\n  get popupCalendarActivated() {\n    const popup = this.dateRangeService.dateRangePopup$.value;\n    return isPresent(popup) && isPresent(popup.calendar);\n  }\n\n  init() {\n    if (this.input.value) {\n      this.dateRangeService.setRange(this.getRange(this.input.value));\n    }\n\n    [this.input.onBlur.subscribe(() => this.deactivate()), this.input.onFocus.pipe(filter(() => !this.popupCalendarActivated)).subscribe(() => this.activate()), this.input.valueUpdate.subscribe(value => this.updateRange(value, 'change')), this.dateRangeService.activeRangeEnd$.subscribe(() => {\n      if (this.navigateCalendarOnFocus) {\n        this.focusActiveDate();\n      }\n\n      this.toggleActiveClass(this.isActiveEnd);\n    }), this.dateRangeService.dateRangePopup$.subscribe(popup => this.initPopup(popup)), this.dateRangeService.range$.subscribe(range => this.updateInputValue(range)), fromEvent(this.element.nativeElement, 'click').subscribe(() => this.activate()), fromEvent(this.element.nativeElement, 'keydown').subscribe(event => this.togglePopup(event || {}))].map(s => this.subscriptions.add(s));\n  }\n\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.unsubscribePopup();\n  }\n\n  initPopup(popup) {\n    if (!popup) {\n      this.unsubscribePopup();\n      return;\n    }\n\n    if (!popup.anchor) {\n      popup.anchor = this.element.nativeElement;\n    }\n\n    [popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()), popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)), popup.onBlur.subscribe(() => this.deactivate())].map(s => this.popupSubscriptions.add(s));\n  }\n\n  unsubscribePopup() {\n    this.popupSubscriptions.unsubscribe();\n    this.popupSubscriptions = new Subscription();\n  }\n\n  activate() {\n    this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);\n    this.dateRangeService.activatePopup();\n  }\n\n  deactivate() {\n    this.zone.runOutsideAngular(() => {\n      setTimeout(() => {\n        this.updateRange(this.input.value, 'blur');\n\n        if (this.dateRangeService.hasActiveComponent()) {\n          return;\n        }\n\n        this.toggleActiveClass(false);\n        this.zone.run(() => this.dateRangeService.deactivatePopup());\n      });\n    });\n  }\n\n  updateRange(value, correctOn) {\n    const range = this.getRange(value, correctOn);\n\n    if (range) {\n      this.focusActiveDate();\n      this.dateRangeService.setRange(range);\n    }\n  }\n\n  togglePopup({\n    altKey,\n    keyCode\n  }) {\n    if (keyCode === Keys.Escape) {\n      this.dateRangeService.cancelPopup();\n    } else if (altKey && keyCode === Keys.ArrowDown) {\n      this.dateRangeService.activatePopup();\n    }\n  }\n\n  focusActiveDate() {\n    if (this.input.value && this.isActiveEnd) {\n      this.dateRangeService.setFocusedDate(cloneDate(this.input.value));\n    }\n  }\n\n  toggleActiveClass(show) {\n    const action = show ? 'addClass' : 'removeClass';\n    const nativeElement = this.element.nativeElement;\n\n    if (nativeElement && nativeElement.querySelector) {\n      this.renderer[action](nativeElement, 'k-focus');\n    }\n  }\n\n}\n/**\n * A directive which manages the end range selection.\n *\n * > You can use the DateRangeEndInputDirective only with a DateInput component.\n */\n\n\nlet DateRangeEndInputDirective = /*#__PURE__*/(() => {\n  class DateRangeEndInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n      super('end', rangeService, dateInput, element, renderer, zone);\n      this.rangeService = rangeService;\n      this.dateInput = dateInput;\n      /**\n       * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,\n       * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.\n       *\n       * By default, the automatic navigation behavior on input focus is disabled.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n       *  <kendo-daterange>\n       *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n       *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n       *  </kendo-daterange>\n       * `\n       * })\n       * export class AppComponent {\n       *   public start: Date = new Date(2018, 3, 10);\n       *   public end: Date = new Date(2018, 10, 20);\n       * }\n       * ```\n       */\n\n      this.navigateCalendarOnFocus = false;\n    }\n\n    ngOnInit() {\n      this.rangeService.registerEndInput(this.dateInput);\n      super.init();\n    }\n\n    ngOnDestroy() {\n      super.destroy();\n    }\n\n    getRange(value, correctOn) {\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (!isInRange(value, min, max)) {\n        return null;\n      }\n\n      const {\n        start\n      } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      const shouldClamp = this.autoCorrectOn === correctOn && isPresent(value) && value < start;\n      return shouldClamp ? clampRange(value) : {\n        start,\n        end: cloneDate(value)\n      };\n    }\n\n    updateInputValue(range) {\n      const {\n        end\n      } = range || EMPTY_SELECTIONRANGE;\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {\n        return;\n      }\n\n      this.dateInput.writeValue(cloneDate(end));\n      this.dateInput.notify();\n    }\n\n  }\n\n  DateRangeEndInputDirective.ɵfac = function DateRangeEndInputDirective_Factory(t) {\n    return new (t || DateRangeEndInputDirective)(i0.ɵɵdirectiveInject(DateRangeService), i0.ɵɵdirectiveInject(DateInputComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  DateRangeEndInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateRangeEndInputDirective,\n    selectors: [[\"\", \"kendoDateRangeEndInput\", \"\"]],\n    inputs: {\n      autoCorrectOn: \"autoCorrectOn\",\n      navigateCalendarOnFocus: \"navigateCalendarOnFocus\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DateRangeEndInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which manages the start selection range.\n *\n * > You can use the DateRangeStartInputDirective only with a DateInput component.\n */\n\n\nlet DateRangeStartInputDirective = /*#__PURE__*/(() => {\n  class DateRangeStartInputDirective extends DateRangeInput {\n    constructor(rangeService, dateInput, element, renderer, zone) {\n      super('start', rangeService, dateInput, element, renderer, zone);\n      this.rangeService = rangeService;\n      this.dateInput = dateInput;\n      /**\n       * Specifies the navigation behavior of the calendar when the active end is changed on input focus.\n       * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar\n       * displays the last picked date.\n       *\n       * By default, the automatic navigation behavior on input focus is disabled.\n       *\n       * @example\n       * ```ts\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>\n       *  <kendo-daterange>\n       *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"start\"></kendo-dateinput>\n       *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]=\"true\" [(value)]=\"end\"></kendo-dateinput>\n       *  </kendo-daterange>\n       * `\n       * })\n       * export class AppComponent {\n       *   public start: Date = new Date(2018, 3, 10);\n       *   public end: Date = new Date(2018, 10, 20);\n       * }\n       * ```\n       */\n\n      this.navigateCalendarOnFocus = false;\n    }\n\n    ngOnInit() {\n      this.rangeService.registerStartInput(this.dateInput);\n      super.init();\n    }\n\n    ngOnDestroy() {\n      super.destroy();\n    }\n\n    getRange(value, correctOn) {\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (!isInRange(value, min, max)) {\n        return null;\n      }\n\n      const {\n        end\n      } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;\n      const shouldClamp = this.autoCorrectOn === correctOn && end && value > end;\n      return shouldClamp ? clampRange(value) : {\n        start: cloneDate(value),\n        end\n      };\n    }\n\n    updateInputValue(range) {\n      const {\n        start\n      } = range || EMPTY_SELECTIONRANGE;\n      const {\n        min,\n        max\n      } = this.dateInput;\n\n      if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {\n        return;\n      }\n\n      this.dateInput.writeValue(cloneDate(start));\n      this.dateInput.notify();\n    }\n\n  }\n\n  DateRangeStartInputDirective.ɵfac = function DateRangeStartInputDirective_Factory(t) {\n    return new (t || DateRangeStartInputDirective)(i0.ɵɵdirectiveInject(DateRangeService), i0.ɵɵdirectiveInject(DateInputComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  DateRangeStartInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DateRangeStartInputDirective,\n    selectors: [[\"\", \"kendoDateRangeStartInput\", \"\"]],\n    inputs: {\n      autoCorrectOn: \"autoCorrectOn\",\n      navigateCalendarOnFocus: \"navigateCalendarOnFocus\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DateRangeStartInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `HeaderComponent`&mdash;The component that renders the UI for vertical navigation.\n * - `ViewComponent`&mdash;The component that renders the active Calendar view.\n */\n\n\nlet CalendarCommonModule = /*#__PURE__*/(() => {\n  class CalendarCommonModule {}\n\n  CalendarCommonModule.ɵfac = function CalendarCommonModule_Factory(t) {\n    return new (t || CalendarCommonModule)();\n  };\n\n  CalendarCommonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CalendarCommonModule\n  });\n  CalendarCommonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, EventsModule]]\n  });\n  return CalendarCommonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n */\n\n\nlet TemplatesModule = /*#__PURE__*/(() => {\n  class TemplatesModule {}\n\n  TemplatesModule.ɵfac = function TemplatesModule_Factory(t) {\n    return new (t || TemplatesModule)();\n  };\n\n  TemplatesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TemplatesModule\n  });\n  TemplatesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TemplatesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the MultiViewCalendar module\n * import { MultiViewCalendarModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, MultiViewCalendarModule], // import MultiViewCalendar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n */\n\n\nlet MultiViewCalendarModule = /*#__PURE__*/(() => {\n  class MultiViewCalendarModule {}\n\n  MultiViewCalendarModule.ɵfac = function MultiViewCalendarModule_Factory(t) {\n    return new (t || MultiViewCalendarModule)();\n  };\n\n  MultiViewCalendarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MultiViewCalendarModule\n  });\n  MultiViewCalendarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, WeekNamesService],\n    imports: [[CommonModule, CalendarCommonModule, IntlModule, TemplatesModule, PopupModule, EventsModule], CalendarCommonModule, TemplatesModule]\n  });\n  return MultiViewCalendarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES$3 = [VirtualizationComponent];\n/**\n * @hidden\n *\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Virtualization component.\n */\n\nlet VirtualizationModule = /*#__PURE__*/(() => {\n  class VirtualizationModule {}\n\n  VirtualizationModule.ɵfac = function VirtualizationModule_Factory(t) {\n    return new (t || VirtualizationModule)();\n  };\n\n  VirtualizationModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VirtualizationModule\n  });\n  VirtualizationModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return VirtualizationModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The exported package module.\n *\n * The package exports:\n * - `CellTemplateDirective`&mdash;The month cell template directive.\n * - `MonthCellTemplateDirective`&mdash;The month cell template directive.\n * - `YearCellTemplateDirective`&mdash;The year cell template directive.\n * - `DecadeCellTemplateDirective`&mdash;The decade cell template directive.\n * - `CenturyCellTemplateDirective`&mdash;The century cell template directive.\n * - `WeekNumberCellTemplateDirective`&mdash;The month week number cell template directive.\n * - `HeaderTitleTemplateDirective`&mdash;The header title template directive.\n * - `NavigationItemTemplateDirective`&mdash;The navigation item template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Calendar module\n * import { CalendarModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CalendarModule], // import Calendar module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet CalendarModule = /*#__PURE__*/(() => {\n  class CalendarModule {}\n\n  CalendarModule.ɵfac = function CalendarModule_Factory(t) {\n    return new (t || CalendarModule)();\n  };\n\n  CalendarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CalendarModule\n  });\n  CalendarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, WeekNamesService],\n    imports: [[CommonModule, CalendarCommonModule, MultiViewCalendarModule, IntlModule, TemplatesModule, VirtualizationModule, EventsModule, ResizeSensorModule], CalendarCommonModule, TemplatesModule]\n  });\n  return CalendarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The exported package module.\n *\n * The package exports:\n * - `CalendarModule`&mdash;The calendar module.\n * - `MultiViewCalendarModule`&mdash;The multi-view calendar module.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Calendars module\n * import { CalendarsModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, CalendarsModule], // import the Calendars module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet CalendarsModule = /*#__PURE__*/(() => {\n  class CalendarsModule {}\n\n  CalendarsModule.ɵfac = function CalendarsModule_Factory(t) {\n    return new (t || CalendarsModule)();\n  };\n\n  CalendarsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CalendarsModule\n  });\n  CalendarsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CalendarModule, MultiViewCalendarModule], CalendarModule, MultiViewCalendarModule]\n  });\n  return CalendarsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet DateInputCustomMessagesComponent = /*#__PURE__*/(() => {\n  class DateInputCustomMessagesComponent extends DateInputMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  DateInputCustomMessagesComponent.ɵfac = function DateInputCustomMessagesComponent_Factory(t) {\n    return new (t || DateInputCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  DateInputCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateInputCustomMessagesComponent,\n    selectors: [[\"kendo-dateinput-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DateInputMessages,\n      useExisting: forwardRef(() => DateInputCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DateInputCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DateInputCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateInput component.\n */\n\n\nlet DateInputModule = /*#__PURE__*/(() => {\n  class DateInputModule {}\n\n  DateInputModule.ɵfac = function DateInputModule_Factory(t) {\n    return new (t || DateInputModule)();\n  };\n\n  DateInputModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DateInputModule\n  });\n  DateInputModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IntlModule, EventsModule]]\n  });\n  return DateInputModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet DatePickerCustomMessagesComponent = /*#__PURE__*/(() => {\n  class DatePickerCustomMessagesComponent extends DatePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  DatePickerCustomMessagesComponent.ɵfac = function DatePickerCustomMessagesComponent_Factory(t) {\n    return new (t || DatePickerCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  DatePickerCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DatePickerCustomMessagesComponent,\n    selectors: [[\"kendo-datepicker-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DatePickerMessages,\n      useExisting: forwardRef(() => DatePickerCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DatePickerCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DatePickerCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DatePicker component.\n */\n\n\nlet DatePickerModule = /*#__PURE__*/(() => {\n  class DatePickerModule {}\n\n  DatePickerModule.ɵfac = function DatePickerModule_Factory(t) {\n    return new (t || DatePickerModule)();\n  };\n\n  DatePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DatePickerModule\n  });\n  DatePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: touchEnabled\n    }],\n    imports: [[CommonModule, DateInputModule, CalendarModule, IntlModule, PopupModule, TemplatesModule, EventsModule], TemplatesModule]\n  });\n  return DatePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES$2 = [DateRangeComponent, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeStartInputDirective, DateRangeEndInputDirective];\nconst COMPONENT_MODULES$2 = [MultiViewCalendarModule, DateInputModule, PopupModule, EventsModule];\n/**\n * The exported package module.\n *\n * The package exports:\n * - `DateRangeComponent`&mdash;The DateRange component class.\n * - `DateRangePopupComponent`&mdash;The DateRangePopup component class.\n * - `DateRangeSelectionDirective`&mdash;The MultiviewCalendar date range selection directive.\n * - `DateRangeEndInputDirective`&mdash;The end DateInput date range selection directive.\n * - `DateRangeStartInputDirective`&mdash;The start DateInput date range selection directive.\n * - `DateRangePopupTemplateDirective`&mdash;The DateRangePopup content template directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the DateRange module\n * import { DateRangeModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, DateRangeModule], // import DateRange module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet DateRangeModule = /*#__PURE__*/(() => {\n  class DateRangeModule {}\n\n  DateRangeModule.ɵfac = function DateRangeModule_Factory(t) {\n    return new (t || DateRangeModule)();\n  };\n\n  DateRangeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DateRangeModule\n  });\n  DateRangeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, COMPONENT_MODULES$2]]\n  });\n  return DateRangeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet TimePickerCustomMessagesComponent = /*#__PURE__*/(() => {\n  class TimePickerCustomMessagesComponent extends TimePickerMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  TimePickerCustomMessagesComponent.ɵfac = function TimePickerCustomMessagesComponent_Factory(t) {\n    return new (t || TimePickerCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  TimePickerCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TimePickerCustomMessagesComponent,\n    selectors: [[\"kendo-timepicker-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TimePickerMessages,\n      useExisting: forwardRef(() => TimePickerCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function TimePickerCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return TimePickerCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES$1 = [TimePickerLocalizedMessagesDirective, TimeListComponent, TimePickerCustomMessagesComponent, TimePickerComponent, TimeSelectorLocalizedMessagesDirective, TimeSelectorCustomMessagesComponent, TimeSelectorComponent];\nconst COMPONENT_MODULES$1 = [DateInputModule, IntlModule, PopupModule, VirtualizationModule, EventsModule];\nconst providers = [TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, {\n  provide: TOUCH_ENABLED,\n  useValue: touchEnabled\n}];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the TimePicker component.\n */\n\nlet TimePickerModule = /*#__PURE__*/(() => {\n  class TimePickerModule {}\n\n  TimePickerModule.ɵfac = function TimePickerModule_Factory(t) {\n    return new (t || TimePickerModule)();\n  };\n\n  TimePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TimePickerModule\n  });\n  TimePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: providers,\n    imports: [[CommonModule, ...COMPONENT_MODULES$1]]\n  });\n  return TimePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages ([see example]({% slug globalization_dateinputs %}#toc-custom-messages)).\n */\n\n\nlet DateTimePickerCustomMessagesComponent = /*#__PURE__*/(() => {\n  class DateTimePickerCustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  DateTimePickerCustomMessagesComponent.ɵfac = function DateTimePickerCustomMessagesComponent_Factory(t) {\n    return new (t || DateTimePickerCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1$1.LocalizationService));\n  };\n\n  DateTimePickerCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DateTimePickerCustomMessagesComponent,\n    selectors: [[\"kendo-datetimepicker-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DateTimePickerCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [DateTimePickerComponent, DateTimePickerCustomMessagesComponent, LocalizedMessagesDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the DateTimePicker component.\n */\n\nlet DateTimePickerModule = /*#__PURE__*/(() => {\n  class DateTimePickerModule {}\n\n  DateTimePickerModule.ɵfac = function DateTimePickerModule_Factory(t) {\n    return new (t || DateTimePickerModule)();\n  };\n\n  DateTimePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DateTimePickerModule\n  });\n  DateTimePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: touchEnabled\n    }],\n    imports: [[CommonModule, IntlModule, DateInputModule, CalendarModule, TimePickerModule, PopupModule, EventsModule, TemplatesModule], TemplatesModule]\n  });\n  return DateTimePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_MODULES = [CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Date Inputs components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Date Inputs module\n * import { DateInputsModule } from '@progress/kendo-angular-dateinputs';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DateInputsModule], // import the Date Inputs module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\nlet DateInputsModule = /*#__PURE__*/(() => {\n  class DateInputsModule {}\n\n  DateInputsModule.ɵfac = function DateInputsModule_Factory(t) {\n    return new (t || DateInputsModule)();\n  };\n\n  DateInputsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DateInputsModule\n  });\n  DateInputsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [COMPONENT_MODULES, CalendarsModule, DateInputModule, DatePickerModule, TimePickerModule, DateRangeModule, DateTimePickerModule]\n  });\n  return DateInputsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CalendarCommonModule, CalendarComponent, CalendarCustomMessagesComponent, CalendarLocalizedMessagesDirective, CalendarModule, CalendarsModule, CellTemplateDirective, CenturyCellTemplateDirective, DateInputComponent, DateInputCustomMessagesComponent, DateInputLocalizedMessagesDirective, DateInputModule, DateInputsModule, DatePickerComponent, DatePickerCustomMessagesComponent, DatePickerLocalizedMessagesDirective, DatePickerModule, DateRangeComponent, DateRangeEndInputDirective, DateRangeModule, DateRangePopupComponent, DateRangePopupTemplateDirective, DateRangeSelectionDirective, DateRangeService, DateRangeStartInputDirective, DateTimePickerComponent, DateTimePickerCustomMessagesComponent, DateTimePickerModule, DecadeCellTemplateDirective, HeaderComponent, HeaderTitleTemplateDirective, HorizontalViewListComponent, KForOf, LocalizedMessagesDirective, MonthCellTemplateDirective, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarLocalizedMessagesDirective, MultiViewCalendarModule, NavigationComponent, NavigationItemTemplateDirective, PreventableEvent, TemplatesModule, TimeListComponent, TimePickerComponent, TimePickerCustomMessagesComponent, TimePickerLocalizedMessagesDirective, TimePickerModule, TimeSelectorComponent, TimeSelectorCustomMessagesComponent, TimeSelectorLocalizedMessagesDirective, ViewComponent, ViewListComponent, WeekNumberCellTemplateDirective, YearCellTemplateDirective };","map":null,"metadata":{},"sourceType":"module"}