{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1723);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  957:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.color\");\n    /***/\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  },\n\n  /***/\n  1706:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./references\");\n    /***/\n  },\n\n  /***/\n  1723:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(957), __webpack_require__(1678), __webpack_require__(1724), __webpack_require__(1706)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        /* jshint laxbreak:true, eqnull:true */\n        var RangeRef = kendo.spreadsheet.RangeRef;\n        var UnionRef = kendo.spreadsheet.UnionRef;\n        var CellRef = kendo.spreadsheet.CellRef;\n        var Range = kendo.spreadsheet.Range; // This is a “dynamic variable” (see Greenspun's 10th rule).  It's\n        // bound to an array via sheet._saveModifiedFormulas (which see)\n        // while the callback runs.  The goal is to enable external code\n        // to get a list of formulas or validations that have been\n        // adjusted as an effect of an insert/delete row/column operation,\n        // to be able to undo it.\n        //\n        // The reason why simply saving the state via sheet.getState() or\n        // range.getState() won't suffice is that an insert or delete\n        // operation can have far-reaching effects, like adjusting\n        // formulas from another sheet.\n\n        var MODIFIED_FORMULAS;\n        var Selection = kendo.Class.extend({\n          init: function (sheet) {\n            this._sheet = sheet;\n            this.selection = kendo.spreadsheet.FIRSTREF.toRangeRef();\n            this.originalSelection = kendo.spreadsheet.FIRSTREF.toRangeRef();\n            this._activeCell = kendo.spreadsheet.FIRSTREF.toRangeRef();\n            this.originalActiveCell = kendo.spreadsheet.FIRSTREF;\n          },\n          currentSelectionRange: function () {\n            return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();\n          },\n          currentOriginalNavigationRange: function () {\n            return this.originalSelection.rangeAt(this.selectionRangeIndex).toRangeRef();\n          },\n          currentNavigationRange: function () {\n            if (this.singleCellSelection()) {\n              return this._sheet._sheetRef;\n            } else {\n              return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();\n            }\n          },\n          nextNavigationRange: function () {\n            if (!this.singleCellSelection()) {\n              this.selectionRangeIndex = this.selection.nextRangeIndex(this.selectionRangeIndex);\n            }\n\n            return this.currentNavigationRange();\n          },\n          previousNavigationRange: function () {\n            if (!this.singleCellSelection()) {\n              this.selectionRangeIndex = this.selection.previousRangeIndex(this.selectionRangeIndex);\n            }\n\n            return this.currentNavigationRange();\n          },\n          activeCell: function (ref) {\n            if (ref) {\n              this.originalActiveCell = ref.first();\n              this._activeCell = this._sheet.unionWithMerged(ref.toRangeRef());\n\n              this._sheet.focus(ref);\n\n              this._sheet.triggerChange({\n                activeCell: true,\n                selection: true\n              });\n            }\n\n            return this._activeCell;\n          },\n          select: function (ref, expanded, changeActiveCell, view) {\n            if (ref) {\n              if (ref.eq(this.originalSelection)) {\n                return;\n              }\n\n              this._sheet.triggerSelect(new Range(ref, this._sheet));\n\n              this.originalSelection = ref;\n              this.selection = expanded;\n\n              if (changeActiveCell !== false) {\n                if (ref.isCell()) {\n                  // when selecting part of a merged cell, i.e. A1:B2 is merged and select(B2)\n                  // is requested, mark A1 as the actually active cell.\n                  // https://github.com/telerik/kendo/issues/7698\n                  this._sheet.forEachMergedCell(ref, function (merged) {\n                    ref = merged.topLeft;\n                  });\n\n                  this.activeCell(ref);\n                } else {\n                  ref = this.selection.lastRange();\n\n                  if (view && view._sheet === this._sheet && view.panes[0]) {\n                    // we should intersect this ref with the range that's currently on\n                    // screen, so that the view doesn't scroll (that is, keep the activeCell\n                    // visible) - https://github.com/telerik/kendo-ui-core/issues/5182 —\n                    // XXX: fiddling with View internals here is probably bad practice, but\n                    // this whole thing is a mess already, so it can be forgiven. :-/\n                    var panes = view.panes;\n                    var i, pane, rows, cols, visible, newRef;\n\n                    for (i = 0; i < panes.length; i++) {\n                      pane = panes[i];\n\n                      if (!pane._currentView) {\n                        continue;\n                      }\n\n                      rows = pane._currentView.rows.values;\n                      cols = pane._currentView.columns.values;\n                      visible = new RangeRef(new CellRef(rows.start, cols.start), new CellRef(rows.end, cols.end));\n                      newRef = ref.intersect(visible);\n\n                      if (newRef !== kendo.spreadsheet.NULLREF) {\n                        break;\n                      }\n                    }\n\n                    if (newRef && newRef !== kendo.spreadsheet.NULLREF) {\n                      ref = newRef;\n                    }\n                  }\n\n                  this.activeCell(ref.first());\n                }\n\n                this.selectionRangeIndex = this.selection.size() - 1;\n              } else {\n                this._sheet.triggerChange({\n                  selection: true\n                });\n              }\n            }\n\n            return this.selection;\n          },\n          singleCellSelection: function () {\n            return this._activeCell.eq(this.selection);\n          }\n        });\n        var Sheet = kendo.Observable.extend({\n          init: function () {\n            kendo.Observable.prototype.init.call(this);\n\n            this._reinit.apply(this, arguments);\n          },\n          events: [\"changing\", \"commandRequest\", \"afterInsertRow\", \"afterDeleteRow\", \"insertRow\", \"insertColumn\", \"deleteRow\", \"deleteColumn\", \"hideRow\", \"hideColumn\", \"unhideRow\", \"unhideColumn\", \"select\", \"dataBinding\", \"dataBound\", \"progress\"],\n          _reinit: function (rowCount, columnCount, rowHeight, columnWidth, headerHeight, headerWidth, defaultCellStyle) {\n            defaultCellStyle = defaultCellStyle || {};\n            this._defaultCellStyle = {\n              background: defaultCellStyle.background,\n              color: defaultCellStyle.color,\n              fontFamily: defaultCellStyle.fontFamily,\n              fontSize: defaultCellStyle.fontSize,\n              italic: defaultCellStyle.italic,\n              bold: defaultCellStyle.bold,\n              underline: defaultCellStyle.underline,\n              wrap: defaultCellStyle.wrap,\n              verticalAlign: defaultCellStyle.verticalAlign,\n              textAlign: defaultCellStyle.textAlign\n            };\n            this._rows = new kendo.spreadsheet.Axis(rowCount, rowHeight);\n            this._columns = new kendo.spreadsheet.Axis(columnCount, columnWidth);\n            this._filteredRows = new kendo.spreadsheet.RangeList(0, rowCount - 1, false);\n            this._mergedCells = [];\n            this._frozenRows = 0;\n            this._frozenColumns = 0;\n            this._suspendChanges = false;\n            this._filter = null;\n            this._showGridLines = true;\n            this._gridLinesColor = null;\n            this._grid = new kendo.spreadsheet.Grid(this._rows, this._columns, rowCount, columnCount, headerHeight, headerWidth);\n            this._sheetRef = this._grid.normalize(kendo.spreadsheet.SHEETREF);\n            this._properties = new kendo.spreadsheet.PropertyBag(rowCount, columnCount, this._defaultCellStyle);\n            this._sorter = new kendo.spreadsheet.Sorter(this._grid, this._properties.sortable());\n            this._viewSelection = new Selection(this);\n            this._editSelection = new Selection(this);\n            this._formulaSelections = [];\n            this._drawings = [];\n          },\n          resize: function (newRows, newCols) {\n            newRows = Math.max(newRows, 1);\n            newCols = Math.max(newCols, 1);\n            var oldRows = this._rows._count;\n            var oldCols = this._columns._count;\n\n            if (newRows < oldRows) {\n              this.range(newRows, 0, oldRows - newRows, oldCols).clear();\n            }\n\n            if (newCols < oldCols) {\n              this.range(0, newCols, oldRows, oldCols - newCols).clear();\n            }\n\n            this._rows._resize(newRows);\n\n            this._columns._resize(newCols);\n\n            this._grid._resize(newRows, newCols);\n\n            this._properties._resize(newRows, newCols);\n\n            this._sheetRef = this._grid.normalize(kendo.spreadsheet.SHEETREF);\n\n            if (newRows > oldRows) {\n              this.range(oldRows, 0, newRows - oldRows, newCols).clear();\n\n              this._filteredRows.value(oldRows, newRows - 1, false);\n            }\n\n            if (newCols > oldCols) {\n              this.range(0, oldCols, newRows, newCols - oldCols).clear();\n            }\n\n            this.triggerChange({\n              layout: true\n            });\n          },\n          _resizeAddRow: function (count) {\n            this.resize(this._rows._count + (count || 1), this._columns._count);\n          },\n          _resizeAddColumn: function (count) {\n            this.resize(this._rows._count, this._columns._count + (count || 1));\n          },\n          _resizeDeleteRow: function (count) {\n            this._resizeAddRow(-(count || 1));\n          },\n          _resizeDeleteColumn: function (count) {\n            this._resizeAddColumn(-(count || 1));\n          },\n          _selectionState: function () {\n            return this._inEdit ? this._editSelection : this._viewSelection;\n          },\n          navigator: function () {\n            if (!this._navigator) {\n              this._navigator = new kendo.spreadsheet.SheetNavigator(this);\n            }\n\n            return this._navigator;\n          },\n          axisManager: function () {\n            if (!this._axisManager) {\n              this._axisManager = new kendo.spreadsheet.AxisManager(this);\n            }\n\n            return this._axisManager;\n          },\n          _name: function (value) {\n            if (!value) {\n              return this._sheetName;\n            }\n\n            this._sheetName = value;\n            return this;\n          },\n          name: function () {\n            return this._name();\n          },\n          _property: function (accessor, value, reason) {\n            if (value === undefined) {\n              return accessor();\n            } else {\n              accessor(value);\n              return this.triggerChange(reason);\n            }\n          },\n          _field: function (name, value, reason) {\n            if (value === undefined) {\n              return this[name];\n            } else {\n              this[name] = value;\n              return this.triggerChange(reason);\n            }\n          },\n          suspendChanges: function (value) {\n            if (value === undefined) {\n              return this._suspendChanges;\n            }\n\n            this._suspendChanges = value;\n            return this;\n          },\n          triggerChange: function (reason) {\n            if (!this._suspendChanges) {\n              this.trigger(\"change\", reason);\n            }\n\n            return this;\n          },\n          triggerSelect: function (range) {\n            this.trigger(\"select\", {\n              range: range\n            });\n          },\n          setDataSource: function (dataSource, columns) {\n            if (this.dataSourceBinder) {\n              this.dataSourceBinder.destroy();\n            }\n\n            this.dataSourceBinder = new kendo.spreadsheet.SheetDataSourceBinder({\n              dataSource: dataSource,\n              sheet: this,\n              columns: columns\n            });\n            this.dataSource = this.dataSourceBinder.dataSource;\n          },\n          hideColumn: function (columnIndex) {\n            if (this.trigger(\"hideColumn\", {\n              index: columnIndex\n            })) {\n              return;\n            }\n\n            return this._property(this._columns.hide.bind(this._columns), columnIndex, {\n              layout: true\n            });\n          },\n          unhideColumn: function (columnIndex) {\n            if (this.trigger(\"unhideColumn\", {\n              index: columnIndex\n            })) {\n              return;\n            }\n\n            return this._property(this._columns.unhide.bind(this._columns), columnIndex, {\n              layout: true\n            });\n          },\n          isHiddenColumn: function (columnIndex) {\n            return this._grid._columns.hidden(columnIndex);\n          },\n          _copyRange: function (sourceRangeRef, targetRef) {\n            var grid = this._grid;\n            var rowCount = grid.rowCount;\n            var nextRefTopLeft = grid.normalize(sourceRangeRef.topLeft);\n            var nextRefBottomRight = grid.normalize(sourceRangeRef.bottomRight);\n            var nextIndex = nextRefTopLeft.col * rowCount + nextRefTopLeft.row;\n            var nextBottomIndex = nextRefBottomRight.col * rowCount + nextRefBottomRight.row;\n            var targetIndex = targetRef.col * rowCount + targetRef.row;\n\n            this._properties.copy(nextIndex, nextBottomIndex, targetIndex);\n          },\n          _saveModifiedFormulas: function (array, callback) {\n            var save = MODIFIED_FORMULAS;\n            MODIFIED_FORMULAS = array;\n            var ret = callback();\n            MODIFIED_FORMULAS = save;\n            return ret;\n          },\n          _restoreModifiedFormulas: function (array) {\n            var wb = this._workbook;\n            array.forEach(function (f) {\n              var sheet = wb.sheetByName(f.sheet),\n                  index;\n\n              if (f instanceof kendo.spreadsheet.calc.runtime.Formula) {\n                index = sheet._grid.cellRefIndex(f); // f has row, col\n\n                sheet._properties.set(\"formula\", index, index, f);\n              }\n\n              if (f instanceof kendo.spreadsheet.validation.Validation) {\n                index = sheet._grid.cellRefIndex(f); // f has row, col\n\n                sheet._properties.set(\"validation\", index, index, f);\n              }\n            });\n          },\n          _adjustReferences: function (operation, start, delta, mergedCells) {\n            this._mergedCells = mergedCells.reduce(function (a, ref) {\n              ref = ref.adjust(null, null, null, null, operation == \"row\", start, delta);\n\n              if (ref instanceof RangeRef) {\n                a.push(ref);\n              }\n\n              return a;\n            }, []);\n\n            if (this._workbook) {\n              var affectedSheet = this._name();\n\n              this._workbook._sheets.forEach(function (sheet) {\n                sheet._forFormulas(function (formula) {\n                  var prev = formula.adjust(affectedSheet, operation, start, delta);\n\n                  if (prev && MODIFIED_FORMULAS) {\n                    // if formula.adjust returns non-null,\n                    // that means the formula was indeed\n                    // modified and the returned value is a\n                    // copy of the previous Formula, which we\n                    // can use for undoing the operation.\n                    MODIFIED_FORMULAS.push(prev);\n                  }\n                });\n\n                sheet._forValidations(function (validation) {\n                  var prev = validation.adjust(affectedSheet, operation, start, delta);\n\n                  if (prev && MODIFIED_FORMULAS) {\n                    MODIFIED_FORMULAS.push(prev);\n                  }\n                });\n              });\n\n              this._workbook.adjustNames(affectedSheet, operation == \"row\", start, delta);\n            }\n\n            var selection = this.select();\n            selection = selection.adjust(null, null, null, null, operation == \"row\", start, delta);\n\n            if (selection !== kendo.spreadsheet.NULLREF) {\n              this.select(selection);\n            } // adjust column widths or row heights and hidden attribute\n\n\n            var axis = operation == \"col\" ? this._columns : this._rows;\n            axis.adjust(start, delta);\n\n            if (operation == \"row\") {\n              if (delta < 0) {\n                this._filteredRows.copy(start - delta, this._rows._count - 1, start);\n              } else {\n                this._filteredRows.copy(start, this._rows._count, start + delta);\n\n                this._filteredRows.value(start, start + delta - 1, false);\n              }\n            } // adjust drawing anchor cells\n\n\n            this._drawings.forEach(function (drawing) {\n              if (drawing.topLeftCell) {\n                drawing.topLeftCell = drawing.topLeftCell.adjust(null, null, null, null, operation == \"row\", start, delta);\n              }\n            });\n          },\n          _forFormulas: function (callback) {\n            var props = this._properties;\n            var formulas = props.get(\"formula\").values();\n            var n = formulas.length;\n            formulas.forEach(function (f, i) {\n              callback.call(this, f.value, i, n);\n            }, this);\n          },\n          _forValidations: function (callback) {\n            var props = this._properties;\n            props.get(\"validation\").values().forEach(function (v) {\n              callback.call(this, v.value);\n            }, this);\n          },\n          insertRow: function (rowIndex, skipDataSourceInsert) {\n            if (this.trigger(\"insertRow\", {\n              index: rowIndex\n            })) {\n              return;\n            }\n\n            this.batch(function () {\n              this._resizeAddRow();\n\n              var grid = this._grid;\n              var columnCount = grid.columnCount;\n              var rowCount = grid.rowCount;\n\n              if (rowIndex + 1 == rowCount) {\n                // we just inserted after the last one, no need to shift data\n                return;\n              }\n\n              var frozenRows = this.frozenRows();\n\n              if (rowIndex < frozenRows) {\n                this.frozenRows(frozenRows + 1);\n              }\n\n              var mergedCells = this._mergedCells.slice();\n\n              for (var ci = 0; ci < columnCount; ci++) {\n                var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));\n                var topLeft = grid.normalize(ref.topLeft);\n                var bottomRight = grid.normalize(ref.bottomRight);\n                var nextRef = new RangeRef(new CellRef(topLeft.row, topLeft.col), new CellRef(rowCount - 2, bottomRight.col));\n\n                this._copyRange(nextRef, new CellRef(topLeft.row + 1, topLeft.col));\n\n                new Range(ref, this).clear({\n                  clearAll: true,\n                  keepBorders: true\n                });\n              }\n\n              this._adjustReferences(\"row\", rowIndex, 1, mergedCells);\n            }, {\n              recalc: true,\n              layout: true,\n              insertRow: {\n                index: rowIndex\n              },\n              ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))\n            });\n\n            if (!skipDataSourceInsert) {\n              this.trigger(\"afterInsertRow\", {\n                index: rowIndex\n              });\n            }\n\n            return this;\n          },\n          isEnabledRow: function (rowIndex) {\n            var ref = new RangeRef(new CellRef(rowIndex, 0), new CellRef(rowIndex, this._grid.columnCount));\n            return new Range(ref, this).enable();\n          },\n          deleteRow: function (rowIndex, skipDataSourceDelete) {\n            if (!this.isEnabledRow(rowIndex)) {\n              return this;\n            }\n\n            if (this.trigger(\"deleteRow\", {\n              index: rowIndex\n            })) {\n              return;\n            }\n\n            this.batch(function () {\n              var grid = this._grid;\n              var columnCount = grid.columnCount;\n              var frozenRows = this.frozenRows();\n\n              if (rowIndex < frozenRows) {\n                this.frozenRows(frozenRows - 1);\n              }\n\n              var mergedCells = this._mergedCells.slice();\n\n              for (var ci = 0; ci < columnCount; ci++) {\n                var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));\n                new Range(ref, this).clear({\n                  clearAll: true,\n                  keepBorders: true\n                });\n                var topLeft = grid.normalize(ref.topLeft);\n                var bottomRight = grid.normalize(ref.bottomRight);\n                var nextRef = new RangeRef(new CellRef(topLeft.row + 1, topLeft.col), new CellRef(Infinity, bottomRight.col));\n\n                this._copyRange(nextRef, topLeft);\n\n                var nextRefBottomRight = grid.normalize(nextRef.bottomRight);\n                new Range(new RangeRef(nextRefBottomRight, nextRefBottomRight), this).clear();\n              }\n\n              this._adjustReferences(\"row\", rowIndex, -1, mergedCells);\n\n              this._resizeDeleteRow();\n            }, {\n              recalc: true,\n              layout: true,\n              deleteRow: {\n                index: rowIndex\n              },\n              ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))\n            });\n\n            if (!skipDataSourceDelete) {\n              this.trigger(\"afterDeleteRow\", {\n                index: rowIndex\n              });\n            }\n\n            return this;\n          },\n          insertColumn: function (columnIndex) {\n            if (this.trigger(\"insertColumn\", {\n              index: columnIndex\n            })) {\n              return;\n            }\n\n            this.batch(function () {\n              this._resizeAddColumn();\n\n              var grid = this._grid;\n              var columnCount = grid.columnCount;\n\n              if (columnIndex + 1 == columnCount) {\n                // we just inserted after the last one, no need to shift data\n                return;\n              }\n\n              var frozenColumns = this.frozenColumns();\n\n              if (columnIndex < frozenColumns) {\n                this.frozenColumns(frozenColumns + 1);\n              }\n\n              var mergedCells = this._mergedCells.slice();\n\n              for (var ci = columnCount; ci >= columnIndex; ci--) {\n                var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));\n                new Range(ref, this).clear({\n                  clearAll: true,\n                  keepBorders: true\n                });\n\n                if (ci == columnIndex) {\n                  break;\n                }\n\n                var topLeft = grid.normalize(ref.topLeft);\n                var bottomRight = grid.normalize(ref.bottomRight);\n                var nextRef = new RangeRef(new CellRef(topLeft.row, topLeft.col - 1), new CellRef(bottomRight.row, bottomRight.col - 1));\n\n                this._copyRange(nextRef, topLeft);\n              }\n\n              this._adjustReferences(\"col\", columnIndex, 1, mergedCells);\n            }, {\n              recalc: true,\n              layout: true,\n              insertColumn: {\n                index: columnIndex\n              },\n              ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))\n            });\n            return this;\n          },\n          isEnabledColumn: function (columnIndex) {\n            var ref = new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, columnIndex));\n            return new Range(ref, this).enable();\n          },\n          deleteColumn: function (columnIndex) {\n            if (!this.isEnabledColumn(columnIndex)) {\n              return this;\n            }\n\n            if (this.trigger(\"deleteColumn\", {\n              index: columnIndex\n            })) {\n              return;\n            }\n\n            this.batch(function () {\n              var grid = this._grid;\n              var columnCount = grid.columnCount;\n              var frozenColumns = this.frozenColumns();\n\n              if (columnIndex < frozenColumns) {\n                this.frozenColumns(frozenColumns - 1);\n              }\n\n              var mergedCells = this._mergedCells.slice();\n\n              for (var ci = columnIndex; ci < columnCount; ci++) {\n                var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));\n                new Range(ref, this).clear({\n                  clearAll: true,\n                  keepBorders: true\n                });\n\n                if (ci == columnCount - 1) {\n                  break;\n                }\n\n                var topLeft = grid.normalize(ref.topLeft);\n                var bottomRight = grid.normalize(ref.bottomRight);\n                var nextRef = new RangeRef(new CellRef(topLeft.row, topLeft.col + 1), new CellRef(bottomRight.row, bottomRight.col + 1));\n\n                this._copyRange(nextRef, topLeft);\n              }\n\n              this._adjustReferences(\"col\", columnIndex, -1, mergedCells);\n\n              this._resizeDeleteColumn();\n            }, {\n              recalc: true,\n              layout: true,\n              deleteColumn: {\n                index: columnIndex\n              },\n              ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))\n            });\n            return this;\n          },\n          _filterRow: function (rowIndex) {\n            this._rows.hide(rowIndex);\n\n            this._filteredRows.value(rowIndex, rowIndex, true);\n\n            this.triggerChange({\n              layout: true\n            });\n          },\n          hideRow: function (rowIndex) {\n            if (this.trigger(\"hideRow\", {\n              index: rowIndex\n            })) {\n              return;\n            }\n\n            return this._property(this._rows.hide.bind(this._rows), rowIndex, {\n              layout: true\n            });\n          },\n          unhideRow: function (rowIndex) {\n            if (this.trigger(\"unhideRow\", {\n              index: rowIndex\n            })) {\n              return;\n            }\n\n            return this._property(this._rows.unhide.bind(this._rows), rowIndex, {\n              layout: true\n            });\n          },\n          isHiddenRow: function (rowIndex) {\n            return this._grid._rows.hidden(rowIndex);\n          },\n          isFilteredRow: function (rowIndex) {\n            return this._filteredRows.value(rowIndex);\n          },\n          columnWidth: function (columnIndex, width) {\n            return this._property(this._columns.value.bind(this._columns, columnIndex, columnIndex), width, {\n              layout: true\n            });\n          },\n          rowHeight: function (rowIndex, height) {\n            return this._property(this._rows.value.bind(this._rows, rowIndex, rowIndex), height, {\n              layout: true\n            });\n          },\n          frozenRows: function (value) {\n            return this._field(\"_frozenRows\", value, {\n              layout: true\n            });\n          },\n          frozenColumns: function (value) {\n            return this._field(\"_frozenColumns\", value, {\n              layout: true\n            });\n          },\n          showGridLines: function (value) {\n            return this._field(\"_showGridLines\", value, {\n              layout: true\n            });\n          },\n          gridLinesColor: function (value) {\n            return this._field(\"_gridLinesColor\", value, {\n              layout: true\n            });\n          },\n          _ref: function (row, column, numRows, numColumns) {\n            var ref = null;\n\n            if (row instanceof kendo.spreadsheet.Ref) {\n              return row;\n            }\n\n            if (row instanceof kendo.spreadsheet.Range) {\n              return row._ref.toRangeRef();\n            }\n\n            if (typeof row === \"string\") {\n              ref = kendo.spreadsheet.calc.parseReference(row);\n            } else {\n              if (!numRows) {\n                numRows = 1;\n              }\n\n              if (!numColumns) {\n                numColumns = 1;\n              }\n\n              ref = new RangeRef(new CellRef(row, column), new CellRef(row + numRows - 1, column + numColumns - 1));\n            }\n\n            return ref;\n          },\n          range: function (row, column, numRows, numColumns) {\n            return new Range(this._ref(row, column, numRows, numColumns), this);\n          },\n          _getMergedCells: function (range) {\n            var grid = this._grid;\n            var primary = {};\n            var secondary = {};\n            var hasMerged = false;\n            this.forEachMergedCell(range, function (ref) {\n              var topLeft = ref.topLeft;\n              grid.forEach(ref, function (cellRef) {\n                if (topLeft.eq(cellRef)) {\n                  primary[cellRef.print()] = ref;\n                  hasMerged = true;\n                } else if (range.contains(cellRef)) {\n                  secondary[cellRef.print()] = topLeft;\n                  hasMerged = true;\n                }\n              });\n            });\n            return {\n              primary: primary,\n              secondary: secondary,\n              hasMerged: hasMerged\n            };\n          },\n          forEachMergedCell: function (ref, callback) {\n            var selectAll = false;\n\n            if (typeof callback === \"undefined\") {\n              callback = ref;\n              selectAll = true;\n            }\n\n            this._mergedCells.forEach(function (merged) {\n              if (selectAll || merged.intersects(ref)) {\n                callback(merged);\n              }\n            });\n          },\n          forEachFilterHeader: function (ref, callback) {\n            var selectAll = false;\n\n            if (typeof callback === \"undefined\") {\n              callback = ref;\n              selectAll = true;\n            }\n\n            if (this._filter) {\n              var refs = []; // get refs of all columns\n\n              this._filter.ref.forEachColumn(function (columnRef) {\n                if (selectAll || columnRef.intersects(ref)) {\n                  refs.push(columnRef.topLeft);\n                }\n              }); // filter out merged references\n\n\n              this._mergedCells.forEach(function (merged) {\n                refs = refs.map(function (ref) {\n                  if (merged.intersects(ref)) {\n                    return merged;\n                  }\n\n                  return ref;\n                });\n              }); // use only unique refs\n\n\n              refs.reduce(function unique(result, element) {\n                if (result.indexOf(element) < 0) {\n                  result.push(element);\n                }\n\n                return result;\n              }, []).forEach(callback);\n            }\n          },\n          forEach: function (ref, callback) {\n            var self = this;\n\n            function forEachRange(ref) {\n              if (!(ref instanceof RangeRef)) {\n                ref = ref.toRangeRef();\n              }\n\n              var topLeft = self._grid.normalize(ref.topLeft);\n\n              var bottomRight = self._grid.normalize(ref.bottomRight);\n\n              var ci, ri;\n\n              function doIt(value) {\n                callback(ri++, ci, value);\n              }\n\n              for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n                ri = topLeft.row;\n\n                var startCellIndex = self._grid.index(ri, ci);\n\n                var endCellIndex = self._grid.index(bottomRight.row, ci);\n\n                self._properties.forEach(startCellIndex, endCellIndex, doIt);\n              }\n            }\n\n            if (!(ref instanceof RangeRef)) {\n              ref = self._ref(ref);\n            }\n\n            if (ref instanceof UnionRef) {\n              // _ref() might still return a UnionRef, for instance, if\n              // `ref` happens to be one.  Probably an oversight, but it\n              // turns out to be useful.\n              ref.forEach(forEachRange);\n            } else {\n              forEachRange(ref);\n            }\n          },\n          startResizing: function (initialPosition) {\n            this._initialPosition = initialPosition;\n            this._resizeInProgress = true;\n          },\n          startAutoFill: function () {\n            this._autoFillInProgress = true;\n            var selection = this.select();\n            this._autoFillOrigin = selection;\n            this._autoFillDest = selection;\n            this.triggerChange({\n              selection: true\n            });\n          },\n          updateAutoFill: function (dest, punch, hint, direction) {\n            this._autoFillDest = dest;\n            this._autoFillPunch = punch;\n            this._autoFillHint = hint;\n            this._autoFillDirection = direction;\n            this.triggerChange({\n              selection: true\n            });\n          },\n          autoFillRef: function () {\n            return this._autoFillDest;\n          },\n          autoFillPunch: function () {\n            return this._autoFillPunch;\n          },\n          autoFillInProgress: function () {\n            return this._autoFillInProgress;\n          },\n          resizingInProgress: function () {\n            return this._resizeInProgress;\n          },\n          draggingInProgress: function () {\n            return this._draggingInProgress;\n          },\n          completeResizing: function () {\n            if (this._resizeInProgress) {\n              this._resizeInProgress = false;\n              var hintPosition = this.resizeHintPosition();\n\n              if (this._initialPosition && hintPosition) {\n                var handlePosition = this.resizeHandlePosition();\n\n                if (handlePosition.col !== -Infinity) {\n                  this.trigger(\"commandRequest\", {\n                    command: \"ColumnWidthCommand\",\n                    options: {\n                      target: handlePosition.col,\n                      value: this.columnWidth(handlePosition.col) - (this._initialPosition.x - hintPosition.x)\n                    }\n                  });\n                } else {\n                  this.trigger(\"commandRequest\", {\n                    command: \"RowHeightCommand\",\n                    options: {\n                      target: handlePosition.row,\n                      value: this.rowHeight(handlePosition.row) - (this._initialPosition.y - hintPosition.y)\n                    }\n                  });\n                }\n              } else {\n                this.trigger(\"change\", {\n                  resize: true\n                });\n              }\n            }\n          },\n          _visualRange: function (ref) {\n            var merged = this._mergedCells;\n\n            for (var i = merged.length; --i >= 0;) {\n              if (merged[i].intersects(ref)) {\n                return this.range(merged[i]);\n              }\n            }\n\n            return this.range(ref);\n          },\n          _renderComment: function (ref) {\n            var comment = null;\n\n            if (ref) {\n              var range = this._visualRange(ref);\n\n              comment = range.comment();\n              ref = range._ref.toRangeRef().topLeft;\n            }\n\n            if (comment) {\n              if (!this._commentRef || !ref.eq(this._commentRef)) {\n                this._commentRef = ref;\n                this.trigger(\"change\", {\n                  comment: true\n                });\n              }\n            } else {\n              if (this._commentRef) {\n                this._commentRef = null;\n                this.trigger(\"change\", {\n                  comment: true\n                });\n              }\n            }\n          },\n          resizeHandlePosition: function () {\n            return this._resizeHandlePosition;\n          },\n          resizeHintPosition: function (location) {\n            if (location !== undefined) {\n              this._resizeHintPosition = location;\n              this.trigger(\"change\", {\n                resize: true\n              });\n            }\n\n            return this._resizeHintPosition;\n          },\n          removeResizeHandle: function () {\n            if (this._resizeHandlePosition) {\n              this._resizeHintPosition = undefined;\n              this._resizeHandlePosition = undefined;\n              this._initialPosition = undefined;\n              this.trigger(\"change\", {\n                resize: true\n              });\n            }\n          },\n          positionResizeHandle: function (ref) {\n            this._resizeHandlePosition = ref;\n            this.trigger(\"change\", {\n              resize: true\n            });\n          },\n          startDragging: function (data) {\n            this._draggingInProgress = data;\n          },\n          completeDragging: function () {\n            var drag = this._draggingInProgress;\n\n            if (drag) {\n              this._draggingInProgress = null;\n              var drawing = drag.drawing;\n\n              if (drawing.eq(drag.copy)) {\n                return;\n              }\n\n              if (drawing.topLeftCell) {\n                // adjust reference - in case the top-left corner\n                // was moving, select the cell beneath it.\n                var box = this.drawingBoundingBox(drawing);\n\n                var row = this._rows.indexVisible(box.top);\n\n                var col = this._columns.indexVisible(box.left);\n\n                var ref = new CellRef(row, col);\n                var refBox = this.refBoundingBox(ref);\n                drawing.offsetX = box.left - refBox.left;\n                drawing.offsetY = box.top - refBox.top;\n                drawing.topLeftCell = ref;\n                this.triggerChange({\n                  dragging: true\n                });\n              }\n\n              this.trigger(\"commandRequest\", {\n                command: \"DrawingUpdateCommand\",\n                options: {\n                  sheet: this,\n                  drawing: drawing,\n                  previous: drag.copy\n                }\n              });\n            }\n          },\n          startSelection: function (view) {\n            if (this.frozenRows() || this.frozenColumns()) {\n              this._currentView = null;\n            } else if (view && view._sheet === this) {\n              this._currentView = view;\n            }\n\n            this._selectionInProgress = true;\n          },\n          completeSelection: function () {\n            if (this._selectionInProgress) {\n              this._selectionInProgress = false;\n              this._resizeHintPosition = undefined;\n              this.trigger(\"change\", {\n                selection: true\n              });\n            }\n\n            if (this._autoFillInProgress) {\n              this._autoFillInProgress = false;\n              var dest = this._autoFillDest;\n              var origin = this._autoFillOrigin;\n\n              if (this._autoFillPunch) {\n                // we just clear data here\n                this.trigger(\"commandRequest\", {\n                  command: \"ClearContentCommand\",\n                  options: {\n                    operatingRange: this.range(this._autoFillPunch)\n                  }\n                });\n              } else {\n                if (!dest.eq(origin)) {\n                  this.trigger(\"commandRequest\", {\n                    command: \"AutoFillCommand\",\n                    options: {\n                      operatingRange: this.range(dest),\n                      origin: this.range(origin)\n                    }\n                  });\n                } else {\n                  this.triggerChange({\n                    selection: true\n                  });\n                }\n              }\n\n              this._autoFillDest = null;\n              this._autoFillPunch = null;\n              this._autoFillOrigin = null;\n              this.select(dest);\n            }\n          },\n          selectionInProgress: function () {\n            return this._selectionInProgress;\n          },\n          select: function (ref, changeActiveCell) {\n            var selectionState = this._selectionState();\n\n            var expandedRef;\n\n            if (ref) {\n              ref = this._ref(ref);\n              ref = this._grid.normalize(ref);\n              expandedRef = this._grid.isAxis(ref) ? ref : this.unionWithMerged(ref);\n            }\n\n            return selectionState.select(ref, expandedRef, changeActiveCell, this._currentView);\n          },\n          originalSelect: function () {\n            return this._selectionState().originalSelection;\n          },\n          currentSelectionRange: function () {\n            return this._selectionState().currentSelectionRange();\n          },\n          currentOriginalSelectionRange: function () {\n            return this._selectionState().currentOriginalNavigationRange();\n          },\n          currentNavigationRange: function () {\n            return this._selectionState().currentNavigationRange();\n          },\n          nextNavigationRange: function () {\n            return this._selectionState().nextNavigationRange();\n          },\n          previousNavigationRange: function () {\n            return this._selectionState().previousNavigationRange();\n          },\n          selectionRangeIndex: function () {\n            return this._selectionState().selectionRangeIndex;\n          },\n          activeCell: function (ref) {\n            return this._selectionState().activeCell(ref);\n          },\n          originalActiveCell: function () {\n            return this._selectionState().originalActiveCell;\n          },\n          singleCellSelection: function () {\n            return this._selectionState().singleCellSelection();\n          },\n          unionWithMerged: function (ref) {\n            var mergedCells = this._mergedCells;\n            return ref.map(function (ref) {\n              return ref.toRangeRef().union(mergedCells);\n            });\n          },\n          trim: function (ref) {\n            var trims = [];\n            var grid = this._grid;\n\n            this._properties.forEachProperty(function (property) {\n              trims.push(grid.trim(ref, property.list));\n            });\n\n            return this.unionWithMerged(ref.topLeft.toRangeRef().union(trims));\n          },\n          focus: function (ref) {\n            if (ref) {\n              this._focus = ref.toRangeRef();\n            } else {\n              var focus = this._focus;\n              this._focus = null;\n              return focus;\n            }\n          },\n          activeCellSelection: function () {\n            return new Range(this._grid.normalize(this.activeCell()), this);\n          },\n          selection: function () {\n            return new Range(this._grid.normalize(this._selectionState().selection), this);\n          },\n          selectedHeaders: function () {\n            var selection = this.select();\n            var rows = {};\n            var cols = {};\n            var allCols = false;\n            var allRows = false;\n            var maxRow = this._grid.rowCount - 1;\n            var maxCol = this._grid.columnCount - 1;\n            selection.forEach(function (ref) {\n              var i;\n              var rowState = \"partial\";\n              var colState = \"partial\";\n              ref = ref.toRangeRef();\n              var bottomRight = ref.bottomRight;\n              var topLeft = ref.topLeft;\n              var rowSelection = topLeft.col <= 0 && bottomRight.col >= maxCol;\n              var colSelection = topLeft.row <= 0 && bottomRight.row >= maxRow;\n\n              if (colSelection) {\n                //column selection\n                allRows = true;\n                colState = \"full\";\n              }\n\n              if (rowSelection) {\n                //row selection\n                allCols = true;\n                rowState = \"full\";\n              }\n\n              if (!colSelection) {\n                //column selection\n                for (i = topLeft.row; i <= bottomRight.row; i++) {\n                  if (rows[i] !== \"full\") {\n                    rows[i] = rowState;\n                  }\n                }\n              }\n\n              if (!rowSelection) {\n                for (i = topLeft.col; i <= bottomRight.col; i++) {\n                  if (cols[i] !== \"full\") {\n                    cols[i] = colState;\n                  }\n                }\n              }\n            });\n            return {\n              rows: rows,\n              cols: cols,\n              allRows: allRows,\n              allCols: allCols,\n              all: allRows && allCols\n            };\n          },\n          isInEditMode: function (isInEdit) {\n            if (isInEdit === undefined) {\n              return this._inEdit;\n            }\n\n            this._inEdit = isInEdit;\n\n            if (isInEdit) {\n              this._editSelection.selection = this._viewSelection.selection.clone();\n              this._editSelection.originalSelection = this._viewSelection.originalSelection.clone();\n              this._editSelection._activeCell = this._viewSelection._activeCell.clone();\n              this._editSelection.originalActiveCell = this._viewSelection.originalActiveCell.clone();\n            }\n          },\n          _setFormulaSelections: function (selection) {\n            this._formulaSelections = (selection || []).slice();\n            this.triggerChange({\n              selection: true\n            });\n          },\n          _viewActiveCell: function () {\n            return this._viewSelection._activeCell.toRangeRef();\n          },\n          toJSON: function () {\n            var positions = {};\n\n            var rows = this._rows.toJSON(\"height\", positions);\n\n            var columns = this._columns.toJSON(\"width\", {});\n\n            var viewSelection = this._viewSelection;\n            var hyperlinks = [];\n            var defaultCellStyle = this._defaultCellStyle || {};\n\n            function clearDefaultStyle(cell) {\n              Object.keys(defaultCellStyle).forEach(function (key) {\n                if (cell[key] === defaultCellStyle[key]) {\n                  delete cell[key];\n                }\n              });\n            }\n\n            this.forEach(kendo.spreadsheet.SHEETREF, function (row, col, cell) {\n              clearDefaultStyle(cell);\n\n              if (Object.keys(cell).length === 0) {\n                return;\n              }\n\n              if (cell.link) {\n                hyperlinks.push({\n                  ref: kendo.spreadsheet.Ref.display(null, row, col),\n                  target: cell.link\n                });\n              }\n\n              var position = positions[row];\n\n              if (position === undefined) {\n                position = rows.length;\n                rows.push({\n                  index: row\n                });\n                positions[row] = position;\n              }\n\n              row = rows[position];\n              cell.index = col;\n\n              if (row.cells === undefined) {\n                row.cells = [];\n              }\n\n              if (cell.formula) {\n                // stringify Formula object.\n                if (cell.formula.arrayFormulaRange) {\n                  cell.formula = {\n                    src: cell.formula.toString(),\n                    ref: cell.formula.arrayFormulaRange.toString()\n                  };\n                } else {\n                  cell.formula = cell.formula.toString();\n                }\n              }\n\n              if (cell.validation) {\n                cell.validation = cell.validation.toJSON();\n              }\n\n              if (cell.color) {\n                cell.color = kendo.parseColor(cell.color).toCss();\n              }\n\n              if (cell.background) {\n                cell.background = kendo.parseColor(cell.background).toCss();\n              }\n\n              if (cell.borderTop && cell.borderTop.color) {\n                cell.borderTop.color = kendo.parseColor(cell.borderTop.color).toCss();\n              }\n\n              if (cell.borderBottom && cell.borderBottom.color) {\n                cell.borderBottom.color = kendo.parseColor(cell.borderBottom.color).toCss();\n              }\n\n              if (cell.borderRight && cell.borderRight.color) {\n                cell.borderRight.color = kendo.parseColor(cell.borderRight.color).toCss();\n              }\n\n              if (cell.borderLeft && cell.borderLeft.color) {\n                cell.borderLeft.color = kendo.parseColor(cell.borderLeft.color).toCss();\n              }\n\n              row.cells.push(cell);\n            });\n            var json = {\n              name: this._name(),\n              rows: rows,\n              columns: columns,\n              selection: viewSelection.selection.toString(),\n              activeCell: viewSelection.activeCell().toString(),\n              frozenRows: this.frozenRows(),\n              frozenColumns: this.frozenColumns(),\n              showGridLines: this.showGridLines(),\n              gridLinesColor: this.gridLinesColor(),\n              mergedCells: this._mergedCells.map(function (ref) {\n                return ref.toString();\n              }),\n              hyperlinks: hyperlinks,\n              defaultCellStyle: defaultCellStyle,\n              drawings: this._drawings.map(function (dr) {\n                return dr.toJSON();\n              })\n            };\n\n            if (this._sort) {\n              json.sort = {\n                ref: this._sort.ref.toString(),\n                columns: this._sort.columns.map(function (column) {\n                  return {\n                    index: column.index,\n                    ascending: column.ascending\n                  };\n                })\n              };\n            }\n\n            if (this._filter) {\n              json.filter = {\n                ref: this._filter.ref.toString(),\n                columns: this._filter.columns.map(function (column) {\n                  var filter = column.filter.toJSON();\n                  filter.index = column.index;\n                  return filter;\n                })\n              };\n            }\n\n            return json;\n          },\n          fromJSON: function (json) {\n            this.batch(function () {\n              if (json.name !== undefined) {\n                this._name(json.name);\n              }\n\n              if (json.frozenColumns !== undefined) {\n                this.frozenColumns(json.frozenColumns);\n              }\n\n              if (json.frozenRows !== undefined) {\n                this.frozenRows(json.frozenRows);\n              }\n\n              if (json.columns !== undefined) {\n                this._columns.fromJSON(\"width\", json.columns);\n              }\n\n              if (json.rows !== undefined) {\n                this._rows.fromJSON(\"height\", json.rows);\n\n                for (var ri = 0; ri < json.rows.length; ri++) {\n                  var row = json.rows[ri];\n                  var rowIndex = row.index;\n\n                  if (rowIndex === undefined) {\n                    rowIndex = ri;\n                  }\n\n                  if (row.cells) {\n                    for (var ci = 0; ci < row.cells.length; ci++) {\n                      var cell = row.cells[ci];\n                      var columnIndex = cell.index;\n\n                      if (columnIndex === undefined) {\n                        columnIndex = ci;\n                      }\n\n                      if (cell.formula) {\n                        var isArray = typeof cell.formula != \"string\";\n                        var src = isArray ? cell.formula.src : cell.formula;\n\n                        var formula = this._compileFormula(rowIndex, columnIndex, src);\n\n                        if (isArray) {\n                          formula.setArrayFormulaRange(kendo.spreadsheet.calc.parseReference(cell.formula.ref));\n                        }\n\n                        cell.formula = formula;\n                      }\n\n                      if (cell.validation) {\n                        cell.validation = this._compileValidation(rowIndex, columnIndex, cell.validation);\n                      }\n\n                      this._properties.fromJSON(this._grid.index(rowIndex, columnIndex), cell);\n                    }\n                  }\n                }\n              }\n\n              if (json.drawings) {\n                this._drawings = json.drawings.map(Drawing.fromJSON);\n              }\n\n              if (json.selection) {\n                this._viewSelection.selection = this._viewSelection.originalSelection = this._ref(json.selection);\n              }\n\n              if (json.activeCell) {\n                var activeCellRef = this._ref(json.activeCell);\n\n                this._viewSelection._activeCell = activeCellRef.toRangeRef();\n                this._viewSelection.originalActiveCell = activeCellRef.first();\n              }\n\n              if (json.mergedCells) {\n                json.mergedCells.forEach(function (ref) {\n                  this.range(ref).merge();\n                }, this);\n              }\n\n              if (json.sort) {\n                this._sort = {\n                  ref: this._ref(json.sort.ref),\n                  columns: json.sort.columns.slice(0)\n                };\n              }\n\n              if (json.filter) {\n                var ref = json.filter.ref;\n                var columns = json.filter.columns === undefined ? [] : json.filter.columns;\n\n                if (!ref) {\n                  kendo.logToConsole(\"Dropping filter for sheet '\" + json.name + \"' due to missing ref\");\n                } else {\n                  this._filter = {\n                    ref: this._ref(ref),\n                    columns: columns.map(function (column) {\n                      return {\n                        index: column.index,\n                        filter: kendo.spreadsheet.Filter.create(column)\n                      };\n                    })\n                  };\n\n                  this._refreshFilter();\n                }\n              }\n\n              if (json.showGridLines !== undefined) {\n                this._showGridLines = json.showGridLines;\n              }\n\n              this._gridLinesColor = json.gridLinesColor;\n            });\n\n            this._rows._refresh();\n\n            this._columns._refresh();\n          },\n          formula: function (ref) {\n            return this._properties.get(\"formula\", this._grid.cellRefIndex(ref));\n          },\n          validation: function (ref) {\n            return this._properties.get(\"validation\", this._grid.cellRefIndex(ref));\n          },\n          // NOTE: resetFormulas should be called first.  We don't do it in this\n          // function because it should be done from the Workbook object for all\n          // sheets.\n          resetFormulas: function () {\n            this._forFormulas(function (formula) {\n              formula.reset();\n            });\n          },\n          resetValidations: function () {\n            this._forValidations(function (validation) {\n              validation.reset();\n            });\n          },\n          recalc: function (context, callback) {\n            var formulas = this._properties.get(\"formula\").values();\n\n            var count = formulas.length,\n                pending = 0,\n                i = 0;\n\n            if (!count && callback) {\n              return callback();\n            }\n\n            function next() {\n              pending--;\n\n              if (i == count && !pending) {\n                callback();\n              }\n            }\n\n            while (i < count) {\n              pending++;\n              formulas[i++].value.exec(context, callback ? next : null);\n            }\n          },\n          revalidate: function (context) {\n            var self = this;\n\n            this._forValidations(function (validation) {\n              var cellRef = new CellRef(validation.row, validation.col);\n              var ref = new RangeRef(cellRef, cellRef);\n              validation.exec(context, self._get(ref, \"value\"), self._get(ref, \"format\"));\n            });\n          },\n          _value: function (row, col, value) {\n            var index = this._grid.index(row, col);\n\n            if (value !== undefined) {\n              this._properties.set(\"value\", index, index, value);\n            } else {\n              return this._properties.get(\"value\", index);\n            }\n          },\n          _validation: function (row, col) {\n            var index = this._grid.index(row, col);\n\n            return this._properties.get(\"validation\", index);\n          },\n          _compileValidation: function (row, col, validation) {\n            if (validation instanceof kendo.spreadsheet.validation.Validation) {\n              // do not alter an existing object.\n              return validation.clone(this._name(), row, col);\n            }\n\n            if (validation.from != null) {\n              // jshint ignore: line\n              validation.from = (validation.from + \"\").replace(/^=/, \"\");\n            }\n\n            if (validation.to != null) {\n              // jshint ignore: line\n              validation.to = (validation.to + \"\").replace(/^=/, \"\");\n            }\n\n            return kendo.spreadsheet.validation.compile(this._name(), row, col, validation);\n          },\n          _compileFormula: function (row, col, f) {\n            f = f.replace(/^=/, \"\");\n            f = kendo.spreadsheet.calc.parseFormula(this._name(), row, col, f);\n            return kendo.spreadsheet.calc.compile(f);\n          },\n          _copyValuesInRange: function (topLeft, bottomRight, value, property) {\n            var ci, start, end;\n\n            for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n              start = this._grid.index(topLeft.row, ci);\n              end = this._grid.index(bottomRight.row, ci);\n\n              for (var index = start, row = topLeft.row; index <= end; ++index, ++row) {\n                // Even if it's the same formula in multiple cells, we\n                // need to have different Formula objects, hence cloning\n                // it.  Don't worry, clone() is fast.\n                value = value.clone(this._name(), row, ci);\n\n                this._properties.set(property, index, index, value);\n              }\n            }\n\n            return value;\n          },\n          _set: function (ref, name, value) {\n            var topLeft = this._grid.normalize(ref.topLeft);\n\n            var bottomRight = this._grid.normalize(ref.bottomRight);\n\n            var ci, start, end;\n\n            if (typeof value == \"number\") {\n              // Apparently, Excel (and LibreOffice and Google\n              // Sheets) will limit precision to 14 digits; type:\n              // -4.2524999999999995 and you get -4.2525.  The\n              // formula engine already does something similar for\n              // intermediate formula results, but we must do it\n              // here as well for original input values.\n              value = kendo.spreadsheet.calc.runtime.limitPrecision(value);\n            }\n\n            if (value && name == \"formula\") {\n              if (typeof value == \"string\") {\n                // get Formula object.  we don't care about handling errors\n                // here since it won't be called interactively.\n                value = this._compileFormula(topLeft.row, topLeft.col, value);\n              }\n\n              value = this._copyValuesInRange(topLeft, bottomRight, value, \"formula\");\n            } else if (value && name == \"validation\") {\n              value = this._compileValidation(topLeft.row, topLeft.col, value);\n              value = this._copyValuesInRange(topLeft, bottomRight, value, \"validation\");\n            } else {\n              for (ci = topLeft.col; ci <= bottomRight.col; ci++) {\n                start = this._grid.index(topLeft.row, ci);\n                end = this._grid.index(bottomRight.row, ci);\n\n                this._properties.set(name, start, end, value);\n\n                if (name == \"formula\") {\n                  // removing a formula, must clear value.\n                  this._properties.set(\"value\", start, end, null);\n                }\n              }\n            }\n          },\n          _get: function (ref, name) {\n            var topLeft = this._grid.normalize(ref.topLeft);\n\n            var index = this._grid.index(topLeft.row, topLeft.col);\n\n            return this._properties.get(name, index);\n          },\n          batch: function (callback, reason) {\n            var suspended = this.suspendChanges();\n            this.suspendChanges(true);\n            callback.call(this);\n            return this.suspendChanges(suspended).triggerChange(reason || {\n              recalc: true\n            });\n          },\n          _sortBy: function (ref, columns) {\n            var indices = null;\n            columns.forEach(function (column) {\n              indices = this._sorter.sortBy(ref, column.index, this._properties.get(\"value\"), column.ascending, indices);\n            }, this);\n            this._sort = {\n              ref: ref,\n              columns: columns\n            };\n\n            this._refreshFilter();\n\n            this.forEach(ref, function (row, col, props) {\n              var formula = props.formula;\n\n              if (formula) {\n                var diff = row - formula.row;\n\n                if (diff !== 0) {\n                  var start = diff > 0 ? formula.row : formula.row + diff;\n                  formula.adjust(this.name(), \"row\", start, diff);\n                }\n              }\n            }.bind(this));\n            this.triggerChange({\n              recalc: true\n            });\n          },\n          _refreshFilter: function () {\n            if (this._filter) {\n              this._filterBy(this._filter.ref, this._filter.columns);\n            }\n          },\n          _filterBy: function (ref, columns) {\n            this.batch(function () {\n              for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {\n                if (this.isFilteredRow(ri)) {\n                  this._filteredRows.value(ri, ri, false);\n\n                  this._rows.unhide(ri);\n                }\n              }\n\n              columns.forEach(function (column) {\n                // do not filter header row\n                var columnRef = ref.resize({\n                  top: 1\n                }).toColumn(column.index);\n                var cells = [];\n\n                if (columnRef === kendo.spreadsheet.NULLREF) {\n                  return;\n                }\n\n                this.forEach(columnRef, function (row, col, cell) {\n                  cell.row = row;\n                  cells.push(cell);\n                });\n                column.filter.prepare(cells);\n\n                for (var ci = 0; ci < cells.length; ci++) {\n                  var cell = cells[ci];\n                  var value = column.filter.value(cell);\n\n                  if (column.filter.matches(value) === false) {\n                    this._filterRow(cell.row);\n                  }\n                }\n              }, this);\n              this._filter = {\n                ref: ref,\n                columns: columns\n              };\n            }, {\n              recalc: true,\n              layout: true,\n              filter: true\n            });\n          },\n          filterColumn: function (ref) {\n            var filterRef = this.filter().ref;\n            return ref.toRangeRef().topLeft.col - filterRef.topLeft.col;\n          },\n          filter: function () {\n            return this._filter;\n          },\n          clearFilter: function (spec) {\n            this._clearFilter(spec instanceof Array ? spec : [spec]);\n          },\n          _clearFilter: function (indices) {\n            if (this._filter) {\n              this.batch(function () {\n                this._filter.columns = this._filter.columns.filter(function (column) {\n                  return indices.indexOf(column.index) < 0;\n                });\n\n                this._refreshFilter();\n              }, {\n                recalc: true,\n                layout: true,\n                filter: true\n              });\n            }\n          },\n          getAxisState: function () {\n            return {\n              rows: this._rows.getState(),\n              columns: this._columns.getState()\n            };\n          },\n          setAxisState: function (state) {\n            this._rows.setState(state.rows);\n\n            this._columns.setState(state.columns);\n\n            this.triggerChange({\n              layout: true\n            });\n          },\n          getState: function () {\n            return {\n              rows: this._rows.getState(),\n              columns: this._columns.getState(),\n              mergedCells: this._mergedCells.map(function (cell) {\n                return cell.clone();\n              }),\n              properties: this._properties.getState()\n            };\n          },\n          setState: function (state) {\n            this._rows.setState(state.rows);\n\n            this._columns.setState(state.columns);\n\n            this._mergedCells = state.mergedCells;\n\n            this._properties.setState(state.properties);\n\n            this.triggerChange(kendo.spreadsheet.ALL_REASONS);\n          },\n          _merge: function (ref) {\n            var mergedCells = this._mergedCells;\n            var sheet = this;\n            var mergedRef;\n            this.batch(function () {\n              mergedRef = ref.map(function (ref) {\n                if (ref instanceof kendo.spreadsheet.CellRef) {\n                  return ref;\n                }\n\n                var currentRef = ref.toRangeRef().union(mergedCells, function (ref) {\n                  mergedCells.splice(mergedCells.indexOf(ref), 1);\n                });\n                var range = new Range(currentRef, sheet);\n\n                var formula = range._get(\"formula\");\n\n                var value = range.value();\n                var format = range.format();\n                var background = range.background();\n                range.value(null);\n                range.format(null);\n                range.background(null);\n                var topLeft = new Range(currentRef.collapse(), sheet);\n\n                if (formula) {\n                  topLeft._set(\"formula\", formula);\n                } else {\n                  topLeft.value(value);\n                }\n\n                topLeft.format(format);\n                topLeft.background(background);\n                mergedCells.push(currentRef);\n                return currentRef;\n              });\n              var viewSelection = sheet._viewSelection;\n              viewSelection.selection = sheet.unionWithMerged(viewSelection.originalSelection);\n              viewSelection._activeCell = sheet.unionWithMerged(viewSelection.originalActiveCell);\n            }, {\n              activeCell: true,\n              selection: true\n            });\n            return mergedRef;\n          },\n          _useCultureDecimals: function () {\n            return this._workbook && this._workbook.options.useCultureDecimals;\n          },\n          withCultureDecimals: function (f) {\n            var dot = \".\";\n\n            if (this._useCultureDecimals()) {\n              dot = kendo.culture().numberFormat[\".\"];\n            }\n\n            return kendo.spreadsheet.calc.withDecimalSeparator(dot, f);\n          },\n          drawingBoundingBox: function (drawing) {\n            var left = drawing.offsetX;\n            var top = drawing.offsetY;\n\n            if (drawing.topLeftCell) {\n              // offsets are relative to cell\n              left += this._columns.sum(0, drawing.topLeftCell.col - 1);\n              top += this._rows.sum(0, drawing.topLeftCell.row - 1);\n            }\n\n            return new kendo.spreadsheet.Rectangle(left, top, drawing.width, drawing.height);\n          },\n          refBoundingBox: function (ref) {\n            return this._grid.rectangle(ref.toRangeRef());\n          },\n          addDrawing: function (drw, activate) {\n            if (!(drw instanceof Drawing)) {\n              drw = new Drawing(drw);\n            }\n\n            this._drawings.push(drw);\n\n            if (activate) {\n              this._activeDrawing = drw;\n            }\n\n            this.triggerChange({\n              layout: true\n            });\n            return drw;\n          },\n          removeDrawing: function (drawing) {\n            var pos = this._drawings.indexOf(drawing);\n\n            if (pos >= 0) {\n              this._drawings.splice(pos, 1);\n\n              this.triggerChange({\n                layout: true\n              });\n            }\n          },\n          usesImage: function (img) {\n            for (var i = this._drawings.length; --i >= 0;) {\n              if (this._drawings[i].image === img) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          isMerged: function (ref) {\n            var merged = this._mergedCells;\n\n            for (var i = merged.length; --i >= 0;) {\n              if (merged[i].eq(ref)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        var Drawing = kendo.Class.extend({\n          init: function Drawing(args) {\n            this.reset(args);\n          },\n          toJSON: function () {\n            return {\n              topLeftCell: this.topLeftCell.toString(),\n              offsetX: this.offsetX,\n              offsetY: this.offsetY,\n              width: this.width,\n              height: this.height,\n              image: this.image,\n              opacity: this.opacity\n            };\n          },\n          clone: function () {\n            return new Drawing(this);\n          },\n          reset: function (dr) {\n            var anchor = dr.topLeftCell;\n\n            if (typeof anchor == \"string\") {\n              anchor = kendo.spreadsheet.calc.parseReference(anchor);\n            }\n\n            this.topLeftCell = anchor;\n            this.offsetX = dr.offsetX || 0;\n            this.offsetY = dr.offsetY || 0;\n            this.width = dr.width;\n            this.height = dr.height;\n            this.image = dr.image;\n            this.opacity = dr.opacity != null ? dr.opacity : 1;\n          },\n          eq: function (dr) {\n            return (!this.topLeftCell && !dr.topLeftCell || this.topLeftCell && dr.topLeftCell && this.topLeftCell.eq(dr.topLeftCell)) && this.offsetX === dr.offsetX && this.offsetY === dr.offsetY && this.width === dr.width && this.height === dr.height && this.image === dr.image && this.opacity === dr.opacity;\n          }\n        });\n\n        Drawing.fromJSON = function (args) {\n          return new Drawing(args);\n        };\n\n        kendo.spreadsheet.Sheet = Sheet;\n        kendo.spreadsheet.Drawing = Drawing;\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1724:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./validation\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}