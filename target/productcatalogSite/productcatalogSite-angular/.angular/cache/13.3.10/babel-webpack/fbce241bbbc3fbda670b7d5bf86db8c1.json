{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(917);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  891:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  896:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.core\");\n    /***/\n  },\n\n  /***/\n  897:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.color\");\n    /***/\n  },\n\n  /***/\n  917:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /***********************************************************************\n    * WARNING: this file is auto-generated.  If you change it directly,\n    * your modifications will eventually be lost.  The source code is in\n    * `kendo-charts` repository, you should make your changes there and\n    * run `src-modules/sync.sh` in this repository.\n    */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(896), __webpack_require__(897), __webpack_require__(893), __webpack_require__(891)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        window.kendo.dataviz = window.kendo.dataviz || {};\n        var dataviz = kendo.dataviz;\n        var getSpacing = dataviz.getSpacing;\n        var defined = dataviz.defined;\n        var constants = dataviz.constants;\n        var BLACK = constants.BLACK;\n        var COORD_PRECISION = constants.COORD_PRECISION;\n        var services = dataviz.services;\n        var deepExtend = dataviz.deepExtend;\n        var isArray = dataviz.isArray;\n        var setDefaultOptions = dataviz.setDefaultOptions;\n        var NumericAxis = dataviz.NumericAxis;\n        var limitValue = dataviz.limitValue;\n        var Box = dataviz.Box;\n        var interpolateValue = dataviz.interpolateValue;\n        var round = dataviz.round;\n        var drawing = kendo.drawing;\n        var DrawingGroup = drawing.Group;\n        var DrawingPath = drawing.Path;\n        var Animation = drawing.Animation;\n        var AnimationFactory = drawing.AnimationFactory;\n        var geometry = kendo.geometry;\n        var Rect = geometry.Rect;\n        var GeometryPoint = geometry.Point;\n        var transform = geometry.transform;\n        var ANGULAR_SPEED = 150;\n        var LINEAR_SPEED = 250;\n        var ARROW = \"arrow\";\n        var ARROW_POINTER = \"arrowPointer\";\n        var BAR_POINTER = \"barPointer\";\n        var DEFAULT_HEIGHT = 200;\n        var DEFAULT_LINE_WIDTH = 0.5;\n        var DEFAULT_WIDTH = 200;\n        var DEGREE = Math.PI / 180;\n        var INSIDE = \"inside\";\n        var LINEAR = \"linear\";\n        var OUTSIDE = \"outside\";\n        var RADIAL_POINTER = \"radialPointer\";\n        var RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\n        function pad(bbox, value) {\n          var origin = bbox.getOrigin();\n          var size = bbox.getSize();\n          var spacing = getSpacing(value);\n          bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);\n          bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);\n          return bbox;\n        }\n\n        var Group = DrawingGroup;\n        var Path$1 = DrawingPath;\n        var Text = drawing.Text;\n\n        function buildLabelElement(label, options) {\n          var labelBox = label.box;\n          var textBox = label.children[0].box;\n          var border = options.border || {};\n          var background = options.background || \"\";\n          var wrapper = Path$1.fromRect(new Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {\n            stroke: {}\n          });\n          var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n            font: options.font,\n            fill: {\n              color: options.color\n            }\n          });\n          var styleGeometry = pad(text.bbox().clone(), options.padding);\n          var styleBox = Path$1.fromRect(styleGeometry, {\n            stroke: {\n              color: border.width ? border.color : \"\",\n              width: border.width,\n              opacity: border.opacity,\n              dashType: border.dashType,\n              lineJoin: \"round\",\n              lineCap: \"round\"\n            },\n            fill: {\n              color: background\n            }\n          });\n          var elements = new Group();\n          elements.append(wrapper);\n          elements.append(styleBox);\n          elements.append(text);\n          return elements;\n        }\n\n        function getRange(range, min, max) {\n          var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n          var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n          range.from = Math.max(Math.min(to, from), min);\n          range.to = Math.min(Math.max(to, from), max);\n          return range;\n        }\n\n        function unpad(bbox, value) {\n          var spacing = getSpacing(value);\n          spacing.left = -spacing.left;\n          spacing.top = -spacing.top;\n          spacing.right = -spacing.right;\n          spacing.bottom = -spacing.bottom;\n          return pad(bbox, spacing);\n        }\n\n        var DEFAULT_MARGIN = 5;\n        var Path = DrawingPath;\n        var Surface = drawing.Surface;\n        var Gauge = dataviz.Class.extend({\n          init: function (element, userOptions, theme, context) {\n            if (context === void 0) {\n              context = {};\n            }\n\n            this.element = element;\n            this.theme = theme;\n            this.contextService = new services.ChartService(this, context);\n            this._originalOptions = deepExtend({}, this.options, userOptions);\n            this.options = deepExtend({}, this._originalOptions);\n\n            this._initTheme(theme);\n\n            this.redraw();\n          },\n          destroy: function () {\n            if (this.surface) {\n              this.surface.destroy();\n              this.surface = null;\n            }\n\n            delete this.element;\n            delete this.surfaceElement;\n          },\n          value: function (pointerValue) {\n            var pointer = this.pointers[0];\n\n            if (arguments.length === 0) {\n              return pointer.value();\n            }\n\n            pointer.value(pointerValue);\n\n            this._setValueOptions(pointerValue);\n          },\n          _draw: function () {\n            var surface = this.surface;\n            surface.clear();\n            surface.draw(this._visuals);\n          },\n          exportVisual: function () {\n            return this._visuals;\n          },\n          allValues: function (values) {\n            var pointers = this.pointers;\n            var allValues = [];\n\n            if (arguments.length === 0) {\n              for (var i = 0; i < pointers.length; i++) {\n                allValues.push(pointers[i].value());\n              }\n\n              return allValues;\n            }\n\n            if (isArray(values)) {\n              for (var i$1 = 0; i$1 < values.length; i$1++) {\n                if (dataviz.isNumber(values[i$1])) {\n                  pointers[i$1].value(values[i$1]);\n                }\n              }\n            }\n\n            this._setValueOptions(values);\n          },\n          _setValueOptions: function (values) {\n            var pointers = [].concat(this.options.pointer);\n            var arrayValues = [].concat(values);\n\n            for (var i = 0; i < arrayValues.length; i++) {\n              pointers[i].value = arrayValues[i];\n            }\n          },\n          resize: function () {\n            this.noTransitionsRedraw();\n          },\n          noTransitionsRedraw: function () {\n            var transitions = this.options.transitions;\n\n            this._toggleTransitions(false);\n\n            this.redraw();\n\n            this._toggleTransitions(transitions);\n          },\n          redraw: function () {\n            var size = this._surfaceSize();\n\n            var wrapper = new Rect([0, 0], [size.width, size.height]);\n\n            this._initSurface();\n\n            this.gaugeArea = this._createGaugeArea();\n\n            this._createModel();\n\n            var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n            this.reflow(bbox);\n          },\n          setOptions: function (options, theme) {\n            this._originalOptions = deepExtend(this._originalOptions, options);\n            this.options = deepExtend({}, this._originalOptions);\n\n            this._initTheme(theme);\n\n            this.redraw();\n          },\n          setDirection: function (rtl) {\n            this.contextService.rtl = Boolean(rtl);\n\n            if (this.surface && this.surface.type === 'svg') {\n              this.surface.destroy();\n              this.surface = null;\n            }\n          },\n          setIntlService: function (intl) {\n            this.contextService.intl = intl;\n          },\n          _initTheme: function (theme) {\n            var currentTheme = theme || this.theme || {};\n            this.theme = currentTheme;\n            this.options = deepExtend({}, currentTheme, this.options);\n            var options = this.options;\n            var pointer = options.pointer;\n\n            if (isArray(pointer)) {\n              var pointers = [];\n\n              for (var i = 0; i < pointer.length; i++) {\n                pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n              }\n\n              options.pointer = pointers;\n            }\n          },\n          _createGaugeArea: function () {\n            var options = this.options.gaugeArea;\n            var size = this.surface.size();\n            var border = options.border || {};\n            var areaGeometry = new Rect([0, 0], [size.width, size.height]);\n            this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n            if (border.width > 0) {\n              areaGeometry = unpad(areaGeometry, border.width);\n            }\n\n            var gaugeArea = Path.fromRect(areaGeometry, {\n              stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n              },\n              fill: {\n                color: options.background\n              }\n            });\n            return gaugeArea;\n          },\n          _initSurface: function () {\n            var ref = this;\n            var options = ref.options;\n            var surface = ref.surface;\n\n            var element = this._surfaceElement();\n\n            var size = this._surfaceSize();\n\n            dataviz.elementSize(element, size);\n\n            if (!surface || surface.options.type !== options.renderAs) {\n              if (surface) {\n                surface.destroy();\n              }\n\n              this.surface = Surface.create(element, {\n                type: options.renderAs\n              });\n            } else {\n              this.surface.clear();\n              this.surface.resize();\n            }\n          },\n          _surfaceSize: function () {\n            var options = this.options;\n\n            var size = this._getSize();\n\n            if (options.gaugeArea) {\n              deepExtend(size, options.gaugeArea);\n            }\n\n            return size;\n          },\n          _surfaceElement: function () {\n            if (!this.surfaceElement) {\n              this.surfaceElement = document.createElement('div');\n              this.element.appendChild(this.surfaceElement);\n            }\n\n            return this.surfaceElement;\n          },\n          getSize: function () {\n            return this._getSize();\n          },\n          _getSize: function () {\n            var element = this.element;\n\n            var defaultSize = this._defaultSize();\n\n            var width = element.offsetWidth;\n            var height = element.offsetHeight;\n\n            if (!width) {\n              width = defaultSize.width;\n            }\n\n            if (!height) {\n              height = defaultSize.height;\n            }\n\n            return {\n              width: width,\n              height: height\n            };\n          },\n          _defaultSize: function () {\n            return {\n              width: DEFAULT_WIDTH,\n              height: DEFAULT_HEIGHT\n            };\n          },\n          _toggleTransitions: function (value) {\n            var this$1 = this;\n            this.options.transitions = value;\n\n            for (var i = 0; i < this.pointers.length; i++) {\n              this$1.pointers[i].options.animation.transitions = value;\n            }\n          }\n        });\n        setDefaultOptions(Gauge, {\n          plotArea: {},\n          theme: \"default\",\n          renderAs: \"\",\n          pointer: {},\n          scale: {},\n          gaugeArea: {}\n        });\n        var Path$2 = DrawingPath;\n        var Group$2 = DrawingGroup;\n        var Point = GeometryPoint;\n\n        function renderAxisTick(tickRenderOptions, tickOptions) {\n          var position = tickRenderOptions.position;\n          var tickX = tickRenderOptions.tickX;\n          var tickY = tickRenderOptions.tickY;\n          var start, end;\n\n          if (tickRenderOptions.vertical) {\n            start = new Point(tickX, position);\n            end = new Point(tickX + tickOptions.size, position);\n          } else {\n            start = new Point(position, tickY);\n            end = new Point(position, tickY + tickOptions.size);\n          }\n\n          var tickPath = new Path$2({\n            stroke: {\n              color: tickOptions.color,\n              width: tickOptions.width\n            }\n          }).moveTo(start).lineTo(end);\n          return tickPath;\n        }\n\n        function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n          var count = tickPositions.length;\n\n          if (tickOptions.visible) {\n            var mirror = tickRenderOptions.mirror;\n            var lineBox = tickRenderOptions.lineBox;\n\n            for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n              if (i % tickOptions.skipUnit === 0) {\n                continue;\n              }\n\n              tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n              tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n              tickRenderOptions.position = tickPositions[i];\n              tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n            }\n          }\n        }\n\n        var LinearScale = NumericAxis.extend({\n          init: function (options, service) {\n            var scaleOptions = options || {};\n\n            if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n              scaleOptions = $.extend({}, scaleOptions, {\n                reverse: true\n              });\n            }\n\n            NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n            this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n          },\n          initUserOptions: function (options) {\n            var scaleOptions = deepExtend({}, this.options, options);\n            scaleOptions = deepExtend({}, scaleOptions, {\n              labels: {\n                mirror: scaleOptions.mirror\n              }\n            });\n            scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n            return scaleOptions;\n          },\n          initFields: function () {},\n          render: function () {\n            var elements = this.elements = new Group$2();\n            var labels = this.renderLabels();\n            var scaleLine = this.renderLine();\n            var scaleTicks = this.renderTicks();\n            var ranges = this.renderRanges();\n            elements.append(scaleLine, labels, scaleTicks, ranges);\n            return elements;\n          },\n          renderRanges: function () {\n            var this$1 = this;\n            var options = this.options;\n            var min = options.min;\n            var max = options.max;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var ranges = options.ranges || [];\n            var elements = new Group$2();\n            var count = ranges.length;\n            var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n            for (var i = 0; i < count; i++) {\n              var range = getRange(ranges[i], min, max);\n              var slot = this$1.getSlot(range.from, range.to);\n              var slotX = vertical ? this$1.lineBox() : slot;\n              var slotY = vertical ? slot : this$1.lineBox();\n\n              if (vertical) {\n                slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n              } else {\n                slotY.y2 += rangeSize * (mirror ? -1 : 1);\n              }\n\n              elements.append(Path$2.fromRect(new Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {\n                fill: {\n                  color: range.color,\n                  opacity: range.opacity\n                },\n                stroke: {}\n              }));\n            }\n\n            return elements;\n          },\n          renderLabels: function () {\n            var ref = this;\n            var labels = ref.labels;\n            var options = ref.options;\n            var elements = new Group$2();\n\n            for (var i = 0; i < labels.length; i++) {\n              elements.append(buildLabelElement(labels[i], options.labels));\n            }\n\n            return elements;\n          },\n          renderLine: function () {\n            var line = this.options.line;\n            var lineBox = this.lineBox();\n            var elements = new Group$2();\n\n            if (line.width > 0 && line.visible) {\n              var linePath = new Path$2({\n                stroke: {\n                  color: line.color,\n                  dashType: line.dashType,\n                  width: line.width\n                }\n              });\n              linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n              elements.append(linePath);\n            }\n\n            return elements;\n          },\n          renderTicks: function () {\n            var ticks = new Group$2();\n            var options = this.options;\n            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n            var tickRenderOptions = {\n              vertical: options.vertical,\n              mirror: options.labels.mirror,\n              lineBox: this.lineBox()\n            };\n            renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n            renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n              skipUnit: majorUnit / options.minorUnit\n            }, options.minorTicks));\n            return ticks;\n          }\n        });\n        setDefaultOptions(LinearScale, {\n          min: 0,\n          max: 50,\n          majorTicks: {\n            size: 15,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n          },\n          minorTicks: {\n            size: 10,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n          },\n          line: {\n            width: DEFAULT_LINE_WIDTH\n          },\n          labels: {\n            position: INSIDE,\n            padding: 2\n          },\n          mirror: false,\n          _alignLines: false\n        });\n        var Pointer = dataviz.Class.extend({\n          init: function (scale, userOptions) {\n            var ref = scale.options;\n            var min = ref.min;\n            var max = ref.max;\n            var options = this.options = deepExtend({}, this.options, userOptions);\n            options.fill = options.color;\n            this.scale = scale;\n\n            if (defined(options.value)) {\n              options.value = limitValue(options.value, min, max);\n            } else {\n              options.value = min;\n            }\n          },\n          value: function (newValue) {\n            var options = this.options;\n            var value = options.value;\n\n            if (arguments.length === 0) {\n              return value;\n            }\n\n            var ref = this.scale.options;\n            var min = ref.min;\n            var max = ref.max;\n            options._oldValue = defined(options._oldValue) ? options.value : min;\n            options.value = limitValue(newValue, min, max);\n\n            if (this.elements) {\n              this.repaint();\n            }\n          }\n        });\n        setDefaultOptions(Pointer, {\n          color: BLACK\n        });\n        var LinearPointer = Pointer.extend({\n          init: function (scale, options) {\n            Pointer.fn.init.call(this, scale, options);\n            this.options = deepExtend({\n              track: {\n                visible: defined(options.track)\n              }\n            }, this.options);\n          },\n          reflow: function () {\n            var ref = this;\n            var options = ref.options;\n            var scale = ref.scale;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var scaleLine = scale.lineBox();\n            var trackSize = options.track.size || options.size;\n            var pointerHalfSize = options.size / 2;\n            var margin = getSpacing(options.margin);\n            var space = vertical ? margin[mirror ? \"left\" : \"right\"] : margin[mirror ? \"bottom\" : \"top\"];\n            var pointerBox, pointerRangeBox, trackBox;\n            space = mirror ? -space : space;\n\n            if (vertical) {\n              trackBox = new Box(scaleLine.x1 + space, scaleLine.y1, scaleLine.x1 + space, scaleLine.y2);\n\n              if (mirror) {\n                trackBox.x1 -= trackSize;\n              } else {\n                trackBox.x2 += trackSize;\n              }\n\n              if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize, scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize);\n                pointerBox = pointerRangeBox;\n              }\n            } else {\n              trackBox = new Box(scaleLine.x1, scaleLine.y1 - space, scaleLine.x2, scaleLine.y1 - space);\n\n              if (mirror) {\n                trackBox.y2 += trackSize;\n              } else {\n                trackBox.y1 -= trackSize;\n              }\n\n              if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space, scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space);\n                pointerBox = pointerRangeBox;\n              }\n            }\n\n            this.trackBox = trackBox;\n            this.pointerRangeBox = pointerRangeBox;\n            this.box = pointerBox || trackBox.clone().pad(options.border.width);\n          },\n          getElementOptions: function () {\n            var options = this.options;\n            return {\n              fill: {\n                color: options.color,\n                opacity: options.opacity\n              },\n              stroke: defined(options.border) ? {\n                color: options.border.width ? options.border.color || options.color : \"\",\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: options.opacity\n              } : null\n            };\n          },\n          _margin: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var margin = getSpacing(options.margin);\n            var space = vertical ? margin[mirror ? \"left\" : \"right\"] : margin[mirror ? \"bottom\" : \"top\"];\n            return space;\n          }\n        });\n        setDefaultOptions(LinearPointer, {\n          shape: BAR_POINTER,\n          track: {\n            border: {\n              width: 1\n            }\n          },\n          color: BLACK,\n          border: {\n            width: 1\n          },\n          opacity: 1,\n          margin: getSpacing(3),\n          animation: {\n            type: BAR_POINTER\n          },\n          visible: true\n        });\n        var ArrowLinearPointerAnimation = Animation.extend({\n          setup: function () {\n            var options = this.options;\n            var margin = options.margin;\n            var from = options.from;\n            var to = options.to;\n            var vertical = options.vertical;\n            var axis = vertical ? \"x1\" : \"y1\";\n\n            if (options.mirror === vertical) {\n              from[axis] -= margin;\n              to[axis] -= margin;\n            } else {\n              from[axis] += margin;\n              to[axis] += margin;\n            }\n\n            var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n            var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n            if (options.duration !== 0) {\n              options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1000, 1);\n            }\n          },\n          step: function (pos) {\n            var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n            var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n            this.element.transform(transform().translate(translateX, translateY));\n          }\n        });\n        setDefaultOptions(ArrowLinearPointerAnimation, {\n          easing: LINEAR,\n          duration: LINEAR_SPEED\n        });\n        AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n        var Point$1 = GeometryPoint;\n        var Path$3 = DrawingPath;\n        var ArrowLinearPointer = LinearPointer.extend({\n          init: function (scale, options) {\n            LinearPointer.fn.init.call(this, scale, options);\n\n            if (!defined(this.options.size)) {\n              this.options.size = this.scale.options.majorTicks.size * 0.6;\n            }\n          },\n          pointerShape: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var size = ref.options.size;\n            var halfSize = size / 2;\n            var sign = scale.options.mirror ? -1 : 1;\n            var shape;\n\n            if (scale.options.vertical) {\n              shape = [new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)];\n            } else {\n              shape = [new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)];\n            }\n\n            return shape;\n          },\n          repaint: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n              vertical: scale.options.vertical,\n              mirror: scale.options.mirror,\n              margin: this._margin(options.margin),\n              from: scale.getSlot(options._oldValue),\n              to: scale.getSlot(options.value)\n            }));\n\n            if (options.animation.transitions === false) {\n              animation.options.duration = 0;\n            }\n\n            animation.setup();\n            animation.play();\n          },\n          render: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var elementOptions = this.getElementOptions();\n            var shape = this.pointerShape(options.value);\n            options.animation.type = ARROW_POINTER;\n            var elements = new Path$3({\n              stroke: elementOptions.stroke,\n              fill: elementOptions.fill\n            }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n            var slot = scale.getSlot(options.value);\n            elements.transform(transform().translate(slot.x1, slot.y1));\n            this.elements = elements;\n            return elements;\n          }\n        });\n        var BarLinearPointerAnimation = Animation.extend({\n          setup: function () {\n            var options = this.options;\n            var axis = this.axis = options.vertical ? constants.Y : constants.X;\n            var to = this.to = options.newPoints[0][axis];\n            var from = this.from = options.oldPoints[0][axis];\n\n            if (options.duration !== 0) {\n              options.duration = Math.max(Math.abs(to - from) / options.speed * 1000, 1);\n            }\n\n            this._set(from);\n          },\n          step: function (pos) {\n            var value = interpolateValue(this.from, this.to, pos);\n\n            this._set(value);\n          },\n          _set: function (value) {\n            var setter = \"set\" + this.axis.toUpperCase();\n            var points = this.options.newPoints;\n            points[0][setter](value);\n            points[1][setter](value);\n          }\n        });\n        setDefaultOptions(BarLinearPointerAnimation, {\n          easing: LINEAR,\n          speed: LINEAR_SPEED\n        });\n        AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n        var Group$3 = DrawingGroup;\n        var Path$4 = DrawingPath;\n        var BarLinearPointer = LinearPointer.extend({\n          init: function (scale, options) {\n            LinearPointer.fn.init.call(this, scale, options);\n\n            if (!defined(this.options.size)) {\n              this.options.size = this.scale.options.majorTicks.size * 0.3;\n            }\n          },\n          pointerShape: function (value) {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var dir = mirror === vertical ? -1 : 1;\n            var size = options.size * dir;\n            var minSlot = scale.getSlot(scale.options.min);\n            var slot = scale.getSlot(value);\n            var axis = vertical ? constants.Y : constants.X;\n            var sizeAxis = vertical ? constants.X : constants.Y;\n            var margin = this._margin() * dir;\n            var p1 = new GeometryPoint();\n            p1[axis] = minSlot[axis + \"1\"];\n            p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n            var p2 = new GeometryPoint();\n            p2[axis] = slot[axis + \"1\"];\n            p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n            if (vertical) {\n              p1.translate(margin, 0);\n              p2.translate(margin, 0);\n            } else {\n              p1.translate(0, margin);\n              p2.translate(0, margin);\n            }\n\n            var p3 = p2.clone();\n            var p4 = p1.clone();\n\n            if (vertical) {\n              p3.translate(size, 0);\n              p4.translate(size, 0);\n            } else {\n              p3.translate(0, size);\n              p4.translate(0, size);\n            }\n\n            return [p1, p2, p3, p4];\n          },\n          repaint: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var shape = this.pointerShape(options.value);\n            var pointerPath = this.pointerPath;\n            var oldShape = this.pointerShape(options._oldValue);\n            pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n            var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n              reverse: scale.options.reverse,\n              vertical: scale.options.vertical,\n              oldPoints: [oldShape[1], oldShape[2]],\n              newPoints: [shape[1], shape[2]]\n            }));\n\n            if (options.animation.transitions === false) {\n              animation.options.duration = 0;\n            }\n\n            animation.setup();\n            animation.play();\n          },\n          render: function () {\n            var group = new Group$3();\n            var elementOptions = this.getElementOptions();\n\n            if (this.options.track.visible) {\n              group.append(this.renderTrack());\n            }\n\n            var pointer = this.pointerPath = new Path$4({\n              stroke: elementOptions.stroke,\n              fill: elementOptions.fill\n            });\n            group.append(pointer);\n            this.elements = group;\n            return group;\n          },\n          renderTrack: function () {\n            var trackOptions = this.options.track;\n            var border = trackOptions.border || {};\n            var trackBox = this.trackBox.clone().pad(border.width || 0);\n            return new Path$4.fromRect(trackBox.toRect(), {\n              fill: {\n                color: trackOptions.color,\n                opacity: trackOptions.opacity\n              },\n              stroke: {\n                color: border.width ? border.color || trackOptions.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n              }\n            });\n          }\n        });\n        var DEFAULT_MIN_WIDTH = 60;\n        var DEFAULT_MIN_HEIGHT = 60;\n        var Group$1 = DrawingGroup;\n        var LinearGauge = Gauge.extend({\n          reflow: function (bbox) {\n            var pointers = this.pointers;\n            var bboxX = bbox.origin.x;\n            var bboxY = bbox.origin.y;\n            var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n            this.scale.reflow(box);\n\n            this._shrinkScaleWidth(box);\n\n            for (var i = 0; i < pointers.length; i++) {\n              pointers[i].reflow();\n            }\n\n            this.bbox = this._getBox(box);\n\n            this._alignElements();\n\n            this._shrinkElements();\n\n            this._buildVisual();\n\n            this._draw();\n          },\n          _buildVisual: function () {\n            var visuals = new Group$1();\n            var scaleElements = this.scale.render();\n            var pointers = this.pointers;\n            visuals.append(this.gaugeArea);\n            visuals.append(scaleElements);\n\n            for (var i = 0; i < pointers.length; i++) {\n              var current = pointers[i];\n              visuals.append(current.render());\n              current.value(current.options.value);\n            }\n\n            this._visuals = visuals;\n          },\n          _createModel: function () {\n            var this$1 = this;\n            var options = this.options;\n            var scale = this.scale = new LinearScale(options.scale, this.contextService);\n            this.pointers = [];\n            var pointers = options.pointer;\n            pointers = isArray(pointers) ? pointers : [pointers];\n\n            for (var i = 0; i < pointers.length; i++) {\n              var currentOptions = deepExtend({}, pointers[i], {\n                animation: {\n                  transitions: options.transitions\n                }\n              });\n              var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n              this$1.pointers.push(new pointerType(scale, currentOptions));\n            }\n          },\n          _defaultSize: function () {\n            var vertical = this.options.scale.vertical;\n            return {\n              width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n              height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n            };\n          },\n          _getBox: function (box) {\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var boxCenter = box.center();\n            var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n            for (var i = 0; i < pointers.length; i++) {\n              plotAreaBox.wrap(pointers[i].box.clone());\n            }\n\n            var size;\n\n            if (scale.options.vertical) {\n              size = plotAreaBox.width() / 2;\n              plotAreaBox = new Box(boxCenter.x - size, box.y1, boxCenter.x + size, box.y2);\n            } else {\n              size = plotAreaBox.height() / 2;\n              plotAreaBox = new Box(box.x1, boxCenter.y - size, box.x2, boxCenter.y + size);\n            }\n\n            return plotAreaBox;\n          },\n          _alignElements: function () {\n            var this$1 = this;\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var scaleBox = scale.box;\n            var box = pointers[0].box.clone().wrap(scale.box);\n            var plotAreaBox = this.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n              box.wrap(pointers[i].box.clone());\n            }\n\n            var diff;\n\n            if (scale.options.vertical) {\n              diff = plotAreaBox.center().x - box.center().x;\n              scale.reflow(new Box(scaleBox.x1 + diff, plotAreaBox.y1, scaleBox.x2 + diff, plotAreaBox.y2));\n            } else {\n              diff = plotAreaBox.center().y - box.center().y;\n              scale.reflow(new Box(scaleBox.x1, scaleBox.y1 + diff, scaleBox.x2, scaleBox.y2 + diff));\n            }\n\n            for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n              pointers[i$1].reflow(this$1.bbox);\n            }\n          },\n          _shrinkScaleWidth: function (bbox) {\n            var ref = this;\n            var scale = ref.scale;\n\n            if (!scale.options.vertical) {\n              var overflow = scale.contentBox().width() - bbox.width();\n\n              if (overflow > 0) {\n                scale.box.shrink(overflow, 0);\n                scale.box.alignTo(bbox, 'center');\n                scale.reflow(scale.box);\n              }\n            }\n          },\n          _shrinkElements: function () {\n            var this$1 = this;\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var scaleBox = scale.box.clone();\n            var pos = scale.options.vertical ? \"y\" : \"x\";\n            var pointerBox = pointers[0].box;\n\n            for (var i = 0; i < pointers.length; i++) {\n              pointerBox.wrap(pointers[i].box.clone());\n            }\n\n            scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n            scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n            scale.reflow(scaleBox);\n\n            for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n              pointers[i$1].reflow(this$1.bbox);\n            }\n          }\n        });\n        setDefaultOptions(LinearGauge, {\n          transitions: true,\n          gaugeArea: {\n            background: \"\"\n          },\n          scale: {\n            vertical: true\n          }\n        });\n        var GEO_ARC_ADJUST_ANGLE = 180;\n        var Arc = drawing.Arc;\n        var Path$5 = DrawingPath;\n        var Group$5 = DrawingGroup;\n\n        function drawTicks(arc, tickAngles, unit, tickOptions) {\n          var ticks = new Group$5();\n          var center = arc.center;\n          var radius = arc.getRadiusX();\n\n          if (tickOptions.visible) {\n            for (var i = 0; i < tickAngles.length; i++) {\n              var tickStart = arc.pointAt(tickAngles[i]);\n              var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n              ticks.append(new Path$5({\n                stroke: {\n                  color: tickOptions.color,\n                  width: tickOptions.width\n                }\n              }).moveTo(tickStart).lineTo(tickEnd));\n            }\n          }\n\n          return ticks;\n        }\n\n        function rangeSegment(from, to, color, opacity) {\n          return {\n            from: from,\n            to: to,\n            color: color,\n            opacity: opacity\n          };\n        }\n\n        var RadialScale = NumericAxis.extend({\n          init: function (options, service) {\n            NumericAxis.fn.init.call(this, 0, 1, options, service);\n          },\n          initUserOptions: function (options) {\n            var scaleOptions = deepExtend({}, this.options, options);\n            scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n            scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n            return scaleOptions;\n          },\n          initFields: function () {},\n          render: function (center, radius) {\n            var arc = this.renderArc(center, radius);\n            this.bbox = arc.bbox();\n            this.labelElements = this.renderLabels();\n            this.ticks = this.renderTicks();\n            this.ranges = this.renderRanges();\n          },\n          reflow: function (bbox) {\n            var center = bbox.center();\n            var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n            if (defined(this.bbox)) {\n              this.bbox = this.arc.bbox();\n              this.radius(this.arc.getRadiusX());\n              this.repositionRanges();\n              this.renderLabels();\n            } else {\n              return this.render(center, radius);\n            }\n          },\n          slotAngle: function (value) {\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var reverse = ref.reverse;\n            var startAngle = ref.startAngle;\n            var endAngle = ref.endAngle;\n            var angle = endAngle - startAngle;\n            var result;\n\n            if (reverse) {\n              result = endAngle - (value - min) / (max - min) * angle;\n            } else {\n              result = (value - min) / (max - min) * angle + startAngle;\n            }\n\n            return result + GEO_ARC_ADJUST_ANGLE;\n          },\n          hasRanges: function () {\n            var ranges = this.options.ranges;\n            return ranges && ranges.length;\n          },\n          ticksSize: function () {\n            var ref = this.options;\n            var majorTicks = ref.majorTicks;\n            var minorTicks = ref.minorTicks;\n            var size = 0;\n\n            if (majorTicks.visible) {\n              size = majorTicks.size;\n            }\n\n            if (minorTicks.visible) {\n              size = Math.max(minorTicks.size, size);\n            }\n\n            return size;\n          },\n          labelsCount: function () {\n            var count = NumericAxis.fn.labelsCount.call(this);\n            var options = this.options;\n            var angle = options.endAngle - options.startAngle;\n\n            if (angle >= 360 && options.max % options.majorUnit === 0) {\n              count -= 1;\n            }\n\n            return count;\n          },\n          renderLabels: function () {\n            var this$1 = this;\n            var options = this.options;\n            var arc = this.arc.clone();\n            var radius = arc.getRadiusX();\n            var tickAngles = this.tickAngles(arc, options.majorUnit);\n            var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n            var labelsGroup = new Group$5();\n            var rangeDistance = radius * 0.05;\n\n            if (defined(options.rangeDistance)) {\n              rangeDistance = options.rangeDistance;\n            } else {\n              options.rangeDistance = rangeDistance;\n            }\n\n            var labelsOptions = options.labels;\n            var isInside = labelsOptions.position === INSIDE;\n            var hasLabelElements = defined(this.labelElements);\n\n            if (isInside) {\n              radius -= this.ticksSize();\n\n              if (this.hasRanges() && !hasLabelElements) {\n                radius -= rangeSize + rangeDistance;\n              }\n\n              arc.setRadiusX(radius).setRadiusY(radius);\n            }\n\n            var labels = this.labels;\n            var count = labels.length;\n            var padding = getSpacing(labelsOptions.padding);\n            var paddingWidth = (padding.left + padding.right) / 2;\n            var paddingHeight = (padding.top + padding.bottom) / 2;\n\n            for (var i = 0; i < count; i++) {\n              var label = labels[i];\n              var halfWidth = label.box.width() / 2;\n              var halfHeight = label.box.height() / 2;\n              var angle = tickAngles[i];\n              var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n              var lp = arc.pointAt(angle);\n              var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);\n              var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);\n              label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n              var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n              var labelElement = void 0;\n\n              if (!hasLabelElements) {\n                labelElement = buildLabelElement(label, options.labels);\n                labelsGroup.append(labelElement);\n              } else {\n                labelElement = this$1.labelElements.children[i];\n                var prevLabelPos = labelElement.bbox().origin;\n                var labelTransform = labelElement.transform() || transform();\n                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                labelElement.transform(labelTransform);\n              }\n\n              this$1.bbox = Rect.union(this$1.bbox, labelElement.bbox());\n            }\n\n            return labelsGroup;\n          },\n          repositionRanges: function () {\n            var ranges = this.ranges.children;\n\n            if (ranges.length > 0) {\n              var ref = this.options;\n              var rangeDistance = ref.rangeDistance;\n              var rangeSize = ref.rangeSize;\n              var rangeRadius = this.getRangeRadius();\n\n              if (this.options.labels.position === INSIDE) {\n                rangeRadius += rangeSize + rangeDistance;\n              }\n\n              var newRadius = rangeRadius + rangeSize / 2;\n\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n              }\n\n              this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n            }\n          },\n          renderRanges: function () {\n            var this$1 = this;\n            var segments = this.rangeSegments();\n            var segmentsCount = segments.length;\n            var result = new Group$5();\n\n            if (segmentsCount) {\n              var ref = this.options;\n              var rangeSize = ref.rangeSize;\n              var reverse = ref.reverse;\n              var rangeDistance = ref.rangeDistance;\n              var rangeRadius = this.getRangeRadius(); // move the ticks with a range distance and a range size\n\n              this.radius(this.radius() - rangeSize - rangeDistance);\n\n              for (var i = 0; i < segmentsCount; i++) {\n                var segment = segments[i];\n                var from = this$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                var to = this$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                if (to - from !== 0) {\n                  result.append(this$1.createRange(from, to, rangeRadius, segment));\n                }\n              }\n            }\n\n            return result;\n          },\n          createRange: function (startAngle, endAngle, rangeRadius, options) {\n            var rangeSize = this.options.rangeSize;\n            var rangeGeom = new geometry.Arc(this.arc.center, {\n              radiusX: rangeRadius + rangeSize / 2,\n              radiusY: rangeRadius + rangeSize / 2,\n              startAngle: startAngle,\n              endAngle: endAngle\n            });\n            return new Arc(rangeGeom, {\n              stroke: {\n                width: rangeSize,\n                color: options.color,\n                opacity: options.opacity,\n                lineCap: options.lineCap\n              }\n            });\n          },\n          rangeSegments: function () {\n            var options = this.options;\n            var ranges = options.ranges || [];\n            var count = ranges.length;\n            var segments = [];\n\n            if (count) {\n              var min = options.min;\n              var max = options.max;\n              var defaultColor = options.rangePlaceholderColor;\n              segments.push(rangeSegment(min, max, defaultColor));\n\n              for (var i = 0; i < count; i++) {\n                var range = getRange(ranges[i], min, max);\n                var segmentsCount = segments.length;\n\n                for (var j = 0; j < segmentsCount; j++) {\n                  var segment = segments[j];\n\n                  if (segment.from <= range.from && range.from <= segment.to) {\n                    segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                    if (segment.from <= range.to && range.to <= segment.to) {\n                      segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                    }\n\n                    segment.to = range.from;\n                    break;\n                  }\n                }\n              }\n            }\n\n            return segments;\n          },\n          getRangeRadius: function () {\n            var ref = this;\n            var arc = ref.arc;\n            var options = ref.options;\n            var rangeSize = options.rangeSize;\n            var rangeDistance = options.rangeDistance;\n            var majorTickSize = options.majorTicks.size;\n            var radius;\n\n            if (options.labels.position === OUTSIDE) {\n              radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n            } else {\n              radius = arc.getRadiusX() - rangeSize;\n            }\n\n            return radius;\n          },\n          renderArc: function (center, radius) {\n            var options = this.options;\n            var arc = this.arc = new geometry.Arc(center, {\n              radiusX: radius,\n              radiusY: radius,\n              startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n              endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n            });\n            return arc;\n          },\n          renderTicks: function () {\n            var ref = this;\n            var arc = ref.arc;\n            var options = ref.options;\n            var tickArc = arc.clone();\n            this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n            this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n            var allTicks = new Group$5();\n            allTicks.append(this.majorTicks);\n            var majorTickSize = options.majorTicks.size;\n            var minorTickSize = options.minorTicks.size;\n            this._tickDifference = majorTickSize - minorTickSize;\n\n            if (options.labels.position === OUTSIDE) {\n              var radius = tickArc.getRadiusX();\n              tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);\n            }\n\n            this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n            this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n            allTicks.append(this.minorTicks);\n            return allTicks;\n          },\n          normalizeTickAngles: function (angles) {\n            var options = this.options;\n            var skip = options.majorUnit / options.minorUnit;\n\n            for (var i = angles.length - 1; i >= 0; i--) {\n              if (i % skip === 0) {\n                angles.splice(i, 1);\n              }\n            }\n\n            return angles;\n          },\n          tickAngles: function (ring, stepValue) {\n            var options = this.options;\n            var reverse = options.reverse;\n            var range = options.max - options.min;\n            var angle = ring.endAngle - ring.startAngle;\n            var tickCount = range / stepValue;\n            var pos = ring.startAngle;\n            var step = angle / tickCount;\n\n            if (reverse) {\n              pos += angle;\n              step = -step;\n            }\n\n            if (angle >= 360 && options.max % stepValue === 0) {\n              tickCount -= 1;\n            }\n\n            var positions = [];\n\n            for (var i = 0; i < tickCount; i++) {\n              positions.push(round(pos, COORD_PRECISION));\n              pos += step;\n            }\n\n            if (round(pos) <= ring.endAngle) {\n              positions.push(pos);\n            }\n\n            return positions;\n          },\n          radius: function (value) {\n            if (value) {\n              this.arc.setRadiusX(value).setRadiusY(value);\n              this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n              this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n            } else {\n              return this.arc.getRadiusX();\n            }\n          },\n          repositionTicks: function (ticks, tickAngles, minor) {\n            var diff = minor ? this._tickDifference || 0 : 0;\n            var tickArc = this.arc;\n            var radius = tickArc.getRadiusX();\n\n            if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n              tickArc = this.arc.clone();\n              tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n            }\n\n            for (var i = 0; i < ticks.length; i++) {\n              var newPoint = tickArc.pointAt(tickAngles[i]);\n              var segments = ticks[i].segments;\n              var xDiff = newPoint.x - segments[0].anchor().x;\n              var yDiff = newPoint.y - segments[0].anchor().y;\n              ticks[i].transform(new transform().translate(xDiff, yDiff));\n            }\n          }\n        });\n        setDefaultOptions(RadialScale, {\n          min: 0,\n          max: 100,\n          majorTicks: {\n            size: 15,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n          },\n          minorTicks: {\n            size: 10,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n          },\n          startAngle: -30,\n          endAngle: 210,\n          labels: {\n            position: INSIDE,\n            padding: 2\n          }\n        });\n        var RadialPointerAnimation = Animation.extend({\n          init: function (element, options) {\n            Animation.fn.init.call(this, element, options);\n            var animationOptions = this.options;\n            animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1000, 1);\n          },\n          step: function (pos) {\n            var options = this.options;\n            var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n            this.element.transform(transform().rotate(angle, options.center));\n          }\n        });\n        setDefaultOptions(RadialPointerAnimation, {\n          easing: LINEAR,\n          duration: ANGULAR_SPEED\n        });\n        AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n        var CAP_SIZE = 0.05;\n        var Circle = drawing.Circle;\n        var Group$6 = DrawingGroup;\n        var Path$6 = DrawingPath;\n        var RadialPointer = Pointer.extend({\n          setAngle: function (angle) {\n            this.elements.transform(transform().rotate(angle, this.center));\n          },\n          repaint: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var oldAngle = scale.slotAngle(options._oldValue);\n            var newAngle = scale.slotAngle(options.value);\n\n            if (options.animation.transitions === false) {\n              this.setAngle(newAngle);\n            } else {\n              new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n              })).play();\n            }\n          },\n          render: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var elements = new Group$6();\n\n            if (options.animation !== false) {\n              deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n              });\n            }\n\n            elements.append(this._renderNeedle(), this._renderCap());\n            this.elements = elements;\n            this.setAngle(DEGREE);\n            return elements;\n          },\n          reflow: function (arc) {\n            var center = this.center = arc.center;\n            var length = limitValue(this.options.length || 1, 0.1, 1.5);\n            var radius = this.radius = arc.getRadiusX() * length;\n            var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n            this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize), new GeometryPoint(center.x + capSize, center.y + capSize));\n          },\n          _renderNeedle: function () {\n            var minorTickSize = this.scale.options.minorTicks.size;\n            var center = this.center;\n            var needleColor = this.options.color;\n            var needlePath = new Path$6({\n              fill: {\n                color: needleColor\n              },\n              stroke: {\n                color: needleColor,\n                width: DEFAULT_LINE_WIDTH\n              }\n            });\n            needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();\n            return needlePath;\n          },\n          _renderCap: function () {\n            var options = this.options;\n            var capColor = options.cap.color || options.color;\n            var circle = new geometry.Circle(this.center, this.capSize);\n            var cap = new Circle(circle, {\n              fill: {\n                color: capColor\n              },\n              stroke: {\n                color: capColor\n              }\n            });\n            return cap;\n          }\n        });\n        setDefaultOptions(RadialPointer, {\n          cap: {\n            size: CAP_SIZE\n          },\n          arrow: {\n            width: 16,\n            height: 14\n          },\n          animation: {\n            type: RADIAL_POINTER,\n            duration: ANGULAR_SPEED\n          }\n        });\n        var Group$4 = DrawingGroup;\n        var RadialGauge = Gauge.extend({\n          reflow: function (bbox) {\n            var this$1 = this;\n            var pointers = this.pointers;\n            this.scale.reflow(bbox);\n            this._initialPlotArea = this.scale.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n              pointers[i].reflow(this$1.scale.arc);\n              this$1._initialPlotArea = Rect.union(this$1._initialPlotArea, pointers[i].bbox);\n            }\n\n            this.fitScale(bbox);\n            this.alignScale(bbox);\n\n            this._buildVisual(this.gaugeArea, pointers, this.scale);\n\n            this._draw();\n          },\n          _buildVisual: function (gaugeArea, pointers, scale) {\n            var visuals = this._visuals = new Group$4();\n            visuals.append(gaugeArea);\n            visuals.append(scale.ticks);\n            visuals.append(scale.ranges);\n\n            this._buildPointers(pointers);\n\n            visuals.append(scale.labelElements);\n          },\n          _buildPointers: function (pointers) {\n            var this$1 = this;\n\n            for (var i = 0; i < pointers.length; i++) {\n              var current = pointers[i];\n              current.render();\n\n              this$1._visuals.append(current.elements);\n\n              current.value(current.options.value);\n            }\n          },\n          fitScale: function (bbox) {\n            var this$1 = this;\n            var arc = this.scale.arc;\n            var plotAreaBox = this._initialPlotArea;\n            var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n            var min = round(step, COORD_PRECISION);\n            var max = round(-step, COORD_PRECISION);\n            var minDiff, midDiff, maxDiff, mid, oldDiff;\n            var staleFlag = 0;\n            var i = 0;\n\n            while (i++ < 100) {\n              staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;\n\n              if (staleFlag > 5) {\n                break;\n              }\n\n              if (min !== mid) {\n                minDiff = this$1.getPlotBox(min, bbox, arc);\n\n                if (0 <= minDiff && minDiff <= 2) {\n                  break;\n                }\n              }\n\n              if (max !== mid) {\n                maxDiff = this$1.getPlotBox(max, bbox, arc);\n\n                if (0 <= maxDiff && maxDiff <= 2) {\n                  break;\n                }\n              }\n\n              if (minDiff > 0 && maxDiff > 0) {\n                mid = min * 2;\n              } else if (minDiff < 0 && maxDiff < 0) {\n                mid = max * 2;\n              } else {\n                mid = round((min + max) / 2 || 1, COORD_PRECISION);\n              }\n\n              midDiff = this$1.getPlotBox(mid, bbox, arc);\n\n              if (0 <= midDiff && midDiff <= 2) {\n                break;\n              }\n\n              oldDiff = maxDiff;\n\n              if (midDiff > 0) {\n                max = mid;\n                maxDiff = midDiff;\n              } else {\n                min = mid;\n                minDiff = midDiff;\n              }\n            }\n          },\n          getPlotBox: function (step, bbox, arc) {\n            var this$1 = this;\n            var scale = this.scale;\n            var pointers = this.pointers;\n            var radius = arc.getRadiusX();\n            var scaleArc = arc.clone();\n            scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n            scale.arc = scaleArc;\n            scale.reflow(bbox);\n            this.plotBbox = scale.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n              pointers[i].reflow(scaleArc);\n              this$1.plotBbox = Rect.union(this$1.plotBbox, pointers[i].bbox);\n            }\n\n            return this.getDiff(this.plotBbox, bbox);\n          },\n          getDiff: function (plotBox, box) {\n            return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n          },\n          alignScale: function (bbox) {\n            var this$1 = this;\n            var plotBoxCenter = this.plotBbox.center();\n            var boxCenter = bbox.center();\n            var paddingX = plotBoxCenter.x - boxCenter.x;\n            var paddingY = plotBoxCenter.y - boxCenter.y;\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            scale.arc.center.x -= paddingX;\n            scale.arc.center.y -= paddingY;\n            scale.reflow(bbox);\n\n            for (var i = 0; i < pointers.length; i++) {\n              pointers[i].reflow(scale.arc);\n              this$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n            }\n          },\n          _createModel: function () {\n            var this$1 = this;\n            var options = this.options;\n            var pointers = options.pointer;\n            var scale = this.scale = new RadialScale(options.scale, this.contextService);\n            this.pointers = [];\n            var pointersArr = isArray(pointers) ? pointers : [pointers];\n\n            for (var i = 0; i < pointersArr.length; i++) {\n              var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n                animation: {\n                  transitions: options.transitions\n                }\n              }));\n              this$1.pointers.push(current);\n            }\n          }\n        });\n        setDefaultOptions(RadialGauge, {\n          transitions: true,\n          gaugeArea: {\n            background: \"\"\n          }\n        });\n        var ArcScale = RadialScale.extend({\n          rangeSegments: function () {\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var rangePlaceholderColor = ref.rangePlaceholderColor;\n            var rangeLineCap = ref.rangeLineCap;\n            return [{\n              from: min,\n              to: max,\n              color: rangePlaceholderColor,\n              lineCap: rangeLineCap\n            }];\n          },\n          hasRanges: function () {\n            return true;\n          },\n          placeholderRangeAngle: function (angle) {\n            var geometry$$1 = this.ranges.children[0].geometry();\n\n            if (this.options.reverse) {\n              geometry$$1.setEndAngle(angle);\n            } else {\n              geometry$$1.setStartAngle(angle);\n            }\n          },\n          addRange: function (from, to, options) {\n            var reverse = this.options.reverse;\n            var startAngle = this.slotAngle(reverse ? to : from);\n            var endAngle = this.slotAngle(reverse ? from : to);\n            var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n            this.ranges.append(range);\n            return range;\n          }\n        });\n        setDefaultOptions(ArcScale, {\n          min: 0,\n          max: 100,\n          majorTicks: {\n            visible: false\n          },\n          minorTicks: {\n            visible: false\n          },\n          labels: {\n            visible: false\n          },\n          startAngle: 0,\n          endAngle: 180,\n          rangeLineCap: 'round'\n        });\n        var MAX_DURATION = 800;\n        var RangePointerAnimation = Animation.extend({\n          init: function (element, options) {\n            Animation.fn.init.call(this, element, options);\n            var animationOptions = this.options;\n            var duration = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1000;\n            animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n            var startColor = element.elements.options.get(\"stroke.color\");\n            var color = element.currentColor();\n\n            if (startColor !== color) {\n              this.startColor = new kendo.Color(startColor);\n              this.color = new kendo.Color(color);\n            }\n          },\n          step: function (pos) {\n            var ref = this;\n            var options = ref.options;\n            var startColor = ref.startColor;\n            var color = ref.color;\n            var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n            this.element.angle(angle);\n\n            if (color) {\n              var r = round(interpolateValue(startColor.r, color.r, pos));\n              var g = round(interpolateValue(startColor.g, color.g, pos));\n              var b = round(interpolateValue(startColor.b, color.b, pos));\n              this.element.stroke(new kendo.Color(r, g, b).toHex());\n            }\n          }\n        });\n        setDefaultOptions(RangePointerAnimation, {\n          easing: LINEAR,\n          duration: ANGULAR_SPEED\n        });\n        AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n        var RangePointer = Pointer.extend({\n          repaint: function () {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var oldAngle = scale.slotAngle(options._oldValue);\n            var newAngle = scale.slotAngle(options.value);\n\n            if (this.animation) {\n              this.animation.abort();\n            }\n\n            if (options.animation.transitions === false) {\n              this.angle(newAngle);\n              this.stroke(this.currentColor());\n            } else {\n              this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n              }));\n              this.animation.play();\n            }\n          },\n          angle: function (value) {\n            var geometry$$1 = this.elements.geometry();\n\n            if (this.scale.options.reverse) {\n              geometry$$1.setStartAngle(value);\n            } else {\n              geometry$$1.setEndAngle(value);\n            }\n\n            this.scale.placeholderRangeAngle(value);\n          },\n          stroke: function (value) {\n            this.elements.stroke(value);\n          },\n          render: function () {\n            if (this.elements) {\n              return;\n            }\n\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n\n            if (options.animation !== false) {\n              deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n              });\n            }\n\n            this.elements = scale.addRange(scale.options.min, this.options.value, {\n              color: this.currentColor(),\n              opacity: options.opacity,\n              lineCap: scale.options.rangeLineCap\n            });\n          },\n          currentColor: function () {\n            var ref = this.scale.options;\n            var min = ref.min;\n            var max = ref.max;\n            var ref$1 = this.options;\n            var colors = ref$1.colors;\n            var color = ref$1.color;\n            var value = ref$1.value;\n            var currentValue = dataviz.isNumber(value) ? value : min;\n\n            if (colors) {\n              for (var idx = 0; idx < colors.length; idx++) {\n                var ref$2 = colors[idx];\n                var rangeColor = ref$2.color;\n                var from = ref$2.from;\n\n                if (from === void 0) {\n                  from = min;\n                }\n\n                var to = ref$2.to;\n\n                if (to === void 0) {\n                  to = max;\n                }\n\n                if (from <= currentValue && currentValue <= to) {\n                  return rangeColor;\n                }\n              }\n            }\n\n            return color;\n          },\n          reflow: function () {\n            this.render();\n            this.bbox = this.elements.bbox();\n          }\n        });\n        setDefaultOptions(RangePointer, {\n          animation: {\n            type: RADIAL_RANGE_POINTER,\n            duration: ANGULAR_SPEED\n          }\n        });\n        var ArcGauge = RadialGauge.extend({\n          _initTheme: function (theme) {\n            RadialGauge.fn._initTheme.call(this, theme);\n\n            this.options.color = this.options.color || (this.theme.pointer || {}).color;\n          },\n          _createModel: function () {\n            var options = this.options;\n            var scale = this.scale = new ArcScale(options.scale, this.contextService);\n            var pointer = new RangePointer(scale, deepExtend({}, {\n              colors: options.colors,\n              color: options.color,\n              value: options.value,\n              opacity: options.opacity,\n              animation: {\n                transitions: options.transitions\n              }\n            }));\n            this.pointers = [pointer];\n          },\n          _buildPointers: function (pointers) {\n            for (var i = 0; i < pointers.length; i++) {\n              var current = pointers[i];\n              current.render();\n              current.value(current.options.value);\n            }\n          },\n          _setValueOptions: function (value) {\n            this.options.value = value;\n          },\n          currentColor: function () {\n            var pointer = this.pointers[0];\n\n            if (pointer) {\n              return pointer.currentColor();\n            }\n          },\n          centerLabelPosition: function (width, height) {\n            var size = this.getSize();\n            var center = this.scale.arc.center;\n            var left = center.x - width / 2;\n            var top = center.y - height / 2;\n\n            if (width < size.width) {\n              var right = left + width;\n              left = Math.max(left, 0);\n\n              if (right > size.width) {\n                left -= right - size.width;\n              }\n            }\n\n            if (height < size.height) {\n              var bbox = this.scale.bbox;\n              var yLimit = bbox.bottomRight().y;\n              var bottom = top + height;\n              top = Math.max(top, bbox.origin.y);\n\n              if (bottom > yLimit) {\n                top -= bottom - yLimit;\n              }\n            }\n\n            return {\n              left: left,\n              top: top\n            };\n          }\n        });\n        var defaultStartAngle = 90;\n        var CircularGauge = ArcGauge.extend({\n          _createModel: function () {\n            var scaleOptions = this.options.scale;\n\n            if (typeof scaleOptions.startAngle !== 'number') {\n              scaleOptions.startAngle = defaultStartAngle;\n            }\n\n            scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n            ArcGauge.fn._createModel.call(this);\n          }\n        });\n        kendo.deepExtend(kendo.dataviz, {\n          Gauge: Gauge,\n          LinearGauge: LinearGauge,\n          LinearPointer: LinearPointer,\n          ArrowLinearPointer: ArrowLinearPointer,\n          BarLinearPointer: BarLinearPointer,\n          LinearScale: LinearScale,\n          RadialGauge: RadialGauge,\n          RadialPointer: RadialPointer,\n          RadialScale: RadialScale,\n          ArcGauge: ArcGauge,\n          RangePointer: RangePointer,\n          ArcScale: ArcScale,\n          CircularGauge: CircularGauge\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}