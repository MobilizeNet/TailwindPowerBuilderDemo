{"ast":null,"code":"import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\nimport { STEP, SMOOTH, ZERO } from '../constants';\n\nclass AreaChart extends LineChart {\n  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n    const isStacked = this.options.isStacked;\n    const style = (currentSeries.line || {}).style;\n    let previousSegment;\n    let stackPoints;\n\n    if (isStacked && seriesIx > 0 && prevSegment) {\n      const missingValues = this.seriesMissingValues(currentSeries);\n\n      if (missingValues !== \"gap\") {\n        stackPoints = prevSegment.linePoints;\n        previousSegment = prevSegment;\n      } else {\n        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n      }\n    }\n\n    let pointType;\n\n    if (style === STEP) {\n      pointType = StepAreaSegment;\n    } else if (style === SMOOTH) {\n      pointType = SplineAreaSegment;\n    } else {\n      pointType = AreaSegment;\n    }\n\n    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n  }\n\n  reflow(targetBox) {\n    super.reflow(targetBox);\n    const stackPoints = this._stackPoints;\n\n    if (stackPoints) {\n      for (let idx = 0; idx < stackPoints.length; idx++) {\n        const stackPoint = stackPoints[idx];\n        const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);\n        stackPoint.reflow(pointSlot);\n      }\n    }\n  }\n\n  _gapStackPoints(linePoints, seriesIx, style) {\n    const seriesPoints = this.seriesPoints;\n    let startIdx = linePoints[0].categoryIx;\n    let length = linePoints.length;\n\n    if (startIdx < 0) {\n      startIdx = 0;\n      length--;\n    }\n\n    const endIdx = startIdx + length;\n    const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n    const stackPoints = [];\n    this._stackPoints = this._stackPoints || [];\n\n    for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n      const pointIx = categoryIx + pointOffset;\n      let currentSeriesIx = seriesIx;\n      let point;\n\n      do {\n        currentSeriesIx--;\n        point = seriesPoints[currentSeriesIx][pointIx];\n      } while (currentSeriesIx > 0 && !point);\n\n      if (point) {\n        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n        }\n\n        stackPoints.push(point);\n\n        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n        }\n      } else {\n        const gapStackPoint = this._createGapStackPoint(categoryIx);\n\n        this._stackPoints.push(gapStackPoint);\n\n        stackPoints.push(gapStackPoint);\n      }\n    }\n\n    return stackPoints;\n  }\n\n  _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n    const seriesPoints = this.seriesPoints;\n    let index = seriesIdx;\n    let point;\n\n    while (index > 0 && !point) {\n      index--;\n      point = seriesPoints[index][segmentIx];\n    }\n\n    if (!point) {\n      point = this._createGapStackPoint(categoryIx);\n\n      this._stackPoints.push(point);\n    } else {\n      point = seriesPoints[index][pointIx];\n    }\n\n    return point;\n  }\n\n  _createGapStackPoint(categoryIx) {\n    const options = this.pointOptions({}, 0);\n    const point = new LinePoint(0, options);\n    point.categoryIx = categoryIx;\n    point.series = {};\n    return point;\n  }\n\n  seriesMissingValues(series) {\n    return series.missingValues || ZERO;\n  }\n\n  supportsPointInactiveOpacity() {\n    return false;\n  }\n\n}\n\nexport default AreaChart;","map":null,"metadata":{},"sourceType":"module"}