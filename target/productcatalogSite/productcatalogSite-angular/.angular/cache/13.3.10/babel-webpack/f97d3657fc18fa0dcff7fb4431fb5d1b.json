{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1297);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1060:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"jquery\");\n    /***/\n  },\n\n  /***/\n  1063:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data\");\n    /***/\n  },\n\n  /***/\n  1089:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.html.button\");\n    /***/\n  },\n\n  /***/\n  1092:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.selectable\");\n    /***/\n  },\n\n  /***/\n  1119:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.filtermenu\");\n    /***/\n  },\n\n  /***/\n  1217:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.resizable\");\n    /***/\n  },\n\n  /***/\n  1218:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.window\");\n    /***/\n  },\n\n  /***/\n  1270:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.dialog\");\n    /***/\n  },\n\n  /***/\n  1279:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.editable\");\n    /***/\n  },\n\n  /***/\n  1282:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.switch\");\n    /***/\n  },\n\n  /***/\n  1287:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.pdf\");\n    /***/\n  },\n\n  /***/\n  1297:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /* WEBPACK VAR INJECTION */\n\n\n    (function (jQuery) {\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1063), __webpack_require__(1298), __webpack_require__(1279), __webpack_require__(1218), __webpack_require__(1119), __webpack_require__(1299), __webpack_require__(1300), __webpack_require__(1301), __webpack_require__(1302), __webpack_require__(1092), __webpack_require__(1303), __webpack_require__(1304), __webpack_require__(1217), __webpack_require__(1305), __webpack_require__(1306), __webpack_require__(1307), __webpack_require__(1308), __webpack_require__(1287), __webpack_require__(1270), __webpack_require__(1307), __webpack_require__(1282), __webpack_require__(1089)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        var __meta__ = {\n          // jshint ignore:line\n          id: \"grid\",\n          name: \"Grid\",\n          category: \"web\",\n          description: \"The Grid widget displays tabular data and offers rich support for interacting with data,including paging, sorting, grouping, and selection.\",\n          depends: [\"data\", \"columnsorter\", \"sortable\", \"html.button\"],\n          features: [{\n            id: \"grid-editing\",\n            name: \"Editing\",\n            description: \"Support for record editing\",\n            depends: [\"editable\", \"window\"]\n          }, {\n            id: \"grid-filtering\",\n            name: \"Filtering\",\n            description: \"Support for record filtering\",\n            depends: [\"filtermenu\"]\n          }, {\n            id: \"grid-columnmenu\",\n            name: \"Column menu\",\n            description: \"Support for header column menu\",\n            depends: [\"columnmenu\"]\n          }, {\n            id: \"grid-grouping\",\n            name: \"Grouping\",\n            description: \"Support for grid grouping\",\n            depends: [\"groupable\"]\n          }, {\n            id: \"grid-filtercell\",\n            name: \"Row filter\",\n            description: \"Support for grid header filtering\",\n            depends: [\"filtercell\"]\n          }, {\n            id: \"grid-paging\",\n            name: \"Paging\",\n            description: \"Support for grid paging\",\n            depends: [\"pager\"]\n          }, {\n            id: \"grid-selection\",\n            name: \"Selection\",\n            description: \"Support for row selection\",\n            depends: [\"selectable\"]\n          }, {\n            id: \"grid-column-reorder\",\n            name: \"Column reordering\",\n            description: \"Support for column reordering\",\n            depends: [\"reorderable\"]\n          }, {\n            id: \"grid-column-resize\",\n            name: \"Column resizing\",\n            description: \"Support for column resizing\",\n            depends: [\"resizable\"]\n          }, {\n            id: \"grid-mobile\",\n            name: \"Grid adaptive rendering\",\n            description: \"Support for adaptive rendering\",\n            depends: [\"dialog\", \"pane\", \"switch\"]\n          }, {\n            id: \"grid-excel-export\",\n            name: \"Excel export\",\n            description: \"Export grid data as Excel spreadsheet\",\n            depends: [\"excel\"]\n          }, {\n            id: \"grid-pdf-export\",\n            name: \"PDF export\",\n            description: \"Export grid data as PDF\",\n            depends: [\"pdf\", \"drawing\", \"progressbar\"]\n          }]\n        };\n        /* jshint eqnull: true */\n\n        (function ($, undefined) {\n          var kendo = window.kendo,\n              ui = kendo.ui,\n              DataSource = kendo.data.DataSource,\n              ObservableObject = kendo.data.ObservableObject,\n              tbodySupportsInnerHtml = kendo.support.tbodyInnerHtml,\n              activeElement = kendo._activeElement,\n              Widget = ui.Widget,\n              outerWidth = kendo._outerWidth,\n              outerHeight = kendo._outerHeight,\n              keys = kendo.keys,\n              isPlainObject = $.isPlainObject,\n              extend = $.extend,\n              map = $.map,\n              grep = $.grep,\n              isArray = Array.isArray,\n              inArray = $.inArray,\n              push = Array.prototype.push,\n              isFunction = kendo.isFunction,\n              isEmptyObject = $.isEmptyObject,\n              contains = $.contains,\n              math = Math,\n              DOT = \".\",\n              PROGRESS = \"progress\",\n              ERROR = \"error\",\n              HIERARCHY_CELL_CLASS = \"k-hierarchy-cell\",\n              DATA_CELL = \":not(.k-group-cell):not([\" + kendo.attr(\"virtual\") + \"]):not(.k-hierarchy-cell:not(:has(.k-icon.k-i-collapse,.k-icon.k-i-expand))):visible\",\n              SELECTION_CELL_SELECTOR = \"tbody>tr:not(.k-grouping-row):not(.k-detail-row):not(.k-group-footer) > td:not(.k-group-cell):not(.k-hierarchy-cell)\",\n              NAVROW = \"tr:not(.k-footer-template):visible\",\n              NAVCELL = \":not(.k-group-cell):not(.k-detail-cell):not(.k-hierarchy-cell):visible\",\n              ITEMROW = \"tr:not(.k-grouping-row):not(.k-detail-row):not(.k-footer-template):not(.k-group-footer):visible\",\n              COLGROUP = \"col:not(.k-group-col, .k-hierarchy-col)\",\n              HEADERCELLS = \"th.k-header:not(.k-group-cell):not(.k-hierarchy-cell)\",\n              WRAPPER = \".k-grid.k-widget\",\n              NS = \".kendoGrid\",\n              CONTENTRLOCKEDCONTAINER = \"k-grid-content-locked\",\n              GROUPCELLCLASS = \"k-group-cell\",\n              EDIT = \"edit\",\n              BEFOREEDIT = \"beforeEdit\",\n              SAVE = \"save\",\n              REMOVE = \"remove\",\n              DETAILINIT = \"detailInit\",\n              FILTERMENUINIT = \"filterMenuInit\",\n              COLUMNMENUINIT = \"columnMenuInit\",\n              FILTERMENUOPEN = \"filterMenuOpen\",\n              COLUMNMENUOPEN = \"columnMenuOpen\",\n              CELLCLOSE = \"cellClose\",\n              CHANGE = \"change\",\n              COLUMNHIDE = \"columnHide\",\n              COLUMNSHOW = \"columnShow\",\n              SAVECHANGES = \"saveChanges\",\n              DATABOUND = \"dataBound\",\n              DETAILEXPAND = \"detailExpand\",\n              DETAILCOLLAPSE = \"detailCollapse\",\n              ITEM_CHANGE = \"itemchange\",\n              PAGE = \"page\",\n              PAGING = \"paging\",\n              SCROLL = \"scroll\",\n              SYNC = \"sync\",\n              LOAD_START = \"loadStart\",\n              LOAD_END = \"loadEnd\",\n              FOCUSED = \"k-state-focused\",\n              FOCUSABLE = \":kendoFocusable\",\n              SELECTED = \"k-state-selected\",\n              CHECKBOX = \"k-checkbox\",\n              CHECKBOXINPUT = \"input[data-role='checkbox'].\" + CHECKBOX,\n              NORECORDSCLASS = \"k-grid-norecords\",\n              LINK_CLASS = \"k-link\",\n              ICON_CLASS = \"k-icon\",\n              ORDER_CLASS = \"k-sort-order\",\n              SORTED_CLASS = \"k-sorted\",\n              HEADER_COLUMN_MENU_CLASS = \"k-header-column-menu\",\n              FILTER_MENU_CLASS = \"k-grid-filter\",\n              STICKY_CELL_CLASS = \"k-grid-content-sticky\",\n              STICKY_HEADER_CLASS = \"k-grid-header-sticky\",\n              STICKY_FOOTER_CLASS = \"k-grid-footer-sticky\",\n              STICKY_HEADER_NO_BORDER_CLASS = \"k-grid-no-left-border\",\n              RESIZE = \"resize\",\n              COLUMNRESIZE = \"columnResize\",\n              COLUMNREORDER = \"columnReorder\",\n              COLUMNLOCK = \"columnLock\",\n              COLUMNUNLOCK = \"columnUnlock\",\n              COLUMNSTICK = \"columnStick\",\n              COLUMNUNSTICK = \"columnUnstick\",\n              ROWREORDER = \"rowReorder\",\n              NAVIGATE = \"navigate\",\n              CLICK = \"click\",\n              MOUSEDOWN = \"mousedown\",\n              HEIGHT = \"height\",\n              TABINDEX = \"tabIndex\",\n              FUNCTION = \"function\",\n              STRING = \"string\",\n              BOTTOM = \"bottom\",\n              CONTAINER_FOR = \"container-for\",\n              FIELD = \"field\",\n              INPUT = \"input\",\n              INCELL = \"incell\",\n              INLINE = \"inline\",\n              UNIQUE_ID = \"uid\",\n              MINCOLSPANVALUE = 1,\n              COLSPAN = \"colSpan\",\n              OVERFLOW = \"overflow\",\n              HIDDEN = \"hidden\",\n              SORT = \"sort\",\n              GROUP_SORT = \"group-sort\",\n              DELETECONFIRM = \"Are you sure you want to delete this record?\",\n              NORECORDS = \"No records available.\",\n              CONFIRMDELETE = \"Delete\",\n              CANCELDELETE = \"Cancel\",\n              COLLAPSE = \"Collapse\",\n              EXPAND = \"Expand\",\n              ARIALABEL = \"aria-label\",\n              formatRegExp = /(\\}|\\#)/ig,\n              templateHashRegExp = /#/ig,\n              whitespaceRegExp = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n              leftRegExp = new RegExp(\"(\\\\s*left\\\\s*:\\\\s*\\\\d*px;?)*\", \"ig\"),\n              rightRegExp = new RegExp(\"(\\\\s*right\\\\s*:\\\\s*\\\\d*px;?)*\", \"ig\"),\n              nonDataCellsRegExp = new RegExp(\"(^|\" + whitespaceRegExp + \")\" + \"(k-group-cell|k-hierarchy-cell)\" + \"(\" + whitespaceRegExp + \"|$)\"),\n              filterRowRegExp = new RegExp(\"(^|\" + whitespaceRegExp + \")\" + \"(k-filter-row)\" + \"(\" + whitespaceRegExp + \"|$)\"),\n              COMMANDBUTTONTMPL = '<button type=\"button\" class=\"#=className#\" #=attr#>#=text#</button>',\n              SELECTCOLUMNTMPL = '<input class=\"' + CHECKBOX + ' k-checkbox-md k-rounded-md\" data-role=\"checkbox\" aria-label=\"Select row\" aria-checked=\"false\" type=\"checkbox\">',\n              SELECTCOLUMNHEADERTMPL = '<input class=\"' + CHECKBOX + ' k-checkbox-md k-rounded-md\" data-role=\"checkbox\" aria-label=\"Select all rows\" aria-checked=\"false\" type=\"checkbox\">',\n              DRAGHANDLECOLUMNTMPL = '<span class=\"k-icon k-i-reorder\"></span>',\n              SORTHEADERTMPL = '<span class=\"k-cell-inner\"><span class=\"k-link\"><span class=\"k-column-title\">#=text#</span></span></span>',\n              isRtl = false,\n              browser = kendo.support.browser;\n          var isIE11 = browser.msie && browser.version === 11;\n          var isMac = /Mac OS/.test(navigator.userAgent);\n          var classNames = {\n            content: \"k-content\",\n            widget: \"k-widget\",\n            scrollContainer: \"k-scroll-container\",\n            headerCellInner: \"k-cell-inner\"\n          };\n          var GroupsPager;\n\n          if (ui.Pager) {\n            GroupsPager = ui.Pager.extend({\n              init: function (element, options) {\n                ui.Pager.fn.init.call(this, element, extend(true, {}, options));\n                this.dataSource.options.useRanges = true;\n                this.dataSource._omitPrefetch = true;\n              },\n              options: {\n                name: \"GroupsPager\"\n              },\n              totalPages: function () {\n                var that = this;\n                return Math.ceil((that._collapsedTotal() || 0) / (that.pageSize() || 1));\n              },\n              _collapsedTotal: function () {\n                var dataSource = this.dataSource;\n                return dataSource ? dataSource.groupsTotal(true) || 0 : 0;\n              }\n            });\n          }\n\n          var VirtualScrollable = Widget.extend({\n            init: function (element, options) {\n              var that = this;\n              Widget.fn.init.call(that, element, options);\n              that._refreshHandler = that.refresh.bind(that);\n              that.setDataSource(options.dataSource);\n              that.wrap();\n            },\n            setDataSource: function (dataSource) {\n              var that = this;\n\n              if (that.dataSource) {\n                that.dataSource.unbind(CHANGE, that._refreshHandler);\n              }\n\n              that.dataSource = dataSource;\n              that.dataSource.bind(CHANGE, that._refreshHandler);\n              that.dataSource.options.useRanges = true;\n              that.dataSource.options.virtual = true;\n            },\n            options: {\n              name: \"VirtualScrollable\",\n              itemHeight: $.noop,\n              prefetch: true,\n              maxScrollHeight: 250000\n            },\n            events: [PAGING, PAGE, SCROLL, LOAD_START, LOAD_END],\n            destroy: function () {\n              var that = this;\n              Widget.fn.destroy.call(that);\n              that.dataSource.unbind(CHANGE, that._refreshHandler);\n              that.wrapper.add(that.verticalScrollbar).off(NS);\n              clearTimeout(that._timeout);\n\n              if (that._scrollingTimeout) {\n                clearTimeout(that._scrollingTimeout);\n              }\n\n              if (that.drag) {\n                that.drag.destroy();\n                that.drag = null;\n              }\n\n              that.wrapper = that.element = that.verticalScrollbar = null;\n              that._refreshHandler = null;\n            },\n            wrap: function () {\n              var that = this,\n                  // workaround for IE issue where scroll is not raised if container is same width as the scrollbar\n              scrollbar = kendo.support.scrollbar() + 1,\n                  element = that.element,\n                  wrapper;\n              element.css({\n                width: \"auto\",\n                overflow: \"hidden\"\n              }).css(isRtl ? \"padding-left\" : \"padding-right\", scrollbar);\n              that.content = element.children().first();\n              wrapper = that.wrapper = that.content.wrap('<div class=\"k-virtual-scrollable-wrap\"/>').parent().on(\"DOMMouseScroll\" + NS + \" mousewheel\" + NS, that._wheelScroll.bind(that));\n\n              that._wrapper();\n\n              if (kendo.support.kineticScrollNeeded || kendo.support.touch) {\n                that.wrapper.css(\"touch-action\", \"none\");\n                that.drag = new kendo.UserEvents(that.wrapper, {\n                  global: true,\n                  allowSelection: true,\n                  start: function (e) {\n                    e.sender.capture();\n                  },\n                  move: function (e) {\n                    that.verticalScrollbar.scrollTop(that.verticalScrollbar.scrollTop() - e.y.delta);\n                    kendo.scrollLeft(wrapper, kendo.scrollLeft(wrapper) - e.x.delta);\n                    e.preventDefault();\n                  }\n                });\n              }\n\n              that.verticalScrollbar = $('<div class=\"k-scrollbar k-scrollbar-vertical\" />').css({\n                width: scrollbar\n              }).appendTo(element).on(\"scroll\" + NS, that._scroll.bind(that));\n            },\n            _wrapper: function () {\n              var that = this;\n\n              if (isIE11) {\n                //scrolling the virtual scrollbar to the bottom and then\n                //scrolling the horizontal content scrollbar does not fire the \"scroll\" event\n                //seems like a problem in IE 11 only (after version 11.0.9600.18860)\n                //https://github.com/telerik/kendo-ui-core/issues/3779\n                that.wrapper.css({\n                  \"overflow-y\": SCROLL\n                }); //hide the wrapper behind the virtual scrollbar\n\n                that.element.css(isRtl ? \"padding-left\" : \"padding-right\", 0);\n              }\n            },\n            _wheelScroll: function (e) {\n              if (e.ctrlKey) {\n                return;\n              }\n\n              var scrollbar = this.verticalScrollbar,\n                  scrollTop = scrollbar.scrollTop(),\n                  delta = kendo.wheelDeltaY(e);\n\n              if (delta && !(delta > 0 && scrollTop === 0) && !(delta < 0 && scrollTop + scrollbar[0].clientHeight == scrollbar[0].scrollHeight)) {\n                e.preventDefault();\n                this.verticalScrollbar.scrollTop(scrollTop + -delta);\n              }\n            },\n            _scroll: function (e) {\n              var that = this,\n                  delayLoading = !that.options.prefetch,\n                  scrollTop = e.currentTarget.scrollTop,\n                  dataSource = that.dataSource,\n                  rowHeight = that.itemHeight,\n                  skip = dataSource.skip() || 0,\n                  start = that._rangeStart || skip,\n                  height = that.element.innerHeight(),\n                  isScrollingUp = !!(that._scrollbarTop && that._scrollbarTop > scrollTop),\n                  firstItemIndex = math.max(math.floor(scrollTop / rowHeight), 0),\n                  lastItemOffset = isScrollingUp ? math.ceil(height / rowHeight) : math.floor(height / rowHeight),\n                  lastItemIndex = math.max(firstItemIndex + lastItemOffset, 0);\n\n              if (that._preventScroll) {\n                that._preventScroll = false;\n                return;\n              }\n\n              that._prevScrollTop = that._scrollTop;\n              that._scrollTop = scrollTop - start * rowHeight;\n              that._scrollbarTop = scrollTop;\n              that._scrolling = delayLoading;\n\n              if (!that._fetch(firstItemIndex, lastItemIndex, isScrollingUp)) {\n                that.wrapper[0].scrollTop = that._scrollTop;\n              }\n\n              that.trigger(SCROLL);\n\n              if (delayLoading) {\n                if (that._scrollingTimeout) {\n                  clearTimeout(that._scrollingTimeout);\n                }\n\n                that._scrollingTimeout = setTimeout(function () {\n                  that._scrolling = false;\n\n                  that._page(that._rangeStart, that.dataSource.take());\n                }, 100);\n              }\n            },\n            scrollToTop: function () {\n              this._scrollTo(0);\n            },\n            scrollToBottom: function () {\n              var scrollbar = this.verticalScrollbar;\n\n              this._scrollTo(scrollbar[0].scrollHeight - scrollbar.height());\n            },\n            _scrollWrapperToTop: function () {\n              this.wrapper.scrollTop(0);\n            },\n            _scrollWrapperToBottom: function () {\n              this.wrapper.scrollTop(this.wrapper[0].scrollHeight);\n            },\n            _scrollWrapperOnColumnResize: function () {\n              var that = this;\n              var wrapper = this.wrapper;\n              var initialScrollTop = wrapper.scrollTop();\n\n              if (wrapper[0].scrollWidth > wrapper[0].clientWidth) {\n                if (!that._wrapperScrolled && initialScrollTop || that._isScrolledToBottom()) {\n                  wrapper.scrollTop(initialScrollTop + kendo.support.scrollbar());\n                  that._scrollTop = wrapper.scrollTop();\n                  that._wrapperScrolled = true;\n                }\n              } else if (that._wrapperScrolled) {\n                if (!that._isWrapperScrolledToBottom()) {\n                  wrapper.scrollTop(initialScrollTop - kendo.support.scrollbar());\n                  that._scrollTop = wrapper.scrollTop();\n                }\n\n                that._wrapperScrolled = false;\n              }\n            },\n            _scrollTo: function (scrollTop) {\n              var that = this;\n              var scrollbar = that.verticalScrollbar;\n\n              if (scrollbar.scrollTop() !== scrollTop) {\n                that._preventScroll = true;\n              }\n\n              that.wrapper.scrollTop(scrollTop);\n              that._scrollTop = that.wrapper.scrollTop();\n              scrollbar.scrollTop(scrollTop);\n              that._scrollbarTop = scrollbar.scrollTop();\n            },\n            _isScrolledToTop: function () {\n              return this.verticalScrollbar.scrollTop() === 0;\n            },\n            _isScrolledToBottom: function () {\n              var scrollbar = this.verticalScrollbar;\n              var scrollTop = scrollbar.scrollTop();\n              return scrollTop > 0 && scrollTop >= parseInt(scrollbar[0].scrollHeight - scrollbar.height(), 10);\n            },\n            _isWrapperScrolledToBottom: function () {\n              var wrapper = this.wrapper;\n              return wrapper.scrollTop() >= parseInt(wrapper[0].scrollHeight - wrapper.height(), 10);\n            },\n            itemIndex: function (rowIndex) {\n              var rangeStart = this._rangeStart || this.dataSource.skip() || 0;\n              return rangeStart + rowIndex;\n            },\n            position: function (index) {\n              var rangeStart = this._rangeStart || this.dataSource.skip() || 0;\n              var pageSize = this.dataSource.pageSize();\n              var result;\n\n              if (index > rangeStart) {\n                result = index - rangeStart;\n              } else {\n                result = rangeStart - index - 1;\n              }\n\n              return result > pageSize ? pageSize : result;\n            },\n            scrollIntoView: function (row) {\n              var container = this.wrapper[0];\n              var containerHeight = container.clientHeight;\n              var containerScroll = !this._isScrolledToBottom() ? this._scrollTop || container.scrollTop : container.scrollTop;\n              var elementOffset = row[0].offsetTop;\n              var elementHeight = row[0].offsetHeight;\n\n              if (containerScroll > elementOffset) {\n                this.verticalScrollbar[0].scrollTop -= containerHeight / 2;\n              } else if (elementOffset + elementHeight >= containerScroll + containerHeight) {\n                this.verticalScrollbar[0].scrollTop += containerHeight / 2;\n              }\n            },\n            _fetch: function (firstItemIndex, lastItemIndex, scrollingUp) {\n              var that = this,\n                  dataSource = that.dataSource,\n                  itemHeight = that.itemHeight,\n                  take = dataSource.take(),\n                  rangeStart = that._rangeStart || dataSource.skip() || 0,\n                  currentSkip = math.floor(firstItemIndex / take) * take,\n                  fetching = false,\n                  prefetchAt = 0.33;\n              var scrollbar = that.verticalScrollbar;\n              var webkitCorrection = browser.webkit ? 1 : 0;\n              var total = dataSource._isGroupPaged() ? dataSource.groupsTotal(true) : dataSource.total();\n\n              if (firstItemIndex < rangeStart) {\n                fetching = true;\n                rangeStart = math.max(0, lastItemIndex - take);\n                that._scrollTop = scrollbar.scrollTop() - rangeStart * itemHeight;\n\n                that._page(rangeStart, take);\n              } else if (lastItemIndex >= rangeStart + take && !scrollingUp) {\n                fetching = true;\n                rangeStart = math.min(firstItemIndex, total - take); //ensure the scrollbar can be scrolled to bottom with mouse drag\n\n                if (scrollbar.scrollTop() >= scrollbar[0].scrollHeight - scrollbar[0].offsetHeight - webkitCorrection) {\n                  that._scrollTop = that.wrapper[0].scrollHeight - that.wrapper[0].offsetHeight;\n                } else if (that.dataSource._isGroupPaged() && firstItemIndex >= total - take) {\n                  that._scrollTop = that.wrapper[0].scrollHeight - that.wrapper[0].offsetHeight - (that._scrollTop - that._prevScrollTop);\n                } else {\n                  that._scrollTop = itemHeight;\n                }\n\n                that._page(rangeStart, take);\n              } else if (!that._fetching && that.options.prefetch) {\n                if (firstItemIndex < currentSkip + take - take * prefetchAt && firstItemIndex > take) {\n                  dataSource.prefetch(currentSkip - take, take, $.noop);\n                }\n\n                if (lastItemIndex > currentSkip + take * prefetchAt) {\n                  dataSource.prefetch(currentSkip + take, take, $.noop);\n                }\n              }\n\n              return fetching;\n            },\n            fetching: function () {\n              return this._fetching;\n            },\n            _page: function (skip, take, callback) {\n              var that = this,\n                  delayLoading = !that.options.prefetch,\n                  dataSource = that.dataSource,\n                  isGroupPaged = dataSource._isGroupPaged();\n\n              callback = isFunction(callback) ? callback : $.noop;\n\n              if (that.trigger(PAGING, {\n                skip: skip,\n                take: take\n              })) {\n                return;\n              }\n\n              clearTimeout(that._timeout);\n              that._fetching = true;\n              that._rangeStart = skip;\n\n              if (isGroupPaged && dataSource._groupRangeExists(skip, skip + take) || !isGroupPaged && dataSource.inRange(skip, take)) {\n                that.trigger(LOAD_START);\n                dataSource.range(skip, take, function () {\n                  that.trigger(LOAD_END);\n                  callback();\n                  that.trigger(PAGE);\n                }, \"page\");\n              } else {\n                if (!delayLoading) {\n                  that.trigger(LOAD_START);\n                }\n\n                that._timeout = setTimeout(function () {\n                  if (!that._scrolling) {\n                    if (delayLoading) {\n                      that.trigger(LOAD_START);\n                    }\n\n                    dataSource.range(skip, take, function () {\n                      that.trigger(LOAD_END);\n                      callback();\n                      that.trigger(PAGE);\n                    });\n                  }\n                }, 100);\n              }\n            },\n            repaintScrollbar: function (shouldScrollWrapper) {\n              var that = this,\n                  html = \"\",\n                  maxHeight = that.options.maxScrollHeight,\n                  dataSource = that.dataSource,\n                  scrollbar = !kendo.support.kineticScrollNeeded ? kendo.support.scrollbar() : 0,\n                  wrapperElement = that.wrapper[0],\n                  totalHeight,\n                  idx,\n                  itemHeight;\n\n              var wasScrolledToBottom = that._isScrolledToBottom();\n\n              itemHeight = that.itemHeight = that.options.itemHeight() || 0;\n              var addScrollBarHeight = wrapperElement.scrollWidth > wrapperElement.offsetWidth ? scrollbar : 0;\n              totalHeight = (dataSource._isGroupPaged() ? dataSource.groupsTotal(true) : dataSource.total()) * itemHeight + addScrollBarHeight;\n\n              for (idx = 0; idx < math.floor(totalHeight / maxHeight); idx++) {\n                html += '<div style=\"width:1px;height:' + maxHeight + 'px\"></div>';\n              }\n\n              if (totalHeight % maxHeight) {\n                html += '<div style=\"width:1px;height:' + totalHeight % maxHeight + 'px\"></div>';\n              }\n\n              that.verticalScrollbar.html(html);\n\n              if (wasScrolledToBottom && !that._isScrolledToBottom() && !that.dataSource._isGroupPaged()) {\n                that.scrollToBottom();\n              }\n\n              if (typeof that._scrollTop !== \"undefined\" && !!shouldScrollWrapper) {\n                wrapperElement.scrollTop = that._scrollTop;\n\n                that._scrollWrapperOnColumnResize();\n              }\n            },\n            refresh: function (e) {\n              var that = this,\n                  dataSource = that.dataSource,\n                  rangeStart = that._rangeStart;\n              var action = (e || {}).action;\n              var shouldScrollWrapper = that._isScrolledToBottom() || !action || action !== ITEM_CHANGE && action !== REMOVE && action !== SYNC;\n              that.trigger(LOAD_END);\n              clearTimeout(that._timeout);\n              that.repaintScrollbar(shouldScrollWrapper);\n\n              if (that.drag) {\n                that.drag.cancel();\n              }\n\n              if (typeof rangeStart !== \"undefined\" && !that._fetching) {\n                // we are rebound from outside local range should be reset\n                if (!action || action !== SYNC && action !== ITEM_CHANGE && action !== \"expandGroup\") {\n                  that._rangeStart = dataSource.skip();\n                }\n\n                if (dataSource.page() === 1 && (!action || action !== SYNC && action !== ITEM_CHANGE && action !== \"expandGroup\" && action !== \"collapseGroup\")) {\n                  // reset the scrollbar position if datasource is filtered\n                  that.verticalScrollbar[0].scrollTop = 0;\n                }\n              }\n\n              that._fetching = false;\n            }\n          });\n\n          function attrEquals(attrName, attrValue) {\n            return \"[\" + kendo.attr(attrName) + \"=\" + attrValue + \"]\";\n          }\n\n          function groupCells(count) {\n            return new Array(count + 1).join('<td class=\"k-group-cell\">&nbsp;</td>');\n          }\n\n          function stringifyAttributes(attributes) {\n            var attr,\n                result = \" \";\n\n            if (attributes) {\n              if (typeof attributes === STRING) {\n                return attributes;\n              }\n\n              for (attr in attributes) {\n                if (attributes[attr] !== '') {\n                  result += attr + '=\"' + attributes[attr] + '\"';\n                }\n              }\n            }\n\n            return result;\n          }\n\n          var defaultCommands = {\n            create: {\n              text: \"Add new record\",\n              className: \"k-grid-add\",\n              iconClass: \"k-icon k-i-plus\"\n            },\n            cancel: {\n              text: \"Cancel changes\",\n              className: \"k-grid-cancel-changes\",\n              iconClass: \"k-icon k-i-cancel\"\n            },\n            save: {\n              text: \"Save changes\",\n              className: \"k-grid-save-changes\",\n              iconClass: \"k-icon k-i-check\"\n            },\n            destroy: {\n              text: \"Delete\",\n              className: \"k-grid-delete\",\n              iconClass: \"k-icon k-i-close\"\n            },\n            edit: {\n              text: \"Edit\",\n              className: \"k-grid-edit\",\n              iconClass: \"k-icon k-i-edit\"\n            },\n            update: {\n              text: \"Update\",\n              className: \"k-grid-update\",\n              iconClass: \"k-icon k-i-check\",\n              themeColor: \"primary\"\n            },\n            canceledit: {\n              text: \"Cancel\",\n              className: \"k-grid-cancel\",\n              iconClass: \"k-icon k-i-cancel\"\n            },\n            excel: {\n              text: \"Export to Excel\",\n              className: \"k-grid-excel\",\n              iconClass: \"k-icon k-i-file-excel\"\n            },\n            pdf: {\n              text: \"Export to PDF\",\n              className: \"k-grid-pdf\",\n              iconClass: \"k-icon k-i-file-pdf\"\n            },\n            search: {\n              text: \"Search...\",\n              className: \"k-grid-search\"\n            }\n          };\n\n          function cursor(context, value) {\n            $('th, th .k-grid-filter, th .k-link', context).add(document.body).css('cursor', value);\n          }\n\n          function reorder(selector, source, dest, before, count) {\n            var sourceIndex = source;\n            source = $();\n            count = count || 1;\n\n            for (var idx = 0; idx < count; idx++) {\n              source = source.add(selector.eq(sourceIndex + idx));\n            }\n\n            if (typeof dest == \"number\") {\n              source[before ? \"insertBefore\" : \"insertAfter\"](selector.eq(dest));\n            } else {\n              source.appendTo(dest);\n            }\n          }\n\n          function elements(lockedContent, content, filter) {\n            return $(lockedContent).add(content).find(filter);\n          }\n\n          function attachCustomCommandEvent(context, container, commands) {\n            var idx, length, command, commandName;\n            commands = !isArray(commands) ? [commands] : commands;\n\n            for (idx = 0, length = commands.length; idx < length; idx++) {\n              command = commands[idx];\n\n              if (isPlainObject(command) && command.click) {\n                commandName = command.name || command.text;\n                container.on(CLICK + NS, \".k-grid-\" + (commandName || \"\").replace(/\\s/g, \"\"), {\n                  commandName: commandName\n                }, command.click.bind(context));\n              }\n            }\n          }\n\n          function normalizeColumns(columns, encoded, hide, locked, parentIds) {\n            return map(columns, function (column) {\n              column = typeof column === STRING ? {\n                field: column\n              } : column;\n              var hidden;\n              column.parentIds = parentIds;\n\n              if (!isVisible(column) || hide) {\n                column.attributes = addHiddenStyle(column.attributes);\n                column.footerAttributes = addHiddenStyle(column.footerAttributes);\n                column.headerAttributes = addHiddenStyle(column.headerAttributes);\n                hidden = true;\n              }\n\n              var uid = kendo.guid();\n\n              if (locked && !column.locked) {\n                column.locked = locked;\n              }\n\n              column.headerAttributes = extend({\n                headers: parentIds\n              }, column.headerAttributes);\n\n              if (!column.headerAttributes.id) {\n                column.headerAttributes = extend({\n                  id: uid\n                }, column.headerAttributes);\n                column.uid = uid;\n              } else {\n                uid = column.headerAttributes.id;\n              }\n\n              if (column.columns) {\n                column.columns = normalizeColumns(column.columns, encoded, hidden, column.locked, parentIds ? parentIds + \" \" + uid : uid);\n              }\n\n              return extend({\n                encoded: encoded,\n                hidden: hidden,\n                locked: locked\n              }, column);\n            });\n          }\n\n          function columnParent(column, columns) {\n            var parents = [];\n            columnParents(column, columns, parents);\n            return parents[parents.length - 1];\n          }\n\n          function columnParents(column, columns, parents) {\n            parents = parents || [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (column === columns[idx]) {\n                return true;\n              } else if (columns[idx].columns) {\n                var inserted = parents.length;\n                parents.push(columns[idx]);\n\n                if (!columnParents(column, columns[idx].columns, parents)) {\n                  parents.splice(inserted, parents.length - inserted);\n                } else {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          }\n\n          function setColumnVisibility(column, visible) {\n            setVisibility(column, visible, visible);\n          }\n\n          function setVisibility(column, visible, show) {\n            var method = show ? removeHiddenStyle : addHiddenStyle;\n            column.hidden = !visible;\n            column.attributes = method(column.attributes);\n            column.footerAttributes = method(column.footerAttributes);\n            column.headerAttributes = method(column.headerAttributes);\n          }\n\n          function setColumnMediaVisibility(column, visible) {\n            setColumnMatchesMedia(column);\n            var hideByMedia = column._hideByMedia;\n            setVisibility(column, visible, hideByMedia ? column.matchesMedia : visible);\n          }\n\n          function setColumnMatchesMedia(column) {\n            column.matchesMedia = columnMatchesMedia(column);\n          }\n\n          function columnMatchesMedia(column) {\n            return column && (isUndefined(column.media) || !isUndefined(column.media) && kendo.matchesMedia(column.media));\n          }\n\n          function isCellVisible() {\n            return this.style.display !== \"none\";\n          }\n\n          function isElementVisible(element) {\n            return $(element)[0].style.display !== \"none\";\n          }\n\n          function isVisible(column) {\n            return visibleColumns([column]).length > 0;\n          }\n\n          function visibleColumns(columns) {\n            return grep(columns, function (column) {\n              var result = !column.hidden && column.matchesMedia !== false;\n\n              if (result && column.columns) {\n                result = visibleColumns(column.columns).length > 0;\n              }\n\n              return result;\n            });\n          }\n\n          function columnsWithMedia(columns) {\n            var result = [];\n            var column;\n\n            for (var i = 0; i < columns.length; i++) {\n              column = columns[i];\n\n              if (!isUndefined(column.media)) {\n                if (!isUndefined(column.minScreenWidth)) {\n                  throw new Error(\"Using 'media' and 'minScreenWidth' options at the same time is not supported.\");\n                }\n\n                result.push(column);\n              }\n\n              if (column.columns) {\n                result = result.concat(columnsWithMedia(column.columns));\n              }\n            }\n\n            return result;\n          }\n\n          function isUndefined(value) {\n            return typeof value === \"undefined\";\n          }\n\n          function toJQuery(elements) {\n            return $(elements).map(function () {\n              return this.toArray();\n            });\n          }\n\n          function updateCellRowSpan(cell, columns, sourceLockedColumnsCount) {\n            var lockedColumnDepth = depth(lockedColumns(columns));\n            var nonLockedColumnDepth = depth(nonLockedColumns(columns));\n            var rowSpan = cell.rowSpan;\n\n            if (sourceLockedColumnsCount) {\n              if (lockedColumnDepth > nonLockedColumnDepth) {\n                cell.rowSpan = rowSpan - (lockedColumnDepth - nonLockedColumnDepth) || 1;\n              } else {\n                cell.rowSpan = rowSpan + (nonLockedColumnDepth - lockedColumnDepth);\n              }\n            } else {\n              if (lockedColumnDepth > nonLockedColumnDepth) {\n                cell.rowSpan = rowSpan + (lockedColumnDepth - nonLockedColumnDepth);\n              } else {\n                cell.rowSpan = rowSpan - (nonLockedColumnDepth - lockedColumnDepth) || 1;\n              }\n            }\n          }\n\n          function findColumnByField(columns, field) {\n            for (var i = 0; i < columns.length; i++) {\n              if (columns[i].field == field) {\n                return columns[i];\n              }\n            }\n          }\n\n          function moveCellsBetweenContainers(sources, target, leafs, columns, container, destination, groups, action) {\n            var sourcesDepth = depth(sources);\n            var targetDepth = depth([target]);\n\n            if (sourcesDepth > targetDepth) {\n              var groupCells = new Array(groups + 1).join('<th class=\"k-group-cell k-header\" scope=\"col\">&nbsp;</th>');\n              var rows = destination.children(\":not(.k-filter-row)\");\n              $(new Array(sourcesDepth - targetDepth + 1).join(\"<tr>\" + groupCells + \"</tr>\")).insertAfter(rows.last());\n            }\n\n            addRowSpanValue(destination, sourcesDepth - targetDepth);\n            moveCells(leafs, columns, container, destination, action);\n          }\n\n          function updateCellIndex(thead, columns, offset) {\n            offset = offset || 0;\n            var position;\n            var cell;\n            var allColumns = columns;\n            columns = leafColumns(columns);\n            var cells = {};\n            var rows = thead.find(\">tr:not(.k-filter-row)\");\n\n            var filter = function () {\n              var el = $(this);\n              return !el.hasClass(\"k-group-cell\") && !el.hasClass(\"k-hierarchy-cell\");\n            };\n\n            for (var idx = 0, length = columns.length; idx < length; idx++) {\n              position = columnPosition(columns[idx], allColumns);\n\n              if (!cells[position.row]) {\n                cells[position.row] = rows.eq(position.row).find(\".k-header\").filter(filter);\n              }\n\n              cell = cells[position.row].eq(position.cell);\n              cell.attr(kendo.attr(\"index\"), offset + idx);\n            }\n\n            return columns.length;\n          }\n\n          function depth(columns) {\n            var result = 1;\n            var max = 0;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].columns) {\n                var temp = depth(columns[idx].columns);\n\n                if (temp > max) {\n                  max = temp;\n                }\n              }\n            }\n\n            return result + max;\n          }\n\n          function moveCells(leafs, columns, container, destination, action) {\n            var sourcePosition = columnVisiblePosition(leafs[0], columns);\n            var ths = container.find(\">tr:not(.k-filter-row)\").eq(sourcePosition.row).children(\"th.k-header\");\n            var t = $();\n            var sourceIndex = sourcePosition.cell;\n            var idx;\n\n            for (idx = 0; idx < leafs.length; idx++) {\n              t = t.add(ths.eq(sourceIndex + idx));\n            }\n\n            destination.find(\">tr:not(.k-filter-row)\").eq(sourcePosition.row)[action](t);\n            var children = [];\n\n            for (idx = 0; idx < leafs.length; idx++) {\n              if (leafs[idx].columns) {\n                children = children.concat(leafs[idx].columns);\n              }\n            }\n\n            if (children.length) {\n              moveCells(children, columns, container, destination, action);\n            }\n          }\n\n          function columnPosition(column, columns, row, cellCounts) {\n            var result;\n            var idx;\n            row = row || 0;\n            cellCounts = cellCounts || {};\n            cellCounts[row] = cellCounts[row] || 0;\n\n            for (idx = 0; idx < columns.length; idx++) {\n              if (columns[idx] == column) {\n                result = {\n                  cell: cellCounts[row],\n                  row: row\n                };\n                break;\n              } else if (columns[idx].columns) {\n                result = columnPosition(column, columns[idx].columns, row + 1, cellCounts);\n\n                if (result) {\n                  break;\n                }\n              }\n\n              cellCounts[row]++;\n            }\n\n            return result;\n          }\n\n          function findParentColumnWithChildren(columns, index, source, rtl) {\n            var target;\n            var locked = !!source.locked;\n            var targetLocked;\n\n            do {\n              target = columns[index];\n              index += rtl ? 1 : -1;\n              targetLocked = !!target.locked;\n            } while (target && index > -1 && index < columns.length && target != source && !target.columns && targetLocked === locked);\n\n            return target;\n          }\n\n          function findReorderTarget(columns, target, source, before, masterColumns) {\n            if (target.columns) {\n              target = target.columns;\n              return target[before ? 0 : target.length - 1];\n            } else {\n              var parent = columnParent(target, columns);\n              var parentColumns;\n\n              if (parent) {\n                parentColumns = parent.columns;\n              } else {\n                parentColumns = columns;\n              }\n\n              var index = inArray(target, parentColumns);\n\n              if (index === 0 && before) {\n                index++;\n              } else if (index == parentColumns.length - 1 && !before || !source.locked && !target.columns && !before) {\n                index--;\n              } else if (index > 0 || index === 0 && !before) {\n                index++;\n              }\n\n              var sourceIndex = inArray(source, parentColumns);\n              target = findParentColumnWithChildren(parentColumns, index, source, sourceIndex > index);\n              var targetIndex = inArray(target, masterColumns);\n\n              if (target.columns && (!targetIndex || targetIndex === parentColumns.length - 1)) {\n                return null;\n              }\n\n              if (target && target != source && target.columns) {\n                return findReorderTarget(columns, target, source, before, masterColumns);\n              }\n            }\n\n            return null;\n          }\n\n          function columnVisiblePosition(column, columns, row, cellCounts) {\n            var result;\n            var idx;\n            row = row || 0;\n            cellCounts = cellCounts || {};\n            cellCounts[row] = cellCounts[row] || 0;\n\n            for (idx = 0; idx < columns.length; idx++) {\n              if (columns[idx] == column) {\n                result = {\n                  cell: cellCounts[row],\n                  row: row\n                };\n                break;\n              } else if (columns[idx].columns) {\n                result = columnVisiblePosition(column, columns[idx].columns, row + 1, cellCounts);\n\n                if (result) {\n                  break;\n                }\n              }\n\n              if (!columns[idx].hidden) {\n                cellCounts[row]++;\n              }\n            }\n\n            return result;\n          }\n\n          function flatColumnsInDomOrder(columns) {\n            var result = flatColumns(lockedColumns(columns));\n            return result.concat(flatColumns(nonLockedColumns(columns)));\n          }\n\n          function targetParentContainerIndex(flatColumns, columns, sourceIndex, targetIndex) {\n            var column = flatColumns[sourceIndex];\n            var target = flatColumns[targetIndex];\n            var parent = columnParent(column, columns);\n            columns = parent ? parent.columns : columns;\n            return inArray(target, columns);\n          }\n\n          function flatColumns(columns) {\n            var result = [];\n            var children = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              result.push(columns[idx]);\n\n              if (columns[idx].columns) {\n                children = children.concat(columns[idx].columns);\n              }\n            }\n\n            if (children.length) {\n              result = result.concat(flatColumns(children));\n            }\n\n            return result;\n          }\n\n          function hiddenLeafColumnsCount(columns) {\n            var counter = 0;\n            var column;\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              column = columns[idx];\n\n              if (column.columns) {\n                counter += hiddenLeafColumnsCount(column.columns);\n              } else if (column.hidden) {\n                counter++;\n              }\n            }\n\n            return counter;\n          }\n\n          function sumWidths(cols) {\n            var width = 0;\n\n            for (var idx = 0, length = cols.length; idx < length; idx++) {\n              if (!cols[idx].hidden) {\n                width += parseInt(cols[idx].width, 10);\n              }\n            }\n\n            return width;\n          }\n\n          function columnsWidth(cols) {\n            var colWidth,\n                width = 0;\n\n            for (var idx = 0, length = cols.length; idx < length; idx++) {\n              colWidth = cols[idx].style.width;\n\n              if (colWidth && colWidth.indexOf(\"%\") == -1) {\n                width += parseInt(colWidth, 10);\n              }\n            }\n\n            return width;\n          }\n\n          function removeRowSpanValue(container, count) {\n            var cells = container.find(\"tr:not(.k-filter-row) th:not(.k-group-cell,.k-hierarchy-cell)\");\n            var rowSpan;\n\n            for (var idx = 0; idx < cells.length; idx++) {\n              rowSpan = cells[idx].rowSpan;\n\n              if (rowSpan > 1) {\n                cells[idx].rowSpan = rowSpan - count || 1;\n              }\n            }\n          }\n\n          function addRowSpanValue(container, count) {\n            var cells = container.find(\"tr:not(.k-filter-row) th:not(.k-group-cell,.k-hierarchy-cell)\");\n\n            for (var idx = 0; idx < cells.length; idx++) {\n              cells[idx].rowSpan += count;\n            }\n          }\n\n          function removeEmptyRows(container) {\n            var rows = container.find(\"tr:not(.k-filter-row)\");\n            var emptyRowsCount = rows.filter(function () {\n              return !$(this).children().length;\n            }).remove().length;\n            var cells = rows.find(\"th:not(.k-group-cell,.k-hierarchy-cell)\");\n\n            for (var idx = 0; idx < cells.length; idx++) {\n              if (cells[idx].rowSpan > 1) {\n                cells[idx].rowSpan -= emptyRowsCount;\n              }\n            }\n\n            return rows.length - emptyRowsCount;\n          }\n\n          function mapColumnToCellRows(columns, cells, rows, rowIndex, offset) {\n            var idx,\n                row,\n                length,\n                children = [];\n\n            for (idx = 0, length = columns.length; idx < length; idx++) {\n              row = rows[rowIndex] || [];\n              row.push(cells.eq(offset + idx));\n              rows[rowIndex] = row;\n\n              if (columns[idx].columns) {\n                children = children.concat(columns[idx].columns);\n              }\n            }\n\n            if (children.length) {\n              mapColumnToCellRows(children, cells, rows, rowIndex + 1, offset + columns.length);\n            }\n          }\n\n          function setLeftAndRightStyles(element, left, right) {\n            element.css({\n              \"left\": left,\n              \"right\": right\n            });\n          }\n\n          function createColumnAttribute(column, attribute, property) {\n            column[attribute] = column[attribute] || {};\n            column[attribute][property] = column[attribute][property] || \"\";\n          }\n\n          function addColumnAttribute(column, attribute, property, value) {\n            createColumnAttribute(column, attribute, property);\n\n            if (column[attribute][property] !== \"\") {\n              column[attribute][property] += \" \" + value;\n            } else {\n              column[attribute][property] = value;\n            }\n          }\n\n          function removeColumnAttribute(column, attribute, property, value) {\n            createColumnAttribute(column, attribute, property);\n            column[attribute][property] = column[attribute][property].replace(value, \"\");\n          }\n\n          function lockedColumns(columns) {\n            return grep(columns, function (column) {\n              return column.locked;\n            });\n          }\n\n          function nonLockedColumns(columns) {\n            return grep(columns, function (column) {\n              return !column.locked;\n            });\n          }\n\n          function stickyColumns(columns) {\n            return grep(columns, function (column) {\n              return column.sticky && !column.locked;\n            });\n          }\n\n          function visibleStickyColumns(columns) {\n            return grep(columns, function (column) {\n              return column.sticky && !column.locked && isVisible(column);\n            });\n          }\n\n          function visibleNonLockedColumns(columns) {\n            return grep(columns, function (column) {\n              return !column.locked && isVisible(column);\n            });\n          }\n\n          function visibleLockedColumns(columns) {\n            return grep(columns, function (column) {\n              return column.locked && isVisible(column);\n            });\n          }\n\n          function visibleLeafColumns(columns) {\n            var result = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].hidden) {\n                continue;\n              }\n\n              if (columns[idx].columns) {\n                result = result.concat(visibleLeafColumns(columns[idx].columns));\n              } else {\n                result.push(columns[idx]);\n              }\n            }\n\n            return result;\n          }\n\n          function childColumns(columns) {\n            var result = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (columns[idx].columns) {\n                result = result.concat(columns[idx].columns);\n              }\n            }\n\n            return result;\n          }\n\n          function visibleChildColumns(columns) {\n            var result = childColumns(columns);\n            result = result.filter(function (e) {\n              return !e.hidden;\n            });\n            return result;\n          }\n\n          function leafColumns(columns) {\n            var result = [];\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (!columns[idx].columns) {\n                result.push(columns[idx]);\n                continue;\n              }\n\n              result = result.concat(leafColumns(columns[idx].columns));\n            }\n\n            return result;\n          }\n\n          function getColumnsFields(columns) {\n            var result = [];\n            columns = leafColumns(columns);\n\n            for (var idx = 0; idx < columns.length; idx++) {\n              if (typeof columns[idx] === \"string\") {\n                result.push(columns[idx]);\n              } else if (columns[idx].field) {\n                result.push(columns[idx].field);\n              }\n            }\n\n            return result;\n          }\n\n          function leafDataCells(container) {\n            var rows = container.find(\">tr:not(.k-filter-row)\");\n\n            var filter = function () {\n              var el = $(this);\n              return !el.hasClass(\"k-group-cell\") && !el.hasClass(\"k-hierarchy-cell\");\n            };\n\n            var cells = $();\n\n            if (rows.length > 1) {\n              cells = rows.find(\"th\").filter(filter).filter(function () {\n                return this.rowSpan > 1;\n              });\n            }\n\n            cells = cells.add(rows.last().find(\"th\").filter(filter));\n            var indexAttr = kendo.attr(\"index\");\n            cells.sort(function (a, b) {\n              a = $(a);\n              b = $(b);\n              var indexA = a.attr(indexAttr);\n              var indexB = b.attr(indexAttr);\n\n              if (indexA === undefined) {\n                indexA = $(a).index();\n              }\n\n              if (indexB === undefined) {\n                indexB = $(b).index();\n              }\n\n              indexA = parseInt(indexA, 10);\n              indexB = parseInt(indexB, 10);\n              return indexA > indexB ? 1 : indexA < indexB ? -1 : 0;\n            });\n            return cells;\n          }\n\n          function parentColumnsCells(cell) {\n            var container = cell.closest(\"table\");\n            var result = $().add(cell);\n            var row = cell.closest(\"tr\");\n            var headerRows = container.find(\"tr:not(.k-filter-row)\");\n            var level = headerRows.index(row);\n\n            if (level > 0) {\n              var parent = headerRows.eq(level - 1);\n              var parentCellsWithChildren = parent.find(\"th:not(.k-group-cell,.k-hierarchy-cell)\").filter(function () {\n                return !$(this).attr(\"rowspan\");\n              });\n              var offset = 0;\n              var index = row.find(\"th:not(.k-group-cell,.k-hierarchy-cell)\").index(cell);\n              var prevCells = cell.prevAll(\":not(.k-group-cell,.k-hierarchy-cell)\").filter(function () {\n                return this.colSpan > 1;\n              });\n\n              for (var idx = 0; idx < prevCells.length; idx++) {\n                offset += prevCells[idx].colSpan || 1;\n              }\n\n              index += Math.max(offset - 1, 0);\n              offset = 0;\n\n              for (idx = 0; idx < parentCellsWithChildren.length; idx++) {\n                var parentCell = parentCellsWithChildren.eq(idx);\n\n                if (parentCell.attr(\"data-colspan\")) {\n                  offset += parentCell[0].getAttribute(\"data-colspan\");\n                } else {\n                  offset += 1;\n                }\n\n                if (index >= idx && index < offset) {\n                  result = parentColumnsCells(parentCell).add(result);\n                  break;\n                }\n              }\n            }\n\n            return result;\n          }\n\n          function childColumnsCells(cell) {\n            var container = cell.closest(\"thead\");\n            var result = $().add(cell);\n            var row = cell.closest(\"tr\");\n            var headerRows = container.find(\"tr:not(.k-filter-row)\");\n            var level = headerRows.index(row) + cell[0].rowSpan;\n            var colSpanAttr = kendo.attr(\"colspan\");\n\n            if (level <= headerRows.length - 1) {\n              var child = row.next();\n              var prevCells = cell.prevAll(\":not(.k-group-cell,.k-hierarchy-cell)\");\n              var idx;\n              prevCells = prevCells.filter(function () {\n                return !this.rowSpan || this.rowSpan === 1;\n              });\n              var offset = 0;\n\n              for (idx = 0; idx < prevCells.length; idx++) {\n                offset += parseInt(prevCells.eq(idx).attr(colSpanAttr), 10) || 1;\n              }\n\n              var cells = child.find(\"th:not(.k-group-cell,.k-hierarchy-cell)\");\n              var colSpan = parseInt(cell.attr(colSpanAttr), 10) || 1;\n              idx = 0;\n\n              while (idx < colSpan) {\n                child = cells.eq(idx + offset);\n                result = result.add(childColumnsCells(child));\n                var value = parseInt(child.attr(colSpanAttr), 10);\n\n                if (value > 1) {\n                  colSpan -= value - 1;\n                }\n\n                idx++;\n              }\n            }\n\n            return result;\n          }\n\n          function appendContent(tbody, table, html, empty) {\n            var placeholder,\n                tmp = tbody; // necessary for AngularJS to cleanup its guts.\n\n            if (empty) {\n              tbody.empty();\n            }\n\n            if (tbodySupportsInnerHtml) {\n              tbody[0].innerHTML = html;\n            } else {\n              placeholder = document.createElement(\"div\");\n              placeholder.innerHTML = \"<table><tbody>\" + html + \"</tbody></table>\";\n              tbody = placeholder.firstChild.firstChild;\n              table[0].replaceChild(tbody, tmp[0]);\n              tbody = $(tbody);\n            }\n\n            return tbody;\n          }\n\n          function addHiddenStyle(attr) {\n            attr = attr || {};\n            var style = attr.style;\n\n            if (!style) {\n              style = \"display:none\";\n            } else {\n              style = style.replace(/display:[^;]*/i, \"display:none\");\n\n              if (!style.match(/display:/i)) {\n                style = style.replace(/(.*)?/i, \"display:none;$1\");\n              }\n            }\n\n            return extend({}, attr, {\n              style: style\n            });\n          }\n\n          function hasHiddenStyle(attr) {\n            attr = attr || {};\n            var style = attr.style || \"\";\n            return style.indexOf(\"display:none\") !== -1;\n          }\n\n          function removeHiddenStyle(attr) {\n            attr = attr || {};\n            var style = attr.style;\n\n            if (style) {\n              attr.style = style.replace(/(display\\s*:\\s*none\\s*;?)*/ig, \"\");\n            }\n\n            return attr;\n          }\n\n          function normalizeCols(table, visibleColumns, hasDetails, groups) {\n            var colgroup = table.find(\">colgroup\"),\n                width,\n                cols = map(visibleColumns, function (column) {\n              width = column.width;\n\n              if (width && parseInt(width, 10) !== 0) {\n                return kendo.format('<col style=\"width:{0}\"/>', typeof width === STRING ? width : width + \"px\");\n              }\n\n              return \"<col />\";\n            });\n\n            if (hasDetails || colgroup.find(\".k-hierarchy-col\").length) {\n              cols.splice(0, 0, '<col class=\"k-hierarchy-col\" />');\n            }\n\n            if (colgroup.length) {\n              colgroup.remove();\n            }\n\n            colgroup = $(new Array(groups + 1).join('<col class=\"k-group-col\">') + cols.join(\"\"));\n\n            if (!colgroup.is(\"colgroup\")) {\n              colgroup = $(\"<colgroup/>\").append(colgroup);\n            }\n\n            table.prepend(colgroup);\n          }\n\n          function normalizeHeaderCells(container, columns) {\n            var lastIndex = 0;\n            var idx, len;\n            var th = container.find(\"th:not(.k-group-cell)\");\n\n            for (idx = 0, len = columns.length; idx < len; idx++) {\n              if (columns[idx].locked) {\n                th.eq(idx).insertBefore(th.eq(lastIndex));\n                th = container.find(\"th:not(.k-group-cell)\");\n                lastIndex++;\n              }\n            }\n          }\n\n          function convertToObject(array) {\n            var result = {},\n                item,\n                idx,\n                length;\n\n            for (idx = 0, length = array.length; idx < length; idx++) {\n              item = array[idx];\n              result[item.value] = item.text;\n            }\n\n            return result;\n          }\n\n          function formatGroupValue(value, format, columnValues, encoded) {\n            var isForeignKey = columnValues && columnValues.length && isPlainObject(columnValues[0]) && \"value\" in columnValues[0],\n                groupValue = isForeignKey ? convertToObject(columnValues)[value] : value;\n            groupValue = groupValue != null ? groupValue : \"\";\n            return format ? kendo.format(format, groupValue) : encoded === false ? groupValue : kendo.htmlEncode(groupValue);\n          }\n\n          function setCellVisibility(cells, index, visible) {\n            var pad = 0,\n                state,\n                cell = cells[pad];\n\n            while (cell) {\n              state = visible ? true : cell.style.display !== \"none\";\n\n              if (state && !nonDataCellsRegExp.test(cell.className) && --index < 0) {\n                cell.style.display = visible ? \"\" : \"none\";\n                break;\n              }\n\n              cell = cells[++pad];\n            }\n          }\n\n          function hideColumnCells(rows, columnIndex) {\n            var idx = 0,\n                length = rows.length,\n                cell,\n                row;\n\n            for (; idx < length; idx += 1) {\n              row = rows.eq(idx);\n\n              if (row.is(\".k-grouping-row,.k-detail-row\")) {\n                cell = row.children(\":not(.k-group-cell):first,.k-detail-cell\").last();\n                cell.attr(\"colspan\", parseInt(cell.attr(\"colspan\"), 10) - 1);\n              } else {\n                if (row.hasClass(\"k-grid-edit-row\") && (cell = row.children(\".k-edit-container\")[0])) {\n                  cell = $(cell);\n                  cell.attr(\"colspan\", parseInt(cell.attr(\"colspan\"), 10) - 1);\n                  cell.find(\"col\").eq(columnIndex).remove();\n                  row = cell.find(\"tr\").first();\n                }\n\n                setCellVisibility(row[0].cells, columnIndex, false);\n              }\n            }\n          }\n\n          function groupRows(data) {\n            var result = [];\n            var item;\n\n            for (var idx = 0; idx < data.length; idx++) {\n              item = data[idx];\n\n              if (!(\"field\" in item && \"value\" in item && \"items\" in item)) {\n                break;\n              }\n\n              result.push(item);\n\n              if (item.hasSubgroups) {\n                result = result.concat(groupRows(item.items));\n              }\n            }\n\n            return result;\n          }\n\n          function groupFooters(data) {\n            var result = [];\n            var item;\n\n            for (var idx = 0; idx < data.length; idx++) {\n              item = data[idx];\n\n              if (!(\"field\" in item && \"value\" in item && \"items\" in item)) {\n                break;\n              }\n\n              if (item.hasSubgroups) {\n                result = result.concat(groupFooters(item.items));\n              }\n\n              result.push(item.aggregates);\n            }\n\n            return result;\n          }\n\n          function showColumnCells(rows, columnIndex) {\n            var idx = 0,\n                length = rows.length,\n                cell,\n                row,\n                columns;\n\n            for (; idx < length; idx += 1) {\n              row = rows.eq(idx);\n\n              if (row.is(\".k-grouping-row,.k-detail-row\")) {\n                cell = row.children(\":not(.k-group-cell):first,.k-detail-cell\").last();\n                cell.attr(\"colspan\", parseInt(cell.attr(\"colspan\"), 10) + 1);\n              } else {\n                if (row.hasClass(\"k-grid-edit-row\") && (cell = row.children(\".k-edit-container\")[0])) {\n                  cell = $(cell);\n                  cell.attr(\"colspan\", parseInt(cell.attr(\"colspan\"), 10) + 1);\n                  normalizeCols(cell.find(\">form>table\"), visibleColumns(columns), false, 0);\n                  row = cell.find(\"tr\").first();\n                }\n\n                setCellVisibility(row[0].cells, columnIndex, true);\n              }\n            }\n          }\n\n          function updateColspan(toAdd, toRemove, num) {\n            num = num || 1;\n            var item, idx, length;\n\n            for (idx = 0, length = toAdd.length; idx < length; idx++) {\n              item = toAdd.eq(idx).children().last();\n              item.attr(\"colspan\", parseInt(item.attr(\"colspan\"), 10) + num);\n              item = toRemove.eq(idx).children().last();\n              item.attr(\"colspan\", parseInt(item.attr(\"colspan\"), 10) - num);\n            }\n          }\n\n          function tableWidth(table) {\n            var idx,\n                length,\n                width = 0;\n            var cols = table.find(\">colgroup>col\");\n\n            for (idx = 0, length = cols.length; idx < length; idx += 1) {\n              width += parseInt(cols[idx].style.width, 10);\n            }\n\n            return width;\n          }\n\n          var Grid = kendo.ui.DataBoundWidget.extend({\n            init: function (element, options, events) {\n              var that = this;\n              options = isArray(options) ? {\n                dataSource: options\n              } : options;\n              Widget.fn.init.call(that, element, options);\n\n              if (events) {\n                that._events = events;\n              }\n\n              isRtl = kendo.support.isRtl(element);\n\n              that._element();\n\n              that._aria();\n\n              that._columns($.extend(true, [], that.options.columns));\n\n              if (that._foreignKeyPromises) {\n                $.when.apply(null, that._foreignKeyPromises).then(function () {\n                  that._foreignKeyPromises = null;\n\n                  that._continueInit();\n                });\n              } else {\n                that._continueInit();\n              }\n            },\n            _continueInit: function () {\n              var that = this;\n\n              that._dataSource();\n\n              that._stickyColumns();\n\n              that._tbody();\n\n              that._thead();\n\n              that._groupable();\n\n              that._toolbar();\n\n              that._pageable();\n\n              that._setContentHeight();\n\n              that._templates();\n\n              that._navigatable();\n\n              that._selectable();\n\n              that._clipboard();\n\n              that._details();\n\n              that._editable();\n\n              that._attachCustomCommandsEvent();\n\n              that._adaptiveColumns();\n\n              that._minScreenSupport();\n\n              if (that.options.autoBind) {\n                that.dataSource.fetch();\n              } else {\n                that._group = that._groups() > 0;\n\n                that._footer();\n              }\n\n              if (that.lockedContent) {\n                that.wrapper.addClass(\"k-grid-lockedcolumns\");\n\n                that._resizeHandler = function () {\n                  that.resize();\n                };\n\n                $(window).on(\"resize\" + NS, that._resizeHandler);\n              }\n\n              kendo.notify(that);\n            },\n            events: [CHANGE, \"dataBinding\", \"cancel\", DATABOUND, DETAILEXPAND, DETAILCOLLAPSE, DETAILINIT, FILTERMENUINIT, FILTERMENUOPEN, COLUMNMENUINIT, COLUMNMENUOPEN, EDIT, BEFOREEDIT, SAVE, REMOVE, SAVECHANGES, CELLCLOSE, COLUMNRESIZE, COLUMNREORDER, COLUMNSHOW, COLUMNHIDE, COLUMNLOCK, COLUMNUNLOCK, COLUMNSTICK, COLUMNUNSTICK, ROWREORDER, NAVIGATE, \"page\", \"sort\", \"filter\", \"group\", \"groupExpand\", \"groupCollapse\", \"kendoKeydown\"],\n            setDataSource: function (dataSource) {\n              var that = this;\n              var scrollable = that.options.scrollable;\n              var scrollableContent;\n              that.options.dataSource = dataSource;\n\n              that._dataSource();\n\n              that._pageable();\n\n              that._thead();\n\n              if (scrollable) {\n                if (scrollable.virtual) {\n                  scrollableContent = that.content.find(\">.k-virtual-scrollable-wrap\");\n                  kendo.scrollLeft(scrollableContent, leftMostPosition(scrollableContent, isRtl));\n                } else {\n                  scrollableContent = that.tbody;\n                  kendo.scrollLeft(that.content, leftMostPosition(scrollableContent, isRtl));\n                }\n              }\n\n              if (that.options.groupable) {\n                that._groupable();\n              }\n\n              if (that.virtualScrollable) {\n                that.virtualScrollable.setDataSource(that.options.dataSource);\n              }\n\n              if (that.options.navigatable) {\n                that._navigatable();\n              }\n\n              if (that.options.selectable) {\n                that._selectable();\n              }\n\n              if (that.options.autoBind) {\n                that.dataSource.fetch();\n              } else {\n                that._footer();\n              }\n            },\n            options: {\n              name: \"Grid\",\n              columns: [],\n              toolbar: null,\n              autoBind: true,\n              filterable: false,\n              scrollable: true,\n              sortable: false,\n              selectable: false,\n              allowCopy: false,\n              navigatable: false,\n              pageable: false,\n              persistSelection: false,\n              editable: false,\n              encodeTitles: false,\n              groupable: false,\n              rowTemplate: \"\",\n              altRowTemplate: \"\",\n              search: false,\n              noRecords: false,\n              dataSource: {},\n              height: null,\n              resizable: false,\n              reorderable: false,\n              columnMenu: false,\n              detailTemplate: null,\n              columnResizeHandleWidth: 3,\n              mobile: \"\",\n              loaderType: \"loadingPanel\",\n              messages: {\n                editable: {\n                  cancelDelete: CANCELDELETE,\n                  confirmation: DELETECONFIRM,\n                  confirmDelete: CONFIRMDELETE\n                },\n                commands: {\n                  create: defaultCommands.create.text,\n                  cancel: defaultCommands.cancel.text,\n                  save: defaultCommands.save.text,\n                  destroy: defaultCommands.destroy.text,\n                  edit: defaultCommands.edit.text,\n                  update: defaultCommands.update.text,\n                  canceledit: defaultCommands.canceledit.text,\n                  excel: defaultCommands.excel.text,\n                  pdf: defaultCommands.pdf.text,\n                  search: defaultCommands.search.text\n                },\n                noRecords: NORECORDS,\n                expandCollapseColumnHeader: \"\",\n                groupHeader: \"Press ctrl + space to group\",\n                ungroupHeader: \"Press ctrl + space to ungroup\",\n                itemsSelected: \"items selected\",\n                dragHandleLabel: \"Drag row\"\n              },\n              width: null\n            },\n            destroy: function () {\n              var that = this,\n                  element;\n\n              that._angularItems(\"cleanup\");\n\n              that._destroyColumnAttachments();\n\n              Widget.fn.destroy.call(that);\n\n              if (this._navigatableTables) {\n                this._navigatableTables.off(NS);\n\n                this._navigatableTables = null;\n                this._headertables = null;\n              }\n\n              if (that._resizeHandler) {\n                $(window).off(\"resize\" + NS, that._resizeHandler);\n              }\n\n              if (that.pager && that.pager.element) {\n                that.pager.destroy();\n              }\n\n              if (that.timer) {\n                clearTimeout(that.timer);\n              }\n\n              if (that._progressTimeOut) {\n                clearTimeout(that._progressTimeOut);\n              }\n\n              if (that._collapseGroupsTimeOut) {\n                clearTimeout(that._collapseGroupsTimeOut);\n              }\n\n              if (that._endlessFetchTimeOut) {\n                clearTimeout(that._endlessFetchTimeOut);\n              }\n\n              that.pager = null;\n\n              that._destroyGroupable();\n\n              if (that.options.reorderable === true || that.options.reorderable && that.options.reorderable.columns) {\n                that.wrapper.data(\"kendoReorderable\").destroy();\n              }\n\n              if (that._hasReorderableRows()) {\n                that.tbody.data(\"kendoReorderable\").destroy();\n              }\n\n              if (that.selectable && that.selectable.element) {\n                that.selectable.destroy();\n                that.clearArea();\n                that._selectedIds = null;\n\n                if (that.copyHandler) {\n                  that.wrapper.off(\"keydown\", that.copyHandler);\n                  that.unbind(that.copyHandler);\n                }\n\n                if (that.updateClipBoardState) {\n                  that.unbind(that.updateClipBoardState);\n                  that.updateClipBoardState = null;\n                }\n\n                if (that.clearAreaHandler) {\n                  that.wrapper.off(\"keyup\", that.clearAreaHandler);\n                }\n              }\n\n              that.selectable = null;\n\n              if (that.resizable) {\n                that.resizable.destroy();\n\n                if (that._resizeUserEvents) {\n                  if (that._resizeHandleDocumentClickHandler) {\n                    $(document).off(\"click\", that._resizeHandleDocumentClickHandler);\n                  }\n\n                  that._resizeUserEvents.destroy();\n\n                  that._resizeUserEvents = null;\n                }\n\n                that.resizable = null;\n              }\n\n              that._destroyVirtualScrollable();\n\n              if (that.editableUserEvents) {\n                that.editableUserEvents.destroy();\n                that.editableUserEvents = null;\n              }\n\n              if (that._lockedContentUserEvents) {\n                that._lockedContentUserEvents.destroy();\n\n                that._lockedContentUserEvents = null;\n              }\n\n              that._destroyEditable();\n\n              if (that.dataSource) {\n                that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(PROGRESS, that._progressHandler).unbind(ERROR, that._errorHandler).unbind(SORT, that._clearSortClasses);\n                that._refreshHandler = that._progressHandler = that._errorHandler = that._sortHandler = null;\n              }\n\n              element = that.element.add(that.wrapper).add(that.table).add(that.thead).add(that.wrapper.find(\">.k-grid-toolbar\"));\n\n              if (that.content) {\n                element = element.add(that.content).add(that.content.find(\">.k-virtual-scrollable-wrap\"));\n              }\n\n              if (that.lockedHeader) {\n                that._removeLockedContainers();\n              }\n\n              if (that.pane) {\n                that.pane.destroy();\n              }\n\n              if (that._isMobile) {\n                that.wrapper.off(\"transitionend\" + NS);\n                that.wrapper.off(\"contextmenu\" + NS);\n              }\n\n              if (that.minScreenResizeHandler) {\n                $(window).off(\"resize\", that.minScreenResizeHandler);\n              }\n\n              that._detachColumnMediaResizeHandler();\n\n              if (that._draggableInstance && that._draggableInstance.element) {\n                that._draggableInstance.destroy();\n              }\n\n              that._draggableInstance = null;\n\n              if (that._draggableRowsInstance && that._draggableRowsInstance.element) {\n                that._draggableRowsInstance.destroy();\n              }\n\n              that._draggableRowsInstance = null;\n              element.off(NS);\n              kendo.destroy(that.wrapper);\n              that.rowTemplate = that.altRowTemplate = that.lockedRowTemplate = that.lockedAltRowTemplate = that.detailTemplate = that.footerTemplate = that.groupFooterTemplate = that.lockedGroupFooterTemplate = that.noRecordsTemplate = null;\n              that.scrollables = that.thead = that.tbody = that.element = that.table = that.content = that.footer = that.wrapper = that.lockedTable = that.lockedContent = that.lockedHeader = that.lockedFooter = that._groupableClickHandler = that._groupRows = that._setContentWidthHandler = null;\n            },\n            getOptions: function () {\n              var options = this.options;\n              options.dataSource = null;\n              var result = extend(true, {}, this.options);\n              result.columns = kendo.deepExtend([], this.columns);\n              var dataSource = this.dataSource;\n              var initialData = dataSource.options.data && dataSource._data;\n              dataSource.options.data = null;\n              result.dataSource = $.extend(true, {}, dataSource.options);\n              dataSource.options.data = initialData;\n              result.dataSource.data = initialData;\n              result.dataSource.page = dataSource.page();\n              result.dataSource.filter = $.extend(true, {}, dataSource.filter());\n              result.dataSource.pageSize = dataSource.pageSize();\n              result.dataSource.sort = dataSource.sort();\n              result.dataSource.group = dataSource.group();\n              result.dataSource.aggregate = dataSource.aggregate();\n\n              if (result.dataSource.transport) {\n                result.dataSource.transport.dataSource = null;\n              }\n\n              if (result.pageable && result.pageable.pageSize) {\n                result.pageable.pageSize = dataSource.pageSize();\n              }\n\n              result.$angular = undefined;\n              return result;\n            },\n            setOptions: function (options) {\n              var currentOptions = this.getOptions();\n              kendo.deepExtend(currentOptions, options);\n\n              if (!options.dataSource) {\n                currentOptions.dataSource = this.dataSource;\n              } else {\n                if (options.dataSource.filter) {\n                  currentOptions.dataSource.filter = options.dataSource.filter;\n                }\n              }\n\n              var wrapper = this.wrapper;\n              var events = this._events;\n              var element = this.element;\n              this.destroy();\n              this.options = null;\n\n              if (this._isMobile) {\n                var mobileWrapper = wrapper.closest(kendo.roleSelector(\"pane\")).parent();\n                mobileWrapper.after(wrapper);\n                mobileWrapper.remove();\n                wrapper.removeClass(\"k-grid-mobile\");\n              }\n\n              if (wrapper[0] !== element[0]) {\n                wrapper.before(element);\n                wrapper.remove();\n              }\n\n              element.empty();\n              this.init(element, currentOptions, events);\n\n              this._setEvents(currentOptions);\n            },\n            items: function () {\n              if (this.lockedContent) {\n                return this._items(this.tbody).add(this._items(this.lockedTable.children(\"tbody\")));\n              } else {\n                return this._items(this.tbody);\n              }\n            },\n            _items: function (container, includeGroupRows) {\n              return container.children().filter(function () {\n                var tr = $(this);\n                return (includeGroupRows ? !tr.hasClass(\"k-detail-row\") : !tr.hasClass(\"k-grouping-row\")) && !tr.hasClass(\"k-detail-row\") && !tr.hasClass(\"k-group-footer\");\n              });\n            },\n            dataItems: function () {\n              var dataItems = kendo.ui.DataBoundWidget.fn.dataItems.call(this);\n\n              if (this.lockedContent) {\n                var n = dataItems.length,\n                    tmp = new Array(2 * n);\n\n                for (var i = n; --i >= 0;) {\n                  tmp[i] = tmp[i + n] = dataItems[i];\n                }\n\n                dataItems = tmp;\n              }\n\n              return dataItems;\n            },\n            _destroyColumnAttachments: function () {\n              var that = this;\n              that.resizeHandle = null;\n\n              if (!that.thead) {\n                return;\n              }\n\n              this.angular(\"cleanup\", function () {\n                return {\n                  elements: that.thead.get()\n                };\n              });\n              that.thead.add(that.lockedHeader).find(\"th\").each(function () {\n                var th = $(this),\n                    filterMenu = th.data(\"kendoFilterMenu\"),\n                    sortable = th.data(\"kendoColumnSorter\"),\n                    columnMenu = th.data(\"kendoColumnMenu\");\n\n                if (filterMenu) {\n                  filterMenu.destroy();\n                }\n\n                if (sortable) {\n                  sortable.destroy();\n                }\n\n                if (columnMenu) {\n                  columnMenu.destroy();\n                }\n              });\n            },\n            _attachCustomCommandsEvent: function () {\n              var that = this,\n                  columns = leafColumns(that.columns || []),\n                  command,\n                  idx,\n                  length;\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                command = columns[idx].command;\n\n                if (command) {\n                  attachCustomCommandEvent(that, that.wrapper, command);\n                }\n              }\n            },\n            _aria: function () {\n              var id = this.element.attr(\"id\") || \"aria\";\n\n              if (id) {\n                this._cellId = id + \"_active_cell\";\n              }\n            },\n            _element: function () {\n              var that = this,\n                  table = that.element;\n\n              if (!table.is(\"table\")) {\n                if (that.options.scrollable) {\n                  table = that.element.find(\"> .k-grid-content > table\");\n                } else {\n                  table = that.element.children(\"table\");\n                }\n\n                if (!table.length) {\n                  table = $(\"<table />\").appendTo(that.element);\n                }\n              }\n\n              that.table = table.attr(\"role\", that._hasDetails() ? \"treegrid\" : \"grid\");\n\n              that._wrapper();\n            },\n            _createResizeHandle: function (container, th) {\n              var that = this;\n              var indicatorWidth = that.options.columnResizeHandleWidth;\n              var scrollable = that.options.scrollable;\n              var resizeHandle = that.resizeHandle;\n              var halfResizeHandle = indicatorWidth * 3 / 2;\n              var rtlCorrection = 0;\n              var headerWrap;\n              var ieCorrection;\n              var webkitCorrection;\n              var firefoxCorrection;\n              var leftMargin;\n              var invisibleSpace;\n              var leftBorderWidth;\n              var scrollLeft;\n              var left;\n              var top;\n\n              if (resizeHandle && that.lockedContent && resizeHandle.data(\"th\")[0] !== th[0]) {\n                resizeHandle.off(NS).remove();\n                resizeHandle = null;\n              }\n\n              if (!resizeHandle) {\n                resizeHandle = that.resizeHandle = $('<div class=\"k-resize-handle\"><div class=\"k-resize-handle-inner\"></div></div>');\n                container.append(resizeHandle);\n              }\n\n              scrollLeft = kendo.scrollLeft(container);\n\n              if (isRtl && (browser.mozilla || browser.webkit && browser.version >= 85)) {\n                scrollLeft = scrollLeft * -1;\n              }\n\n              leftBorderWidth = parseFloat(container.css(\"borderLeftWidth\"));\n              left = th.offset().left + scrollLeft - parseFloat(th.css(\"marginLeft\")) - (container.offset().left + leftBorderWidth);\n\n              if (!isRtl) {\n                left += th[0].offsetWidth;\n              } else {\n                if (scrollable) {\n                  rtlCorrection = left <= scrollLeft ? halfResizeHandle : 0; // when shown on first column headers are misaligned due to the width of the resize handler\n\n                  headerWrap = th.closest(\".k-grid-header-wrap, .k-grid-header-locked\");\n                  invisibleSpace = headerWrap[0].scrollWidth - headerWrap[0].offsetWidth; // the difference between the entire width and the visible area\n\n                  leftMargin = parseFloat(headerWrap.css(\"marginLeft\"));\n                  ieCorrection = browser.msie ? 2 * kendo.scrollLeft(headerWrap) + leftBorderWidth - leftMargin - rtlCorrection : 0;\n                  webkitCorrection = -rtlCorrection;\n                  firefoxCorrection = browser.mozilla ? leftBorderWidth - leftMargin - rtlCorrection : 0;\n                  left -= webkitCorrection + firefoxCorrection + ieCorrection;\n                }\n              }\n\n              top = th.offset().top - parseFloat(th.css(\"marginTop\")) - (container.offset().top + parseFloat(container.css(\"borderTopWidth\")));\n              resizeHandle.css({\n                top: top,\n                //scrollable ? 0 : heightAboveHeader(that.wrapper),\n                left: left - halfResizeHandle,\n                height: outerHeight(th),\n                width: indicatorWidth * 3 - rtlCorrection\n              }).data(\"th\", th).show();\n              resizeHandle.off(\"dblclick\" + NS).on(\"dblclick\" + NS, function () {\n                that._autoFitLeafColumn(parseInt(th.attr(kendo.attr(\"index\")), 10));\n              });\n            },\n            _positionColumnResizeHandle: function () {\n              var that = this,\n                  lockedHead = that.lockedHeader ? that.lockedHeader.find(\"thead\").first() : $();\n              that.thead.add(lockedHead).on(\"mousemove\" + NS, \"tr:not(.k-filter-row) > th\", function (e) {\n                var button = typeof e.buttons !== \"undefined\" ? e.buttons : e.which || e.button;\n                var th = $(this);\n\n                if (th.hasClass(\"k-group-cell\") || th.hasClass(\"k-hierarchy-cell\")) {\n                  return;\n                }\n\n                if (typeof button !== \"undefined\" && button !== 0) {\n                  //do not create a new resize handle if a mouse button is still pressed\n                  //this happens during resizing or before UserEvents trigger \"start\"\n                  return;\n                }\n\n                if (th[0].hasAttribute(kendo.attr(COLSPAN))) {\n                  // resizing multi-column headers is not supported\n                  return;\n                }\n\n                that._createResizeHandle(th.closest(\"div\"), th);\n              });\n            },\n            _resizeHandleDocumentClick: function (e) {\n              if ($(e.target).closest(\".k-column-active\").length) {\n                return;\n              }\n\n              $(document).off(e);\n\n              this._resetResizeHandleHeader();\n\n              this._hideResizeHandle();\n            },\n            _resetResizeHandleHeader: function () {\n              var th;\n\n              if (!this.resizeHandle) {\n                return;\n              }\n\n              th = $(this.resizeHandle).data(\"th\");\n\n              if (th) {\n                th.find(DOT + LINK_CLASS).find(DOT + ICON_CLASS).show();\n                th.find(DOT + ORDER_CLASS).show();\n                th.find(DOT + HEADER_COLUMN_MENU_CLASS).show();\n                th.find(DOT + FILTER_MENU_CLASS).show();\n              }\n            },\n            _hideResizeHandle: function () {\n              if (this.resizeHandle) {\n                this.resizeHandle.data(\"th\").removeClass(\"k-column-active\");\n\n                if (this.lockedContent && !this._isMobile) {\n                  this.resizeHandle.off(NS).remove();\n                  this.resizeHandle = null;\n                } else {\n                  this.resizeHandle.hide();\n                }\n              }\n            },\n            _positionColumnResizeHandleTouch: function () {\n              var that = this,\n                  lockedHead = that.lockedHeader ? that.lockedHeader.find(\"thead\").first() : $();\n              that._resizeUserEvents = new kendo.UserEvents(lockedHead.add(that.thead), {\n                filter: \"th:not(.k-group-cell):not(.k-hierarchy-cell)\",\n                threshold: 10,\n                minHold: 500,\n                hold: function (e) {\n                  var th = $(e.target);\n                  e.preventDefault();\n\n                  if (that.resizeHandle) {\n                    that.resizeHandle.data(\"th\").removeClass(\"k-column-active\");\n\n                    that._resetResizeHandleHeader();\n                  }\n\n                  th.addClass(\"k-column-active\");\n                  th.find(DOT + LINK_CLASS).find(DOT + ICON_CLASS).hide();\n                  th.find(DOT + ORDER_CLASS).hide();\n                  th.find(DOT + HEADER_COLUMN_MENU_CLASS).hide();\n                  th.find(DOT + FILTER_MENU_CLASS).hide();\n\n                  that._createResizeHandle(th.closest(\"div\"), th);\n\n                  if (!that._resizeHandleDocumentClickHandler) {\n                    that._resizeHandleDocumentClickHandler = that._resizeHandleDocumentClick.bind(that);\n                  }\n\n                  $(document).on(\"click\", that._resizeHandleDocumentClickHandler);\n                }\n              });\n            },\n            resizeColumn: function (column, columnWidth) {\n              var that = this;\n              var isLocked = !!column.locked;\n              var isHidden = !!column.hidden;\n              var options = this.options;\n              var scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0;\n              var index = isLocked ? inArray(column, visibleLockedColumns(visibleLeafColumns(that.columns))) : inArray(column, visibleNonLockedColumns(visibleLeafColumns(that.columns)));\n              var contentTable = isLocked ? that.lockedTable : that.table;\n              var footer = that.footer || $();\n              var header = isLocked ? that.lockedHeader.find(\"table\") : that.thead.closest(\"table\");\n              var columnMinWidth = column.minResizableWidth || 10;\n              var gridWidth = isLocked ? outerWidth(contentTable.find(\"tbody\")) : outerWidth(that.tbody); // IE returns 0 if grid is empty and scrolling is enabled\n\n              var col;\n\n              if (isHidden) {\n                column.width = columnWidth > columnMinWidth ? columnWidth : columnMinWidth;\n                return;\n              }\n\n              if (that.footer && that.lockedContent) {\n                footer = isLocked ? that.footer.children(\".k-grid-footer-locked\") : that.footer.children(\".k-grid-footer-wrap\");\n              }\n\n              if (options.scrollable) {\n                col = header.find(\"col:not(.k-group-col,.k-hierarchy-col)\").eq(index).add(contentTable.children(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index)).add(footer.find(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index));\n              } else {\n                col = contentTable.find(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index);\n              }\n\n              if (options.scrollable) {\n                var constrain = false;\n                var totalWidth = that.wrapper.width() - scrollbar;\n                var width = columnWidth = columnWidth > columnMinWidth ? columnWidth : columnMinWidth;\n\n                if (isLocked && gridWidth - columnWidth + width > totalWidth) {\n                  width = columnWidth + (totalWidth - gridWidth - scrollbar * 2);\n\n                  if (width < 0) {\n                    width = columnWidth;\n                  }\n\n                  constrain = true;\n                }\n\n                if (width > 10 && width >= columnMinWidth) {\n                  col.css('width', width);\n\n                  if (gridWidth) {\n                    if (constrain) {\n                      width = totalWidth - scrollbar * 2;\n                    } else {\n                      width = gridWidth + (columnWidth - column.width);\n                    }\n\n                    contentTable.add(header).add(footer).css('width', width);\n\n                    if (!isLocked) {\n                      that._footerWidth = width;\n                    }\n                  }\n                }\n\n                that._scrollVirtualWrapperOnColumnResize();\n              } else if (columnWidth > 10 && columnWidth >= columnMinWidth) {\n                col.css('width', columnWidth);\n              }\n\n              column.width = columnWidth;\n\n              that._applyLockedContainersWidth();\n\n              that._syncLockedContentHeight();\n\n              that._syncLockedHeaderHeight();\n\n              that._updateStickyColumns();\n            },\n            _resizable: function () {\n              var that = this,\n                  options = that.options,\n                  container,\n                  columnStart,\n                  columnWidth,\n                  columnMinWidth,\n                  gridWidth,\n                  isMobile = this._isMobile,\n                  scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0,\n                  isLocked,\n                  col,\n                  th;\n\n              if (options.resizable) {\n                container = options.scrollable ? that.wrapper.find(\".k-grid-header-wrap\").first() : that.wrapper;\n\n                if (isMobile) {\n                  that._positionColumnResizeHandleTouch(container);\n                } else {\n                  that._positionColumnResizeHandle(container);\n                }\n\n                if (that.resizable) {\n                  that.resizable.destroy();\n                }\n\n                that.resizable = new ui.Resizable(container.add(that.lockedHeader), {\n                  handle: (!!options.scrollable ? \"\" : \">\") + \".k-resize-handle\",\n                  hint: function (handle) {\n                    return $('<div class=\"k-grid-resize-indicator\" />').css({\n                      height: outerHeight(handle.data(\"th\")) + that.tbody.attr(\"clientHeight\")\n                    });\n                  },\n                  start: function (e) {\n                    th = $(e.currentTarget).data(\"th\");\n\n                    if (isMobile) {\n                      that._hideResizeHandle();\n                    }\n\n                    var header = th.closest(\"table\"),\n                        index = $.inArray(th[0], leafDataCells(th.closest(\"thead\")).filter(\":visible\"));\n                    isLocked = header.parent().hasClass(\"k-grid-header-locked\");\n                    var contentTable = isLocked ? that.lockedTable : that.table,\n                        footer = that.footer || $();\n\n                    if (that.footer && that.lockedContent) {\n                      footer = isLocked ? that.footer.children(\".k-grid-footer-locked\") : that.footer.children(\".k-grid-footer-wrap\");\n                    }\n\n                    cursor(that.wrapper, 'col-resize');\n\n                    if (options.scrollable) {\n                      col = header.find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index).add(contentTable.children(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index)).add(footer.find(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index));\n                    } else {\n                      col = contentTable.children(\"colgroup\").find(\"col:not(.k-group-col):not(.k-hierarchy-col)\").eq(index);\n                    }\n\n                    var columns = $.map(that.columns, function (a) {\n                      return !a.hidden && (isLocked && a.locked || !isLocked && !a.locked) ? a : null;\n                    });\n                    columnStart = e.x.location;\n                    columnWidth = outerWidth(th);\n                    columnMinWidth = leafColumns(columns)[index].minResizableWidth || 10;\n                    gridWidth = isLocked ? outerWidth(contentTable.children(\"tbody\")) : outerWidth(that.tbody); // IE returns 0 if grid is empty and scrolling is enabled\n                    // fix broken UI in Chrome38+\n\n                    if (browser.webkit) {\n                      that.wrapper.addClass(\"k-grid-column-resizing\");\n                    }\n                  },\n                  resize: function (e) {\n                    var rtlMultiplier = isRtl ? -1 : 1,\n                        currentWidth = columnWidth + e.x.location * rtlMultiplier - columnStart * rtlMultiplier;\n\n                    if (options.scrollable) {\n                      var footer;\n\n                      if (isLocked && that.lockedFooter) {\n                        footer = that.lockedFooter.children(\"table\");\n                      } else if (that.footer) {\n                        footer = that.footer.find(\">.k-grid-footer-wrap>table\");\n                      }\n\n                      if (!footer || !footer[0]) {\n                        footer = $();\n                      }\n\n                      var header = th.closest(\"table\");\n                      var contentTable = isLocked ? that.lockedTable : that.table;\n                      var constrain = false;\n                      var totalWidth = that.wrapper.width() - scrollbar;\n                      var width = currentWidth;\n\n                      if (isLocked && gridWidth - columnWidth + width > totalWidth) {\n                        width = columnWidth + (totalWidth - gridWidth - scrollbar * 2);\n\n                        if (width < 0) {\n                          width = currentWidth;\n                        }\n\n                        constrain = true;\n                      }\n\n                      if (width > 10 && width >= columnMinWidth) {\n                        col.css('width', width);\n\n                        if (gridWidth) {\n                          if (constrain) {\n                            width = totalWidth - scrollbar * 2;\n                          } else {\n                            width = gridWidth + e.x.location * rtlMultiplier - columnStart * rtlMultiplier;\n                          }\n\n                          contentTable.add(header).add(footer).css('width', width);\n\n                          if (!isLocked) {\n                            that._footerWidth = width;\n                          }\n                        }\n                      }\n\n                      that._scrollVirtualWrapperOnColumnResize();\n                    } else if (currentWidth > 10 && currentWidth >= columnMinWidth) {\n                      col.css('width', currentWidth);\n                    }\n                  },\n                  resizeend: function () {\n                    var newWidth = outerWidth(th),\n                        column,\n                        header;\n                    cursor(that.wrapper, \"\");\n\n                    if (browser.webkit) {\n                      that.wrapper.removeClass(\"k-grid-column-resizing\");\n                    }\n\n                    if (columnWidth != newWidth) {\n                      header = that.lockedHeader ? that.lockedHeader.find(\"thead\").first().find(\"tr\").first().add(that.thead.find(\"tr\").first()) : th.parent();\n                      var index = th.attr(kendo.attr(\"index\"));\n\n                      if (!index) {\n                        index = header.find(\"th:not(.k-group-cell):not(.k-hierarchy-cell)\").index(th);\n                      }\n\n                      column = leafColumns(that.columns)[index];\n                      column.width = newWidth;\n                      that.trigger(COLUMNRESIZE, {\n                        column: column,\n                        oldWidth: columnWidth,\n                        newWidth: newWidth\n                      });\n\n                      that._applyLockedContainersWidth();\n\n                      that._syncLockedContentHeight();\n\n                      that._syncLockedHeaderHeight();\n\n                      that._updateStickyColumns();\n                    }\n\n                    that._resetResizeHandleHeader();\n\n                    that._hideResizeHandle();\n\n                    th = null;\n                  }\n                });\n              }\n            },\n            _draggable: function () {\n              var that = this,\n                  reorderable = that.options.reorderable;\n\n              if (reorderable === true || reorderable && reorderable.columns) {\n                if (that._draggableInstance) {\n                  that._draggableInstance.destroy();\n                }\n\n                var header = that.wrapper.children(\".k-grid-header\");\n                that._draggableInstance = that.wrapper.kendoDraggable({\n                  group: kendo.guid(),\n                  autoScroll: true,\n                  filter: that.content ? \".k-grid-header:first \" + HEADERCELLS : \"table:first>.k-grid-header \" + HEADERCELLS,\n                  dragstart: function () {\n                    header.children(\".k-grid-header-wrap\").off(\"scroll\" + NS + \"scrolling\").on(\"scroll\" + NS + \"scrolling\", function (e) {\n                      if (that.virtualScrollable) {\n                        kendo.scrollLeft(that.content.find(\">.k-virtual-scrollable-wrap\"), this.scrollLeft);\n                      } else {\n                        kendo.scrollLeft(that.scrollables.not(e.currentTarget), this.scrollLeft);\n                      }\n                    });\n                  },\n                  dragend: function () {\n                    that._resetResizeHandleHeader();\n\n                    header.children(\".k-grid-header-wrap\").off(\"scroll\" + NS + \"scrolling\");\n                  },\n                  drag: function () {\n                    that._hideResizeHandle();\n                  },\n                  hint: function (target) {\n                    var title = target.attr(kendo.attr(\"title\"));\n\n                    if (title) {\n                      title = kendo.htmlEncode(title);\n                    }\n\n                    return $('<div class=\"k-reorder-clue k-drag-clue\" />').html(title || target.attr(kendo.attr(\"field\")) || target.text()).prepend('<span class=\"k-icon k-drag-status k-i-cancel\"></span>');\n                  }\n                }).data(\"kendoDraggable\");\n              }\n            },\n            _reorderable: function () {\n              var that = this,\n                  reorderable = that.options.reorderable;\n\n              if (reorderable === true || reorderable && reorderable.columns) {\n                if (that.wrapper.data(\"kendoReorderable\")) {\n                  that.wrapper.data(\"kendoReorderable\").destroy();\n                }\n\n                that.wrapper.kendoReorderable({\n                  draggable: that._draggableInstance,\n                  dropFilter: HEADERCELLS,\n                  dragOverContainers: function (sourceIndex, targetIndex) {\n                    var columns = flatColumnsInDomOrder(that.columns);\n                    return columns[sourceIndex].lockable !== false && targetParentContainerIndex(columns, that.columns, sourceIndex, targetIndex) > -1;\n                  },\n                  inSameContainer: function (e) {\n                    return $(e.source).parent()[0] === $(e.target).parent()[0] && targetParentContainerIndex(flatColumnsInDomOrder(that.columns), that.columns, e.sourceIndex, e.targetIndex) > -1;\n                  },\n                  change: function (e) {\n                    var columns = flatColumnsInDomOrder(that.columns);\n                    var column = columns[e.oldIndex];\n                    var newIndex = targetParentContainerIndex(columns, that.columns, e.oldIndex, e.newIndex);\n                    that.trigger(COLUMNREORDER, {\n                      newIndex: newIndex,\n                      oldIndex: inArray(column, columns),\n                      column: column\n                    });\n                    that.reorderColumn(newIndex, column, e.position === \"before\");\n                  }\n                });\n              }\n            },\n            _reorderHeader: function (sources, target, before, container) {\n              var that = this;\n              var sourcePosition = columnPosition(sources[0], that.columns);\n              var destPosition = columnPosition(target, that.columns);\n              var action;\n              var ths;\n              var leafs = [];\n\n              for (var idx = 0; idx < sources.length; idx++) {\n                if (sources[idx].columns) {\n                  leafs = leafs.concat(sources[idx].columns);\n                }\n              }\n\n              if (container) {\n                ths = elements(container, container, \"tr:eq(\" + sourcePosition.row + \")>th.k-header:not(.k-group-cell,.k-hierarchy-cell)\");\n              } else {\n                ths = elements(that.lockedHeader, that.thead, \"tr:eq(\" + sourcePosition.row + \")>th.k-header:not(.k-group-cell,.k-hierarchy-cell)\");\n              }\n\n              var sourceLockedColumns = lockedColumns(sources).length;\n              var targetLockedColumns = lockedColumns([target]).length;\n\n              if (leafs.length) {\n                if (sourceLockedColumns > 0 && targetLockedColumns === 0) {\n                  action = \"prepend\";\n                  moveCellsBetweenContainers(sources, target, leafs, that.columns, that.lockedHeader.find(\"thead\"), that.thead, this._groups(), action);\n                } else if (sourceLockedColumns === 0 && targetLockedColumns > 0) {\n                  action = destPosition.cell === 0 && sources[0].columns && !target.columns && !that._group ? \"prepend\" : \"append\";\n                  moveCellsBetweenContainers(sources, target, leafs, nonLockedColumns(that.columns), that.thead, that.lockedHeader.find(\"thead\"), this._groups(), action);\n                }\n\n                if (target.columns || sourcePosition.cell - destPosition.cell > 1 || destPosition.cell - sourcePosition.cell > 1) {\n                  target = findReorderTarget(that.columns, target, sources[0], before, that.columns);\n\n                  if (target) {\n                    if (sourceLockedColumns > 0 && targetLockedColumns === 0) {\n                      that._reorderHeader(leafs, target, before, that.thead);\n                    } else if (sourceLockedColumns === 0 && targetLockedColumns > 0) {\n                      that._reorderHeader(leafs, target, before, that.lockedHead);\n                    } else {\n                      that._reorderHeader(leafs, target, before);\n                    }\n                  }\n                }\n              } else if (sourceLockedColumns !== targetLockedColumns) {\n                // move between containers\n                updateCellRowSpan(ths[sourcePosition.cell], that.columns, sourceLockedColumns);\n              }\n\n              reorder(ths, sourcePosition.cell, destPosition.cell, before, sources.length);\n            },\n            _reorderContent: function (sources, destination, before) {\n              var that = this;\n              var lockedRows = $();\n              var source = sources[0];\n              var visibleSources = visibleColumns(sources);\n              var sourceIndex = inArray(source, leafColumns(that.columns));\n              var destIndex = inArray(destination, leafColumns(that.columns));\n              var colSourceIndex = inArray(visibleSources[0], visibleLeafColumns(that.columns));\n              var colDest = inArray(destination, visibleLeafColumns(that.columns));\n              var lockedCount = lockedColumns(that.columns).length;\n              var isLocked = !!destination.locked;\n              var footer = that.footer || that.wrapper.find(\".k-grid-footer\");\n              var headerCol, footerCol, beforeVisibleColumn;\n              headerCol = footerCol = colDest;\n\n              if (destination.hidden) {\n                var columnsArray = isLocked ? lockedColumns(that.columns) : nonLockedColumns(that.columns);\n\n                if (visibleColumns(columnsArray).length > 0) {\n                  headerCol = footerCol = colDest = this._findClosestVisibleColumnIndex(columnsArray, destIndex);\n                  beforeVisibleColumn = visibleColumns(columnsArray.slice(destIndex)).length > 0;\n                } else {\n                  if (isLocked) {\n                    colDest = that.lockedTable.find(\"colgroup\");\n                    headerCol = that.lockedHeader.find(\"colgroup\");\n                    footerCol = $(that.lockedFooter).find(\">table>colgroup\");\n                  } else {\n                    colDest = that.tbody.prev();\n                    headerCol = that.thead.prev();\n                    footerCol = footer.find(\".k-grid-footer-wrap\").find(\">table>colgroup\");\n                  }\n                }\n              }\n\n              if (that._hasFilterRow()) {\n                reorder(that.wrapper.find(\".k-filter-row th:not(.k-group-cell,.k-hierarchy-cell)\"), sourceIndex, destIndex, before, sources.length);\n              }\n\n              if (colSourceIndex >= 0) {\n                reorder(elements(that.lockedHeader, that.thead.prev(), COLGROUP), colSourceIndex, headerCol, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n              }\n\n              if (that.options.scrollable) {\n                if (colSourceIndex >= 0 && !that._hasVirtualColumns()) {\n                  reorder(elements(that.lockedTable, that.tbody.prev(), COLGROUP), colSourceIndex, colDest, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n                }\n              }\n\n              if (footer && footer.length) {\n                if (colSourceIndex >= 0) {\n                  reorder(elements(that.lockedFooter, footer.find(\".k-grid-footer-wrap\"), \">table>colgroup>col:not(.k-group-col,.k-hierarchy-col)\"), colSourceIndex, footerCol, beforeVisibleColumn ? beforeVisibleColumn : before, visibleSources.length);\n                }\n\n                reorder(footer.find(\".k-footer-template>td:not(.k-group-cell,.k-hierarchy-cell)\"), sourceIndex, destIndex, before, sources.length);\n              }\n\n              var rows = that.tbody.children(\":not(.k-grouping-row,.k-detail-row)\");\n\n              if (that.lockedTable) {\n                if (lockedCount > destIndex) {\n                  if (lockedCount <= sourceIndex) {\n                    updateColspan(that.lockedTable.find(\">tbody>tr.k-grouping-row\"), that.table.find(\">tbody>tr.k-grouping-row\"), sources.length);\n                  }\n                } else if (lockedCount > sourceIndex) {\n                  updateColspan(that.table.find(\">tbody>tr.k-grouping-row\"), that.lockedTable.find(\">tbody>tr.k-grouping-row\"), sources.length);\n                }\n\n                lockedRows = that.lockedTable.find(\">tbody>tr:not(.k-grouping-row,.k-detail-row)\");\n              }\n\n              for (var idx = 0, length = rows.length; idx < length; idx += 1) {\n                reorder(elements(lockedRows[idx], rows[idx], \">td:not(.k-group-cell,.k-hierarchy-cell)\"), sourceIndex, destIndex, before, sources.length);\n              }\n            },\n            _findClosestVisibleColumnIndex: function (columns, columnIndex) {\n              var columnsArray = visibleColumns(columns.slice(columnIndex)).length > 0 ? columns.slice(columnIndex) : columns.slice(0, columnIndex + 1).reverse(),\n                  closestVisibleColumn = visibleColumns(columnsArray)[0];\n              return inArray(closestVisibleColumn, visibleColumns(this.columns));\n            },\n            _autoFitLeafColumn: function (leafIndex) {\n              this.autoFitColumn(leafColumns(this.columns)[leafIndex]);\n            },\n            _hasReorderableRows: function () {\n              return this._hasDragHandleColumn || this.options.reorderable && this.options.reorderable.rows;\n            },\n            _draggableRows: function () {\n              var that = this,\n                  selectable = that._checkBoxSelection || that.options.selectable && !kendo.ui.Selectable.parseOptions(that.options.selectable).cell;\n\n              if (that._draggableRowsInstance) {\n                that._draggableRowsInstance.destroy();\n              }\n\n              that._draggableRowsInstance = that.tbody.kendoDraggable({\n                group: \"row-draggable\",\n                autoScroll: true,\n                filter: (selectable ? \" > .k-state-selected\" : \" > \" + ITEMROW) + (that._hasDragHandleColumn ? \" > .k-drag-cell\" : \"\"),\n                hint: function (target) {\n                  var hint = $('<div class=\"k-reorder-clue k-drag-clue\"><span class=\"k-icon k-drag-status k-i-cancel\"></span></div>');\n\n                  if (selectable && that.select().length > 1) {\n                    hint.append(\"<span>\" + that.select().length + \" \" + that.options.messages.itemsSelected + \"</span>\");\n                  } else {\n                    var clone = target.closest(ITEMROW).clone();\n                    clone.find(\"td.k-command-cell\").remove();\n                    clone.find(\"td\").each(function (index, elm) {\n                      hint.append(\"<span>\" + elm.innerText + \"&nbsp;</span>\");\n                    });\n                  }\n\n                  return hint;\n                }\n              }).data(\"kendoDraggable\");\n            },\n            _reorderableRows: function () {\n              var that = this,\n                  selectable = that._checkBoxSelection || that.options.selectable && !kendo.ui.Selectable.parseOptions(that.options.selectable).cell;\n\n              if (that.tbody.data(\"kendoReorderable\")) {\n                that.tbody.data(\"kendoReorderable\").destroy();\n              }\n\n              that.tbody.kendoReorderable({\n                smartPosition: false,\n                draggable: that._draggableRowsInstance,\n                dragOverContainers: function (sourceIndex, targetIndex) {\n                  var result = true,\n                      target = $(ITEMROW, that.content).eq(targetIndex);\n\n                  if (selectable) {\n                    result = !target.is(\".k-state-selected\");\n                  }\n\n                  return result;\n                },\n                inSameContainer: function (e) {\n                  if (selectable) {\n                    return !$(e.target).is(\".k-state-selected\");\n                  }\n\n                  return true;\n                },\n                dropFilter: ITEMROW,\n                allowIcon: \"k-i-insert-middle\",\n                orientation: \"vertical\",\n                reorderDropCue: $('<div class=\"k-drop-hint k-drop-hint-h\"><div class=\"k-drop-hint-start\"></div><div class=\"k-drop-hint-line\"></div></div>'),\n                positionDropCue: function (reorderDropCue, dropTarget) {\n                  var firstCellLeft = kendo.getOffset(dropTarget.children(DATA_CELL).eq(0)).left;\n                  reorderDropCue.css({\n                    transform: \"translate(0,-50%)\",\n                    left: firstCellLeft\n                  });\n                },\n                externalDraggable: function (e) {\n                  var draggable = e.draggable;\n\n                  if (draggable) {\n                    return draggable;\n                  }\n                },\n                change: function (e) {\n                  that._triggerRowRorder(e);\n                }\n              });\n            },\n            _triggerRowRorder: function (e) {\n              var that = this,\n                  args = {\n                newIndex: e.position === \"after\" ? e.newIndex + 1 : e.newIndex,\n                oldIndex: e.oldIndex\n              },\n                  row = e.element,\n                  selectable = that._checkBoxSelection || that.options.selectable && !kendo.ui.Selectable.parseOptions(that.options.selectable).cell;\n\n              if (selectable && that.select().length > 1) {\n                args = extend(args, {\n                  rows: that.select()\n                });\n              } else {\n                args = extend(args, {\n                  row: row\n                });\n              }\n\n              if (!that.trigger(ROWREORDER, args)) {\n                that.reorderRows(selectable ? that.select() : row, args.newIndex);\n              }\n            },\n            reorderRows: function (rows, index) {\n              var that = this,\n                  dataSource = that.dataSource,\n                  rowsLength = that.tbody.children(ITEMROW).length,\n                  targetItem = that.dataItem(that.tbody.children(ITEMROW).eq(index)),\n                  items = rows.toArray().map(function (row) {\n                return that.dataItem(row);\n              });\n\n              if (!targetItem) {\n                // If index is after last row dataItem wouldn't exist\n                targetItem = that.dataItem(that.tbody.children(ITEMROW).eq(rowsLength - 1));\n                index = dataSource.indexOf(targetItem) + 1;\n              } else {\n                index = dataSource.indexOf(targetItem);\n              }\n\n              if (index >= 0) {\n                that._rowDropping = true;\n                dataSource.pushMove(index, items);\n                that._rowDropping = false;\n              }\n            },\n            autoFitColumns: function (columns) {\n              var that = this;\n              columns = columns || that.columns;\n\n              for (var i = 0; i < columns.length; i++) {\n                var column = columns[i];\n\n                if (column.columns) {\n                  that.autoFitColumns(column.columns);\n                } else {\n                  that.autoFitColumn(column);\n                }\n              }\n            },\n            autoFitColumn: function (column) {\n              var that = this,\n                  options = that.options,\n                  columns = that.columns,\n                  index,\n                  th,\n                  headerTable,\n                  leafCols,\n                  isLocked,\n                  visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(\">table>thead\")).filter(isCellVisible).length : 0,\n                  col,\n                  minWidth,\n                  contentDiv,\n                  scrollLeft,\n                  notGroupOrHierarchyCol = \"col:not(.k-group-col):not(.k-hierarchy-col)\",\n                  notGroupOrHierarchyVisibleCell = \"td:visible:not(.k-group-cell):not(.k-hierarchy-cell)\",\n                  menu,\n                  thWidth; //  retrieve the column object, depending on the method argument\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else if (isPlainObject(column)) {\n                column = grep(flatColumns(columns), function (item) {\n                  return item === column;\n                })[0];\n              } else {\n                column = grep(flatColumns(columns), function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || !isVisible(column)) {\n                return;\n              }\n\n              leafCols = leafColumns(columns);\n              minWidth = column.minResizableWidth;\n              index = inArray(column, leafCols);\n              isLocked = column.locked;\n\n              if (isLocked) {\n                headerTable = that.lockedHeader.children(\"table\");\n              } else {\n                headerTable = that.thead.parent();\n              }\n\n              th = headerTable.find(\"[data-index='\" + index + \"']\");\n              menu = th.find('a.k-header-column-menu, a.k-grid-filter');\n              var contentTable = isLocked ? that.lockedTable : that.table,\n                  footer = that.footer || $();\n\n              if (that.footer && that.lockedContent) {\n                footer = isLocked ? that.footer.children(\".k-grid-footer-locked\") : that.footer.children(\".k-grid-footer-wrap\");\n              }\n\n              var footerTable = footer.find(\"table\").first();\n\n              if (that.lockedHeader && !isLocked) {\n                index -= visibleLocked;\n              } // adjust column index, depending on previous hidden columns\n\n\n              for (var j = 0; j < leafCols.length; j++) {\n                if (leafCols[j] === column) {\n                  break;\n                } else {\n                  if (leafCols[j].hidden) {\n                    index--;\n                  }\n                }\n              } // get col elements\n\n\n              if (options.scrollable) {\n                col = headerTable.find(notGroupOrHierarchyCol).eq(index).add(contentTable.children(\"colgroup\").find(notGroupOrHierarchyCol).eq(index)).add(footerTable.find(\"colgroup\").find(notGroupOrHierarchyCol).eq(index));\n\n                if (!isLocked) {\n                  contentDiv = contentTable.parent();\n                  scrollLeft = kendo.scrollLeft(contentDiv);\n                }\n              } else {\n                col = contentTable.children(\"colgroup\").find(notGroupOrHierarchyCol).eq(index);\n              }\n\n              var tables = headerTable.add(contentTable).add(footerTable);\n\n              if (browser.safari) {\n                th.css(\"white-space\", \"initial\");\n              }\n\n              var oldColumnWidth = outerWidth(th); // reset the table and autofitted column widths\n              // if scrolling is disabled, we need some additional repainting of the table\n\n              col.width(\"\");\n              tables.css(\"table-layout\", \"fixed\");\n              col.width(\"auto\");\n              tables.addClass(\"k-autofitting\");\n              tables.css(\"table-layout\", \"\");\n              thWidth = menu.length ? outerWidth(menu) + outerWidth(th) : outerWidth(th); // +1 is required by IE, regardless of the border widths, otherwise unexpected wrapping may occur with hyphenated text\n\n              var newColumnWidth = Math.ceil(Math.max(thWidth, outerWidth(contentTable.find(\"tr:not(.k-grouping-row)\").eq(0).children(notGroupOrHierarchyVisibleCell).eq(index)), outerWidth(footerTable.find(\"tr\").eq(0).children(notGroupOrHierarchyVisibleCell).eq(index)))) + 1;\n\n              if (minWidth && minWidth > newColumnWidth) {\n                newColumnWidth = minWidth;\n              }\n\n              col.width(newColumnWidth);\n              column.width = newColumnWidth;\n\n              if (browser.safari) {\n                th.css(\"white-space\", \"\");\n              } // if all visible columns have widths, the table needs a pixel width as well\n\n\n              if (options.scrollable) {\n                var cols = headerTable.find(\"col\"),\n                    colWidth,\n                    totalWidth = 0;\n\n                for (var idx = 0, length = cols.length; idx < length; idx += 1) {\n                  colWidth = cols[idx].style.width;\n\n                  if (colWidth && colWidth.indexOf(\"%\") == -1) {\n                    totalWidth += parseInt(colWidth, 10);\n                  } else if (cols.eq(idx).hasClass(\"k-group-col\")) {\n                    totalWidth += parseInt(cols.eq(idx).width(), 10);\n                  } else {\n                    totalWidth = 0;\n                    break;\n                  }\n                }\n\n                if (totalWidth) {\n                  tables.each(function () {\n                    this.style.width = totalWidth + \"px\";\n                  });\n                }\n              }\n\n              tables.removeClass(\"k-autofitting\");\n\n              if (scrollLeft) {\n                kendo.scrollLeft(contentDiv, scrollLeft);\n              }\n\n              that.trigger(COLUMNRESIZE, {\n                column: column,\n                oldWidth: oldColumnWidth,\n                newWidth: newColumnWidth\n              });\n\n              that._applyLockedContainersWidth();\n\n              that._syncLockedContentHeight();\n\n              that._syncLockedHeaderHeight();\n\n              that._updateStickyColumns();\n            },\n            reorderColumn: function (destIndex, column, before) {\n              var that = this,\n                  parent = columnParent(column, that.columns),\n                  columns = parent ? parent.columns : that.columns,\n                  sourceIndex = inArray(column, columns),\n                  destColumn = columns[destIndex],\n                  virtualScroll = that.virtualScroll || {},\n                  lockChanged,\n                  isLocked = !!destColumn.locked,\n                  lockedCount = lockedColumns(that.columns).length,\n                  groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function (column) {\n                return column.groupHeaderColumnTemplate;\n              });\n\n              if (sourceIndex === destIndex) {\n                return;\n              }\n\n              if (!column.locked && isLocked && nonLockedColumns(that.columns).length == 1) {\n                return;\n              }\n\n              if (column.locked && !isLocked && lockedCount == 1) {\n                return;\n              }\n\n              that._hideResizeHandle();\n\n              if (before === undefined) {\n                before = destIndex < sourceIndex;\n              }\n\n              var sourceColumns = [column];\n\n              that._reorderHeader(sourceColumns, destColumn, before);\n\n              if (that.lockedHeader) {\n                removeEmptyRows(that.thead);\n                removeEmptyRows(that.lockedHeader);\n              }\n\n              if (destColumn.columns) {\n                destColumn = leafColumns(destColumn.columns);\n                destColumn = destColumn[before ? 0 : destColumn.length - 1];\n              }\n\n              if (column.columns) {\n                sourceColumns = leafColumns(column.columns);\n              }\n\n              that._reorderContent(sourceColumns, destColumn, before);\n\n              lockChanged = !!column.locked;\n              lockChanged = lockChanged != isLocked;\n              column.locked = isLocked;\n              columns.splice(before ? destIndex : destIndex + 1, 0, column);\n              columns.splice(sourceIndex < destIndex ? sourceIndex : sourceIndex + 1, 1);\n\n              that._updateLockedCols();\n\n              that._updateCols();\n\n              that._templates();\n\n              that._updateColumnCellIndex();\n\n              that._updateColumnSorters();\n\n              if (groupHeaderColumnTemplateColumns.length > 0) {\n                that._renderGroupRows();\n              }\n\n              that._updateTablesWidth();\n\n              that._applyLockedContainersWidth();\n\n              that._syncLockedHeaderHeight();\n\n              that._syncLockedContentHeight();\n\n              that._updateFirstColumnClass();\n\n              that._updateStickyColumns();\n\n              if (virtualScroll.columns) {\n                that.refresh();\n              }\n\n              if (!lockChanged) {\n                return;\n              }\n\n              if (isLocked) {\n                that.trigger(COLUMNLOCK, {\n                  column: column\n                });\n              } else {\n                that.trigger(COLUMNUNLOCK, {\n                  column: column\n                });\n              }\n            },\n            _updateColumnCellIndex: function () {\n              var header;\n              var offset = 0;\n\n              if (this.lockedHeader) {\n                header = this.lockedHeader.find(\"thead\");\n                offset = updateCellIndex(header, lockedColumns(this.columns));\n              }\n\n              updateCellIndex(this.thead, nonLockedColumns(this.columns), offset);\n            },\n            lockColumn: function (column) {\n              var columns = this.columns;\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else {\n                column = grep(columns, function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || column.locked || column.hidden) {\n                return;\n              }\n\n              if (column.sticky) {\n                this.unstickColumn(columns.indexOf(column));\n              }\n\n              var index = lockedColumns(columns).length - 1;\n              this.reorderColumn(index, column, false);\n            },\n            unlockColumn: function (column) {\n              var columns = this.columns;\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else {\n                column = grep(columns, function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || !column.locked || column.hidden) {\n                return;\n              }\n\n              var index = lockedColumns(columns).length;\n              this.reorderColumn(index, column, true);\n            },\n            stickColumn: function (column) {\n              var columns = this.columns;\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else {\n                column = grep(columns, function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || column.sticky || column.hidden) {\n                return;\n              }\n\n              if (column.locked) {\n                this.unlockColumn(columns.indexOf(column));\n\n                if (column.locked) {\n                  return;\n                }\n              }\n\n              column.sticky = true;\n\n              this._updateStickyColumns();\n            },\n            unstickColumn: function (column) {\n              var columns = this.columns;\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else {\n                column = grep(columns, function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || !column.sticky || column.locked || column.hidden) {\n                return;\n              }\n\n              this._removeStickyAttributes([column]);\n\n              this._removeStickyStyles(stickyColumns(columns));\n\n              column.sticky = false;\n\n              this._updateStickyColumns();\n\n              if (this._anyStickyColumns() === 0) {\n                this._templates();\n\n                if (this._hasFilterRow()) {\n                  this._updateStickyFilterCells();\n                }\n              }\n            },\n            cellIndex: function (td) {\n              var lockedColumnOffset = 0;\n\n              if (this.lockedTable && !$.contains(this.lockedTable[0], td[0])) {\n                lockedColumnOffset = leafColumns(lockedColumns(this.columns)).length;\n              }\n\n              return $(td).parent().children('td:not(.k-group-cell,.k-hierarchy-cell)').index(td) + lockedColumnOffset;\n            },\n            _modelForContainer: function (container) {\n              container = $(container);\n\n              if (!container.is(\"tr\") && this._editMode() !== \"popup\") {\n                container = container.closest(\"tr\");\n              }\n\n              var id = container.attr(kendo.attr(\"uid\"));\n              return this.dataSource.getByUid(id);\n            },\n            _calculateColumnIndex: function (cell) {\n              var cellIndex = this.cellIndex(cell);\n              var virtualOffset = 0;\n\n              if (this._hasVirtualColumns()) {\n                virtualOffset = parseInt($(cell).closest(\"tr\").find(\"td\").first().attr(\"colspan\"), 10);\n                virtualOffset = virtualOffset > 1 ? virtualOffset - 1 : 0;\n              }\n\n              return cellIndex + virtualOffset;\n            },\n            _editable: function () {\n              var that = this,\n                  editable = that.options.editable,\n                  handler = function () {\n                var target = activeElement(),\n                    cell = that._editContainer;\n\n                if (cell && cell[0] && !$.contains(cell[0], target) && cell[0] !== target && !$(target).closest(\".k-animation-container\").length) {\n                  if (that.editable.end()) {\n                    that.closeCell();\n                  } else {\n                    that._scrollVirtualWrapper();\n                  }\n                }\n              };\n\n              if (editable) {\n                this.wrapper.addClass(\"k-editable\");\n\n                var mode = that._editMode();\n\n                if (mode === \"incell\") {\n                  that.table.add(that.lockedTable).on(\"mousedown\" + NS, NAVROW + \">\" + NAVCELL, function (e) {\n                    var target = $(e.target);\n\n                    if (that._editMode() === \"incell\" && target.hasClass(\"k-checkbox\") && target.prev().attr(kendo.attr(\"bind\"))) {\n                      e.preventDefault();\n                    }\n                  });\n\n                  if (editable.update !== false) {\n                    if (isMac) {\n                      that.wrapper.on(CLICK + NS, \".k-edit-cell > input[type='checkbox']\", function (e) {\n                        // checking /unchecking a checkbox does not change the document.activeElement to be the checkbox\n                        // this is necessary for the \"focusout\" event to be fired\n                        $(e.target).trigger(\"focus\");\n                      }).on(CLICK + NS, \".k-edit-cell\", function (e) {\n                        if (!$(e.target).is(\"input\")) {\n                          $(e.currentTarget).find(\"input[type='checkbox']\").trigger(\"focus\");\n                        }\n                      }).on(MOUSEDOWN + NS, \"tr:not(.k-grouping-row) > td\", function (e) {\n                        var editContainer = that._editContainer;\n\n                        if (editContainer && editContainer[0] && ($.contains(editContainer[0], e.target) || editContainer[0] === e.target)) {\n                          that._mousedownOnEditCell = true;\n                        } else {\n                          that._mousedownOnEditCell = false;\n                        }\n                      });\n                    }\n\n                    that.editableUserEvents = new kendo.UserEvents(that.wrapper, {\n                      filter: \"tr:not(.k-grouping-row) > td\",\n                      allowSelection: true,\n                      tap: function (e) {\n                        var td = $(e.target),\n                            isLockedCell = that.lockedTable && td.closest(\"table\")[0] === that.lockedTable[0];\n                        that._mousedownOnEditCell = false;\n\n                        if (td.hasClass(\"k-hierarchy-cell\") || td.hasClass(\"k-detail-cell\") || td.hasClass(\"k-group-cell\") || td.hasClass(\"k-edit-cell\") || td.has(\".k-grid-delete\").length || td.closest(\"tbody\")[0] !== that.tbody[0] && !isLockedCell || $(e.target).is(\":input\")) {\n                          return;\n                        }\n\n                        if (that.editable) {\n                          if (that.editable.end()) {\n                            $(activeElement()).trigger(\"blur\");\n                            that.closeCell();\n                            that.editCell(td);\n                          } else {\n                            that._scrollVirtualWrapper();\n                          }\n                        } else {\n                          that.editCell(td);\n                        }\n                      }\n                    });\n                    that.wrapper.on(\"focusin\" + NS, function () {\n                      // fix focus issue in IE\n                      if (!$.contains(this, activeElement())) {\n                        clearTimeout(that.timer);\n                        that.timer = null;\n                      }\n                    }).on(\"focusout\" + NS, function (e) {\n                      var shouldCloseCell = true;\n\n                      if (isMac && that._mousedownOnEditCell || that._virtualColScroll) {\n                        shouldCloseCell = false;\n                      }\n\n                      that._mousedownOnEditCell = false;\n\n                      if (shouldCloseCell) {\n                        that.timer = setTimeout(function () {\n                          handler(e);\n                        }, 1);\n                      }\n                    });\n                  }\n                } else {\n                  if (editable.update !== false) {\n                    that.wrapper.on(CLICK + NS, \"tbody>tr:not(.k-detail-row,.k-grouping-row):visible .k-grid-edit\", function (e) {\n                      var element = $(this);\n\n                      if (!that._belongsToGrid(element)) {\n                        return;\n                      }\n\n                      e.preventDefault();\n                      that.editRow(element.closest(\"tr\"));\n                    });\n\n                    if (that._isVirtualInlineEditable()) {\n                      that.wrapper.on(\"focusout\" + NS, \"tr:not(.k-grouping-row) > td\", function () {\n                        if (that.editable && !that.editable.end()) {\n                          that._scrollVirtualWrapper();\n                        }\n                      });\n                    }\n                  }\n                }\n\n                if (editable.destroy !== false) {\n                  that.wrapper.on(CLICK + NS, \"tbody>tr:not(.k-detail-row,.k-grouping-row):visible .k-grid-delete\", function (e) {\n                    var element = $(this);\n\n                    if (!that._belongsToGrid(element)) {\n                      return;\n                    }\n\n                    e.preventDefault();\n                    e.stopPropagation();\n                    that.removeRow(element.closest(\"tr\"));\n                  });\n                } else {\n                  //Required for the MVC server wrapper delete button\n                  that.wrapper.on(CLICK + NS, \"tbody>tr:not(.k-detail-row,.k-grouping-row):visible .k-grid-delete\", function (e) {\n                    if (!that._belongsToGrid($(this))) {\n                      return;\n                    }\n\n                    e.stopPropagation();\n\n                    if (!that._confirmation()) {\n                      e.preventDefault();\n                    }\n                  });\n                }\n              }\n            },\n            editCell: function (cell) {\n              cell = $(cell);\n\n              var that = this,\n                  column = leafColumns(that.columns)[that._calculateColumnIndex(cell)],\n                  model = that._modelForContainer(cell);\n\n              that.closeCell();\n\n              if (model && isColumnEditable(column, model) && !column.command) {\n                if (that.trigger(BEFOREEDIT, {\n                  model: model\n                })) {\n                  return;\n                }\n\n                that._attachModelChange(model);\n\n                that._editContainer = cell;\n\n                if (that._shouldClearEditableState) {\n                  that._clearEditableState();\n                }\n\n                that.editable = cell.addClass(\"k-edit-cell\").kendoEditable({\n                  fields: {\n                    field: column.field,\n                    format: column.format,\n                    editor: column.editor,\n                    values: column.values\n                  },\n                  model: model,\n                  target: that,\n                  change: function (e) {\n                    if (that.trigger(SAVE, {\n                      values: e.values,\n                      container: cell,\n                      model: model\n                    })) {\n                      e.preventDefault();\n                    }\n                  },\n                  skipFocus: (that._isVirtualIncellEditable() || that._hasVirtualColumns()) && that._editableState ? true : false\n                }).data(\"kendoEditable\");\n                var tr = cell.parent().addClass(\"k-grid-edit-row\");\n\n                if (that.lockedContent) {\n                  adjustRowHeight(tr[0], that._relatedRow(tr).addClass(\"k-grid-edit-row\")[0]);\n\n                  that._syncLockedScroll();\n                }\n\n                that.trigger(EDIT, {\n                  container: cell,\n                  model: model\n                });\n              }\n            },\n            _adjustLockedHorizontalScrollBar: function () {\n              var table = this.table,\n                  content = table.parent();\n              var scrollbar = table[0].offsetWidth > content[0].clientWidth ? kendo.support.scrollbar() : 0;\n              this.lockedContent.height(content[0].offsetHeight - scrollbar);\n            },\n            _syncLockedScroll: function () {\n              this.lockedContent[0].scrollTop = this.content[0].scrollTop;\n\n              if (this.virtualScrollable) {\n                this.lockedContent[0].scrollTop = this.wrapper.find(\".k-virtual-scrollable-wrap\")[0].scrollTop;\n              }\n            },\n            _syncLockedContentHeight: function () {\n              if (this.lockedTable) {\n                if (!this.touchScroller) {\n                  this._adjustLockedHorizontalScrollBar();\n                }\n\n                this._adjustRowsHeight(this.table, this.lockedTable);\n              }\n            },\n            _syncLockedHeaderHeight: function () {\n              if (this.lockedHeader) {\n                var lockedTable = this.lockedHeader.children(\"table\");\n                var table = this.thead.parent();\n\n                this._adjustRowsHeight(lockedTable, table);\n\n                syncTableHeight(lockedTable, table);\n              }\n            },\n            _syncLockedFooterHeight: function () {\n              if (this.lockedFooter && this.footer && this.footer.length) {\n                this._adjustRowsHeight(this.lockedFooter.children(\"table\"), this.footer.find(\".k-grid-footer-wrap > table\"));\n              }\n            },\n            _destroyEditable: function () {\n              var that = this;\n\n              var destroy = function () {\n                if (that.editable) {\n                  var container = that.editView ? that.editView.element : that._editContainer;\n\n                  if (container) {\n                    container.off(CLICK + NS, \".k-grid-cancel\", that._editCancelClickHandler);\n                    container.off(CLICK + NS, \".k-grid-update\", that._editUpdateClickHandler);\n                  }\n\n                  that._detachModelChange();\n\n                  that.editable.destroy();\n                  that.editable = null;\n                  that._editContainer = null;\n\n                  that._destroyEditView();\n\n                  that._editableIsClosing = null;\n                }\n              };\n\n              if (that.editable) {\n                if (that._editMode() === \"popup\" && !that._isMobile) {\n                  if (that._editableIsClosing) {\n                    that._editContainer.data(\"kendoWindow\").bind(\"deactivate\", destroy);\n                  } else {\n                    that._editableIsClosing = true;\n\n                    that._editContainer.data(\"kendoWindow\").bind(\"deactivate\", destroy).close();\n                  }\n                } else {\n                  destroy();\n                }\n              }\n\n              if (that._confirmDialog) {\n                that._confirmDialog.close();\n\n                that._confirmDialog.destroy();\n\n                that._confirmDialog = null;\n              }\n            },\n            _destroyEditView: function () {\n              if (this.editView) {\n                this.editView.purge();\n                this.editView = null;\n                this.pane.navigate(\"\");\n              }\n            },\n            _attachModelChange: function (model) {\n              var that = this;\n\n              that._modelChangeHandler = function (e) {\n                that._modelChange({\n                  field: e.field,\n                  model: this\n                });\n              };\n\n              model.bind(\"change\", that._modelChangeHandler);\n            },\n            _detachModelChange: function () {\n              var that = this,\n                  container = that._editContainer,\n                  model = that._modelForContainer(container);\n\n              if (model) {\n                model.unbind(CHANGE, that._modelChangeHandler);\n              }\n            },\n            closeCell: function (isCancel) {\n              var that = this,\n                  cell = that._editContainer,\n                  column,\n                  tr,\n                  model;\n\n              if (!cell) {\n                return;\n              }\n\n              model = that._modelForContainer(cell);\n\n              if (isCancel && that.trigger(\"cancel\", {\n                container: cell,\n                model: model\n              })) {\n                return;\n              }\n\n              that.trigger(CELLCLOSE, {\n                type: isCancel ? \"cancel\" : \"save\",\n                model: model,\n                container: cell\n              });\n              cell.removeClass(\"k-edit-cell\");\n              column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n              tr = cell.parent().removeClass(\"k-grid-edit-row\");\n\n              if (that.lockedContent) {\n                that._relatedRow(tr).removeClass(\"k-grid-edit-row\");\n              }\n\n              that._destroyEditable(); // editable should be destroyed before content of the container is changed\n\n\n              that._displayCell(cell, column, model);\n\n              if (that._shouldClearEditableState) {\n                that._clearEditableState();\n              }\n\n              that.trigger(\"itemChange\", {\n                item: tr,\n                data: model,\n                ns: ui\n              });\n\n              if (that.lockedContent) {\n                adjustRowHeight(tr.css(\"height\", \"\")[0], that._relatedRow(tr).css(\"height\", \"\")[0]);\n              }\n            },\n            _displayCell: function (cell, column, dataItem) {\n              var that = this,\n                  state = {\n                storage: {},\n                count: 0\n              },\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n              if (state.count > 0) {\n                tmpl = tmpl.bind(state.storage);\n              }\n\n              cell.empty().html(tmpl(dataItem));\n              that.angular(\"compile\", function () {\n                return {\n                  elements: cell,\n                  data: [{\n                    dataItem: dataItem\n                  }]\n                };\n              });\n            },\n            removeRow: function (row) {\n              if (!this._confirmation(row)) {\n                return;\n              }\n\n              this._removeRow(row);\n            },\n            _removeRow: function (row) {\n              var that = this,\n                  model,\n                  modelId,\n                  key,\n                  schema,\n                  mode = that._editMode();\n\n              if (mode !== \"incell\") {\n                that.cancelRow();\n              }\n\n              row = $(row);\n\n              if (that.lockedContent) {\n                row = row.add(that._relatedRow(row));\n              }\n\n              row = row.hide();\n\n              if (that.dataSource._isGroupPaged()) {\n                that._removeGroupIfEmpty(row);\n              }\n\n              model = that._modelForContainer(row);\n\n              if (model && !that.trigger(REMOVE, {\n                row: row,\n                model: model\n              })) {\n                schema = that.dataSource.options.schema;\n\n                if (that._selectedIds && schema && schema.model) {\n                  modelId = isFunction(that.dataSource.options.schema.model) ? that.dataSource.options.schema.model.fn.idField : that.dataSource.options.schema.model.id;\n                  key = model[modelId];\n                  delete that._selectedIds[key];\n                }\n\n                that.dataSource.remove(model);\n\n                if (mode === \"inline\" || mode === \"popup\") {\n                  that.dataSource.sync();\n                }\n              } else if (mode === \"incell\") {\n                that._destroyEditable();\n              }\n            },\n            _editMode: function () {\n              var mode = \"incell\",\n                  editable = this.options.editable;\n\n              if (editable !== true) {\n                if (typeof editable == \"string\") {\n                  mode = editable;\n                } else {\n                  mode = editable.mode || mode;\n                }\n              }\n\n              return mode;\n            },\n            editRow: function (row) {\n              var model;\n              var that = this;\n\n              if (row instanceof ObservableObject) {\n                model = row;\n              } else {\n                row = $(row);\n                model = that._modelForContainer(row);\n              }\n\n              var mode = that._editMode();\n\n              var container;\n              that.cancelRow();\n\n              if (model) {\n                row = that.tbody.children(\"[\" + kendo.attr(\"uid\") + \"=\" + model.uid + \"]\");\n\n                that._attachModelChange(model);\n\n                if (mode === \"popup\") {\n                  that._createPopupEditor(model);\n                } else if (mode === \"inline\") {\n                  that._createInlineEditor(row, model);\n                } else if (mode === \"incell\") {\n                  $(row).children(DATA_CELL).each(function () {\n                    var cell = $(this);\n\n                    var column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n                    model = that._modelForContainer(cell);\n\n                    if (model && (!model.editable || model.editable(column.field)) && column.field && !column.selectable) {\n                      that.editCell(cell);\n                      return false;\n                    }\n                  });\n                }\n\n                container = that.editView ? that.editView.element : that._editContainer;\n\n                if (container) {\n                  if (!this._editCancelClickHandler) {\n                    this._editCancelClickHandler = this._editCancelClick.bind(this);\n                  }\n\n                  container.on(CLICK + NS, \".k-grid-cancel\", this._editCancelClickHandler);\n\n                  if (!this._editUpdateClickHandler) {\n                    this._editUpdateClickHandler = this._editUpdateClick.bind(this);\n                  }\n\n                  container.on(CLICK + NS, \".k-grid-update\", this._editUpdateClickHandler);\n                }\n              }\n            },\n            _editUpdateClick: function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n              this.saveRow();\n            },\n            _editCancelClick: function (e) {\n              var that = this;\n              var navigatable = that.options.navigatable;\n              var model = that.editable.options.model;\n              var container = that.editView ? that.editView.element : that._editContainer;\n              e.preventDefault();\n              e.stopPropagation();\n\n              if (that.trigger(\"cancel\", {\n                container: container,\n                model: model\n              })) {\n                return;\n              }\n\n              var currentIndex = that.items().index($(that.current()).parent());\n              that.cancelRow();\n\n              if (navigatable) {\n                that._setCurrent(that.items().eq(currentIndex).children().filter(NAVCELL).first());\n\n                focusTable(that.table, true);\n              }\n            },\n            _createPopupEditor: function (model) {\n              var that = this;\n              var html = '<div ' + kendo.attr(\"uid\") + '=\"' + model.uid + '\" class=\"k-popup-edit-form\"><' + (that._isMobile ? 'ul class=\"k-edit-form-container k-listgroup k-listgroup-flush\">' : 'div class=\"k-edit-form-container\">');\n              var column;\n              var command;\n              var fields = [];\n              var idx;\n              var length;\n              var tmpl;\n              var updateText;\n              var cancelText;\n              var updateIconClass;\n              var cancelIconClass;\n              var tempCommand;\n              var columns = leafColumns(that.columns);\n              var attr;\n              var editMenuGuid = kendo.guid();\n              var editable = that.options.editable;\n              var template = editable.template;\n              var options = isPlainObject(editable) ? editable.window : {};\n              var settings = extend({}, kendo.Template, that.options.templateSettings);\n              var state;\n\n              if (that.trigger(BEFOREEDIT, {\n                model: model\n              })) {\n                return;\n              }\n\n              options = options || {};\n\n              if (template) {\n                if (typeof template === STRING) {\n                  template = kendo.unescape(template);\n                }\n\n                html += kendo.template(template, settings)(model);\n\n                for (idx = 0, length = columns.length; idx < length; idx++) {\n                  column = columns[idx];\n\n                  if (column.command) {\n                    tempCommand = getCommand(column.command, \"edit\");\n\n                    if (tempCommand) {\n                      command = tempCommand;\n                    }\n                  }\n                }\n              } else {\n                for (idx = 0, length = columns.length; idx < length; idx++) {\n                  column = columns[idx];\n\n                  if (column.selectable) {\n                    continue;\n                  }\n\n                  if (!column.command) {\n                    if (!that._isMobile) {\n                      html += '<div class=\"k-edit-label\"><label for=\"' + column.field + '\">' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title) : column.title) || column.field || \"\") + '</label></div>';\n\n                      if (isColumnEditable(column, model)) {\n                        fields.push({\n                          field: column.field,\n                          title: column.title,\n                          format: column.format,\n                          editor: column.editor,\n                          values: column.values\n                        });\n                        html += '<div ' + kendo.attr(\"container-for\") + '=\"' + column.field + '\" class=\"k-edit-field\"></div>';\n                      } else {\n                        state = {\n                          storage: {},\n                          count: 0\n                        };\n                        tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n                        if (state.count > 0) {\n                          tmpl = tmpl.bind(state.storage);\n                        }\n\n                        html += '<div class=\"k-edit-field k-no-editor\">' + tmpl(model) + '</div>';\n                      }\n                    } else {\n                      html += '<li class=\"k-item k-listgroup-item\">';\n\n                      if (isColumnEditable(column, model)) {\n                        fields.push({\n                          field: column.field,\n                          title: column.title,\n                          format: column.format,\n                          editor: column.editor,\n                          values: column.values\n                        });\n                        html += '<label class=\"k-label k-listgroup-form-row\">';\n                        html += '<span class=\"k-item-title k-listgroup-form-field-label\">' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || column.field || \"\") + '</span>';\n                        html += '<div class=\"k-listgroup-form-field-wrapper\" id=\"' + column.field + '_' + editMenuGuid + '\" ' + kendo.attr(\"container-for\") + '=\"' + column.field + '\"></div>';\n                        html += '</label>';\n                      } else {\n                        state = {\n                          storage: {},\n                          count: 0\n                        };\n                        tmpl = kendo.template(that._cellTmpl(column, state), settings);\n\n                        if (state.count > 0) {\n                          tmpl = tmpl.bind(state.storage);\n                        }\n\n                        html += '<label class=\"k-label k-listgroup-form-row k-no-click\">';\n                        html += '<span class=\"k-item-title k-listgroup-form-field-label\">' + (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || column.field || \"\") + '</span>';\n                        html += '<span class=\"k-no-editor k-listgroup-form-field-wrapper\">' + tmpl(model) + '</span>';\n                        html += '</label>';\n                      }\n\n                      html += \"</li>\";\n                    }\n                  } else if (column.command) {\n                    tempCommand = getCommand(column.command, \"edit\");\n\n                    if (tempCommand) {\n                      command = tempCommand;\n                    }\n                  }\n                }\n              }\n\n              if (command) {\n                if (isPlainObject(command)) {\n                  if (isPlainObject(command.text)) {\n                    updateText = command.text.update;\n                    cancelText = command.text.cancel;\n                  }\n\n                  if (isPlainObject(command.iconClass)) {\n                    updateIconClass = command.iconClass.update;\n                    cancelIconClass = command.iconClass.cancel;\n                  }\n\n                  if (command.attr) {\n                    attr = command.attr;\n                  }\n                }\n              }\n\n              var container;\n\n              if (!that._isMobile) {\n                html += '<div class=\"k-edit-buttons k-actions-end\">';\n                html += that._createButton({\n                  name: \"update\",\n                  text: updateText,\n                  attr: attr,\n                  iconClass: updateIconClass\n                }) + that._createButton({\n                  name: \"canceledit\",\n                  text: cancelText,\n                  attr: attr,\n                  iconClass: cancelIconClass\n                });\n                html += '</div></div></div>';\n                container = that._editContainer = $(html).appendTo(that.wrapper).eq(0).kendoWindow(extend({\n                  modal: true,\n                  resizable: false,\n                  draggable: true,\n                  title: that.options.messages.commands.edit || \"Edit\",\n                  visible: false,\n                  close: function (e) {\n                    if (e.userTriggered) {\n                      //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n                      e.sender.element.trigger(\"focus\");\n\n                      if (that.trigger(\"cancel\", {\n                        container: container,\n                        model: model\n                      })) {\n                        e.preventDefault();\n                        return;\n                      }\n\n                      var currentIndex = that.items().index($(that.current()).parent());\n                      that._editableIsClosing = true;\n                      that.cancelRow();\n\n                      if (that.options.navigatable) {\n                        that._setCurrent(that.items().eq(currentIndex).children().filter(NAVCELL).first());\n\n                        focusTable(that.table, true);\n                      }\n                    }\n                  }\n                }, options));\n              } else {\n                html += \"</ul></div>\";\n                that.editView = that.pane.append('<div data-' + kendo.ns + 'role=\"view\" class=\"k-grid-edit-form\">' + '<div data-' + kendo.ns + 'role=\"header\" class=\"k-header\">' + '<a href=\"\\\\#\" class=\"k-header-cancel k-link k-grid-cancel\" title=\"#=messages.cancel#\" ' + 'aria-label=\"#=messages.cancel#\"><span class=\"k-icon k-i-arrow-chevron-left\"></span></a>' + (that.options.messages.commands.edit || \"Edit\") + '<a href=\"\\\\#\" class=\"k-header-done k-link k-grid-update\" title=\"#=messages.done#\" ' + 'aria-label=\"#=messages.done#\"><span class=\"k-icon k-i-check\"></span></a>' + '</div>' + '<div data-' + kendo.ns + 'role=\"content\" class=\"' + classNames.content + '\">' + html + '</div>' + '</div>');\n                container = that._editContainer = that.editView.element.find(\".k-popup-edit-form\");\n              }\n\n              that.editable = that._editContainer.kendoEditable({\n                fields: fields,\n                model: model,\n                clearContainer: false,\n                target: that\n              }).data(\"kendoEditable\");\n\n              that._openPopUpEditor();\n\n              that.trigger(EDIT, {\n                container: container,\n                model: model\n              });\n            },\n            _openPopUpEditor: function () {\n              var that = this;\n              var windowEditor = that._editContainer ? that._editContainer.data(\"kendoWindow\") : null;\n              var windowOptions = (that.options.editable || {}).window || {};\n\n              if (!this._isMobile) {\n                if (windowEditor) {\n                  if (!windowOptions.position) {\n                    windowEditor.center();\n                  }\n\n                  windowEditor.open();\n                }\n              } else {\n                this.pane.navigate(this.editView, this._editAnimation);\n              }\n            },\n            _createInlineEditor: function (row, model) {\n              var that = this;\n              var column;\n              var cell;\n              var command;\n              var fields = [];\n\n              if (that.trigger(BEFOREEDIT, {\n                model: model\n              })) {\n                return;\n              }\n\n              if (that.lockedContent) {\n                row = row.add(that._relatedRow(row));\n              }\n\n              row.children(\":not(.k-group-cell,.k-hierarchy-cell)\").each(function () {\n                cell = $(this);\n                column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n                if (!column.command && isColumnEditable(column, model)) {\n                  fields.push({\n                    field: column.field,\n                    title: column.title,\n                    format: column.format,\n                    editor: column.editor,\n                    values: column.values\n                  });\n                  cell.attr(kendo.attr(\"container-for\"), column.field);\n                  cell.empty();\n                } else if (column.command) {\n                  command = getCommand(column.command, \"edit\");\n\n                  if (command) {\n                    cell.empty();\n                    var updateText, cancelText, updateIconClass, cancelIconClass, attr;\n\n                    if (isPlainObject(command)) {\n                      if (isPlainObject(command.text)) {\n                        updateText = command.text.update;\n                        cancelText = command.text.cancel;\n                      }\n\n                      if (isPlainObject(command.iconClass)) {\n                        updateIconClass = command.iconClass.update;\n                        cancelIconClass = command.iconClass.cancel;\n                      }\n\n                      if (command.attr) {\n                        attr = command.attr;\n                      }\n                    }\n\n                    $(that._createButton({\n                      name: \"update\",\n                      text: updateText,\n                      attr: attr,\n                      iconClass: updateIconClass\n                    }) + that._createButton({\n                      name: \"canceledit\",\n                      text: cancelText,\n                      attr: attr,\n                      iconClass: cancelIconClass\n                    })).appendTo(cell);\n                  }\n                }\n              });\n              that._editContainer = row;\n\n              that._editContainer.addClass(\"k-grid-edit-row\");\n\n              if (that._shouldClearEditableState) {\n                that._clearEditableState();\n              }\n\n              that.editable = new kendo.ui.Editable(that._editContainer, {\n                target: that,\n                fields: fields,\n                model: model,\n                skipFocus: that._isVirtualInlineEditable() && that._editableState && (that._editableState.field ? true : false) || that._hasVirtualColumns(),\n                clearContainer: false\n              });\n\n              if (row.length > 1) {\n                adjustRowHeight(row[0], row[1]);\n\n                that._applyLockedContainersWidth();\n              }\n\n              that.trigger(EDIT, {\n                container: row,\n                model: model\n              });\n            },\n            cancelRow: function (notify) {\n              var that = this,\n                  container = that._editContainer,\n                  model;\n\n              if (container) {\n                model = that._modelForContainer(container);\n\n                if (!model || notify && that.trigger(\"cancel\", {\n                  container: container,\n                  model: model\n                })) {\n                  return;\n                }\n\n                that._destroyEditable();\n\n                that.dataSource.cancelChanges(model);\n\n                that._clearEditableState();\n\n                if (that._editMode() !== \"popup\") {\n                  that._displayRow(container);\n                } else {\n                  that._displayRow(that.tbody.find(\"[\" + kendo.attr(\"uid\") + \"=\" + model.uid + \"]\"));\n                }\n              }\n            },\n            saveRow: function () {\n              var that = this;\n              var container = this._editContainer;\n\n              var model = this._modelForContainer(container);\n\n              var deferred = $.Deferred();\n              var valid;\n\n              if (!container || !this.editable) {\n                return deferred.resolve().promise();\n              }\n\n              valid = that.editable && that.editable.end();\n\n              if (!valid || this.trigger(SAVE, {\n                container: container,\n                model: model\n              })) {\n                if (!valid) {\n                  that._scrollVirtualWrapper();\n                }\n\n                return deferred.reject().promise();\n              }\n\n              that._clearEditableState();\n\n              return this.dataSource.sync();\n            },\n            _displayRow: function (row) {\n              var that = this,\n                  model = that._modelForContainer(row),\n                  related,\n                  newRow,\n                  nextRow,\n                  isSelected = row.hasClass(\"k-state-selected\"),\n                  isAlt = row.hasClass(\"k-alt\");\n\n              if (model) {\n                if (that.lockedContent) {\n                  related = $((isAlt ? that.lockedAltRowTemplate : that.lockedRowTemplate)(model));\n\n                  that._relatedRow(row.last()).replaceWith(related);\n                }\n\n                that.angular(\"cleanup\", function () {\n                  return {\n                    elements: row.get()\n                  };\n                });\n                newRow = $((isAlt ? that.altRowTemplate : that.rowTemplate)(model));\n\n                if (!row.is(\":visible\")) {\n                  newRow.hide();\n                }\n\n                row.replaceWith(newRow);\n                that.trigger(\"itemChange\", {\n                  item: newRow,\n                  data: model,\n                  ns: ui\n                });\n\n                if (related && related.length) {\n                  that.trigger(\"itemChange\", {\n                    item: related,\n                    data: model,\n                    ns: ui\n                  });\n                }\n\n                var angularElements = newRow;\n                var angularData = [{\n                  dataItem: model\n                }];\n\n                if (related && related.length) {\n                  angularElements = newRow.add(related);\n                  angularData.push({\n                    dataItem: model\n                  });\n                }\n\n                that.angular(\"compile\", function () {\n                  return {\n                    elements: angularElements.get(),\n                    data: angularData\n                  };\n                });\n\n                if (isSelected && (that.options.selectable || that._checkBoxSelection)) {\n                  that.select(newRow.add(related));\n                }\n\n                if (related) {\n                  adjustRowHeight(newRow[0], related[0]);\n                }\n\n                nextRow = newRow.next();\n\n                if (nextRow.hasClass(\"k-detail-row\") && nextRow.is(\":visible\")) {\n                  newRow.find(\".k-hierarchy-cell .k-icon\").removeClass(\"k-i-expand\").addClass(\"k-i-collapse\");\n                }\n              }\n            },\n            _showMessage: function (messages, row) {\n              var that = this;\n\n              if (!that._isMobile) {\n                return window.confirm(messages.title);\n              }\n\n              var confirmDialog = that._confirmDialog = new kendo.ui.Confirm($(\"<div />\").appendTo(document.body), {\n                modal: {\n                  preventScroll: true\n                },\n                closable: false,\n                title: false,\n                content: messages.title,\n                messages: {\n                  okText: messages.confirmDelete,\n                  cancel: messages.cancelDelete\n                },\n                open: function () {\n                  if (that.content) {\n                    that.content.data(OVERFLOW, that.content.css(OVERFLOW));\n                    that.content.css(OVERFLOW, HIDDEN);\n                  }\n                },\n                close: function () {\n                  if (that.content) {\n                    that.content.css(OVERFLOW, that.content.data(OVERFLOW));\n                  }\n                }\n              });\n              confirmDialog.result.done(function () {\n                that._removeRow(row);\n              }).fail(function () {\n                var confirmDialog = that._confirmDialog;\n\n                if (confirmDialog) {\n                  confirmDialog.close();\n                  confirmDialog.destroy();\n                }\n              });\n              return false;\n            },\n            _confirmation: function (row) {\n              var that = this,\n                  editable = that.options.editable,\n                  confirmation = editable === true || typeof editable === STRING ? that.options.messages.editable.confirmation : editable.confirmation;\n\n              if (isPlainObject(editable) && typeof editable.mode === STRING && typeof confirmation !== FUNCTION && typeof confirmation !== STRING && confirmation !== false) {\n                confirmation = that.options.messages.editable.confirmation;\n              }\n\n              if (confirmation !== false && confirmation != null) {\n                if (typeof confirmation === FUNCTION) {\n                  confirmation = confirmation(that._modelForContainer(row));\n                }\n\n                return that._showMessage({\n                  confirmDelete: editable.confirmDelete || that.options.messages.editable.confirmDelete,\n                  cancelDelete: editable.cancelDelete || that.options.messages.editable.cancelDelete,\n                  title: confirmation === true ? that.options.messages.editable.confirmation : confirmation\n                }, row);\n              }\n\n              return true;\n            },\n            cancelChanges: function () {\n              var that = this;\n              that.dataSource.cancelChanges();\n\n              if (that._isVirtualEditable()) {\n                that._virtualPageToTop(function () {\n                  that.virtualScrollable.scrollToTop();\n                });\n              }\n            },\n            saveChanges: function () {\n              var that = this;\n              var valid = that.editable && that.editable.end();\n\n              if ((valid || !that.editable) && !that.trigger(SAVECHANGES)) {\n                that.dataSource.sync();\n              } else if (!valid) {\n                that._scrollVirtualWrapper();\n              }\n            },\n            addRow: function () {\n              var that = this,\n                  index,\n                  dataSource = that.dataSource,\n                  mode = that._editMode(),\n                  createAt = that.options.editable.createAt || \"\",\n                  pageSize = dataSource.pageSize(),\n                  view = dataSource.view() || [];\n\n              var createAtBottom = createAt.toLowerCase() === BOTTOM;\n              var model;\n\n              var virtualEditable = that._isVirtualEditable();\n\n              if (that.editable && that.editable.end() || !that.editable) {\n                if (mode != \"incell\") {\n                  that.cancelRow();\n                }\n\n                index = dataSource.indexOf(view[0]);\n\n                if (createAtBottom) {\n                  index += view.length;\n\n                  if (pageSize && !dataSource.options.serverPaging && pageSize <= view.length) {\n                    index -= 1;\n                  }\n                }\n\n                if (index < 0) {\n                  if (dataSource.page() > dataSource.totalPages()) {\n                    index = (dataSource.page() - 1) * pageSize;\n                  } else {\n                    index = 0;\n                  }\n                }\n\n                if (that.options.navigatable && mode == \"incell\") {\n                  that._removeCurrent();\n                }\n\n                if (virtualEditable) {\n                  that._virtualAddRow();\n                } else {\n                  model = dataSource.insert(index, {});\n\n                  that._editModel(model);\n                }\n              } else {\n                that._scrollVirtualWrapper();\n              }\n            },\n            _editModel: function (model) {\n              var that = this;\n              var createAt = that.options.editable.createAt || \"\";\n\n              var mode = that._editMode();\n\n              if (model) {\n                var id = model.uid,\n                    table = that.lockedContent ? that.lockedTable : that.table,\n                    row = table.find(\"tr[\" + kendo.attr(\"uid\") + \"=\" + id + \"]\"),\n                    cell = row.children(\"td:not(.k-group-cell,.k-hierarchy-cell)\").eq(that._firstEditableColumnIndex(row));\n\n                if (mode === \"inline\" && row.length) {\n                  that.editRow(row);\n                } else if (mode === \"popup\") {\n                  that.editRow(model);\n                } else if (cell.length) {\n                  that.editCell(cell);\n                }\n\n                if (createAt.toLowerCase() == \"bottom\" && that.lockedContent) {\n                  //scroll the containers to the bottom\n                  that.lockedContent[0].scrollTop = that.content[0].scrollTop = that.table[0].offsetHeight;\n                }\n              }\n            },\n            _virtualAddRow: function () {\n              var that = this;\n              var createAtBottom = (that.options.editable.createAt || \"\").toLowerCase() === BOTTOM;\n\n              that._clearEditableState();\n\n              if (createAtBottom) {\n                that._virtualAddRowAtBottom();\n              } else {\n                that._virtualAddRowAtTop();\n              }\n            },\n            _virtualAddRowAtTop: function () {\n              var that = this;\n              var dataSource = that.dataSource;\n              var virtualScrollable = that.virtualScrollable;\n              var model;\n\n              if (dataSource.page() === 1) {\n                model = dataSource.insert(0, {});\n\n                that._editModel(model);\n\n                virtualScrollable.scrollToTop();\n              } else {\n                that._virtualPageToTop(function () {\n                  model = dataSource.insert(0, {});\n\n                  that._editModel(model);\n\n                  virtualScrollable.scrollToTop();\n                });\n              }\n            },\n            _virtualAddRowAtBottom: function () {\n              var that = this;\n              var dataSource = that.dataSource;\n              var virtualScrollable = that.virtualScrollable;\n              var index = dataSource.total();\n              var model;\n\n              if (dataSource.at(index - 1) instanceof ObservableObject) {\n                model = dataSource.insert(index, {});\n\n                that._virtualPageToBottom(function () {\n                  that._editModel(model);\n\n                  virtualScrollable.scrollToBottom();\n                });\n              } else {\n                that._virtualPageToBottom(function () {\n                  model = dataSource.insert(index, {});\n\n                  that._editModel(model);\n\n                  virtualScrollable.scrollToBottom();\n                });\n              }\n            },\n            _virtualPageToTop: function (callback) {\n              var that = this;\n\n              that._virtualPage(0, that.dataSource.take(), function () {\n                callback();\n              });\n            },\n            _virtualPageToBottom: function (callback) {\n              var that = this;\n              var dataSource = that.dataSource;\n              var take = dataSource.take();\n              var total = dataSource.total();\n              var skip = total > take ? total - take : 0;\n\n              that._virtualPage(skip, take, function () {\n                callback();\n              });\n            },\n            _virtualPage: function (skip, take, callback) {\n              var that = this;\n\n              if (that._isVirtualEditable()) {\n                that.virtualScrollable._preventScroll = true;\n\n                that.virtualScrollable._page(skip, take, callback);\n              }\n            },\n            _firstEditableColumnIndex: function (container) {\n              var that = this,\n                  column,\n                  columns = leafColumns(that.columns),\n                  idx,\n                  length,\n                  model = that._modelForContainer(container);\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                column = columns[idx];\n\n                if (model && (!model.editable || model.editable(column.field)) && !column.command && column.field && column.hidden !== true) {\n                  return idx;\n                }\n              }\n\n              return -1;\n            },\n            _toolbar: function () {\n              var that = this,\n                  wrapper = that.wrapper,\n                  toolbar = that.options.toolbar,\n                  editable = that.options.editable,\n                  container;\n\n              if (toolbar) {\n                container = that.wrapper.find(\".k-grid-toolbar\");\n\n                if (!container.length) {\n                  if (!isFunction(toolbar)) {\n                    toolbar = typeof toolbar === STRING ? toolbar : that._toolbarTmpl(toolbar).replace(templateHashRegExp, \"\\\\#\");\n                    toolbar = kendo.template(toolbar).bind(that);\n                  }\n\n                  container = $('<div class=\"k-toolbar k-grid-toolbar\" />').html(toolbar({})).prependTo(wrapper);\n                  that.angular(\"compile\", function () {\n                    return {\n                      elements: container.get()\n                    };\n                  });\n                }\n\n                if (editable && editable.create !== false) {\n                  container.on(CLICK + NS, \".k-grid-add\", function (e) {\n                    e.preventDefault();\n                    that.addRow();\n                  }).on(CLICK + NS, \".k-grid-cancel-changes\", function (e) {\n                    e.preventDefault();\n                    that.cancelChanges();\n                  }).on(CLICK + NS, \".k-grid-save-changes\", function (e) {\n                    e.preventDefault();\n                    that.saveChanges();\n                  });\n                }\n\n                container.on(CLICK + NS, \".k-grid-excel\", function (e) {\n                  e.preventDefault();\n                  that.saveAsExcel();\n                });\n                container.on(CLICK + NS, \".k-grid-pdf\", function (e) {\n                  e.preventDefault();\n                  var promise = that.saveAsPDF();\n\n                  if (promise) {\n                    promise.done(function () {\n                      that._pdfInitialized = false;\n                    });\n                  }\n                });\n                container.on(INPUT + NS, \".k-grid-search input\", function (e) {\n                  var input = e.currentTarget;\n                  clearTimeout(that._searchTimeOut);\n                  that._searchTimeOut = setTimeout(function () {\n                    that._searchTimeOut = null;\n                    var options = that.options;\n                    var searchFields = options.search ? options.search.fields : null;\n                    var expression = {\n                      filters: [],\n                      logic: \"or\"\n                    };\n                    var value = input.value;\n\n                    if (!searchFields) {\n                      searchFields = getColumnsFields(options.columns);\n                    }\n\n                    if (that.dataSource.options.endless) {\n                      that.dataSource.options.endless = null;\n                      that._endlessPageSize = that.dataSource.options.pageSize;\n                    }\n\n                    if (value) {\n                      for (var i = 0; i < searchFields.length; i++) {\n                        that._pushExpression(expression.filters, searchFields[i], value);\n                      }\n                    } else {\n                      expression = {};\n                    }\n\n                    that.dataSource.filter(expression);\n                  }, 300);\n                });\n              }\n            },\n            _pushExpression: function (filters, field, value) {\n              var that = this,\n                  isServerFiltering = that.dataSource.options.serverFiltering,\n                  defaultOperators = {\n                string: \"contains\",\n                number: \"gte\",\n                date: \"gte\",\n                enums: \"eq\",\n                boolean: \"eq\"\n              },\n                  name = field.name || field,\n                  operator = field.operator,\n                  modelInfo = that.dataSource.reader.model && that.dataSource.reader.model.fields,\n                  fieldInfo = modelInfo && modelInfo[name],\n                  parseFn = fieldInfo && fieldInfo.parse,\n                  expression = {\n                field: name,\n                operator: operator || defaultOperators.string,\n                value: value\n              };\n\n              if ((operator || isServerFiltering) && fieldInfo && kendo.isFunction(parseFn) && parseFn(value) !== null) {\n                extend(expression, {\n                  operator: operator || defaultOperators[fieldInfo.type],\n                  value: parseFn(value)\n                });\n              }\n\n              if (isServerFiltering && fieldInfo && kendo.isFunction(parseFn) && parseFn(value) === null) {\n                return;\n              }\n\n              filters.push(expression);\n            },\n            _toolbarTmpl: function (commands) {\n              var that = this,\n                  idx,\n                  length,\n                  html = \"\",\n                  command,\n                  searchText = \"\",\n                  messages = that.options.messages.commands;\n\n              if (isArray(commands)) {\n                for (idx = 0, length = commands.length; idx < length; idx++) {\n                  command = typeof commands[idx] === 'string' ? commands[idx].toLowerCase() : (commands[idx].name || \"\").toLowerCase();\n\n                  if (command === \"search\") {\n                    if (typeof commands[idx] !== 'string') {\n                      searchText = commands[idx].text;\n                    }\n\n                    searchText = searchText || messages.search;\n                    html += \"<span class='k-spacer'></span>\";\n                    html += \"<span class='k-searchbox k-input k-input-md k-rounded-md k-input-solid k-grid-search'>\";\n                    html += \"<span class='k-input-icon k-icon k-i-search'></span>\";\n                    html += \"<input autocomplete='off' placeholder='\" + searchText + \"' title='\" + searchText + \"' class='k-input-inner' />\";\n                    html += \"</span>\";\n                  } else {\n                    html += that._createButton(commands[idx]);\n                  }\n                }\n              }\n\n              return html;\n            },\n            _createButton: function (command) {\n              var button,\n                  template = command.template || COMMANDBUTTONTMPL,\n                  commandName = typeof command === STRING ? command : command.name || command.text,\n                  className = defaultCommands[commandName] ? defaultCommands[commandName].className : \"k-grid-\" + (commandName || \"\").replace(/\\s/g, \"\"),\n                  options = {\n                className: className,\n                text: commandName,\n                attr: \"\",\n                iconClass: \"\"\n              },\n                  messages = this.options.messages.commands,\n                  attributeClassMatch;\n\n              if (!commandName && !(isPlainObject(command) && command.template)) {\n                throw new Error(\"Custom commands should have name specified\");\n              }\n\n              if (isPlainObject(command)) {\n                command = extend(true, {}, command);\n\n                if (command.className && inArray(options.className, command.className.split(\" \")) < 0) {\n                  command.className += \" \" + options.className;\n                } else if (command.className === undefined) {\n                  command.className = options.className;\n                }\n\n                if (command.className.indexOf(\"k-primary\") > -1) {\n                  command.className = command.className.replace(\"k-primary\", \"\");\n                  command.themeColor = \"primary\";\n                }\n\n                if (commandName === \"edit\") {\n                  command = extend(true, {}, command);\n                  command.text = isPlainObject(command.text) ? command.text.edit : command.text;\n                  command.iconClass = isPlainObject(command.iconClass) ? command.iconClass.edit : command.iconClass;\n                }\n\n                if (command.attr) {\n                  if (isPlainObject(command.attr)) {\n                    command.attr = stringifyAttributes(command.attr);\n                  }\n\n                  if (typeof command.attr === STRING) {\n                    attributeClassMatch = command.attr.match(/class=\"(.+?)\"/);\n\n                    if (attributeClassMatch && inArray(attributeClassMatch[1], command.className.split(\" \")) < 0) {\n                      command.className += \" \" + attributeClassMatch[1];\n                    }\n                  }\n                }\n\n                options = extend(true, options, defaultCommands[commandName], {\n                  text: messages[commandName]\n                }, command);\n              } else {\n                options = extend(true, options, defaultCommands[commandName], {\n                  text: messages[commandName]\n                });\n              }\n\n              button = kendo.template(template)(options);\n\n              if (!command.template) {\n                return kendo.html.renderButton($(button), options);\n              } else {\n                return button;\n              }\n            },\n            _hasFooters: function () {\n              return !!this.footerTemplate || !!this.groupFooterTemplate || this.footer && this.footer.length > 0 || this.wrapper.find(\".k-grid-footer\").length > 0;\n            },\n            _groupable: function () {\n              var that = this;\n\n              if (that._groupableClickHandler) {\n                that.table.add(that.lockedTable).off(CLICK + NS, that._groupableClickHandler);\n              } else {\n                that._groupableClickHandler = function (e) {\n                  var element = $(this),\n                      groupRow = element.closest(\"tr\");\n                  var group = that._groupRows ? that._groupRows[that.wrapper.find(\".k-grouping-row\").index(groupRow)] : {};\n\n                  if (element.hasClass('k-i-collapse')) {\n                    if (!that.trigger(\"groupCollapse\", {\n                      group: group,\n                      element: groupRow\n                    })) {\n                      that.collapseGroup(groupRow);\n                    }\n                  } else {\n                    if (!that.trigger(\"groupExpand\", {\n                      group: group,\n                      element: groupRow\n                    })) {\n                      that.expandGroup(groupRow);\n                    }\n                  }\n\n                  e.preventDefault();\n                  e.stopPropagation();\n                };\n              }\n\n              if (that._isLocked()) {\n                that.lockedTable.on(CLICK + NS, \".k-grouping-row .k-i-expand, .k-grouping-row .k-i-collapse\", that._groupableClickHandler);\n              } else {\n                that.table.on(CLICK + NS, \".k-grouping-row .k-i-expand, .k-grouping-row .k-i-collapse\", that._groupableClickHandler);\n              }\n\n              that._attachGroupable();\n            },\n            _attachGroupable: function () {\n              var that = this,\n                  wrapper = that.wrapper,\n                  groupable = that.options.groupable,\n                  draggables = HEADERCELLS + \"[\" + kendo.attr(\"field\") + \"]\",\n                  filter = that.content ? \".k-grid-header:first \" + draggables : \"table:first>.k-grid-header \" + draggables;\n\n              if (groupable && groupable.enabled !== false) {\n                if (!wrapper.has(\"div.k-grouping-header\")[0]) {\n                  $(\"<div>&nbsp;</div>\").addClass(\"k-grouping-header\").prependTo(wrapper);\n                }\n\n                if (that.groupable) {\n                  that._destroyGroupable();\n                }\n\n                if (browser.chrome) {\n                  wrapper.find(\"div.k-grouping-header\").css(\"touch-action\", \"none\");\n                  wrapper.find(filter).css(\"touch-action\", \"none\");\n                }\n\n                that.groupable = new ui.Groupable(wrapper, extend({}, groupable, {\n                  draggable: that._draggableInstance,\n                  groupContainer: \">div.k-grouping-header\",\n                  dataSource: that.dataSource,\n                  draggableElements: filter,\n                  filter: filter,\n                  allowDrag: that.options.reorderable,\n                  change: function (e) {\n                    if (that.trigger(\"group\", {\n                      groups: e.groups\n                    })) {\n                      e.preventDefault();\n                    } else {\n                      that._clearEditableState();\n\n                      if (that.dataSource.options.endless) {\n                        that._resetEndless();\n                      }\n                    }\n                  }\n                }));\n\n                that._addGroupableOptionsToHeader();\n              }\n            },\n            _resetEndless: function () {\n              var that = this;\n              that.dataSource.options.endless = null;\n              that._endlessPageSize = that.dataSource.options.pageSize;\n              that.dataSource._skip = 0;\n              that.dataSource._pageSize = that.dataSource._take = that._endlessPageSize;\n              that.dataSource._page = 1;\n            },\n            _addGroupableOptionsToHeader: function () {\n              var that = this;\n              var columns = flatColumns(that.columns);\n              var columnFieldMap = {};\n              var field = \"\";\n\n              var headerCells = that._headerCells();\n\n              var cellFieldAttr = \"\";\n              var headerCell;\n              var columnOptions;\n              var i;\n\n              for (i = 0; i < columns.length; i++) {\n                field = columns[i].field;\n                columnFieldMap[columns[i].field] = columns[i];\n              }\n\n              for (i = 0; i < headerCells.length; i++) {\n                headerCell = headerCells.eq(i);\n                cellFieldAttr = headerCell.attr(kendo.attr(FIELD));\n                columnOptions = columnFieldMap[cellFieldAttr];\n\n                if (columnOptions && columnOptions.groupable && columnOptions.groupable.sort) {\n                  headerCell.data(GROUP_SORT, columnOptions.groupable.sort);\n                }\n              }\n            },\n            _destroyGroupable: function () {\n              var that = this;\n\n              if (that.groupable && that.groupable.element) {\n                that.groupable.element.kendoGroupable(\"destroy\");\n              }\n\n              that.groupable = null;\n\n              that._removeGroupableOptionsFromHeader();\n            },\n            _removeGroupableOptionsFromHeader: function () {\n              var that = this;\n\n              var headerCells = that._headerCells();\n\n              for (var i = 0; i < headerCells.length; i++) {\n                headerCells.eq(i).removeData(GROUP_SORT);\n              }\n            },\n            _continuousItems: function (filter, cell) {\n              if (!this.lockedContent) {\n                return;\n              }\n\n              var that = this;\n              var elements = that.table.add(that.lockedTable);\n              var lockedItems = $(filter, elements[0]);\n              var nonLockedItems = $(filter, elements[1]);\n              var columns = cell ? lockedColumns(that.columns).length : 1;\n              var nonLockedColumns = cell ? that.columns.length - columns : 1;\n              var result = [];\n\n              for (var idx = 0; idx < lockedItems.length; idx += columns) {\n                push.apply(result, lockedItems.slice(idx, idx + columns));\n                push.apply(result, nonLockedItems.splice(0, nonLockedColumns));\n              }\n\n              return result;\n            },\n            _selectable: function () {\n              var that = this,\n                  multi,\n                  cell,\n                  notString = [],\n                  isLocked = that._isLocked(),\n                  selectable = that.options.selectable;\n\n              if (selectable) {\n                if (that.selectable) {\n                  that.selectable.destroy();\n                }\n\n                that._selectedIds = {};\n                selectable = kendo.ui.Selectable.parseOptions(selectable);\n                multi = selectable.multiple;\n                cell = selectable.cell;\n\n                if (that._hasDetails()) {\n                  notString[notString.length] = \".k-detail-row\";\n                }\n\n                if (that.options.groupable || that._hasFooters() || that._groups()) {\n                  notString[notString.length] = \".k-grouping-row,.k-group-footer\";\n                }\n\n                notString = notString.join(\",\");\n\n                if (notString !== \"\") {\n                  notString = \":not(\" + notString + \")\";\n                }\n\n                var elements = that.table;\n\n                if (isLocked) {\n                  elements = elements.add(that.lockedTable);\n                }\n\n                var filter = \">\" + (cell ? SELECTION_CELL_SELECTOR : \"tbody>tr\" + notString);\n                that.selectable = new kendo.ui.Selectable(elements, {\n                  filter: filter,\n                  aria: true,\n                  multiple: multi,\n                  dragToSelect: that.options.selectable && that.options.selectable.dragToSelect,\n                  change: function (e) {\n                    var selectedValues;\n\n                    if (!cell) {\n                      that._persistSelectedRows();\n                    }\n\n                    if (that._checkBoxSelection) {\n                      selectedValues = that.selectable.value();\n\n                      that._uncheckCheckBoxes();\n\n                      that._checkRows(selectedValues);\n\n                      if (selectedValues.length && selectedValues.length === that.items().length) {\n                        that._toggleHeaderCheckState(true);\n                      } else {\n                        that._toggleHeaderCheckState(false);\n                      }\n                    }\n\n                    if (e.event) {\n                      that.trigger(CHANGE);\n                    }\n                  },\n                  useAllItems: isLocked && multi && cell,\n                  relatedTarget: function (items) {\n                    if (cell || !isLocked) {\n                      return;\n                    }\n\n                    var related;\n                    var result = $();\n\n                    for (var idx = 0, length = items.length; idx < length; idx++) {\n                      related = that._relatedRow(items[idx]);\n\n                      if (inArray(related[0], items) < 0) {\n                        result = result.add(related);\n                      }\n                    }\n\n                    return result;\n                  },\n                  continuousItems: function () {\n                    return that._continuousItems(filter, cell);\n                  },\n                  ignoreOverlapped: that.options.selectable && that.options.selectable.ignoreOverlapped,\n                  addIdToRanges: true\n                });\n\n                if (that.options.navigatable) {\n                  elements.on(\"keydown\" + NS, function (e) {\n                    var current = that.current();\n                    var target = e.target;\n                    var eventObject = {\n                      event: e\n                    };\n\n                    if (!current) {\n                      return;\n                    }\n\n                    if (e.keyCode === keys.SPACEBAR && !e.shiftKey && $.inArray(target, elements) > -1 && !current.is(\".k-edit-cell,.k-header\") && current.parent().is(\":not(.k-grouping-row,.k-detail-row,.k-group-footer)\")) {\n                      e.preventDefault();\n                      e.stopPropagation();\n                      current = cell ? current : current.parent();\n\n                      if (isLocked && !cell) {\n                        current = current.add(that._relatedRow(current));\n                      }\n\n                      if (multi) {\n                        if (!e.ctrlKey) {\n                          that.selectable.clear();\n                        } else {\n                          if (current.hasClass(SELECTED)) {\n                            that._deselectCheckRows(current);\n\n                            return;\n                          }\n                        }\n                      } else {\n                        that.selectable.clear();\n                      }\n\n                      if (!cell) {\n                        that.selectable._lastActive = current;\n                      }\n\n                      that.selectable.value(current, eventObject);\n                    } else if (!cell && ($(target).is(\"td\") || $(target).is(\"table\") && inArray(target, this._navigatableTables)) && (e.shiftKey && e.keyCode == keys.LEFT || e.shiftKey && e.keyCode == keys.RIGHT || e.shiftKey && e.keyCode == keys.UP || e.shiftKey && e.keyCode == keys.DOWN || e.keyCode === keys.SPACEBAR && e.shiftKey)) {\n                      e.preventDefault();\n                      e.stopPropagation();\n                      current = current.parent();\n\n                      if (isLocked) {\n                        current = current.add(that._relatedRow(current));\n                      }\n\n                      if (multi) {\n                        if (!that.selectable._lastActive) {\n                          that.selectable._lastActive = current;\n                        }\n\n                        that.selectable.selectRange(that.selectable._firstSelectee(), current, eventObject);\n                      } else {\n                        that.selectable.clear();\n                        that.selectable.value(current, eventObject);\n                      }\n                    }\n                  });\n                }\n              }\n            },\n            _clipboard: function () {\n              var options = this.options;\n              var selectable = options.selectable;\n\n              if (selectable && options.allowCopy) {\n                var grid = this;\n\n                if (!options.navigatable) {\n                  grid.table.add(grid.lockedTable).attr(\"tabindex\", 0).on(\"mousedown\" + NS + \" keydown\" + NS, \".k-detail-cell\", function (e) {\n                    if (e.target !== e.currentTarget) {\n                      e.stopImmediatePropagation();\n                    }\n                  }).on(\"mousedown\" + NS, NAVROW + \">\" + NAVCELL, tableClick.bind(grid));\n                }\n\n                grid.copyHandler = grid.copySelection.bind(grid);\n\n                grid.updateClipBoardState = function () {\n                  if (grid.areaClipBoard) {\n                    grid.areaClipBoard.val(grid.getTSV()).trigger(\"focus\").select();\n                  }\n                };\n\n                grid.bind(\"change\", grid.updateClipBoardState);\n                grid.wrapper.on(\"keydown\", grid.copyHandler);\n                grid.clearAreaHandler = grid.clearArea.bind(grid);\n                grid.wrapper.on(\"keyup\", grid.clearAreaHandler);\n              }\n            },\n            copySelectionToClipboard: function (includeHeaders) {\n              this._createAreaClipBoard();\n\n              this.areaClipBoard.val(this.getTSV(includeHeaders)).trigger(\"focus\").select();\n              document.execCommand('copy');\n            },\n            copySelection: function (e) {\n              if (e instanceof jQuery.Event && !(e.ctrlKey || e.metaKey) || $(e.target).is(\"input:visible,textarea:visible\") || window.getSelection && window.getSelection().toString() || document.selection && document.selection.createRange().text) {\n                return;\n              }\n\n              this._createAreaClipBoard();\n\n              this.areaClipBoard.val(this.getTSV()).trigger(\"focus\").select();\n            },\n            _createAreaClipBoard: function () {\n              if (!this.areaClipBoard) {\n                this.areaClipBoard = $(\"<textarea />\").css({\n                  position: \"fixed\",\n                  top: \"50%\",\n                  left: \"50%\",\n                  opacity: 0,\n                  width: 0,\n                  height: 0\n                }).appendTo(this.wrapper);\n              }\n            },\n            getTSV: function (includeHeaders) {\n              var grid = this;\n              var selected = grid.select();\n              var delimeter = \"\\t\";\n              var allowCopy = grid.options.allowCopy;\n              var onlyVisible = true;\n              var hasLockedCols = grid._isLocked() && lockedColumns(grid.columns).length;\n\n              if ($.isPlainObject(allowCopy) && allowCopy.delimeter) {\n                delimeter = allowCopy.delimeter;\n              }\n\n              var text = \"\";\n\n              if (selected.length) {\n                if (selected.eq(0).is(\"tr\")) {\n                  selected = selected.find(\"td:not(.k-group-cell)\");\n                }\n\n                if (onlyVisible) {\n                  selected.filter(\":visible\");\n                }\n\n                var result = [];\n                var cellsOffset = this.columns.length;\n                var lockedCols = grid._isLocked() && lockedColumns(grid.columns).length;\n                var inLockedArea = true;\n                var fields = [];\n                var field;\n                var columns = visibleLeafColumns(this.columns);\n                $.each(selected, function (idx, cell) {\n                  cell = $(cell);\n                  field = grid._getCellField(cell, hasLockedCols);\n                  var tr = cell.closest(\"tr\");\n                  var rowIndex = tr.index();\n                  var cellIndex = cell.index();\n\n                  if (onlyVisible) {\n                    cellIndex -= cell.prevAll(\":hidden\").length;\n                  }\n\n                  if (lockedCols && inLockedArea) {\n                    inLockedArea = $.contains(grid.lockedTable[0], cell[0]);\n                  }\n\n                  if (grid._groups() && inLockedArea) {\n                    cellIndex -= grid._groups();\n                  }\n\n                  cellIndex = inLockedArea ? cellIndex : cellIndex + lockedCols;\n\n                  if (field) {\n                    fields[cellIndex] = field;\n                  }\n\n                  if (cellsOffset > cellIndex) {\n                    cellsOffset = cellIndex;\n                  }\n\n                  var cellText = cell.text();\n\n                  if (!result[rowIndex]) {\n                    result[rowIndex] = [];\n                  }\n\n                  result[rowIndex][cellIndex] = cellText;\n                });\n                var rowsOffset = result.length;\n                result = $.each(result, function (idx, val) {\n                  if (val) {\n                    result[idx] = val.slice(cellsOffset);\n\n                    if (rowsOffset > idx) {\n                      rowsOffset = idx;\n                    }\n                  }\n                });\n\n                if (includeHeaders && fields.length) {\n                  result.splice(rowsOffset, 0, fields.map(function (field) {\n                    return getTitle(field, columns);\n                  }));\n                  var headerIndex = result.findIndex(function (el) {\n                    return el !== undefined;\n                  });\n                  result[headerIndex] = result[headerIndex].slice(cellsOffset);\n                }\n\n                $.each(result.slice(rowsOffset), function (idx, val) {\n                  if (val) {\n                    text += val.join(delimeter) + \"\\r\\n\";\n                  } else {\n                    text += \"\\r\\n\";\n                  }\n                });\n              }\n\n              return text;\n            },\n            clearArea: function (e) {\n              var table;\n\n              if (this.areaClipBoard && e && e.target === this.areaClipBoard[0]) {\n                if (this.options.navigatable) {\n                  table = $(this.current()).closest(\"table\");\n                } else {\n                  table = this.table;\n                }\n\n                focusTable(table, true);\n              }\n\n              if (this.areaClipBoard) {\n                this.areaClipBoard.remove();\n                this.areaClipBoard = null;\n              }\n            },\n            _adaptiveColumns: function () {\n              var that = this;\n\n              if (that._anyColumnHasMediaQuery()) {\n                that._setColumnsMediaVisibility(that.columns);\n\n                that._attachColumnMediaResizeHandler();\n              }\n            },\n            _anyColumnHasMediaQuery: function () {\n              return this._columnsWithMediaQuery().length;\n            },\n            _columnsWithMediaQuery: function () {\n              return columnsWithMedia(this.columns);\n            },\n            _attachColumnMediaResizeHandler: function () {\n              var that = this;\n\n              that._detachColumnMediaResizeHandler();\n\n              that._columnMediaResizeHandler = that._onColumnMediaResize.bind(that);\n              $(window).on(RESIZE + NS, that._columnMediaResizeHandler);\n            },\n            _detachColumnMediaResizeHandler: function () {\n              var that = this;\n\n              if (that._columnMediaResizeHandler) {\n                $(window).off(RESIZE + NS, that._columnMediaResizeHandler);\n              }\n            },\n            _onColumnMediaResize: function () {\n              var that = this;\n\n              that._setColumnsMediaVisibility(that.columns);\n\n              that._setContentMediaWidth();\n            },\n            _setColumnsMediaVisibility: function (columns) {\n              var cols = columns || [];\n\n              for (var i = 0; i < cols.length; i++) {\n                this._setColumnMediaVisibility(cols[i]);\n              }\n            },\n            _setColumnMediaVisibility: function (column) {\n              var that = this;\n\n              if (isUndefined(column.media)) {\n                that._setColumnsMediaVisibility(column.columns);\n              } else {\n                if (columnMatchesMedia(column)) {\n                  that._showColumnByMedia(column);\n\n                  if (!column.hidden) {\n                    that._setColumnsMediaVisibility(column.columns);\n                  }\n                } else {\n                  that._hideColumnByMedia(column);\n                }\n              }\n            },\n            _showColumnByMedia: function (column) {\n              if (!column.hidden) {\n                // \"hidden\" has a priority over \"matchesMedia\"\n                this.showColumn(column);\n              }\n\n              setColumnMatchesMedia(column);\n            },\n            _hideColumnByMedia: function (column) {\n              var initiallyHidden = column.hidden;\n\n              if (!initiallyHidden) {\n                column._hideByMedia = true;\n                this.hideColumn(column);\n                column._hideByMedia = false; // hiding is tracked in \"matchesMedia\" instead of \"hidden\" flag\n\n                column.hidden = initiallyHidden;\n              }\n\n              setColumnMatchesMedia(column);\n            },\n            _setContentMediaWidth: function () {\n              var that = this;\n              var options = that.options;\n\n              var isLocked = that._isLocked();\n\n              var footer;\n\n              if (options.scrollable && options.resizable) {\n                if (isLocked && that.lockedFooter) {\n                  footer = that.lockedFooter.children(\"table\");\n                } else if (that.footer) {\n                  footer = that.footer.find(\">.k-grid-footer-wrap>table\");\n                }\n\n                if (!footer || !footer[0]) {\n                  footer = $();\n                }\n\n                var header = isLocked ? that.wrapper.find(\".k-grid-header-locked\").find(\"table\") : that.wrapper.find(\".k-grid-header\").find(\"table\");\n                var contentTable = isLocked ? that.lockedTable : that.table;\n                var headerColumns = header.find(\"th\");\n                var headerColgroup = header.find(\"colgroup\");\n                var headerColumnsCount = headerColumns.length;\n                var visibleHeaderColumnsCount = headerColumns.filter(isCellVisible).length;\n                var hiddenHeaderColumnsCount = headerColumns.length - visibleHeaderColumnsCount;\n                var totalHeaderWidth = 0;\n\n                if (header[0].style.width !== \"\" && parseFloat(header[0].style.width) !== totalHeaderWidth) {\n                  var currentHeaderWidth = header.css(\"width\");\n\n                  for (var i = 0; i < headerColumnsCount; i++) {\n                    if (isElementVisible(headerColumns[i])) {\n                      var columnWidth;\n                      var cellIndex = Math.max(i, i - hiddenHeaderColumnsCount);\n                      var colgroupChild = headerColgroup.children()[cellIndex];\n                      var columnStyleWidth = colgroupChild ? colgroupChild.style.width : \"\";\n\n                      if (columnStyleWidth !== \"\") {\n                        columnWidth = parseFloat(columnStyleWidth);\n                      } else {\n                        // remove the header width to calculate the height of a column without fixed width\n                        header.css(\"width\", \"auto\");\n                        columnWidth = outerWidth(headerColumns.eq(i));\n                        header.css(\"width\", currentHeaderWidth);\n                      }\n\n                      totalHeaderWidth += columnWidth;\n                    }\n                  }\n\n                  contentTable.css('width', totalHeaderWidth - 1); // subtract 1 to remove the horizontal scroll\n\n                  header.css('width', totalHeaderWidth);\n                  footer.css('width', totalHeaderWidth);\n\n                  that._updateStickyColumns();\n                }\n              }\n            },\n            _minScreenSupport: function () {\n              var any = this.hideMinScreenCols();\n\n              if (any) {\n                this.minScreenResizeHandler = this.hideMinScreenCols.bind(this);\n                $(window).on(\"resize\", this.minScreenResizeHandler);\n              }\n            },\n            hideMinScreenCols: function () {\n              var cols = this.columns,\n                  screenWidth = window.innerWidth > 0 ? window.innerWidth : screen.width;\n              return this._iterateMinScreenCols(cols, screenWidth);\n            },\n            _iterateMinScreenCols: function (cols, screenWidth) {\n              var any = false;\n\n              for (var i = 0; i < cols.length; i++) {\n                var col = cols[i];\n                var minWidth = col.minScreenWidth;\n\n                if (minWidth !== undefined && minWidth !== null) {\n                  any = true;\n\n                  if (minWidth > screenWidth) {\n                    this.hideColumn(col);\n                  } else {\n                    this.showColumn(col);\n                  }\n                }\n\n                if (!col.hidden && col.columns) {\n                  any = this._iterateMinScreenCols(col.columns, screenWidth) || any;\n                }\n              }\n\n              return any;\n            },\n            _stickyColumns: function () {\n              var that = this;\n\n              if (that._anyStickyColumns()) {\n                that._setStickyColumns(false);\n              }\n            },\n            _updateStickyColumns: function () {\n              var that = this;\n              var groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function (column) {\n                return column.groupHeaderColumnTemplate;\n              });\n\n              if (that._anyStickyColumns()) {\n                that._setStickyColumns(true);\n\n                that._templates();\n\n                if (groupHeaderColumnTemplateColumns.length > 0) {\n                  that._renderGroupRows();\n                }\n\n                if (that._hasFilterRow()) {\n                  that._updateStickyFilterCells();\n                }\n              }\n            },\n            _updateStickyFilterCells: function () {\n              var that = this;\n              var filterCells = that.thead.find(\".k-filter-row\").find(\"th:not(.k-group-cell,.k-hierarchy-cell)\");\n\n              if (filterCells.length) {\n                filterCells.each(function () {\n                  var th = $(this);\n                  var column = th.data(\"column\");\n                  var style = th.attr(\"style\") || \"\";\n\n                  if (column.sticky) {\n                    th.attr(\"style\", style + column.stickyStyle);\n                    th.addClass(STICKY_HEADER_CLASS);\n                  } else {\n                    style = style.replace(leftRegExp, \"\");\n                    style = style.replace(rightRegExp, \"\");\n                    th.attr(\"style\", style);\n                    th.removeClass(STICKY_HEADER_CLASS);\n                  }\n                });\n              }\n            },\n            _anyStickyColumns: function () {\n              var that = this;\n              return stickyColumns(that.columns).length;\n            },\n            _setStickyColumns: function (updateStyles) {\n              var that = this;\n              var columns = stickyColumns(that.columns);\n              var visibleColumns = visibleStickyColumns(that.columns);\n\n              var stickyWidths = that._calculateStickyWidths(visibleColumns);\n\n              that._removeStickyAttributes(columns);\n\n              that._setStickyClassAttributes(columns);\n\n              that._setStickyStyleAttributes(visibleColumns, stickyWidths, updateStyles);\n\n              if (updateStyles) {\n                that._setStickyStyles(visibleColumns, stickyWidths);\n              }\n            },\n            _calculateStickyWidths: function (columns, initialLeftWidth, initialRightWidth) {\n              var that = this;\n              var i;\n              var column;\n              var columnWidth;\n              var nextColumnLeft;\n              var nextColumnRight;\n              var left = isRtl ? \"right\" : \"left\";\n              var right = isRtl ? \"left\" : \"right\";\n              var stickyWidths = {\n                left: new Array(columns.length).fill(initialLeftWidth ? initialLeftWidth : 0),\n                right: new Array(columns.length).fill(initialRightWidth ? initialRightWidth : 0)\n              };\n\n              for (i = 0; i < columns.length - 1; i++) {\n                column = columns[i];\n                columnWidth = that._sumColumnWidth(column);\n                nextColumnLeft = columnWidth + stickyWidths[left][i];\n                stickyWidths[left][i + 1] = nextColumnLeft;\n              }\n\n              for (i = columns.length - 1; i > 0; i--) {\n                column = columns[i];\n                columnWidth = that._sumColumnWidth(column);\n                nextColumnRight = columnWidth + stickyWidths[right][i];\n                stickyWidths[right][i - 1] = nextColumnRight;\n              }\n\n              return stickyWidths;\n            },\n            _setStickyClassAttributes: function (columns, masterIndex) {\n              var that = this;\n              var i;\n              var column;\n\n              for (i = 0; i < columns.length; i++) {\n                column = columns[i];\n\n                if (column.columns) {\n                  if (!masterIndex && i) {\n                    masterIndex = i;\n                  }\n\n                  that._setStickyClassAttributes(childColumns([column]), masterIndex);\n                }\n\n                if (masterIndex) {\n                  addColumnAttribute(column, \"headerAttributes\", \"class\", STICKY_HEADER_NO_BORDER_CLASS);\n                }\n\n                addColumnAttribute(column, \"attributes\", \"class\", STICKY_CELL_CLASS);\n                addColumnAttribute(column, \"headerAttributes\", \"class\", STICKY_HEADER_CLASS);\n                addColumnAttribute(column, \"footerAttributes\", \"class\", STICKY_FOOTER_CLASS);\n              }\n            },\n            _setStickyStyleAttributes: function (columns, stickyWidths, updateStyles) {\n              var that = this;\n              var i;\n              var column;\n              var stickyLeft;\n              var stickyRight;\n              var stickyStyle;\n              var childCols;\n              var childStickyWidths;\n\n              for (i = 0; i < columns.length; i++) {\n                column = columns[i];\n                stickyLeft = stickyWidths.left[i];\n                stickyRight = stickyWidths.right[i];\n                stickyStyle = \"left: \" + stickyLeft + \"px; right: \" + stickyRight + \"px;\";\n\n                if (column.columns) {\n                  childCols = visibleChildColumns([column]);\n                  childStickyWidths = that._calculateStickyWidths(childCols, stickyLeft, stickyRight);\n\n                  that._setStickyStyleAttributes(childCols, childStickyWidths, updateStyles);\n\n                  if (updateStyles) {\n                    that._setStickyStyles(childCols, childStickyWidths);\n                  }\n                }\n\n                addColumnAttribute(column, \"attributes\", \"style\", stickyStyle);\n                addColumnAttribute(column, \"headerAttributes\", \"style\", stickyStyle);\n                addColumnAttribute(column, \"footerAttributes\", \"style\", stickyStyle);\n                column.stickyStyle = stickyStyle;\n              }\n            },\n            _removeStickyAttributes: function (columns) {\n              var that = this;\n              var i;\n              var cellClassRegExp = new RegExp(\"(\\\\s*\" + STICKY_CELL_CLASS + \")*\", \"ig\");\n              var headerClassRegExp = new RegExp(\"(\\\\s*\" + STICKY_HEADER_CLASS + \")*\", \"ig\");\n              var footerClassRegExp = new RegExp(\"(\\\\s*\" + STICKY_FOOTER_CLASS + \")*\", \"ig\");\n              var headerClassNoBorderRegExp = new RegExp(\"(\\\\s*\" + STICKY_HEADER_NO_BORDER_CLASS + \")*\", \"ig\");\n              var column;\n\n              for (i = 0; i < columns.length; i++) {\n                column = columns[i];\n\n                if (column.columns) {\n                  that._removeStickyAttributes(childColumns([column]));\n                }\n\n                removeColumnAttribute(column, \"attributes\", \"class\", cellClassRegExp);\n                removeColumnAttribute(column, \"attributes\", \"style\", leftRegExp);\n                removeColumnAttribute(column, \"attributes\", \"style\", rightRegExp);\n                removeColumnAttribute(column, \"headerAttributes\", \"class\", headerClassRegExp);\n                removeColumnAttribute(column, \"headerAttributes\", \"class\", headerClassNoBorderRegExp);\n                removeColumnAttribute(column, \"headerAttributes\", \"style\", leftRegExp);\n                removeColumnAttribute(column, \"headerAttributes\", \"style\", rightRegExp);\n                removeColumnAttribute(column, \"footerAttributes\", \"class\", footerClassRegExp);\n                removeColumnAttribute(column, \"footerAttributes\", \"style\", leftRegExp);\n                removeColumnAttribute(column, \"footerAttributes\", \"style\", rightRegExp);\n              }\n            },\n            _setStickyStyles: function (columns, stickyWidths) {\n              var that = this;\n              var i;\n              var j;\n              var leafsCols = leafColumns(nonLockedColumns(that.columns));\n              var rows = that.tbody.children(\":not(.k-detail-row)\");\n              var row;\n              var column;\n              var columnIndex;\n              var left;\n              var right;\n              var header;\n              var footer;\n              var groupHeader;\n              var cell;\n\n              for (i = 0; i < columns.length; i++) {\n                column = columns[i];\n                left = stickyWidths.left[i];\n                right = stickyWidths.right[i];\n                columnIndex = leafsCols.indexOf(column);\n                header = that._getColumnHeader(column);\n                header.addClass(STICKY_HEADER_CLASS);\n\n                if (column.headerAttributes[\"class\"] && column.headerAttributes[\"class\"].indexOf(STICKY_HEADER_NO_BORDER_CLASS) !== -1) {\n                  header.addClass(STICKY_HEADER_NO_BORDER_CLASS);\n                }\n\n                setLeftAndRightStyles(header, left, right);\n\n                if (column.columns) {\n                  continue;\n                }\n\n                if (that.footer) {\n                  footer = that.footer.find(\".k-grid-footer-wrap tr.k-footer-template\").children().filter(\":not(.k-group-cell,.k-hierarchy-cell)\").eq(columnIndex);\n                  footer.addClass(STICKY_FOOTER_CLASS);\n                  setLeftAndRightStyles(footer, left, right);\n                }\n\n                for (j = 0; j < rows.length; j++) {\n                  row = $(rows[j]);\n\n                  if (row.hasClass(\"k-grouping-row\")) {\n                    groupHeader = row.find(\".\" + column.groupHeaderColumnTemplateClass);\n                    groupHeader.addClass(STICKY_CELL_CLASS);\n                    setLeftAndRightStyles(groupHeader, left, right);\n                  } else {\n                    cell = row.children().filter(\":not(.k-group-cell,.k-hierarchy-cell)\").eq(columnIndex);\n                    cell.addClass(STICKY_CELL_CLASS);\n                    setLeftAndRightStyles(cell, left, right);\n                  }\n                }\n              }\n            },\n            _removeStickyStyles: function (columns) {\n              var that = this;\n              var i;\n              var j;\n              var leafsCols = leafColumns(nonLockedColumns(that.columns));\n              var rows = that.tbody.children(\":not(.k-detail-row)\");\n              var row;\n              var column;\n              var columnIndex;\n              var header;\n              var footer;\n              var groupHeader;\n              var cell;\n\n              for (i = 0; i < columns.length; i++) {\n                column = columns[i];\n                columnIndex = leafsCols.indexOf(column);\n                header = that._getColumnHeader(column);\n                header.removeClass(STICKY_HEADER_CLASS);\n                header.removeClass(STICKY_HEADER_NO_BORDER_CLASS);\n                setLeftAndRightStyles(header, \"\", \"\");\n\n                if (column.columns) {\n                  that._removeStickyStyles(column.columns);\n\n                  continue;\n                }\n\n                if (column.footerTemplate && that.footer) {\n                  footer = that.footer.find(\".k-grid-footer-wrap tr.k-footer-template\").children().filter(\":not(.k-group-cell,.k-hierarchy-cell)\").eq(columnIndex);\n                  footer.removeClass(STICKY_FOOTER_CLASS);\n                  setLeftAndRightStyles(footer, \"\", \"\");\n                }\n\n                for (j = 0; j < rows.length; j++) {\n                  row = $(rows[j]);\n\n                  if (row.hasClass(\"k-grouping-row\")) {\n                    groupHeader = row.find(\".\" + column.groupHeaderColumnTemplateClass);\n                    groupHeader.removeClass(STICKY_CELL_CLASS);\n                    setLeftAndRightStyles(groupHeader, \"\", \"\");\n                  } else {\n                    cell = row.children().filter(\":not(.k-group-cell,.k-hierarchy-cell)\").eq(columnIndex);\n                    cell.removeClass(STICKY_CELL_CLASS);\n                    setLeftAndRightStyles(cell, \"\", \"\");\n                  }\n                }\n              }\n            },\n            _getColumnHeader: function (column) {\n              var that = this;\n              var header = $(\"#\" + column.headerAttributes.id).length ? $(\"#\" + column.headerAttributes.id) : $(\"#\" + that._cellId);\n              return header;\n            },\n            _sumColumnWidth: function (column) {\n              var that = this;\n              var width = 0;\n\n              if (column.columns) {\n                width = that._sumCurrentWidths(leafColumns([column]));\n              } else {\n                width = that._sumCurrentWidths([column]);\n              }\n\n              return width;\n            },\n            _sumCurrentWidths: function (cols) {\n              var that = this;\n              var width = 0;\n              var colWidth = 0;\n              var col;\n              var header;\n              var i;\n              var length = cols.length;\n\n              for (i = 0; i < length; i++) {\n                col = cols[i];\n                header = that._getColumnHeader(col);\n\n                if (!col.hidden && columnMatchesMedia(col)) {\n                  colWidth = header.is(\":visible\") ? header.outerWidth() : col.width;\n                  width += colWidth ? parseInt(colWidth, 10) : 0;\n                }\n              }\n\n              return width;\n            },\n            _belongsToGrid: function (element) {\n              return this.wrapper[0] === element.closest(WRAPPER)[0];\n            },\n            getSelectedData: function () {\n              var that = this;\n              var selectedRanges = that.selectable.selectedRanges();\n              var selectedRangeNames = Object.keys(selectedRanges);\n              var selectedSingleItems = that.selectable.selectedSingleItems();\n              var result = [];\n              var visibleColumns = visibleLeafColumns(that.columns);\n\n              for (var idx = 0; idx < selectedRangeNames.length; idx++) {\n                result = result.concat(that._mapSelectionToData(selectedRanges[selectedRangeNames[idx]], visibleColumns));\n              }\n\n              if (selectedSingleItems.length) {\n                result = result.concat(that._mapSelectionToData(selectedSingleItems, visibleColumns));\n              }\n\n              return result;\n            },\n            exportSelectedToExcel: function (includeHeaders) {\n              if (!kendo.excel || !kendo.ooxml) {\n                throw new Error(\"The excel export functionality depends on both kendo.excel.js and kendo.ooxml.js scripts, please make sure they are included.\");\n              }\n\n              var that = this;\n              var excel = this.options.excel || {};\n              var visibleColumns = visibleLeafColumns(that.columns);\n              var exporter = new kendo.excel.ExcelExporter({});\n\n              var columnHandler = function () {\n                return {\n                  autoWidth: true\n                };\n              };\n\n              var book = {\n                sheets: [{\n                  columns: Array.apply(0, Array(visibleColumns.length)).map(columnHandler),\n                  rows: [],\n                  freezePane: {},\n                  filter: false\n                }]\n              };\n              var selectedRanges = that.selectable.selectedRanges();\n              var selectedRangeNames = Object.keys(selectedRanges);\n              var selectedSingleItems = that.selectable.selectedSingleItems();\n              var idx;\n              var exportData = [];\n              var hasLockedCols = that._isLocked() && lockedColumns(that.columns).length;\n              var sortHandler = exportDataSort.bind(that);\n\n              for (idx = 0; idx < selectedRangeNames.length; idx++) {\n                exportData = exportData.concat(that._mapSelectionToData(selectedRanges[selectedRangeNames[idx]], visibleColumns, isExcelExportableColumn));\n              }\n\n              if (exportData.length) {\n                that._addRangeSelectionRows(book, exporter, exportData, includeHeaders);\n              }\n\n              exportData = selectedSingleItems.length ? that._mapSelectionToData(selectedSingleItems, visibleColumns, isExcelExportableColumn) : [];\n\n              if (exportData.length) {\n                if (hasLockedCols) {\n                  exportData = exportData.sort(sortHandler);\n                }\n\n                that._addSingleSelectionRows(book, exporter, exportData, includeHeaders);\n              }\n\n              if (book.sheets[0].rows.length) {\n                var workbook = new kendo.ooxml.Workbook(book);\n\n                if (!workbook.options) {\n                  workbook.options = {};\n                }\n\n                workbook.options.skipCustomHeight = true;\n                workbook.toDataURLAsync().then(function (dataURI) {\n                  kendo.saveAs({\n                    dataURI: dataURI,\n                    fileName: book.fileName || excel.fileName,\n                    proxyURL: excel.proxyURL,\n                    forceProxy: excel.forceProxy\n                  });\n                });\n              }\n            },\n            _addSingleSelectionRows: function (book, exporter, data, includeHeaders) {\n              var idx = 0;\n              var visibleColumns = visibleLeafColumns(this.columns);\n              var item;\n\n              for (idx = 0; idx < data.length; idx++) {\n                item = data[idx];\n                exporter.data = [item];\n\n                this._setExporterColumns(exporter, visibleColumns, item);\n\n                this._createExportRows(book, exporter, includeHeaders);\n              }\n            },\n            _addRangeSelectionRows: function (book, exporter, data, includeHeaders) {\n              var visibleColumns = visibleLeafColumns(this.columns);\n              exporter.data = data;\n\n              this._setExporterColumns(exporter, visibleColumns, data[0]);\n\n              this._createExportRows(book, exporter, includeHeaders);\n            },\n            _createExportRows: function (book, exporter, includeHeaders) {\n              book.sheets[0].rows = book.sheets[0].rows.concat(includeHeaders ? exporter._rows() : exporter._dataRows(exporter.data, 0));\n            },\n            _setExporterColumns: function (exporter, columns, item) {\n              exporter.columns = exporter.options.columns = $.map(columns.filter(function (col) {\n                return Object.keys(item).indexOf(col.field) >= 0;\n              }), exporter._prepareColumn);\n            },\n            _mapSelectionToData: function (elements, visibleColumns, columnsFilter) {\n              var that = this;\n              var elementType = elements[0][0].nodeName;\n              var isRowSelection = elementType === 'TR';\n              var dataItem;\n              var result = {};\n              var element;\n              var curr;\n              var field;\n\n              var columnMapHandler = function (col) {\n                var result = {};\n\n                if (!col.field || columnsFilter && !columnsFilter(col)) {\n                  return;\n                }\n\n                result[col.field] = dataItem[col.field];\n                return result;\n              };\n\n              var hasLockedCols = that._isLocked() && lockedColumns(that.columns).length;\n              var column;\n\n              for (var i = 0; i < elements.length; i++) {\n                element = elements[i];\n                dataItem = that.dataItem(isRowSelection ? element : element.parent());\n\n                if (isRowSelection) {\n                  result[dataItem.uid] = $.extend.apply(null, visibleColumns.map(columnMapHandler));\n                } else {\n                  field = that._getCellField(element, hasLockedCols);\n\n                  if (!field) {\n                    continue;\n                  }\n\n                  curr = result[dataItem.uid];\n\n                  if (!curr) {\n                    curr = result[dataItem.uid] = {};\n                  }\n\n                  column = findColumnByField(visibleColumns, field);\n\n                  if (!column || columnsFilter && !columnsFilter(column)) {\n                    continue;\n                  }\n\n                  curr[field] = dataItem[field];\n                }\n              }\n\n              return Object.keys(result).map(function (id) {\n                result[id].uid = id;\n                return result[id];\n              });\n            },\n            _getCellField: function (cell, hasLockedCols) {\n              var grid = this;\n              var inLockedArea = hasLockedCols && $.contains(grid.lockedTable[0], cell[0]);\n              var fieldAttr = kendo.attr('field');\n\n              if (hasLockedCols) {\n                return grid.element.find(\".k-grid-header-\" + (inLockedArea ? \"locked\" : \"wrap\") + \" th\").eq(cell.index()).attr(fieldAttr);\n              } else {\n                return grid.thead.find(\"th\").eq(cell.index()).attr(fieldAttr);\n              }\n            },\n            _relatedRow: function (row) {\n              var lockedTable = this.lockedTable;\n              row = $(row);\n\n              if (!lockedTable) {\n                return row;\n              }\n\n              var table = row.closest(this.table.add(this.lockedTable));\n              var index = table.find(\">tbody>tr\").index(row);\n              table = table[0] === this.table[0] ? lockedTable : this.table;\n              return table.find(\">tbody>tr\").eq(index);\n            },\n            _relatedCell: function (cell) {\n              var lockedTable = this.lockedTable;\n              cell = $(cell);\n\n              if (!lockedTable) {\n                return cell;\n              }\n\n              var table = cell.closest(this.table.add(this.lockedTable));\n              var index = table.find(\">tbody>tr>td\").index(cell);\n              table = table[0] === this.table[0] ? lockedTable : this.table;\n              return table.find(\">tbody>tr>td\").index(index);\n            },\n            clearSelection: function () {\n              var that = this;\n\n              if (that.selectable && !that._checkBoxSelection) {\n                that.selectable.clear();\n              }\n\n              if (that._checkBoxSelection) {\n                that._deselectCheckRows(that.select());\n\n                return;\n              }\n\n              if (that.options.persistSelection) {\n                that._persistSelectedRows();\n              } else {\n                that._selectedIds = {};\n              }\n            },\n            select: function (items) {\n              var that = this,\n                  selectable = that.selectable,\n                  selectableoptions = kendo.ui.Selectable.parseOptions(this.options.selectable),\n                  cell = selectableoptions.cell;\n              items = that.table.add(that.lockedTable).find(items);\n\n              if (items.length) {\n                if (selectable && !selectable.options.multiple) {\n                  selectable.clear();\n                  items = items.first();\n                }\n\n                if (that._isLocked()) {\n                  items = items.add(items.map(function () {\n                    if (cell) {\n                      return that._relatedCell(this);\n                    } else {\n                      return that._relatedRow(this);\n                    }\n                  }));\n                }\n\n                if (selectable && !that._checkBoxSelection) {\n                  selectable.value(items);\n                } else {\n                  that._checkRows(items);\n\n                  if (that.select().length === that.items().length) {\n                    that._toggleHeaderCheckState(true);\n                  }\n\n                  if (!cell) {\n                    that._persistSelectedRows();\n                  }\n\n                  that.trigger(CHANGE);\n                }\n\n                return;\n              }\n\n              return selectable ? selectable.value() : that.items().filter(\".\" + SELECTED);\n            },\n            _toggleHeaderCheckState: function (checked) {\n              var that = this;\n\n              if (checked) {\n                that.thead.add(that.lockedHeader).find(\"tr \" + CHECKBOXINPUT).prop(\"checked\", true).attr(\"aria-checked\", true).attr(\"aria-label\", \"Deselect all rows\");\n              } else {\n                that.thead.add(that.lockedHeader).find(\"tr \" + CHECKBOXINPUT).prop(\"checked\", false).attr(\"aria-checked\", false).attr(\"aria-label\", \"Select all rows\");\n              }\n            },\n            _uncheckCheckBoxes: function () {\n              var that = this;\n              var tables = that.table.add(that.lockedTable);\n              tables.find(\"tbody \" + CHECKBOXINPUT).attr(\"aria-checked\", false).prop(\"checked\", false).attr(\"aria-label\", \"Select row\");\n            },\n            _deselectCheckRows: function (items) {\n              var that = this,\n                  rangeSelectedAttr = kendo.attr(\"range-selected\");\n              items = that.table.add(that.lockedTable).find(items);\n\n              if (that._isLocked()) {\n                items = items.add(items.map(function () {\n                  return that._relatedRow(this);\n                }));\n              }\n\n              items.each(function () {\n                $(this).removeClass(SELECTED).removeAttr(rangeSelectedAttr).find(CHECKBOXINPUT).attr(\"aria-checked\", false).prop(\"checked\", false).attr(\"aria-label\", \"Select row\");\n              });\n\n              that._toggleHeaderCheckState(false);\n\n              that._persistSelectedRows();\n\n              that.trigger(CHANGE);\n            },\n            _checkRows: function (items) {\n              items.each(function () {\n                $(this).addClass(SELECTED).find(CHECKBOXINPUT).prop(\"checked\", true).attr(\"aria-label\", \"Deselect row\").attr(\"aria-checked\", true);\n              });\n            },\n            _persistSelectedRows: function () {\n              var that = this,\n                  key,\n                  dataItem,\n                  allRows = that.items(),\n                  dataSourceOptions = that.dataSource.options,\n                  schema = dataSourceOptions.schema,\n                  modelId,\n                  selectedViewIds = {};\n\n              if (!schema || !schema.model || !that._data) {\n                return;\n              }\n\n              modelId = isFunction(schema.model) ? schema.model.fn.idField : schema.model.id;\n\n              if (!modelId) {\n                return;\n              }\n\n              if (!kendo.ui.Selectable.parseOptions(that.options.selectable).multiple && !that._checkBoxSelection) {\n                that._selectedIds = {};\n              }\n\n              that.select().each(function () {\n                dataItem = that.dataItem(this);\n                selectedViewIds[dataItem[modelId]] = true;\n              });\n\n              for (var i = 0; i < allRows.length; i++) {\n                dataItem = that.dataItem(allRows[i]);\n                key = dataItem[modelId];\n\n                if (selectedViewIds[key]) {\n                  that._selectedIds[key] = true;\n                } else {\n                  delete that._selectedIds[key];\n                }\n              }\n            },\n            selectedKeyNames: function () {\n              var that = this,\n                  ids = [];\n\n              for (var property in that._selectedIds) {\n                ids.push(property);\n              }\n\n              ids.sort();\n              return ids;\n            },\n            _updateCurrentAttr: function (current, next) {\n              var headerId = $(current).data(\"headerId\");\n              var nextId;\n              var descId;\n              $(current).removeClass(FOCUSED).closest(\"table\").removeAttr(\"aria-activedescendant\");\n\n              if (headerId) {\n                headerId = headerId.replace(this._cellId, \"\");\n                $(current).attr(\"id\", headerId);\n              } else {\n                $(current).removeAttr(\"id\");\n              }\n\n              nextId = next.attr(\"id\");\n\n              if (nextId != this._cellId) {\n                next.data(\"headerId\", nextId);\n              }\n\n              if (next.is(\"th\")) {\n                descId = nextId;\n              } else {\n                next.attr(\"id\", this._cellId);\n              }\n\n              next.addClass(FOCUSED).closest(\"table\").attr(\"aria-activedescendant\", descId || this._cellId);\n              this._current = next;\n            },\n            _scrollCurrent: function () {\n              var current = this._current;\n              var scrollable = this.options.scrollable;\n\n              if (!current || !scrollable) {\n                return;\n              }\n\n              var row = current.parent();\n              var tableContainer = row.closest(\"table\").parent();\n              var isInLockedContainer = tableContainer.is(\".k-grid-content-locked,.k-grid-header-locked\");\n              var isInContent = tableContainer.is(\".k-grid-content-locked,.k-grid-content,.k-virtual-scrollable-wrap\");\n              var scrollableContainer = $(this.content).find(\">.k-virtual-scrollable-wrap\").addBack().last()[0]; //adjust scroll vertically\n\n              if (isInContent) {\n                if (this.virtualScroll) {\n                  var rowIndex = Math.max(inArray(row[0], this._items(row.parent())), 0);\n\n                  if (this.virtualScroll.rows) {\n                    this._rowVirtualIndex = this.virtualScrollable.itemIndex(rowIndex);\n                    this.virtualScrollable.scrollIntoView(row);\n                  } else {\n                    this._rowVirtualIndex = rowIndex;\n\n                    this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n                  }\n                } else {\n                  this._scrollTo(this._relatedRow(row)[0], scrollableContainer);\n                }\n              }\n\n              if (this.lockedContent) {\n                //sync locked and non-locked content scrollTop\n                this.lockedContent[0].scrollTop = scrollableContainer.scrollTop;\n              } //adjust scroll horizontally, if not inside locked tables\n\n\n              if (!isInLockedContainer) {\n                this._scrollTo(current[0], scrollableContainer);\n              }\n            },\n            current: function (next) {\n              return this._setCurrent(next, true);\n            },\n            _setCurrent: function (next, preventTrigger, preventScroll) {\n              var current = this._current;\n              next = $(next);\n\n              if (next.length) {\n                if (!current || current[0] !== next[0]) {\n                  var parent = next.parent();\n                  var siblings = parent.children(DATA_CELL);\n                  var colspan = parseInt(parent.children().first().attr(\"colspan\"), 10);\n\n                  if (this._hasVirtualColumns()) {\n                    this._virtualCellIndex = (colspan > 1 ? colspan : 0) + siblings.index(next);\n                  }\n\n                  this._updateCurrentAttr(current, next);\n\n                  if (!preventScroll) {\n                    this._scrollCurrent();\n                  }\n\n                  if (!preventTrigger) {\n                    this.trigger(NAVIGATE, {\n                      element: next\n                    });\n                  }\n                }\n              }\n\n              if (next && next.length) {\n                this._lastCellIndex = next.parent().children(DATA_CELL).index(next);\n              }\n\n              return this._current;\n            },\n            _removeCurrent: function () {\n              if (this._current) {\n                this._current.removeClass(FOCUSED);\n\n                this._current = null;\n              }\n            },\n            _scrollTo: function (element, container) {\n              var elementToLowercase = element.tagName.toLowerCase();\n              var isHorizontal = elementToLowercase === \"td\" || elementToLowercase === \"th\";\n              var table = $(element).closest(\"table\")[0];\n              var elementOffsetDir = element[isHorizontal ? \"offsetWidth\" : \"offsetHeight\"];\n              var containerScroll = container[isHorizontal ? \"scrollLeft\" : \"scrollTop\"];\n              var containerOffsetDir = container[isHorizontal ? \"clientWidth\" : \"clientHeight\"];\n              var elementOffset = $(element).css(\"position\") === \"relative\" && isRtl && isHorizontal ? Math.abs(table.offsetLeft - element.offsetLeft) : element[isHorizontal ? \"offsetLeft\" : \"offsetTop\"];\n              var bottomDistance = elementOffset + elementOffsetDir;\n              var result = 0;\n              var ieCorrection = 0;\n              var firefoxCorrection = 0;\n\n              if (isRtl && isHorizontal) {\n                if (browser.msie || browser.edge) {\n                  ieCorrection = table.offsetLeft;\n                } else if (browser.mozilla || browser.webkit && browser.version > 85) {\n                  firefoxCorrection = table.offsetLeft - kendo.support.scrollbar();\n                }\n              }\n\n              containerScroll = Math.abs(containerScroll + ieCorrection - firefoxCorrection);\n\n              if (containerScroll > elementOffset) {\n                result = elementOffset;\n              } else if (bottomDistance > containerScroll + containerOffsetDir) {\n                if (elementOffsetDir <= containerOffsetDir) {\n                  result = bottomDistance - containerOffsetDir;\n                } else {\n                  result = elementOffset;\n                }\n              } else {\n                result = containerScroll;\n              }\n\n              result = Math.abs(result + ieCorrection) + firefoxCorrection;\n              container[isHorizontal ? \"scrollLeft\" : \"scrollTop\"] = result;\n            },\n            _navigatable: function () {\n              var that = this;\n\n              if (!that.options.navigatable) {\n                return;\n              } //data tables - locked and non-locked\n\n\n              var dataTables = that.table.add(that.lockedTable); //header tables - locked and non-locked\n\n              var headerTables = that.thead.parent().add($(\">table\", that.lockedHeader)); //the over wich keys will be handled\n\n              var tables = dataTables;\n\n              if (that.options.scrollable) {\n                //add the header table when the widget is scrollable\n                tables = tables.add(headerTables); //data tables will recive first focus on TAB\n\n                headerTables.attr(TABINDEX, -1);\n              }\n\n              this._navigatableTables = tables;\n              this._headertables = headerTables; //dettach all previous events\n\n              tables.off(\"mousedown\" + NS + \" focus\" + NS + \" focusout\" + NS + \" keydown\" + NS);\n              headerTables.on(\"keydown\" + NS, that._openHeaderMenu.bind(that)).find(\"a.k-link\").attr(\"tabIndex\", -1); //prevent propagation when clicked inside detail grid\n\n              dataTables.attr(TABINDEX, math.max(dataTables.attr(TABINDEX) || 0, 0)).on(\"keydown\" + NS, \".k-detail-cell\", function (e) {\n                if (e.target !== e.currentTarget) {\n                  e.stopImmediatePropagation();\n                }\n              });\n              tables //handle click on tables, will attempt to focus the table\n              .on(kendo.support.touch ? \"touchstart\" + NS : \"mousedown\" + NS, NAVROW + \">\" + NAVCELL, tableClick.bind(that)).on(\"focus\" + NS, that._tableFocus.bind(that)).on(\"focusout\" + NS, that._tableBlur.bind(that)).on(\"keydown\" + NS, that, that._tableKeyDown.bind(that));\n            },\n            _openHeaderMenu: function (e) {\n              if (e.altKey && e.keyCode == keys.DOWN) {\n                this.current().find(\".k-grid-filter, .k-header-column-menu\").click();\n                e.stopImmediatePropagation();\n              }\n            },\n            _setTabIndex: function (table) {\n              this._navigatableTables.attr(TABINDEX, -1);\n\n              table.attr(TABINDEX, 0);\n            },\n            _tableFocus: function (e) {\n              var current = this.current();\n              var table = $(e.currentTarget); //if there is already current, highlighted it\n              //otherwise highlight the first possible cell\n\n              if (current && current.is(\":visible\")) {\n                current.addClass(FOCUSED);\n              } else {\n                if (this._virtualColScroll) {\n                  this._setCurrent(table.find(NAVROW).first().children(NAVCELL).first(), true, true);\n                } else {\n                  this._setCurrent(table.find(NAVROW).first().children(NAVCELL).first());\n                }\n              }\n\n              this._setTabIndex(table);\n            },\n            _tableBlur: function () {\n              var current = this.current();\n\n              if (current) {\n                current.removeClass(FOCUSED);\n              }\n            },\n            _findCellIndex: function (columns, startIndex, reversed) {\n              var cellIndex;\n              var i;\n\n              if (reversed) {\n                for (i = startIndex; i >= 0; i--) {\n                  cellIndex = i;\n\n                  if (!columns[i].hidden) {\n                    break;\n                  }\n                }\n              } else {\n                for (i = startIndex; i < columns.length; i++) {\n                  cellIndex = i;\n\n                  if (!columns[i].hidden) {\n                    break;\n                  }\n                }\n              }\n\n              return cellIndex;\n            },\n            _scrollToColumn: function (key, e) {\n              if (this._virtualCellIndex === undefined) {\n                return false;\n              }\n\n              var that = this;\n              var cellIndex = that._virtualCellIndex;\n              var leafsCols = leafColumns(nonLockedColumns(that.columns));\n              var scrollWidth = 0;\n\n              if (key == (isRtl ? keys.LEFT : keys.RIGHT) && cellIndex !== leafsCols.length - 1) {\n                cellIndex = that._findCellIndex(leafsCols, cellIndex + 1);\n              } else if (key == (isRtl ? keys.RIGHT : keys.LEFT) && cellIndex) {\n                cellIndex = that._findCellIndex(leafsCols, cellIndex - 1, true);\n              } else if (key == keys.HOME) {\n                cellIndex = that._findCellIndex(leafsCols, 0);\n              } else if (key == keys.END) {\n                cellIndex = that._findCellIndex(leafsCols, leafsCols.length - 1, true);\n              }\n\n              for (var i = 0; i < cellIndex; i++) {\n                scrollWidth += leafsCols[i].width;\n              }\n\n              that._virtualCellIndex = cellIndex;\n\n              if (e) {\n                e.preventDefault();\n                e.stopPropagation();\n              }\n\n              kendo.scrollLeft(that.content, scrollWidth);\n              return true;\n            },\n            _tableKeyDown: function (e) {\n              var current = this.current();\n              var virtualScroll = this.virtualScroll || {};\n              var requestInProgress = this.virtualScrollable && this.virtualScrollable.fetching();\n              var target = $(e.target);\n              var canHandle = !e.isDefaultPrevented() && !target.is(\":button,a,:input,a>.k-icon\"); // do not handle key down if request in progress\n              // or there isn't current set\n\n              if (requestInProgress) {\n                // swallow key events while in progress\n                e.preventDefault();\n                return;\n              }\n\n              if (virtualScroll.columns && (!current || !document.body.contains(current[0])) && this._scrollToColumn(e.keyCode, e)) {\n                return;\n              }\n\n              if (!current) {\n                current = $(this.lockedTable).add(this.options.scrollable ? this.table : this.tbody).find(NAVROW).first().children(NAVCELL).first();\n              }\n\n              if (!current.length) {\n                return;\n              }\n\n              var handled = false;\n\n              if (canHandle && e.keyCode == keys.UP) {\n                handled = this._moveUp(current, e.shiftKey, e.ctrlKey);\n              }\n\n              if (canHandle && e.keyCode == keys.DOWN) {\n                handled = this._moveDown(current, e.shiftKey, e.ctrlKey);\n              }\n\n              if (canHandle && e.keyCode == (isRtl ? keys.LEFT : keys.RIGHT)) {\n                handled = this._moveRight(current, e.altKey, e.shiftKey, e.ctrlKey, e.currentTarget);\n              }\n\n              if (canHandle && e.keyCode == (isRtl ? keys.RIGHT : keys.LEFT)) {\n                handled = this._moveLeft(current, e.altKey, e.shiftKey, e.ctrlKey, e.currentTarget);\n              }\n\n              if (canHandle && e.keyCode == keys.PAGEDOWN) {\n                handled = this._handlePageDown();\n              }\n\n              if (canHandle && e.keyCode == keys.PAGEUP) {\n                handled = this._handlePageUp();\n              }\n\n              if (canHandle && e.keyCode == keys.HOME) {\n                handled = this._handleHome(current, e.ctrlKey);\n              }\n\n              if (canHandle && e.keyCode == keys.END) {\n                handled = this._handleEnd(current, e.ctrlKey);\n              }\n\n              if (canHandle && e.keyCode == keys.SPACEBAR) {\n                handled = this._handleSpaceKey(current, e.ctrlKey);\n              }\n\n              if (e.keyCode == keys.ENTER || e.keyCode == keys.F2) {\n                handled = this._handleEnterKey(current, e.currentTarget, target);\n              }\n\n              if (e.keyCode == keys.ESC) {\n                handled = this._handleEscKey(current, e.currentTarget);\n              }\n\n              if (e.keyCode == keys.TAB) {\n                handled = this._handleTabKey(current, e.currentTarget, e.shiftKey, target);\n              }\n\n              if (handled) {\n                //prevent scrolling while pressing the keys\n                e.preventDefault(); //required in hierarchy\n\n                e.stopPropagation();\n              }\n            },\n            _moveLeft: function (current, altKey, shiftKey, ctrlKey, currentTable) {\n              var next, index;\n              var row = current.parent(); //thead or tbody\n\n              var container = row.parent();\n\n              if (altKey) {\n                if (row.hasClass(\"k-grouping-row\")) {\n                  this.collapseGroup(row);\n                } else {\n                  this.collapseRow(row);\n                }\n              } else if (ctrlKey && current.is(\".k-header\") && this.options.reorderable) {\n                this._moveColumn(current, true);\n              } else {\n                index = container.find(NAVROW).index(row);\n                next = this._prevHorizontalCell(container, current, index);\n\n                if (!next[0]) {\n                  if (shiftKey) {\n                    if (this.lockedTable) {\n                      next = this._relatedRow(row);\n\n                      if ($.contains(this.lockedTable[0], row[0])) {\n                        next = next.prevAll(ITEMROW).first();\n                      }\n\n                      next = next.children(DATA_CELL).last();\n                    } else {\n                      next = this._tabNext(current, currentTable, true);\n                    }\n                  } else {\n                    container = this._horizontalContainer(container);\n                    next = this._prevHorizontalCell(container, current, index);\n\n                    if (next[0] !== current[0]) {\n                      focusTable(container.parent(), true);\n                    }\n                  }\n                }\n\n                this._setCurrent(next);\n              }\n\n              return true;\n            },\n            _moveRight: function (current, altKey, shiftKey, ctrlKey, currentTable) {\n              var next, index;\n              var row = current.parent(); //thead or tbody\n\n              var container = row.parent();\n\n              if (altKey) {\n                if (row.hasClass(\"k-grouping-row\")) {\n                  this.expandGroup(row);\n                } else {\n                  this.expandRow(row);\n                }\n              } else if (ctrlKey && current.is(\".k-header\") && this.options.reorderable) {\n                this._moveColumn(current, false);\n              } else {\n                index = container.find(NAVROW).index(row);\n                next = this._nextHorizontalCell(container, current, index);\n\n                if (!next[0]) {\n                  if (shiftKey) {\n                    if (this.lockedTable) {\n                      next = this._relatedRow(row);\n\n                      if ($.contains(this.table[0], row[0])) {\n                        next = next.nextAll(ITEMROW).first();\n                      }\n\n                      next = next.children(DATA_CELL).first();\n                    } else {\n                      next = this._tabNext(current, currentTable, false);\n                    }\n                  } else {\n                    container = this._horizontalContainer(container, true);\n                    next = this._nextHorizontalCell(container, current, index);\n\n                    if (next[0] !== current[0]) {\n                      focusTable(container.parent(), true);\n                    }\n                  }\n                }\n\n                this._setCurrent(next);\n              }\n\n              return true;\n            },\n            _moveUp: function (current, shiftKey, ctrlKey) {\n              //thead or tbody\n              var container = current.parent().parent();\n              var next, cellIndex, index, oldIndex;\n\n              if (shiftKey) {\n                next = current.parent();\n                next = next.prevAll(ITEMROW).first();\n                next = current.parent().is(ITEMROW) ? next.children().eq(current.index()) : next.children(DATA_CELL).last();\n              } else if (ctrlKey && current.parent().is(ITEMROW) && this._hasReorderableRows()) {\n                cellIndex = current.index();\n                next = current.parent();\n                next = next.prevAll(ITEMROW).first();\n                index = this.tbody.children(ITEMROW).index(next);\n                oldIndex = this.tbody.children(ITEMROW).index(current.parent());\n\n                if (index >= 0 && !this.trigger(ROWREORDER, {\n                  oldIndex: oldIndex,\n                  newIndex: index,\n                  row: current.parent()\n                })) {\n                  this.reorderRows(current.parent(), index);\n                  next = this.tbody.children(ITEMROW).eq(index).children().eq(cellIndex);\n                }\n              } else {\n                next = this._prevVerticalCell(container, current);\n\n                if (!next[0]) {\n                  this._lastCellIndex = 0;\n                  container = this._verticalContainer(container, true);\n                  next = this._prevVerticalCell(container, current);\n\n                  if (next[0]) {\n                    focusTable(container.parent(), true);\n                  }\n                }\n              }\n\n              var tmp = this._lastCellIndex || 0;\n\n              this._setCurrent(next);\n\n              this._lastCellIndex = tmp;\n              return true;\n            },\n            _moveDown: function (current, shiftKey, ctrlKey) {\n              //thead or tbody\n              var container = current.parent().parent();\n              var next, cellIndex, index, oldIndex;\n\n              if (shiftKey) {\n                next = current.parent();\n                next = next.nextAll(ITEMROW).first();\n                next = current.parent().is(ITEMROW) ? next.children().eq(current.index()) : next.children(DATA_CELL).first();\n              } else if (ctrlKey && current.parent().is(ITEMROW) && this._hasReorderableRows()) {\n                cellIndex = current.index();\n                next = current.parent();\n                next = next.nextAll(ITEMROW).first();\n                index = this.tbody.children(ITEMROW).index(next);\n                oldIndex = this.tbody.children(ITEMROW).index(current.parent());\n\n                if (index >= 0 && !this.trigger(ROWREORDER, {\n                  oldIndex: oldIndex,\n                  newIndex: index,\n                  row: current.parent()\n                })) {\n                  this.reorderRows(current.parent(), index + 1);\n                  next = this.tbody.children(ITEMROW).eq(index).children().eq(cellIndex);\n                }\n              } else {\n                next = this._nextVerticalCell(container, current);\n\n                if (!next[0]) {\n                  this._lastCellIndex = 0;\n                  container = this._verticalContainer(container);\n                  next = this._nextVerticalCell(container, current);\n\n                  if (next[0]) {\n                    focusTable(container.parent(), true);\n                  }\n                }\n              }\n\n              var tmp = this._lastCellIndex || 0;\n\n              this._setCurrent(next);\n\n              this._lastCellIndex = tmp;\n              return true;\n            },\n            _moveColumn: function (current, isLeft) {\n              var elements = this.wrapper.data().kendoReorderable.element.find(this._draggableInstance.options.filter + \":visible\");\n              var columns = visibleColumns(flatColumnsInDomOrder(this.columns));\n              var oldIndex = elements.index($(current));\n              var offset = isLeft ? -1 : 1;\n              var column = columns[oldIndex];\n              var newIndex = targetParentContainerIndex(columns, this.columns, oldIndex, oldIndex + offset);\n\n              if (newIndex >= 0) {\n                this.reorderColumn(newIndex, column, isLeft);\n                this.trigger(COLUMNREORDER, {\n                  newIndex: newIndex,\n                  oldIndex: oldIndex,\n                  column: column\n                });\n              }\n            },\n            _handleHome: function (current, ctrl) {\n              var row = current.parent();\n              var rowContainer = row.parent();\n              var isInLockedTable = this.lockedTable && this.lockedTable.children(\"tbody\")[0] === rowContainer[0];\n              var isInBody = rowContainer[0] === this.tbody[0];\n              var prev;\n\n              if (this._hasVirtualColumns()) {\n                this._scrollToColumn(kendo.keys.HOME);\n\n                return true;\n              }\n\n              if (ctrl) {\n                if (this.lockedTable) {\n                  prev = this.lockedTable.find(ITEMROW).first().children(NAVCELL).first();\n                } else {\n                  prev = this.table.find(ITEMROW).first().children(NAVCELL).first();\n                }\n              } else if (isInBody || isInLockedTable) {\n                if (isInBody && this.lockedTable) {\n                  row = this._relatedRow(row);\n                }\n\n                prev = row.children(DATA_CELL).first();\n              }\n\n              if (prev && prev.length) {\n                this._setCurrent(prev);\n\n                return true;\n              }\n            },\n            _handleEnd: function (current, ctrl) {\n              var row = current.parent();\n              var rowContainer = row.parent();\n              var isInLockedTable = this.lockedTable && this.lockedTable.children(\"tbody\")[0] === rowContainer[0];\n              var isInBody = rowContainer[0] === this.tbody[0];\n              var next;\n\n              if (this._hasVirtualColumns()) {\n                this._scrollToColumn(kendo.keys.END);\n\n                return true;\n              }\n\n              if (ctrl) {\n                next = this.table.find(ITEMROW).last().children(NAVCELL).last();\n              } else if (isInBody || isInLockedTable) {\n                if (!isInBody && this.lockedTable) {\n                  row = this._relatedRow(row);\n                }\n\n                next = row.children(DATA_CELL).last();\n              }\n\n              if (next && next.length) {\n                this._setCurrent(next);\n\n                return true;\n              }\n            },\n            _handlePageDown: function () {\n              if (!this.options.pageable) {\n                return false;\n              }\n\n              this.dataSource.page(this.dataSource.page() + 1);\n              return true;\n            },\n            _handlePageUp: function () {\n              if (!this.options.pageable) {\n                return false;\n              }\n\n              this.dataSource.page(this.dataSource.page() - 1);\n              return true;\n            },\n            _handleTabKey: function (current, currentTable, shiftKey, target) {\n              var isInCell = this.options.editable && this._editMode() == \"incell\";\n              var cell;\n\n              if (!isInCell || current.is(\"th\") || (this.options.scrollable ? this._headertables.filter(currentTable).length : this.thead.filter(target).length)) {\n                return false;\n              }\n\n              cell = $(activeElement()).closest(\".k-edit-cell\");\n\n              if (cell[0] && cell[0] !== current[0]) {\n                current = cell;\n              }\n\n              cell = this._tabNext(current, currentTable, shiftKey);\n\n              if (cell[0] === current[0]) {\n                return false;\n              }\n\n              if (cell.length) {\n                this._handleEditing(current, cell, cell.closest(\"table\"));\n\n                return true;\n              }\n\n              return false;\n            },\n            _handleEscKey: function (current, currentTable) {\n              var active = activeElement();\n              var isInCell = this._editMode() == \"incell\";\n\n              if (!isInEdit(current)) {\n                if (current.has(active).length) {\n                  // return focus back to the table\n                  focusTable(currentTable, true);\n                  return true;\n                }\n\n                return false;\n              }\n\n              if (isInCell) {\n                this.closeCell(true);\n              } else {\n                var currentIndex = $(current).parent().index();\n\n                if (active) {\n                  active.blur();\n                }\n\n                this.cancelRow(true);\n\n                if (currentIndex >= 0) {\n                  this._setCurrent(this.items().eq(currentIndex).children(NAVCELL).first());\n                }\n              }\n\n              focusTable(currentTable, true);\n              return true;\n            },\n            _toggleCurrent: function (current, editable, hasDetails) {\n              var row = current.parent();\n\n              if (current.is(\".k-command-cell\")) {\n                return false;\n              }\n\n              if (row.is(\".k-grouping-row\")) {\n                row.find(\".k-icon\").first().click();\n                return true;\n              }\n\n              if (!editable && hasDetails) {\n                row.find(\".k-icon\").first().click();\n                return true;\n              }\n\n              return false;\n            },\n            _handleSpaceKey: function (current, ctrlKey) {\n              var that = this;\n\n              if (!ctrlKey || !that.groupable || !current.hasClass(\"k-header\")) {\n                return;\n              }\n\n              var descriptors = that.groupable.descriptors();\n              var field = current.attr(kendo.attr(\"field\"));\n              var aggregates = that.groupable.aggregates();\n              var label = current.attr(kendo.attr(\"title\")) || field;\n\n              if (that.groupable._canDrag(current)) {\n                descriptors.push({\n                  field: field,\n                  dir: \"asc\",\n                  aggregates: aggregates || []\n                });\n                label += \" \" + that.options.messages.ungroupHeader;\n              } else {\n                descriptors = $.grep(descriptors, function (item) {\n                  return item.field !== field;\n                });\n                label += \" \" + that.options.messages.groupHeader;\n              }\n\n              current.attr(\"aria-label\", label);\n              that.dataSource.group(descriptors);\n              return true;\n            },\n            _handleEnterKey: function (current, currentTable, target) {\n              var editable = this.options.editable && this.options.editable.update !== false;\n              var container = target.closest(\"[role=gridcell]\");\n\n              var hasDetails = this._hasDetails();\n\n              var link;\n\n              if (!target.is(\"table\") && !$.contains(current[0], target[0])) {\n                current = container;\n              }\n\n              if (current.is(\"th\")) {\n                // sort the column, if possible\n                link = current.find(\".k-link\");\n\n                if (link.length) {\n                  link.click();\n                } else {\n                  current.find(CHECKBOXINPUT).trigger(\"focus\");\n                }\n\n                return true;\n              }\n\n              if (this._toggleCurrent(current, editable, hasDetails)) {\n                return true;\n              }\n\n              var focusable = current.find(\":kendoFocusable\").first();\n\n              if (focusable[0] && !current.hasClass(\"k-edit-cell\") && current.hasClass(\"k-state-focused\")) {\n                focusable.trigger(\"focus\");\n                return true;\n              }\n\n              if (editable && !target.is(\":button,.k-button,textarea\")) {\n                if (!container[0]) {\n                  container = current;\n                }\n\n                this._handleEditing(container, false, currentTable);\n\n                return true;\n              }\n\n              return false;\n            },\n            _nextHorizontalCell: function (table, current, originalIndex) {\n              var cells = current.nextAll(DATA_CELL);\n\n              if (!cells.length) {\n                var rows = table.find(NAVROW);\n                var rowIndex = rows.index(current.parent()); //no sibling cells are found and we've changed the table\n\n                if (rowIndex == -1) {\n                  if (current.hasClass(\"k-header\")) {\n                    var headerRows = [];\n                    mapColumnToCellRows([lockedColumns(this.columns)[0]], childColumnsCells(rows.eq(0).children(\":visible\").first()), headerRows, 0, 0);\n\n                    if (headerRows[originalIndex]) {\n                      return headerRows[originalIndex][0];\n                    }\n\n                    return current;\n                  } //current is in filter row\n\n\n                  if (current.parent().hasClass(\"k-filter-row\")) {\n                    return rows.last().children(DATA_CELL).first();\n                  } //get the same row index in the new table\n\n\n                  return rows.eq(originalIndex).children(DATA_CELL).first();\n                }\n              }\n\n              return cells.first();\n            },\n            _prevHorizontalCell: function (table, current, originalIndex) {\n              var cells = current.prevAll(DATA_CELL);\n\n              if (!cells.length) {\n                var rows = table.find(NAVROW);\n                var rowIndex = rows.index(current.parent()); //no sibling cells are found and we've changed the table\n\n                if (rowIndex == -1) {\n                  if (current.hasClass(\"k-header\")) {\n                    var headerRows = [];\n                    var columns = lockedColumns(this.columns);\n                    mapColumnToCellRows([columns[columns.length - 1]], childColumnsCells(rows.eq(0).children().last()), headerRows, 0, 0);\n\n                    if (headerRows[originalIndex]) {\n                      return headerRows[originalIndex][0];\n                    }\n\n                    return current;\n                  } //current is in filter row\n\n\n                  if (current.parent().hasClass(\"k-filter-row\")) {\n                    return rows.last().children(DATA_CELL).last();\n                  } //get the same row index in the new table\n\n\n                  return rows.eq(originalIndex).children(DATA_CELL).last();\n                }\n              }\n\n              return cells.first();\n            },\n            _currentDataIndex: function (table, current) {\n              var index = current.attr(\"data-index\");\n\n              if (!index) {\n                return undefined;\n              }\n\n              var lockedColumnsCount = lockedColumns(this.columns).length;\n\n              if (lockedColumnsCount && !table.closest(\"div\").hasClass(\"k-grid-content-locked\")[0]) {\n                return index - lockedColumnsCount;\n              }\n\n              return index;\n            },\n            _prevVerticalCell: function (container, current) {\n              var cells;\n              var row = current.parent();\n              var rows = container.children(NAVROW);\n              var rowIndex = rows.index(row); //get data-index in case of last level of multi-level columns\n\n              var index = this._currentDataIndex(container, current); //current is in the header, but not at the last level of multi-level columns\n\n\n              if (index || current.hasClass(\"k-header\")) {\n                cells = parentColumnsCells(current);\n                return cells.eq(cells.length - 2);\n              } //check this out\n\n\n              index = Math.max(row.children(DATA_CELL).index(current), this._lastCellIndex || 0); //if current is inside filter row\n\n              if (row.hasClass(\"k-filter-row\")) {\n                return leafDataCells(container).filter(isCellVisible).eq(index);\n              } //move up to header container\n\n\n              if (rowIndex == -1) {\n                if (this._hasVirtualColumns()) {\n                  index = this._virtualCellIndex;\n                } //is there filter row in the header container\n\n\n                row = container.find(\"tr.k-filter-row:visible\");\n\n                if (!row[0]) {\n                  // in hierarchical grid we need to correct the index\n                  // since the k-hierarchy cell is navigatable\n                  if ((this._hasDetails() || current.parent().find('.k-hierarchy-cell').length) && index) {\n                    index--;\n                  }\n\n                  return leafDataCells(container).filter(isCellVisible).eq(index);\n                }\n              } else {\n                row = rowIndex === 0 ? $() : rows.eq(rowIndex - 1);\n              }\n\n              cells = row.children(DATA_CELL);\n\n              if (cells.length > index) {\n                return cells.eq(index);\n              }\n\n              return cells.eq(0);\n            },\n            _nextVerticalCell: function (container, current) {\n              var cells;\n              var row = current.parent();\n              var rows = container.children(NAVROW);\n              var rowIndex = rows.index(row); //get data-index in case of last level of multi-level columns\n\n              var index = this._currentDataIndex(container, current);\n\n              var virtualScroll = this.virtualScroll || {};\n              var colspan; //current is in the header, but not at the last level of multi-level columns\n              //and we are not changing the table\n\n              if (rowIndex != -1 && index === undefined && current.hasClass(\"k-header\")) {\n                return childColumnsCells(current).eq(1);\n              }\n\n              index = index ? parseInt(index, 10) : row.children(DATA_CELL).index(current);\n              index = Math.max(index, this._lastCellIndex || 0); //move down to data container\n\n              if (rowIndex == -1) {\n                row = rows.eq(0);\n\n                if (virtualScroll.columns) {\n                  colspan = parseInt(row.children().first().attr(\"colspan\"), 10);\n                  index = this._virtualCellIndex - (colspan > 1 ? colspan : 0);\n                } // in hierarchical grid we need to correct the index\n                // since the k-hierarchy cell is navigatable\n\n\n                if (this._hasDetails() || row.find('.k-hierarchy-cell').length) {\n                  index++;\n                }\n              } else {\n                row = rows.eq(rowIndex + current[0].rowSpan);\n              }\n\n              var tmpIndex = index; //in case of last level of multi-level columns the index should be updated depending on the hidden columns\n\n              if (this._currentDataIndex(container, current) !== undefined) {\n                var currentRowCells = row.children(\":not(.k-group-cell):not(.k-hierarchy-cell)\");\n                var hiddenColumns = currentRowCells.filter(\":hidden\");\n\n                for (var idx = 0, length = hiddenColumns.length; idx < length; idx++) {\n                  if (currentRowCells.index(hiddenColumns[idx]) < index) {\n                    tmpIndex--;\n                  }\n                }\n              }\n\n              index = tmpIndex;\n              cells = row.children(DATA_CELL);\n\n              if (cells.length > index) {\n                return cells.eq(index);\n              }\n\n              return cells.eq(0);\n            },\n            _verticalContainer: function (container, up) {\n              var table = container.parent();\n              var length = this._navigatableTables.length;\n              var step = Math.floor(length / 2);\n              var index = inArray(table[0], this._navigatableTables);\n\n              if (up) {\n                step *= -1;\n              }\n\n              index += step;\n\n              if (index >= 0 || index < length) {\n                table = this._navigatableTables.eq(index);\n              }\n\n              return table.find(up ? \">thead\" : \">tbody\");\n            },\n            _horizontalContainer: function (container, right) {\n              var length = this._navigatableTables.length;\n\n              if (length <= 2) {\n                return container;\n              }\n\n              var table = container.parent();\n              var index = inArray(table[0], this._navigatableTables);\n              index += right ? 1 : -1;\n\n              if (right && (index == 2 || index == length)) {\n                return container;\n              }\n\n              if (!right && (index == 1 || index < 0)) {\n                return container;\n              }\n\n              return this._navigatableTables.eq(index).find(\"thead, tbody\");\n            },\n            _tabNext: function (current, currentTable, back) {\n              var switchRow = true;\n              var next = back ? current.prevAll(DATA_CELL).first() : current.nextAll(\":visible\").first();\n\n              if (!next.length) {\n                next = current.parent();\n\n                if (this.lockedTable) {\n                  switchRow = back && currentTable == this.lockedTable[0] || !back && currentTable == this.table[0];\n                  next = this._relatedRow(next);\n                }\n\n                if (switchRow) {\n                  if (this._hasVirtualColumns()) {\n                    return current;\n                  }\n\n                  next = next[back ? \"prevAll\" : \"nextAll\"](\"tr:not(.k-grouping-row):not(.k-detail-row):visible\").first();\n                }\n\n                if (back) {\n                  next = next.children(DATA_CELL).last();\n                } else {\n                  next = next.children(DATA_CELL).first();\n                }\n              }\n\n              return next;\n            },\n            _handleEditing: function (current, next, table) {\n              var that = this,\n                  active = $(activeElement()),\n                  mode = that._editMode(),\n                  isIE = browser.msie,\n                  editContainer = that._editContainer,\n                  focusable,\n                  editable = that.options.editable && that.options.editable.update !== false,\n                  isEdited;\n\n              table = $(table);\n\n              if (mode == \"incell\") {\n                isEdited = current.hasClass(\"k-edit-cell\");\n              } else {\n                isEdited = current.parent().hasClass(\"k-grid-edit-row\");\n              }\n\n              if (that.editable) {\n                if ($.contains(editContainer[0], active[0])) {\n                  active.trigger(\"blur\");\n\n                  if (isIE) {\n                    //IE10 with jQuery 1.9.x does not trigger blur handler\n                    //numeric textbox does trigger change\n                    active.trigger(\"blur\");\n                  }\n                }\n\n                if (!that.editable) {\n                  focusTable(table);\n                  return;\n                }\n\n                if (that.editable.end()) {\n                  if (mode == \"incell\") {\n                    that.closeCell();\n                  } else {\n                    that.saveRow();\n                    isEdited = true;\n                  }\n                } else {\n                  if (mode == \"incell\") {\n                    that._setCurrent(editContainer);\n                  } else {\n                    that._setCurrent(editContainer.children().filter(DATA_CELL).first());\n                  }\n\n                  focusable = editContainer.find(\":kendoFocusable\").first()[0];\n\n                  if (focusable) {\n                    focusable.focus();\n                  }\n\n                  return;\n                }\n              }\n\n              if (next) {\n                that._setCurrent(next);\n              }\n\n              focusTable(table, true);\n\n              if (!editable) {\n                return;\n              }\n\n              if (!isEdited && !next || next) {\n                if (mode === INCELL) {\n                  if (!$(that.current()).hasClass(HIERARCHY_CELL_CLASS)) {\n                    that.editCell(that.current());\n                  }\n                } else {\n                  that.editRow(that.current().parent());\n                }\n              }\n            },\n            _wrapper: function () {\n              var that = this,\n                  table = that.table,\n                  height = that.options.height,\n                  width = that.options.width,\n                  wrapper = that.element;\n\n              if (!wrapper.is(\"div\")) {\n                wrapper = wrapper.wrap(\"<div/>\").parent();\n              }\n\n              that.wrapper = wrapper.addClass(\"k-grid k-widget k-grid-display-block\");\n\n              if (height) {\n                that.wrapper.css(HEIGHT, height);\n                table.css(HEIGHT, \"auto\");\n              }\n\n              if (width) {\n                that.wrapper.css(\"width\", width);\n              }\n\n              that._initMobile();\n            },\n            _initMobile: function () {\n              var options = this.options;\n              var that = this;\n              this._isMobile = options.mobile === true && kendo.support.mobileOS || options.mobile === \"phone\" || options.mobile === \"tablet\";\n\n              if (this._isMobile) {\n                var html = this.wrapper.addClass(\"k-grid-mobile\").wrap('<div data-' + kendo.ns + 'stretch=\"true\" data-' + kendo.ns + 'role=\"view\" ' + 'data-' + kendo.ns + 'init-widgets=\"false\"></div>').parent();\n                this.pane = this._createPane(html);\n                this.view = this.pane.view();\n\n                if (options.height) {\n                  this.pane.element.parent().css(HEIGHT, options.height);\n                } else {\n                  this.pane.element.parent().css(HEIGHT, this.wrapper[0].style.height);\n                }\n\n                this._editAnimation = \"slide\"; // Grid transitions should not propagate to the view\n\n                that.wrapper.on(\"transitionend\" + NS, function (e) {\n                  e.stopPropagation();\n                });\n                that.wrapper.on(\"contextmenu\" + NS, \"th a\", function (e) {\n                  e.preventDefault();\n                  return false;\n                });\n                this.view.bind(\"showStart\", function () {\n                  if (that._isLocked()) {\n                    that._updateTablesWidth();\n\n                    that._applyLockedContainersWidth();\n\n                    that._syncLockedContentHeight();\n\n                    that._syncLockedHeaderHeight();\n\n                    that._syncLockedFooterHeight();\n                  }\n                });\n              }\n            },\n            _createPane: function (html) {\n              var pane = kendo.Pane.wrap(html, {\n                viewEngine: {\n                  viewOptions: {\n                    renderOnInit: true,\n                    wrap: false,\n                    wrapInSections: true,\n                    detachOnHide: false,\n                    detachOnDestroy: false\n                  }\n                }\n              });\n              return pane;\n            },\n            _tbody: function () {\n              var that = this,\n                  table = that.table,\n                  tbody;\n              tbody = table.find(\">tbody\");\n\n              if (!tbody.length) {\n                tbody = $(\"<tbody/>\").appendTo(table);\n              }\n\n              that.tbody = tbody.attr(\"role\", \"rowgroup\");\n            },\n            _scrollable: function () {\n              var that = this,\n                  header,\n                  table,\n                  options = that.options,\n                  scrollable = options.scrollable,\n                  hasVirtualScroll = scrollable !== true && scrollable.virtual,\n                  virtualScroll = hasVirtualScroll ? parseVirtualSettings(scrollable.virtual) : null,\n                  scrollbar = !kendo.support.kineticScrollNeeded || virtualScroll && virtualScroll.rows ? kendo.support.scrollbar() : 0,\n                  headerWrap;\n\n              if (scrollable) {\n                header = that.wrapper.children(\".k-grid-header\");\n\n                if (!header[0]) {\n                  header = $('<div class=\"k-grid-header\" />').insertBefore(that.table);\n                } // workaround for IE issue where scroll is not raised if container is same width as the scrollbar\n\n\n                header.css(isRtl ? \"padding-left\" : \"padding-right\", scrollable.virtual ? scrollbar + 1 : scrollbar);\n                table = $('<table role=\"grid\" />');\n                table.width(that.table[0].style.width);\n                table.append(that.thead);\n                header.empty().append($('<div class=\"k-grid-header-wrap k-auto-scrollable\" />').append(table));\n                that.content = that.table.parent();\n                that.virtualScroll = virtualScroll;\n\n                if (that.content.is(\".k-virtual-scrollable-wrap, \" + DOT + classNames.scrollContainer)) {\n                  that.content = that.content.parent();\n                }\n\n                if (!that.content.is(\".k-grid-content, .k-virtual-scrollable-wrap\")) {\n                  that.content = that.table.wrap('<div class=\"k-grid-content k-auto-scrollable\" />').parent();\n                }\n\n                if (virtualScroll && virtualScroll.rows && !that.virtualScrollable) {\n                  that._createVirtualScrollable();\n                }\n\n                if (virtualScroll && virtualScroll.columns) {\n                  that.table.css({\n                    width: sumWidths(visibleLeafColumns(visibleNonLockedColumns(that.columns)))\n                  });\n                }\n\n                headerWrap = header.children(\".k-grid-header-wrap\");\n                that.scrollables = headerWrap.add(that.content); // the footer may exists if rendered from the server\n\n                var footer = that.wrapper.find(\".k-grid-footer\");\n\n                if (footer.length) {\n                  that.scrollables = that.scrollables.add(footer.children(\".k-grid-footer-wrap\"));\n                }\n\n                headerWrap.off(\"scroll\" + NS).on(\"scroll\" + NS, function (e) {\n                  if (that._scrollLeft !== this.scrollLeft) {\n                    kendo.scrollLeft(that.scrollables.not(e.currentTarget), this.scrollLeft);\n                  }\n                });\n\n                if (virtualScroll && virtualScroll.rows) {\n                  that.content.find(\">.k-virtual-scrollable-wrap\").off(\"scroll\" + NS).on(\"scroll\" + NS, function () {\n                    var isScrollingLeft = this.scrollLeft != that._scrollLeft;\n                    that._scrollLeft = this.scrollLeft;\n                    kendo.scrollLeft(that.scrollables, this.scrollLeft);\n\n                    if (that.lockedContent) {\n                      that.lockedContent[0].scrollTop = this.scrollTop;\n                    }\n\n                    if (virtualScroll.columns && isScrollingLeft) {\n                      that.refresh();\n                    }\n                  });\n                } else {\n                  var endless = scrollable.endless;\n                  var originalPageSize = that.dataSource.options.pageSize;\n\n                  if (endless) {\n                    that._endlessPageSize = originalPageSize;\n                  }\n\n                  that.content.off(\"scroll\" + NS).on(\"scroll\" + NS, function (e) {\n                    var isScrollingLeft = this.scrollLeft != that._scrollLeft;\n                    that._scrollLeft = this.scrollLeft;\n                    kendo.scrollLeft(that.scrollables.not(e.currentTarget), that._scrollLeft);\n\n                    if (that.lockedContent && e.currentTarget == that.content[0]) {\n                      that.lockedContent[0].scrollTop = this.scrollTop;\n                    }\n\n                    if (endless) {\n                      if (this.scrollTop + this.clientHeight - this.scrollHeight >= -10 && !that._endlessFetchInProgress && that._endlessPageSize < that.dataSource.total()) {\n                        that._skipRerenderItemsCount = that._endlessPageSize;\n                        that._endlessPageSize = that._endlessPageSize + originalPageSize;\n                        that.dataSource.options.endless = true;\n                        that._endlessFetchInProgress = true;\n                        that.dataSource.pageSize(that._endlessPageSize);\n                      }\n                    }\n\n                    if (virtualScroll && virtualScroll.columns && isScrollingLeft) {\n                      that._virtualColScroll = true;\n\n                      that._cacheEditableState();\n\n                      that.refresh();\n\n                      that._restoreEditableState();\n\n                      that._virtualColScroll = false;\n                    }\n                  });\n                  var touchScroller = that.content.data(\"kendoTouchScroller\");\n\n                  if (touchScroller) {\n                    touchScroller.destroy();\n                  }\n\n                  touchScroller = kendo.touchScroller(that.content);\n\n                  if (touchScroller && touchScroller.movable) {\n                    that.touchScroller = touchScroller;\n                    touchScroller.movable.bind(\"change\", function (e) {\n                      kendo.scrollLeft(that.scrollables, -e.sender.x);\n\n                      if (that.lockedContent) {\n                        that.lockedContent.scrollTop(-e.sender.y);\n                      }\n                    });\n                    that.one(DATABOUND, function (e) {\n                      e.sender.wrapper.addClass(\"k-grid-backface\");\n                    });\n                  }\n                }\n              }\n            },\n            _createVirtualScrollable: function () {\n              var that = this;\n\n              if (that.virtualScrollable) {\n                that.virtualScrollable.destroy();\n              }\n\n              that.virtualScrollable = new VirtualScrollable(that.content, {\n                dataSource: that.dataSource,\n                itemHeight: function () {\n                  return that._averageRowHeight();\n                },\n                page: function () {\n                  that._restoreEditableState();\n                },\n                scroll: function () {\n                  that._focusEditable();\n                },\n                loadStart: function () {\n                  that._progress(true);\n                },\n                loadEnd: function () {\n                  that._progress(false);\n                }\n              });\n              that.virtualScrollable.bind(PAGING, that._onVirtualPaging.bind(that));\n            },\n            _onVirtualPaging: function () {\n              var that = this;\n\n              that._cacheEditableState();\n\n              if (that._isVirtualIncellEditable()) {\n                that._shouldClearEditableState = false;\n                that.closeCell();\n                that._shouldClearEditableState = true;\n              }\n            },\n            _isVirtualEditable: function () {\n              return this._isVirtualIncellEditable() || this._isVirtualInlineEditable() || this._isVirtualPopupEditable();\n            },\n            _isVirtualInlineEditable: function () {\n              return this.virtualScrollable && this._editMode() === INLINE;\n            },\n            _isVirtualIncellEditable: function () {\n              return this.virtualScrollable && this._editMode() === INCELL;\n            },\n            _isVirtualPopupEditable: function () {\n              return this.virtualScrollable && this._editMode() === \"popup\";\n            },\n            _hasVirtualColumns: function () {\n              return (this.virtualScroll || {}).columns ? true : false;\n            },\n            _scrollVirtualWrapper: function () {\n              var that = this;\n              var scrollable = that.virtualScrollable;\n\n              if (that._isVirtualInlineEditable() || that._isVirtualIncellEditable()) {\n                if (scrollable._isScrolledToBottom()) {\n                  scrollable._scrollWrapperToBottom();\n                } else if (scrollable._isScrolledToTop()) {\n                  scrollable._scrollWrapperToTop();\n                }\n              }\n            },\n            _scrollVirtualWrapperOnColumnResize: function () {\n              var virtualScrollable = this.virtualScrollable;\n\n              if (virtualScrollable) {\n                virtualScrollable._scrollWrapperOnColumnResize();\n              }\n            },\n            _restoreEditableState: function () {\n              var that = this;\n              var editableState = that._editableState || {};\n              var editedModel = editableState.model;\n              var dataSource = that.dataSource;\n\n              var inlineMode = that._isVirtualInlineEditable();\n\n              var incellMode = that._isVirtualIncellEditable();\n\n              var virtualColumns = that._hasVirtualColumns();\n\n              var row;\n              var cell;\n\n              if ((inlineMode || incellMode || virtualColumns) && editedModel && dataSource._getByUid(editedModel.uid, dataSource.view())) {\n                if (that._editMode() === INLINE) {\n                  that._shouldClearEditableState = false;\n                  that.editRow(editedModel);\n\n                  if (!virtualColumns) {\n                    that._focusEditable();\n                  }\n                } else if (that._editMode() === INCELL) {\n                  row = that.tbody.children(attrEquals(UNIQUE_ID, editedModel.uid));\n                  cell = $(row).children(attrEquals(FIELD, editableState.field));\n\n                  if (cell[0]) {\n                    that._shouldClearEditableState = false;\n                    that.editCell(cell);\n\n                    if (!virtualColumns) {\n                      that._focusEditable();\n                    }\n                  }\n                }\n              }\n\n              that._shouldClearEditableState = true;\n            },\n            _focusEditable: function () {\n              var that = this;\n              var editedField = (that._editableState || {}).field;\n              var editContainer = that._editContainer;\n\n              if (editContainer && editContainer.length && !contains(editContainer[0], activeElement()) && that._canFocusEditable()) {\n                if (that._isVirtualInlineEditable() || that._hasVirtualColumns()) {\n                  editContainer.find(attrEquals(CONTAINER_FOR, editedField)).find(FOCUSABLE).eq(0).trigger(\"focus\");\n                } else if (that._isVirtualIncellEditable() || that._hasVirtualColumns()) {\n                  editContainer.find(FOCUSABLE).eq(0).trigger(\"focus\");\n                }\n              }\n            },\n            _canFocusEditable: function () {\n              var that = this;\n              var result = (that._isVirtualIncellEditable() || that._isVirtualInlineEditable() || that._hasVirtualColumns()) && (isElementVisibleInWrapper((that.virtualScrollable || {}).wrapper, that._editContainer) || isElementVisibleInWrapper(that.content, that._editContainer));\n              return result;\n            },\n            _cacheEditableState: function () {\n              var that = this;\n              var editContainer = that._editContainer;\n              var editedModel = editContainer ? that._modelForContainer(editContainer) : null;\n\n              var inlineMode = that._isVirtualInlineEditable();\n\n              var incellMode = that._isVirtualIncellEditable();\n\n              var virtualColumns = that._hasVirtualColumns();\n\n              var active;\n              var widget;\n\n              if ((inlineMode || incellMode || virtualColumns) && editedModel) {\n                that._clearEditableState();\n\n                active = $(activeElement());\n\n                if (editContainer && active[0] && contains(editContainer[0], active[0])) {\n                  //change event is not fired if the editable container is scrolled\n                  //out of the virtual view with the mousewheel right after editing\n                  active.change();\n                  widget = kendo.widgetInstance(active, kendo.ui);\n\n                  if (widget && isFunction(widget.value) && active.is(INPUT)) {\n                    widget.value(active.val());\n                    widget.trigger(CHANGE);\n                  }\n                }\n\n                if (that._editMode() === INLINE) {\n                  that._editableState = {\n                    model: editedModel,\n                    field: active.closest(\"[\" + kendo.attr(CONTAINER_FOR) + \"]\").attr(kendo.attr(CONTAINER_FOR))\n                  };\n                } else if (that._editMode() === INCELL) {\n                  that._editableState = {\n                    model: editedModel,\n                    field: editContainer.attr(kendo.attr(FIELD))\n                  };\n                }\n              }\n            },\n            _clearSortClasses: function () {\n              var that = this,\n                  content = that.content || that.table,\n                  lockedContent = that.lockedContent;\n\n              if (content) {\n                content.find(COLGROUP).removeClass(SORTED_CLASS);\n              }\n\n              if (lockedContent) {\n                lockedContent.find(COLGROUP).removeClass(SORTED_CLASS);\n              }\n            },\n            _clearEditableState: function () {\n              var that = this;\n\n              if (that.virtualScrollable || that.virtualScroll && that._hasVirtualColumns()) {\n                that._editableState = null;\n              }\n            },\n            _destroyVirtualScrollable: function () {\n              var that = this;\n\n              that._clearEditableState();\n\n              if (that.virtualScrollable && that.virtualScrollable.element) {\n                that.virtualScrollable.destroy();\n              }\n\n              that.virtualScrollable = null;\n            },\n            _renderNoRecordsContent: function () {\n              var that = this;\n\n              if (that.options.noRecords) {\n                var noRecordsElement = that.table.parent().children('.' + NORECORDSCLASS);\n\n                if (noRecordsElement.length) {\n                  that.angular(\"cleanup\", function () {\n                    return {\n                      elements: noRecordsElement.get()\n                    };\n                  });\n                  noRecordsElement.remove();\n                }\n\n                if (!that.dataSource || !that.dataSource.view().length) {\n                  noRecordsElement = $(that.noRecordsTemplate({})).insertAfter(that.table);\n                  that.angular(\"compile\", function () {\n                    return {\n                      elements: noRecordsElement.get(),\n                      data: [{}]\n                    };\n                  });\n                }\n              }\n            },\n            _setContentWidth: function (scrollLeft) {\n              var that = this,\n                  hiddenDivClass = 'k-grid-content-expander',\n                  hiddenDiv = '<div class=\"' + hiddenDivClass + '\"></div>',\n                  resizable = that.resizable,\n                  expander;\n\n              if (that.options.scrollable && that.wrapper.is(\":visible\")) {\n                expander = that.table.parent().children('.' + hiddenDivClass);\n                that._setContentWidthHandler = that._setContentWidth.bind(that);\n\n                if (!that.dataSource || !that.dataSource.view().length) {\n                  if (!expander[0]) {\n                    expander = $(hiddenDiv).appendTo(that.table.parent());\n\n                    if (resizable) {\n                      resizable.bind(\"resize\", that._setContentWidthHandler);\n                    }\n                  }\n\n                  if (that.thead) {\n                    expander.width(that.thead.width());\n\n                    if (!isNaN(parseFloat(scrollLeft, 10))) {\n                      kendo.scrollLeft(that.content, scrollLeft);\n                    }\n                  }\n                } else if (expander[0]) {\n                  expander.remove();\n\n                  if (resizable) {\n                    resizable.unbind(\"resize\", that._setContentWidthHandler);\n                  }\n                }\n\n                that._applyLockedContainersWidth();\n\n                that._syncLockedContentHeight(); // workaround IE does not show vertical scrollbar for elements without width\n\n\n                if (that.lockedHeader && that.table[0].clientWidth === 0) {\n                  that.table[0].style.width = \"1px\";\n                }\n              }\n            },\n            _applyLockedContainersWidth: function () {\n              if (this.options.scrollable && this.lockedHeader) {\n                var headerTable = this.thead.parent(),\n                    headerWrap = headerTable.parent(),\n                    contentWidth = this.wrapper[0].clientWidth,\n                    groups = this._groups(),\n                    scrollbar = kendo.support.scrollbar(),\n                    cols = this.lockedHeader.find(\">table>colgroup>col:not(.k-group-col, .k-hierarchy-col)\"),\n                    nonLockedCols = headerTable.find(\">colgroup>col:not(.k-group-col, .k-hierarchy-col)\"),\n                    width = columnsWidth(cols),\n                    nonLockedColsWidth = columnsWidth(nonLockedCols),\n                    footerWrap;\n\n                if (groups > 0) {\n                  width += outerWidth(this.lockedHeader.find(\".k-group-cell\").first()) * groups;\n                }\n\n                if (width >= contentWidth) {\n                  width = contentWidth - 3 * scrollbar;\n                }\n\n                this.lockedHeader.add(this.lockedContent).width(width);\n                headerWrap[0].style.width = headerWrap.parent().width() - width - 2 + \"px\";\n                headerTable.add(this.table).width(nonLockedColsWidth); //https://github.com/telerik/kendo-ui-core/issues/377\n\n                if (this.virtualScrollable && !isIE11) {\n                  contentWidth -= scrollbar;\n                }\n\n                this.content[0].style.width = contentWidth - width - 1 + \"px\";\n\n                if (this.lockedFooter && this.lockedFooter.length) {\n                  this.lockedFooter.width(width);\n                  footerWrap = this.footer.find(\".k-grid-footer-wrap\");\n                  footerWrap[0].style.width = headerWrap[0].clientWidth + \"px\";\n                  footerWrap.children().first().width(nonLockedColsWidth);\n                }\n              }\n            },\n            _setContentHeight: function () {\n              var that = this,\n                  options = that.options,\n                  height,\n                  header = that.wrapper.children(\".k-grid-header\"),\n                  scrollbar = kendo.support.scrollbar();\n              var scrollableHeight = (options.scrollable || {}).height;\n\n              if (options.scrollable && that.wrapper.is(\":visible\")) {\n                if (scrollableHeight && that.content[0].style.height === \"\") {\n                  // fallback to client-side setting as ASP.NET MVC Core wrapper does not provide server rendering of the content\n                  that.content[0].style.height = scrollableHeight;\n                }\n\n                height = that.wrapper.innerHeight();\n                height -= outerHeight(header);\n\n                if (that.pager && that.pager.element.is(\":visible\")) {\n                  height -= outerHeight(that.pager.element);\n                }\n\n                if (options.groupable) {\n                  height -= outerHeight(that.wrapper.children(\".k-grouping-header\"));\n                }\n\n                if (options.toolbar) {\n                  height -= outerHeight(that.wrapper.children(\".k-grid-toolbar\"));\n                }\n\n                if (that.footerTemplate) {\n                  height -= outerHeight(that.wrapper.children(\".k-grid-footer\"));\n                }\n\n                var isGridHeightSet = function (el) {\n                  var initialHeight, newHeight;\n\n                  if (el[0].style.height) {\n                    return true;\n                  } else {\n                    initialHeight = el.height();\n                  }\n\n                  el.height(\"auto\");\n                  newHeight = el.height();\n\n                  if (initialHeight != newHeight) {\n                    el.height(\"\");\n                    return true;\n                  }\n\n                  el.height(\"\");\n                  return false;\n                };\n\n                if (isGridHeightSet(that.wrapper)) {\n                  // set content height only if needed\n                  if (height > scrollbar * 2) {\n                    // do not set height if proper scrollbar cannot be displayed\n                    if (that.lockedContent) {\n                      scrollbar = that.table[0].offsetWidth > that.table.parent()[0].clientWidth ? scrollbar : 0;\n                      that.lockedContent.height(height - scrollbar);\n                    }\n\n                    that.content.height(height);\n                  } else {\n                    that.content.height(scrollbar * 2 + 1);\n                  }\n                }\n              }\n            },\n            _averageRowHeight: function () {\n              var that = this,\n                  itemsCount = that._items(that.tbody, true).length,\n                  rowHeight = that._rowHeight;\n\n              if (itemsCount === 0) {\n                return rowHeight;\n              }\n\n              if (!that._rowHeight) {\n                that._rowHeight = rowHeight = outerHeight(that.table) / itemsCount;\n                that._sum = rowHeight;\n                that._measures = 1;\n              }\n\n              var currentRowHeight = outerHeight(that.table) / itemsCount;\n\n              if (rowHeight !== currentRowHeight) {\n                that._measures++;\n                that._sum += currentRowHeight;\n                that._rowHeight = that._sum / that._measures;\n              }\n\n              return rowHeight;\n            },\n            _dataSource: function () {\n              var that = this,\n                  options = that.options,\n                  pageable,\n                  dataSource = options.dataSource;\n              dataSource = isArray(dataSource) ? {\n                data: dataSource\n              } : dataSource;\n\n              if (isPlainObject(dataSource)) {\n                extend(dataSource, {\n                  table: that.table,\n                  fields: that.columns\n                });\n                pageable = options.pageable;\n\n                if (isPlainObject(pageable) && pageable.pageSize !== undefined) {\n                  dataSource.pageSize = pageable.pageSize;\n                }\n              }\n\n              if (that.dataSource && that._refreshHandler) {\n                that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(PROGRESS, that._progressHandler).unbind(ERROR, that._errorHandler).unbind(SORT, that._sortHandler);\n              } else {\n                that._refreshHandler = that.refresh.bind(that);\n                that._progressHandler = that._requestStart.bind(that);\n                that._errorHandler = that._error.bind(that);\n                that._sortHandler = that._clearSortClasses.bind(that);\n              }\n\n              that.dataSource = DataSource.create(dataSource).bind(CHANGE, that._refreshHandler).bind(PROGRESS, that._progressHandler).bind(ERROR, that._errorHandler).bind(SORT, that._sortHandler);\n            },\n            _error: function () {\n              this._progress(false);\n            },\n            _requestStart: function () {\n              this._progress(true);\n            },\n            _modelChange: function (e) {\n              var that = this,\n                  tbody = that.tbody,\n                  model = e.model,\n                  row = that.tbody.find(\"tr[\" + kendo.attr(\"uid\") + \"=\" + model.uid + \"]\"),\n                  relatedRow,\n                  cell,\n                  column,\n                  isAlt = row.hasClass(\"k-alt\"),\n                  tmp,\n                  idx = that._items(tbody).index(row),\n                  isLocked = that.lockedContent,\n                  selectable,\n                  selectableRow,\n                  childCells,\n                  originalCells,\n                  length;\n\n              if (isLocked) {\n                relatedRow = that._relatedRow(row);\n              }\n\n              if (row.add(relatedRow).children(\".k-edit-cell\").length && !that.options.rowTemplate) {\n                row.add(relatedRow).children(\":not(.k-group-cell,.k-hierarchy-cell)\").each(function () {\n                  cell = $(this);\n                  column = leafColumns(that.columns)[that._calculateColumnIndex(cell)];\n\n                  if (column.field === e.field) {\n                    if (!cell.hasClass(\"k-edit-cell\")) {\n                      that._displayCell(cell, column, model);\n                    } else {\n                      cell.addClass(\"k-dirty-cell\");\n                    }\n                  }\n                });\n              } else if (!row.hasClass(\"k-grid-edit-row\")) {\n                selectableRow = $().add(row);\n\n                if (isLocked) {\n                  tmp = (isAlt ? that.lockedAltRowTemplate : that.lockedRowTemplate)(model);\n                  selectableRow = selectableRow.add(relatedRow);\n                  relatedRow.replaceWith(tmp);\n                }\n\n                that.angular(\"cleanup\", function () {\n                  return {\n                    elements: selectableRow.get()\n                  };\n                });\n                tmp = (isAlt ? that.altRowTemplate : that.rowTemplate)(model);\n                row.replaceWith(tmp);\n                tmp = that._items(tbody).eq(idx);\n                var angularData = [{\n                  dataItem: model\n                }];\n\n                if (isLocked) {\n                  row = row.add(relatedRow);\n                  relatedRow = that._relatedRow(tmp)[0];\n                  adjustRowHeight(tmp[0], relatedRow);\n                  tmp = tmp.add(relatedRow);\n                  angularData.push({\n                    dataItem: model\n                  });\n                }\n\n                that.angular(\"compile\", function () {\n                  return {\n                    elements: tmp.get(),\n                    data: angularData\n                  };\n                });\n                selectable = that.options.selectable;\n\n                if ((selectable || that._checkBoxSelection) && row.hasClass(\"k-state-selected\")) {\n                  that.select(tmp);\n                }\n\n                originalCells = selectableRow.children(\":not(.k-group-cell,.k-hierarchy-cell)\");\n                childCells = tmp.children(\":not(.k-group-cell,.k-hierarchy-cell)\");\n\n                for (idx = 0, length = that.columns.length; idx < length; idx++) {\n                  column = that.columns[idx];\n                  cell = childCells.eq(idx);\n\n                  if (selectable && originalCells.eq(idx).hasClass(\"k-state-selected\")) {\n                    cell.addClass(\"k-state-selected\");\n                  }\n                }\n\n                that.trigger(\"itemChange\", {\n                  item: tmp,\n                  data: model,\n                  ns: ui\n                });\n              }\n            },\n            _pageable: function () {\n              var that = this,\n                  pagerWrap,\n                  pageable = that.options.pageable,\n                  navigatable = that.options.navigatable;\n\n              if (pageable) {\n                pagerWrap = that.wrapper.children(\"div.k-grid-pager\");\n\n                if (!pagerWrap.length) {\n                  pagerWrap = $('<div class=\"k-pager-wrap k-grid-pager\"/>');\n                }\n\n                if (pageable.position === \"top\") {\n                  pagerWrap.prependTo(that.wrapper).addClass(\"k-grid-pager-top\");\n                } else {\n                  pagerWrap.appendTo(that.wrapper);\n                }\n\n                if (that.pager) {\n                  that.pager.destroy();\n                }\n\n                if (typeof pageable === \"object\" && pageable instanceof kendo.ui.Pager) {\n                  that.pager = pageable;\n                } else {\n                  if (that.dataSource._groupPaging) {\n                    that.pager = new GroupsPager(pagerWrap, extend({}, pageable, {\n                      dataSource: that.dataSource,\n                      navigatable: navigatable\n                    }));\n                  } else {\n                    that.pager = new kendo.ui.Pager(pagerWrap, extend({}, pageable, {\n                      dataSource: that.dataSource,\n                      navigatable: navigatable\n                    }));\n                  }\n                }\n\n                that.pager.bind(\"pageChange\", function (e) {\n                  if (that.trigger(\"page\", {\n                    page: e.index\n                  })) {\n                    e.preventDefault();\n                  }\n                });\n\n                that._togglePagerVisibility();\n              }\n            },\n            _footer: function () {\n              var that = this,\n                  aggregates = that.dataSource.aggregates(),\n                  html = \"\",\n                  footerTemplate = that.footerTemplate,\n                  options = that.options,\n                  footerWrap,\n                  footer = that.footer || that.wrapper.find(\".k-grid-footer\");\n\n              if (footerTemplate) {\n                html = $(that._wrapFooter(footerTemplate(aggregates)));\n\n                if (footer.length) {\n                  var tmp = html;\n                  that.angular(\"cleanup\", function () {\n                    return {\n                      elements: footer.get()\n                    };\n                  });\n                  footer.replaceWith(tmp);\n                  footer = that.footer = tmp;\n                } else {\n                  if (options.scrollable) {\n                    footer = that.footer = options.pageable && options.pageable.position !== \"top\" ? html.insertBefore(that.wrapper.children(\"div.k-grid-pager\")) : html.appendTo(that.wrapper);\n                  } else {\n                    footer = that.footer = html.insertAfter(that.tbody);\n                  }\n                }\n\n                that.angular(\"compile\", function () {\n                  return {\n                    elements: footer.find(\"td:not(.k-group-cell, .k-hierarchy-cell)\").get(),\n                    data: map(that.columns, function (col) {\n                      return {\n                        column: col,\n                        aggregate: aggregates[col.field]\n                      };\n                    })\n                  };\n                });\n              } else if (footer && !that.footer) {\n                that.footer = footer;\n              }\n\n              if (footer.length) {\n                if (options.scrollable) {\n                  footerWrap = footer.attr(\"tabindex\", -1).children(\".k-grid-footer-wrap\");\n                  that.scrollables = $(that.scrollables.filter(function () {\n                    return !$(this).is(\".k-grid-footer-wrap\");\n                  }).toArray()).add(footerWrap);\n                }\n\n                if (that._footerWidth) {\n                  footer.find(\"table\").css('width', that._footerWidth);\n                }\n\n                if (footerWrap) {\n                  var offset = kendo.scrollLeft(that.content);\n\n                  if (options.scrollable !== true && that.virtualScroll && that.virtualScroll.rows) {\n                    offset = kendo.scrollLeft(that.wrapper.find('.k-virtual-scrollable-wrap'));\n                  }\n\n                  kendo.scrollLeft(footerWrap, offset);\n                }\n              }\n\n              if (that.lockedContent) {\n                that._appendLockedColumnFooter();\n\n                that._applyLockedContainersWidth();\n\n                that._syncLockedFooterHeight();\n              }\n            },\n            _wrapFooter: function (footerRow) {\n              var that = this,\n                  html = \"\",\n                  scrollbar = !kendo.support.mobileOS ? kendo.support.scrollbar() : 0;\n\n              if (that.options.scrollable) {\n                html = $('<div class=\"k-grid-footer\"><div class=\"k-grid-footer-wrap\"><table><tbody>' + footerRow + '</tbody></table></div></div>');\n\n                that._appendCols(html.find(\"table\"));\n\n                html.css(isRtl ? \"padding-left\" : \"padding-right\", scrollbar); // Update inner fix.\n\n                return html;\n              }\n\n              return '<tfoot class=\"k-grid-footer\">' + footerRow + '</tfoot>';\n            },\n            _columnMenu: function () {\n              var that = this,\n                  menu,\n                  columns = leafColumns(that.columns),\n                  column,\n                  options = that.options,\n                  columnMenu = options.columnMenu,\n                  menuOptions,\n                  sortable,\n                  filterable,\n                  cells,\n                  hasMultiColumnHeaders = grep(that.columns, function (item) {\n                return item.columns !== undefined;\n              }).length > 0,\n                  hasLockableColumns = grep(that.columns, function (item) {\n                return item.lockable !== false;\n              }).length > 0,\n                  hasStickableColumns = grep(that.columns, function (item) {\n                return item.stickable === true;\n              }).length > 0,\n                  isMobile = this._isMobile,\n                  initCallback = function (e) {\n                that.trigger(COLUMNMENUINIT, {\n                  field: e.field,\n                  container: e.container\n                });\n              },\n                  openCallback = function (e) {\n                that.trigger(COLUMNMENUOPEN, {\n                  field: e.field,\n                  container: e.container\n                });\n              },\n                  closeCallback = function (element) {\n                focusTable(element.closest(\"table\"), true);\n              },\n                  stickCallback = function (e) {\n                that.trigger(COLUMNSTICK, {\n                  column: e.column\n                });\n              },\n                  unstickCallback = function (e) {\n                that.trigger(COLUMNUNSTICK, {\n                  column: e.column\n                });\n              },\n                  sortHandler = function (e) {\n                if (that.trigger(\"sort\", {\n                  sort: e.sort\n                })) {\n                  e.preventDefault();\n                } else {\n                  that._clearEditableState();\n\n                  if (that.dataSource.options.endless) {\n                    that._resetEndless();\n                  }\n                }\n              },\n                  filterHandler = function (e) {\n                if (that.trigger(\"filter\", {\n                  filter: e.filter,\n                  field: e.field\n                })) {\n                  e.preventDefault();\n                } else {\n                  that._clearEditableState();\n\n                  if (that.dataSource.options.endless) {\n                    that._resetEndless();\n                  }\n                }\n              },\n                  $angular = options.$angular;\n\n              if (columnMenu) {\n                if (typeof columnMenu == \"boolean\") {\n                  columnMenu = {};\n                }\n\n                that._setColumnsMediaVisibility(columns);\n\n                cells = leafDataCells(that.thead);\n\n                for (var idx = 0, length = cells.length; idx < length; idx++) {\n                  column = columns[idx];\n                  var cell = cells.eq(idx);\n\n                  if (!column.command && (column.field || cell.attr(\"data-\" + kendo.ns + \"field\"))) {\n                    menu = cell.data(\"kendoColumnMenu\");\n\n                    if (menu) {\n                      menu.destroy();\n                    }\n\n                    sortable = column.sortable !== false && columnMenu.sortable !== false && options.sortable !== false ? extend({}, options.sortable, {\n                      compare: (column.sortable || {}).compare\n                    }) : false;\n                    filterable = options.filterable && column.filterable !== false && columnMenu.filterable !== false ? extend({\n                      pane: that.pane\n                    }, options.filterable, column.filterable) : false;\n\n                    if (column.filterable && column.filterable.dataSource) {\n                      filterable.forceUnique = false;\n                      filterable.checkSource = column.filterable.dataSource;\n                    }\n\n                    if (filterable) {\n                      filterable.format = column.format;\n                    }\n\n                    menuOptions = {\n                      dataSource: that.dataSource,\n                      values: column.values,\n                      columns: columnMenu.columns,\n                      sortable: sortable,\n                      filterable: filterable,\n                      messages: columnMenu.messages,\n                      owner: that,\n                      closeCallback: closeCallback,\n                      init: initCallback,\n                      open: openCallback,\n                      stick: stickCallback,\n                      unstick: unstickCallback,\n                      pane: that.pane,\n                      sort: sortHandler,\n                      filtering: filterHandler,\n                      filter: isMobile ? \":not(.k-column-active)\" : \"\",\n                      hasLockableColumns: lockedColumns(columns).length > 0 && hasLockableColumns && !hasMultiColumnHeaders,\n                      hasStickableColumns: hasStickableColumns && !hasMultiColumnHeaders,\n                      encodeTitles: that.options.encodeTitles,\n                      componentType: columnMenu.componentType,\n                      appendTo: DOT + classNames.headerCellInner\n                    };\n\n                    if ($angular) {\n                      menuOptions.$angular = $angular;\n                    }\n\n                    cell.kendoColumnMenu(menuOptions);\n                  }\n                }\n              }\n            },\n            _headerCells: function () {\n              return $(this.thead).find(\"th\").filter(function () {\n                var th = $(this);\n                return !th.hasClass(\"k-group-cell\") && !th.hasClass(\"k-hierarchy-cell\");\n              });\n            },\n            _hasFilterMenu: function () {\n              var filterable = this.options.filterable;\n\n              if (filterable && typeof filterable.mode == STRING && filterable.mode.indexOf(\"menu\") == -1) {\n                return false;\n              }\n\n              return filterable;\n            },\n            _filterable: function () {\n              var that = this,\n                  columns = leafColumns(that.columns),\n                  filterMenu,\n                  cells,\n                  cell,\n                  filterInit = function (e) {\n                that.trigger(FILTERMENUINIT, {\n                  field: e.field,\n                  container: e.container\n                });\n              },\n                  closeCallback = function (element) {\n                focusTable(element.closest(\"table\"), true);\n              },\n                  filterHandler = function (e) {\n                if (that.trigger(\"filter\", {\n                  filter: e.filter,\n                  field: e.field\n                })) {\n                  e.preventDefault();\n                } else {\n                  that._clearEditableState();\n\n                  if (that.dataSource.options.endless) {\n                    that._resetEndless();\n                  }\n                }\n              },\n                  filterOpen = function (e) {\n                that.trigger(FILTERMENUOPEN, {\n                  field: e.field,\n                  container: e.container\n                });\n              },\n                  filterable = that._hasFilterMenu();\n\n              if (filterable && !that.options.columnMenu) {\n                cells = leafDataCells(that.thead); //that._headerCells();\n\n                for (var idx = 0, length = cells.length; idx < length; idx++) {\n                  cell = cells.eq(idx);\n\n                  if (columns[idx].filterable !== false && !columns[idx].command && (columns[idx].field || cell.attr(\"data-\" + kendo.ns + \"field\"))) {\n                    filterMenu = cell.data(\"kendoFilterMenu\");\n\n                    if (filterMenu) {\n                      filterMenu.destroy();\n                    }\n\n                    filterMenu = cell.data(\"kendoFilterMultiCheck\");\n\n                    if (filterMenu) {\n                      filterMenu.destroy();\n                    }\n\n                    var columnFilterable = columns[idx].filterable;\n                    var options = extend({}, filterable, columnFilterable, {\n                      dataSource: that.dataSource,\n                      values: columns[idx].values,\n                      format: columns[idx].format,\n                      closeCallback: closeCallback,\n                      title: columns[idx].title || columns[idx].field,\n                      init: filterInit,\n                      open: filterOpen,\n                      pane: that.pane,\n                      change: filterHandler,\n                      appendTo: DOT + classNames.headerCellInner\n                    });\n\n                    if (columnFilterable && columnFilterable.messages) {\n                      options.messages = extend(true, {}, filterable.messages, columnFilterable.messages);\n                    }\n\n                    if (columnFilterable && columnFilterable.dataSource) {\n                      options.forceUnique = false;\n                      options.checkSource = columnFilterable.dataSource;\n                    }\n\n                    if (columnFilterable && columnFilterable.multi) {\n                      cell.kendoFilterMultiCheck(options);\n                    } else {\n                      cell.kendoFilterMenu(options);\n                    }\n                  }\n                }\n              }\n            },\n            _filterRow: function () {\n              var that = this;\n\n              if (!that._hasFilterRow()) {\n                return;\n              }\n\n              var settings;\n              var $angular = that.options.$angular;\n\n              var columns = leafColumns(that.columns),\n                  filterable = that.options.filterable,\n                  rowheader = that.thead.find(\".k-filter-row\"),\n                  filterHandler = function (e) {\n                if (that.trigger(\"filter\", {\n                  filter: e.filter,\n                  field: e.field\n                })) {\n                  e.preventDefault();\n                } else {\n                  that._clearEditableState();\n\n                  if (that.dataSource.options.endless) {\n                    that._resetEndless();\n                  }\n                }\n              };\n\n              this._updateHeader(this.dataSource.group().length);\n\n              for (var i = 0; i < columns.length; i++) {\n                var suggestDataSource,\n                    col = columns[i],\n                    operators = that.options.filterable.operators,\n                    customDataSource = false,\n                    th = $(\"<th/>\"),\n                    field = col.field;\n\n                if (col.hidden) {\n                  th.hide();\n                }\n\n                rowheader.append(th);\n\n                if (field && col.filterable !== false) {\n                  var cellOptions = col.filterable && col.filterable.cell || {};\n                  suggestDataSource = that.options.dataSource;\n\n                  if (suggestDataSource instanceof DataSource) {\n                    suggestDataSource = that.options.dataSource.options;\n                  }\n\n                  var messages = extend(true, {}, filterable.messages);\n\n                  if (col.filterable) {\n                    extend(true, messages, col.filterable.messages);\n                  }\n\n                  if (cellOptions.enabled === false) {\n                    th.html(\"&nbsp;\");\n                    continue;\n                  }\n\n                  if (cellOptions.dataSource) {\n                    suggestDataSource = cellOptions.dataSource;\n                    customDataSource = true;\n                  }\n\n                  if (col.filterable && col.filterable.operators) {\n                    operators = col.filterable.operators;\n                  }\n\n                  settings = {\n                    column: col,\n                    dataSource: that.dataSource,\n                    suggestDataSource: suggestDataSource,\n                    customDataSource: customDataSource,\n                    field: field,\n                    messages: messages,\n                    values: col.values,\n                    template: cellOptions.template,\n                    delay: cellOptions.delay,\n                    inputWidth: cellOptions.inputWidth,\n                    suggestionOperator: cellOptions.suggestionOperator,\n                    minLength: cellOptions.minLength,\n                    dataTextField: cellOptions.dataTextField,\n                    operator: cellOptions.operator,\n                    operators: operators,\n                    showOperators: cellOptions.showOperators,\n                    change: filterHandler\n                  };\n\n                  if ($angular) {\n                    settings.$angular = $angular;\n                  }\n\n                  $(\"<span/>\").attr(kendo.attr(\"field\"), field).appendTo(th).kendoFilterCell(settings);\n                } else {\n                  th.html(\"&nbsp;\");\n                }\n\n                th.data(\"column\", col);\n              }\n            },\n            _sortable: function () {\n              var that = this,\n                  columns = leafColumns(that.columns),\n                  column,\n                  sorterInstance,\n                  cell,\n                  sortable = that.options.sortable,\n                  sortHandler = function (e) {\n                if (that.trigger(\"sort\", {\n                  sort: e.sort\n                })) {\n                  e.preventDefault();\n                } else {\n                  that._clearEditableState();\n                }\n              };\n\n              if (sortable) {\n                var cells = leafDataCells(that.thead);\n\n                for (var idx = 0, length = cells.length; idx < length; idx++) {\n                  column = columns[idx];\n\n                  if (column.sortable !== false && !column.command && column.field) {\n                    cell = cells.eq(idx);\n                    sorterInstance = cell.data(\"kendoColumnSorter\");\n\n                    if (sorterInstance) {\n                      sorterInstance.destroy();\n                    }\n\n                    cell.attr(\"data-\" + kendo.ns + \"field\", column.field).kendoColumnSorter(extend({}, sortable, column.sortable, {\n                      dataSource: that.dataSource,\n                      aria: true,\n                      filter: \":not(.k-column-active)\",\n                      change: sortHandler\n                    }));\n                  }\n                }\n\n                cells = null;\n              }\n            },\n            _columns: function (columns) {\n              var that = this,\n                  table = that.table,\n                  encoded,\n                  cols = table.find(\"col\"),\n                  lockedCols,\n                  headerRows = that.element.find('thead tr'),\n                  dataSource = that.options.dataSource,\n                  draggableColumns; // using HTML5 data attributes as a configuration option e.g. <th data-field=\"foo\">Foo</foo>\n\n              columns = columns.length ? columns : map(table.find(\"th:not(.k-group-cell):not(.k-hierarchy-cell)\"), function (th, idx) {\n                th = $(th);\n                var sortable = th.attr(kendo.attr(\"sortable\")),\n                    filterable = th.attr(kendo.attr(\"filterable\")),\n                    type = th.attr(kendo.attr(\"type\")),\n                    groupable = th.attr(kendo.attr(\"groupable\")),\n                    field = th.attr(kendo.attr(\"field\")),\n                    title = th.attr(kendo.attr(\"title\")),\n                    menu = th.attr(kendo.attr(\"menu\"));\n\n                if (!field) {\n                  field = th.text().replace(/\\s|[^A-z0-9]/g, \"\");\n                }\n\n                return {\n                  field: field,\n                  type: type,\n                  title: title,\n                  sortable: sortable !== \"false\",\n                  filterable: filterable !== \"false\",\n                  groupable: groupable !== \"false\",\n                  menu: menu !== \"false\",\n                  template: th.attr(kendo.attr(\"template\")),\n                  width: cols.eq(idx).css(\"width\")\n                };\n              });\n              encoded = !(that.table.find(\"tbody tr\").length > 0 && (!dataSource || !dataSource.transport));\n\n              if (that.options.scrollable) {\n                var initialColumns = columns;\n                lockedCols = lockedColumns(columns);\n                columns = nonLockedColumns(columns);\n\n                if (lockedCols.length > 0 && columns.length === 0) {\n                  throw new Error(\"There should be at least one non locked column\");\n                }\n\n                normalizeHeaderCells(that.element.find(\"tr:has(th)\").first(), initialColumns);\n                columns = lockedCols.concat(columns);\n              }\n\n              if (headerRows.length && columns.length) {\n                that._updateColumnIDs(columns, headerRows.first());\n              }\n\n              that.columns = normalizeColumns(columns, encoded);\n\n              if ($.grep(leafColumns(that.columns), function (col) {\n                return col.selectable;\n              }).length) {\n                that._selectedIds = {};\n                that._checkBoxSelection = true;\n                that.wrapper.on(CLICK + NS, \"tbody > tr \" + CHECKBOXINPUT, that._checkboxClick.bind(that));\n                that.wrapper.on(CLICK + NS, \"thead > tr \" + CHECKBOXINPUT, that._headerCheckboxClick.bind(that));\n              }\n\n              draggableColumns = $.grep(leafColumns(that.columns), function (col) {\n                return col.draggable;\n              });\n\n              if (draggableColumns.length) {\n                that._hasDragHandleColumn = true;\n\n                for (var i = 0; i < draggableColumns.length; i++) {\n                  draggableColumns[i].headerAttributes = $.extend({\n                    \"aria-label\": that.options.messages.dragHandleLabel\n                  }, draggableColumns[i].headerAttributes);\n                }\n              }\n\n              that._foreignKeyBindings(that.columns);\n            },\n            _foreignKeyBindings: function (columns) {\n              var that = this;\n              var length = columns.length;\n              var column;\n\n              for (var i = 0; i < length; i++) {\n                column = columns[i];\n\n                if (column.dataSource) {\n                  that._fetchForeignKeyValues(column);\n                }\n              }\n            },\n            _fetchForeignKeyValues: function (column) {\n              var that = this;\n              var promise = $.Deferred();\n              that._hasBoundForeignKey = true;\n              column.dataSource = DataSource.create(column.dataSource);\n\n              if (!that._foreignKeyPromises) {\n                that._foreignKeyPromises = [];\n              }\n\n              that._foreignKeyPromises.push(promise);\n\n              column.dataSource.fetch().then(function () {\n                var data = column.dataSource.data();\n                column.values = data.map(function (item) {\n                  return {\n                    value: item[column.dataValueField],\n                    text: item[column.dataTextField]\n                  };\n                });\n                promise.resolve();\n              });\n            },\n            _updateColumnIDs: function (columns, tr) {\n              if (!columns.length) {\n                return;\n              }\n\n              var ths = tr.find(\"th:not(.k-group-cell):not(.k-hierarchy-cell)\");\n              var id;\n\n              for (var i = 0; i < columns.length; i++) {\n                id = ths.eq(i).attr(\"id\");\n\n                if (id) {\n                  columns[i].headerAttributes = extend(columns[i].headerAttributes, {\n                    id: id\n                  });\n                }\n              }\n\n              this._updateColumnIDs(childColumns(columns), tr.next());\n            },\n            _headerCheckboxClick: function (e) {\n              var that = this,\n                  checkBox = $(e.target),\n                  checked = checkBox.prop(\"checked\");\n\n              if (!that._belongsToGrid(checkBox)) {\n                return;\n              }\n\n              if (checked) {\n                that.select(that.items());\n              } else {\n                that.clearSelection();\n              }\n            },\n            _checkboxClick: function (e) {\n              var that = this,\n                  row = $(e.target).closest(\"tr\"),\n                  isSelecting = !row.hasClass(SELECTED);\n\n              if (!that._belongsToGrid(row)) {\n                return;\n              }\n\n              if (isSelecting) {\n                that.select(row);\n              } else {\n                that._deselectCheckRows(row);\n              }\n            },\n            _groups: function () {\n              var group = this.dataSource.group();\n              return group ? group.length : 0;\n            },\n            _tmpl: function (rowTemplate, columns, alt, skipGroupCells) {\n              var that = this,\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  paramName = settings.paramName,\n                  idx,\n                  length = columns.length,\n                  template,\n                  state = {\n                storage: {},\n                count: 0\n              },\n                  column,\n                  type,\n                  hasDetails = that._hasDetails(),\n                  className = [],\n                  groups = that._groups(),\n                  navigatable = that.options.navigatable;\n\n              var fieldAttr = kendo.attr(\"field\");\n              var field;\n              var dirtyCellTemplate = \"\";\n\n              if (!rowTemplate) {\n                rowTemplate = \"<tr\";\n\n                if (alt) {\n                  className.push(\"k-alt\");\n                }\n\n                className.push(\"k-master-row\");\n\n                if (className.length) {\n                  rowTemplate += ' class=\"' + className.join(\" \") + '\"';\n                }\n\n                if (length) {\n                  // data item is an object\n                  rowTemplate += ' ' + kendo.attr(\"uid\") + '=\"#=' + kendo.expr(\"uid\", settings.paramName) + '#\"';\n                }\n\n                rowTemplate += \" role='row'>\";\n\n                if (groups > 0 && !skipGroupCells) {\n                  rowTemplate += groupCells(groups);\n                }\n\n                if (hasDetails) {\n                  rowTemplate += '<td class=\"k-hierarchy-cell\" aria-expanded=\"false\"><a class=\"k-icon k-i-expand\" href=\"\\\\#\" ' + ARIALABEL + '=\"' + EXPAND + '\" tabindex=\"-1\"></a></td>';\n                }\n\n                for (idx = 0; idx < length; idx++) {\n                  column = columns[idx];\n                  template = column.template;\n                  type = typeof template;\n                  field = column.field;\n\n                  if (that._editMode() === INCELL && field) {\n                    column.attributes = column.attributes || {};\n\n                    if (that.virtualScroll) {\n                      column.attributes[fieldAttr] = field;\n                    }\n\n                    dirtyCellTemplate = that._dirtyCellTemplate(field, paramName);\n                    column.attributes[\"class\"] = column.attributes[\"class\"] || \"\";\n\n                    if (column.attributes[\"class\"].indexOf(dirtyCellTemplate) < 0) {\n                      column.attributes[\"class\"] += dirtyCellTemplate;\n                    }\n                  }\n\n                  if (column.colSpan && column.colSpan > 0 && hasHiddenStyle(column.attributes)) {\n                    //virtual cell should be visible at all times\n                    column.attributes = removeHiddenStyle(column.attributes);\n                  } else if (!column.colSpan && column.hidden) {\n                    column.attributes = addHiddenStyle(column.attributes);\n                  }\n\n                  if (column.command) {\n                    column.attributes = column.attributes || {};\n\n                    if (typeof column.attributes[\"class\"] !== \"undefined\") {\n                      column.attributes[\"class\"] += \" k-command-cell\";\n                    } else {\n                      column.attributes[\"class\"] = \"k-command-cell\";\n                    }\n                  }\n\n                  if (column.draggable) {\n                    column.attributes = column.attributes || {};\n\n                    if (typeof column.attributes[\"class\"] !== \"undefined\") {\n                      column.attributes[\"class\"] += \" k-drag-cell k-touch-action-none\";\n                    } else {\n                      column.attributes[\"class\"] = \"k-drag-cell k-touch-action-none\";\n                    }\n\n                    if (typeof column.attributes[\"aria-label\"] === \"undefined\") {\n                      column.attributes[\"aria-label\"] = that.options.messages.dragHandleLabel;\n                    }\n\n                    if (typeof column.attributes.style !== \"undefined\") {\n                      column.attributes.style += \" cursor: move;\";\n                    } else {\n                      column.attributes.style = \"cursor: move;\";\n                    }\n                  }\n\n                  rowTemplate += \"<td\" + stringifyAttributes(column.attributes);\n\n                  if (navigatable && !column.draggable) {\n                    rowTemplate += \" aria-describedby='\" + column.headerAttributes.id + \"'\";\n                  }\n\n                  if (column.colSpan) {\n                    if (column.colSpan > 1) {\n                      rowTemplate += \" \" + kendo.attr(\"virtual\");\n                    }\n\n                    rowTemplate += \" colSpan='\" + column.colSpan + \"'\";\n                  }\n\n                  rowTemplate += \" role='gridcell'>\";\n                  rowTemplate += that._cellTmpl(column, state);\n                  rowTemplate += \"</td>\";\n                }\n\n                rowTemplate += \"</tr>\";\n              }\n\n              rowTemplate = kendo.template(rowTemplate, settings);\n\n              if (state.count > 0) {\n                return rowTemplate.bind(state.storage);\n              }\n\n              return rowTemplate;\n            },\n            _dirtyCellTemplate: function (field, paramName) {\n              var dirtyField;\n\n              if (field && paramName) {\n                dirtyField = field.charAt(0) === \"[\" ? kendo.expr(field, paramName + \".dirtyFields\") : paramName + \".dirtyFields['\" + field + \"']\";\n                return \"#= \" + paramName + \" && \" + paramName + \".dirty && \" + paramName + \".dirtyFields && \" + dirtyField + \" ? ' k-dirty-cell' : '' #\";\n              }\n\n              return \"\";\n            },\n            _headerCellText: function (column) {\n              var that = this,\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  template = column.headerTemplate,\n                  type = typeof template,\n                  text = column.title && (that.options.encodeTitles ? htmlEncode(column.title) : column.title) || column.field || \"\";\n\n              if (type === FUNCTION) {\n                text = kendo.template(template, settings)({});\n              } else if (type === STRING) {\n                text = template;\n              }\n\n              return text;\n            },\n            _cellTmpl: function (column, state) {\n              var that = this,\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  template = column.template,\n                  paramName = settings.paramName,\n                  field = column.field,\n                  html = \"\",\n                  idx,\n                  length,\n                  format = column.format,\n                  type = typeof template,\n                  columnValues = column.values;\n\n              if (column.command) {\n                if (isArray(column.command)) {\n                  for (idx = 0, length = column.command.length; idx < length; idx++) {\n                    if (column.command[idx].visible) {\n                      html += kendo.format(\"#= {0}(data)? '{1}':'' #\", column.command[idx].visible, that._createButton(column.command[idx]).replace(templateHashRegExp, \"\\\\#\").replace(/'/ig, \"\\\\'\"));\n                    } else {\n                      html += that._createButton(column.command[idx]).replace(templateHashRegExp, \"\\\\#\");\n                    }\n                  }\n\n                  return html;\n                }\n\n                return that._createButton(column.command).replace(templateHashRegExp, \"\\\\#\");\n              }\n\n              if (column.selectable) {\n                return SELECTCOLUMNTMPL;\n              }\n\n              if (column.draggable) {\n                return DRAGHANDLECOLUMNTMPL;\n              }\n\n              html += that._dirtyIndicatorTemplate(field, paramName);\n\n              if (type === FUNCTION) {\n                state.storage[\"tmpl\" + state.count] = template;\n                html += \"#=this.tmpl\" + state.count + \"(\" + paramName + \")#\";\n                state.count++;\n              } else if (type === STRING) {\n                html += template;\n              } else if (columnValues && columnValues.length && isPlainObject(columnValues[0]) && \"value\" in columnValues[0] && field) {\n                html += \"#var v =\" + kendo.stringify(convertToObject(columnValues)).replace(templateHashRegExp, \"\\\\#\") + \"#\";\n                html += \"#var f = v[\";\n\n                if (!settings.useWithBlock) {\n                  html += paramName + \".\";\n                }\n\n                html += field + \"]#\";\n                html += \"${f != null ? f : ''}\";\n              } else {\n                html += column.encoded ? \"#:\" : \"#=\";\n\n                if (format) {\n                  html += 'kendo.format(\\\"' + format.replace(formatRegExp, \"\\\\$1\") + '\\\",';\n                }\n\n                if (field) {\n                  field = kendo.expr(field, paramName);\n                  html += field + \"==null?'':\" + field;\n                } else {\n                  html += \"''\";\n                }\n\n                if (format) {\n                  html += \")\";\n                }\n\n                html += \"#\";\n              }\n\n              return html;\n            },\n            _dirtyIndicatorTemplate: function (field, paramName) {\n              var dirtyField;\n\n              if (field && paramName) {\n                dirtyField = field.charAt(0) === \"[\" ? kendo.expr(field, paramName + \".dirtyFields\") : paramName + \".dirtyFields['\" + field + \"']\";\n                return \"#= \" + paramName + \" && \" + paramName + \".dirty && \" + paramName + \".dirtyFields && \" + dirtyField + \" ? '<span class=\\\"k-dirty\\\"></span>' : '' #\";\n              }\n\n              return \"\";\n            },\n            _virtualCols: function (columns) {\n              var that = this;\n              var widths = $.map(columns, function (c) {\n                return c.hidden ? 0 : parseInt(c.width, 10);\n              });\n              var scrollLeft = that.virtualScrollable ? kendo.scrollLeft(that.content.find(\">.k-virtual-scrollable-wrap\")) : kendo.scrollLeft(that.content);\n              var tableWidth = outerWidth(that.content);\n              var sumOfWidths = sumWidths(columns);\n              var colsToRender = [];\n              var firstColspan = 0;\n              var lastColspan = 0;\n              var hiddenColumns = 0;\n              var idx = 0;\n              var widthOfHiddenColumns = 0;\n              var considerNext;\n\n              for (idx = 0; idx < columns.length; idx++) {\n                considerNext = idx < widths.length - 1 ? widths[idx + 1] : 0;\n\n                if (widthOfHiddenColumns + widths[idx] + 2 * considerNext < scrollLeft) {\n                  if (widths[idx]) {\n                    hiddenColumns++;\n                  }\n\n                  widthOfHiddenColumns += widths[idx];\n                } else {\n                  firstColspan = 1 + hiddenColumns;\n                  break;\n                }\n              }\n\n              hiddenColumns = 0;\n              widthOfHiddenColumns = 0;\n\n              for (var i = columns.length - 1; i >= 0; i--) {\n                if (widthOfHiddenColumns + 3 * widths[i] < sumOfWidths - tableWidth - scrollLeft) {\n                  if (widths[i]) {\n                    hiddenColumns++;\n                  }\n\n                  widthOfHiddenColumns += widths[i];\n                } else {\n                  lastColspan = 1 + hiddenColumns;\n\n                  for (var j = idx; j <= i; j++) {\n                    if (columns[j].locked) {\n                      continue;\n                    }\n\n                    colsToRender.push(columns[j]);\n\n                    if (columns[j].colSpan) {\n                      delete columns[j].colSpan;\n                    }\n                  }\n\n                  colsToRender[0].colSpan = firstColspan;\n                  colsToRender[colsToRender.length - 1].colSpan = lastColspan;\n                  break;\n                }\n              }\n\n              if (colsToRender[0].hidden) {\n                colsToRender[0].colSpan--;\n              }\n\n              that.virtualCols = colsToRender;\n              return colsToRender;\n            },\n            _templates: function () {\n              var that = this,\n                  options = that.options,\n                  dataSource = that.dataSource,\n                  groups = dataSource.group(),\n                  footer = that.footer || that.wrapper.find(\".k-grid-footer\"),\n                  aggregates = dataSource.aggregate(),\n                  columnLeafs = leafColumns(that.columns),\n                  columnsLocked = leafColumns(lockedColumns(that.columns)),\n                  leafsCols = options.scrollable ? leafColumns(nonLockedColumns(that.columns)) : columnLeafs,\n                  columns = (that.virtualScroll || {}).columns ? that._virtualCols(leafsCols) : leafsCols,\n                  groupHeaderColumnTemplateLockedColumns = grep(visibleColumns(columnsLocked), function (column, index) {\n                return column.groupHeaderColumnTemplate && index !== 0;\n              }),\n                  groupHeaderColumnTemplateNonLockedColumns = grep(visibleColumns(columns), function (column) {\n                return column.groupHeaderColumnTemplate;\n              });\n\n              if (options.scrollable && columnsLocked.length) {\n                if (options.rowTemplate || options.altRowTemplate) {\n                  throw new Error(\"Having both row template and locked columns is not supported\");\n                }\n\n                that.rowTemplate = that._tmpl(options.rowTemplate, columns, false, true);\n                that.altRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columns, true, true);\n                that.lockedRowTemplate = that._tmpl(options.rowTemplate, columnsLocked);\n                that.lockedAltRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columnsLocked, true);\n              } else {\n                that.rowTemplate = that._tmpl(options.rowTemplate, columns);\n                that.altRowTemplate = that._tmpl(options.altRowTemplate || options.rowTemplate, columns, true);\n              }\n\n              if (that._hasDetails()) {\n                that.detailTemplate = that._detailTmpl(options.detailTemplate || \"\");\n              }\n\n              if (that._group && !isEmptyObject(aggregates) || !isEmptyObject(aggregates) && !footer.length || grep(columnLeafs, function (column) {\n                return column.footerTemplate;\n              }).length) {\n                that.footerTemplate = that._footerTmpl(columnLeafs, aggregates, \"footerTemplate\", \"k-footer-template\");\n              }\n\n              if (groups && grep(columnLeafs, function (column) {\n                return column.groupFooterTemplate;\n              }).length) {\n                aggregates = $.map(groups, function (g) {\n                  return g.aggregates;\n                });\n                that.groupFooterTemplate = that._footerTmpl(columns, aggregates, \"groupFooterTemplate\", \"k-group-footer\", columnsLocked.length);\n\n                if (options.scrollable && columnsLocked.length) {\n                  that.lockedGroupFooterTemplate = that._footerTmpl(columnsLocked, aggregates, \"groupFooterTemplate\", \"k-group-footer\");\n                }\n              }\n\n              if (groups && (groupHeaderColumnTemplateLockedColumns.length || groupHeaderColumnTemplateNonLockedColumns.length)) {\n                aggregates = $.map(groups, function (g) {\n                  return g.aggregates;\n                });\n                that.groupHeaderColumnTemplate = that._groupHeaderTmpl(visibleColumns(columns), aggregates, \"groupHeaderColumnTemplate\", \"k-grouping-row\", columnsLocked.length, groupHeaderColumnTemplateNonLockedColumns);\n\n                if (options.scrollable && columnsLocked.length) {\n                  that.lockedGroupHeaderColumnTemplate = that._groupHeaderTmpl(visibleColumns(columnsLocked), aggregates, \"groupHeaderColumnTemplate\", \"k-grouping-row\", 0, groupHeaderColumnTemplateLockedColumns);\n                }\n              } else {\n                that.groupHeaderColumnTemplate = null;\n                that.lockedGroupHeaderColumnTemplate = null;\n              }\n\n              if (that.options.noRecords) {\n                that.noRecordsTemplate = that._noRecordsTmpl();\n              }\n            },\n            _noRecordsTmpl: function () {\n              var wrapper = '<div class=\"{0}\">{1}</div>';\n              var defaultTemplate = '<div class=\"k-grid-norecords-template\"{1}>{0}</div>';\n              var scrollableNoGridHeightStyles = this.options.scrollable && !this.wrapper[0].style.height ? ' style=\"margin:0 auto;position:static;\"' : '';\n              var state = {\n                storage: {},\n                count: 0\n              };\n              var settings = $.extend({}, kendo.Template, this.options.templateSettings);\n              var paramName = settings.paramName;\n              var template;\n              var html = \"\";\n              var type;\n              var tmpl;\n\n              if (this.options.noRecords.template) {\n                template = this.options.noRecords.template;\n              } else {\n                template = kendo.format(defaultTemplate, this.options.messages.noRecords, scrollableNoGridHeightStyles);\n              }\n\n              type = typeof template;\n\n              if (type === \"function\") {\n                state.storage[\"tmpl\" + state.count] = template;\n                html += \"#=this.tmpl\" + state.count + \"(\" + paramName + \")#\";\n                state.count++;\n              } else if (type === \"string\") {\n                html += template;\n              }\n\n              tmpl = kendo.template(kendo.format(wrapper, NORECORDSCLASS, html), settings);\n\n              if (state.count > 0) {\n                tmpl = tmpl.bind(state.storage);\n              }\n\n              return tmpl;\n            },\n            _footerTmpl: function (columns, aggregates, templateName, rowClass, skipGroupCells) {\n              var that = this,\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  paramName = settings.paramName,\n                  html = \"\",\n                  idx,\n                  length,\n                  template,\n                  type,\n                  storage = {},\n                  count = 0,\n                  scope = {},\n                  groups = that._groups(),\n                  fieldsMap = that.dataSource._emptyAggregates(aggregates),\n                  column;\n\n              html += '<tr class=\"' + rowClass + '\">';\n\n              if (groups > 0 && !skipGroupCells) {\n                html += groupCells(groups);\n              }\n\n              if (that._hasDetails()) {\n                html += '<td class=\"k-hierarchy-cell\">&nbsp;</td>';\n              }\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                column = columns[idx];\n                template = column[templateName];\n                type = typeof template;\n                html += \"<td\" + stringifyAttributes(column.footerAttributes) + \">\";\n\n                if (template) {\n                  if (type !== FUNCTION) {\n                    scope = fieldsMap[column.field] ? extend({}, settings, {\n                      paramName: paramName + \"['\" + column.field + \"']\"\n                    }) : {};\n                    template = kendo.template(template, scope);\n                  }\n\n                  storage[\"tmpl\" + count] = template;\n                  html += \"#=this.tmpl\" + count + \"(\" + paramName + \")#\";\n                  count++;\n                } else {\n                  html += \"&nbsp;\";\n                }\n\n                html += \"</td>\";\n              }\n\n              html += '</tr>';\n              html = kendo.template(html, settings);\n\n              if (count > 0) {\n                return html.bind(storage);\n              }\n\n              return html;\n            },\n            _groupHeaderTmpl: function (columns, aggregates, templateName, rowClass, skipGroupCells, groupHeaderColumnTemplateColumns) {\n              var that = this,\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  paramName = settings.paramName,\n                  html = \"\",\n                  idx,\n                  length,\n                  template,\n                  type,\n                  storage = {},\n                  count = 0,\n                  scope = {},\n                  fieldsMap = that.dataSource._emptyAggregates(aggregates),\n                  column,\n                  headerTemplateIndex = groupHeaderColumnTemplateColumns.length ? inArray(groupHeaderColumnTemplateColumns[0], columns) : -1,\n                  groupHeaderColumnTemplateClass;\n\n              html += '<tr role=\"row\" class=\"' + rowClass + '\">';\n\n              if (!skipGroupCells) {\n                html += '# for (var i = 0; i < data.groupCells; i++) { #' + '<td class=\"k-group-cell\">' + '&nbsp;' + '</td>' + '# } #';\n              }\n\n              if (that._hasDetails()) {\n                html += '<td class=\"k-hierarchy-cell\">&nbsp;</td>';\n              }\n\n              if (headerTemplateIndex < 0) {\n                html += !skipGroupCells ? groupCellBuilder(columns.length) : '';\n                return;\n              }\n\n              if (headerTemplateIndex < MINCOLSPANVALUE && groupHeaderColumnTemplateColumns.length <= 1 && !skipGroupCells) {\n                html += !skipGroupCells ? groupCellBuilder(columns.length) : '';\n                return kendo.template(html, settings);\n              }\n\n              if (headerTemplateIndex < MINCOLSPANVALUE) {\n                headerTemplateIndex = !skipGroupCells ? 1 : 0;\n                html += !skipGroupCells ? groupCellBuilder(headerTemplateIndex) : '';\n              } else {\n                html += !skipGroupCells ? groupCellBuilder(headerTemplateIndex) : groupCellLockedContentBuilder(headerTemplateIndex);\n              }\n\n              for (idx = headerTemplateIndex, length = columns.length; idx < length; idx++) {\n                column = columns[idx];\n                template = column[templateName];\n                type = typeof template;\n\n                if (column.sticky) {\n                  groupHeaderColumnTemplateClass = column.groupHeaderColumnTemplateClass || '';\n\n                  if (!groupHeaderColumnTemplateClass) {\n                    groupHeaderColumnTemplateClass = column.groupHeaderColumnTemplateClass = \"group-header-column-template-\" + kendo.guid();\n                  }\n\n                  html += \"<td class='\" + STICKY_CELL_CLASS + \" \" + groupHeaderColumnTemplateClass + \"' style='\" + (column.stickyStyle || '') + \"'>\";\n                } else {\n                  html += \"<td>\";\n                }\n\n                if (template) {\n                  if (type !== FUNCTION) {\n                    scope = fieldsMap[column.field] ? extend({}, settings, {\n                      paramName: paramName + \"['\" + column.field + \"']\"\n                    }) : {};\n                    template = kendo.template(template, scope);\n                  }\n\n                  storage[\"tmpl\" + count] = template;\n                  html += \"#=this.tmpl\" + count + \"(\" + paramName + \")#\";\n                  count++;\n                } else {\n                  html += \"&nbsp;\";\n                }\n\n                html += \"</td>\";\n              }\n\n              html += '</tr>';\n              html = kendo.template(html, settings);\n\n              if (count > 0) {\n                return html.bind(storage);\n              }\n\n              return html;\n            },\n            _detailTmpl: function (template) {\n              var that = this,\n                  html = \"\",\n                  settings = extend({}, kendo.Template, that.options.templateSettings),\n                  paramName = settings.paramName,\n                  templateFunctionStorage = {},\n                  templateFunctionCount = 0,\n                  groups = that._groups(),\n                  colspan = visibleColumns(leafColumns(that.columns)).length,\n                  type = typeof template;\n\n              html += '<tr class=\"k-detail-row\">';\n\n              if (groups > 0) {\n                html += groupCells(groups);\n              }\n\n              html += '<td class=\"k-hierarchy-cell\"></td><td class=\"k-detail-cell\"' + (colspan ? ' colspan=\"' + colspan + '\"' : '') + \">\";\n\n              if (type === FUNCTION) {\n                templateFunctionStorage[\"tmpl\" + templateFunctionCount] = template;\n                html += \"#=this.tmpl\" + templateFunctionCount + \"(\" + paramName + \")#\";\n                templateFunctionCount++;\n              } else {\n                html += template;\n              }\n\n              html += \"</td></tr>\";\n              html = kendo.template(html, settings);\n\n              if (templateFunctionCount > 0) {\n                return html.bind(templateFunctionStorage);\n              }\n\n              return html;\n            },\n            _hasDetails: function () {\n              var that = this;\n              return that.options.detailTemplate !== null || (that._events[DETAILINIT] || []).length;\n            },\n            _hasFilterRow: function () {\n              var filterable = this.options.filterable;\n              var hasFiltering = filterable && typeof filterable.mode == STRING && filterable.mode.indexOf(\"row\") != -1;\n              var columns = this.columns;\n              var columnsWithoutFiltering = $.grep(columns, function (col) {\n                return col.filterable === false;\n              });\n\n              if (columns.length && columnsWithoutFiltering.length == columns.length) {\n                hasFiltering = false;\n              }\n\n              return hasFiltering;\n            },\n            _details: function () {\n              var that = this;\n\n              if (that.options.scrollable && that._hasDetails() && lockedColumns(that.columns).length) {\n                throw new Error(\"Having both detail template and locked columns is not supported\");\n              }\n\n              that.table.on(CLICK + NS, \".k-hierarchy-cell .k-i-expand, .k-hierarchy-cell .k-i-collapse\", function (e) {\n                var button = $(this);\n\n                that._toggleDetails(button);\n\n                e.preventDefault();\n                return false;\n              });\n            },\n            _toggleDetails: function (button, omitAnimation) {\n              var that = this,\n                  cell = button.closest(\"td.k-hierarchy-cell\"),\n                  expanding = button.hasClass(\"k-i-expand\"),\n                  masterRow = button.closest(\"tr.k-master-row\"),\n                  detailRow,\n                  detailTemplate = that.detailTemplate,\n                  data,\n                  hasDetails = that._hasDetails(),\n                  ariaLabelText = expanding ? COLLAPSE : EXPAND,\n                  ariaExpandText = expanding ? true : false;\n\n              button.toggleClass(\"k-i-expand\", !expanding).toggleClass(\"k-i-collapse\", expanding).attr(ARIALABEL, ariaLabelText);\n              cell.attr(\"aria-expanded\", ariaExpandText);\n              detailRow = masterRow.next();\n\n              if (hasDetails && !detailRow.hasClass(\"k-detail-row\")) {\n                data = that.dataItem(masterRow);\n                detailRow = $(detailTemplate(data)).addClass(masterRow.hasClass(\"k-alt\") ? \"k-alt\" : \"\").insertAfter(masterRow);\n                that.angular(\"compile\", function () {\n                  return {\n                    elements: detailRow.get(),\n                    data: [{\n                      dataItem: data\n                    }]\n                  };\n                });\n                that.trigger(DETAILINIT, {\n                  masterRow: masterRow,\n                  detailRow: detailRow,\n                  data: data,\n                  detailCell: detailRow.find(\".k-detail-cell\")\n                });\n              }\n\n              that.trigger(expanding ? DETAILEXPAND : DETAILCOLLAPSE, {\n                masterRow: masterRow,\n                detailRow: detailRow\n              });\n\n              if (omitAnimation) {\n                toggleRow(detailRow, expanding);\n              } else {\n                detailRow.toggle(expanding);\n              }\n            },\n            dataItem: function (tr) {\n              tr = $(tr)[0];\n\n              if (!tr) {\n                return null;\n              }\n\n              var rows = this.tbody.children(),\n                  classesRegEx = /k-grouping-row|k-detail-row|k-group-footer/,\n                  idx = tr.sectionRowIndex,\n                  j,\n                  correctIdx;\n              correctIdx = idx;\n\n              for (j = 0; j < idx; j++) {\n                if (classesRegEx.test(rows[j].className)) {\n                  correctIdx--;\n                }\n              }\n\n              return this._data[correctIdx];\n            },\n            expandRow: function (tr, omitAnimation) {\n              var button = $(tr).find('> td .k-i-expand');\n\n              if (button.length) {\n                this._toggleDetails(button, omitAnimation);\n              }\n            },\n            collapseRow: function (tr, omitAnimation) {\n              var button = $(tr).find('> td .k-i-collapse');\n\n              if (button.length) {\n                this._toggleDetails(button, omitAnimation);\n              }\n            },\n            _createHeaderCells: function (columns, rowSpan) {\n              var that = this,\n                  idx,\n                  th,\n                  text,\n                  html = \"\",\n                  length,\n                  title,\n                  columnMenu = that.options.columnMenu,\n                  sortable = that.options.sortable,\n                  filterable = that._hasFilterMenu(),\n                  messages = that.options.messages,\n                  leafs = leafColumns(that.columns),\n                  groups = that.dataSource.group(),\n                  field;\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                th = columns[idx].column || columns[idx];\n                text = that._headerCellText(th);\n                title = th.title;\n                field = \"\";\n                var index = inArray(th, leafs);\n\n                if (th.selectable) {\n                  html += \"<th scope='col'\" + stringifyAttributes(th.headerAttributes);\n\n                  if (rowSpan && !columns[idx].colSpan) {\n                    html += \" rowspan='\" + rowSpan + \"'\";\n                  }\n\n                  if (index > -1) {\n                    html += kendo.attr(\"index\") + \"='\" + index + \"'\";\n                  }\n\n                  text = th.headerTemplate ? text : kendo.template(SELECTCOLUMNHEADERTMPL)({});\n                  html += \">\" + text + \"</th>\";\n                } else if (th.draggable) {\n                  html += \"<th class='k-header k-drag-cell' scope='col'\" + stringifyAttributes(th.headerAttributes);\n\n                  if (rowSpan && !columns[idx].colSpan) {\n                    html += \" rowspan='\" + rowSpan + \"'\";\n                  }\n\n                  if (index > -1) {\n                    html += kendo.attr(\"index\") + \"='\" + index + \"'\";\n                  }\n\n                  text = th.headerTemplate ? text : \"\";\n                  html += \">\" + text + \"</th>\";\n                } else if (th.command) {\n                  html += \"<th scope='col'\" + stringifyAttributes(th.headerAttributes);\n\n                  if (rowSpan && !columns[idx].colSpan) {\n                    html += \" rowspan='\" + rowSpan + \"'\";\n                  }\n\n                  if (index > -1) {\n                    html += kendo.attr(\"index\") + \"='\" + index + \"'\";\n                  }\n\n                  html += \">\" + text + \"</th>\";\n                } else {\n                  if (th.field) {\n                    field = kendo.attr(\"field\") + \"='\" + th.field + \"' \";\n                  }\n\n                  html += \"<th scope='col' role='columnheader' \" + field;\n\n                  if (columnMenu && th.field && th.menu !== false || filterable && th.filterable !== false && !th.command) {\n                    html += \" aria-haspopup='true'\";\n                  }\n\n                  if (rowSpan && !columns[idx].colSpan) {\n                    html += \" rowspan='\" + rowSpan + \"'\";\n                  }\n\n                  if (columns[idx].colSpan > 1) {\n                    html += 'colspan=\"' + (columns[idx].colSpan - hiddenLeafColumnsCount(th.columns)) + '\" ';\n                    html += kendo.attr(\"colspan\") + \"='\" + columns[idx].colSpan + \"'\";\n                  } else if (columns[idx].colSpan === 1) {\n                    html += kendo.attr(\"colspan\") + \"='\" + columns[idx].colSpan + \"'\";\n                  }\n\n                  if (title) {\n                    title = title && (that.options.encodeTitles ? htmlEncode(title, true) : title);\n                    html += kendo.attr(\"title\") + '=\"' + title + '\" ';\n                  }\n\n                  if (th.groupable !== undefined) {\n                    html += kendo.attr(\"groupable\") + \"='\" + th.groupable + \"' \";\n                  }\n\n                  if (isColumnGroupable(that, th)) {\n                    html += \"aria-label='\" + (title || th.field) + \" \";\n                    html += isGroupedBy(groups, th.field) ? messages.ungroupHeader : messages.groupHeader;\n                    html += \"' \";\n                  }\n\n                  if (th.aggregates && th.aggregates.length) {\n                    html += kendo.attr(\"aggregates\") + \"='\" + th.aggregates + \"'\";\n                  }\n\n                  if (index > -1) {\n                    html += kendo.attr(\"index\") + \"='\" + index + \"'\";\n                  }\n\n                  html += stringifyAttributes(th.headerAttributes);\n\n                  if (sortable) {\n                    text = kendo.template(SORTHEADERTMPL)({\n                      text: text\n                    });\n                  }\n\n                  html += \">\" + text + \"</th>\";\n                }\n              }\n\n              return html;\n            },\n            _appendLockedColumnContent: function () {\n              var columns = this.columns,\n                  idx,\n                  colgroup = this.table.find(\"colgroup\"),\n                  cols = colgroup.find(COLGROUP),\n                  length,\n                  lockedCols = $(),\n                  skipHiddenCount = 0,\n                  container,\n                  colSpan,\n                  spanIdx,\n                  colOffset = 0;\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                if (columns[idx].locked) {\n                  if (isVisible(columns[idx])) {\n                    colSpan = 1;\n\n                    if (columns[idx].columns) {\n                      colSpan = leafColumns(columns[idx].columns).length - hiddenLeafColumnsCount(columns[idx].columns);\n                    }\n\n                    colSpan = colSpan || 1;\n\n                    for (spanIdx = 0; spanIdx < colSpan; spanIdx++) {\n                      lockedCols = lockedCols.add(cols.eq(idx + colOffset + spanIdx - skipHiddenCount));\n                    }\n\n                    colOffset += colSpan - 1;\n                  } else {\n                    skipHiddenCount++;\n                  }\n                }\n              }\n\n              container = $('<div class=\"k-grid-content-locked\"><table><colgroup></colgroup><tbody></tbody></table></div>'); // detach is required for IE8, otherwise it switches to compatibility mode\n\n              colgroup.detach();\n              container.find(\"colgroup\").append(lockedCols);\n              colgroup.insertBefore(this.table.find(\"tbody\"));\n              this.lockedContent = container.insertBefore(this.content);\n              this.lockedTable = container.children(\"table\");\n            },\n            _appendLockedColumnFooter: function () {\n              var that = this;\n              var footer = that.footer;\n              var cells = footer.find(\".k-footer-template>td\");\n              var cols = footer.find(\".k-grid-footer-wrap>table>colgroup>col\");\n              var html = $('<div class=\"k-grid-footer-locked\"><table><colgroup></colgroup><tbody><tr class=\"k-footer-template\"></tr></tbody></table></div>');\n              var idx, length;\n\n              var groups = that._groups();\n\n              var lockedCells = $(),\n                  lockedCols = $();\n              lockedCells = lockedCells.add(cells.filter(\".k-group-cell\"));\n\n              for (idx = 0, length = leafColumns(lockedColumns(that.columns)).length; idx < length; idx++) {\n                lockedCells = lockedCells.add(cells.eq(idx + groups));\n              }\n\n              lockedCols = lockedCols.add(cols.filter(\".k-group-col\"));\n\n              for (idx = 0, length = visibleColumns(leafColumns(visibleLockedColumns(that.columns))).length; idx < length; idx++) {\n                lockedCols = lockedCols.add(cols.eq(idx + groups));\n              }\n\n              lockedCells.appendTo(html.find(\"tr\"));\n              lockedCols.appendTo(html.find(\"colgroup\"));\n              that.lockedFooter = html.prependTo(footer);\n            },\n            _appendLockedColumnHeader: function (container) {\n              var that = this,\n                  columns = this.columns,\n                  idx,\n                  html,\n                  length,\n                  colgroup,\n                  tr,\n                  trFilter,\n                  table,\n                  header,\n                  filtercellCells,\n                  rows = [],\n                  skipHiddenCount = 0,\n                  cols = $(),\n                  hasFilterRow = that._hasFilterRow(),\n                  filterCellOffset = 0,\n                  filterCells = $(),\n                  cell,\n                  leafColumnsCount = 0,\n                  cells = $();\n\n              colgroup = that.thead.prev().find(COLGROUP);\n              header = that.thead.find(\"tr\").first().find(\".k-header:not(.k-group-cell,.k-hierarchy-cell)\");\n              filtercellCells = that.thead.find(\".k-filter-row\").find(\"th:not(.k-group-cell,.k-hierarchy-cell)\");\n              var colOffset = 0;\n\n              for (idx = 0, length = columns.length; idx < length; idx++) {\n                if (columns[idx].locked) {\n                  cell = header.eq(idx);\n                  leafColumnsCount = leafColumns(columns[idx].columns || []).length;\n\n                  if (isVisible(columns[idx])) {\n                    var colSpan = null;\n\n                    if (columns[idx].columns) {\n                      colSpan = leafColumnsCount - hiddenLeafColumnsCount(columns[idx].columns);\n                    }\n\n                    colSpan = colSpan || 1;\n\n                    for (var spanIdx = 0; spanIdx < colSpan; spanIdx++) {\n                      cols = cols.add(colgroup.eq(idx + colOffset + spanIdx - skipHiddenCount));\n                    }\n\n                    colOffset += colSpan - 1;\n                  }\n\n                  mapColumnToCellRows([columns[idx]], childColumnsCells(cell), rows, 0, 0);\n                  leafColumnsCount = leafColumnsCount || 1;\n\n                  for (var j = 0; j < leafColumnsCount; j++) {\n                    filterCells = filterCells.add(filtercellCells.eq(filterCellOffset + j));\n                  }\n\n                  filterCellOffset += leafColumnsCount;\n                }\n\n                if (columns[idx].columns) {\n                  skipHiddenCount += hiddenLeafColumnsCount(columns[idx].columns);\n                }\n\n                if (!isVisible(columns[idx])) {\n                  skipHiddenCount++;\n                }\n              }\n\n              if (rows.length) {\n                html = '<div class=\"k-grid-header-locked\" style=\"width:1px\"><table><colgroup></colgroup><thead>';\n                html += new Array(rows.length + 1).join(\"<tr></tr>\");\n                html += (hasFilterRow ? '<tr class=\"k-filter-row\"></tr>' : '') + '</thead></table></div>';\n                table = $(html);\n                colgroup = table.find(\"colgroup\");\n                colgroup.append(that.thead.prev().find(\"col.k-group-col\").add(cols));\n                tr = table.find(\"thead tr:not(.k-filter-row)\");\n\n                for (idx = 0, length = rows.length; idx < length; idx++) {\n                  cells = toJQuery(rows[idx]);\n                  tr.eq(idx).append(that.thead.find(\"tr\").eq(idx).find(\".k-group-cell\").add(cells));\n                }\n\n                var count = removeEmptyRows(this.thead);\n\n                if (rows.length < count) {\n                  removeRowSpanValue(table, count - rows.length);\n                }\n\n                trFilter = table.find(\".k-filter-row\");\n                trFilter.append(that.thead.find(\".k-filter-row .k-group-cell\").add(filterCells));\n                this.lockedHeader = table.prependTo(container);\n                this.thead.find(\".k-group-cell\").remove();\n                return true;\n              }\n\n              return false;\n            },\n            _removeLockedContainers: function () {\n              var elements = this.lockedHeader.add(this.lockedContent).add(this.lockedFooter);\n              kendo.destroy(elements);\n              elements.off(NS).remove();\n              this.lockedHeader = this.lockedContent = this.lockedFooter = null;\n              this.selectable = null;\n            },\n            _thead: function () {\n              var that = this,\n                  columns = that.columns,\n                  hasDetails = that._hasDetails() && columns.length,\n                  hasFilterRow = that._hasFilterRow(),\n                  idx,\n                  html = \"\",\n                  thead = that.table.find(\">thead\"),\n                  hasTHead = that.element.find(\"thead\").first().length > 0,\n                  headerContent = that.options.messages.expandCollapseColumnHeader,\n                  tr;\n\n              if (!thead.length) {\n                thead = $(\"<thead/>\").insertBefore(that.tbody);\n              }\n\n              if (that.lockedHeader && that.thead) {\n                tr = that.thead.find(\"tr:has(th):not(.k-filter-row)\").html(\"\");\n                tr.remove();\n                tr = $();\n\n                that._removeLockedContainers();\n              } else if (hasTHead) {\n                tr = that.element.find(\"thead\").first().find(\"tr:has(th):not(.k-filter-row)\");\n              } else {\n                tr = that.element.find(\"tr:has(th)\").first();\n              }\n\n              if (!tr.length) {\n                tr = thead.children().first();\n\n                if (!tr.length) {\n                  var rows = [{\n                    rowSpan: 1,\n                    cells: [],\n                    index: 0\n                  }];\n\n                  that._prepareColumns(rows, columns);\n\n                  for (idx = 0; idx < rows.length; idx++) {\n                    html += \"<tr>\";\n\n                    if (hasDetails) {\n                      html += '<th class=\"k-hierarchy-cell\" scope=\"col\">' + headerContent + '</th>';\n                    }\n\n                    html += that._createHeaderCells(rows[idx].cells, rows[idx].rowSpan);\n                    html += \"</tr>\";\n                  }\n\n                  tr = $(html);\n                }\n              } else {\n                for (idx = 0; idx < columns.length; idx++) {\n                  var columnIndex = inArray(columns[idx], leafColumns(columns));\n                  var cell = leafDataCells(tr.parent()).filter(\"th:not(.k-group-cell):not(.k-hierarchy-cell)\").eq(columnIndex);\n\n                  if (columns[idx].hidden && columnIndex >= 0) {\n                    cell[0].style.display = \"none\";\n                  }\n                }\n\n                that._updateHeadersAttr(childColumns(columns));\n              }\n\n              if (hasFilterRow) {\n                var filterRow = $(\"<tr/>\");\n                filterRow.addClass(\"k-filter-row\");\n\n                if (hasDetails || tr.find(\".k-hierarchy-cell\").length) {\n                  // handles server side detail template\n                  filterRow.prepend('<th class=\"k-hierarchy-cell\" scope=\"col\">&nbsp;</th>');\n                }\n\n                var existingFilterRow = (that.thead || thead).find(\".k-filter-row\");\n\n                if (existingFilterRow.length) {\n                  kendo.destroy(existingFilterRow);\n                  existingFilterRow.remove();\n                }\n\n                thead.append(filterRow);\n              }\n\n              if (!tr.children().length) {\n                html = \"\";\n\n                if (hasDetails) {\n                  html += '<th class=\"k-hierarchy-cell\" scope=\"col\">&nbsp;</th>';\n                }\n\n                html += that._createHeaderCells(columns);\n                tr.html(html);\n              } else if (hasDetails && !tr.find(\".k-hierarchy-cell\")[0]) {\n                tr.prepend('<th class=\"k-hierarchy-cell\" scope=\"col\">' + (headerContent ? headerContent : '&nbsp;') + '</th>');\n              }\n\n              tr.attr(\"role\", \"row\").find(\"th\").addClass(\"k-header\");\n\n              if (!that.options.scrollable) {\n                thead.addClass(\"k-grid-header\");\n              }\n\n              tr.find(\"script\").remove().end().prependTo(thead);\n\n              if (that.thead) {\n                that._destroyColumnAttachments();\n              }\n\n              this.angular(\"cleanup\", function () {\n                return {\n                  elements: thead.find(\"th\" + NAVCELL).get()\n                };\n              });\n              this.angular(\"compile\", function () {\n                return {\n                  elements: thead.find(HEADERCELLS).get(),\n                  data: map(columns, function (col) {\n                    return {\n                      column: col\n                    };\n                  })\n                };\n              });\n              that.thead = thead.attr(\"role\", \"rowgroup\");\n\n              that._sortable();\n\n              that._filterable();\n\n              that._filterRow();\n\n              that._scrollable();\n\n              that._columnMenu();\n\n              var syncHeight;\n              var hasLockedColumns = this.options.scrollable && lockedColumns(this.columns).length;\n\n              if (hasLockedColumns) {\n                syncHeight = that._appendLockedColumnHeader(that.thead.closest(\".k-grid-header\"));\n\n                that._appendLockedColumnContent();\n\n                that.lockedContent.on(\"DOMMouseScroll\" + NS + \" mousewheel\" + NS, that._wheelScroll.bind(that));\n\n                if (kendo.support.touch) {\n                  that._lockedContentUserEvents = new kendo.UserEvents(that.lockedContent, {\n                    move: function (e) {\n                      that.content.scrollTop(that.content.scrollTop() + -e.y.delta);\n                      e.preventDefault();\n                    }\n                  });\n                }\n\n                that._updateLockedCols();\n              }\n\n              that._updateCols();\n\n              that._updateColumnCellIndex();\n\n              that._updateFirstColumnClass();\n\n              that._resizable();\n\n              that._draggable();\n\n              that._reorderable();\n\n              that._updateHeader(that._groups());\n\n              that._updateStickyColumns();\n\n              if (hasLockedColumns) {\n                if (syncHeight) {\n                  that._syncLockedHeaderHeight();\n                }\n\n                that._applyLockedContainersWidth();\n              }\n\n              if (that.groupable) {\n                that._attachGroupable();\n              }\n            },\n            _retrieveFirstColumn: function (columns, rows) {\n              var result = $();\n\n              if (rows.length && columns[0]) {\n                var column = columns[0];\n\n                while (column.columns && column.columns.length) {\n                  column = column.columns[0];\n                  rows = rows.filter(\":not(:first)\");\n                }\n\n                result = result.add(rows);\n              }\n\n              return result;\n            },\n            _updateFirstColumnClass: function () {\n              var that = this,\n                  columns = that.columns || [],\n                  hasDetails = that._hasDetails() && columns.length;\n\n              if (!hasDetails && !that._groups()) {\n                var tr = that.thead.find(\">tr:not(.k-filter-row):not(:first)\");\n                columns = nonLockedColumns(columns);\n\n                var rows = that._retrieveFirstColumn(columns, tr);\n\n                if (that._isLocked()) {\n                  tr = that.lockedHeader.find(\"thead>tr:not(.k-filter-row):not(:first)\");\n                  columns = lockedColumns(that.columns);\n                  rows = rows.add(that._retrieveFirstColumn(columns, tr));\n                }\n\n                rows.each(function () {\n                  var ths = $(this).find(\"th\");\n                  ths.removeClass(\"k-first\");\n                  ths.eq(0).addClass(\"k-first\");\n                });\n              }\n            },\n            _prepareColumns: function (rows, columns, parentCell, parentRow) {\n              var row = parentRow || rows[rows.length - 1];\n              var childRow = rows[row.index + 1];\n              var totalColSpan = 0;\n\n              for (var idx = 0; idx < columns.length; idx++) {\n                var cell = {\n                  column: columns[idx],\n                  colSpan: 0\n                };\n                row.cells.push(cell);\n\n                if (columns[idx].columns && columns[idx].columns.length) {\n                  if (!childRow) {\n                    childRow = {\n                      rowSpan: 0,\n                      cells: [],\n                      index: rows.length\n                    };\n                    rows.push(childRow);\n                  }\n\n                  cell.colSpan = columns[idx].columns.length;\n\n                  this._prepareColumns(rows, columns[idx].columns, cell, childRow);\n\n                  totalColSpan += cell.colSpan - 1;\n                  row.rowSpan = rows.length - row.index;\n                }\n              }\n\n              if (parentCell) {\n                parentCell.colSpan += totalColSpan;\n              }\n            },\n            _wheelScroll: function (e) {\n              if (e.ctrlKey) {\n                return;\n              }\n\n              var content = this.content;\n\n              if (this.virtualScroll && this.virtualScroll.rows) {\n                content = this.virtualScrollable.verticalScrollbar;\n              }\n\n              var scrollTop = content.scrollTop(),\n                  delta = kendo.wheelDeltaY(e);\n\n              if (delta) {\n                if (content[0].scrollHeight > content[0].clientHeight && (content[0].scrollTop < content[0].scrollHeight - content[0].clientHeight && delta < 0 || content[0].scrollTop > 0 && delta > 0)) {\n                  e.preventDefault();\n                }\n\n                content.scrollTop(scrollTop + -delta);\n              }\n            },\n            _isLocked: function () {\n              return this.lockedHeader != null;\n            },\n            _updateHeaderCols: function () {\n              var table = this.thead.parent().add(this.table);\n\n              if (this._isLocked()) {\n                normalizeCols(table, visibleLeafColumns(visibleNonLockedColumns(this.columns)), this._hasDetails(), 0);\n              } else {\n                normalizeCols(table, visibleLeafColumns(visibleColumns(this.columns)), this._hasDetails(), 0);\n              }\n            },\n            _updateColumnSorters: function () {\n              var that = this;\n              var cells = leafDataCells(that.thead);\n              var columns = leafColumns(that.columns);\n              var column;\n              var cell;\n              var sorterInstance;\n\n              if (!that.options.sortable) {\n                return;\n              }\n\n              for (var idx = 0, length = cells.length; idx < length; idx++) {\n                column = columns[idx];\n\n                if (column.sortable !== false && !column.command && column.field) {\n                  cell = cells.eq(idx);\n                  sorterInstance = cell.data(\"kendoColumnSorter\");\n\n                  if (sorterInstance) {\n                    sorterInstance.refresh();\n                  }\n                }\n              }\n            },\n            _updateHeadersAttr: function (columns) {\n              if (!columns.length) {\n                return;\n              }\n\n              var that = this;\n\n              for (var i = 0; i < columns.length; i++) {\n                if (columns[i].headerAttributes) {\n                  var th = that.element.find(\"[id='\" + columns[i].headerAttributes.id + \"']\");\n                  th.attr(\"headers\", columns[i].headerAttributes.headers);\n                }\n              }\n\n              that._updateHeadersAttr(childColumns(columns));\n            },\n            _updateCols: function (table) {\n              table = table || this.thead.parent().add(this.table);\n\n              this._appendCols(table, this._isLocked());\n            },\n            _updateLockedCols: function (table) {\n              if (this._isLocked()) {\n                table = table || this.lockedHeader.find(\"table\").add(this.lockedTable);\n                normalizeCols(table, visibleLeafColumns(visibleLockedColumns(this.columns)), this._hasDetails(), this._groups());\n              }\n            },\n            _appendCols: function (table, locked) {\n              if (locked) {\n                normalizeCols(table, visibleLeafColumns(visibleNonLockedColumns(this.columns)), this._hasDetails(), 0);\n              } else {\n                normalizeCols(table, visibleLeafColumns(visibleColumns(this.columns)), this._hasDetails(), this._groups());\n              }\n            },\n            _autoColumns: function (schema) {\n              if (schema && schema.toJSON) {\n                var that = this,\n                    field,\n                    encoded;\n                schema = schema.toJSON();\n                encoded = !(that.table.find(\"tbody tr\").length > 0 && (!that.dataSource || !that.dataSource.transport));\n\n                for (field in schema) {\n                  that.columns.push({\n                    field: field,\n                    encoded: encoded,\n                    headerAttributes: {\n                      id: kendo.guid()\n                    }\n                  });\n                }\n\n                that._thead();\n\n                that._templates();\n              }\n            },\n            _rowsHtml: function (data, templates) {\n              var that = this,\n                  html = \"\",\n                  idx,\n                  rowTemplate = templates.rowTemplate,\n                  altRowTemplate = templates.altRowTemplate,\n                  length;\n\n              for (idx = 0, length = data.length; idx < length; idx++) {\n                if (that._skipRerenderItemsCount > 0) {\n                  that._skipRerenderItemsCount--;\n                } else {\n                  if (idx % 2) {\n                    html += altRowTemplate(data[idx]);\n                  } else {\n                    html += rowTemplate(data[idx]);\n                  }\n                }\n\n                that._data.push(data[idx]);\n              }\n\n              return html;\n            },\n            _groupData: function (group, skipFooter, firstColumn) {\n              var that = this,\n                  footerDefaults = that._groupAggregatesDefaultObject || {},\n                  groupItems = group.items,\n                  aggregates = extend({}, footerDefaults, group.aggregates),\n                  headerData = extend({}, {\n                field: group.field,\n                value: group.value,\n                items: groupItems,\n                aggregates: aggregates\n              }, group.aggregates[firstColumn ? firstColumn.field : group.field]),\n                  footerData = {};\n\n              if (!skipFooter) {\n                for (var aggregate in aggregates) {\n                  footerData[aggregate] = extend({}, aggregates[aggregate], {\n                    group: {\n                      field: group.field,\n                      value: group.value,\n                      items: groupItems\n                    }\n                  });\n                }\n              }\n\n              return extend({}, footerData, headerData);\n            },\n            _removeGroupIfEmpty: function (row) {\n              var that = this,\n                  itemsCount,\n                  subgroupsCount,\n                  length = that.dataSource._group.length;\n\n              for (var i = 0; i < length; i++) {\n                row = row.prev();\n                itemsCount = +row.attr('data-group-item-count');\n                subgroupsCount = +row.attr('data-sub-group-count');\n\n                if (itemsCount == 1 || subgroupsCount == 1) {\n                  row.hide();\n                }\n              }\n            },\n            _groupRowHtml: function (group, colspan, level, groupHeaderBuilder, templates, skipColspan, skipLastGroup, isLockedTable) {\n              var that = this,\n                  html = \"\",\n                  idx,\n                  length,\n                  isLocked = that.lockedContent != null,\n                  field = group.field,\n                  column = grep(leafColumns(that.columns), function (column) {\n                return column.field == field;\n              })[0] || {},\n                  firstColumn = visibleColumns(that.columns)[0],\n                  firstVisibleColumnGroupHeaderTemplate = firstColumn ? firstColumn.groupHeaderColumnTemplate : null,\n                  template = column.groupHeaderTemplate ? column.groupHeaderTemplate : firstVisibleColumnGroupHeaderTemplate,\n                  text = (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || field) + ': ' + formatGroupValue(group.value, column.format, column.values, column.encoded),\n                  groupItems = group.currentItems || group.items,\n                  groups = that._groups(),\n                  groupFooterTemplate = templates.groupFooterTemplate,\n                  groupHeaderColumnTemplate = templates.groupHeaderColumnTemplate,\n                  groupData,\n                  isGroupPaged = that.dataSource._isGroupPaged(),\n                  expanded = isGroupPaged ? that.dataSource._groupsState[group.uid] : true;\n\n              if (that.options.editable && group.items && group.items[0] && group.items[0].isNew && group.items[0].isNew()) {\n                expanded = true;\n              }\n\n              if (templates.groupFooterTemplate || templates.groupHeaderColumnTemplate || column.groupHeaderTemplate) {\n                groupData = that._groupData(group, false, !column.groupHeaderTemplate && visibleColumns(that.columns)[0].groupHeaderColumnTemplate ? visibleColumns(that.columns)[0] : false);\n              }\n\n              if (template && !skipColspan) {\n                text = typeof template === FUNCTION ? template(groupData) : kendo.template(template)(groupData);\n              }\n\n              if (!that._skipRerenderItemsCount) {\n                if (!group.excludeHeader) {\n                  html += groupHtmlBuilder(groupHeaderColumnTemplate, groupHeaderBuilder, colspan, groups - level, groupData, level, text, expanded, group, isGroupPaged);\n                } else if (isLocked) {\n                  group.excludeHeader = isLockedTable ? false : true;\n                } else {\n                  group.excludeHeader = false;\n                }\n              } else {\n                groupHeaderBuilder(colspan, level, text, expanded, group.uid, isGroupPaged);\n              }\n\n              if (expanded) {\n                if (group.hasSubgroups) {\n                  for (idx = 0, length = groupItems.length; idx < length; idx++) {\n                    html += that._groupRowHtml(groupItems[idx], skipColspan ? colspan : colspan - 1, level + 1, groupHeaderBuilder, templates, skipColspan, skipLastGroup && idx === groupItems.length - 1, isLockedTable);\n                  }\n                } else {\n                  html += that._rowsHtml(groupItems, templates);\n                }\n              }\n\n              if (groupFooterTemplate) {\n                if (skipLastGroup) {\n                  if (!inArray(group.value, that._skippedGroups)) {\n                    that._skippedGroups.push(group.value);\n                  }\n                } else {\n                  if (that._skippedGroups.length && that._skippedGroups[0] === group.value) {\n                    that._skippedGroups.shift();\n                  }\n\n                  if (!that._skipRerenderItemsCount) {\n                    html += groupFooterTemplate(groupData);\n                  }\n                }\n              }\n\n              return html;\n            },\n            collapseGroup: function (group) {\n              var level,\n                  that = this,\n                  groupToCollapse = group,\n                  groupable = this.options.groupable,\n                  showFooter = groupable.showFooter,\n                  footerCount = showFooter ? 0 : 1,\n                  offset,\n                  relatedGroup = $(),\n                  idx,\n                  length,\n                  tr;\n              group = $(group);\n              level = group.find(\".k-group-cell\").length;\n\n              if (this.dataSource._isGroupPaged()) {\n                var groupUid = group.attr(\"data-group-uid\");\n\n                var groupObject = that.dataSource._getGroupByUid(groupUid);\n\n                var currentGroupCount = that.dataSource._calculateGroupsTotal([groupObject], true);\n\n                var groupCountAfterCollapse;\n                that.dataSource._groupsState[groupUid] = false;\n                groupCountAfterCollapse = that.dataSource._calculateGroupsTotal([groupObject], true);\n                that.dataSource._serverGroupsTotal -= currentGroupCount - groupCountAfterCollapse;\n\n                that._progress(true);\n\n                that.dataSource.range(that.dataSource._currentRangeStart, that.dataSource.take(), function () {\n                  that._progress(false);\n                }, \"collapseGroup\");\n                return;\n              }\n\n              if (this._isLocked()) {\n                if (!group.closest(\"div\").hasClass(\"k-grid-content-locked\")) {\n                  relatedGroup = group.nextAll(\"tr\");\n                  group = this.lockedTable.find(\">tbody>tr\").eq(group.index());\n                } else {\n                  relatedGroup = this.tbody.children(\"tr\").eq(group.index()).nextAll(\"tr\");\n                }\n              }\n\n              group.find(\".k-i-collapse\").addClass(\"k-i-expand\").removeClass(\"k-i-collapse\");\n              group.find(\"td[aria-expanded='true']\").first().attr(\"aria-expanded\", false).find(\"a\").attr(ARIALABEL, EXPAND);\n              group = group.nextAll(\"tr\");\n              var toHide = [];\n\n              for (idx = 0, length = group.length; idx < length; idx++) {\n                tr = group.eq(idx);\n                offset = tr.find(\".k-group-cell\").length;\n\n                if (tr.hasClass(\"k-grouping-row\")) {\n                  footerCount++;\n                } else if (tr.hasClass(\"k-group-footer\")) {\n                  footerCount--;\n                }\n\n                if (offset <= level || tr.hasClass(\"k-group-footer\") && footerCount < 0) {\n                  break;\n                }\n\n                if (relatedGroup.length) {\n                  toHide.push(relatedGroup[idx]);\n                }\n\n                toHide.push(tr[0]);\n              }\n\n              $(toHide).hide();\n\n              if (this.options.scrollable.endless && this.content) {\n                clearTimeout(that._collapseGroupsTimeOut);\n                that._collapseGroupsTimeOut = setTimeout(function () {\n                  that.content.scroll();\n                  that._groupToCollapse = groupToCollapse;\n                });\n              }\n            },\n            expandGroup: function (group) {\n              group = $(group);\n              var that = this,\n                  showFooter = that.options.groupable.showFooter,\n                  level,\n                  tr,\n                  offset,\n                  relatedGroup = $(),\n                  idx,\n                  length,\n                  footersVisibility = [],\n                  groupsCount = 1;\n              level = group.find(\".k-group-cell\").length;\n\n              if (this.dataSource._isGroupPaged()) {\n                var groupUid = group.attr(\"data-group-uid\");\n\n                var groupObject = that.dataSource._getGroupByUid(groupUid);\n\n                var groupCount = that.dataSource._calculateGroupsTotal([groupObject], true);\n\n                var groupCountAfterExpand;\n                that.dataSource._groupsState[groupUid] = true;\n\n                if (groupObject.items && groupObject.items.length) {\n                  groupCountAfterExpand = that.dataSource._calculateGroupsTotal([groupObject], true);\n                  that.dataSource._serverGroupsTotal += groupCountAfterExpand - groupCount;\n                }\n\n                that._progress(true);\n\n                that.dataSource.range(that.dataSource._currentRangeStart, that.dataSource.take(), function () {\n                  that._progress(false);\n                }, \"expandGroup\");\n                return;\n              }\n\n              if (this._isLocked()) {\n                if (!group.closest(\"div\").hasClass(\"k-grid-content-locked\")) {\n                  relatedGroup = group.nextAll(\"tr\");\n                  group = this.lockedTable.find(\">tbody>tr\").eq(group.index());\n                } else {\n                  relatedGroup = this.tbody.children(\"tr\").eq(group.index()).nextAll(\"tr\");\n                }\n              }\n\n              group.find(\".k-i-expand\").addClass(\"k-i-collapse\").removeClass(\"k-i-expand\");\n              group.find(\"td[aria-expanded='false']\").first().attr(\"aria-expanded\", true).find(\"a\").attr(ARIALABEL, COLLAPSE);\n              group = group.nextAll(\"tr\");\n\n              for (idx = 0, length = group.length; idx < length; idx++) {\n                tr = group.eq(idx);\n                offset = tr.find(\".k-group-cell\").length;\n\n                if (offset <= level) {\n                  break;\n                }\n\n                if (offset == level + 1 && !tr.hasClass(\"k-detail-row\")) {\n                  tr.show();\n                  relatedGroup.eq(idx).show();\n\n                  if (tr.hasClass(\"k-grouping-row\") && tr.find(\".k-icon\").hasClass(\"k-i-collapse\")) {\n                    that.expandGroup(tr);\n                  }\n\n                  if (tr.hasClass(\"k-master-row\") && tr.find(\".k-icon\").hasClass(\"k-i-collapse\")) {\n                    tr.next().show();\n                    relatedGroup.eq(idx + 1).show();\n                  }\n                }\n\n                if (tr.hasClass(\"k-grouping-row\")) {\n                  if (showFooter) {\n                    footersVisibility.push(tr.is(\":visible\"));\n                  }\n\n                  groupsCount++;\n                }\n\n                if (tr.hasClass(\"k-group-footer\")) {\n                  if (showFooter) {\n                    var toggleVisibility = footersVisibility.pop();\n                    tr.toggle(toggleVisibility);\n                    relatedGroup.eq(idx).toggle(toggleVisibility);\n                  }\n\n                  if (groupsCount == 1) {\n                    tr.show();\n                    relatedGroup.eq(idx).show();\n                  } else {\n                    groupsCount--;\n                  }\n                }\n              }\n\n              if (level === 0 && that.options.scrollable.endless && this._isLocked() || !that.options.scrollable.endless && this._isLocked()) {\n                that._syncLockedContentHeight();\n              }\n            },\n            _updateHeader: function (groups) {\n              var that = this,\n                  container = that._isLocked() ? that.lockedHeader.find(\"thead\") : that.thead,\n                  filterCells = container.find(\"tr.k-filter-row\").find(\"th.k-group-cell\").length,\n                  length = container.find(\"tr\").first().find(\"th.k-group-cell\").length,\n                  rows = container.children(\"tr:not(:first)\").filter(function () {\n                return !$(this).children(\":visible\").length;\n              });\n\n              if (groups > length) {\n                $(new Array(groups - length + 1).join('<th class=\"k-group-cell k-header\" scope=\"col\">' + that.options.messages.expandCollapseColumnHeader + '</th>')).prependTo(container.children(\"tr:not(.k-filter-row)\"));\n\n                if (that.element.is(\":visible\")) {\n                  rows.find(\"th.k-group-cell\").hide();\n                }\n              } else if (groups < length) {\n                container.find(\"tr\").each(function () {\n                  $(this).find(\"th.k-group-cell\").eq(groups).remove();\n                  $(this).find(\"th.k-group-cell\").slice(groups).remove();\n                });\n              }\n\n              if (groups > filterCells) {\n                $(new Array(groups - filterCells + 1).join('<th class=\"k-group-cell k-header\" scope=\"col\">&nbsp;</th>')).prependTo(container.find(\".k-filter-row\"));\n              }\n            },\n            _firstDataItem: function (data, grouped) {\n              if (data && grouped) {\n                if (data.hasSubgroups) {\n                  data = this._firstDataItem(data.items[0], grouped);\n                } else {\n                  data = data.items[0];\n                }\n              }\n\n              return data;\n            },\n            _updateTablesWidth: function () {\n              var that = this,\n                  tables;\n\n              if (!that._isLocked()) {\n                return;\n              }\n\n              tables = $(\">.k-grid-footer>.k-grid-footer-wrap>table\", that.wrapper).add(that.thead.parent()).add(that.table);\n              that._footerWidth = tableWidth(tables.eq(0));\n              tables.width(that._footerWidth);\n              tables = $(\">.k-grid-footer>.k-grid-footer-locked>table\", that.wrapper).add(that.lockedHeader.find(\">table\")).add(that.lockedTable);\n              tables.width(tableWidth(tables.eq(0)));\n            },\n            hideColumn: function (column) {\n              var that = this,\n                  cell,\n                  tables,\n                  idx,\n                  cols,\n                  colWidth,\n                  position,\n                  width = 0,\n                  headerCellIndex,\n                  length,\n                  footer = that.footer || that.wrapper.find(\".k-grid-footer\"),\n                  virtualScroll = that.virtualScroll || {},\n                  columns = that.columns,\n                  visibleLocked = that.lockedHeader ? leafDataCells(that.lockedHeader.find(\">table>thead\")).filter(isCellVisible).length : 0,\n                  columnIndex,\n                  groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function (column) {\n                return column.groupHeaderColumnTemplate;\n              });\n\n              if (typeof column == \"number\") {\n                column = columns[column];\n              } else if (isPlainObject(column)) {\n                column = grep(flatColumns(columns), function (item) {\n                  return item === column;\n                })[0];\n              } else {\n                column = grep(flatColumns(columns), function (item) {\n                  return item.field === column;\n                })[0];\n              }\n\n              if (!column || !isVisible(column)) {\n                return;\n              }\n\n              var setColumnVisibility = that._columnVisibilitySetter(column);\n\n              if (column.columns && column.columns.length) {\n                position = columnVisiblePosition(column, columns);\n                setColumnVisibility(column, false);\n                setCellVisibility(elements($(\">table>thead\", that.lockedHeader), that.thead, \">tr:eq(\" + position.row + \")>th\"), position.cell, false);\n\n                for (idx = 0; idx < column.columns.length; idx++) {\n                  this.hideColumn(column.columns[idx]);\n                }\n\n                that.trigger(COLUMNHIDE, {\n                  column: column\n                });\n                return;\n              }\n\n              columnIndex = inArray(column, visibleColumns(leafColumns(columns)));\n              setColumnVisibility(column, false);\n\n              that._setParentsVisibility(column, false);\n\n              that._templates();\n\n              that._updateCols();\n\n              that._updateLockedCols();\n\n              var container = that.thead;\n              headerCellIndex = columnIndex;\n\n              if (that.lockedHeader && visibleLocked > columnIndex) {\n                container = that.lockedHeader.find(\">table>thead\");\n              } else {\n                headerCellIndex -= visibleLocked;\n              }\n\n              cell = leafDataCells(container).filter(isCellVisible).eq(headerCellIndex);\n              cell[0].style.display = \"none\";\n              setCellVisibility(elements($(\">table>thead\", that.lockedHeader), that.thead, \">tr.k-filter-row>th\"), columnIndex, false);\n\n              if (footer[0]) {\n                that._updateCols(footer.find(\">.k-grid-footer-wrap>table\"));\n\n                that._updateLockedCols(footer.find(\">.k-grid-footer-locked>table\"));\n\n                setCellVisibility(footer.find(\".k-footer-template>td\"), columnIndex, false);\n              }\n\n              if (virtualScroll.columns && !column.locked) {\n                that._updateContentWidth();\n\n                that.trigger(COLUMNHIDE, {\n                  column: column\n                });\n                return;\n              }\n\n              if (that.lockedTable && visibleLocked > columnIndex) {\n                hideColumnCells(that.lockedTable.find(\">tbody>tr\"), columnIndex);\n              } else {\n                hideColumnCells(that.tbody.children(), columnIndex - visibleLocked);\n              }\n\n              if (that.lockedTable) {\n                that._updateTablesWidth();\n\n                that._applyLockedContainersWidth();\n\n                that._syncLockedContentHeight();\n\n                that._syncLockedHeaderHeight();\n\n                that._syncLockedFooterHeight();\n              } else {\n                cols = that.thead.prev().find(\"col\");\n\n                for (idx = 0, length = cols.length; idx < length; idx += 1) {\n                  colWidth = cols[idx].style.width;\n\n                  if (cols[idx].className.indexOf(\"k-hierarchy-col\") > -1) {\n                    width += outerWidth(cols[idx]);\n                    continue;\n                  }\n\n                  if (cols[idx].className.indexOf(\"k-group-col\") > -1) {\n                    width += outerWidth(cols[idx]);\n                    continue;\n                  }\n\n                  if (colWidth && colWidth.indexOf(\"%\") == -1) {\n                    width += parseInt(colWidth, 10);\n                  } else {\n                    width = 0;\n                    break;\n                  }\n                }\n\n                tables = that.wrapper.find(\">.k-grid-header table\").first().add(that.wrapper.find(\">.k-grid-footer table\").first()).add(that.table);\n                that._footerWidth = null;\n\n                if (width) {\n                  tables.each(function () {\n                    this.style.width = width + \"px\";\n                  });\n                  that._footerWidth = width;\n\n                  that._setContentWidth();\n                }\n              }\n\n              that._updateFirstColumnClass();\n\n              that._updateStickyColumns();\n\n              if (groupHeaderColumnTemplateColumns.length > 0) {\n                that._renderGroupRows();\n              }\n\n              that.trigger(COLUMNHIDE, {\n                column: column\n              });\n            },\n            _setParentsVisibility: function (column, visible) {\n              var that = this;\n              var columns = that.columns;\n              var idx;\n              var parents = [];\n              var parent;\n              var position;\n              var cell;\n              var colSpan;\n\n              var setColumnVisibility = that._columnVisibilitySetter(column);\n\n              var predicate = visible ? function (p) {\n                return visibleColumns(p.columns).length && p.hidden;\n              } : function (p) {\n                return !visibleColumns(p.columns).length && !p.hidden;\n              };\n\n              if (columnParents(column, columns, parents) && parents.length) {\n                for (idx = parents.length - 1; idx >= 0; idx--) {\n                  parent = parents[idx];\n                  position = columnPosition(parent, columns);\n                  cell = elements($(\">table>thead\", this.lockedHeader), this.thead, \">tr:eq(\" + position.row + \")>th:not(.k-group-cell):not(.k-hierarchy-cell)\").eq(position.cell);\n\n                  if (predicate(parent)) {\n                    setColumnVisibility(parent, visible);\n                    cell[0].style.display = visible ? \"\" : \"none\";\n                  }\n\n                  if (cell.filter(\"[\" + kendo.attr(\"colspan\") + \"]\").length) {\n                    colSpan = parseInt(cell.attr(kendo.attr(\"colspan\")), 10);\n                    cell[0].colSpan = colSpan - hiddenLeafColumnsCount(parent.columns) || 1;\n                  }\n                }\n              }\n            },\n            _updateContentWidth: function () {\n              var that = this;\n              var tables = that.table.add(that.thead.parent());\n              tables.css({\n                width: sumWidths(visibleLeafColumns(visibleNonLockedColumns(that.columns)))\n              });\n              that.refresh();\n            },\n            showColumn: function (column) {\n              var that = this,\n                  idx,\n                  length,\n                  cell,\n                  tables,\n                  width,\n                  headerCellIndex,\n                  position,\n                  colWidth,\n                  cols,\n                  columns = that.columns,\n                  virtualScroll = that.virtualScroll || {},\n                  footer = that.footer || that.wrapper.find(\".k-grid-footer\"),\n                  lockedColumnsCount = that.lockedHeader ? leafDataCells(that.lockedHeader.find(\">table>thead\")).length : 0,\n                  columnIndex,\n                  originalColumn,\n                  columnLeafIndex,\n                  groupHeaderColumnTemplateColumns = grep(leafColumns(that.columns), function (column) {\n                return column.groupHeaderColumnTemplate;\n              });\n\n              if (typeof column == \"number\") {\n                columnIndex = column;\n                column = columns[column];\n              } else if (isPlainObject(column)) {\n                $.each(flatColumns(columns), function (index, item) {\n                  if (item === column) {\n                    column = item;\n                    columnIndex = index;\n                    return false;\n                  }\n                });\n              } else {\n                $.each(flatColumns(columns), function (index, item) {\n                  if (item.field === column) {\n                    column = item;\n                    columnIndex = index;\n                    return false;\n                  }\n                });\n              }\n\n              if (!column || isVisible(column)) {\n                return;\n              }\n\n              var setColumnVisibility = that._columnVisibilitySetter(column);\n\n              if (column.columns && column.columns.length) {\n                position = columnPosition(column, columns);\n                originalColumn = flatColumns(that.options.columns)[columnIndex];\n                setColumnVisibility(column, true);\n                setCellVisibility(elements($(\">table>thead\", that.lockedHeader), that.thead, \">tr:eq(\" + position.row + \")>th\"), position.cell, true);\n\n                for (idx = 0; idx < column.columns.length; idx++) {\n                  if (!originalColumn.columns[idx].hidden) {\n                    this.showColumn(column.columns[idx]);\n                  }\n                }\n\n                that.trigger(COLUMNSHOW, {\n                  column: column\n                });\n                return;\n              }\n\n              columnLeafIndex = inArray(column, leafColumns(columns));\n              setColumnVisibility(column, true);\n\n              that._setParentsVisibility(column, true);\n\n              that._templates();\n\n              that._updateCols();\n\n              that._updateLockedCols();\n\n              var container = that.thead;\n              headerCellIndex = columnLeafIndex;\n\n              if (that.lockedHeader && lockedColumnsCount > columnLeafIndex) {\n                container = that.lockedHeader.find(\">table>thead\");\n              } else {\n                headerCellIndex -= lockedColumnsCount;\n              }\n\n              cell = leafDataCells(container).eq(headerCellIndex);\n              cell[0].style.display = \"\";\n              setCellVisibility(elements($(\">table>thead\", that.lockedHeader), that.thead, \">tr.k-filter-row>th\"), columnLeafIndex, true);\n\n              if (footer[0]) {\n                that._updateCols(footer.find(\">.k-grid-footer-wrap>table\"));\n\n                that._updateLockedCols(footer.find(\">.k-grid-footer-locked>table\"));\n\n                setCellVisibility(footer.find(\".k-footer-template>td\"), columnLeafIndex, true);\n              }\n\n              if (virtualScroll.columns && !column.locked) {\n                that._updateContentWidth();\n\n                that.trigger(COLUMNSHOW, {\n                  column: column\n                });\n                return;\n              }\n\n              if (that.lockedTable && lockedColumnsCount > columnLeafIndex) {\n                showColumnCells(that.lockedTable.find(\">tbody>tr\"), columnLeafIndex);\n              } else {\n                showColumnCells(that.tbody.children(), columnLeafIndex - lockedColumnsCount);\n              }\n\n              if (that.lockedTable) {\n                that._updateTablesWidth();\n\n                that._applyLockedContainersWidth();\n\n                that._syncLockedContentHeight();\n\n                that._syncLockedHeaderHeight();\n              } else {\n                tables = that.wrapper.find(\">.k-grid-header table\").first().add(that.wrapper.find(\">.k-grid-footer table\").first()).add(that.table);\n\n                if (!column.width) {\n                  tables.width(\"\");\n                } else {\n                  width = 0;\n                  cols = that.thead.prev().find(\"col\");\n\n                  for (idx = 0, length = cols.length; idx < length; idx += 1) {\n                    colWidth = cols[idx].style.width;\n\n                    if (cols[idx].className.indexOf(\"k-hierarchy-col\") > -1) {\n                      width += outerWidth(cols[idx]);\n                      continue;\n                    }\n\n                    if (cols[idx].className.indexOf(\"k-group-col\") > -1) {\n                      width += outerWidth(cols[idx]);\n                      continue;\n                    }\n\n                    if (colWidth.indexOf(\"%\") > -1) {\n                      width = 0;\n                      break;\n                    }\n\n                    width += parseInt(colWidth, 10);\n                  }\n\n                  that._footerWidth = null;\n\n                  if (width) {\n                    tables.each(function () {\n                      this.style.width = width + \"px\";\n                    });\n                    that._footerWidth = width;\n\n                    that._setContentWidth();\n                  }\n                }\n              }\n\n              that._updateFirstColumnClass();\n\n              that._updateStickyColumns();\n\n              if (groupHeaderColumnTemplateColumns.length > 0) {\n                that._renderGroupRows();\n              }\n\n              that.trigger(COLUMNSHOW, {\n                column: column\n              });\n            },\n            _columnVisibilitySetter: function (column) {\n              var col = column || {};\n\n              if (isUndefined(col.media)) {\n                return setColumnVisibility;\n              } else {\n                return setColumnMediaVisibility;\n              }\n            },\n            _buildSkeleton: function () {\n              var visibleColumns = this.virtualCols ? this.virtualCols : visibleLeafColumns(this.columns);\n              var pageSize = this.dataSource.pageSize() || this.dataSource.total();\n              var loaderHTML = \"\";\n              var colspan;\n              var groups = (this.dataSource.group() || []).length;\n              var columnsCount = visibleColumns.length + groups;\n\n              if (this._hasDetails()) {\n                columnsCount++;\n              }\n\n              if (this._hasVirtualColumns()) {\n                colspan = parseInt(this.content.find(\"tr\").first().find(\"td\").first().attr(\"colspan\"), 10);\n              }\n\n              for (var i = 0; i < pageSize; i++) {\n                loaderHTML += \"<tr>\";\n\n                for (var j = 0; j < columnsCount; j++) {\n                  if (colspan && !j) {\n                    loaderHTML += \"<td colspan='\" + colspan + \"'><span class='k-skeleton k-skeleton-text k-skeleton-pulse'></span></td>\";\n                  } else {\n                    loaderHTML += \"<td><span class='k-skeleton k-skeleton-text k-skeleton-pulse'></span></td>\";\n                  }\n                }\n\n                loaderHTML += \"</tr>\";\n              }\n\n              return loaderHTML;\n            },\n            _progress: function (toggle) {\n              var element = this.element;\n              var endless = this.options.scrollable && this.options.scrollable.endless;\n              var loaderType = this.options.loaderType;\n              var isVirtualization = this.options.scrollable && this.options.scrollable.virtual;\n              var skeleton;\n\n              if (isVirtualization) {\n                element = this.content;\n              } else if (this._editContainer && this._editMode() === \"popup\") {\n                element = this._editContainer;\n              } else if (this.lockedContent || endless) {\n                element = this.wrapper;\n              } else if (this.element.is(\"table\")) {\n                element = this.element.parent();\n              } else if (this.content && this.content.length) {\n                element = this.content;\n              }\n\n              if (loaderType == \"skeleton\") {\n                if (toggle) {\n                  skeleton = this._buildSkeleton();\n                  element.find(\"tbody\").empty().append(skeleton);\n                } else {\n                  element.find(\".k-skeleton\").closest(\"tbody\").empty();\n                }\n              } else {\n                if (endless && toggle) {\n                  kendo.ui.progress(element, toggle, {\n                    height: this.content.height(),\n                    top: this.content[0].offsetTop,\n                    opacity: true\n                  });\n                } else {\n                  kendo.ui.progress(element, toggle);\n                }\n              }\n            },\n            _resize: function (size, force) {\n              this._syncLockedContentHeight();\n\n              this._syncLockedHeaderHeight();\n\n              if (this.content) {\n                this._setContentWidth();\n\n                this._setContentHeight();\n              }\n\n              if (this.lockedTable) {\n                this._syncLockedScroll();\n              }\n\n              if (this.virtualScrollable && (force || this._rowHeight)) {\n                if (force) {\n                  this._rowHeight = null;\n                }\n\n                this.virtualScrollable.repaintScrollbar();\n              }\n\n              if (this.pager && this.pager.element) {\n                this.pager.resize(force);\n              }\n\n              if (this._anyStickyColumns()) {\n                this._updateStickyColumns(false);\n              }\n            },\n            _isActiveInTable: function () {\n              var active = activeElement();\n\n              if (!active) {\n                return false;\n              }\n\n              return this.table[0] === active || $.contains(this.table[0], active) || this._isLocked() && (this.lockedTable[0] === active || $.contains(this.lockedTable[0], active));\n            },\n            refresh: function (e) {\n              var that = this,\n                  data = that.dataSource.view(),\n                  navigatable = that.options.navigatable,\n                  virtualScroll = that.virtualScroll || {},\n                  currentIndex,\n                  current = $(that.current()),\n                  isCurrentInHeader = false,\n                  groups = (that.dataSource.group() || []).length,\n                  colspan = groups + visibleLeafColumns(visibleColumns(that.columns)).length,\n                  contentScrollLeft,\n                  cachedItemsToSkip;\n\n              if (e && e.action === \"itemchange\" && (that.editable || that.options.scrollable.endless)) {\n                // skip rebinding if editing is in progress\n                if (this._editMode() != \"popup\" || this._editMode() === \"popup\" && !that._editableIsClosing) {\n                  // popup editing animation has not finished yet and the editable is not destoyed\n                  return;\n                }\n              }\n\n              if (virtualScroll.columns) {\n                that._templates();\n              } //someone remove the edited item\n\n\n              if (e && e.action === \"remove\" && that.editable && that.editable.options.model && inArray(that.editable.options.model, e.items) > -1) {\n                that.editable.options.model.unbind(CHANGE, that._modelChangeHandler);\n              }\n\n              e = e || {};\n\n              if (that.trigger(\"dataBinding\", {\n                action: e.action || \"rebind\",\n                index: e.index,\n                items: e.items\n              })) {\n                return;\n              }\n\n              if (e.action === SYNC && that._isVirtualEditable()) {\n                that._destroyEditable();\n\n                that._clearEditableState();\n              }\n\n              that._angularItems(\"cleanup\");\n\n              if (!that._endlessFetchInProgress) {\n                if (navigatable && (that._isActiveInTable() || that._editContainer && that._editContainer.data(\"kendoWindow\"))) {\n                  isCurrentInHeader = current.is(\"th\");\n                  currentIndex = isCurrentInHeader ? current.parent().children(\":not(.k-group-cell)\").index(current[0]) : Math.max(that.cellIndex(current), 0);\n                }\n\n                that._destroyEditable();\n              }\n\n              if (that.options.scrollable && that.options.scrollable.endless && !that._pdfInitialized) {\n                clearTimeout(that._progressTimeOut);\n                that._progressTimeOut = setTimeout(function () {\n                  if (!that._endlessFetchInProgress) {\n                    that._progress(false);\n                  }\n                }, 250);\n              } else {\n                that._progress(false);\n              }\n\n              that._hideResizeHandle();\n\n              that._data = [];\n\n              if (!that.columns.length) {\n                that._autoColumns(that._firstDataItem(data[0], groups));\n\n                colspan = groups + that.columns.length;\n              }\n\n              that._group = groups > 0 || that._group;\n\n              if (that._group) {\n                that._templates();\n\n                that._updateCols();\n\n                that._updateLockedCols();\n\n                if (!that._virtualColScroll) {\n                  that._updateHeader(groups);\n                }\n\n                that._group = groups > 0;\n                that._groupRows = groupRows(data);\n              }\n\n              if (that.content) {\n                contentScrollLeft = kendo.scrollLeft(that.content);\n              }\n\n              cachedItemsToSkip = that._skipRerenderItemsCount;\n\n              that._renderContent(data, colspan, groups);\n\n              if (that.options.scrollable && that.options.scrollable.endless && this.lockedContent) {\n                that._skipRerenderItemsCount = cachedItemsToSkip;\n              }\n\n              that._renderLockedContent(data, colspan, groups);\n\n              if (!that._virtualColScroll) {\n                that._footer();\n\n                that._renderNoRecordsContent();\n\n                that._togglePagerVisibility();\n\n                that._setContentHeight();\n\n                that._setContentWidth(that.content && contentScrollLeft);\n              }\n\n              if (that.lockedTable) {\n                //requires manual trigger of scroll to sync both tables\n                if (virtualScroll.rows) {\n                  that.content.find(\">.k-virtual-scrollable-wrap\").trigger(\"scroll\");\n                } else if (that.touchScroller) {\n                  that.touchScroller.movable.trigger(\"change\");\n                } else {\n                  that.wrapper.one(\"scroll\", function (e) {\n                    e.stopPropagation();\n                  });\n                  that.content.trigger(\"scroll\");\n                }\n              }\n\n              if (!that._endlessFetchInProgress && !that._rowDropping) {\n                that._restoreCurrent(currentIndex, isCurrentInHeader);\n              }\n\n              if (that.touchScroller) {\n                that.touchScroller.contentResized();\n              }\n\n              if (that.selectable) {\n                that.selectable.resetTouchEvents();\n              }\n\n              that._muteAngularRebind(function () {\n                that._angularItems(\"compile\");\n              });\n\n              if (that._checkBoxSelection) {\n                that._toggleHeaderCheckState(false);\n              }\n\n              if (that.options.persistSelection && (that.selectable && !kendo.ui.Selectable.parseOptions(that.options.selectable).cell || that._checkBoxSelection) && (that.items().length || that.dataSource._isGroupPaged())) {\n                that._restoreSelection();\n              }\n\n              if (!that.options.persistSelection) {\n                that._selectedIds = {};\n              }\n\n              if (that._hasReorderableRows()) {\n                that._draggableRows();\n\n                that._reorderableRows();\n              }\n\n              that.trigger(DATABOUND);\n            },\n            _restoreCurrent: function (currentIndex, isCurrentInHeader) {\n              if (currentIndex === undefined || currentIndex < 0) {\n                return;\n              }\n\n              this._removeCurrent();\n\n              if (isCurrentInHeader) {\n                this._setCurrent(this.thead.find(\"th:not(.k-group-cell)\").eq(currentIndex));\n              } else {\n                var rowIndex = 0;\n                var virtualScroll = this.virtualScroll || {};\n\n                if (this._rowVirtualIndex) {\n                  if (virtualScroll.rows) {\n                    rowIndex = this.virtualScrollable.position(this._rowVirtualIndex);\n                  } else {\n                    rowIndex = this._rowVirtualIndex;\n                  }\n                } else {\n                  currentIndex = 0;\n                }\n\n                var row = $();\n                var colspan;\n\n                if (this.lockedTable) {\n                  row = this.lockedTable.find(\">tbody>tr\").eq(rowIndex);\n                }\n\n                row = row.add(this.tbody.children().eq(rowIndex));\n\n                if (this._hasVirtualColumns()) {\n                  colspan = parseInt(row.find(\"td\").first().attr(\"colspan\"), 10);\n                  currentIndex = this._virtualCellIndex - (colspan > 1 ? colspan - 1 : 0);\n                }\n\n                var td = row.find(\">td:not(.k-group-cell):not(.k-hierarchy-cell)\").eq(currentIndex);\n\n                if (!td.length || currentIndex < 0) {\n                  return;\n                }\n\n                if (this._hasVirtualColumns()) {\n                  this._setCurrent(td, true, true);\n                } else {\n                  this._setCurrent(td);\n                }\n              }\n\n              if (this._current) {\n                focusTable(this._current.closest(\"table\")[0], true);\n              }\n            },\n            _restoreSelection: function () {\n              var that = this,\n                  allRows = that.items(),\n                  selectedRows,\n                  id = isFunction(that.dataSource.options.schema.model) ? that.dataSource.options.schema.model.fn.idField : that.dataSource.options.schema.model.id;\n              selectedRows = grep(allRows, function (row) {\n                var dataItemKey = that.dataItem(row)[id];\n\n                if (that._selectedIds[dataItemKey]) {\n                  return row;\n                }\n              });\n              that.select(selectedRows);\n            },\n            _angularItems: function (cmd) {\n              kendo.ui.DataBoundWidget.fn._angularItems.call(this, cmd);\n\n              if (cmd === \"cleanup\" && (!this.dataSource || !this.dataSource.options.endless)) {\n                this._cleanupDetailItems();\n              }\n\n              this._angularGroupItems(cmd);\n\n              this._angularGroupFooterItems(cmd);\n            },\n            _cleanupDetailItems: function () {\n              var that = this;\n\n              if (that._hasDetails()) {\n                that.angular(\"cleanup\", function () {\n                  return {\n                    elements: that.tbody.children(\".k-detail-row\")\n                  };\n                });\n                that.tbody.find(\".k-detail-cell\").empty();\n              }\n            },\n            _angularGroupItems: function (cmd) {\n              var that = this,\n                  container = that.tbody;\n\n              if (that.lockedContent) {\n                container = that.lockedTable.find(\"tbody\");\n              }\n\n              if (that._group) {\n                that.angular(cmd, function () {\n                  return {\n                    elements: container.children(\".k-grouping-row\"),\n                    data: $.map(groupRows(that.dataSource.view()), function (dataItem) {\n                      return {\n                        dataItem: dataItem\n                      };\n                    })\n                  };\n                });\n              }\n            },\n            _angularGroupFooterItems: function (cmd) {\n              var that = this,\n                  container = that.tbody;\n\n              if (that.lockedContent) {\n                container = that.element;\n              }\n\n              if (that._group && that.groupFooterTemplate) {\n                that.angular(cmd, function () {\n                  return {\n                    elements: container.find(\".k-group-footer\"),\n                    data: $.map(groupFooters(that.dataSource.view()), function (dataItem) {\n                      return {\n                        dataItem: dataItem\n                      };\n                    })\n                  };\n                });\n              }\n            },\n            _renderContent: function (data, colspan, groups) {\n              var that = this,\n                  idx,\n                  length,\n                  html = \"\",\n                  isLocked = that.lockedContent != null,\n                  endlessAppend = null,\n                  skipLastGroup,\n                  flatViewLength,\n                  scrollable = that.options.scrollable,\n                  templates = {\n                rowTemplate: that.rowTemplate,\n                altRowTemplate: that.altRowTemplate,\n                groupFooterTemplate: that.groupFooterTemplate,\n                groupHeaderColumnTemplate: that.groupHeaderColumnTemplate\n              };\n\n              if (scrollable && scrollable.endless && !that.dataSource.options.endless) {\n                that._skipRerenderItemsCount = 0;\n\n                if (that.content) {\n                  that.content[0].scrollTop = 0;\n                }\n              }\n\n              endlessAppend = that._skipRerenderItemsCount > 0;\n              colspan = isLocked ? colspan - visibleLeafColumns(visibleLockedColumns(that.columns)).length : colspan;\n\n              if (groups > 0) {\n                colspan = isLocked ? colspan - groups : colspan;\n\n                if (that.detailTemplate) {\n                  colspan++;\n                }\n\n                if (that.groupFooterTemplate) {\n                  that._groupAggregatesDefaultObject = that.dataSource.aggregates();\n                }\n\n                if (that.options.scrollable.endless) {\n                  flatViewLength = that.dataSource.flatView().length;\n                }\n\n                for (idx = 0, length = data.length; idx < length; idx++) {\n                  if (!that._skippedGroups) {\n                    that._skippedGroups = [];\n                  }\n\n                  skipLastGroup = flatViewLength && idx === data.length - 1 && flatViewLength !== that.dataSource.total();\n                  html += that._groupRowHtml(data[idx], colspan, 0, isLocked ? groupRowLockedContentBuilder : groupRowBuilder, templates, isLocked, skipLastGroup, false);\n                }\n              } else {\n                html += that._rowsHtml(data, templates);\n              }\n\n              if (endlessAppend) {\n                that.tbody.append(html);\n                clearTimeout(that._endlessFetchTimeOut);\n                that._endlessFetchTimeOut = setTimeout(function () {\n                  if (that._groupToCollapse) {\n                    that.collapseGroup(that._groupToCollapse);\n                    that._groupToCollapse = null;\n                  }\n                });\n                that._endlessFetchInProgress = null;\n              } else {\n                that.tbody = appendContent(that.tbody, that.table, html, this.options.$angular);\n              }\n            },\n            _renderGroupRows: function () {\n              var that = this,\n                  data = that._groupRows,\n                  groupRows = that.wrapper.find(\".k-grouping-row\"),\n                  groups = that._groups(),\n                  groupRowBuilderFunc,\n                  isLocked = that.lockedContent != null,\n                  columns,\n                  colspan,\n                  group,\n                  field,\n                  column,\n                  template,\n                  text,\n                  groupHeaderData,\n                  tableContainer,\n                  isInLockedContainer,\n                  prevElement,\n                  newGroupRowElement,\n                  currentRow,\n                  level,\n                  groupHeaderColumnTemplate,\n                  firstColumnGroupData;\n\n              groupRows.each(function (index, row) {\n                currentRow = $(row);\n                tableContainer = currentRow.closest(\"table\").parent();\n                isInLockedContainer = tableContainer.is(\".\" + CONTENTRLOCKEDCONTAINER);\n                columns = isInLockedContainer ? visibleLeafColumns(visibleColumns(lockedColumns(that.columns))) : visibleLeafColumns(visibleColumns(nonLockedColumns(that.columns)));\n                level = currentRow.find(\".\" + GROUPCELLCLASS).length;\n\n                if (isLocked) {\n                  groupRowBuilderFunc = isInLockedContainer ? groupRowBuilder : groupRowLockedContentBuilder;\n                  colspan = isInLockedContainer ? columns.length + groups - level : columns.length;\n                } else {\n                  groupRowBuilderFunc = groupRowBuilder;\n                  colspan = columns.length + groups - level;\n                }\n\n                group = index >= data.length ? data[index - data.length] : data[index];\n                field = group.field;\n                column = grep(leafColumns(that.columns), function (column) {\n                  return column.field == field;\n                })[0] || {};\n                firstColumnGroupData = !column.groupHeaderTemplate && visibleColumns(that.columns)[0].groupHeaderColumnTemplate ? visibleColumns(that.columns)[0] : false;\n                template = column.groupHeaderTemplate ? column.groupHeaderTemplate : visibleColumns(that.columns)[0].groupHeaderColumnTemplate;\n                text = (column.title && (that.options.encodeTitles ? htmlEncode(column.title, true) : column.title) || field) + ': ' + formatGroupValue(group.value, column.format, column.values, column.encoded);\n                groups = groups;\n                groupHeaderData = that._groupData(group, false, firstColumnGroupData);\n                groupHeaderColumnTemplate = isInLockedContainer ? that.lockedGroupHeaderColumnTemplate : that.groupHeaderColumnTemplate;\n\n                if (template) {\n                  text = typeof template === FUNCTION ? template(groupHeaderData) : kendo.template(template)(groupHeaderData);\n                }\n\n                prevElement = currentRow.prev().length ? currentRow.prev() : currentRow.parent();\n                newGroupRowElement = $(groupHeaderColumnTemplate ? groupHeaderColumnTemplate(extend({}, groupHeaderData, {\n                  groupCells: level,\n                  colspan: groups - level,\n                  text: text\n                })) : groupRowBuilderFunc(colspan, level, text));\n\n                if (prevElement.is(\"tbody\")) {\n                  prevElement.prepend(newGroupRowElement);\n                } else {\n                  prevElement.after(newGroupRowElement);\n                }\n\n                currentRow.remove();\n              });\n            },\n            _renderLockedContent: function (data, colspan, groups) {\n              var html = \"\",\n                  idx,\n                  length,\n                  skipLastGroup,\n                  endlessAppend = null,\n                  flatViewLength,\n                  templates = {\n                rowTemplate: this.lockedRowTemplate,\n                altRowTemplate: this.lockedAltRowTemplate,\n                groupFooterTemplate: this.lockedGroupFooterTemplate,\n                groupHeaderColumnTemplate: this.lockedGroupHeaderColumnTemplate\n              };\n\n              if (this.lockedContent) {\n                var table = this.lockedTable;\n                endlessAppend = this._skipRerenderItemsCount > 0;\n\n                if (groups > 0) {\n                  colspan = colspan - visibleColumns(leafColumns(nonLockedColumns(this.columns))).length;\n\n                  if (this.options.scrollable.endless) {\n                    flatViewLength = this.dataSource.flatView().length;\n                  }\n\n                  for (idx = 0, length = data.length; idx < length; idx++) {\n                    skipLastGroup = flatViewLength && idx === data.length - 1 && flatViewLength !== this.dataSource.total();\n                    html += this._groupRowHtml(data[idx], colspan, 0, groupRowBuilder, templates, false, skipLastGroup, true);\n                  }\n                } else {\n                  html = this._rowsHtml(data, templates);\n                }\n\n                if (endlessAppend) {\n                  table.children(\"tbody\").append(html);\n                } else {\n                  appendContent(table.children(\"tbody\"), table, html, this.options.$angular);\n                }\n\n                this._syncLockedContentHeight();\n              }\n            },\n            _togglePagerVisibility: function () {\n              if (this.options.pageable.alwaysVisible === false) {\n                this.wrapper.find(\".k-grid-pager\").toggle(this.dataSource.total() >= this.dataSource.pageSize());\n              }\n            },\n            _adjustRowsHeight: function (table1, table2) {\n              var rows = table1[0].rows,\n                  length = rows.length,\n                  idx,\n                  rows2 = table2[0].rows,\n                  containers = table1.add(table2),\n                  containersLength = containers.length,\n                  heights = [];\n\n              for (idx = 0; idx < length; idx++) {\n                if (!rows2[idx]) {\n                  break;\n                }\n\n                if (rows[idx].style.height) {\n                  rows[idx].style.height = rows2[idx].style.height = \"\";\n                }\n              }\n\n              for (idx = 0; idx < length; idx++) {\n                if (!rows2[idx]) {\n                  break;\n                }\n\n                var offsetHeight1 = rows[idx].offsetHeight;\n                var offsetHeight2 = rows2[idx].offsetHeight;\n                var height = 0;\n\n                if (offsetHeight1 > offsetHeight2) {\n                  height = offsetHeight1;\n                } else if (offsetHeight1 < offsetHeight2) {\n                  height = offsetHeight2;\n                }\n\n                heights.push(height);\n              }\n\n              for (idx = 0; idx < containersLength; idx++) {\n                containers[idx].style.display = \"none\";\n              }\n\n              for (idx = 0; idx < length; idx++) {\n                if (heights[idx]) {\n                  //add one to resolve row misalignment in IE\n                  rows[idx].style.height = rows2[idx].style.height = heights[idx] + 1 + \"px\";\n                }\n              }\n\n              for (idx = 0; idx < containersLength; idx++) {\n                containers[idx].style.display = \"\";\n              }\n            }\n          });\n\n          if (kendo.ExcelMixin) {\n            kendo.ExcelMixin.extend(Grid.prototype);\n          }\n\n          if (kendo.PDFMixin) {\n            kendo.PDFMixin.extend(Grid.prototype);\n\n            Grid.prototype._drawPDF_autoPageBreak = function (progress) {\n              var grid = this;\n              var result = new $.Deferred();\n              var dataSource = grid.dataSource;\n              var allPages = grid.options.pdf.allPages;\n              var origBody = grid.wrapper.find('table[role$=\"grid\"] > tbody').first();\n              var cont = $(\"<div>\").css({\n                position: \"absolute\",\n                left: -10000,\n                top: -10000\n              });\n              var clone;\n              grid.toggleUnexportableColumns(grid.columns);\n              clone = grid.wrapper.clone().css({\n                height: \"auto\",\n                width: \"auto\"\n              }).appendTo(cont);\n              clone.find(\".k-grid-content\").css({\n                height: \"auto\",\n                width: \"auto\",\n                overflow: \"visible\"\n              });\n              clone.find('table[role$=\"grid\"], .k-grid-footer table').css({\n                height: \"auto\",\n                width: \"100%\",\n                overflow: \"visible\"\n              });\n              clone.find(\".k-grid-pager, .k-grid-toolbar, .k-grouping-header\").remove();\n              clone.find(\".k-grid-header, .k-grid-footer, .k-auto-scrollable\").css({\n                paddingRight: 0\n              });\n\n              this._initPDFProgress(progress);\n\n              var body = clone.find('table[role$=\"grid\"] > tbody').first().empty();\n              var startingPage = dataSource.page();\n\n              function resolve() {\n                if (allPages && startingPage !== undefined) {\n                  dataSource.one(\"change\", draw);\n                  dataSource.page(startingPage);\n                } else {\n                  grid.refresh();\n                  draw();\n                }\n              }\n\n              function draw() {\n                cont.appendTo(document.body);\n                var options = $.extend({}, grid.options.pdf, {\n                  _destructive: true,\n                  progress: function (p) {\n                    progress.notify({\n                      page: p.page,\n                      pageNumber: p.pageNum,\n                      progress: 0.5 + p.pageNum / p.totalPages / 2,\n                      totalPages: p.totalPages\n                    });\n                  }\n                });\n                kendo.drawing.drawDOM(clone, options).always(function () {\n                  cont.remove();\n                }).then(function (group) {\n                  result.resolve(group);\n                  grid.toggleUnexportableColumns(grid.columns, true);\n                }).fail(function (err) {\n                  result.reject(err);\n                });\n              }\n\n              function renderPage() {\n                var pageNum = dataSource.page();\n                var totalPages = allPages ? dataSource.totalPages() : 1;\n                body.append(origBody.children(\"tr:not(.k-detail-row)\"));\n\n                if (pageNum < totalPages) {\n                  dataSource.page(pageNum + 1);\n                } else {\n                  dataSource.unbind(\"change\", renderPage);\n                  resolve();\n                }\n              }\n\n              if (allPages) {\n                dataSource.bind(\"change\", renderPage);\n                dataSource.page(1);\n              } else {\n                renderPage();\n              }\n\n              return result.promise();\n            };\n\n            Grid.prototype.toggleUnexportableColumns = function (columns, restore) {\n              var length = columns.length;\n              var column;\n              var exportable;\n              var visibleInExport;\n              var visibleInExportOnly;\n\n              for (var i = 0; i < length; i++) {\n                column = columns[i];\n                exportable = column.exportable;\n\n                if (!restore) {\n                  if (typeof column.exportable === \"object\") {\n                    exportable = column.exportable.pdf;\n                  }\n\n                  visibleInExport = !column.hidden && exportable !== false;\n                  visibleInExportOnly = column.hidden && exportable === true;\n                  exportable = visibleInExport || visibleInExportOnly;\n\n                  if (!exportable && !column.hidden) {\n                    column._toggledDuringExport = true;\n                    this.hideColumn(column);\n                  } else if (exportable && column.hidden) {\n                    column._toggledDuringExport = true;\n                    this.showColumn(column);\n                  } else if (exportable && column.columns) {\n                    this.toggleUnexportableColumns(column.columns);\n                  }\n                } else {\n                  if (column._toggledDuringExport) {\n                    column._toggledDuringExport = false;\n\n                    if (column.hidden) {\n                      this.showColumn(column);\n                    } else {\n                      this.hideColumn(column);\n                    }\n                  } else if (column.columns) {\n                    this.toggleUnexportableColumns(column.columns, restore);\n                  }\n                }\n              }\n            };\n\n            Grid.prototype._drawPDF = function (progress) {\n              var grid = this;\n\n              if (grid.options.pdf.paperSize && grid.options.pdf.paperSize != \"auto\") {\n                return grid._drawPDF_autoPageBreak(progress);\n              }\n\n              var result = new $.Deferred();\n              var dataSource = grid.dataSource;\n              var allPages = grid.options.pdf.allPages;\n\n              this._initPDFProgress(progress); // This group will be our document containing all pages\n\n\n              var doc = new kendo.drawing.Group();\n              var startingPage = dataSource.page();\n\n              function resolve() {\n                if (allPages && startingPage !== undefined) {\n                  dataSource.unbind(\"change\", exportPage);\n                  dataSource.one(\"change\", function () {\n                    result.resolve(doc);\n                  });\n                  dataSource.page(startingPage);\n                } else {\n                  result.resolve(doc);\n                }\n              }\n\n              function exportPage() {\n                grid.toggleUnexportableColumns(grid.columns);\n\n                grid._drawPDFShadow({\n                  width: grid.wrapper.width()\n                }, {\n                  avoidLinks: grid.options.pdf.avoidLinks\n                }).done(function (group) {\n                  var pageNum = dataSource.page();\n                  var totalPages = allPages ? dataSource.totalPages() : 1;\n                  var args = {\n                    page: group,\n                    pageNumber: pageNum,\n                    progress: pageNum / totalPages,\n                    totalPages: totalPages\n                  };\n                  grid.toggleUnexportableColumns(grid.columns, true);\n                  progress.notify(args);\n                  doc.append(args.page);\n\n                  if (pageNum < totalPages) {\n                    dataSource.page(pageNum + 1);\n                  } else {\n                    resolve();\n                  }\n                }).fail(function (err) {\n                  result.reject(err);\n                });\n              }\n\n              if (allPages) {\n                dataSource.bind(\"change\", exportPage);\n                dataSource.page(1);\n              } else {\n                exportPage();\n              }\n\n              return result.promise();\n            };\n\n            Grid.prototype._initPDFProgress = function (deferred) {\n              var loading = $(\"<div class='k-loading-pdf-mask'><div class='k-loading-color'></div></div>\");\n              loading.prepend(this.wrapper.clone().css({\n                position: \"absolute\",\n                top: 0,\n                left: 0\n              }));\n              this._pdfInitialized = true;\n              this.wrapper.append(loading);\n              var pb = $(\"<div class='k-loading-pdf-progress'>\").appendTo(loading).kendoProgressBar({\n                type: \"chunk\",\n                chunkCount: 10,\n                min: 0,\n                max: 1,\n                value: 0\n              }).data(\"kendoProgressBar\");\n              deferred.progress(function (e) {\n                pb.value(e.progress);\n              }).always(function () {\n                kendo.destroy(loading);\n                loading.remove();\n              });\n            };\n          }\n\n          function syncTableHeight(table1, table2) {\n            table1 = table1[0];\n            table2 = table2[0];\n\n            if (table1.rows.length !== table2.rows.length) {\n              var lockedHeigth = table1.offsetHeight;\n              var tableHeigth = table2.offsetHeight;\n              var row;\n              var diff;\n\n              if (lockedHeigth > tableHeigth) {\n                row = table2.rows[table2.rows.length - 1];\n\n                if (filterRowRegExp.test(row.className)) {\n                  row = table2.rows[table2.rows.length - 2];\n                }\n\n                diff = lockedHeigth - tableHeigth;\n              } else {\n                row = table1.rows[table1.rows.length - 1];\n\n                if (filterRowRegExp.test(row.className)) {\n                  row = table1.rows[table1.rows.length - 2];\n                }\n\n                diff = tableHeigth - lockedHeigth;\n              }\n\n              row.style.height = row.offsetHeight + diff + \"px\";\n            }\n          }\n\n          function adjustRowHeight(row1, row2) {\n            var height;\n            var offsetHeight1 = row1.offsetHeight;\n            var offsetHeight2 = row2.offsetHeight;\n\n            if (offsetHeight1 > offsetHeight2) {\n              height = offsetHeight1 + \"px\";\n            } else if (offsetHeight1 < offsetHeight2) {\n              height = offsetHeight2 + \"px\";\n            }\n\n            if (height) {\n              row1.style.height = row2.style.height = height;\n            }\n          }\n\n          function getCommand(commands, name) {\n            var idx, length, command;\n\n            if (typeof commands === STRING && commands === name) {\n              return commands;\n            }\n\n            if (isPlainObject(commands) && commands.name === name) {\n              return commands;\n            }\n\n            if (isArray(commands)) {\n              for (idx = 0, length = commands.length; idx < length; idx++) {\n                command = commands[idx];\n\n                if (typeof command === STRING && command === name || command.name === name) {\n                  return command;\n                }\n              }\n            }\n\n            return null;\n          }\n\n          function focusTable(table, direct) {\n            if (direct === true) {\n              table = $(table);\n              var scrollLeft = kendo.scrollLeft(table.parent());\n              kendo.focusElement(table);\n              kendo.scrollLeft(table.parent(), scrollLeft);\n            } else {\n              $(table).one(\"focusin\", function (e) {\n                e.preventDefault();\n              }).trigger(\"focus\");\n            }\n          }\n\n          function isColumnGroupable(grid, column) {\n            return grid.options.groupable && (column.groupable || column.groupable === undefined);\n          }\n\n          function isGroupedBy(groups, field) {\n            return !!$.grep(groups, function (item) {\n              return item.field === field;\n            }).length;\n          }\n\n          function isColumnEditable(column, model) {\n            if (!column.field || column.selectable) {\n              return false;\n            }\n\n            if (model.editable && !model.editable(column.field)) {\n              return false;\n            }\n\n            if (column.editable && !column.editable(model)) {\n              return false;\n            }\n\n            return true;\n          }\n\n          function isInputElement(element) {\n            return $(element).is(\":button,a,:input,a>.k-icon,textarea,span.k-select,span.k-icon,span.k-link,label.k-checkbox-label,.k-input,.k-multiselect-wrap,.k-picker-wrap,.k-picker-wrap>.k-selected-color,.k-tool-icon,.k-dropdownlist,.k-switch-thumb,.k-switch-track,.k-switch-label-off,.k-switch-label-on\");\n          }\n\n          function tableClick(e) {\n            var currentTarget = $(e.currentTarget),\n                isHeader = currentTarget.is(\"th\"),\n                table = this.table.add(this.lockedTable),\n                headerTable = this.thead.parent().add($(\">table\", this.lockedHeader)),\n                isInput = isInputElement(e.target),\n                preventScroll = $(e.target).is('.k-checkbox'),\n                target = $(e.target),\n                currentTable = currentTarget.closest(\"table\")[0];\n\n            if (isInput && currentTarget.find(kendo.roleSelector(\"filtercell\")).length) {\n              this._setCurrent(currentTarget);\n\n              return;\n            }\n\n            if (currentTable !== table[0] && currentTable !== table[1] && currentTable !== headerTable[0] && currentTable !== headerTable[1]) {\n              return;\n            }\n\n            if (target.is(\"a.k-i-expand, a.k-i-collapse\")) {\n              return;\n            }\n\n            if (this.options.navigatable) {\n              this._setCurrent(currentTarget, false, preventScroll);\n            }\n\n            if (isHeader || !isInput) {\n              setTimeout(function () {\n                var activeEl = $(kendo._activeElement());\n\n                if ((activeEl.hasClass(\"k-widget\") || activeEl.hasClass(\"k-dropdownlist\")) && !activeEl.hasClass(\"k-grid-pager\")) {\n                  return;\n                } //Only if input element is not selected yet and it is not descendant of the grid's table\n\n\n                if (activeEl.is(CHECKBOXINPUT) || !isInputElement(kendo._activeElement()) || !$.contains(currentTable, kendo._activeElement())) {\n                  //DOMElement.focus() only for header, because IE doesn't really focus the table\n                  focusTable(currentTable, true);\n                }\n              });\n            }\n\n            if (isHeader && !kendo.support.touch) {\n              e.preventDefault(); //if any problem occurs, call preventDefault only for the clicked header links\n            }\n          }\n\n          function leftMostPosition(element, rtl) {\n            if (!rtl) {\n              return 0;\n            }\n\n            var result = 0;\n\n            if (kendo.support.browser.webkit) {\n              result = element.width();\n            }\n\n            return result;\n          }\n\n          function parseVirtualSettings(options) {\n            var asLowerString;\n\n            if (typeof options === \"string\") {\n              asLowerString = options.toLowerCase();\n\n              if (asLowerString === \"true\") {\n                return {\n                  rows: true\n                };\n              } else {\n                return {\n                  rows: asLowerString.indexOf(\"rows\") > -1,\n                  columns: asLowerString.indexOf(\"columns\") > -1\n                };\n              }\n            } else if (options === true) {\n              return {\n                rows: true\n              };\n            }\n          }\n\n          function isElementVisibleInWrapper(wrapper, element) {\n            var offsetTop;\n            var halfHeight;\n\n            if (!wrapper) {\n              return false;\n            }\n\n            element = $(element);\n\n            if (element[0] && contains(wrapper[0], element[0])) {\n              offsetTop = element.offset().top - wrapper.offset().top;\n              halfHeight = element.outerHeight() / 2;\n\n              if ((offsetTop >= 0 || math.abs(offsetTop) <= halfHeight) && math.floor(offsetTop + halfHeight) <= wrapper.height()) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n\n          function isInEdit(cell) {\n            return cell && (cell.hasClass(\"k-edit-cell\") || cell.parent().hasClass(\"k-grid-edit-row\"));\n          }\n\n          function groupHtmlBuilder(groupHeaderColumnTemplate, groupHeaderBuilder, colspan, templateColspan, groupData, level, text, expanded, group, isGroupPaged) {\n            var html;\n\n            if (groupHeaderColumnTemplate) {\n              html = groupHeaderColumnTemplate(extend({}, groupData, {\n                groupCells: level,\n                colspan: templateColspan,\n                text: text\n              }));\n            } else {\n              html = groupHeaderBuilder(colspan, level, text, expanded, group.uid, isGroupPaged);\n            }\n\n            return html;\n          }\n\n          function groupCellBuilder(headerTemplateIndex) {\n            return '<td colspan=\"#=data.colspan +' + headerTemplateIndex + '#\">' + '<p class=\"k-reset\">' + '<a class=\"k-icon k-i-collapse\" href=\"\\\\#\" tabindex=\"-1\" ' + ARIALABEL + '=\"' + COLLAPSE + '\"></a>#=data.text#' + '</p></td>';\n          }\n\n          function groupCellLockedContentBuilder(headerTemplateIndex) {\n            return '<td colspan=\"' + headerTemplateIndex + '\">' + '<p class=\"k-reset\">&nbsp;</p></td>';\n          }\n\n          function groupRowBuilder(colspan, level, text, expanded, uid, includeAdditionalData) {\n            return '<tr role=\"row\"' + (includeAdditionalData ? 'data-group-uid=\"' + uid + '\"' : '') + 'class=\"k-grouping-row\">' + groupCells(level) + '<td colspan=\"' + colspan + '\" aria-expanded=\"' + !!expanded + '\">' + '<p class=\"k-reset\">' + '<a class=\"k-icon ' + (expanded ? 'k-i-collapse' : 'k-i-expand') + '\" href=\"#\" tabindex=\"-1\" ' + ARIALABEL + '=\"' + (expanded ? COLLAPSE : EXPAND) + '\"></a>' + text + '</p></td></tr>';\n          }\n\n          function groupRowLockedContentBuilder(colspan) {\n            return '<tr role=\"row\" class=\"k-grouping-row\">' + '<td colspan=\"' + colspan + '\" aria-expanded=\"true\">' + '<p class=\"k-reset\">&nbsp;</p></td></tr>';\n          }\n\n          function toggleRow(row, visible) {\n            row = $(row)[0];\n\n            if (visible) {\n              row.style.display = \"\";\n            } else {\n              row.style.display = \"none\";\n            }\n          }\n\n          function htmlEncode(value, backslashEscapeQuotes) {\n            var ampRegExp = /&/g,\n                ltRegExp = /</g,\n                quoteRegExp = /\"/g,\n                aposRegExp = /'/g,\n                gtRegExp = />/g;\n            return (\"\" + value).replace(ampRegExp, \"&amp;\").replace(ltRegExp, \"&lt;\").replace(gtRegExp, \"&gt;\").replace(quoteRegExp, function (match) {\n              if (backslashEscapeQuotes) {\n                return \"\\\\\" + match;\n              }\n\n              return \"&quot;\";\n            }).replace(aposRegExp, \"&#39;\");\n          }\n\n          function getTitle(field, columns) {\n            return columns.filter(function (col) {\n              return col.field === field;\n            })[0].title || field;\n          }\n\n          function exportDataSort(a, b) {\n            return this.dataSource.indexOf(this.dataSource.getByUid(a.uid)) - this.dataSource.indexOf(this.dataSource.getByUid(b.uid));\n          }\n\n          function isExcelExportableColumn(column) {\n            return !(column.exportable === false || column.exportable && column.exportable.excel === false);\n          }\n\n          ui.plugin(Grid);\n          ui.plugin(VirtualScrollable);\n        })(window.kendo.jQuery);\n\n        return window.kendo;\n      }, __webpack_require__(3));\n      /* WEBPACK VAR INJECTION */\n\n    }).call(exports, __webpack_require__(1060));\n    /***/\n  },\n\n  /***/\n  1298:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.columnsorter\");\n    /***/\n  },\n\n  /***/\n  1299:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.filtercell\");\n    /***/\n  },\n\n  /***/\n  1300:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.columnmenu\");\n    /***/\n  },\n\n  /***/\n  1301:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.groupable\");\n    /***/\n  },\n\n  /***/\n  1302:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.pager\");\n    /***/\n  },\n\n  /***/\n  1303:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.sortable\");\n    /***/\n  },\n\n  /***/\n  1304:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.reorderable\");\n    /***/\n  },\n\n  /***/\n  1305:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.ooxml\");\n    /***/\n  },\n\n  /***/\n  1306:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.excel\");\n    /***/\n  },\n\n  /***/\n  1307:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.pane\");\n    /***/\n  },\n\n  /***/\n  1308:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.progressbar\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}