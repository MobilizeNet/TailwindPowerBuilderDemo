{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1433);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1136:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.draganddrop\");\n    /***/\n  },\n\n  /***/\n  1433:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1136)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"slider\",\n        name: \"Slider\",\n        category: \"web\",\n        description: \"The Slider widget provides a rich input for selecting values or ranges of values.\",\n        depends: [\"draganddrop\"]\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            Widget = kendo.ui.Widget,\n            Draggable = kendo.ui.Draggable,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            format = kendo.format,\n            parse = kendo.parseFloat,\n            isArray = Array.isArray,\n            math = Math,\n            support = kendo.support,\n            pointers = support.pointers,\n            msPointers = support.msPointers,\n            CHANGE = \"change\",\n            SLIDE = \"slide\",\n            NS = \".slider\",\n            MOUSE_DOWN = \"touchstart\" + NS + \" mousedown\" + NS,\n            TRACK_MOUSE_DOWN = pointers ? \"pointerdown\" + NS : msPointers ? \"MSPointerDown\" + NS : MOUSE_DOWN,\n            MOUSE_UP = \"touchend\" + NS + \" mouseup\" + NS,\n            TRACK_MOUSE_UP = pointers ? \"pointerup\" : msPointers ? \"MSPointerUp\" + NS : MOUSE_UP,\n            MOVE_SELECTION = \"moveSelection\",\n            KEY_DOWN = \"keydown\" + NS,\n            CLICK = \"click\" + NS,\n            MOUSE_OVER = \"mouseover\" + NS,\n            FOCUS = \"focus\" + NS,\n            BLUR = \"blur\" + NS,\n            DRAG_HANDLE = \".k-draghandle\",\n            TRACK_SELECTOR = \".k-slider-track\",\n            TICK_SELECTOR = \".k-tick\",\n            STATE_SELECTED = \"k-state-selected\",\n            STATE_FOCUSED = \"k-state-focused\",\n            STATE_DISABLED = \"k-state-disabled\",\n            DISABLED = \"disabled\",\n            UNDEFINED = \"undefined\",\n            TABINDEX = \"tabindex\",\n            getTouches = kendo.getTouches,\n            ARIA_VALUETEXT = \"aria-valuetext\",\n            ARIA_VALUENOW = \"aria-valuenow\";\n        var SliderBase = Widget.extend({\n          init: function (element, options) {\n            var that = this;\n            Widget.fn.init.call(that, element, options);\n            options = that.options;\n            that._isHorizontal = options.orientation == \"horizontal\";\n            that._isRtl = that._isHorizontal && kendo.support.isRtl(element);\n            that._position = that._isHorizontal ? \"left\" : \"bottom\";\n            that._sizeFn = that._isHorizontal ? \"width\" : \"height\";\n            that._outerSize = that._isHorizontal ? outerWidth : outerHeight;\n            options.tooltip.format = options.tooltip.enabled ? options.tooltip.format || \"{0}\" : \"{0}\";\n\n            if (options.smallStep <= 0) {\n              throw new Error('Kendo UI Slider smallStep must be a positive number.');\n            }\n\n            that._createHtml();\n\n            that._trackDiv = that.wrapper.find(TRACK_SELECTOR);\n            that._maxSelection = that._trackDiv[that._sizeFn]();\n\n            that._sliderItemsInit();\n\n            that._reset();\n\n            that._tabindex(that.wrapper.find(DRAG_HANDLE));\n\n            that[options.enabled ? \"enable\" : \"disable\"]();\n            var rtlDirectionSign = kendo.support.isRtl(that.wrapper) ? -1 : 1;\n            that._keyMap = {\n              37: step(-1 * rtlDirectionSign * options.smallStep),\n              // left arrow\n              40: step(-options.smallStep),\n              // down arrow\n              39: step(+1 * rtlDirectionSign * options.smallStep),\n              // right arrow\n              38: step(+options.smallStep),\n              // up arrow\n              35: setValue(options.max),\n              // end\n              36: setValue(options.min),\n              // home\n              33: step(+options.largeStep),\n              // page up\n              34: step(-options.largeStep) // page down\n\n            };\n            kendo.notify(that);\n          },\n          events: [CHANGE, SLIDE],\n          options: {\n            enabled: true,\n            min: 0,\n            max: 10,\n            smallStep: 1,\n            largeStep: 5,\n            orientation: \"horizontal\",\n            tickPlacement: \"both\",\n            tooltip: {\n              enabled: true,\n              format: \"{0}\"\n            }\n          },\n          _distance: function () {\n            return round(this.options.max - this.options.min);\n          },\n          _resize: function () {\n            this.wrapper.find(\".k-slider-items\").remove();\n            this._maxSelection = this._trackDiv[this._sizeFn]();\n\n            this._sliderItemsInit();\n\n            this._refresh();\n\n            if (this.options.enabled) {\n              this.enable(true);\n            }\n          },\n          _sliderItemsInit: function () {\n            var that = this,\n                options = that.options; // [Backwards compatibilty]: maxSelection is reduced with 2 to compensate new styling and preserve automatic calculation to not show ticks.\n\n            var sizeBetweenTicks = (that._maxSelection - 2) / ((options.max - options.min) / options.smallStep);\n\n            var pixelWidths = that._calculateItemsWidth(math.floor(removeFraction(that._distance()) / removeFraction(options.smallStep)));\n\n            if (options.tickPlacement != \"none\" && sizeBetweenTicks >= 2) {\n              $(this.element).parent().find(\".k-slider-items\").remove();\n\n              that._trackDiv.before(createSliderItems(options, that._distance()));\n\n              that._setItemsTitle();\n            }\n\n            that._calculateSteps(pixelWidths);\n\n            if (options.tickPlacement != \"none\" && sizeBetweenTicks >= 2 && options.largeStep >= options.smallStep) {\n              that._setItemsLargeTick();\n\n              that.wrapper.find(TICK_SELECTOR).first().addClass(\"k-first\");\n              that.wrapper.find(TICK_SELECTOR).last().addClass(\"k-last\");\n            }\n          },\n          getSize: function () {\n            return kendo.dimensions(this.wrapper);\n          },\n          _setItemsTitle: function () {\n            var that = this,\n                options = that.options,\n                items = that.wrapper.find(TICK_SELECTOR),\n                titleNumber = options.min,\n                count = items.length;\n\n            for (var i = 0; i <= count; i += 1) {\n              $(items[i]).attr(\"title\", format(options.tooltip.format, round(titleNumber)));\n              titleNumber += options.smallStep;\n            }\n          },\n          _setItemsLargeTick: function () {\n            var that = this,\n                options = that.options,\n                items = that.wrapper.find(TICK_SELECTOR),\n                i = 0,\n                item,\n                value;\n\n            if (removeFraction(options.largeStep) % removeFraction(options.smallStep) === 0 || that._distance() / options.largeStep >= 3) {\n              if (!that._isHorizontal && !that._isRtl) {\n                items = $.makeArray(items).reverse();\n              }\n\n              for (i = 0; i < items.length; i++) {\n                item = $(items[i]);\n                value = that._values[i];\n                var valueWithoutFraction = round(removeFraction(value - this.options.min));\n\n                if (valueWithoutFraction % removeFraction(options.smallStep) === 0 && valueWithoutFraction % removeFraction(options.largeStep) === 0) {\n                  item.addClass(\"k-tick-large\").html(\"<span class='k-label'>\" + item.attr(\"title\") + \"</span>\");\n\n                  if (i !== 0 && i !== items.length - 1) {\n                    item.css(\"line-height\", item[that._sizeFn]() + \"px\");\n                  }\n                }\n              }\n            }\n          },\n          _calculateItemsWidth: function (itemsCount) {\n            var that = this,\n                options = that.options,\n                trackDivSize = parseFloat(that._trackDiv.css(that._sizeFn)) + 1,\n                distance = that._distance(),\n                preciseItemsCount = removeFraction(distance) / removeFraction(options.smallStep),\n                pixelStep = trackDivSize / removeFraction(distance),\n                itemWidth,\n                pixelWidths,\n                i;\n\n            if (preciseItemsCount - itemsCount > 0) {\n              trackDivSize -= removeFraction(distance) % removeFraction(options.smallStep) * pixelStep;\n            }\n\n            itemWidth = trackDivSize / itemsCount;\n            pixelWidths = [];\n\n            for (i = 0; i < itemsCount - 1; i++) {\n              pixelWidths[i] = itemWidth;\n            }\n\n            pixelWidths[itemsCount - 1] = pixelWidths[itemsCount] = itemWidth / 2;\n            return that._roundWidths(pixelWidths);\n          },\n          _roundWidths: function (pixelWidthsArray) {\n            var balance = 0,\n                count = pixelWidthsArray.length,\n                i;\n\n            for (i = 0; i < count; i++) {\n              balance += pixelWidthsArray[i] - math.floor(pixelWidthsArray[i]);\n              pixelWidthsArray[i] = math.floor(pixelWidthsArray[i]);\n            }\n\n            balance = math.round(balance);\n            return this._addAdditionalSize(balance, pixelWidthsArray);\n          },\n          _addAdditionalSize: function (additionalSize, pixelWidthsArray) {\n            if (additionalSize === 0) {\n              return pixelWidthsArray;\n            } //set step size\n\n\n            var step = parseFloat(pixelWidthsArray.length - 1) / parseFloat(additionalSize == 1 ? additionalSize : additionalSize - 1),\n                i;\n\n            for (i = 0; i < additionalSize; i++) {\n              pixelWidthsArray[parseInt(math.round(step * i), 10)] += 1;\n            }\n\n            return pixelWidthsArray;\n          },\n          _calculateSteps: function (pixelWidths) {\n            var that = this,\n                options = that.options,\n                val = options.min,\n                selection = 0,\n                distance = that._distance(),\n                itemsCount = math.ceil(removeFraction(distance) / removeFraction(options.smallStep)),\n                i = 1,\n                lastItem;\n\n            itemsCount += removeFraction(distance) / removeFraction(options.smallStep) % 1 === 0 ? 1 : 0;\n            pixelWidths.splice(0, 0, pixelWidths[itemsCount - 2] * 2);\n            pixelWidths.splice(itemsCount - 1, 1, pixelWidths.pop() * 2);\n            that._pixelSteps = [selection];\n            that._values = [val];\n\n            if (itemsCount === 0) {\n              return;\n            }\n\n            while (i < itemsCount) {\n              selection += (pixelWidths[i - 1] + pixelWidths[i]) / 2;\n              that._pixelSteps[i] = selection;\n              val += options.smallStep;\n              that._values[i] = round(val);\n              i++;\n            }\n\n            lastItem = removeFraction(distance) % removeFraction(options.smallStep) === 0 ? itemsCount - 1 : itemsCount;\n            that._pixelSteps[lastItem] = that._maxSelection;\n            that._values[lastItem] = options.max;\n\n            if (that._isRtl) {\n              that._pixelSteps.reverse();\n\n              that._values.reverse();\n            }\n          },\n          _getValueFromPosition: function (mousePosition, draggableArea) {\n            var that = this,\n                options = that.options,\n                step = math.max(options.smallStep * (that._maxSelection / that._distance()), 0),\n                position = 0,\n                halfStep = step / 2,\n                i;\n\n            if (that._isHorizontal) {\n              position = mousePosition - draggableArea.startPoint;\n\n              if (that._isRtl) {\n                position = that._maxSelection - position;\n              }\n            } else {\n              position = draggableArea.startPoint - mousePosition;\n            }\n\n            if (that._maxSelection - (parseInt(that._maxSelection % step, 10) - 3) / 2 < position) {\n              return options.max;\n            }\n\n            for (i = 0; i < that._pixelSteps.length; i++) {\n              if (math.abs(that._pixelSteps[i] - position) - 1 <= halfStep) {\n                return round(that._values[i]);\n              }\n            }\n          },\n          _getFormattedValue: function (val, drag) {\n            var that = this,\n                html = \"\",\n                tooltip = that.options.tooltip,\n                tooltipTemplate,\n                selectionStart,\n                selectionEnd;\n\n            if (isArray(val)) {\n              selectionStart = val[0];\n              selectionEnd = val[1];\n            } else if (drag && drag.type) {\n              selectionStart = drag.selectionStart;\n              selectionEnd = drag.selectionEnd;\n            }\n\n            if (drag) {\n              tooltipTemplate = drag.tooltipTemplate;\n            }\n\n            if (!tooltipTemplate && tooltip.template) {\n              tooltipTemplate = kendo.template(tooltip.template);\n            }\n\n            if (isArray(val) || drag && drag.type) {\n              if (tooltipTemplate) {\n                html = tooltipTemplate({\n                  selectionStart: selectionStart,\n                  selectionEnd: selectionEnd\n                });\n              } else {\n                selectionStart = format(tooltip.format, selectionStart);\n                selectionEnd = format(tooltip.format, selectionEnd);\n                html = selectionStart + \" - \" + selectionEnd;\n              }\n            } else {\n              if (drag) {\n                drag.val = val;\n              }\n\n              if (tooltipTemplate) {\n                html = tooltipTemplate({\n                  value: val\n                });\n              } else {\n                html = format(tooltip.format, val);\n              }\n            }\n\n            return html;\n          },\n          _getDraggableArea: function () {\n            var that = this,\n                offset = kendo.getOffset(that._trackDiv);\n            return {\n              startPoint: that._isHorizontal ? offset.left : offset.top + that._maxSelection,\n              endPoint: that._isHorizontal ? offset.left + that._maxSelection : offset.top\n            };\n          },\n          _createHtml: function () {\n            var that = this,\n                element = that.element,\n                options = that.options,\n                inputs = element.find(\"input\");\n\n            if (inputs.length == 2) {\n              inputs.eq(0).prop(\"value\", formatValue(options.selectionStart));\n              inputs.eq(1).prop(\"value\", formatValue(options.selectionEnd));\n            } else {\n              element.prop(\"value\", formatValue(options.value));\n            }\n\n            that.wrapper = element.wrap(createWrapper(options, element, that._isHorizontal)).hide().parents(\".k-slider\");\n\n            if (options.showButtons) {\n              that.wrapper.find(\".k-slider-track-wrap\").after(createButton(options, \"increase\", that._isHorizontal, that._isRtl)).before(createButton(options, \"decrease\", that._isHorizontal, that._isRtl));\n            }\n\n            element.before(createTrack(options, element, that._isHorizontal));\n          },\n          _focus: function (e) {\n            var that = this,\n                target = e.target,\n                val = that.value(),\n                drag = that._drag;\n\n            if (!drag) {\n              if (target == that.wrapper.find(DRAG_HANDLE).eq(0)[0]) {\n                drag = that._firstHandleDrag;\n                that._activeHandle = 0;\n              } else {\n                drag = that._lastHandleDrag;\n                that._activeHandle = 1;\n              }\n\n              val = val[that._activeHandle];\n            }\n\n            $(target).addClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n\n            if (drag) {\n              that._activeHandleDrag = drag;\n              drag.selectionStart = that.options.selectionStart;\n              drag.selectionEnd = that.options.selectionEnd;\n\n              drag._updateTooltip(val);\n            }\n          },\n          _focusWithMouse: function (target) {\n            target = $(target);\n            var that = this,\n                idx = target.is(DRAG_HANDLE) ? target.index() : 0;\n            window.setTimeout(function () {\n              that.wrapper.find(DRAG_HANDLE)[idx == 2 ? 1 : 0].focus();\n            }, 1);\n\n            that._setTooltipTimeout();\n          },\n          _blur: function (e) {\n            var that = this,\n                drag = that._activeHandleDrag;\n            $(e.target).removeClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n\n            if (drag) {\n              drag._removeTooltip();\n\n              delete that._activeHandleDrag;\n              delete that._activeHandle;\n            }\n          },\n          _setTooltipTimeout: function () {\n            var that = this;\n            that._tooltipTimeout = window.setTimeout(function () {\n              var drag = that._drag || that._activeHandleDrag;\n\n              if (drag) {\n                drag._removeTooltip();\n              }\n            }, 300);\n          },\n          _clearTooltipTimeout: function () {\n            var that = this;\n            window.clearTimeout(this._tooltipTimeout);\n            var drag = that._drag || that._activeHandleDrag;\n\n            if (drag && drag.tooltipDiv) {\n              drag.tooltipDiv.stop(true, false).css(\"opacity\", 1);\n            }\n          },\n          _reset: function () {\n            var that = this,\n                element = that.element,\n                formId = element.attr(\"form\"),\n                form = formId ? $(\"#\" + formId) : element.closest(\"form\");\n\n            if (form[0]) {\n              that._form = form.on(\"reset\", that._formResetHandler.bind(that));\n            }\n          },\n          min: function (value) {\n            if (!value) {\n              return this.options.min;\n            }\n\n            this.setOptions({\n              \"min\": value\n            });\n          },\n          max: function (value) {\n            if (!value) {\n              return this.options.max;\n            }\n\n            this.setOptions({\n              \"max\": value\n            });\n          },\n          setOptions: function (options) {\n            Widget.fn.setOptions.call(this, options);\n\n            this._sliderItemsInit();\n\n            this._refresh();\n          },\n          destroy: function () {\n            if (this._form) {\n              this._form.off(\"reset\", this._formResetHandler);\n            }\n\n            Widget.fn.destroy.call(this);\n          }\n        });\n\n        function createWrapper(options, element, isHorizontal) {\n          var orientationCssClass = isHorizontal ? \" k-slider-horizontal\" : \" k-slider-vertical\",\n              style = options.style ? options.style : element.attr(\"style\"),\n              cssClasses = element.attr(\"class\") ? \" \" + element.attr(\"class\") : \"\",\n              tickPlacementCssClass = \"\";\n\n          if (options.tickPlacement == \"bottomRight\") {\n            tickPlacementCssClass = \" k-slider-bottomright\";\n          } else if (options.tickPlacement == \"topLeft\") {\n            tickPlacementCssClass = \" k-slider-topleft\";\n          }\n\n          style = style ? \" style='\" + style + \"'\" : \"\";\n          return \"<div class='k-widget k-slider\" + orientationCssClass + cssClasses + \"'\" + style + \">\" + \"<div class='k-slider-track-wrap\" + tickPlacementCssClass + \"'></div></div>\";\n        }\n\n        function createButton(options, type, isHorizontal) {\n          var buttonCssClass = \"\";\n\n          if (isHorizontal) {\n            if (type === \"increase\") {\n              buttonCssClass = \"k-i-arrow-e\";\n            } else {\n              buttonCssClass = \"k-i-arrow-w\";\n            }\n          } else {\n            if (type == \"increase\") {\n              buttonCssClass = \"k-i-arrow-n\";\n            } else {\n              buttonCssClass = \"k-i-arrow-s\";\n            }\n          }\n\n          return \"<a role='button' class='k-button k-button-md k-rounded-full k-button-solid k-button-solid-base k-icon-button k-button-\" + type + \"' \" + \"title='\" + options[type + \"ButtonTitle\"] + \"' \" + \"aria-label='\" + options[type + \"ButtonTitle\"] + \"'>\" + \"<span class='k-button-icon k-icon \" + buttonCssClass + \"'></span></a>\";\n        }\n\n        function createSliderItems(options, distance) {\n          var result = \"<ul class='k-reset k-slider-items' role='presentation'>\",\n              count = math.floor(round(distance / options.smallStep)) + 1,\n              i;\n\n          for (i = 0; i < count; i++) {\n            result += \"<li class='k-tick'></li>\";\n          }\n\n          result += \"</ul>\";\n          return result;\n        }\n\n        function createTrack(options, element, isHorizontal) {\n          var dragHandleCount = element.is(\"input\") ? 1 : 2,\n              firstDragHandleTitle = dragHandleCount == 2 ? options.leftDragHandleTitle : options.dragHandleTitle,\n              value = options.value,\n              min = options.selectionStart,\n              max = options.selectionEnd,\n              elementValue,\n              minElementValue,\n              maxElementValue;\n\n          if (dragHandleCount === 1) {\n            elementValue = element.val();\n\n            if (elementValue !== null && elementValue !== undefined && elementValue !== 'null') {\n              if (value === null || value === undefined) {\n                value = elementValue;\n              }\n            }\n          } else {\n            minElementValue = element.find(\"input\").eq(0).val();\n            maxElementValue = element.find(\"input\").eq(1).val();\n\n            if (minElementValue !== null && minElementValue !== undefined && minElementValue !== 'null') {\n              if (min === null || min === undefined) {\n                min = minElementValue;\n              }\n            }\n\n            if (maxElementValue !== null && maxElementValue !== undefined && maxElementValue !== 'null') {\n              if (max === null || max === undefined) {\n                max = maxElementValue;\n              }\n            }\n          }\n\n          var result = \"<div class='k-slider-track'><div class='k-slider-selection'><!-- --></div>\" + \"<span tabindex='0' class='k-draghandle' title='\" + firstDragHandleTitle + \"' role='slider' \" + (isHorizontal === false ? \"aria-orientation='vertical' \" : \"\") + \"aria-valuemin='\" + options.min + \"' aria-valuemax='\" + options.max + \"' aria-valuenow='\" + (dragHandleCount > 1 ? min || options.min : value || options.min) + \"'></span>\" + (dragHandleCount > 1 ? \"<span tabindex='0' class='k-draghandle' title='\" + options.rightDragHandleTitle + \"'role='slider' \" + (isHorizontal === false ? \"aria-orientation='vertical' \" : \"\") + \"aria-valuemin='\" + options.min + \"' aria-valuemax='\" + options.max + \"' aria-valuenow='\" + (max || options.max) + \"'></span>\" : \"\") + \"</div>\";\n          return result;\n        }\n\n        function step(stepValue) {\n          return function (value) {\n            return value + stepValue;\n          };\n        }\n\n        function setValue(value) {\n          return function () {\n            return value;\n          };\n        }\n\n        function formatValue(value) {\n          return (value + \"\").replace(\".\", kendo.cultures.current.numberFormat[\".\"]);\n        }\n\n        function calculatePrecision(value) {\n          var number = value.toString();\n          var precision = 0;\n          number = number.split(\".\");\n\n          if (number[1]) {\n            precision = number[1].length;\n          }\n\n          precision = precision > 10 ? 10 : precision;\n          return precision;\n        }\n\n        function round(value) {\n          var precision, power;\n          value = parseFloat(value, 10);\n          precision = calculatePrecision(value);\n          power = math.pow(10, precision || 0);\n          return math.round(value * power) / power;\n        }\n\n        function parseAttr(element, name) {\n          var value = parse(element.getAttribute(name));\n\n          if (value === null) {\n            value = undefined;\n          }\n\n          return value;\n        }\n\n        function defined(value) {\n          return typeof value !== UNDEFINED;\n        }\n\n        function removeFraction(value) {\n          return value * 10000;\n        }\n\n        var Slider = SliderBase.extend({\n          init: function (element, options) {\n            var that = this,\n                dragHandle;\n            element.type = \"text\";\n            options = extend({}, {\n              value: parseAttr(element, \"value\"),\n              min: parseAttr(element, \"min\"),\n              max: parseAttr(element, \"max\"),\n              smallStep: parseAttr(element, \"step\")\n            }, options);\n            element = $(element);\n\n            if (options && options.enabled === undefined) {\n              options.enabled = !element.is(\"[disabled]\");\n            }\n\n            SliderBase.fn.init.call(that, element, options);\n            options = that.options;\n\n            if (!defined(options.value) || options.value === null) {\n              options.value = options.min;\n              element.prop(\"value\", formatValue(options.min));\n            }\n\n            options.value = math.max(math.min(options.value, options.max), options.min);\n            dragHandle = that.wrapper.find(DRAG_HANDLE);\n            that._selection = new Slider.Selection(dragHandle, that, options);\n            that._drag = new Slider.Drag(dragHandle, \"\", that, options);\n\n            that._refreshAriaAttr(options.value);\n          },\n          options: {\n            name: \"Slider\",\n            showButtons: true,\n            increaseButtonTitle: \"Increase\",\n            decreaseButtonTitle: \"Decrease\",\n            dragHandleTitle: \"drag\",\n            tooltip: {\n              format: \"{0:#,#.##}\"\n            },\n            value: null\n          },\n          enable: function (enable) {\n            var that = this,\n                options = that.options,\n                clickHandler,\n                move;\n            that.disable();\n\n            if (enable === false) {\n              return;\n            }\n\n            that.wrapper.removeClass(STATE_DISABLED);\n            that.wrapper.find(\"input\").prop(DISABLED, false);\n\n            clickHandler = function (e) {\n              var touch = getTouches(e)[0];\n\n              if (!touch) {\n                return;\n              }\n\n              var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,\n                  draggableArea = that._getDraggableArea(),\n                  target = $(e.target);\n\n              if (target.hasClass(\"k-draghandle\")) {\n                target.addClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n                return;\n              }\n\n              that._update(that._getValueFromPosition(mousePosition, draggableArea));\n\n              that._focusWithMouse(e.target);\n\n              that._drag.dragstart(e);\n\n              e.preventDefault();\n            };\n\n            that.wrapper.find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).on(TRACK_MOUSE_DOWN, clickHandler).end().on(TRACK_MOUSE_DOWN, function () {\n              $(document.documentElement).one(\"selectstart\", kendo.preventDefault);\n            }).on(TRACK_MOUSE_UP, function () {\n              that._drag._end();\n            });\n            that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, 0).on(MOUSE_UP, function () {\n              that._setTooltipTimeout();\n            }).on(CLICK, function (e) {\n              that._focusWithMouse(e.target);\n\n              e.preventDefault();\n            }).on(FOCUS, that._focus.bind(that)).on(BLUR, that._blur.bind(that));\n\n            move = function (sign) {\n              var newVal = that._nextValueByIndex(that._valueIndex + sign * 1);\n\n              that._setValueInRange(newVal);\n\n              that._drag._updateTooltip(newVal);\n            }.bind(that);\n\n            if (options.showButtons) {\n              var mouseDownHandler = function (e, sign) {\n                this._clearTooltipTimeout();\n\n                if (e.which === 1 || support.touch && e.which === 0) {\n                  move(sign);\n                  this.timeout = setTimeout(function () {\n                    this.timer = setInterval(function () {\n                      move(sign);\n                    }, 60);\n                  }.bind(this), 200);\n                }\n              }.bind(that);\n\n              that.wrapper.find(\".k-button\").on(MOUSE_UP, function (e) {\n                this._clearTimer();\n\n                that._focusWithMouse(e.target);\n              }.bind(that)).on(MOUSE_OVER, function (e) {\n                $(e.currentTarget).addClass(\"k-state-hover\");\n              }).on(\"mouseout\" + NS, function (e) {\n                $(e.currentTarget).removeClass(\"k-state-hover\");\n\n                this._clearTimer();\n              }.bind(that)).on(MOUSE_DOWN, function (e) {\n                var sign = $(e.target).closest(\".k-button\").is(\".k-button-increase\") ? 1 : -1;\n                mouseDownHandler(e, sign);\n              }.bind(that)).on(\"click\", kendo.preventDefault);\n            }\n\n            that.wrapper.find(DRAG_HANDLE).off(KEY_DOWN, false).on(KEY_DOWN, this._keydown.bind(that));\n            options.enabled = true;\n          },\n          disable: function () {\n            var that = this;\n            that.wrapper.addClass(STATE_DISABLED);\n            $(that.element).prop(DISABLED, DISABLED);\n            that.wrapper.find(\".k-button\").off(MOUSE_DOWN).on(MOUSE_DOWN, function (e) {\n              e.preventDefault();\n              $(this).addClass(\"k-state-active\");\n            }).off(MOUSE_UP).on(MOUSE_UP, function (e) {\n              e.preventDefault();\n              $(this).removeClass(\"k-state-active\");\n            }).off(\"mouseleave\" + NS).on(\"mouseleave\" + NS, kendo.preventDefault).off(MOUSE_OVER).on(MOUSE_OVER, kendo.preventDefault);\n            that.wrapper.find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);\n            that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, -1).off(MOUSE_UP).off(KEY_DOWN).off(CLICK).off(FOCUS).off(BLUR);\n            that.options.enabled = false;\n          },\n          _update: function (val) {\n            var that = this,\n                change = that.value() != val;\n            that.value(val);\n\n            if (change) {\n              that.trigger(CHANGE, {\n                value: that.options.value\n              });\n            }\n          },\n          value: function (value) {\n            var that = this,\n                options = that.options;\n            value = round(value);\n\n            if (isNaN(value)) {\n              return options.value;\n            }\n\n            if (value >= options.min && value <= options.max) {\n              if (options.value != value) {\n                that.element.prop(\"value\", formatValue(value));\n                options.value = value;\n\n                that._refreshAriaAttr(value);\n\n                that._refresh();\n              }\n            }\n          },\n          _refresh: function () {\n            this.trigger(MOVE_SELECTION, {\n              value: this.options.value\n            });\n          },\n          _refreshAriaAttr: function (value) {\n            var that = this,\n                drag = that._drag,\n                formattedValue;\n\n            if (drag && drag._tooltipDiv) {\n              formattedValue = drag._tooltipDiv.text();\n            } else {\n              formattedValue = that._getFormattedValue(value, null);\n            }\n\n            this.wrapper.find(DRAG_HANDLE).attr(ARIA_VALUENOW, value).attr(ARIA_VALUETEXT, formattedValue);\n          },\n          _clearTimer: function () {\n            clearTimeout(this.timeout);\n            clearInterval(this.timer);\n          },\n          _keydown: function (e) {\n            var that = this;\n\n            if (e.keyCode in that._keyMap) {\n              that._clearTooltipTimeout();\n\n              that._setValueInRange(that._keyMap[e.keyCode](that.options.value));\n\n              that._drag._updateTooltip(that.value());\n\n              e.preventDefault();\n            }\n          },\n          _setValueInRange: function (val) {\n            var that = this,\n                options = that.options;\n            val = round(val);\n\n            if (isNaN(val)) {\n              that._update(options.min);\n\n              return;\n            }\n\n            val = math.max(math.min(val, options.max), options.min);\n\n            that._update(val);\n          },\n          _nextValueByIndex: function (index) {\n            var count = this._values.length;\n\n            if (this._isRtl) {\n              index = count - 1 - index;\n            }\n\n            return this._values[math.max(0, math.min(index, count - 1))];\n          },\n          _formResetHandler: function () {\n            var that = this,\n                min = that.options.min;\n            setTimeout(function () {\n              var value = that.element[0].value;\n              that.value(value === \"\" || isNaN(value) ? min : value);\n            });\n          },\n          destroy: function () {\n            var that = this;\n            SliderBase.fn.destroy.call(that);\n            that.wrapper.off(NS).find(\".k-button\").off(NS).end().find(DRAG_HANDLE).off(NS).end().find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).off(NS).end();\n\n            that._drag.draggable.destroy();\n\n            that._drag._removeTooltip(true);\n          }\n        });\n\n        Slider.Selection = function (dragHandle, that, options) {\n          function moveSelection(val) {\n            var selectionValue = val - options.min,\n                index = that._valueIndex = math.ceil(round(selectionValue / options.smallStep)),\n                selection = parseInt(that._pixelSteps[index], 10),\n                selectionDiv = that._trackDiv.find(\".k-slider-selection\"),\n                rtlCorrection = that._isRtl ? 2 : 0;\n\n            selectionDiv[that._sizeFn](that._isRtl ? that._maxSelection - selection : selection);\n\n            dragHandle.css(that._position, selection - rtlCorrection);\n          }\n\n          moveSelection(options.value);\n          that.bind([SLIDE, MOVE_SELECTION], function (e) {\n            moveSelection(parseFloat(e.value, 10));\n          });\n          that.bind(CHANGE, function (e) {\n            moveSelection(parseFloat(e.sender.value(), 10));\n          });\n        };\n\n        Slider.Drag = function (element, type, owner, options) {\n          var that = this;\n          that.owner = owner;\n          that.options = options;\n          that.element = element;\n          that.type = type;\n          that.draggable = new Draggable(element, {\n            distance: 0,\n            dragstart: that._dragstart.bind(that),\n            drag: that.drag.bind(that),\n            dragend: that.dragend.bind(that),\n            dragcancel: that.dragcancel.bind(that)\n          });\n          element.click(false); // Disable link dragging\n\n          element.on(\"dragstart\", function (e) {\n            e.preventDefault();\n          });\n        };\n\n        Slider.Drag.prototype = {\n          dragstart: function (e) {\n            // add reference to the last active drag handle.\n            this.owner._activeDragHandle = this; // HACK to initiate click on the line\n\n            this.draggable.userEvents.cancel();\n\n            this._dragstart(e);\n\n            this.dragend();\n          },\n          _dragstart: function (e) {\n            var that = this,\n                owner = that.owner,\n                options = that.options;\n\n            if (!options.enabled) {\n              e.preventDefault();\n              return;\n            } // add reference to the last active drag handle.\n\n\n            this.owner._activeDragHandle = this;\n            owner.element.off(MOUSE_OVER);\n            owner.wrapper.find(\".\" + STATE_FOCUSED).removeClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n            that.element.addClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n            $(document.documentElement).css(\"cursor\", \"pointer\");\n            that.draggableArea = owner._getDraggableArea();\n            that.step = math.max(options.smallStep * (owner._maxSelection / owner._distance()), 0);\n\n            if (that.type) {\n              that.selectionStart = options.selectionStart;\n              that.selectionEnd = options.selectionEnd;\n\n              owner._setZIndex(that.type);\n            } else {\n              that.oldVal = that.val = options.value;\n            }\n\n            that._removeTooltip(true);\n\n            that._createTooltip();\n          },\n          _createTooltip: function () {\n            var that = this,\n                owner = that.owner,\n                tooltip = that.options.tooltip,\n                html = '',\n                wnd = $(window),\n                tooltipTemplate,\n                calloutCssClass;\n\n            if (!tooltip.enabled) {\n              return;\n            }\n\n            if (tooltip.template) {\n              tooltipTemplate = that.tooltipTemplate = kendo.template(tooltip.template);\n            }\n\n            $(\".k-slider-tooltip\").remove(); // if user changes window while tooltip is visible, a second one will be created\n\n            that.tooltipDiv = $(\"<div class='k-tooltip k-slider-tooltip'><!-- --></div>\").appendTo(document.body);\n            html = owner._getFormattedValue(that.val || owner.value(), that);\n\n            if (!that.type) {\n              calloutCssClass = \"k-callout-\" + (owner._isHorizontal ? 's' : 'e');\n              that.tooltipInnerDiv = \"<div class='k-callout \" + calloutCssClass + \"'><!-- --></div>\";\n              html += that.tooltipInnerDiv;\n            }\n\n            that.tooltipDiv.html(html);\n            that._scrollOffset = {\n              top: wnd.scrollTop(),\n              left: kendo.scrollLeft(wnd)\n            };\n            that.moveTooltip();\n          },\n          drag: function (e) {\n            var that = this,\n                owner = that.owner,\n                x = e.x.location,\n                y = e.y.location,\n                startPoint = that.draggableArea.startPoint,\n                endPoint = that.draggableArea.endPoint,\n                slideParams;\n            e.preventDefault();\n\n            if (owner._isHorizontal) {\n              if (owner._isRtl) {\n                that.val = that.constrainValue(x, startPoint, endPoint, x < endPoint);\n              } else {\n                that.val = that.constrainValue(x, startPoint, endPoint, x >= endPoint);\n              }\n            } else {\n              that.val = that.constrainValue(y, endPoint, startPoint, y <= endPoint);\n            }\n\n            if (that.oldVal != that.val) {\n              that.oldVal = that.val;\n\n              if (that.type) {\n                if (that.type == \"firstHandle\") {\n                  if (that.val < that.selectionEnd) {\n                    that.selectionStart = that.val;\n                  } else {\n                    that.selectionStart = that.selectionEnd = that.val;\n                  }\n                } else {\n                  if (that.val > that.selectionStart) {\n                    that.selectionEnd = that.val;\n                  } else {\n                    that.selectionStart = that.selectionEnd = that.val;\n                  }\n                }\n\n                slideParams = {\n                  values: [that.selectionStart, that.selectionEnd],\n                  value: [that.selectionStart, that.selectionEnd]\n                };\n              } else {\n                slideParams = {\n                  value: that.val\n                };\n              }\n\n              owner.trigger(SLIDE, slideParams);\n            }\n\n            that._updateTooltip(that.val);\n          },\n          _updateTooltip: function (val) {\n            var that = this,\n                options = that.options,\n                tooltip = options.tooltip,\n                html = \"\";\n\n            if (!tooltip.enabled) {\n              return;\n            }\n\n            if (!that.tooltipDiv) {\n              that._createTooltip();\n            }\n\n            html = that.owner._getFormattedValue(round(val), that);\n\n            if (!that.type) {\n              html += that.tooltipInnerDiv;\n            }\n\n            that.tooltipDiv.html(html);\n            that.moveTooltip();\n          },\n          dragcancel: function () {\n            this.owner._refresh();\n\n            $(document.documentElement).css(\"cursor\", \"\");\n            return this._end();\n          },\n          dragend: function () {\n            var that = this,\n                owner = that.owner;\n            $(document.documentElement).css(\"cursor\", \"\");\n\n            if (that.type) {\n              owner._update(that.selectionStart, that.selectionEnd);\n            } else {\n              owner._update(that.val);\n\n              that.draggable.userEvents._disposeAll();\n            }\n\n            that.draggable.userEvents.cancel();\n            return that._end();\n          },\n          _end: function () {\n            var that = this,\n                owner = that.owner;\n\n            owner._focusWithMouse(that.element);\n\n            owner.element.on(MOUSE_OVER);\n            return false;\n          },\n          _removeTooltip: function (noAnimation) {\n            var that = this,\n                owner = that.owner;\n\n            if (that.tooltipDiv && owner.options.tooltip.enabled && owner.options.enabled) {\n              if (noAnimation) {\n                that.tooltipDiv.remove();\n                that.tooltipDiv = null;\n              } else {\n                that.tooltipDiv.fadeOut(\"slow\", function () {\n                  $(this).remove();\n                  that.tooltipDiv = null;\n                });\n              }\n            }\n          },\n          moveTooltip: function () {\n            var that = this,\n                owner = that.owner,\n                top = 0,\n                left = 0,\n                element = that.element,\n                offset = kendo.getOffset(element),\n                margin = 8,\n                viewport = $(window),\n                callout = that.tooltipDiv.find(\".k-callout\"),\n                width = outerWidth(that.tooltipDiv),\n                height = outerHeight(that.tooltipDiv),\n                dragHandles,\n                sdhOffset,\n                diff,\n                anchorSize;\n\n            if (that.type) {\n              dragHandles = owner.wrapper.find(DRAG_HANDLE);\n              offset = kendo.getOffset(dragHandles.eq(0));\n              sdhOffset = kendo.getOffset(dragHandles.eq(1));\n\n              if (owner._isHorizontal) {\n                top = sdhOffset.top;\n                left = offset.left + (sdhOffset.left - offset.left) / 2;\n              } else {\n                top = offset.top + (sdhOffset.top - offset.top) / 2;\n                left = sdhOffset.left;\n              }\n\n              anchorSize = outerWidth(dragHandles.eq(0)) + 2 * margin;\n            } else {\n              top = offset.top;\n              left = offset.left;\n              anchorSize = outerWidth(element) + 2 * margin;\n            }\n\n            if (owner._isHorizontal) {\n              left -= parseInt((width - owner._outerSize(element)) / 2, 10);\n              top -= height + margin + (callout.length ? callout.height() : 0);\n            } else {\n              top -= parseInt((height - owner._outerSize(element)) / 2, 10);\n              left -= width + margin + (callout.length ? callout.width() : 0);\n            }\n\n            if (owner._isHorizontal) {\n              diff = that._flip(top, height, anchorSize, outerHeight(viewport) + that._scrollOffset.top);\n              top += diff;\n              left += that._fit(left, width, outerWidth(viewport) + that._scrollOffset.left);\n            } else {\n              diff = that._flip(left, width, anchorSize, outerWidth(viewport) + that._scrollOffset.left);\n              top += that._fit(top, height, outerHeight(viewport) + that._scrollOffset.top);\n              left += diff;\n            }\n\n            if (diff > 0 && callout) {\n              callout.removeClass();\n              callout.addClass(\"k-callout k-callout-\" + (owner._isHorizontal ? \"n\" : \"w\"));\n            }\n\n            that.tooltipDiv.css({\n              top: top,\n              left: left\n            });\n          },\n          _fit: function (position, size, viewPortEnd) {\n            var output = 0;\n\n            if (position + size > viewPortEnd) {\n              output = viewPortEnd - (position + size);\n            }\n\n            if (position < 0) {\n              output = -position;\n            }\n\n            return output;\n          },\n          _flip: function (offset, size, anchorSize, viewPortEnd) {\n            var output = 0;\n\n            if (offset + size > viewPortEnd) {\n              output += -(anchorSize + size);\n            }\n\n            if (offset + output < 0) {\n              output += anchorSize + size;\n            }\n\n            return output;\n          },\n          constrainValue: function (position, min, max, maxOverflow) {\n            var that = this,\n                val = 0;\n\n            if (min < position && position < max) {\n              val = that.owner._getValueFromPosition(position, that.draggableArea);\n            } else {\n              if (maxOverflow) {\n                val = that.options.max;\n              } else {\n                val = that.options.min;\n              }\n            }\n\n            return val;\n          }\n        };\n        kendo.ui.plugin(Slider);\n        var RangeSlider = SliderBase.extend({\n          init: function (element, options) {\n            var that = this,\n                inputs = $(element).find(\"input\"),\n                firstInput = inputs.eq(0)[0],\n                secondInput = inputs.eq(1)[0];\n            firstInput.type = \"text\";\n            secondInput.type = \"text\";\n\n            if (options && options.showButtons) {\n              if (window.console) {\n                window.console.warn(\"showbuttons option is not supported for the range slider, ignoring\");\n              }\n\n              options.showButtons = false;\n            }\n\n            options = extend({}, {\n              selectionStart: parseAttr(firstInput, \"value\"),\n              min: parseAttr(firstInput, \"min\"),\n              max: parseAttr(firstInput, \"max\"),\n              smallStep: parseAttr(firstInput, \"step\")\n            }, {\n              selectionEnd: parseAttr(secondInput, \"value\"),\n              min: parseAttr(secondInput, \"min\"),\n              max: parseAttr(secondInput, \"max\"),\n              smallStep: parseAttr(secondInput, \"step\")\n            }, options);\n\n            if (options && options.enabled === undefined) {\n              options.enabled = !inputs.is(\"[disabled]\");\n            }\n\n            SliderBase.fn.init.call(that, element, options);\n            options = that.options;\n\n            if (!defined(options.selectionStart) || options.selectionStart === null) {\n              options.selectionStart = options.min;\n              inputs.eq(0).prop(\"value\", formatValue(options.min));\n            }\n\n            if (!defined(options.selectionEnd) || options.selectionEnd === null) {\n              options.selectionEnd = options.max;\n              inputs.eq(1).prop(\"value\", formatValue(options.max));\n            }\n\n            var dragHandles = that.wrapper.find(DRAG_HANDLE);\n            this._selection = new RangeSlider.Selection(dragHandles, that, options);\n            that._firstHandleDrag = new Slider.Drag(dragHandles.eq(0), \"firstHandle\", that, options);\n            that._lastHandleDrag = new Slider.Drag(dragHandles.eq(1), \"lastHandle\", that, options);\n\n            that._refreshAriaAttr(options.selectionStart, options.selectionEnd);\n          },\n          options: {\n            name: \"RangeSlider\",\n            leftDragHandleTitle: \"drag\",\n            rightDragHandleTitle: \"drag\",\n            tooltip: {\n              format: \"{0:#,#.##}\"\n            },\n            selectionStart: null,\n            selectionEnd: null\n          },\n          enable: function (enable) {\n            var that = this,\n                options = that.options,\n                clickHandler;\n            that.disable();\n\n            if (enable === false) {\n              return;\n            }\n\n            that.wrapper.removeClass(STATE_DISABLED);\n            that.wrapper.find(\"input\").prop(DISABLED, false);\n\n            clickHandler = function (e) {\n              var touch = getTouches(e)[0];\n\n              if (!touch) {\n                return;\n              }\n\n              var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY,\n                  draggableArea = that._getDraggableArea(),\n                  val = that._getValueFromPosition(mousePosition, draggableArea),\n                  target = $(e.target),\n                  from,\n                  to,\n                  drag;\n\n              if (target.hasClass(\"k-draghandle\")) {\n                that.wrapper.find(\".\" + STATE_FOCUSED).removeClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n                target.addClass(STATE_FOCUSED + \" \" + STATE_SELECTED);\n                return;\n              }\n\n              if (val < options.selectionStart) {\n                from = val;\n                to = options.selectionEnd;\n                drag = that._firstHandleDrag;\n              } else if (val > that.selectionEnd) {\n                from = options.selectionStart;\n                to = val;\n                drag = that._lastHandleDrag;\n              } else {\n                if (val - options.selectionStart <= options.selectionEnd - val) {\n                  from = val;\n                  to = options.selectionEnd;\n                  drag = that._firstHandleDrag;\n                } else {\n                  from = options.selectionStart;\n                  to = val;\n                  drag = that._lastHandleDrag;\n                }\n              }\n\n              drag.dragstart(e);\n\n              that._setValueInRange(from, to);\n\n              that._focusWithMouse(drag.element);\n            };\n\n            that.wrapper.find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).on(TRACK_MOUSE_DOWN, clickHandler).end().on(TRACK_MOUSE_DOWN, function () {\n              $(document.documentElement).one(\"selectstart\", kendo.preventDefault);\n            }).on(TRACK_MOUSE_UP, function () {\n              if (that._activeDragHandle) {\n                that._activeDragHandle._end();\n              }\n            });\n            that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, 0).on(MOUSE_UP, function () {\n              that._setTooltipTimeout();\n            }).on(CLICK, function (e) {\n              that._focusWithMouse(e.target);\n\n              e.preventDefault();\n            }).on(FOCUS, that._focus.bind(that)).on(BLUR, that._blur.bind(that));\n            that.wrapper.find(DRAG_HANDLE).off(KEY_DOWN, kendo.preventDefault).eq(0).on(KEY_DOWN, function (e) {\n              this._keydown(e, \"firstHandle\");\n            }.bind(that)).end().eq(1).on(KEY_DOWN, function (e) {\n              this._keydown(e, \"lastHandle\");\n            }.bind(that));\n            that.options.enabled = true;\n          },\n          disable: function () {\n            var that = this;\n            that.wrapper.addClass(STATE_DISABLED);\n            that.wrapper.find(\"input\").prop(DISABLED, DISABLED);\n            that.wrapper.find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);\n            that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, -1).off(MOUSE_UP).off(KEY_DOWN).off(CLICK).off(FOCUS).off(BLUR);\n            that.options.enabled = false;\n          },\n          _keydown: function (e, handle) {\n            var that = this,\n                selectionStartValue = that.options.selectionStart,\n                selectionEndValue = that.options.selectionEnd,\n                dragSelectionStart,\n                dragSelectionEnd,\n                activeHandleDrag;\n\n            if (e.keyCode in that._keyMap) {\n              that._clearTooltipTimeout();\n\n              if (handle == \"firstHandle\") {\n                activeHandleDrag = that._activeHandleDrag = that._firstHandleDrag;\n                selectionStartValue = that._keyMap[e.keyCode](selectionStartValue);\n\n                if (selectionStartValue > selectionEndValue) {\n                  selectionEndValue = selectionStartValue;\n                }\n              } else {\n                activeHandleDrag = that._activeHandleDrag = that._lastHandleDrag;\n                selectionEndValue = that._keyMap[e.keyCode](selectionEndValue);\n\n                if (selectionStartValue > selectionEndValue) {\n                  selectionStartValue = selectionEndValue;\n                }\n              }\n\n              that._setValueInRange(round(selectionStartValue), round(selectionEndValue));\n\n              dragSelectionStart = Math.max(selectionStartValue, that.options.selectionStart);\n              dragSelectionEnd = Math.min(selectionEndValue, that.options.selectionEnd);\n              activeHandleDrag.selectionEnd = Math.max(dragSelectionEnd, that.options.selectionStart);\n              activeHandleDrag.selectionStart = Math.min(dragSelectionStart, that.options.selectionEnd);\n\n              activeHandleDrag._updateTooltip(that.value()[that._activeHandle]);\n\n              e.preventDefault();\n            }\n          },\n          _update: function (selectionStart, selectionEnd) {\n            var that = this,\n                values = that.value();\n            var change = values[0] != selectionStart || values[1] != selectionEnd;\n            that.value([selectionStart, selectionEnd]);\n\n            if (change) {\n              that.trigger(CHANGE, {\n                values: [selectionStart, selectionEnd],\n                value: [selectionStart, selectionEnd]\n              });\n            }\n          },\n          value: function (value) {\n            if (value && value.length) {\n              return this._value(value[0], value[1]);\n            } else {\n              return this._value();\n            }\n          },\n          _value: function (start, end) {\n            var that = this,\n                options = that.options,\n                selectionStart = options.selectionStart,\n                selectionEnd = options.selectionEnd;\n\n            if (isNaN(start) && isNaN(end)) {\n              return [selectionStart, selectionEnd];\n            } else {\n              start = round(start);\n              end = round(end);\n            }\n\n            if (start >= options.min && start <= options.max && end >= options.min && end <= options.max && start <= end) {\n              if (selectionStart != start || selectionEnd != end) {\n                that.element.find(\"input\").eq(0).prop(\"value\", formatValue(start)).end().eq(1).prop(\"value\", formatValue(end));\n                options.selectionStart = start;\n                options.selectionEnd = end;\n\n                that._refresh();\n\n                that._refreshAriaAttr(start, end);\n              }\n            }\n          },\n          values: function (start, end) {\n            if (isArray(start)) {\n              return this._value(start[0], start[1]);\n            } else {\n              return this._value(start, end);\n            }\n          },\n          _refresh: function () {\n            var that = this,\n                options = that.options;\n            that.trigger(MOVE_SELECTION, {\n              values: [options.selectionStart, options.selectionEnd],\n              value: [options.selectionStart, options.selectionEnd]\n            });\n\n            if (options.selectionStart == options.max && options.selectionEnd == options.max) {\n              that._setZIndex(\"firstHandle\");\n            }\n          },\n          _refreshAriaAttr: function (start, end) {\n            var that = this,\n                dragHandles = that.wrapper.find(DRAG_HANDLE),\n                drag = that._activeHandleDrag,\n                formattedValue;\n            formattedValue = that._getFormattedValue([start, end], drag);\n            dragHandles.eq(0).attr(ARIA_VALUENOW, start);\n            dragHandles.eq(1).attr(ARIA_VALUENOW, end);\n            dragHandles.attr(ARIA_VALUETEXT, formattedValue);\n          },\n          _setValueInRange: function (selectionStart, selectionEnd) {\n            var options = this.options;\n            selectionStart = math.max(math.min(selectionStart, options.max), options.min);\n            selectionEnd = math.max(math.min(selectionEnd, options.max), options.min);\n\n            if (selectionStart == options.max && selectionEnd == options.max) {\n              this._setZIndex(\"firstHandle\");\n            }\n\n            this._update(math.min(selectionStart, selectionEnd), math.max(selectionStart, selectionEnd));\n          },\n          _setZIndex: function (type) {\n            this.wrapper.find(DRAG_HANDLE).each(function (index) {\n              $(this).css(\"z-index\", type == \"firstHandle\" ? 1 - index : index);\n            });\n          },\n          _formResetHandler: function () {\n            var that = this,\n                options = that.options;\n            setTimeout(function () {\n              var inputs = that.element.find(\"input\");\n              var start = inputs[0].value;\n              var end = inputs[1].value;\n              that.values(start === \"\" || isNaN(start) ? options.min : start, end === \"\" || isNaN(end) ? options.max : end);\n            });\n          },\n          destroy: function () {\n            var that = this;\n            SliderBase.fn.destroy.call(that);\n            that.wrapper.off(NS).find(TICK_SELECTOR + \", \" + TRACK_SELECTOR).off(NS).end().find(DRAG_HANDLE).off(NS);\n\n            that._firstHandleDrag.draggable.destroy();\n\n            that._lastHandleDrag.draggable.destroy();\n          }\n        });\n\n        RangeSlider.Selection = function (dragHandles, that, options) {\n          function moveSelection(value) {\n            value = value || [];\n            var selectionStartValue = value[0] - options.min,\n                selectionEndValue = value[1] - options.min,\n                selectionStartIndex = math.ceil(round(selectionStartValue / options.smallStep)),\n                selectionEndIndex = math.ceil(round(selectionEndValue / options.smallStep)),\n                selectionStart = that._pixelSteps[selectionStartIndex],\n                selectionEnd = that._pixelSteps[selectionEndIndex],\n                rtlCorrection = that._isRtl ? 2 : 0;\n            dragHandles.eq(0).css(that._position, selectionStart - rtlCorrection).end().eq(1).css(that._position, selectionEnd - rtlCorrection);\n            makeSelection(selectionStart, selectionEnd);\n          }\n\n          function makeSelection(selectionStart, selectionEnd) {\n            var selection,\n                selectionPosition,\n                selectionDiv = that._trackDiv.find(\".k-slider-selection\");\n\n            selection = math.abs(selectionStart - selectionEnd);\n\n            selectionDiv[that._sizeFn](selection);\n\n            if (that._isRtl) {\n              selectionPosition = math.max(selectionStart, selectionEnd);\n              selectionDiv.css(\"right\", that._maxSelection - selectionPosition - 1);\n            } else {\n              selectionPosition = math.min(selectionStart, selectionEnd);\n              selectionDiv.css(that._position, selectionPosition - 1);\n            }\n          }\n\n          moveSelection(that.value());\n          that.bind([CHANGE, SLIDE, MOVE_SELECTION], function (e) {\n            moveSelection(e.values);\n          });\n        };\n\n        kendo.ui.plugin(RangeSlider);\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}