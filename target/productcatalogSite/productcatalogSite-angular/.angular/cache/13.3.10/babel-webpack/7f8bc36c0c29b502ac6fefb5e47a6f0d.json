{"ast":null,"code":"import CategoricalChart from '../categorical-chart';\nimport ClusterLayout from '../layout/cluster-layout';\nimport Candlestick from './candlestick';\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport { CANDLESTICK } from '../constants';\nimport areNumbers from '../utils/are-numbers';\nimport { MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { deepExtend, isFunction } from '../../common';\n\nclass CandlestickChart extends CategoricalChart {\n  reflowCategories(categorySlots) {\n    const children = this.children;\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      children[i].reflow(categorySlots[i]);\n    }\n  }\n\n  addValue(data, fields) {\n    const {\n      categoryIx,\n      category,\n      series,\n      seriesIx\n    } = fields;\n    const {\n      children,\n      options\n    } = this;\n    const value = data.valueFields;\n    const valueParts = this.splitValue(value);\n    const hasValue = areNumbers(valueParts);\n    const dataItem = series.data[categoryIx];\n    let categoryPoints = this.categoryPoints[categoryIx];\n    let point;\n\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n\n    if (hasValue) {\n      point = this.createPoint(data, fields);\n    }\n\n    let cluster = children[categoryIx];\n\n    if (!cluster) {\n      cluster = new ClusterLayout({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n\n    if (point) {\n      this.updateRange(value, fields);\n      cluster.append(point);\n      point.categoryIx = categoryIx;\n      point.category = category;\n      point.series = series;\n      point.seriesIx = seriesIx;\n      point.owner = this;\n      point.dataItem = dataItem;\n      point.noteText = data.fields.noteText;\n    }\n\n    this.points.push(point);\n    categoryPoints.push(point);\n  }\n\n  pointType() {\n    return Candlestick;\n  }\n\n  createPoint(data, fields) {\n    const {\n      categoryIx,\n      category,\n      series,\n      seriesIx\n    } = fields;\n    const pointType = this.pointType();\n    const value = data.valueFields;\n    let pointOptions = deepExtend({}, series);\n    let color = data.fields.color || series.color;\n    pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n\n    if (series.type === CANDLESTICK) {\n      if (value.open > value.close) {\n        color = data.fields.downColor || series.downColor || series.color;\n      }\n    }\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    pointOptions.vertical = !this.options.invertAxes;\n    const point = new pointType(value, pointOptions);\n    point.color = color;\n    return point;\n  }\n\n  splitValue(value) {\n    return [value.low, value.open, value.close, value.high];\n  }\n\n  updateRange(value, fields) {\n    const axisName = fields.series.axis;\n    const parts = this.splitValue(value);\n    let axisRange = this.valueAxisRanges[axisName];\n    axisRange = this.valueAxisRanges[axisName] = axisRange || {\n      min: MAX_VALUE,\n      max: MIN_VALUE\n    };\n    axisRange = this.valueAxisRanges[axisName] = {\n      min: Math.min.apply(Math, parts.concat([axisRange.min])),\n      max: Math.max.apply(Math, parts.concat([axisRange.max]))\n    };\n  }\n\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.open, value.high, value.low, value.close, point.category);\n  }\n\n  animationPoints() {\n    return this.points;\n  }\n\n}\n\ndeepExtend(CandlestickChart.prototype, ClipAnimationMixin);\nexport default CandlestickChart;","map":null,"metadata":{},"sourceType":"module"}