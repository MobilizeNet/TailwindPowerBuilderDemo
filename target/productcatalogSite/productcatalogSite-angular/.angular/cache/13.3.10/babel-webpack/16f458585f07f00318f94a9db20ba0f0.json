{"ast":null,"code":"import { geometry as g, throttle } from '@progress/kendo-drawing';\nimport { Class, deepExtend, round, limitValue, hashKey, setDefaultOptions, isFunction } from '../../common';\nimport { removeChildren } from '../utils';\nimport { Layer } from './layer';\nimport TemplateService from '../../services/template-service';\nlet math = Math,\n    Point = g.Point;\n\nfunction compileTemplate(template) {\n  if (isFunction(template)) {\n    return template;\n  }\n\n  return TemplateService.compile(template);\n}\n\nfunction roundPoint(point) {\n  return new Point(round(point.x), round(point.y));\n}\n\nfunction renderSize(size) {\n  let newSize = size;\n\n  if (typeof size !== \"string\") {\n    newSize += \"px\";\n  }\n\n  return newSize;\n}\n\nexport class TileLayer extends Layer {\n  constructor(map, options) {\n    super(map, options);\n\n    if (typeof this.options.subdomains === 'string') {\n      this.options.subdomains = this.options.subdomains.split('');\n    }\n\n    let viewType = this._viewType();\n\n    this._view = new viewType(this.element, this.options);\n  }\n\n  destroy() {\n    super.destroy();\n\n    this._view.destroy();\n\n    this._view = null;\n  }\n\n  _beforeReset() {\n    let map = this.map;\n    let origin = map.locationToLayer(map.extent().nw).round();\n\n    this._view.viewOrigin(origin);\n  }\n\n  _reset() {\n    super._reset();\n\n    this._updateView();\n\n    this._view.reset();\n  }\n\n  _viewType() {\n    return TileView;\n  }\n\n  _activate() {\n    super._activate();\n\n    if (!this.support.mobileOS) {\n      if (!this._pan) {\n        this._pan = throttle(this._render.bind(this), 100);\n      }\n\n      this.map.bind('pan', this._pan);\n    }\n  }\n\n  _deactivate() {\n    super._deactivate();\n\n    if (this._pan) {\n      this.map.unbind('pan', this._pan);\n    }\n  }\n\n  _updateView() {\n    let view = this._view,\n        map = this.map,\n        extent = map.extent(),\n        extentToPoint = {\n      nw: map.locationToLayer(extent.nw).round(),\n      se: map.locationToLayer(extent.se).round()\n    };\n    view.center(map.locationToLayer(map.center()));\n    view.extent(extentToPoint);\n    view.zoom(map.zoom());\n  }\n\n  _resize() {\n    this._render();\n  }\n\n  _panEnd(e) {\n    super._panEnd(e);\n\n    this._render();\n  }\n\n  _render() {\n    this._updateView();\n\n    this._view.render();\n  }\n\n}\nsetDefaultOptions(TileLayer, {\n  tileSize: 256,\n  subdomains: ['a', 'b', 'c'],\n  urlTemplate: '',\n  zIndex: 1\n});\nexport class TileView extends Class {\n  constructor(element, options) {\n    super();\n    this.element = element;\n\n    this._initOptions(options);\n\n    this.pool = new TilePool();\n  }\n\n  _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  }\n\n  center(center) {\n    this._center = center;\n  }\n\n  extent(extent) {\n    this._extent = extent;\n  }\n\n  viewOrigin(origin) {\n    this._viewOrigin = origin;\n  }\n\n  zoom(zoom) {\n    this._zoom = zoom;\n  }\n\n  pointToTileIndex(point) {\n    return new Point(math.floor(point.x / this.options.tileSize), math.floor(point.y / this.options.tileSize));\n  }\n\n  tileCount() {\n    let size = this.size(),\n        firstTileIndex = this.pointToTileIndex(this._extent.nw),\n        nw = this._extent.nw,\n        point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);\n    return {\n      x: math.ceil((math.abs(point.x) + size.width) / this.options.tileSize),\n      y: math.ceil((math.abs(point.y) + size.height) / this.options.tileSize)\n    };\n  }\n\n  size() {\n    let nw = this._extent.nw,\n        se = this._extent.se,\n        diff = se.clone().translate(-nw.x, -nw.y);\n    return {\n      width: diff.x,\n      height: diff.y\n    };\n  }\n\n  indexToPoint(index) {\n    let x = index.x,\n        y = index.y;\n    return new Point(x * this.options.tileSize, y * this.options.tileSize);\n  }\n\n  subdomainText() {\n    let subdomains = this.options.subdomains;\n    return subdomains[this.subdomainIndex++ % subdomains.length];\n  }\n\n  destroy() {\n    removeChildren(this.element);\n    this.pool.empty();\n  }\n\n  reset() {\n    this.pool.reset();\n    this.subdomainIndex = 0;\n    this.render();\n  }\n\n  render() {\n    let size = this.tileCount(),\n        firstTileIndex = this.pointToTileIndex(this._extent.nw),\n        tile,\n        x,\n        y;\n\n    for (x = 0; x < size.x; x++) {\n      for (y = 0; y < size.y; y++) {\n        tile = this.createTile({\n          x: firstTileIndex.x + x,\n          y: firstTileIndex.y + y\n        });\n\n        if (!tile.visible) {\n          tile.show();\n        }\n      }\n    }\n  }\n\n  createTile(currentIndex) {\n    let options = this.tileOptions(currentIndex);\n    let tile = this.pool.get(this._center, options);\n\n    if (!tile.element.parentNode) {\n      this.element.append(tile.element);\n    }\n\n    return tile;\n  }\n\n  tileOptions(currentIndex) {\n    let index = this.wrapIndex(currentIndex),\n        point = this.indexToPoint(currentIndex),\n        origin = this._viewOrigin,\n        offset = point.clone().translate(-origin.x, -origin.y);\n    return {\n      index: index,\n      currentIndex: currentIndex,\n      point: point,\n      offset: roundPoint(offset),\n      zoom: this._zoom,\n      size: this.options.tileSize,\n      subdomain: this.subdomainText(),\n      urlTemplate: this.options.urlTemplate,\n      errorUrlTemplate: this.options.errorUrlTemplate\n    };\n  }\n\n  wrapIndex(index) {\n    let boundary = math.pow(2, this._zoom);\n    return {\n      x: this.wrapValue(index.x, boundary),\n      y: limitValue(index.y, 0, boundary - 1)\n    };\n  }\n\n  wrapValue(value, boundary) {\n    let remainder = math.abs(value) % boundary;\n    let wrappedValue = value;\n\n    if (value >= 0) {\n      wrappedValue = remainder;\n    } else {\n      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);\n    }\n\n    return wrappedValue;\n  }\n\n}\nexport class ImageTile extends Class {\n  constructor(id, options) {\n    super();\n    this.id = id;\n    this.visible = true;\n\n    this._initOptions(options);\n\n    this.createElement();\n    this.show();\n  }\n\n  destroy() {\n    const element = this.element;\n    const parentNode = element ? element.parentNode : null;\n\n    if (element) {\n      if (parentNode) {\n        parentNode.removeChild(element);\n      }\n\n      this.element = null;\n    }\n  }\n\n  _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  }\n\n  createElement() {\n    let el = document.createElement(\"img\");\n    const size = this.options.size + \"px\";\n    el.style.position = \"absolute\";\n    el.style.display = \"block\";\n    el.style.width = el.style.maxWidth = size;\n    el.style.height = el.style.maxHeight = size;\n    this.element = el; // todo\n    // add on error handler\n    // this.element =\n    // $('<img style=\\'position: absolute; display: block;\\' alt=\\'\\' />')\n    // .css({\n    //     width: this.options.size,\n    //     height: this.options.size\n    // })\n    // .on('error', proxy(function(e) {\n    //     if (this.errorUrl()) {\n    //         e.target.setAttribute('src', this.errorUrl());\n    //     } else {\n    //         e.target.removeAttribute('src');\n    //     }\n    // }, this));\n  }\n\n  show() {\n    let element = this.element;\n    element.style.top = renderSize(this.options.offset.y);\n    element.style.left = renderSize(this.options.offset.x);\n    let url = this.url();\n\n    if (url) {\n      element.setAttribute('src', url);\n    }\n\n    element.style.visibility = 'visible';\n    this.visible = true;\n  }\n\n  hide() {\n    this.element.style.visibility = 'hidden';\n    this.visible = false;\n  }\n\n  url() {\n    let urlResult = compileTemplate(this.options.urlTemplate);\n    return urlResult(this.urlOptions());\n  }\n\n  errorUrl() {\n    let urlResult = compileTemplate(this.options.errorUrlTemplate);\n    return urlResult(this.urlOptions());\n  }\n\n  urlOptions() {\n    let options = this.options;\n    return {\n      zoom: options.zoom,\n      subdomain: options.subdomain,\n      z: options.zoom,\n      x: options.index.x,\n      y: options.index.y,\n      s: options.subdomain,\n      quadkey: options.quadkey,\n      q: options.quadkey,\n      culture: options.culture,\n      c: options.culture\n    };\n  }\n\n}\nsetDefaultOptions(ImageTile, {\n  urlTemplate: '',\n  errorUrlTemplate: ''\n});\nexport class TilePool extends Class {\n  constructor() {\n    super();\n    this._items = [];\n  }\n\n  get(center, options) {\n    if (this._items.length >= this.options.maxSize) {\n      this._remove(center);\n    }\n\n    return this._create(options);\n  }\n\n  empty() {\n    let items = this._items;\n\n    for (let i = 0; i < items.length; i++) {\n      items[i].destroy();\n    }\n\n    this._items = [];\n  }\n\n  reset() {\n    let items = this._items;\n\n    for (let i = 0; i < items.length; i++) {\n      items[i].hide();\n    }\n  }\n\n  _create(options) {\n    let items = this._items;\n    let tile;\n    let id = hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);\n\n    for (let i = 0; i < items.length; i++) {\n      if (items[i].id === id) {\n        tile = items[i];\n        break;\n      }\n    }\n\n    if (tile) {\n      tile.show();\n    } else {\n      tile = new ImageTile(id, options);\n\n      this._items.push(tile);\n    }\n\n    return tile;\n  }\n\n  _remove(center) {\n    let items = this._items;\n    let maxDist = -1;\n    let index = -1;\n\n    for (let i = 0; i < items.length; i++) {\n      let dist = items[i].options.point.distanceTo(center);\n\n      if (dist > maxDist && !items[i].visible) {\n        index = i;\n        maxDist = dist;\n      }\n    }\n\n    if (index !== -1) {\n      items[index].destroy();\n      items.splice(index, 1);\n    }\n  }\n\n}\nsetDefaultOptions(TilePool, {\n  maxSize: 100\n});","map":null,"metadata":{},"sourceType":"module"}