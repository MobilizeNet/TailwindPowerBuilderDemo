{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1425);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1417:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.scheduler.view\");\n    /***/\n  },\n\n  /***/\n  1425:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1417)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"scheduler.monthview\",\n        name: \"Scheduler Month View\",\n        category: \"web\",\n        description: \"The Scheduler Month View\",\n        depends: [\"scheduler.view\"],\n        hidden: true\n      };\n\n      (function ($) {\n        var kendo = window.kendo,\n            ui = kendo.ui,\n            SchedulerView = ui.SchedulerView,\n            NS = \".kendoMonthView\",\n            extend = $.extend,\n            getDate = kendo.date.getDate,\n            MS_PER_DAY = kendo.date.MS_PER_DAY,\n            NUMBER_OF_ROWS = 6,\n            NUMBER_OF_COLUMNS = 7,\n            INVERSE_COLOR_CLASS = \"k-event-inverse\",\n            DAY_TEMPLATE = kendo.template('<span class=\"k-link k-nav-day\">#:kendo.toString(date, \"dd\")#</span>'),\n            EVENT_WRAPPER_STRING = '<div role=\"button\" data-#=ns#uid=\"#=uid#\"' + 'aria-label=\"#: ariaLabel #\" ' + '#if (resources[0]) { #' + 'style=\"background-color:#=resources[0].color #; border-color: #=resources[0].color#\"' + 'class=\"k-event\"' + '#} else {#' + 'class=\"k-event\"' + '#}#' + '>' + '<span class=\"k-event-actions\">' + '# if (data.tail || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-left\"></span>' + '#}#' + '# if (data.isException()) {#' + '<span class=\"k-icon k-i-non-recurrence\"></span>' + '# } else if (data.isRecurring()) {#' + '<span class=\"k-icon k-i-reload\"></span>' + '#}#' + '</span>' + '{0}' + '<span class=\"k-event-actions\">' + '#if (showDelete) {#' + '<a href=\"\\\\#\" class=\"k-link k-event-delete\" title=\"${data.messages.destroy}\" aria-label=\"${data.messages.destroy}\"><span class=\"k-icon k-i-close\"></span></a>' + '#}#' + '# if (data.head || data.middle) {#' + '<span class=\"k-icon k-i-arrow-60-right\"></span>' + '#}#' + '</span>' + '# if (resizable && !data.tail && !data.middle) {#' + '<span class=\"k-resize-handle k-resize-w\"></span>' + '#}#' + '# if (resizable && !data.head && !data.middle) {#' + '<span class=\"k-resize-handle k-resize-e\"></span>' + '#}#' + '</div>',\n            EVENT_TEMPLATE = kendo.template('<div title=\"#=title.replace(/\"/g,\"&\\\\#34;\")#\">' + '<div class=\"k-event-template\">#:title#</div>' + '</div>');\n        var CELL_INNER_SPACING = 2;\n        var MORE_BUTTON_TEMPLATE = kendo.template('<div style=\"width:#=width#px;left:#=left#px;top:#=top#px\" class=\"k-more-events k-button k-button-md k-rounded-md k-button-solid k-button-solid-base\"><span class=\"k-button-icon k-icon k-i-more-horizontal\"></span></div>');\n        var MonthGroupedView = kendo.Class.extend({\n          init: function (view) {\n            this._view = view;\n          },\n          _verticalRowCountForLevel: function (level) {\n            var view = this._view;\n            return view._rowCountForLevel(level);\n          },\n          _horizontalGroupCountForLevel: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level);\n          },\n          _getCalendarRowsLength: function (cellsPerRow, cellCount) {\n            return cellCount / cellsPerRow;\n          },\n          _createRows: function (start, startIdx, horizontalGroupCount, verticalGroupIndex) {\n            var view = this._view;\n            var cellsPerRow = NUMBER_OF_COLUMNS;\n\n            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n            var html = \"\";\n\n            for (var groupIdx = 0; groupIdx < horizontalGroupCount; groupIdx++) {\n              html += view._createRow(start, startIdx, cellsPerRow, isVerticallyGrouped ? verticalGroupIndex : groupIdx);\n            }\n\n            return html;\n          },\n          _adjustStartDate: function (start) {\n            return kendo.date.addDays(start, NUMBER_OF_COLUMNS);\n          },\n          _getContent: function (content, startDate, resources) {\n            return content({\n              date: startDate,\n              resources: resources\n            });\n          },\n          _getTimeSlotByPosition: function (x, y, groupIndex) {\n            var group = this._view.groups[groupIndex];\n            return group.daySlotByPosition(x, y);\n          },\n          _nextSlotStartDate: function (startDate) {\n            return kendo.date.nextDay(startDate);\n          },\n          _createRowsLayout: function (resources, rows, groupHeaderTemplate) {\n            var view = this._view;\n            return view._createRowsLayout(resources, rows, groupHeaderTemplate);\n          },\n          _createVerticalColumnsLayout: function (resources, rows, groupHeaderTemplate, columns) {\n            return columns;\n          },\n          _createColumnsLayout: function (resources, columns, groupHeaderTemplate) {\n            var view = this._view;\n            return view._createColumnsLayout(resources, columns, groupHeaderTemplate);\n          },\n          _verticalGroupCount: function (level) {\n            var view = this._view;\n            return view._rowCountForLevel(level);\n          },\n          _horizontalGroupCount: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level) / view._columnOffsetForResource(level);\n          },\n          _positionMobileEvent: function (event, group, range, rangeCount, start, end, rangeIndex) {\n            var view = this._view;\n\n            if (rangeCount > 1) {\n              if (rangeIndex === 0) {\n                end = range.end.endDate();\n              } else if (rangeIndex == rangeCount - 1) {\n                start = range.start.startDate();\n              } else {\n                start = range.start.startDate();\n                end = range.end.endDate();\n              }\n            }\n\n            var occurrence = event.clone({\n              start: new Date(start),\n              end: new Date(end),\n              head: range.head,\n              tail: range.tail\n            });\n\n            view._positionMobileEvent(range, view._createEventElement(occurrence), group);\n          },\n          _positionEvent: function (event, group, range, rangeCount, start, end, rangeIndex) {\n            var view = this._view;\n\n            if (rangeCount > 1) {\n              if (rangeIndex === 0) {\n                end = range.end.endDate();\n              } else if (rangeIndex == rangeCount - 1) {\n                start = range.start.startDate();\n              } else {\n                start = range.start.startDate();\n                end = range.end.endDate();\n              }\n            }\n\n            var occurrence = event.clone({\n              start: start,\n              end: end,\n              head: range.head,\n              tail: range.tail\n            });\n\n            view._positionEvent(range, view._createEventElement(occurrence), group);\n          },\n          _addDaySlotCollections: function (groupCount, tableRows, startDate) {\n            var view = this._view;\n            var columnCount = NUMBER_OF_COLUMNS;\n            var rowCount = NUMBER_OF_ROWS;\n\n            for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {\n              var cellCount = 0;\n              var rowMultiplier = 0;\n\n              if (view._isVerticallyGrouped()) {\n                rowMultiplier = groupIndex;\n              }\n\n              for (var rowIndex = rowMultiplier * rowCount; rowIndex < (rowMultiplier + 1) * rowCount; rowIndex++) {\n                var group = view.groups[groupIndex];\n                var collection = group.addDaySlotCollection(kendo.date.addDays(startDate, cellCount), kendo.date.addDays(startDate, cellCount + columnCount));\n                var tableRow = tableRows[rowIndex];\n                var cells = tableRow.children;\n                var cellMultiplier = 0;\n\n                if (!view._isVerticallyGrouped()) {\n                  cellMultiplier = groupIndex;\n                }\n\n                for (var cellIndex = cellMultiplier * columnCount; cellIndex < (cellMultiplier + 1) * columnCount; cellIndex++) {\n                  var cell = cells[cellIndex];\n                  view.addDaySlot(collection, cell, startDate, cellCount);\n                  cellCount++;\n                }\n              }\n            }\n          },\n          _changePeriodGroupIndex: function (reverse) {\n            var view = this._view;\n            return reverse ? view.groups.length - 1 : 0;\n          },\n          _createResizeHint: function (range) {\n            var view = this._view;\n            var left = range.startSlot().offsetLeft;\n            var top = range.start.offsetTop;\n            var width = range.innerWidth();\n            var height = range.start.clientHeight - 2;\n\n            var hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n            view._appendResizeHint(hint);\n          },\n          _createMoveHint: function (range, event) {\n            var view = this._view;\n            var startSlot = range.startSlot();\n            var endSlot = range.endSlot();\n\n            var hint = view._createEventElement(event.clone({\n              head: range.head,\n              tail: range.tail\n            }));\n\n            hint.css({\n              left: startSlot.offsetLeft + 2,\n              top: startSlot.offsetTop + startSlot.firstChildHeight,\n              height: view.options.eventHeight === \"auto\" ? 25 : view.options.eventHeight,\n              width: range.innerWidth() - (startSlot.index !== endSlot.index ? 3 : 2)\n            });\n            hint.addClass(\"k-event-drag-hint\");\n\n            if (event.inverseColor) {\n              hint.addClass(INVERSE_COLOR_CLASS);\n            }\n\n            view._appendMoveHint(hint);\n          }\n        });\n        var MonthGroupedByDateView = kendo.Class.extend({\n          init: function (view) {\n            this._view = view;\n          },\n          _verticalRowCountForLevel: function () {\n            return 1;\n          },\n          _horizontalGroupCountForLevel: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level + 1) / NUMBER_OF_COLUMNS;\n          },\n          _createRows: function (start, startIdx, horizontalGroupCount) {\n            var view = this._view;\n            var cellsPerRow = NUMBER_OF_COLUMNS;\n\n            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n            var html = \"\";\n            var dateIdx = 0;\n\n            if (isVerticallyGrouped) {\n              var verticalStart = new Date(start);\n\n              var groupCount = view._groupCount();\n\n              for (dateIdx; dateIdx < NUMBER_OF_ROWS; dateIdx++) {\n                html += view._createRow(verticalStart, startIdx, groupCount, dateIdx);\n                verticalStart = kendo.date.addDays(verticalStart, cellsPerRow);\n              }\n\n              start = kendo.date.nextDay(start);\n            } else {\n              for (dateIdx; dateIdx < cellsPerRow; dateIdx++) {\n                html += view._createRow(start, startIdx, horizontalGroupCount, dateIdx);\n                start = kendo.date.nextDay(start);\n              }\n\n              start = kendo.date.addDays(start, cellsPerRow);\n            }\n\n            return html;\n          },\n          _adjustStartDate: function (start, isLastRow) {\n            var view = this._view;\n\n            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n            if (isVerticallyGrouped) {\n              if (isLastRow) {\n                return kendo.date.addDays(start, NUMBER_OF_COLUMNS * (NUMBER_OF_ROWS - 1) + 1);\n              } else {\n                return kendo.date.nextDay(start);\n              }\n            }\n\n            return kendo.date.addDays(start, NUMBER_OF_COLUMNS);\n          },\n          _getContent: function (content, startDate, resources, cellIdx) {\n            if (cellIdx === 0) {\n              return content({\n                date: startDate,\n                resources: resources\n              });\n            }\n\n            return \"\";\n          },\n          _getTimeSlotByPosition: function (x, y, groupIndex) {\n            var group = this._view.groups[groupIndex];\n            return group.daySlotByPosition(x, y, true);\n          },\n          _nextSlotStartDate: function (startDate) {\n            return startDate;\n          },\n          _getCalendarRowsLength: function () {\n            var view = this._view;\n\n            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n            return isVerticallyGrouped ? NUMBER_OF_COLUMNS : NUMBER_OF_ROWS;\n          },\n          _createRowsLayout: function (resources, rows, groupHeaderTemplate, columns) {\n            var view = this._view;\n            return view._createDateLayout(columns, null, false);\n          },\n          _createVerticalColumnsLayout: function (resources, rows, groupHeaderTemplate) {\n            var view = this._view;\n            var resource = resources[0];\n            var configuration = [];\n            var data = resource.dataSource.view();\n\n            for (var dataIndex = 0; dataIndex < data.length * NUMBER_OF_ROWS; dataIndex++) {\n              var value = kendo.getter(resource.dataValueField)(data[dataIndex % data.length]);\n              var obj = {\n                text: groupHeaderTemplate({\n                  text: kendo.htmlEncode(kendo.getter(resource.dataTextField)(data[dataIndex % data.length])),\n                  color: kendo.getter(resource.dataColorField)(data[dataIndex % data.length]),\n                  field: resource.field,\n                  title: resource.title,\n                  name: resource.name,\n                  value: value\n                }),\n                className: \"k-slot-cell\",\n                value: value\n              };\n              obj.columns = view._createColumnsLayout(resources.slice(1), null, groupHeaderTemplate, null, null, value);\n              configuration.push(obj);\n            }\n\n            return configuration;\n          },\n          _createColumnsLayout: function (resources, columns, groupHeaderTemplate, subColumns) {\n            var view = this._view;\n            return view._createColumnsLayout(resources, columns, groupHeaderTemplate, subColumns, true);\n          },\n          _verticalGroupCount: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level) / NUMBER_OF_ROWS;\n          },\n          _horizontalGroupCount: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level) / NUMBER_OF_COLUMNS;\n          },\n          _positionMobileEvent: function (event, group, range, rangeCount, start, end) {\n            var view = this._view;\n            var startIndex = range.start.index;\n            var endIndex = range.end.index;\n\n            for (var i = range.start.index; i <= range.end.index; i++) {\n              var currentSlot = range.collection._slots[i];\n              var dateRange = group.daySlotRanges(currentSlot.start, currentSlot.start, true)[0];\n              var occurrence = event.clone({\n                start: i === startIndex ? start : currentSlot.startDate(),\n                end: i === endIndex ? end : currentSlot.endDate(),\n                head: i !== endIndex || range.head,\n                tail: i !== startIndex || range.tail\n              });\n\n              view._positionMobileEvent(dateRange, view._createEventElement(occurrence), group);\n            }\n          },\n          _positionEvent: function (event, group, range, rangeCount, start, end) {\n            var view = this._view;\n            var startIndex = range.start.index;\n            var endIndex = range.end.index;\n\n            for (var i = range.start.index; i <= range.end.index; i++) {\n              var currentSlot = range.collection._slots[i];\n              var dateRange = group.daySlotRanges(currentSlot.start, currentSlot.start, true)[0];\n              var occurrence = event.clone({\n                start: i === startIndex ? start : currentSlot.startDate(),\n                end: i === endIndex ? end : currentSlot.endDate(),\n                head: i !== endIndex || range.head,\n                tail: i !== startIndex || range.tail\n              });\n\n              view._positionEvent(dateRange, view._createEventElement(occurrence), group);\n            }\n          },\n          _addDaySlotCollections: function (groupCount, tableRows, startDate) {\n            var view = this._view;\n            var columnCount = NUMBER_OF_COLUMNS;\n            var rowCount = NUMBER_OF_ROWS;\n\n            var isVerticallyGrouped = view._isVerticallyGrouped();\n\n            for (var dateIndex = 0; dateIndex < columnCount; dateIndex++) {\n              for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n                var groupIndex = 0;\n                var currentTableIndex = isVerticallyGrouped ? dateIndex : rowIndex;\n                var tableRow = tableRows[currentTableIndex];\n                var cells = tableRow.children;\n                var cellMultiplier = 0;\n\n                if (!view._isVerticallyGrouped()) {\n                  cellMultiplier = dateIndex;\n                }\n\n                for (var cellIndex = cellMultiplier * groupCount; cellIndex < (cellMultiplier + 1) * groupCount; cellIndex++) {\n                  var cellCount = rowIndex * columnCount + dateIndex;\n                  var currentCellIndex = isVerticallyGrouped ? cellIndex + rowIndex * groupCount : cellIndex;\n                  var cell = cells[currentCellIndex];\n                  var currentGroupIndex = isVerticallyGrouped ? cellIndex : groupIndex;\n                  var group = view.groups[currentGroupIndex];\n                  var collection;\n\n                  if (dateIndex === 0) {\n                    collection = group.addDaySlotCollection(kendo.date.addDays(startDate, cellCount), kendo.date.addDays(startDate, cellCount + columnCount));\n                  } else {\n                    collection = group._daySlotCollections[rowIndex];\n                  }\n\n                  view.addDaySlot(collection, cell, startDate, cellCount);\n                  groupIndex++;\n                }\n              }\n            }\n          },\n          _changePeriodGroupIndex: function (reverse, vertical, selectionGroupIndex) {\n            var view = this._view;\n\n            if (vertical && view._isVerticallyGrouped()) {\n              return reverse ? view.groups.length - 1 : 0;\n            }\n\n            return selectionGroupIndex;\n          },\n          _createResizeHint: function (range) {\n            var view = this._view;\n            var left, top, width, height, hint;\n\n            if (view._isVerticallyGrouped()) {\n              left = range.startSlot().offsetLeft;\n              top = range.start.offsetTop;\n              width = range.startSlot().offsetWidth;\n              height = range.endSlot().offsetTop + range.startSlot().offsetHeight - range.startSlot().offsetTop - 2;\n              hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n              view._appendResizeHint(hint);\n            } else {\n              for (var slotIdx = range.startSlot().index; slotIdx <= range.endSlot().index; slotIdx++) {\n                var slot = range.collection._slots[slotIdx];\n                left = slot.offsetLeft;\n                top = slot.offsetTop;\n                width = slot.offsetWidth;\n                height = slot.offsetHeight - 2;\n                hint = SchedulerView.fn._createResizeHint.call(view, left, top, width, height);\n\n                view._appendResizeHint(hint);\n              }\n            }\n          },\n          _createMoveHint: function (range, event) {\n            var view = this._view;\n            var startSlot = range.startSlot();\n            var endSlot = range.endSlot();\n\n            for (var slotIdx = startSlot.index; slotIdx <= endSlot.index; slotIdx++) {\n              var slot = range.collection._slots[slotIdx];\n\n              var hint = view._createEventElement(event.clone({\n                head: range.head,\n                tail: range.tail\n              }));\n\n              hint.css({\n                left: slot.offsetLeft,\n                top: slot.offsetTop + slot.firstChildHeight,\n                height: view.options.eventHeight === \"auto\" ? 25 : view.options.eventHeight,\n                width: slot.offsetWidth - 2\n              });\n              hint.addClass(\"k-event-drag-hint\");\n\n              if (event.inverseColor) {\n                hint.addClass(INVERSE_COLOR_CLASS);\n              }\n\n              view._appendMoveHint(hint);\n            }\n          }\n        });\n        kendo.ui.scheduler.MonthGroupedView = MonthGroupedView;\n        kendo.ui.scheduler.MonthGroupedByDateView = MonthGroupedByDateView;\n        ui.MonthView = SchedulerView.extend({\n          init: function (element, options) {\n            var that = this; // Do not allow less than one event\n\n            if (options.eventsPerDay === 0) {\n              options.eventsPerDay = 1;\n            } // Do not allow 0 height events\n\n\n            if (options.eventHeight === 0) {\n              options.eventHeight = 1;\n            } // Do not allow 0 height more-button\n\n\n            if (options.moreButtonHeight === 0) {\n              options.moreButtonHeight = 1;\n            } // Do not allow string values other than auto\n\n\n            if (typeof options.eventHeight === \"string\" && options.eventHeight !== \"auto\") {\n              options.eventHeight = 25;\n            } // Set adaptiveSlotHeight to true if eventHeight is auto\n\n\n            if (options.eventHeight === \"auto\") {\n              options.adaptiveSlotHeight = true;\n            }\n\n            SchedulerView.fn.init.call(that, element, options);\n            that._groupedView = that._getGroupedView(); // Exception handling for invalid combinations\n\n            var isGroupedByDate = this._isGroupedByDate();\n\n            var adaptiveSlotHeight = this.options.adaptiveSlotHeight;\n            var eventHeight = this.options.eventHeight;\n\n            if (isGroupedByDate === true && adaptiveSlotHeight === true) {\n              throw new Error(\"Incompatible options: adaptive slot height and date grouping!\");\n            }\n\n            if (isGroupedByDate === true && eventHeight === \"auto\") {\n              throw new Error(\"Incompatible options: auto event height and date grouping!\");\n            }\n\n            that.title = that.options.title;\n\n            that._templates();\n\n            that._editable();\n\n            that._renderLayout(that.options.date);\n\n            that._groups();\n          },\n          name: \"month\",\n          _getGroupedView: function () {\n            if (this._isGroupedByDate()) {\n              return new kendo.ui.scheduler.MonthGroupedByDateView(this);\n            } else {\n              return new kendo.ui.scheduler.MonthGroupedView(this);\n            }\n          },\n          _updateDirection: function (selection, ranges, multiple, reverse, vertical) {\n            if (multiple) {\n              var startSlot = ranges[0].start;\n              var endSlot = ranges[ranges.length - 1].end;\n              var isSameSlot = startSlot.index === endSlot.index;\n              var isSameCollection = startSlot.collectionIndex === endSlot.collectionIndex;\n              var updateDirection;\n\n              if (vertical) {\n                updateDirection = isSameSlot && isSameCollection || isSameCollection;\n              } else {\n                updateDirection = isSameSlot && isSameCollection;\n              }\n\n              if (updateDirection) {\n                selection.backward = reverse;\n              }\n            }\n          },\n          _changeDate: function (selection, slot, previous) {\n            var group = this.groups[selection.groupIndex];\n            var collections, index;\n\n            if (previous) {\n              collections = group._getCollections(group.daySlotCollectionCount());\n              index = slot.collectionIndex - 1;\n\n              if (index >= 0) {\n                return collections[index]._slots[collections[index]._slots.length - 1];\n              }\n            } else {\n              collections = group._getCollections(group.daySlotCollectionCount());\n              index = slot.collectionIndex + 1;\n              var slotIndex = 0;\n\n              if (collections[index] && collections[index]._slots[slotIndex]) {\n                return collections[index]._slots[slotIndex];\n              }\n            }\n          },\n          _getNextHorizontalRange: function (group, method, horizontalRange) {\n            var isVertical = this._isVerticallyGrouped();\n\n            horizontalRange.startSlot = group[method](horizontalRange.startSlot, isVertical);\n            horizontalRange.endSlot = group[method](horizontalRange.endSlot, isVertical);\n            return horizontalRange;\n          },\n          _getNextVerticalRange: function (group, method, verticalRange, multiple) {\n            var isVertical = this._isVerticallyGrouped() && this._isGroupedByDate();\n\n            verticalRange.startSlot = group[method](verticalRange.startSlot, multiple, isVertical);\n            verticalRange.endSlot = group[method](verticalRange.endSlot, multiple, isVertical);\n            return verticalRange;\n          },\n          _changeViewPeriod: function (selection, reverse, vertical) {\n            var pad = vertical ? 7 : 1;\n            var newStart, newEnd;\n\n            if (reverse) {\n              pad *= -1;\n            }\n\n            newStart = kendo.date.addDays(selection.start, pad);\n            newEnd = kendo.date.addDays(selection.end, pad);\n\n            if (this._isInRange(newStart, newEnd)) {\n              return false;\n            }\n\n            selection.start = newStart;\n            selection.end = newEnd;\n\n            if (!vertical || vertical && this._isVerticallyGrouped()) {\n              selection.groupIndex = this._groupedView._changePeriodGroupIndex(reverse, vertical, selection.groupIndex);\n            }\n\n            selection.events = [];\n            return true;\n          },\n          _continuousSlot: function (selection, ranges, reverse) {\n            var index = selection.backward ? 0 : ranges.length - 1;\n            var group = this.groups[selection.groupIndex];\n            return group.continuousSlot(ranges[index].start, reverse);\n          },\n          _changeGroupContinuously: function (selection, continuousSlot, multiple, reverse) {\n            if (!multiple) {\n              var groupIndex = selection.groupIndex;\n              var lastGroupIndex = this.groups.length - 1;\n\n              var vertical = this._isVerticallyGrouped();\n\n              var group = this.groups[groupIndex];\n\n              if (!continuousSlot && vertical) {\n                continuousSlot = group[reverse ? \"lastSlot\" : \"firstSlot\"]();\n                groupIndex += reverse ? -1 : 1;\n              } else if (continuousSlot && !vertical) {\n                groupIndex = reverse ? lastGroupIndex : 0;\n              }\n\n              if (groupIndex < 0 || groupIndex > lastGroupIndex) {\n                groupIndex = reverse ? lastGroupIndex : 0;\n                continuousSlot = null;\n              }\n\n              selection.groupIndex = groupIndex;\n            }\n\n            return continuousSlot;\n          },\n          _normalizeHorizontalSelection: function (selection, ranges, reverse) {\n            var slot;\n\n            if (reverse) {\n              slot = ranges[0].start;\n            } else {\n              slot = ranges[ranges.length - 1].end;\n            }\n\n            return slot;\n          },\n          _normalizeVerticalSelection: function (selection, ranges) {\n            var slot;\n\n            if (selection.backward) {\n              slot = ranges[0].start;\n            } else {\n              slot = ranges[ranges.length - 1].end;\n            }\n\n            return slot;\n          },\n          _templates: function () {\n            var options = this.options,\n                settings = extend({}, kendo.Template, options.templateSettings);\n            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n            this.dayTemplate = kendo.template(options.dayTemplate, settings);\n            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n          },\n          dateForTitle: function () {\n            return kendo.format(this.options.selectedDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n          },\n          shortDateForTitle: function () {\n            return kendo.format(this.options.selectedShortDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n          },\n          mobileDateForTitle: function () {\n            return kendo.format(this.options.selectedMobileDateFormat, this._firstDayOfMonth, this._lastDayOfMonth);\n          },\n          nextDate: function () {\n            return kendo.date.nextDay(this._lastDayOfMonth);\n          },\n          previousDate: function () {\n            return kendo.date.previousDay(this._firstDayOfMonth);\n          },\n          startDate: function () {\n            return this._startDate;\n          },\n          endDate: function () {\n            return this._endDate;\n          },\n          _renderLayout: function (date) {\n            var that = this;\n            this._firstDayOfMonth = kendo.date.firstDayOfMonth(date);\n            this._lastDayOfMonth = kendo.date.lastDayOfMonth(date);\n            this._startDate = firstVisibleMonthDay(date, this.calendarInfo());\n            this.createLayout(this._layout());\n\n            this._content();\n\n            this._initSlotHeight();\n\n            this.refreshLayout();\n\n            if (this._isVirtualized()) {\n              this._tryRenderContent();\n            }\n\n            this.content.on(\"click\" + NS, \".k-nav-day,.k-more-events\", function (e) {\n              var offset = $(e.currentTarget).offset();\n\n              var slot = that._slotByPosition(offset.left, offset.top);\n\n              e.preventDefault();\n              that.trigger(\"navigate\", {\n                view: \"day\",\n                date: slot.startDate()\n              });\n            });\n\n            this._footer();\n          },\n          _editable: function () {\n            if (this.options.editable) {\n              if (this._isMobile()) {\n                this._touchEditable();\n              } else {\n                this._mouseEditable();\n              }\n            }\n          },\n          _mouseEditable: function () {\n            var that = this;\n            that.element.on(\"click\" + NS, \".k-scheduler-monthview .k-event a:has(.k-i-close)\", function (e) {\n              that.trigger(\"remove\", {\n                uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n              });\n              e.preventDefault();\n            });\n\n            if (that.options.editable.create !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-scheduler-monthview .k-scheduler-content td\", function (e) {\n                var offset = $(e.currentTarget).offset();\n\n                var slot = that._slotByPosition(offset.left, offset.top);\n\n                if (slot) {\n                  var resourceInfo = that._resourceBySlot(slot);\n\n                  that.trigger(\"add\", {\n                    eventInfo: extend({\n                      isAllDay: true,\n                      start: slot.startDate(),\n                      end: slot.startDate()\n                    }, resourceInfo)\n                  });\n                }\n\n                e.preventDefault();\n              });\n            }\n\n            if (that.options.editable.update !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-scheduler-monthview .k-event\", function (e) {\n                that.trigger(\"edit\", {\n                  uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n                });\n                e.preventDefault();\n              });\n            }\n          },\n          _touchEditable: function () {\n            var that = this;\n            var threshold = 0;\n\n            if (kendo.support.mobileOS.android) {\n              threshold = 5;\n            }\n\n            if (that.options.editable.create !== false) {\n              that._addUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                useClickAsTap: !kendo.support.browser.edge,\n                filter: \".k-scheduler-monthview .k-scheduler-content td\",\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  var offset = $(e.target).offset();\n\n                  var slot = that._slotByPosition(offset.left, offset.top);\n\n                  if (slot) {\n                    var resourceInfo = that._resourceBySlot(slot);\n\n                    that.trigger(\"add\", {\n                      eventInfo: extend({\n                        isAllDay: true,\n                        start: slot.startDate(),\n                        end: slot.startDate()\n                      }, resourceInfo)\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              });\n            }\n          },\n          selectionByElement: function (cell) {\n            var offset = $(cell).offset();\n            return this._slotByPosition(offset.left, offset.top);\n          },\n          _columnCountForLevel: function (level) {\n            var columnLevel = this.columnLevels[level];\n            return columnLevel ? columnLevel.length : 0;\n          },\n          _rowCountForLevel: function (level) {\n            var rowLevel = this.rowLevels[level];\n            return rowLevel ? rowLevel.length : 0;\n          },\n          _content: function () {\n            var html = '<tbody>';\n            var verticalGroupCount = 1;\n            var groupedView = this._groupedView;\n            var resources = this.groupedResources;\n\n            if (resources.length) {\n              if (this._isVerticallyGrouped()) {\n                verticalGroupCount = groupedView._verticalRowCountForLevel(resources.length - 1);\n              }\n            }\n\n            for (var verticalGroupIdx = 0; verticalGroupIdx < verticalGroupCount; verticalGroupIdx++) {\n              html += this._createCalendar(verticalGroupIdx);\n              this._cachedGroupIndex = verticalGroupIdx;\n            }\n\n            html += \"</tbody>\";\n            this.content.find(\"table\").html(html);\n          },\n          _virtualContent: function () {\n            var that = this;\n            var html = '';\n            html += this._createCalendar(++this._cachedGroupIndex);\n            that.content.find(\"table tbody\").append(html);\n\n            that._initSlotHeight();\n          },\n          _calcSlotHeight: function (eventsPerDay) {\n            var options = this.options;\n            var eventHeight = options.eventHeight;\n            var eventSpacing = options.eventSpacing;\n            var moreButtonHeight = options.moreButtonHeight;\n            var firstCell = this.content.find(\"table tr td\")[0];\n            var dateHeader;\n\n            if (eventHeight === \"auto\" || !firstCell) {\n              return undefined;\n            }\n\n            dateHeader = firstCell.firstChild;\n            return Math.round( // border of cell\n            firstCell.offsetHeight - firstCell.clientHeight + // top padding\n            dateHeader.offsetTop + // height of date header\n            dateHeader.offsetHeight + // cell inner spacing\n            CELL_INNER_SPACING + // all visible events and spacing\n            eventsPerDay * eventHeight + (eventsPerDay - 1) * eventSpacing + ( // leading space, more button\n            CELL_INNER_SPACING + moreButtonHeight) + // traling spacing\n            CELL_INNER_SPACING);\n          },\n          _initSlotHeight: function () {\n            var options = this.options;\n            var eventsPerDay = options.eventsPerDay;\n            var eventHeight = options.eventHeight;\n\n            var isMobile = this._isMobile();\n\n            var table = this.content.find(\"table\");\n            var rowHeight;\n\n            if (isMobile) {\n              return;\n            }\n\n            if (typeof eventHeight === \"number\") {\n              rowHeight = this._calcSlotHeight(eventsPerDay);\n              table.find(\"tr\").height(rowHeight);\n              table.addClass(\"k-scheduler-table-auto\");\n            }\n          },\n          _adjustSlotHeight: function (group) {\n            var options = this.options;\n            var eventHeight = options.eventHeight;\n            var eventSpacing = options.eventSpacing;\n            var moreButtonHeight = options.moreButtonHeight;\n\n            if (this._canAdjustSlotHeight !== true) {\n              return;\n            }\n\n            var weeks = group._daySlotCollections;\n            this.content.find(\"table\").addClass(\"k-scheduler-table-auto\");\n            weeks.forEach(function (week) {\n              var events = week._events;\n              var eventIndex = 0;\n              var slots = week._slots;\n              var firstSlot = slots[0];\n              var weekOffsetTop = firstSlot.element.offsetTop;\n              var weekHeight = 0; // Ensure event meta exists in each slot\n\n              slots.forEach(function (slot) {\n                if (!slot.eventMeta) {\n                  slot.eventMeta = [];\n                  slot.actualEventCount = 0;\n                } else {\n                  slot.actualEventCount = slot.eventMeta.length;\n                }\n              }); // Ensure spanning event meta is present in all related slots\n\n              slots.forEach(function (slot, slotIndex) {\n                slot.eventMeta.forEach(function (meta, eventIndex) {\n                  // Skip events not starting in this slot\n                  if (meta.startIndex !== slotIndex) {\n                    return;\n                  } // Skip non-spanning events\n\n\n                  if (meta.startIndex === meta.endIndex) {\n                    return;\n                  } // Copy spanning event meta in all related slots\n\n\n                  slots.slice(slotIndex, meta.endIndex + 1).forEach(function (adjSlot) {\n                    var adjMeta = adjSlot.eventMeta;\n\n                    if (adjMeta.indexOf(meta) > -1) {\n                      return;\n                    } // adjMeta.push(meta);\n\n\n                    adjMeta[adjMeta.length] = slot.eventMeta[eventIndex];\n                    adjSlot.actualEventCount = adjMeta.length;\n                    adjSlot.dirty = true;\n                  });\n                }); // Set correct order\n\n                if (slot.dirty === true) {\n                  slot.eventMeta.sort(function (first, second) {\n                    return first.order - second.order;\n                  });\n                  delete slot.dirty;\n                }\n              });\n\n              if (eventHeight === \"auto\") {\n                slots.forEach(function (slot, slotIndex) {\n                  // jshint ignore:line\n                  var slotHeight = slot.firstChildTop + slot.firstChildHeight + CELL_INNER_SPACING;\n                  slot.eventMeta.forEach(function (meta, eventIndex) {\n                    // jshint ignore:line\n                    meta.top = Math.max(meta.top, weekOffsetTop + slotHeight);\n                    slotHeight = meta.top - weekOffsetTop + eventSpacing + meta.height;\n                  });\n                });\n              } // Position events\n\n\n              slots.forEach(function (slot, slotIndex) {\n                var slotHeight = slot.firstChildTop + slot.firstChildHeight + CELL_INNER_SPACING;\n                slot.eventMeta.forEach(function (meta) {\n                  meta.top = Math.max(meta.top, weekOffsetTop + slotHeight);\n                  slotHeight = meta.top - weekOffsetTop + eventSpacing + meta.height;\n\n                  if (meta.startIndex === slotIndex) {\n                    events[eventIndex].element[0].style.top = meta.top + \"px\";\n                    eventIndex++;\n                  }\n                });\n\n                if (slot.eventMeta.length > 0) {\n                  slotHeight -= eventSpacing;\n                  slotHeight += CELL_INNER_SPACING;\n                } else {\n                  slotHeight += eventHeight === \"auto\" ? 25 : eventHeight;\n                }\n\n                if (slot.more) {\n                  slot.more[0].style.top = weekOffsetTop + slotHeight + \"px\";\n                  slotHeight += CELL_INNER_SPACING + moreButtonHeight;\n                }\n\n                weekHeight = Math.max(weekHeight, slotHeight + 1);\n              }); // Update slot size and meta\n\n              firstSlot.element.parentNode.style.height = weekHeight + \"px\";\n              slots.forEach(function (slot) {\n                slot.offsetTop = weekOffsetTop;\n                slot.offsetHeight = weekHeight;\n                slot.clientHeight = weekHeight - 1;\n              });\n            }.bind(this));\n          },\n          _createCalendar: function (verticalGroupIndex) {\n            var start = this.startDate();\n            var cellCount = NUMBER_OF_COLUMNS * NUMBER_OF_ROWS;\n            var cellsPerRow = NUMBER_OF_COLUMNS;\n            var weekStartDates = [start];\n            var html = '';\n            var horizontalGroupCount = 1;\n\n            var isVerticallyGrouped = this._isVerticallyGrouped();\n\n            var groupedView = this._groupedView;\n            var resources = this.groupedResources;\n\n            if (resources.length) {\n              if (!isVerticallyGrouped) {\n                horizontalGroupCount = groupedView._horizontalGroupCountForLevel(resources.length - 1);\n              }\n            }\n\n            this._slotIndices = {};\n\n            var calendarRowsLength = groupedView._getCalendarRowsLength(cellsPerRow, cellCount);\n\n            for (var rowIdx = 0; rowIdx < calendarRowsLength; rowIdx++) {\n              html += \"<tr>\";\n              weekStartDates.push(start);\n              var startIdx = rowIdx * cellsPerRow;\n              html += groupedView._createRows(start, startIdx, horizontalGroupCount, verticalGroupIndex);\n              start = groupedView._adjustStartDate(start, rowIdx === calendarRowsLength - 1);\n              html += \"</tr>\";\n            }\n\n            this._weekStartDates = weekStartDates;\n            this._endDate = kendo.date.previousDay(start);\n            return html;\n          },\n          _createRow: function (startDate, startIdx, cellsPerRow, groupIndex) {\n            var that = this;\n            var min = that._firstDayOfMonth;\n            var max = that._lastDayOfMonth;\n            var content = that.dayTemplate;\n            var classes = \"\";\n            var html = \"\";\n            var groupedView = this._groupedView;\n\n            var resources = function () {\n              return that._resourceBySlot({\n                groupIndex: groupIndex\n              });\n            };\n\n            for (var cellIdx = 0; cellIdx < cellsPerRow; cellIdx++) {\n              classes = \"\";\n\n              if (kendo.date.isToday(startDate)) {\n                classes += \"k-today\";\n              }\n\n              if (!kendo.date.isInDateRange(startDate, min, max)) {\n                classes += \" k-other-month\";\n              }\n\n              html += \"<td \";\n\n              if (classes !== \"\") {\n                html += 'class=\"' + classes + '\"';\n              }\n\n              html += \">\";\n              html += groupedView._getContent(content, startDate, resources, cellIdx);\n              html += \"</td>\";\n              that._slotIndices[getDate(startDate).getTime()] = startIdx + cellIdx;\n              startDate = groupedView._nextSlotStartDate(startDate);\n            }\n\n            return html;\n          },\n          _layout: function () {\n            var calendarInfo = this.calendarInfo();\n            var weekDayNames = this._isMobile() ? calendarInfo.days.namesShort.map(function (name) {\n              return name[0];\n            }) : calendarInfo.days.names;\n            var names = shiftArray(weekDayNames, calendarInfo.firstDay);\n            var columns = $.map(names, function (value) {\n              return {\n                text: value\n              };\n            });\n            var resources = this.groupedResources;\n            var rows;\n            var groupedView = this._groupedView;\n\n            if (resources.length) {\n              if (this._isVerticallyGrouped()) {\n                var inner = []; //add hidden cells in order to sync the content rows\n\n                for (var idx = 0; idx < 6; idx++) {\n                  inner.push({\n                    text: \"<div>&nbsp;</div>\",\n                    className: \"k-hidden k-slot-cell\"\n                  });\n                }\n\n                rows = groupedView._createRowsLayout(resources, inner, this.groupHeaderTemplate, columns);\n                columns = groupedView._createVerticalColumnsLayout(resources, inner, this.groupHeaderTemplate, columns);\n              } else {\n                columns = groupedView._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n              }\n            }\n\n            return {\n              columns: columns,\n              rows: rows\n            };\n          },\n          _createEventElement: function (event) {\n            var options = this.options;\n            var editable = options.editable;\n\n            var isMobile = this._isMobile();\n\n            event.showDelete = editable && editable.destroy !== false && !isMobile;\n            event.resizable = editable && editable.resize !== false && !isMobile;\n            event.ns = kendo.ns;\n            event.resources = this.eventResources(event);\n            event.inverseColor = false;\n            event.messages = options.messages || {\n              destroy: \"Delete\"\n            };\n            var element = $(this.eventTemplate($.extend({}, event, {\n              ariaLabel: this._formatEventAriaLabel(event.title, event.start, event.end, event.isAllDay)\n            })));\n            this.angular(\"compile\", function () {\n              return {\n                elements: element,\n                data: [{\n                  dataItem: event\n                }]\n              };\n            });\n            return element;\n          },\n          _isInDateSlot: function (event) {\n            var groups = this.groups[0];\n            var slotStart = groups.firstSlot().start;\n            var slotEnd = groups.lastSlot().end - 1;\n            var startTime = kendo.date.toUtcTime(event.start);\n            var endTime = kendo.date.toUtcTime(event.end);\n            return (isInDateRange(startTime, slotStart, slotEnd) || isInDateRange(endTime, slotStart, slotEnd) || isInDateRange(slotStart, startTime, endTime) || isInDateRange(slotEnd, startTime, endTime)) && (!isInDateRange(endTime, slotStart, slotStart) || isInDateRange(endTime, startTime, startTime) || event.isAllDay);\n          },\n          _slotIndex: function (date) {\n            return this._slotIndices[getDate(date).getTime()];\n          },\n          _positionMobileEvent: function (slotRange, element, group) {\n            var startSlot = slotRange.start,\n                tableEl = this.table.find(\".k-scheduler-content .k-scheduler-table\")[0],\n                contentEl = this.table.find(\".k-scheduler-content\")[0],\n                offsetLeft;\n\n            if (slotRange.start.offsetLeft > slotRange.end.offsetLeft) {\n              startSlot = slotRange.end;\n            }\n\n            var startIndex = slotRange.start.index;\n            var endIndex = startIndex;\n            var eventCount = 3;\n            var events = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n            events.push({\n              element: element,\n              start: startIndex,\n              end: endIndex\n            });\n            var rows = SchedulerView.createRows(events);\n            var slot = slotRange.collection.at(startIndex);\n            var container = slot.container;\n\n            if (!container) {\n              if (this._isRtl && contentEl.clientWidth < contentEl.scrollWidth) {\n                // RTL mobile rendering with horizontal scroll\n                offsetLeft = startSlot.offsetLeft - (tableEl.clientWidth - contentEl.clientWidth) + \"px\";\n              } else {\n                offsetLeft = startSlot.offsetLeft + \"px\";\n              }\n\n              container = $(kendo.format('<div class=\"k-events-container\" style=\"top:{0};left:{1};width:{2}\"></div>', startSlot.offsetTop + startSlot.firstChildTop + startSlot.firstChildHeight + \"px\", offsetLeft, startSlot.offsetWidth + \"px\"));\n              slot.container = container;\n              this.content[0].appendChild(container[0]);\n            }\n\n            if (rows.length <= eventCount) {\n              slotRange.addEvent({\n                element: element,\n                start: startIndex,\n                end: endIndex,\n                groupIndex: startSlot.groupIndex\n              });\n\n              group._continuousEvents.push({\n                element: element,\n                uid: element.attr(kendo.attr(\"uid\")),\n                start: slotRange.start,\n                end: slotRange.end\n              });\n\n              container[0].appendChild(element[0]);\n            }\n          },\n          _positionEvent: function (slotRange, element, group) {\n            var eventHeight = this.options.eventHeight;\n            var eventSpacing = this.options.eventSpacing;\n            var startSlot = slotRange.start;\n\n            if (slotRange.start.offsetLeft > slotRange.end.offsetLeft) {\n              startSlot = slotRange.end;\n            }\n\n            var startIndex = slotRange.start.index;\n            var endIndex = slotRange.end.index;\n            var eventCount = startSlot.eventCount;\n            var events = SchedulerView.collidingEvents(slotRange.events(), startIndex, endIndex);\n            var rightOffset = startIndex !== endIndex ? 3 : 2;\n            events.push({\n              element: element,\n              start: startIndex,\n              end: endIndex\n            });\n            var rows = SchedulerView.createRows(events);\n\n            for (var idx = 0, length = Math.min(rows.length, eventCount); idx < length; idx++) {\n              var rowEvents = rows[idx].events;\n              var eventTop = eventHeight === \"auto\" ? \"\" // jshint ignore:line\n              : startSlot.offsetTop + startSlot.firstChildTop + startSlot.firstChildHeight + CELL_INNER_SPACING + idx * (eventHeight + eventSpacing) + \"px\";\n\n              for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n                rowEvents[j].element[0].style.top = eventTop;\n                rowEvents[j].element.attr(kendo.attr(\"order\"), idx);\n              }\n            }\n\n            if (rows.length > eventCount) {\n              for (var slotIndex = startIndex; slotIndex <= endIndex; slotIndex++) {\n                var collection = slotRange.collection;\n                var slot = collection.at(slotIndex);\n\n                if (slot.more) {\n                  continue;\n                }\n\n                slot.more = $(MORE_BUTTON_TEMPLATE({\n                  ns: kendo.ns,\n                  start: slotIndex,\n                  end: slotIndex,\n                  width: slot.clientWidth - 2,\n                  left: slot.offsetLeft + 2,\n                  top: eventHeight === \"auto\" ? \"\" // jshint ignore:line\n                  : slot.offsetTop + slot.firstChildTop + slot.firstChildHeight + CELL_INNER_SPACING + eventCount * eventHeight + (eventCount - 1) * eventSpacing + CELL_INNER_SPACING\n                }));\n                this.content[0].appendChild(slot.more[0]);\n              }\n            } else {\n              slotRange.addEvent({\n                element: element,\n                start: startIndex,\n                end: endIndex,\n                groupIndex: startSlot.groupIndex\n              });\n              element[0].style.width = slotRange.innerWidth() - rightOffset + \"px\";\n              element[0].style.left = startSlot.offsetLeft + 2 + \"px\";\n              element[0].style.height = eventHeight === \"auto\" ? \"\" : eventHeight + \"px\";\n\n              group._continuousEvents.push({\n                element: element,\n                uid: element.attr(kendo.attr(\"uid\")),\n                start: slotRange.start,\n                end: slotRange.end,\n                order: parseInt(element.attr(kendo.attr(\"order\")), 10)\n              });\n\n              element.appendTo(this.content);\n\n              this._inverseEventColor(element); // Add event meta to slot\n\n\n              var _collectionIndex = slotRange.start.collectionIndex;\n              var _startSlotIndex = slotRange.start.index;\n              var _startSlot = group._daySlotCollections[_collectionIndex]._slots[_startSlotIndex];\n\n              if (!_startSlot.eventMeta) {\n                _startSlot.eventMeta = [];\n              }\n\n              _startSlot.eventMeta.push({\n                height: eventHeight === \"auto\" ? element.outerHeight() : eventHeight,\n                top: 0,\n                startIndex: _startSlotIndex,\n                endIndex: slotRange.end.index,\n                uid: element.attr(kendo.attr(\"uid\")),\n                order: parseInt(element.attr(kendo.attr(\"order\")), 10)\n              });\n            }\n          },\n          _slotByPosition: function (x, y) {\n            var offset = this.content.offset();\n            x -= offset.left;\n            y -= offset.top;\n            y += this.content[0].scrollTop;\n            x += this.content[0].scrollLeft;\n            x = Math.ceil(x);\n            y = Math.ceil(y);\n\n            for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n              var slot = this._groupedView._getTimeSlotByPosition(x, y, groupIndex);\n\n              if (slot) {\n                return slot;\n              }\n            }\n\n            return null;\n          },\n          _appendResizeHint: function (hint) {\n            hint.appendTo(this.content);\n            this._resizeHint = this._resizeHint.add(hint);\n          },\n          _updateResizeHint: function (event, groupIndex, startTime, endTime) {\n            this._removeResizeHint();\n\n            var group = this.groups[groupIndex];\n            var ranges = group.ranges(startTime, endTime, true, event.isAllDay);\n\n            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n              this._groupedView._createResizeHint(ranges[rangeIndex]);\n            }\n\n            this._resizeHint.find(\".k-label-top,.k-label-bottom\").text(\"\");\n\n            this._resizeHint.first().addClass(\"k-first\").find(\".k-label-top\").text(kendo.toString(kendo.timezone.toLocalDate(startTime), \"M/dd\"));\n\n            this._resizeHint.last().addClass(\"k-last\").find(\".k-label-bottom\").text(kendo.toString(kendo.timezone.toLocalDate(endTime), \"M/dd\"));\n          },\n          _updateMoveHint: function (event, groupIndex, distance) {\n            var start = kendo.date.toUtcTime(event.start) + distance;\n            var end = start + event.duration();\n            var group = this.groups[groupIndex];\n            var ranges = group.ranges(start, end, true, event.isAllDay);\n\n            this._removeMoveHint(event.uid);\n\n            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n              this._groupedView._createMoveHint(ranges[rangeIndex], event);\n            }\n          },\n          _appendMoveHint: function (hint) {\n            hint.appendTo(this.content);\n            this._moveHint = this._moveHint.add(hint);\n          },\n          _groups: function () {\n            var groupCount = this._groupCount();\n\n            var tableRows = this.content[0].getElementsByTagName(\"tr\");\n            var startDate = this.startDate();\n            this.groups = [];\n\n            for (var idx = 0; idx < groupCount; idx++) {\n              this._addResourceView(idx);\n            }\n\n            this._groupedView._addDaySlotCollections(groupCount, tableRows, startDate);\n          },\n          addDaySlot: function (collection, cell, startDate, cellCount) {\n            var start = kendo.date.addDays(startDate, cellCount);\n            var end = kendo.date.MS_PER_DAY;\n            var eventsPerDay = this.options.eventsPerDay;\n\n            if (startDate.getHours() !== start.getHours()) {\n              end += (startDate.getHours() - start.getHours()) * kendo.date.MS_PER_HOUR;\n            }\n\n            start = kendo.date.toUtcTime(start);\n            end += start;\n            collection.addDaySlot(cell, start, end, eventsPerDay);\n          },\n          render: function (events) {\n            this.content.children(\".k-event,.k-more-events,.k-events-container\").remove();\n            this._cachedEvents = events;\n\n            this._groups();\n\n            events = new kendo.data.Query(events).sort([{\n              field: \"start\",\n              dir: \"asc\"\n            }, {\n              field: \"end\",\n              dir: \"desc\"\n            }]).toArray().filter(function (event) {\n              return this._isInDateSlot(event);\n            }.bind(this));\n            var resources = this.groupedResources;\n\n            var isMobile = this._isMobile();\n\n            var isGroupedByDate = this._isGroupedByDate();\n\n            var adaptiveSlotHeight = this.options.adaptiveSlotHeight;\n            this._canAdjustSlotHeight = isMobile !== true && isGroupedByDate !== true && resources.length === 0 && adaptiveSlotHeight === true;\n\n            if (resources.length) {\n              this._renderGroups(events, resources, 0, 1);\n            } else {\n              this._renderEvents(events, 0);\n            }\n\n            this.refreshLayout();\n            this.trigger(\"activate\");\n          },\n          _renderEvents: function (events, groupIndex) {\n            var group = this.groups[groupIndex];\n            var view = this._groupedView._view;\n\n            var isMobile = view._isMobile();\n\n            if (!group) {\n              return;\n            }\n\n            if (!group._continuousEvents) {\n              group._continuousEvents = [];\n            }\n\n            if (isMobile) {\n              events.forEach(function (event) {\n                var ranges = group.slotRanges(event, true);\n                var range = ranges[0];\n                var start = range.start.start;\n                var end = range.end.end;\n                var rangeStart = new Date(range.start.start);\n                var rangeEnd = ranges[ranges.length - 1].end.end;\n                var newStart = new Date(rangeStart);\n                var newEnd = new Date(end);\n\n                while (rangeStart.getTime() <= rangeEnd && event.end >= kendo.timezone.toLocalDate(rangeStart) && event.start <= kendo.timezone.toLocalDate(rangeEnd)) {\n                  var dateRange = group.daySlotRanges(newStart.getTime(), newEnd.getTime(), true)[0];\n                  newEnd.setDate(newEnd.getDate() + 1);\n                  newStart.setDate(newStart.getDate() + 1);\n\n                  if (dateRange) {\n                    dateRange.head = null;\n                    dateRange.middle = null;\n                    dateRange.tail = null;\n\n                    this._groupedView._positionMobileEvent(event, group, dateRange, 1, start, end, 0);\n                  }\n\n                  rangeStart = kendo.date.addDays(rangeStart, 1);\n                }\n              }.bind(this));\n            } else {\n              events.forEach(function (event) {\n                var range;\n                var start = event.start;\n                var end = event.end;\n                var ranges = group.slotRanges(event, true);\n                var rangeCount = ranges.length;\n\n                for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++) {\n                  range = ranges[rangeIndex];\n\n                  this._groupedView._positionEvent(event, group, range, rangeCount, start, end, rangeIndex);\n                }\n              }.bind(this));\n\n              if (this._canAdjustSlotHeight === true) {\n                this._adjustSlotHeight(group);\n              }\n            }\n          },\n          _renderGroups: function (events, resources, offset, columnLevel, parentValue) {\n            var resource = resources[0];\n\n            if (resource) {\n              var view = resource.dataSource.view();\n              view = view.filter(function (item) {\n                var itemParentValue = kendo.getter(resource.dataParentValueField)(item);\n                return itemParentValue === null || itemParentValue === undefined || itemParentValue === parentValue;\n              });\n\n              for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n                var value = this._resourceValue(resource, view[itemIdx]);\n\n                var tmp = new kendo.data.Query(events).filter({\n                  field: resource.field,\n                  operator: SchedulerView.groupEqFilter(value)\n                }).toArray();\n\n                if (resources.length > 1) {\n                  offset = this._renderGroups(tmp, resources.slice(1), offset++, columnLevel + 1, value);\n                } else {\n                  this._renderEvents(tmp, offset++);\n                }\n              }\n            }\n\n            return offset;\n          },\n          _groupCount: function () {\n            var resources = this.groupedResources;\n            var groupedView = this._groupedView;\n\n            if (resources.length) {\n              if (this._isVerticallyGrouped()) {\n                return groupedView._verticalGroupCount(resources.length - 1);\n              } else {\n                return groupedView._horizontalGroupCount(resources.length);\n              }\n            }\n\n            return 1;\n          },\n          _columnOffsetForResource: function (index) {\n            return this._columnCountForLevel(index) / this._columnCountForLevel(index - 1);\n          },\n          destroy: function () {\n            if (this.table) {\n              this.table.removeClass(\"k-scheduler-monthview\");\n            }\n\n            if (this.content) {\n              this.content.off(NS);\n            }\n\n            if (this.element) {\n              this.element.off(NS);\n            }\n\n            SchedulerView.fn.destroy.call(this);\n\n            if (this._isMobile() && this.options.editable) {\n              if (this.options.editable.create !== false) {\n                this._addUserEvents.destroy();\n              }\n            }\n          },\n          events: [\"remove\", \"add\", \"edit\", \"navigate\"],\n          options: {\n            title: \"Month\",\n            name: \"month\",\n            eventHeight: 25,\n            moreButtonHeight: 13,\n            editable: true,\n            selectedDateFormat: \"{0:y}\",\n            selectedShortDateFormat: \"{0:y}\",\n            selectedMobileDateFormat: \"{0:MMMM}\",\n            groupHeaderTemplate: \"#=text#\",\n            dayTemplate: DAY_TEMPLATE,\n            eventTemplate: EVENT_TEMPLATE,\n            eventsPerDay: 2,\n            adaptiveSlotHeight: false,\n            eventSpacing: 3\n          }\n        });\n\n        function shiftArray(array, idx) {\n          return array.slice(idx).concat(array.slice(0, idx));\n        }\n\n        function firstVisibleMonthDay(date, calendarInfo) {\n          var firstDay = calendarInfo.firstDay,\n              firstVisibleDay = new Date(date.getFullYear(), date.getMonth(), 0, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\n          while (firstVisibleDay.getDay() != firstDay) {\n            kendo.date.setTime(firstVisibleDay, -1 * MS_PER_DAY);\n          }\n\n          return firstVisibleDay;\n        }\n\n        function isInDateRange(value, min, max) {\n          var msMin = min,\n              msMax = max,\n              msValue;\n          msValue = value;\n          return msValue >= msMin && msValue <= msMax;\n        }\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}