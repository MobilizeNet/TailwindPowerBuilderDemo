{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, round, isArray } from '../../common';\nimport { COORD_PRECISION } from '../../common/constants';\nimport Gauge from '../gauge';\nimport RadialScale from './radial-scale';\nimport RadialPointer from './radial-pointer';\nconst Group = drawing.Group;\n\nclass RadialGauge extends Gauge {\n  reflow(bbox) {\n    const pointers = this.pointers;\n    this.scale.reflow(bbox);\n    this._initialPlotArea = this.scale.bbox;\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(this.scale.arc);\n      this._initialPlotArea = geo.Rect.union(this._initialPlotArea, pointers[i].bbox);\n    }\n\n    this.fitScale(bbox);\n    this.alignScale(bbox);\n\n    this._buildVisual(this.gaugeArea, pointers, this.scale);\n\n    this._draw();\n  }\n\n  _buildVisual(gaugeArea, pointers, scale) {\n    const visuals = this._visuals = new Group();\n    visuals.append(gaugeArea);\n    visuals.append(scale.ticks);\n    visuals.append(scale.ranges);\n\n    this._buildPointers(pointers);\n\n    visuals.append(scale.labelElements);\n  }\n\n  _buildPointers(pointers) {\n    for (let i = 0; i < pointers.length; i++) {\n      const current = pointers[i];\n      current.render();\n\n      this._visuals.append(current.elements);\n\n      current.value(current.options.value);\n    }\n  }\n\n  fitScale(bbox) {\n    const arc = this.scale.arc;\n    const plotAreaBox = this._initialPlotArea;\n    const step = Math.abs(this.getDiff(plotAreaBox, bbox));\n    let min = round(step, COORD_PRECISION);\n    let max = round(-step, COORD_PRECISION);\n    let minDiff, midDiff, maxDiff, mid, oldDiff;\n    let staleFlag = 0;\n    let i = 0;\n\n    while (i++ < 100) {\n      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;\n\n      if (staleFlag > 5) {\n        break;\n      }\n\n      if (min !== mid) {\n        minDiff = this.getPlotBox(min, bbox, arc);\n\n        if (0 <= minDiff && minDiff <= 2) {\n          break;\n        }\n      }\n\n      if (max !== mid) {\n        maxDiff = this.getPlotBox(max, bbox, arc);\n\n        if (0 <= maxDiff && maxDiff <= 2) {\n          break;\n        }\n      }\n\n      if (minDiff > 0 && maxDiff > 0) {\n        mid = min * 2;\n      } else if (minDiff < 0 && maxDiff < 0) {\n        mid = max * 2;\n      } else {\n        mid = round((min + max) / 2 || 1, COORD_PRECISION);\n      }\n\n      midDiff = this.getPlotBox(mid, bbox, arc);\n\n      if (0 <= midDiff && midDiff <= 2) {\n        break;\n      }\n\n      oldDiff = maxDiff;\n\n      if (midDiff > 0) {\n        max = mid;\n        maxDiff = midDiff;\n      } else {\n        min = mid;\n        minDiff = midDiff;\n      }\n    }\n  }\n\n  getPlotBox(step, bbox, arc) {\n    const scale = this.scale;\n    const pointers = this.pointers;\n    const radius = arc.getRadiusX();\n    const scaleArc = arc.clone();\n    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n    scale.arc = scaleArc;\n    scale.reflow(bbox);\n    this.plotBbox = scale.bbox;\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(scaleArc);\n      this.plotBbox = geo.Rect.union(this.plotBbox, pointers[i].bbox);\n    }\n\n    return this.getDiff(this.plotBbox, bbox);\n  }\n\n  getDiff(plotBox, box) {\n    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n  }\n\n  alignScale(bbox) {\n    const plotBoxCenter = this.plotBbox.center();\n    const boxCenter = bbox.center();\n    const paddingX = plotBoxCenter.x - boxCenter.x;\n    const paddingY = plotBoxCenter.y - boxCenter.y;\n    const {\n      scale,\n      pointers\n    } = this;\n    scale.arc.center.x -= paddingX;\n    scale.arc.center.y -= paddingY;\n    scale.reflow(bbox);\n\n    for (let i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(scale.arc);\n      this.plotBbox = geo.Rect.union(scale.bbox, pointers[i].bbox);\n    }\n  }\n\n  _createModel() {\n    const options = this.options;\n    const pointers = options.pointer;\n    const scale = this.scale = new RadialScale(options.scale, this.contextService);\n    this.pointers = [];\n    const pointersArr = isArray(pointers) ? pointers : [pointers];\n\n    for (let i = 0; i < pointersArr.length; i++) {\n      const current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n        animation: {\n          transitions: options.transitions\n        }\n      }));\n      this.pointers.push(current);\n    }\n  }\n\n}\n\nsetDefaultOptions(RadialGauge, {\n  transitions: true,\n  gaugeArea: {\n    background: \"\"\n  }\n});\nexport default RadialGauge;","map":null,"metadata":{},"sourceType":"module"}