{"ast":null,"code":"import { ChartElement, Box } from '../../core';\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport ErrorRangeCalculator from '../error-bars/error-range-calculator';\nimport ScatterErrorBar from '../error-bars/scatter-error-bar';\nimport LinePoint from '../line-chart/line-point';\nimport CategoricalChart from '../categorical-chart';\nimport hasValue from '../utils/has-value';\nimport evalOptions from '../utils/eval-options';\nimport { deepExtend, isNumber, isString, defined, isFunction, setDefaultOptions } from '../../common';\nimport { X, Y, MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { parseDate } from '../../date-utils';\n\nclass ScatterChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n\n    this._initFields();\n\n    this.render();\n  }\n\n  _initFields() {\n    // X and Y axis ranges grouped by name, e.g.:\n    // primary: { min: 0, max: 1 }\n    this.xAxisRanges = {};\n    this.yAxisRanges = {};\n    this.points = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n  }\n\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n\n  addErrorBar(point, field, fields) {\n    const value = point.value[field];\n    const valueErrorField = field + \"Value\";\n    const lowField = field + \"ErrorLow\";\n    const highField = field + \"ErrorHigh\";\n    const {\n      seriesIx,\n      series\n    } = fields;\n    const errorBars = point.options.errorBars;\n    const lowValue = fields[lowField];\n    const highValue = fields[highField];\n\n    if (isNumber(value)) {\n      let errorRange;\n\n      if (isNumber(lowValue) && isNumber(highValue)) {\n        errorRange = {\n          low: lowValue,\n          high: highValue\n        };\n      }\n\n      if (errorBars && defined(errorBars[valueErrorField])) {\n        this.seriesErrorRanges = this.seriesErrorRanges || {\n          x: [],\n          y: []\n        };\n        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n      }\n\n      if (errorRange) {\n        this.addPointErrorBar(errorRange, point, field);\n      }\n    }\n  }\n\n  addPointErrorBar(errorRange, point, field) {\n    const {\n      low,\n      high\n    } = errorRange;\n    const {\n      series,\n      options: {\n        errorBars: options\n      }\n    } = point;\n    const isVertical = field === Y;\n    const item = {};\n    point[field + \"Low\"] = low;\n    point[field + \"High\"] = high;\n    point.errorBars = point.errorBars || [];\n    const errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars.push(errorBar);\n    point.append(errorBar);\n    item[field] = low;\n    this.updateRange(item, series);\n    item[field] = high;\n    this.updateRange(item, series);\n  }\n\n  addValue(value, fields) {\n    const {\n      x,\n      y\n    } = value;\n    const seriesIx = fields.seriesIx;\n    const series = this.options.series[seriesIx];\n    const missingValues = this.seriesMissingValues(series);\n    const seriesPoints = this.seriesPoints[seriesIx];\n    let pointValue = value;\n\n    if (!(hasValue(x) && hasValue(y))) {\n      pointValue = this.createMissingValue(pointValue, missingValues);\n    }\n\n    let point;\n\n    if (pointValue) {\n      point = this.createPoint(pointValue, fields);\n\n      if (point) {\n        Object.assign(point, fields);\n        this.addErrorBar(point, X, fields);\n        this.addErrorBar(point, Y, fields);\n      }\n\n      this.updateRange(pointValue, fields.series);\n    }\n\n    this.points.push(point);\n    seriesPoints.push(point);\n  }\n\n  seriesMissingValues(series) {\n    return series.missingValues;\n  }\n\n  createMissingValue() {}\n\n  updateRange(value, series) {\n    const intlService = this.chartService.intl;\n    const {\n      xAxis: xAxisName,\n      yAxis: yAxisName\n    } = series;\n    let {\n      x,\n      y\n    } = value;\n    let xAxisRange = this.xAxisRanges[xAxisName];\n    let yAxisRange = this.yAxisRanges[yAxisName];\n\n    if (hasValue(x)) {\n      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n\n      if (isString(x)) {\n        x = parseDate(intlService, x);\n      }\n\n      xAxisRange.min = Math.min(xAxisRange.min, x);\n      xAxisRange.max = Math.max(xAxisRange.max, x);\n    }\n\n    if (hasValue(y)) {\n      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n\n      if (isString(y)) {\n        y = parseDate(intlService, y);\n      }\n\n      yAxisRange.min = Math.min(yAxisRange.min, y);\n      yAxisRange.max = Math.max(yAxisRange.max, y);\n    }\n  }\n\n  evalPointOptions(options, value, fields) {\n    const {\n      series,\n      seriesIx\n    } = fields;\n    const state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n    };\n    let doEval = this._evalSeries[seriesIx];\n\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n\n    let pointOptions = options;\n\n    if (doEval) {\n      pointOptions = deepExtend({}, options);\n      evalOptions(pointOptions, {\n        value: value,\n        series: series,\n        dataItem: fields.dataItem\n      }, state);\n    }\n\n    return pointOptions;\n  }\n\n  pointType() {\n    return LinePoint;\n  }\n\n  pointOptions(series, seriesIx) {\n    let options = this.seriesOptions[seriesIx];\n\n    if (!options) {\n      const defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        markers: {\n          opacity: series.opacity\n        },\n        tooltip: {\n          format: this.options.tooltip.format\n        },\n        labels: {\n          format: this.options.labels.format\n        }\n      }, series);\n    }\n\n    return options;\n  }\n\n  createPoint(value, fields) {\n    const series = fields.series;\n    let pointOptions = this.pointOptions(series, fields.seriesIx);\n    let color = fields.color || series.color;\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    const point = new LinePoint(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  }\n\n  seriesAxes(series) {\n    const {\n      xAxis: xAxisName,\n      yAxis: yAxisName\n    } = series;\n    const plotArea = this.plotArea;\n    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n    if (!xAxis) {\n      throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n    }\n\n    if (!yAxis) {\n      throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n    }\n\n    return {\n      x: xAxis,\n      y: yAxis\n    };\n  }\n\n  reflow(targetBox) {\n    const chartPoints = this.points;\n    const limit = !this.options.clip;\n    let pointIx = 0;\n    this.traverseDataPoints((value, fields) => {\n      const point = chartPoints[pointIx++];\n      const seriesAxes = this.seriesAxes(fields.series);\n      const slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n      const slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n      if (point) {\n        if (slotX && slotY) {\n          const pointSlot = this.pointSlot(slotX, slotY);\n          point.reflow(pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.box = targetBox;\n  }\n\n  pointSlot(slotX, slotY) {\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  }\n\n  traverseDataPoints(callback) {\n    const {\n      options: {\n        series\n      },\n      seriesPoints\n    } = this;\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const currentSeriesPoints = seriesPoints[seriesIx];\n\n      if (!currentSeriesPoints) {\n        seriesPoints[seriesIx] = [];\n      }\n\n      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n        const {\n          valueFields: value,\n          fields\n        } = this._bindPoint(currentSeries, seriesIx, pointIx);\n\n        callback(value, deepExtend({\n          pointIx: pointIx,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: currentSeries.data[pointIx],\n          owner: this\n        }, fields));\n      }\n    }\n  }\n\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.x, value.y);\n  }\n\n  animationPoints() {\n    const points = this.points;\n    const result = [];\n\n    for (let idx = 0; idx < points.length; idx++) {\n      result.push((points[idx] || {}).marker);\n    }\n\n    return result;\n  }\n\n}\n\nsetDefaultOptions(ScatterChart, {\n  series: [],\n  tooltip: {\n    format: \"{0}, {1}\"\n  },\n  labels: {\n    format: \"{0}, {1}\"\n  },\n  clip: true\n});\ndeepExtend(ScatterChart.prototype, ClipAnimationMixin, {\n  _bindPoint: CategoricalChart.prototype._bindPoint\n});\nexport default ScatterChart;","map":null,"metadata":{},"sourceType":"module"}