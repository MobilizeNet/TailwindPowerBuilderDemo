{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1710);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1697:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./calc\");\n    /***/\n  },\n\n  /***/\n  1710:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1697), __webpack_require__(1711), __webpack_require__(1712)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\"; // WARNING: removing the following jshint declaration and turning\n      // == into === to make JSHint happy will break functionality.\n\n      /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */\n\n      /* jshint latedef: nofunc */\n\n      var util = kendo.util;\n      var calc = kendo.spreadsheet.calc;\n      var dom = kendo.dom;\n      var RX_COLORS = /^\\[(black|green|white|blue|magenta|yellow|cyan|red)\\]/i;\n      var RX_CONDITION = /^\\[(<=|>=|<>|<|>|=)(-?[0-9.]+)\\]/;\n      /* The proper amount of suffering for whoever designed the Excel\n         Custom Number Format would be to have him implement the\n         formatter himself. */\n\n      function parse(input) {\n        input = calc.InputStream(input);\n        var sections = [],\n            haveConditional = false,\n            decimalPart;\n\n        while (!input.eof()) {\n          var sec = readSection();\n          sections.push(sec);\n\n          if (sec.cond) {\n            haveConditional = true;\n          }\n        } // From https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4:\n        //\n        //    A number format can have up to four sections of code, separated by semicolons. These\n        //    code sections define the format for positive numbers, negative numbers, zero values,\n        //    and text, in that order.\n        //\n        //    You do not have to include all code sections in your custom number format. If you\n        //    specify only two code sections for your custom number format, the first section is\n        //    used for positive numbers and zeros, and the second section is used for negative\n        //    numbers. If you specify only one code section, it is used for all numbers. If you want\n        //    to skip a code section and include a code section that follows it, you must include\n        //    the ending semicolon for the section that you skip.\n        //\n        // However, if sections have conditionals, it is not clear if:\n        //\n        //    - still at most four are allowed\n        //    - is the last section still for text\n        //\n        // We will assume that if no sections have conditionals, then there must be at most 4, and\n        // they will be interpreted in the order above.  If the first section contains a\n        // conditional, then there can be any number of them; if the last one is not conditional\n        // then it will be interpreted as text format.\n\n\n        if (!haveConditional) {\n          if (sections.length == 1) {\n            sections[0].cond = \"num\";\n          } else if (sections.length == 2) {\n            sections[0].cond = {\n              op: \">=\",\n              value: 0\n            };\n            sections[1].cond = {\n              op: \"<\",\n              value: 0\n            };\n          } else if (sections.length >= 3) {\n            sections[0].cond = {\n              op: \">\",\n              value: 0\n            };\n            sections[1].cond = {\n              op: \"<\",\n              value: 0\n            };\n            sections[2].cond = {\n              op: \"=\",\n              value: 0\n            };\n\n            if (sections.length > 3) {\n              sections[3].cond = \"text\";\n              sections = sections.slice(0, 4);\n            }\n          }\n        }\n\n        return sections;\n\n        function maybeColor() {\n          var m = input.skip(RX_COLORS);\n\n          if (m) {\n            return m[1].toLowerCase();\n          }\n        }\n\n        function maybeCondition() {\n          var m = input.skip(RX_CONDITION);\n\n          if (m) {\n            var val = parseFloat(m[2]);\n\n            if (!isNaN(val)) {\n              return {\n                op: m[1],\n                value: val,\n                custom: true\n              };\n            }\n          }\n        }\n\n        function readFormat() {\n          var format = [],\n              tok,\n              prev = null;\n\n          while (!input.eof() && (tok = readNext())) {\n            // disambiguate: m/mm might mean month or minutes depending on surrounding context.\n            if (tok.type == \"date\") {\n              if (prev && /^(el)?time$/.test(prev.type) && prev.part == \"h\" && tok.part == \"m\" && tok.format < 3) {\n                // m or mm that follows hours should display minutes\n                tok.type = \"time\";\n              }\n            } else if (/^(el)?time$/.test(tok.type) && tok.part == \"s\") {\n              if (prev && prev.type == \"date\" && prev.part == \"m\" && prev.format < 3) {\n                // m or mm followed by seconds should display minutes\n                prev.type = \"time\";\n              }\n            }\n\n            if (!/^(?:str|space|fill)$/.test(tok.type)) {\n              prev = tok;\n            }\n\n            format.push(tok);\n          }\n\n          return format;\n        }\n\n        function maybeFraction(tok) {\n          if (tok.type != \"date\" || tok.part == \"m\" && tok.format < 3) {\n            var m = input.skip(/^\\.(0+)/);\n\n            if (m) {\n              tok.fraction = m[1].length;\n\n              if (tok.type == \"date\") {\n                tok.type = \"time\";\n              }\n            }\n          }\n\n          return tok;\n        }\n\n        function readNext() {\n          var ch, m; // numbers\n\n          if (m = input.skip(/^([#0?]+)(?:,([#0?]+))+/)) {\n            // thousands separator.  seems convenient to treat\n            // this as a single token.\n            return {\n              type: \"digit\",\n              sep: true,\n              format: m[1] + m[2],\n              decimal: decimalPart\n            };\n          }\n\n          if (m = input.skip(/^[#0?]+/)) {\n            return {\n              type: \"digit\",\n              sep: false,\n              format: m[0],\n              decimal: decimalPart\n            };\n          } // XXX: handle this one!\n\n\n          if (m = input.skip(/^(e)([+-])/i)) {\n            return {\n              type: \"exp\",\n              ch: m[1],\n              sign: m[2]\n            };\n          } // dates\n\n\n          if (m = input.skip(/^(d{1,4}|m{1,5}|yyyy|yy)/i)) {\n            m = m[1].toLowerCase();\n            return maybeFraction({\n              type: \"date\",\n              part: m.charAt(0),\n              format: m.length\n            });\n          } // time (interpret as a date)\n\n\n          if (m = input.skip(/^(hh?|ss?)/i)) {\n            // m and mm are handled above\n            m = m[1].toLowerCase();\n            return maybeFraction({\n              type: \"time\",\n              part: m.charAt(0),\n              format: m.length\n            });\n          } // elapsed time (interpret as interval of days)\n\n\n          if (m = input.skip(/^\\[(hh?|mm?|ss?)\\]/i)) {\n            m = m[1].toLowerCase();\n            return maybeFraction({\n              type: \"eltime\",\n              part: m.charAt(0),\n              format: m.length\n            });\n          }\n\n          if (m = input.skip(/^(a[.]?m[.]?\\/p[.]?m[.]?|a\\/p)/i)) {\n            m = m[1].split(\"/\");\n            return {\n              type: \"ampm\",\n              am: m[0],\n              pm: m[1]\n            };\n          }\n\n          switch (ch = input.next()) {\n            // JSHint sadness\n            case \";\":\n              return null;\n\n            case \"\\\\\":\n              // quotes next character\n              return {\n                type: \"str\",\n                value: input.next()\n              };\n\n            case '\"':\n              return {\n                type: \"str\",\n                value: input.readEscaped(ch)\n              };\n\n            case \"@\":\n              return {\n                type: \"text\"\n              };\n\n            case \"_\":\n              // whitespace of the width of following character\n              return {\n                type: \"space\",\n                value: input.next()\n              };\n\n            case \"*\":\n              // fills cell width with the following character\n              return {\n                type: \"fill\",\n                value: input.next()\n              };\n\n            case \".\":\n              if (input.lookingAt(/^\\s*[#0?]/)) {\n                decimalPart = true;\n                return {\n                  type: \"dec\"\n                };\n              }\n\n              return {\n                type: \"str\",\n                value: \".\"\n              };\n\n            case \"%\":\n              return {\n                type: \"percent\"\n              };\n\n            case \",\":\n              return {\n                type: \"comma\"\n              };\n          } // whatever we can't make sense of, output literally.\n\n\n          return {\n            type: \"str\",\n            value: ch\n          };\n        }\n\n        function readSection() {\n          decimalPart = false;\n          var color = maybeColor(),\n              cond = maybeCondition();\n\n          if (!color && cond) {\n            color = maybeColor();\n          }\n\n          return {\n            color: color,\n            cond: cond,\n            body: readFormat()\n          };\n        }\n      }\n\n      function print(sections) {\n        return sections.map(printSection).join(\";\");\n\n        function printSection(sec) {\n          var out = \"\";\n\n          if (sec.color) {\n            out += \"[\" + sec.color + \"]\";\n          }\n\n          if (sec.cond) {\n            if (!(sec.cond == \"text\" || sec.cond == \"num\")) {\n              out += \"[\" + sec.cond.op + sec.cond.value + \"]\";\n            }\n          }\n\n          out += sec.body.map(printToken).join(\"\");\n          return out;\n        }\n\n        function maybeFraction(fmt, tok) {\n          if (tok.fraction) {\n            fmt += \".\" + padLeft(\"\", tok.fraction, \"0\");\n          }\n\n          return fmt;\n        }\n\n        function printToken(tok) {\n          if (tok.type == \"digit\") {\n            if (tok.sep) {\n              return tok.format.charAt(0) + \",\" + tok.format.substr(1);\n            } else {\n              return tok.format;\n            }\n          } else if (tok.type == \"exp\") {\n            return tok.ch + tok.sign;\n          } else if (tok.type == \"date\" || tok.type == \"time\") {\n            return maybeFraction(padLeft(\"\", tok.format, tok.part), tok);\n          } else if (tok.type == \"eltime\") {\n            return maybeFraction(\"[\" + padLeft(\"\", tok.format, tok.part) + \"]\", tok);\n          } else if (tok.type == \"ampm\") {\n            return tok.am + \"/\" + tok.pm;\n          } else if (tok.type == \"str\") {\n            return JSON.stringify(tok.value);\n          } else if (tok.type == \"text\") {\n            return \"@\";\n          } else if (tok.type == \"space\") {\n            return \"_\" + tok.value;\n          } else if (tok.type == \"fill\") {\n            return \"*\" + tok.value;\n          } else if (tok.type == \"dec\") {\n            return \".\";\n          } else if (tok.type == \"percent\") {\n            return \"%\";\n          } else if (tok.type == \"comma\") {\n            return \",\";\n          }\n        }\n      }\n\n      function adjustDecimals(sections, x) {\n        sections.forEach(function (sec) {\n          var diff = x;\n\n          if (sec.cond == \"text\") {\n            return;\n          }\n\n          var body = sec.body,\n              adjusted = false,\n              i = body.length;\n\n          while (diff !== 0 && --i >= 0) {\n            var tok = body[i];\n\n            if (tok.type == \"digit\") {\n              if (tok.decimal) {\n                adjusted = true;\n\n                if (diff > 0) {\n                  tok.format += padLeft(\"\", diff, \"0\");\n                } else if (diff < 0) {\n                  var tmp = tok.format.length;\n                  tok.format = tok.format.substr(0, tmp + diff);\n                  diff += tmp - tok.format.length;\n                }\n\n                if (tok.format.length === 0) {\n                  body.splice(i, 1);\n\n                  while (--i >= 0) {\n                    tok = body[i];\n\n                    if (tok.type == \"digit\" && tok.decimal) {\n                      ++i;\n                      break;\n                    }\n\n                    if (tok.type == \"dec\") {\n                      body.splice(i, 1);\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (diff > 0) {\n                break;\n              }\n            }\n          }\n\n          if (!adjusted && diff > 0) {\n            // no decimal part was found, insert one after the last digit token.\n            body.splice(i + 1, 0, {\n              type: \"dec\"\n            }, {\n              type: \"digit\",\n              sep: false,\n              decimal: true,\n              format: padLeft(\"\", diff, \"0\")\n            });\n          }\n        });\n      }\n\n      function TokenStream(parts) {\n        var index = 0;\n        return {\n          next: function () {\n            return parts[index++];\n          },\n          eof: function () {\n            return index >= parts.length;\n          },\n          ahead: function (n, f) {\n            if (index + n <= parts.length) {\n              var val = f.apply(null, parts.slice(index, index + n));\n\n              if (val) {\n                index += n;\n              }\n\n              return val;\n            }\n          },\n          restart: function () {\n            index = 0;\n          }\n        };\n      }\n\n      function compileFormatPart(format) {\n        var input = TokenStream(format.body);\n        var hasDate = false;\n        var hasTime = false;\n        var hasAmpm = false;\n        var percentCount = 0;\n        var currency = /[\\$\\xA2-\\xA5\\u058F\\u060B\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BD\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6]/;\n        var scaleCount = 0;\n        var code = \"var intPart, decPart, isNegative, date, time; \";\n        var separeThousands = false;\n        var declen = 0;\n        var intFormat = [],\n            decFormat = [];\n        var condition = format.cond;\n        var preamble = \"\";\n\n        if (condition == \"text\") {\n          preamble = \"if (typeof value == 'string' || value instanceof kendo.spreadsheet.CalcError) { \";\n        } else if (condition == \"num\") {\n          preamble = \"if (typeof value == 'number') { \";\n        } else if (condition) {\n          var op = condition.op == \"=\" ? \"==\" : condition.op;\n          preamble = \"if (typeof value == 'number' && value \" + op + \" \" + condition.value + \") { \";\n\n          if (!condition.custom) {\n            code += \"value = Math.abs(value); \";\n          }\n        }\n\n        if (format.color) {\n          code += \"result.color = \" + JSON.stringify(format.color) + \"; \";\n        }\n\n        function checkComma(a, b) {\n          if (a.type == \"digit\" && b.type == \"comma\" || a.type == \"comma\" && a.hidden && b.type == \"comma\") {\n            b.hidden = true;\n            scaleCount++;\n          }\n        }\n\n        while (!input.eof()) {\n          input.ahead(2, checkComma);\n          var tok = input.next();\n\n          if (tok.type == \"percent\") {\n            percentCount++;\n          } else if (tok.type == \"digit\") {\n            if (tok.decimal) {\n              declen += tok.format.length;\n              decFormat.push(tok.format);\n            } else {\n              intFormat.push(tok.format);\n\n              if (tok.sep) {\n                separeThousands = true;\n              }\n            }\n          } else if (tok.type == \"time\") {\n            hasTime = true;\n          } else if (tok.type == \"date\") {\n            hasDate = true;\n          } else if (tok.type == \"ampm\") {\n            hasAmpm = hasTime = true;\n          }\n        }\n\n        if (percentCount > 0) {\n          code += \"value *= \" + Math.pow(100, percentCount) + \"; \";\n        }\n\n        if (scaleCount > 0) {\n          code += \"value /= \" + Math.pow(1000, scaleCount) + \"; \";\n        }\n\n        if (intFormat.length) {\n          code += \"intPart = runtime.formatInt(culture, value, \" + JSON.stringify(intFormat) + \", \" + declen + \", \" + separeThousands + \"); \";\n          code += \"isNegative = parseInt(intPart[0]) < 0;\";\n        }\n\n        if (decFormat.length) {\n          code += \"decPart = runtime.formatDec(value, \" + JSON.stringify(decFormat) + \", \" + declen + \"); \";\n        }\n\n        if (intFormat.length || decFormat.length) {\n          code += \"type = 'number'; \";\n        }\n\n        if (hasDate) {\n          code += \"date = runtime.unpackDate(value); \";\n        }\n\n        if (hasTime) {\n          code += \"time = runtime.unpackTime(value); \";\n        }\n\n        if (hasDate || hasTime) {\n          code += \"type = 'date'; \";\n        }\n\n        if (percentCount > 0 || scaleCount > 0 || intFormat.length || decFormat.length || hasDate || hasTime) {\n          if (!preamble) {\n            preamble = \"if (typeof value == 'number') { \";\n          }\n        }\n\n        input.restart();\n        code += \"var matchedCurrency = false;\";\n\n        while (!input.eof()) {\n          var tok = input.next();\n\n          if (tok.type == \"dec\") {\n            code += \"output += culture.numberFormat['.']; \";\n          } else if (tok.type == \"comma\" && !tok.hidden) {\n            code += \"output += ','; \";\n          } else if (tok.type == \"percent\") {\n            code += \"type = 'percent'; \";\n            code += \"output += culture.numberFormat.percent.symbol; \";\n          } else if (tok.type == \"str\") {\n            if (currency.test(tok.value)) {\n              code += \"type = 'currency'; \";\n              code += \"if (isNegative) { output += '-'; matchedCurrency = true; }\";\n            }\n\n            code += \"output += \" + JSON.stringify(tok.value) + \"; \";\n          } else if (tok.type == \"text\") {\n            code += \"type = 'text'; \";\n            code += \"output += value; \";\n          } else if (tok.type == \"space\") {\n            code += \"if (output) result.body.push(output); \";\n            code += \"output = ''; \";\n            code += \"result.body.push({ type: 'space', value: \" + JSON.stringify(tok.value) + \" }); \";\n          } else if (tok.type == \"fill\") {\n            code += \"output += runtime.fill(\" + JSON.stringify(tok.value) + \"); \";\n          } else if (tok.type == \"digit\") {\n            code += \"if (isNegative && intPart[0] && matchedCurrency) {intPart[0] = intPart[0].replace('-', '');}\";\n            code += \"output += \" + (tok.decimal ? \"decPart\" : \"intPart\") + \".shift(); \";\n          } else if (tok.type == \"date\") {\n            code += \"output += runtime.date(culture, date, \" + JSON.stringify(tok.part) + \", \" + tok.format + \"); \";\n          } else if (tok.type == \"time\") {\n            code += \"output += runtime.time(time, \" + JSON.stringify(tok.part) + \", \" + tok.format + \", \" + hasAmpm + \", \" + tok.fraction + \"); \";\n          } else if (tok.type == \"eltime\") {\n            code += \"output += runtime.eltime(value, \" + JSON.stringify(tok.part) + \", \" + tok.format + \", \" + tok.fraction + \"); \";\n          } else if (tok.type == \"ampm\") {\n            // XXX: should use culture?  As per the \"spec\", Excel\n            // displays whatever the token was (AM/PM, a/p etc.)\n            code += \"output += time.hours < 12 ? \" + JSON.stringify(tok.am) + \" : \" + JSON.stringify(tok.pm) + \"; \";\n          }\n        }\n\n        code += \"if (output) result.body.push(output); \";\n        code += \"result.type = type; \";\n        code += \"return result; \";\n\n        if (preamble) {\n          code = preamble + code + \"}\";\n        }\n\n        return code;\n      }\n\n      var TEXT = compileFormatPart({\n        cond: \"text\",\n        body: [{\n          type: \"text\"\n        }]\n      });\n      var compile = util.memoize(function (format) {\n        var tree = parse(format);\n        var code = tree.map(compileFormatPart);\n        code.push(TEXT);\n        code = code.join(\"\\n\");\n        code = \"'use strict'; return function(value, culture){ \" + \"if (!culture) culture = kendo.culture(); \" + \"var output = '', type = null, result = { body: [] }; \" + code + \"; return result; };\";\n        return new Function(\"runtime\", code)(runtime);\n      }); // Attempts to produce a format compatible with kendo.parseDate from our Excel format.  Needed\n      // in runtime.parseDate (passing Excel format to kendo.parseDate will mess up the month or\n      // minutes).  https://github.com/telerik/kendo-ui-core/issues/3797\n\n      var makeDateFormat = util.memoize(function (format) {\n        var tree = parse(format);\n        var section,\n            found = false,\n            hasAmpm = false; // locate a section that contains date/time formatting.  only the first will be converted.\n\n        for (var i = 0; i < tree.length; ++i) {\n          section = tree[i];\n\n          for (var j = 0; j < section.body.length; ++j) {\n            if (/^(?:date|time|ampm)$/.test(section.body[j].type)) {\n              found = true;\n\n              if (section.body[j].type == \"ampm\") {\n                hasAmpm = true;\n              }\n            }\n          }\n\n          if (found) {\n            break;\n          }\n        }\n\n        if (!found) {\n          return null;\n        }\n\n        return section.body.map(printToken).join(\"\"); // a little copy/paste goes a long way\n\n        function maybeFraction(fmt, tok) {\n          if (tok.fraction) {\n            fmt += padLeft(\"\", Math.max(tok.fraction, 3), \"f\");\n          }\n\n          return fmt;\n        }\n\n        function printToken(tok) {\n          if (tok.type == \"digit\") {\n            if (tok.sep) {\n              return tok.format.charAt(0) + \",\" + tok.format.substr(1);\n            } else {\n              return tok.format;\n            }\n          } else if (tok.type == \"exp\") {\n            return tok.ch + tok.sign;\n          } else if (tok.type == \"date\" || tok.type == \"time\") {\n            var part = tok.part;\n\n            if (tok.type == \"date\" && /^m/.test(part)) {\n              part = \"M\"; // month, not minutes\n            } else if (tok.type == \"time\" && /^h/.test(part)) {\n              if (!hasAmpm) {\n                // 24-hours clock is H or HH\n                part = part.toUpperCase();\n              }\n            }\n\n            return maybeFraction(padLeft(\"\", tok.format, part), tok);\n          } else if (tok.type == \"ampm\") {\n            return \"tt\";\n          } else if (tok.type == \"str\") {\n            // XXX: this is a bit wrong.  it doesn't look like kendo.toString / kendo.parseDate\n            // support arbitrary text (in Excel formats that's quoted), for example:\n            //    kendo.toString(new Date(), \"here's the day dude: dd\")\n            //  â†’ \"3ere'8 t3e 19ay 19u19e: 19\"   (it's 19th June, 3 o'clock, probably 8 seconds)\n            return tok.value;\n          } else if (tok.type == \"space\") {\n            return \" \";\n          } else if (tok.type == \"dec\") {\n            return \".\";\n          } else if (tok.type == \"percent\") {\n            return \"%\";\n          } else if (tok.type == \"comma\") {\n            return \",\";\n          } else {\n            return \"\";\n          }\n        }\n      });\n      var runtime = {\n        unpackDate: calc.runtime.unpackDate,\n        unpackTime: calc.runtime.unpackTime,\n        date: function (culture, d, part, length) {\n          switch (part) {\n            case \"d\":\n              switch (length) {\n                case 1:\n                  return d.date;\n\n                case 2:\n                  return padLeft(d.date, 2, \"0\");\n\n                case 3:\n                  return culture.calendars.standard.days.namesAbbr[d.day];\n\n                case 4:\n                  return culture.calendars.standard.days.names[d.day];\n              }\n\n              break;\n\n            case \"m\":\n              switch (length) {\n                case 1:\n                  return d.month + 1;\n\n                case 2:\n                  return padLeft(d.month + 1, 2, \"0\");\n\n                case 3:\n                  return culture.calendars.standard.months.namesAbbr[d.month];\n\n                case 4:\n                  return culture.calendars.standard.months.names[d.month];\n\n                case 5:\n                  return culture.calendars.standard.months.names[d.month].charAt(0);\n              }\n\n              break;\n\n            case \"y\":\n              switch (length) {\n                case 2:\n                  return d.year % 100;\n\n                case 4:\n                  return d.year;\n              }\n\n              break;\n          }\n\n          return \"##\";\n        },\n        time: function (t, part, length, ampm, fraclen) {\n          var ret, fraction;\n\n          switch (part) {\n            case \"h\":\n              ret = padLeft(ampm ? t.hours % 12 || 12 : t.hours, length, \"0\");\n\n              if (fraclen) {\n                fraction = (t.minutes + (t.seconds + t.milliseconds / 1000) / 60) / 60;\n              }\n\n              break;\n\n            case \"m\":\n              ret = padLeft(t.minutes, length, \"0\");\n\n              if (fraclen) {\n                fraction = (t.seconds + t.milliseconds / 1000) / 60;\n              }\n\n              break;\n\n            case \"s\":\n              ret = padLeft(t.seconds, length, \"0\");\n\n              if (fraclen) {\n                fraction = t.milliseconds / 1000;\n              }\n\n              break;\n          }\n\n          if (fraction) {\n            ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, \"\");\n          }\n\n          return ret;\n        },\n        eltime: function (value, part, length, fraclen) {\n          var ret, fraction;\n\n          switch (part) {\n            case \"h\":\n              ret = value * 24;\n              break;\n\n            case \"m\":\n              ret = value * 24 * 60;\n              break;\n\n            case \"s\":\n              ret = value * 24 * 60 * 60;\n              break;\n          }\n\n          if (fraclen) {\n            fraction = ret - (ret | 0);\n          }\n\n          ret = padLeft(ret | 0, length, \"0\");\n\n          if (fraction) {\n            ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, \"\");\n          }\n\n          return ret;\n        },\n        fill: function (ch) {\n          // XXX: how to implement this?\n          return ch;\n        },\n        // formatting integer part is slightly different than decimal\n        // part, so they're implemented in two functions.  For the\n        // integer part we need to walk the value and the format\n        // backwards (right-to-left).\n        formatInt: function (culture, value, parts, declen, sep) {\n          // toFixed is perfect for rounding our value; if there is\n          // no format for decimals, for example, we want the number\n          // rounded up.\n          value = runtime.toFixed(value, declen).replace(/\\..*$/, \"\");\n          var lastPart = parts[parts.length - 1];\n\n          if (declen > 0 && lastPart[parts.length - 1] != \"0\") {\n            // if the rounded number is zero and we have decimal\n            // format, consider it a non-significant digit (Excel\n            // won't display the leading zero for 0.2 in format #.#).\n            // the zero won't e omitted if using 0.0 format\n            if (value === \"0\") {\n              value = \"\";\n            } else if (value === \"-0\") {\n              value = \"-\";\n            }\n          }\n\n          var shouldInsertMinus = false;\n          var iv = value.length - 1;\n          var result = [];\n          var len = 0,\n              str;\n\n          function add(ch, skipMinus) {\n            if (sep && len && len % 3 === 0 && /^[0-9]$/.test(ch)) {\n              str = culture.numberFormat[\",\"] + str;\n            }\n\n            if (skipMinus && ch === \"-\") {\n              shouldInsertMinus = true;\n              ch = \"0\";\n            }\n\n            str = ch + str;\n            len++;\n          }\n\n          for (var j = parts.length; --j >= 0;) {\n            var format = parts[j];\n            str = \"\";\n\n            for (var k = format.length; --k >= 0;) {\n              var chf = format.charAt(k);\n\n              if (iv < 0) {\n                if (chf == \"0\") {\n                  add(\"0\");\n                } else if (chf == \"?\") {\n                  add(\" \");\n                }\n              } else {\n                if (value == \"0\" && chf == \"?\") {\n                  add(\" \");\n                } else if (chf == \"0\") {\n                  add(value.charAt(iv), true);\n                } else {\n                  add(value.charAt(iv));\n                }\n\n                iv--;\n              }\n            }\n\n            if (j === 0) {\n              while (iv >= 0) {\n                add(value.charAt(iv--));\n              }\n            }\n\n            result.unshift(str);\n          }\n\n          if (shouldInsertMinus) {\n            result[0] = \"-\" + result[0];\n          }\n\n          return result;\n        },\n        // for decimal part we walk in normal direction and pad on the\n        // right if required (for '0' or '?' chars).\n        formatDec: function (value, parts, declen) {\n          value = runtime.toFixed(value, declen);\n          var pos = value.indexOf(\".\");\n\n          if (pos >= 0) {\n            value = value.substr(pos + 1).replace(/0+$/, \"\");\n          } else {\n            value = \"\";\n          }\n\n          var iv = 0;\n          var result = [];\n\n          for (var j = 0; j < parts.length; ++j) {\n            var format = parts[j];\n            var str = \"\";\n\n            for (var k = 0; k < format.length; ++k) {\n              var chf = format.charAt(k);\n\n              if (iv < value.length) {\n                str += value.charAt(iv++);\n              } else if (chf == \"0\") {\n                str += \"0\";\n              } else if (chf == \"?\") {\n                str += \" \";\n              }\n            }\n\n            result.push(str);\n          }\n\n          return result;\n        },\n        // JS's toFixed is broken, it's only OK to use it on integers.\n        toFixed: function (value, decimals) {\n          return function toFixed(value, last) {\n            if (!isFinite(value)) {\n              return \"#NUM!\";\n            } // deal early with the trivial cases\n\n\n            if (value < 0) {\n              // JS's Math.round is broken with negative numbers\n              return \"-\" + toFixed(-value);\n            }\n\n            if (decimals === 0) {\n              // no decimals\n              return String(Math.round(value));\n            }\n\n            if (value === Math.round(value) && !/e/i.test(String(value))) {\n              // value is integer and not too big\n              return value.toFixed(decimals);\n            } // this handles cases like 0.3.toFixed(20) == \"0.29999999999999998890\", or\n            // 2.1825.toFixed(20) = \"2.18250000000000010658\".\n            // https://github.com/telerik/kendo-ui-core/issues/3520#issuecomment-333768221\n            // https://twitter.com/mcbazon/status/1035828655652593665\n\n\n            var num = digNumber(value);\n            var intpart = num.intpart;\n            var decpart = num.decpart;\n\n            if (decpart.length <= decimals) {\n              while (decpart.length < decimals) {\n                decpart += \"0\";\n              }\n\n              return intpart + \".\" + decpart;\n            }\n\n            if (last) {\n              // \"we should definitely not get here\" (famous last words).  Let's MAKE SURE\n              // there's no more recursion.\n              return intpart + \".\" + decpart.substr(0, decimals);\n            } // if there are more decimals than wanted, round and try again.\n            // it should not recurse more than once.\n\n\n            var f = Math.pow(10, decimals);\n            return toFixed(Math.round(value * f) / f, true);\n          }(Number(value.toFixed(14)));\n          /* restrict to 14 decimals, because 0.1 + 0.2 ===\n                * 0.30000000000000004 */\n        }\n      };\n\n      function padLeft(val, width, ch) {\n        val += \"\";\n\n        while (val.length < width) {\n          val = ch + val;\n        }\n\n        return val;\n      }\n\n      function padRight(val, width, ch) {\n        val += \"\";\n\n        while (val.length < width) {\n          val += ch;\n        }\n\n        return val;\n      } // given a number, return { intpart, decpart } as strings.  the main difficulty here is that JS\n      // will stringify really large values in scientific notation (e.g. 1.23e+30, which is actually\n      // the integer 1230000000000000000000000000000).\n\n\n      function digNumber(num) {\n        var str = String(num).toLowerCase();\n        var intpart, decpart, m;\n        var pos = str.indexOf(\".\");\n\n        if (pos < 0) {\n          pos = str.indexOf(\"e\");\n\n          if (pos < 0) {\n            intpart = str;\n            decpart = \"\";\n          } else {\n            intpart = str.substr(0, pos);\n            decpart = str.substr(pos);\n          }\n        } else {\n          intpart = str.substr(0, pos);\n          decpart = str.substr(pos + 1);\n        }\n\n        if (m = /(\\d*)e([-+]?\\d+)/.exec(decpart)) {\n          var exp = parseInt(m[2], 10);\n\n          if (exp >= 0) {\n            decpart = padRight(m[1], exp, \"0\");\n            intpart += decpart.substr(0, exp);\n            decpart = decpart.substr(exp);\n          } else {\n            intpart = padLeft(intpart, -exp, \"0\");\n            decpart = intpart.substr(exp) + m[1];\n            intpart = intpart.substr(0, intpart.length + exp);\n          }\n        }\n\n        return {\n          intpart: intpart || \"0\",\n          decpart: decpart\n        };\n      }\n      /* -----[ exports ]----- */\n\n\n      function text(f) {\n        var a = f.body;\n        var text = \"\";\n\n        for (var i = 0; i < a.length; ++i) {\n          var el = a[i];\n\n          if (typeof el == \"string\") {\n            text += el;\n          } else if (el.type == \"space\") {\n            text += \" \";\n          }\n        }\n\n        return text;\n      }\n\n      kendo.spreadsheet.formatting = {\n        compile: compile,\n        parse: parse,\n        format: function (value, format, culture) {\n          var f = compile(format)(value, culture);\n          var span = dom.element(\"span\");\n          span.__dataType = f.type;\n          var a = f.body;\n\n          if (f.color) {\n            span.attr.style = {\n              color: f.color\n            };\n          }\n\n          for (var i = 0; i < a.length; ++i) {\n            var el = a[i];\n\n            if (typeof el == \"string\") {\n              span.children.push(dom.text(el));\n            } else if (el.type == \"space\") {\n              span.children.push(dom.element(\"span\", {\n                style: {\n                  visibility: \"hidden\"\n                }\n              }, [dom.text(el.value)]));\n            }\n          }\n\n          return span;\n        },\n        text: function (value, format, culture) {\n          var f = compile(format)(value, culture);\n          return text(f);\n        },\n        textAndColor: function (value, format, culture) {\n          var f = compile(format)(value, culture);\n          return {\n            text: text(f),\n            color: f.color,\n            type: f.type\n          };\n        },\n        type: function (value, format) {\n          return compile(format)(value).type;\n        },\n        adjustDecimals: function (format, diff) {\n          var ast = parse(format);\n          adjustDecimals(ast, diff);\n          return print(ast);\n        },\n        makeDateFormat: makeDateFormat\n      };\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1711:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.dom\");\n    /***/\n  },\n\n  /***/\n  1712:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../util/main\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}