{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(934);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  925:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../location\");\n    /***/\n  },\n\n  /***/\n  931:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./base\");\n    /***/\n  },\n\n  /***/\n  934:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(931), __webpack_require__(925)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            DataSource = kendo.data.DataSource,\n            dataviz = kendo.dataviz,\n            deepExtend = kendo.deepExtend,\n            g = kendo.geometry,\n            d = kendo.drawing,\n            Group = d.Group,\n            last = d.util.last,\n            defined = d.util.defined,\n            map = dataviz.map,\n            Location = map.Location,\n            Layer = map.layers.Layer; // Implementation =========================================================\n\n        var ShapeLayer = Layer.extend({\n          init: function (map, options) {\n            this._pan = this._pan.bind(this);\n            Layer.fn.init.call(this, map, options);\n            this.surface = d.Surface.create(this.element, {\n              width: map.scrollElement.width(),\n              height: map.scrollElement.height()\n            });\n\n            this._initRoot();\n\n            this.movable = new kendo.ui.Movable(this.surface.element);\n            this._markers = [];\n            this._click = this._handler(\"shapeClick\");\n            this.surface.bind(\"click\", this._click);\n            this._mouseenter = this._handler(\"shapeMouseEnter\");\n            this.surface.bind(\"mouseenter\", this._mouseenter);\n            this._mouseleave = this._handler(\"shapeMouseLeave\");\n            this.surface.bind(\"mouseleave\", this._mouseleave);\n\n            this._initDataSource();\n          },\n          options: {\n            autoBind: true\n          },\n          destroy: function () {\n            Layer.fn.destroy.call(this);\n            this.surface.destroy();\n            this.dataSource.unbind(\"change\", this._dataChange);\n          },\n          setDataSource: function (dataSource) {\n            if (this.dataSource) {\n              this.dataSource.unbind(\"change\", this._dataChange);\n            }\n\n            this.dataSource = kendo.data.DataSource.create(dataSource);\n            this.dataSource.bind(\"change\", this._dataChange);\n\n            if (this.options.autoBind) {\n              this.dataSource.fetch();\n            }\n          },\n          _reset: function () {\n            Layer.fn._reset.call(this);\n\n            this._translateSurface();\n\n            if (this._data) {\n              this._load(this._data);\n            }\n          },\n          _initRoot: function () {\n            this._root = new Group();\n            this.surface.draw(this._root);\n          },\n          _beforeReset: function () {\n            this.surface.clear();\n\n            this._initRoot();\n          },\n          _resize: function () {\n            this.surface.size(this.map.size());\n          },\n          _initDataSource: function () {\n            var dsOptions = this.options.dataSource;\n            this._dataChange = this._dataChange.bind(this);\n            this.dataSource = DataSource.create(dsOptions).bind(\"change\", this._dataChange);\n\n            if (dsOptions && this.options.autoBind) {\n              this.dataSource.fetch();\n            }\n          },\n          _dataChange: function (e) {\n            this._data = e.sender.view();\n\n            this._load(this._data);\n          },\n          _load: function (data) {\n            this._clearMarkers();\n\n            if (!this._loader) {\n              this._loader = new GeoJSONLoader(this.map, this.options.style, this);\n            }\n\n            var container = new Group();\n\n            for (var i = 0; i < data.length; i++) {\n              var shape = this._loader.parse(data[i]);\n\n              if (shape) {\n                container.append(shape);\n              }\n            }\n\n            this._root.clear();\n\n            this._root.append(container);\n          },\n          shapeCreated: function (shape) {\n            var cancelled = false;\n\n            if (shape instanceof d.Circle) {\n              cancelled = defined(this._createMarker(shape));\n            }\n\n            if (!cancelled) {\n              var args = {\n                layer: this,\n                shape: shape\n              };\n              cancelled = this.map.trigger(\"shapeCreated\", args);\n            }\n\n            return cancelled;\n          },\n          featureCreated: function (e) {\n            e.layer = this;\n            this.map.trigger(\"shapeFeatureCreated\", e);\n          },\n          _createMarker: function (shape) {\n            var marker = this.map.markers.bind({\n              location: shape.location\n            }, shape.dataItem);\n\n            if (marker) {\n              this._markers.push(marker);\n            }\n\n            return marker;\n          },\n          _clearMarkers: function () {\n            for (var i = 0; i < this._markers.length; i++) {\n              this.map.markers.remove(this._markers[i]);\n            }\n\n            this._markers = [];\n          },\n          _pan: function () {\n            if (!this._panning) {\n              this._panning = true;\n              this.surface.suspendTracking();\n            }\n          },\n          _panEnd: function (e) {\n            Layer.fn._panEnd.call(this, e);\n\n            this._translateSurface();\n\n            this.surface.resumeTracking();\n            this._panning = false;\n          },\n          _translateSurface: function () {\n            var map = this.map;\n            var nw = map.locationToView(map.extent().nw);\n\n            if (this.surface.translate) {\n              this.surface.translate(nw);\n              this.movable.moveTo({\n                x: nw.x,\n                y: nw.y\n              });\n            }\n          },\n          _handler: function (event) {\n            var layer = this;\n            return function (e) {\n              if (e.element) {\n                var args = {\n                  layer: layer,\n                  shape: e.element,\n                  originalEvent: e.originalEvent\n                };\n                layer.map.trigger(event, args);\n              }\n            };\n          },\n          _activate: function () {\n            Layer.fn._activate.call(this);\n\n            this.map.bind(\"pan\", this._pan);\n          },\n          _deactivate: function () {\n            Layer.fn._deactivate.call(this);\n\n            this.map.unbind(\"pan\", this._pan);\n          }\n        });\n        var GeoJSONLoader = Class.extend({\n          init: function (locator, defaultStyle, observer) {\n            this.observer = observer;\n            this.locator = locator;\n            this.style = defaultStyle;\n          },\n          parse: function (item) {\n            var root = new Group();\n            var unwrap = true;\n\n            if (item.type === \"Feature\") {\n              unwrap = false;\n\n              this._loadGeometryTo(root, item.geometry, item);\n\n              this._featureCreated(root, item);\n            } else {\n              this._loadGeometryTo(root, item, item);\n            }\n\n            if (unwrap && root.children.length < 2) {\n              root = root.children[0];\n            }\n\n            return root;\n          },\n          _shapeCreated: function (shape) {\n            var cancelled = false;\n\n            if (this.observer && this.observer.shapeCreated) {\n              cancelled = this.observer.shapeCreated(shape);\n            }\n\n            return cancelled;\n          },\n          _featureCreated: function (group, dataItem) {\n            if (this.observer && this.observer.featureCreated) {\n              this.observer.featureCreated({\n                group: group,\n                dataItem: dataItem,\n                properties: dataItem.properties\n              });\n            }\n          },\n          _loadGeometryTo: function (container, geometry, dataItem) {\n            var coords = geometry.coordinates;\n            var i;\n            var path;\n\n            switch (geometry.type) {\n              case \"LineString\":\n                path = this._loadPolygon(container, [coords], dataItem);\n\n                this._setLineFill(path);\n\n                break;\n\n              case \"MultiLineString\":\n                for (i = 0; i < coords.length; i++) {\n                  path = this._loadPolygon(container, [coords[i]], dataItem);\n\n                  this._setLineFill(path);\n                }\n\n                break;\n\n              case \"Polygon\":\n                this._loadPolygon(container, coords, dataItem);\n\n                break;\n\n              case \"MultiPolygon\":\n                for (i = 0; i < coords.length; i++) {\n                  this._loadPolygon(container, coords[i], dataItem);\n                }\n\n                break;\n\n              case \"Point\":\n                this._loadPoint(container, coords, dataItem);\n\n                break;\n\n              case \"MultiPoint\":\n                for (i = 0; i < coords.length; i++) {\n                  this._loadPoint(container, coords[i], dataItem);\n                }\n\n                break;\n            }\n          },\n          _setLineFill: function (path) {\n            var segments = path.segments;\n\n            if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {\n              path.options.fill = null;\n            }\n          },\n          _loadShape: function (container, shape) {\n            if (!this._shapeCreated(shape)) {\n              container.append(shape);\n            }\n\n            return shape;\n          },\n          _loadPolygon: function (container, rings, dataItem) {\n            var shape = this._buildPolygon(rings);\n\n            shape.dataItem = dataItem;\n            return this._loadShape(container, shape);\n          },\n          _buildPolygon: function (rings) {\n            var type = rings.length > 1 ? d.MultiPath : d.Path;\n            var path = new type(this.style);\n\n            for (var i = 0; i < rings.length; i++) {\n              for (var j = 0; j < rings[i].length; j++) {\n                var point = this.locator.locationToView(Location.fromLngLat(rings[i][j]));\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n              }\n            }\n\n            return path;\n          },\n          _loadPoint: function (container, coords, dataItem) {\n            var location = Location.fromLngLat(coords);\n            var point = this.locator.locationToView(location);\n            var circle = new g.Circle(point, 10);\n            var shape = new d.Circle(circle, this.style);\n            shape.dataItem = dataItem;\n            shape.location = location;\n            return this._loadShape(container, shape);\n          }\n        }); // Exports ================================================================\n\n        deepExtend(kendo.data, {\n          schemas: {\n            geojson: {\n              type: \"json\",\n              data: function (data) {\n                if (data.type === \"FeatureCollection\") {\n                  return data.features;\n                }\n\n                if (data.type === \"GeometryCollection\") {\n                  return data.geometries;\n                }\n\n                return data;\n              }\n            }\n          },\n          transports: {\n            geojson: {\n              read: {\n                dataType: \"json\"\n              }\n            }\n          }\n        });\n        deepExtend(dataviz, {\n          map: {\n            layers: {\n              shape: ShapeLayer,\n              ShapeLayer: ShapeLayer\n            },\n            GeoJSONLoader: GeoJSONLoader\n          }\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}