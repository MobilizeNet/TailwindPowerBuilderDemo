{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, HostBinding, Directive, Injectable, InjectionToken, HostListener, ViewChildren, forwardRef, isDevMode, ViewContainerRef, Optional, Inject, ContentChild, ContentChildren, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport * as i9 from '@progress/kendo-angular-common';\nimport { isDocumentAvailable, Keys, isChanged, hasObservers, KendoInput, anyChanged, guid as guid$1, ResizeSensorModule, EventsModule } from '@progress/kendo-angular-common';\nimport * as i8 from '@angular/forms';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { getter as getter$1, pointers, touchEnabled } from '@progress/kendo-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { merge, fromEvent, Subject, Subscription, of, interval } from 'rxjs';\nimport * as i2 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nexport { PopupComponent } from '@progress/kendo-angular-popup';\nimport { map, switchMap, take, auditTime, tap, filter, partition, throttleTime, catchError, skipWhile, concatMap, takeUntil } from 'rxjs/operators';\nimport * as i11 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@progress/kendo-angular-treeview';\nimport { DataBoundComponent, ExpandableComponent, FlatDataBindingDirective, HierarchyBindingDirective, ExpandDirective, TreeViewModule } from '@progress/kendo-angular-treeview';\n/**\n * @hidden\n */\n\nconst _c0 = [\"input\"];\n\nconst _c1 = function (a0, a1) {\n  return {\n    focus: a0,\n    blur: a1\n  };\n};\n\nconst _c2 = [\"content\"];\nconst _c3 = [\"list\"];\nconst _c4 = [\"virtualContainer\"];\n\nfunction ListComponent_div_0_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c5 = function (a0, a1) {\n  return {\n    templateRef: a0,\n    $implicit: a1\n  };\n};\n\nfunction ListComponent_div_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_div_0_1_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r7.fixedGroupTemplate.templateRef, ctx_r7.currentGroup));\n  }\n}\n\nfunction ListComponent_div_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r8.listGroupStickyHeaderTextClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r8.currentGroup);\n  }\n}\n\nconst _c6 = function (a0, a1, a2) {\n  return {\n    \"height.px\": a0,\n    \"minHeight.px\": a1,\n    \"boxSizing\": a2\n  };\n};\n\nfunction ListComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtemplate(1, ListComponent_div_0_1_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(2, ListComponent_div_0_ng_template_2_Template, 2, 3, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r0.listGroupStickyHeaderClass);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction3(5, _c6, ctx_r0.virtual == null ? null : ctx_r0.virtual.itemHeight, ctx_r0.virtual == null ? null : ctx_r0.virtual.itemHeight, ctx_r0.virtual ? \"border-box\" : \"inherit\"));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.fixedGroupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.fixedGroupTemplate);\n  }\n}\n\nfunction ListComponent_5_ng_template_0_input_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"input\", 14);\n    i0.ɵɵlistener(\"change\", function ListComponent_5_ng_template_0_input_1_Template_input_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const itemIndex_r12 = i0.ɵɵnextContext().index;\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.onCheckedChange($event, itemIndex_r12);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const itemIndex_r12 = i0.ɵɵnextContext().index;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r13.checkboxClasses)(\"checked\", ctx_r13.isChecked(itemIndex_r12));\n  }\n}\n\nfunction ListComponent_5_ng_template_0_2_ng_template_0_Template(rf, ctx) {}\n\nfunction ListComponent_5_ng_template_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_5_ng_template_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const dataItem_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r14.template.templateRef, dataItem_r11));\n  }\n}\n\nfunction ListComponent_5_ng_template_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dataItem_r11 = i0.ɵɵnextContext().$implicit;\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r15.getText(dataItem_r11));\n  }\n}\n\nconst _c7 = function (a0, a1) {\n  return {\n    \"k-disabled\": a0,\n    \"k-table-alt-row\": a1\n  };\n};\n\nfunction ListComponent_5_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 12);\n    i0.ɵɵtemplate(1, ListComponent_5_ng_template_0_input_1_Template, 1, 2, \"input\", 13);\n    i0.ɵɵtemplate(2, ListComponent_5_ng_template_0_2_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(3, ListComponent_5_ng_template_0_ng_template_3_Template, 2, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dataItem_r11 = ctx.$implicit;\n    const itemIndex_r12 = ctx.index;\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r10.listItemClass);\n    i0.ɵɵproperty(\"checkboxes\", ctx_r10.checkboxes)(\"height\", ctx_r10.virtual == null ? null : ctx_r10.virtual.itemHeight)(\"index\", itemIndex_r12 + ctx_r10.startFrom)(\"multipleSelection\", ctx_r10.multipleSelection)(\"ngClass\", i0.ɵɵpureFunction2(12, _c7, ctx_r10.isDisabled(itemIndex_r12), ctx_r10.isAltRow(itemIndex_r12)));\n    i0.ɵɵattribute(\"id\", ctx_r10.optionPrefix + \"-\" + ctx_r10.getValue(dataItem_r11))(\"tabIndex\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.checkboxes.enabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r10.template);\n  }\n}\n\nfunction ListComponent_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_5_ng_template_0_Template, 4, 15, \"ng-template\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.data);\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_0_2_ng_template_0_Template(rf, ctx) {}\n\nfunction ListComponent_6_ng_template_0_li_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r28.groupTemplate.templateRef, dataItem_r24.value));\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵtextInterpolate(dataItem_r24.value);\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 18)(1, \"span\");\n    i0.ɵɵtemplate(2, ListComponent_6_ng_template_0_li_0_2_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(3, ListComponent_6_ng_template_0_li_0_ng_template_3_Template, 1, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r33 = i0.ɵɵnextContext();\n    const itemIndex_r25 = ctx_r33.index;\n    const dataItem_r24 = ctx_r33.$implicit;\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r26.listGroupItemClass);\n    i0.ɵɵclassProp(\"k-table-alt-row\", ctx_r26.isAltRow(itemIndex_r25 - 1));\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction3(12, _c6, ctx_r26.virtual == null ? null : ctx_r26.virtual.itemHeight, ctx_r26.virtual == null ? null : ctx_r26.virtual.itemHeight, ctx_r26.virtual ? \"border-box\" : \"inherit\"));\n    i0.ɵɵattribute(\"group-index\", dataItem_r24.index)(\"id\", ctx_r26.optionPrefix + \"-\" + ctx_r26.getValue(dataItem_r24.value))(\"tabIndex\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(ctx_r26.listGroupItemTextClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.groupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r26.groupTemplate);\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_1_1_ng_template_0_Template(rf, ctx) {}\n\nfunction ListComponent_6_ng_template_0_li_1_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_1_1_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r34.template.templateRef, dataItem_r24.value));\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 15);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dataItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r35 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r35.getText(dataItem_r24.value));\n  }\n}\n\nfunction ListComponent_6_ng_template_0_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 19);\n    i0.ɵɵtemplate(1, ListComponent_6_ng_template_0_li_1_1_Template, 1, 4, null, 5);\n    i0.ɵɵtemplate(2, ListComponent_6_ng_template_0_li_1_ng_template_2_Template, 2, 1, \"ng-template\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r39 = i0.ɵɵnextContext();\n    const dataItem_r24 = ctx_r39.$implicit;\n    const itemIndex_r25 = ctx_r39.index;\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassMap(ctx_r27.listItemClass);\n    i0.ɵɵproperty(\"height\", ctx_r27.virtual == null ? null : ctx_r27.virtual.itemHeight)(\"index\", dataItem_r24.offsetIndex)(\"multipleSelection\", ctx_r27.multipleSelection)(\"ngClass\", i0.ɵɵpureFunction2(11, _c7, ctx_r27.isDisabled(dataItem_r24.offsetIndex), ctx_r27.isAltRow(itemIndex_r25 - 1)));\n    i0.ɵɵattribute(\"absolute-index\", dataItem_r24.index)(\"id\", ctx_r27.optionPrefix + \"-\" + ctx_r27.getValue(dataItem_r24.value))(\"tabIndex\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r27.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r27.template);\n  }\n}\n\nfunction ListComponent_6_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_6_ng_template_0_li_0_Template, 4, 16, \"li\", 16);\n    i0.ɵɵtemplate(1, ListComponent_6_ng_template_0_li_1_Template, 3, 14, \"li\", 17);\n  }\n\n  if (rf & 2) {\n    const dataItem_r24 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", dataItem_r24.header && dataItem_r24.index > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !dataItem_r24.header);\n  }\n}\n\nfunction ListComponent_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ListComponent_6_ng_template_0_Template, 2, 2, \"ng-template\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.data);\n  }\n}\n\nfunction ListComponent_kendo_resize_sensor_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 20);\n    i0.ɵɵlistener(\"resize\", function ListComponent_kendo_resize_sensor_7_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r41);\n      const ctx_r40 = i0.ɵɵnextContext();\n      return ctx_r40.listResize.emit();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction ListComponent_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 21, 22)(2, \"div\")(3, \"kendo-resize-sensor\", 20);\n    i0.ɵɵlistener(\"resize\", function ListComponent_div_8_Template_kendo_resize_sensor_resize_3_listener() {\n      i0.ɵɵrestoreView(_r44);\n      const ctx_r43 = i0.ɵɵnextContext();\n      return ctx_r43.listResize.emit();\n    });\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"height\", ctx_r6.scrollHeight, \"px\");\n  }\n}\n\nconst _c8 = [\"container\"];\nconst _c9 = [\"popupTemplate\"];\nconst _c10 = [\"optionsList\"];\n\nfunction AutoCompleteComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 8);\n    i0.ɵɵlistener(\"click\", function AutoCompleteComponent_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearValue($event);\n    })(\"mousedown\", function AutoCompleteComponent_span_3_Template_span_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r1.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n  }\n}\n\nfunction AutoCompleteComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_5_0_ng_template_0_Template(rf, ctx) {}\n\nconst _c15 = function (a0) {\n  return {\n    templateRef: a0\n  };\n};\n\nfunction AutoCompleteComponent_ng_template_5_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_5_0_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r10.headerTemplate.templateRef));\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_5_div_3_ng_template_1_Template(rf, ctx) {}\n\nfunction AutoCompleteComponent_ng_template_5_div_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r16.messageFor(\"noDataText\"));\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_5_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵtemplate(1, AutoCompleteComponent_ng_template_5_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 17);\n    i0.ɵɵtemplate(2, AutoCompleteComponent_ng_template_5_div_3_ng_template_2_Template, 2, 1, \"ng-template\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r12.noDataTemplate == null ? null : ctx_r12.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.noDataTemplate);\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_5_4_ng_template_0_Template(rf, ctx) {}\n\nfunction AutoCompleteComponent_ng_template_5_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_5_4_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r13.footerTemplate.templateRef));\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, AutoCompleteComponent_ng_template_5_0_Template, 1, 3, null, 11);\n    i0.ɵɵelementStart(1, \"kendo-list\", 12, 13);\n    i0.ɵɵlistener(\"pageChange\", function AutoCompleteComponent_ng_template_5_Template_kendo_list_pageChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.pageChange($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, AutoCompleteComponent_ng_template_5_div_3_Template, 3, 5, \"div\", 14);\n    i0.ɵɵtemplate(4, AutoCompleteComponent_ng_template_5_4_Template, 1, 3, null, 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r4.size)(\"rounded\", ctx_r4.rounded)(\"id\", ctx_r4.listBoxId)(\"optionPrefix\", ctx_r4.optionPrefix)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.valueField)(\"valueField\", ctx_r4.valueField)(\"template\", ctx_r4.template)(\"groupTemplate\", ctx_r4.groupTemplate)(\"fixedGroupTemplate\", ctx_r4.fixedGroupTemplate)(\"height\", ctx_r4.listHeight)(\"show\", ctx_r4.isOpen)(\"virtual\", ctx_r4.virtual);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n  }\n}\n\nfunction AutoCompleteComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 18);\n    i0.ɵɵlistener(\"resize\", function AutoCompleteComponent_ng_template_7_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c16 = [\"select\"];\n\nconst _c23 = function (a0) {\n  return {\n    mousedown: a0\n  };\n};\n\nfunction ComboBoxComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵlistener(\"click\", function ComboBoxComponent_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearValue($event);\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r1.clearButtonVisiblity);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(4, _c23, ctx_r1.preventEventDefault));\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n  }\n}\n\nfunction ComboBoxComponent_ng_template_7_0_ng_template_0_Template(rf, ctx) {}\n\nfunction ComboBoxComponent_ng_template_7_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ComboBoxComponent_ng_template_7_0_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r9.headerTemplate.templateRef));\n  }\n}\n\nfunction ComboBoxComponent_ng_template_7_div_3_ng_template_1_Template(rf, ctx) {}\n\nfunction ComboBoxComponent_ng_template_7_div_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r15.messageFor(\"noDataText\"));\n  }\n}\n\nfunction ComboBoxComponent_ng_template_7_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵtemplate(1, ComboBoxComponent_ng_template_7_div_3_ng_template_1_Template, 0, 0, \"ng-template\", 18);\n    i0.ɵɵtemplate(2, ComboBoxComponent_ng_template_7_div_3_ng_template_2_Template, 2, 1, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r11.noDataTemplate ? ctx_r11.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r11.noDataTemplate);\n  }\n}\n\nfunction ComboBoxComponent_ng_template_7_4_ng_template_0_Template(rf, ctx) {}\n\nfunction ComboBoxComponent_ng_template_7_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, ComboBoxComponent_ng_template_7_4_ng_template_0_Template, 0, 0, \"ng-template\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r12.footerTemplate.templateRef));\n  }\n}\n\nfunction ComboBoxComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, ComboBoxComponent_ng_template_7_0_Template, 1, 3, null, 12);\n    i0.ɵɵelementStart(1, \"kendo-list\", 13, 14);\n    i0.ɵɵlistener(\"pageChange\", function ComboBoxComponent_ng_template_7_Template_kendo_list_pageChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.pageChange($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, ComboBoxComponent_ng_template_7_div_3_Template, 3, 5, \"div\", 15);\n    i0.ɵɵtemplate(4, ComboBoxComponent_ng_template_7_4_Template, 1, 3, null, 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r4.size)(\"rounded\", ctx_r4.rounded)(\"id\", ctx_r4.listBoxId)(\"optionPrefix\", ctx_r4.optionPrefix)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.textField)(\"valueField\", ctx_r4.valueField)(\"template\", ctx_r4.template)(\"groupTemplate\", ctx_r4.groupTemplate)(\"fixedGroupTemplate\", ctx_r4.fixedGroupTemplate)(\"height\", ctx_r4.listHeight)(\"show\", ctx_r4.isOpen)(\"virtual\", ctx_r4.virtual);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n  }\n}\n\nfunction ComboBoxComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 19);\n    i0.ɵɵlistener(\"resize\", function ComboBoxComponent_ng_template_9_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction DropDownListComponent_3_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownListComponent_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownListComponent_3_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r0.valueTemplate.templateRef, ctx_r0.dataItem));\n  }\n}\n\nfunction DropDownListComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r1.getText());\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵlistener(\"click\", function DropDownListComponent_ng_template_7_ng_template_0_Template_div_click_0_listener($event) {\n      return $event.stopImmediatePropagation();\n    });\n    i0.ɵɵelementStart(1, \"span\", 14);\n    i0.ɵɵelement(2, \"span\", 15);\n    i0.ɵɵelementStart(3, \"input\", 16);\n    i0.ɵɵlistener(\"ngModelChange\", function DropDownListComponent_ng_template_7_ng_template_0_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.filterText = $event;\n    })(\"keydown\", function DropDownListComponent_ng_template_7_ng_template_0_Template_input_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return ctx_r17.keydown($event);\n    })(\"input\", function DropDownListComponent_ng_template_7_ng_template_0_Template_input_input_3_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return ctx_r18.handleFilter($event);\n    })(\"focus\", function DropDownListComponent_ng_template_7_ng_template_0_Template_input_focus_3_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.onFilterFocus();\n    })(\"blur\", function DropDownListComponent_ng_template_7_ng_template_0_Template_input_blur_3_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r20 = i0.ɵɵnextContext(2);\n      return ctx_r20.blurFilterInput();\n    });\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r7.filterInputClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"filterInput\", ctx_r7.isFocused && !ctx_r7.touchEnabled)(\"dir\", ctx_r7.direction)(\"ngModel\", ctx_r7.filterText);\n    i0.ɵɵattribute(\"aria-owns\", ctx_r7.ariaOwns)(\"aria-activedescendant\", ctx_r7.ariaActivedescendant)(\"aria-label\", ctx_r7.noDataLabel);\n  }\n}\n\nconst _c28 = function (a0) {\n  return {\n    \"k-disabled\": a0\n  };\n};\n\nfunction DropDownListComponent_ng_template_7_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17)(1, \"div\", 18);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r8.optionLabelSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(4, _c28, ctx_r8.isDisabledDefaultItem))(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r8.getDefaultItemText(), \" \");\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_ng_template_2_ng_template_2_Template(rf, ctx) {}\n\nfunction DropDownListComponent_ng_template_7_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17)(1, \"div\", 18);\n    i0.ɵɵtemplate(2, DropDownListComponent_ng_template_7_ng_template_2_ng_template_2_Template, 0, 0, \"ng-template\", 9);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r9.optionLabelSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(4, _c28, ctx_r9.isDisabledDefaultItem))(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(6, _c5, ctx_r9.itemTemplate.templateRef, ctx_r9.defaultItem));\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_3_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownListComponent_ng_template_7_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownListComponent_ng_template_7_3_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r10.headerTemplate.templateRef));\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_div_6_ng_template_1_Template(rf, ctx) {}\n\nfunction DropDownListComponent_ng_template_7_div_6_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r24.messageFor(\"noDataText\"));\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 19);\n    i0.ɵɵtemplate(1, DropDownListComponent_ng_template_7_div_6_ng_template_1_Template, 0, 0, \"ng-template\", 20);\n    i0.ɵɵtemplate(2, DropDownListComponent_ng_template_7_div_6_ng_template_2_Template, 2, 1, \"ng-template\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r12.noDataTemplate ? ctx_r12.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.noDataTemplate);\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_7_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownListComponent_ng_template_7_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownListComponent_ng_template_7_7_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r13.footerTemplate.templateRef));\n  }\n}\n\nfunction DropDownListComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, DropDownListComponent_ng_template_7_ng_template_0_Template, 4, 7, \"ng-template\", 4);\n    i0.ɵɵtemplate(1, DropDownListComponent_ng_template_7_ng_template_1_Template, 3, 6, \"ng-template\", 4);\n    i0.ɵɵtemplate(2, DropDownListComponent_ng_template_7_ng_template_2_Template, 3, 9, \"ng-template\", 4);\n    i0.ɵɵtemplate(3, DropDownListComponent_ng_template_7_3_Template, 1, 3, null, 3);\n    i0.ɵɵelementStart(4, \"kendo-list\", 10, 11);\n    i0.ɵɵlistener(\"pageChange\", function DropDownListComponent_ng_template_7_Template_kendo_list_pageChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext();\n      return ctx_r26.pageChange($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, DropDownListComponent_ng_template_7_div_6_Template, 3, 5, \"div\", 12);\n    i0.ɵɵtemplate(7, DropDownListComponent_ng_template_7_7_Template, 1, 3, null, 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.filterable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.defaultItem && !ctx_r3.itemTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.defaultItem && ctx_r3.itemTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r3.size)(\"rounded\", ctx_r3.rounded)(\"id\", ctx_r3.listBoxId)(\"optionPrefix\", ctx_r3.optionPrefix)(\"data\", ctx_r3.data)(\"textField\", ctx_r3.textField)(\"valueField\", ctx_r3.valueField)(\"template\", ctx_r3.itemTemplate)(\"groupTemplate\", ctx_r3.groupTemplate)(\"fixedGroupTemplate\", ctx_r3.fixedGroupTemplate)(\"height\", ctx_r3.listHeight)(\"show\", ctx_r3.isOpen)(\"virtual\", ctx_r3.virtual);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.footerTemplate);\n  }\n}\n\nfunction DropDownListComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 21);\n    i0.ɵɵlistener(\"resize\", function DropDownListComponent_ng_template_9_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return ctx_r28.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction TagListComponent_div_0_2_ng_template_0_Template(rf, ctx) {}\n\nfunction TagListComponent_div_0_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TagListComponent_div_0_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_3_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TagListComponent_div_0_ng_template_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TagListComponent_div_0_ng_template_3_1_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r9.groupTemplate.templateRef, tag_r1));\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵtextInterpolate2(\"\", tag_r1.length, \" \", tag_r1.length === 1 ? \"item\" : \"items\", \" selected\");\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, TagListComponent_div_0_ng_template_3_1_Template, 1, 4, null, 10);\n    i0.ɵɵtemplate(2, TagListComponent_div_0_ng_template_3_ng_template_2_Template, 1, 2, \"ng-template\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.groupTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.groupTemplate);\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_5_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TagListComponent_div_0_ng_template_5_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TagListComponent_div_0_ng_template_5_1_ng_template_0_Template, 0, 0, \"ng-template\", 12);\n  }\n\n  if (rf & 2) {\n    const tag_r1 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r14.template.templateRef, tag_r1));\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_5_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    const tag_r1 = ctx_r18.$implicit;\n    const index_r2 = ctx_r18.index;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r15.tagProp(tag_r1, ctx_r15.textField, index_r2));\n  }\n}\n\nfunction TagListComponent_div_0_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵtemplate(1, TagListComponent_div_0_ng_template_5_1_Template, 1, 4, null, 10);\n    i0.ɵɵtemplate(2, TagListComponent_div_0_ng_template_5_ng_template_2_Template, 1, 1, \"ng-template\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.template);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.template);\n  }\n}\n\nconst _c29 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n  return {\n    \"k-focus\": a0,\n    \"k-disabled\": a1,\n    \"k-chip-sm\": a2,\n    \"k-chip-md\": a3,\n    \"k-chip-lg\": a4,\n    \"k-rounded-sm\": a5,\n    \"k-rounded-md\": a6,\n    \"k-rounded-lg\": a7,\n    \"k-rounded-full\": a8,\n    \"k-chip-solid k-chip-solid-base\": a9,\n    \"k-chip-flat k-chip-flat-base\": a10,\n    \"k-chip-outline k-chip-outline-base\": a11\n  };\n};\n\nfunction TagListComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1)(1, \"span\", 2);\n    i0.ɵɵtemplate(2, TagListComponent_div_0_2_Template, 1, 0, null, 3);\n    i0.ɵɵtemplate(3, TagListComponent_div_0_ng_template_3_Template, 3, 2, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(5, TagListComponent_div_0_ng_template_5_Template, 3, 2, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"span\", 6)(8, \"span\", 7)(9, \"span\", 8);\n    i0.ɵɵlistener(\"mousedown\", function TagListComponent_div_0_Template_span_mousedown_9_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r20);\n      const tag_r1 = restoredCtx.$implicit;\n      const index_r2 = restoredCtx.index;\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.deleteTag($event, tag_r1, index_r2);\n    });\n    i0.ɵɵelementEnd()()()();\n  }\n\n  if (rf & 2) {\n    const tag_r1 = ctx.$implicit;\n    const index_r2 = ctx.index;\n\n    const _r4 = i0.ɵɵreference(4);\n\n    const _r6 = i0.ɵɵreference(6);\n\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunctionV(7, _c29, [index_r2 === ctx_r0.focused, ctx_r0.isTagDisabled(tag_r1, index_r2), ctx_r0.size === \"small\", ctx_r0.size === \"medium\", ctx_r0.size === \"large\", ctx_r0.rounded === \"small\", ctx_r0.rounded === \"medium\", ctx_r0.rounded === \"large\", ctx_r0.rounded === \"full\", ctx_r0.fillMode === \"solid\", ctx_r0.fillMode === \"flat\", ctx_r0.fillMode === \"outline\"]));\n    i0.ɵɵattribute(\"id\", ctx_r0.itemId(tag_r1, index_r2))(\"aria-hidden\", ctx_r0.tagAriaHidden(index_r2));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isGroupTag(tag_r1))(\"ngIfThen\", _r4)(\"ngIfElse\", _r6);\n    i0.ɵɵadvance(6);\n    i0.ɵɵattribute(\"aria-hidden\", index_r2 !== ctx_r0.focused);\n  }\n}\n\nconst _c30 = [\"*\"];\n\nfunction MultiSelectComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵlistener(\"mousedown\", function MultiSelectComponent_span_4_Template_span_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearAll($event);\n    });\n    i0.ɵɵelement(1, \"span\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r1.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n  }\n}\n\nfunction MultiSelectComponent_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 11);\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_0_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiSelectComponent_ng_template_6_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiSelectComponent_ng_template_6_0_ng_template_0_Template, 0, 0, \"ng-template\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r9.headerTemplate.templateRef));\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_div_1_2_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiSelectComponent_ng_template_6_div_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiSelectComponent_ng_template_6_div_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r15.customItemTemplate.templateRef, ctx_r15.text));\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_div_1_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(3);\n    i0.ɵɵtextInterpolate(ctx_r17.text);\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18)(1, \"div\", 19);\n    i0.ɵɵtemplate(2, MultiSelectComponent_ng_template_6_div_1_2_Template, 1, 4, null, 20);\n    i0.ɵɵtemplate(3, MultiSelectComponent_ng_template_6_div_1_ng_template_3_Template, 1, 1, \"ng-template\", null, 21, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelement(5, \"span\", 22);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const _r16 = i0.ɵɵreference(4);\n\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r10.customItemSizeClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"multipleSelection\", true)(\"index\", -1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.customItemTemplate)(\"ngIfElse\", _r16);\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_div_4_ng_template_1_Template(rf, ctx) {}\n\nfunction MultiSelectComponent_ng_template_6_div_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r20.messageFor(\"noDataText\"));\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 23);\n    i0.ɵɵtemplate(1, MultiSelectComponent_ng_template_6_div_4_ng_template_1_Template, 0, 0, \"ng-template\", 24);\n    i0.ɵɵtemplate(2, MultiSelectComponent_ng_template_6_div_4_ng_template_2_Template, 2, 1, \"ng-template\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r12.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r12.noDataTemplate ? ctx_r12.noDataTemplate.templateRef : undefined));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r12.noDataTemplate);\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_5_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiSelectComponent_ng_template_6_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiSelectComponent_ng_template_6_5_ng_template_0_Template, 0, 0, \"ng-template\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r13.footerTemplate.templateRef));\n  }\n}\n\nfunction MultiSelectComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, MultiSelectComponent_ng_template_6_0_Template, 1, 3, null, 12);\n    i0.ɵɵtemplate(1, MultiSelectComponent_ng_template_6_div_1_Template, 6, 5, \"div\", 13);\n    i0.ɵɵelementStart(2, \"kendo-list\", 14, 15);\n    i0.ɵɵlistener(\"pageChange\", function MultiSelectComponent_ng_template_6_Template_kendo_list_pageChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return ctx_r22.pageChange($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, MultiSelectComponent_ng_template_6_div_4_Template, 3, 5, \"div\", 16);\n    i0.ɵɵtemplate(5, MultiSelectComponent_ng_template_6_5_Template, 1, 3, null, 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.allowCustom && ctx_r4.text);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r4.size)(\"rounded\", ctx_r4.rounded)(\"id\", ctx_r4.listBoxId)(\"optionPrefix\", ctx_r4.optionPrefix)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.textField)(\"valueField\", ctx_r4.valueField)(\"height\", ctx_r4.listHeight)(\"template\", ctx_r4.template)(\"groupTemplate\", ctx_r4.groupTemplate)(\"fixedGroupTemplate\", ctx_r4.fixedGroupTemplate)(\"show\", ctx_r4.isOpen)(\"multipleSelection\", true)(\"virtual\", ctx_r4.virtual)(\"checkboxes\", ctx_r4.checkboxes);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n  }\n}\n\nfunction MultiSelectComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 25);\n    i0.ɵɵlistener(\"resize\", function MultiSelectComponent_ng_template_8_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return ctx_r24.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c35 = [\"header\"];\n\nfunction MultiColumnComboBoxComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵlistener(\"click\", function MultiColumnComboBoxComponent_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearValue($event);\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r1.clearButtonVisiblity);\n    i0.ɵɵproperty(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(4, _c23, ctx_r1.preventEventDefault));\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_0_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_7_0_ng_template_0_Template, 0, 0, \"ng-template\", 25);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r9.headerTemplate == null ? null : ctx_r9.headerTemplate.templateRef));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_7_col_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"col\");\n  }\n\n  if (rf & 2) {\n    const column_r19 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵstyleProp(\"width\", column_r19.width, \"px\");\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_ng_container_7_col_1_Template, 1, 2, \"col\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r19 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r19.hidden && column_r19.matchesMedia);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r22 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r22.title || column_r22.field, \" \");\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c40 = function (a0, a1, a2) {\n  return {\n    templateRef: a0,\n    $implicit: a1,\n    column: a2\n  };\n};\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 25);\n  }\n\n  if (rf & 2) {\n    const column_r22 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction3(1, _c40, column_r22.headerTemplate == null ? null : column_r22.headerTemplate.templateRef, column_r22, column_r22));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 28);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_ng_container_1_Template, 2, 1, \"ng-container\", 12);\n    i0.ɵɵtemplate(2, MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_2_Template, 1, 5, null, 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r22 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"ngStyle\", column_r22.headerStyle)(\"ngClass\", column_r22.headerClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r22.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r22.headerTemplate);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_ng_container_10_th_1_Template, 3, 4, \"th\", 27);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r22 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r22.hidden && column_r22.matchesMedia);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r32 = i0.ɵɵnextContext(2).$implicit;\n    const dataItem_r30 = i0.ɵɵnextContext().$implicit;\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r34.textFrom(dataItem_r30, column_r32.field), \" \");\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_2_ng_template_0_Template(rf, ctx) {}\n\nconst _c41 = function (a0, a1, a2, a3) {\n  return {\n    templateRef: a0,\n    $implicit: a1,\n    dataItem: a2,\n    column: a3\n  };\n};\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 25);\n  }\n\n  if (rf & 2) {\n    const column_r32 = i0.ɵɵnextContext(2).$implicit;\n    const dataItem_r30 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction4(1, _c41, column_r32.cellTemplate == null ? null : column_r32.cellTemplate.templateRef, dataItem_r30, dataItem_r30, column_r32));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 30);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_ng_container_1_Template, 2, 1, \"ng-container\", 12);\n    i0.ɵɵtemplate(2, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_2_Template, 1, 6, null, 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r32 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵstyleProp(\"width\", column_r32.width, \"px\");\n    i0.ɵɵproperty(\"ngClass\", column_r32.class)(\"ngStyle\", column_r32.style);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r32.cellTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", column_r32.cellTemplate);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_span_1_Template, 3, 6, \"span\", 29);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r32 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !column_r32.hidden && column_r32.matchesMedia);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_ng_container_0_Template, 2, 1, \"ng-container\", 18);\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r14.columns);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_div_15_ng_template_1_Template(rf, ctx) {}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_div_15_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r43 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r43.messageFor(\"noDataText\"));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_div_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 31);\n    i0.ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_7_div_15_ng_template_1_Template, 0, 0, \"ng-template\", 32);\n    i0.ɵɵtemplate(2, MultiColumnComboBoxComponent_ng_template_7_div_15_ng_template_2_Template, 2, 1, \"ng-template\", 33);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r16.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r16.noDataTemplate == null ? null : ctx_r16.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r16.noDataTemplate);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_16_ng_template_6_Template(rf, ctx) {}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_ng_container_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 34)(2, \"table\", 35)(3, \"tfoot\", 36)(4, \"tr\", 20)(5, \"td\", 37);\n    i0.ɵɵtemplate(6, MultiColumnComboBoxComponent_ng_template_7_ng_container_16_ng_template_6_Template, 0, 0, \"ng-template\", 25);\n    i0.ɵɵelementEnd()()()()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(6);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r17.footerTemplate.templateRef));\n  }\n}\n\nfunction MultiColumnComboBoxComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r46 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_7_0_Template, 1, 3, null, 12);\n    i0.ɵɵelementStart(1, \"div\", 13)(2, \"div\", 14, 15)(4, \"div\", 16)(5, \"table\", 17)(6, \"colgroup\");\n    i0.ɵɵtemplate(7, MultiColumnComboBoxComponent_ng_template_7_ng_container_7_Template, 2, 1, \"ng-container\", 18);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"thead\", 19)(9, \"tr\", 20);\n    i0.ɵɵtemplate(10, MultiColumnComboBoxComponent_ng_template_7_ng_container_10_Template, 2, 1, \"ng-container\", 18);\n    i0.ɵɵelementEnd()()()()();\n    i0.ɵɵtemplate(11, MultiColumnComboBoxComponent_ng_template_7_ng_template_11_Template, 1, 1, \"ng-template\", null, 21, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementStart(13, \"kendo-list\", 22, 23);\n    i0.ɵɵlistener(\"pageChange\", function MultiColumnComboBoxComponent_ng_template_7_Template_kendo_list_pageChange_13_listener($event) {\n      i0.ɵɵrestoreView(_r46);\n      const ctx_r45 = i0.ɵɵnextContext();\n      return ctx_r45.pageChange($event);\n    })(\"listResize\", function MultiColumnComboBoxComponent_ng_template_7_Template_kendo_list_listResize_13_listener() {\n      i0.ɵɵrestoreView(_r46);\n\n      const _r10 = i0.ɵɵreference(3);\n\n      const ctx_r47 = i0.ɵɵnextContext();\n      return ctx_r47.updateHeaderPadding(_r10);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(15, MultiColumnComboBoxComponent_ng_template_7_div_15_Template, 3, 5, \"div\", 24);\n    i0.ɵɵtemplate(16, MultiColumnComboBoxComponent_ng_template_7_ng_container_16_Template, 7, 3, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r13 = i0.ɵɵreference(12);\n\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r4.tableSizeClass);\n    i0.ɵɵadvance(6);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.columns);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.columns);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"id\", ctx_r4.listBoxId)(\"optionPrefix\", ctx_r4.optionPrefix)(\"data\", ctx_r4.data)(\"textField\", ctx_r4.textField)(\"valueField\", ctx_r4.valueField)(\"template\", i0.ɵɵpureFunction1(18, _c15, _r13))(\"groupTemplate\", ctx_r4.groupTemplate)(\"fixedGroupTemplate\", ctx_r4.fixedGroupTemplate)(\"height\", ctx_r4.listHeight)(\"show\", ctx_r4.isOpen)(\"virtual\", ctx_r4.virtual)(\"type\", \"dropdowngrid\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n  }\n}\n\nfunction MultiColumnComboBoxComponent_kendo_resize_sensor_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r49 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-resize-sensor\", 38);\n    i0.ɵɵlistener(\"resize\", function MultiColumnComboBoxComponent_kendo_resize_sensor_9_Template_kendo_resize_sensor_resize_0_listener() {\n      i0.ɵɵrestoreView(_r49);\n      const ctx_r48 = i0.ɵɵnextContext();\n      return ctx_r48.onResize();\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c42 = [\"treeview\"];\nconst _c43 = [\"filterInput\"];\n\nfunction DropDownTreeComponent_3_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownTreeComponent_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownTreeComponent_3_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction2(1, _c5, ctx_r0.valueTemplate.templateRef, ctx_r0.dataItem));\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.text || ctx_r1.placeholder, \" \");\n  }\n}\n\nfunction DropDownTreeComponent_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵlistener(\"click\", function DropDownTreeComponent_span_5_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.clearValue($event);\n    });\n    i0.ɵɵelement(1, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", ctx_r2.clearButtonVisiblity);\n    i0.ɵɵattribute(\"title\", ctx_r2.messageFor(\"clearTitle\"));\n  }\n}\n\nconst _c50 = function (a0) {\n  return {\n    blur: a0\n  };\n};\n\nfunction DropDownTreeComponent_ng_template_8_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 16)(1, \"span\", 17)(2, \"span\", 18);\n    i0.ɵɵelement(3, \"span\", 19);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"input\", 20, 21);\n    i0.ɵɵlistener(\"input\", function DropDownTreeComponent_ng_template_8_span_0_Template_input_input_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.handleFilterInputChange($event.target);\n    })(\"keydown.arrowdown\", function DropDownTreeComponent_ng_template_8_span_0_Template_input_keydown_arrowdown_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return ctx_r17.handleKeydown($event);\n    })(\"keydown.alt.arrowup\", function DropDownTreeComponent_ng_template_8_span_0_Template_input_keydown_alt_arrowup_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return ctx_r18.handleKeydown($event);\n    })(\"ngModelChange\", function DropDownTreeComponent_ng_template_8_span_0_Template_input_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.filter = $event;\n    });\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r9.filterInputClasses);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"filterInput\", ctx_r9.filterable && !ctx_r9.touchEnabled)(\"ngModel\", ctx_r9.filter)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(5, _c50, ctx_r9.handleBlur))(\"scope\", ctx_r9);\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_1_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownTreeComponent_ng_template_8_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownTreeComponent_ng_template_8_1_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r10.headerTemplate == null ? null : ctx_r10.headerTemplate.templateRef));\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-treeview\", 22, 23);\n    i0.ɵɵlistener(\"selectedKeysChange\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_selectedKeysChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.selectedKeys = $event;\n    })(\"focusout\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_focusout_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.handleBlur($event);\n    })(\"keydown\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return ctx_r25.handleKeydown($event);\n    })(\"selectionChange\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_selectionChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.onSelectionChange($event);\n    })(\"expand\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_expand_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return ctx_r27.nodeExpand.emit($event);\n    })(\"collapse\", function DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template_kendo_treeview_collapse_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.nodeCollapse.emit($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r11.listHeight, \"px\");\n    i0.ɵɵproperty(\"size\", ctx_r11.size)(\"nodes\", ctx_r11.data)(\"animate\", false)(\"selectedKeys\", ctx_r11.selectedKeys)(\"selectBy\", ctx_r11.selectBy)(\"textField\", ctx_r11.textField)(\"children\", ctx_r11.children)(\"hasChildren\", ctx_r11.hasChildren)(\"loadOnDemand\", ctx_r11.loadOnDemand)(\"isExpanded\", ctx_r11.isNodeExpanded)(\"isDisabled\", ctx_r11.itemDisabled)(\"nodeTemplate\", ctx_r11.nodeTemplate)(\"filter\", ctx_r11.filter)(\"isVisible\", ctx_r11.isNodeVisible);\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_3_ng_template_0_Template(rf, ctx) {}\n\nfunction DropDownTreeComponent_ng_template_8_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownTreeComponent_ng_template_8_3_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r12.footerTemplate == null ? null : ctx_r12.footerTemplate.templateRef));\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_div_4_ng_template_1_Template(rf, ctx) {}\n\nfunction DropDownTreeComponent_ng_template_8_div_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r31.messageFor(\"noDataText\"));\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵtemplate(1, DropDownTreeComponent_ng_template_8_div_4_ng_template_1_Template, 0, 0, \"ng-template\", 25);\n    i0.ɵɵtemplate(2, DropDownTreeComponent_ng_template_8_div_4_ng_template_2_Template, 2, 1, \"ng-template\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r13.noDataTemplate == null ? null : ctx_r13.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r13.noDataTemplate);\n  }\n}\n\nfunction DropDownTreeComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropDownTreeComponent_ng_template_8_span_0_Template, 6, 7, \"span\", 13);\n    i0.ɵɵtemplate(1, DropDownTreeComponent_ng_template_8_1_Template, 1, 3, null, 3);\n    i0.ɵɵtemplate(2, DropDownTreeComponent_ng_template_8_kendo_treeview_2_Template, 2, 16, \"kendo-treeview\", 14);\n    i0.ɵɵtemplate(3, DropDownTreeComponent_ng_template_8_3_Template, 1, 3, null, 3);\n    i0.ɵɵtemplate(4, DropDownTreeComponent_ng_template_8_div_4_Template, 3, 5, \"div\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.filterable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length !== 0 && !ctx_r4.allNodesHidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.data.length === 0 || ctx_r4.allNodesHidden);\n  }\n}\n\nconst _c51 = [\"checkAllInput\"];\n\nfunction MultiSelectTreeComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 7)(1, \"span\", 8);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.placeholder);\n  }\n}\n\nfunction MultiSelectTreeComponent_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵlistener(\"click\", function MultiSelectTreeComponent_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.clearAll($event);\n    });\n    i0.ɵɵelement(1, \"span\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"title\", ctx_r1.messageFor(\"clearTitle\"));\n  }\n}\n\nfunction MultiSelectTreeComponent_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 11);\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 18)(1, \"span\", 19)(2, \"span\", 20);\n    i0.ɵɵelement(3, \"span\", 21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"input\", 22, 23);\n    i0.ɵɵlistener(\"input\", function MultiSelectTreeComponent_ng_template_5_span_0_Template_input_input_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.handleFilterInputChange($event.target);\n    })(\"keydown\", function MultiSelectTreeComponent_ng_template_5_span_0_Template_input_keydown_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      return ctx_r17.handleKeydown($event);\n    })(\"ngModelChange\", function MultiSelectTreeComponent_ng_template_5_span_0_Template_input_ngModelChange_4_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return ctx_r18.filter = $event;\n    });\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r8.filterInputClasses);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"filterInput\", ctx_r8.filterable && !ctx_r8.touchEnabled)(\"ngModel\", ctx_r8.filter)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(5, _c50, ctx_r8.handleBlur))(\"scope\", ctx_r8);\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_1_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiSelectTreeComponent_ng_template_5_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_5_1_ng_template_0_Template, 0, 0, \"ng-template\", 24);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r9.headerTemplate == null ? null : ctx_r9.headerTemplate.templateRef));\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 25)(1, \"input\", 26, 27);\n    i0.ɵɵlistener(\"checkedItemsChange\", function MultiSelectTreeComponent_ng_template_5_div_2_Template_input_checkedItemsChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext(2);\n      return ctx_r21.handleCheckedItemsChange($event);\n    })(\"keydown\", function MultiSelectTreeComponent_ng_template_5_div_2_Template_input_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return ctx_r23.handleKeydown($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"span\", 28);\n    i0.ɵɵlistener(\"click\", function MultiSelectTreeComponent_ng_template_5_div_2_Template_span_click_3_listener() {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.toggleCheckAll();\n    })(\"mousedown\", function MultiSelectTreeComponent_ng_template_5_div_2_Template_span_mousedown_3_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r11 = i0.ɵɵreference(4);\n\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checkAll\", !ctx_r10.filterable && !ctx_r10.touchEnabled)(\"ngClass\", ctx_r10.checkAllCheckboxClasses)(\"treeview\", _r11)(\"checkedItems\", ctx_r10.checkedItems)(\"valueField\", ctx_r10.valueField)(\"lastAction\", ctx_r10.lastAction)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(9, _c50, ctx_r10.handleBlur))(\"scope\", ctx_r10);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r10.messageFor(\"checkAllText\"), \" \");\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_5_ng_template_0_Template(rf, ctx) {}\n\nfunction MultiSelectTreeComponent_ng_template_5_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_5_5_ng_template_0_Template, 0, 0, \"ng-template\", 24);\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"templateContext\", i0.ɵɵpureFunction1(1, _c15, ctx_r12.footerTemplate == null ? null : ctx_r12.footerTemplate.templateRef));\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_div_6_ng_template_1_Template(rf, ctx) {}\n\nfunction MultiSelectTreeComponent_ng_template_5_div_6_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r28.messageFor(\"noDataText\"));\n  }\n}\n\nfunction MultiSelectTreeComponent_ng_template_5_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 29);\n    i0.ɵɵtemplate(1, MultiSelectTreeComponent_ng_template_5_div_6_ng_template_1_Template, 0, 0, \"ng-template\", 30);\n    i0.ɵɵtemplate(2, MultiSelectTreeComponent_ng_template_5_div_6_ng_template_2_Template, 2, 1, \"ng-template\", 31);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.noDataTemplate)(\"templateContext\", i0.ɵɵpureFunction1(3, _c15, ctx_r13.noDataTemplate == null ? null : ctx_r13.noDataTemplate.templateRef));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r13.noDataTemplate);\n  }\n}\n\nconst _c58 = function (a0) {\n  return {\n    focusout: a0\n  };\n};\n\nfunction MultiSelectTreeComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_5_span_0_Template, 6, 7, \"span\", 12);\n    i0.ɵɵtemplate(1, MultiSelectTreeComponent_ng_template_5_1_Template, 1, 3, null, 13);\n    i0.ɵɵtemplate(2, MultiSelectTreeComponent_ng_template_5_div_2_Template, 5, 11, \"div\", 14);\n    i0.ɵɵelementStart(3, \"kendo-treeview\", 15, 16);\n    i0.ɵɵlistener(\"keydown\", function MultiSelectTreeComponent_ng_template_5_Template_kendo_treeview_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return ctx_r29.handleKeydown($event);\n    })(\"nodeClick\", function MultiSelectTreeComponent_ng_template_5_Template_kendo_treeview_nodeClick_3_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return ctx_r31.handleNodeClick($event);\n    })(\"expand\", function MultiSelectTreeComponent_ng_template_5_Template_kendo_treeview_expand_3_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return ctx_r32.nodeExpand.emit($event);\n    })(\"collapse\", function MultiSelectTreeComponent_ng_template_5_Template_kendo_treeview_collapse_3_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r33 = i0.ɵɵnextContext();\n      return ctx_r33.nodeCollapse.emit($event);\n    })(\"checkedItemsChange\", function MultiSelectTreeComponent_ng_template_5_Template_kendo_treeview_checkedItemsChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.handleCheckedItemsChange($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, MultiSelectTreeComponent_ng_template_5_5_Template, 1, 3, null, 13);\n    i0.ɵɵtemplate(6, MultiSelectTreeComponent_ng_template_5_div_6_Template, 3, 5, \"div\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.filterable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.headerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.checkAll);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r4.listHeight, \"px\");\n    i0.ɵɵproperty(\"size\", ctx_r4.size)(\"nodes\", ctx_r4.data)(\"animate\", false)(\"checkable\", ctx_r4.checkableSettings)(\"checkedItems\", ctx_r4.checkedItems)(\"valueField\", ctx_r4.valueField)(\"textField\", ctx_r4.textField)(\"children\", ctx_r4.children)(\"hasChildren\", ctx_r4.hasChildren)(\"isExpanded\", ctx_r4.isNodeExpanded)(\"isDisabled\", ctx_r4.itemDisabled)(\"nodeTemplate\", ctx_r4.nodeTemplate)(\"loadOnDemand\", ctx_r4.loadOnDemand)(\"filter\", ctx_r4.filter)(\"isVisible\", ctx_r4.isNodeVisible)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(24, _c58, ctx_r4.handleBlur))(\"scope\", ctx_r4);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.footerTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", (ctx_r4.data == null ? null : ctx_r4.data.length) === 0 || ctx_r4.allNodesHidden);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-dropdowns',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654848651,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/* eslint-disable no-bitwise */\n\n/**\n * @hidden\n */\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isNumber = value => !isNaN(value);\n/**\n * @hidden\n */\n\n\nconst guid = () => {\n  let id = \"\";\n  let i;\n  let random;\n\n  for (i = 0; i < 32; i++) {\n    random = Math.random() * 16 | 0;\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      id += \"-\";\n    }\n\n    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return id;\n};\n/**\n * @hidden\n */\n\n\nconst combineStr = (begin, end) => {\n  return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));\n};\n/**\n * @hidden\n */\n\n\nconst isWindowAvailable = () => typeof window !== 'undefined';\n/**\n * @hidden\n */\n\n\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\n\n\nconst isObject = value => isPresent(value) && typeof value === 'object';\n/**\n * @hidden\n */\n\n\nconst isEmptyString = value => typeof value === 'string' && value.length === 0;\n/**\n * @hidden\n */\n\n\nconst resolveValuesInArray = (values, data = [], valueField) => values.map(value => {\n  return data.find(item => getter(item, valueField) === value);\n}).filter(value => value !== undefined);\n/**\n * @hidden\n */\n\n\nconst validateComplexValues = (values, valueField) => isArray(values) && values.filter(item => {\n  return isObject(item) && isPresent(getter(item, valueField));\n});\n/**\n * @hidden\n */\n\n\nconst resolveAllValues = (value, data, valueField) => {\n  const customValues = validateComplexValues(value, valueField) || [];\n  const resolvedValues = resolveValuesInArray(value, data, valueField) || [];\n  return resolvedValues.concat(customValues);\n};\n/**\n * @hidden\n */\n\n\nconst isObjectArray = values => {\n  return isArray(values) && values.every(item => isObject(item));\n};\n/**\n * @hidden\n */\n\n\nconst selectedIndices = (values, data, valueField) => {\n  const extractedValues = data.map(item => {\n    return isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;\n  });\n  return values.reduce((arr, item) => {\n    const value = isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;\n    const index = extractedValues.indexOf(value);\n\n    if (index !== -1) {\n      arr.push(index);\n    }\n\n    return arr;\n  }, []);\n};\n/**\n * @hidden\n */\n\n\nconst getter = (dataItem, field) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n\n  if (!isPresent(field) || !isObject(dataItem)) {\n    return dataItem;\n  } // creates a field accessor supporting nested fields processing\n\n\n  const valueFrom = getter$1(field);\n  return valueFrom(dataItem);\n};\n/**\n * @hidden\n */\n\n\nconst resolveValue = args => {\n  let dataItem;\n\n  if (isPresent(args.value)) {\n    const data = [args.defaultItem, ...args.data];\n    dataItem = data.find(element => getter(element, args.valueField) === args.value);\n    return {\n      dataItem: dataItem,\n      focused: args.data.indexOf(dataItem),\n      selected: args.data.indexOf(dataItem)\n    };\n  } else if (args.index) {\n    dataItem = args.data[args.index];\n    return {\n      dataItem: args.data[args.index],\n      focused: args.index,\n      selected: args.index\n    };\n  }\n\n  return {\n    dataItem: args.defaultItem,\n    focused: -1,\n    selected: -1\n  };\n};\n/**\n * @hidden\n */\n\n\nconst sameCharsOnly = (word, character) => {\n  for (let idx = 0; idx < word.length; idx++) {\n    if (word.charAt(idx) !== character) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * @hidden\n */\n\n\nconst shuffleData = (data, splitIndex, defaultItem) => {\n  let result = data;\n\n  if (defaultItem) {\n    result = [defaultItem].concat(result);\n  }\n\n  return result.slice(splitIndex).concat(result.slice(0, splitIndex));\n};\n/**\n * @hidden\n */\n\n\nconst matchText = (text, word, ignoreCase) => {\n  if (!isPresent(text)) {\n    return false;\n  }\n\n  let temp = String(text);\n\n  if (ignoreCase) {\n    temp = temp.toLowerCase();\n  }\n\n  return temp.indexOf(word) === 0;\n};\n/**\n * @hidden\n */\n\n\nconst elementFromPoint = (x, y) => {\n  if (!isDocumentAvailable()) {\n    return;\n  }\n\n  return document.elementFromPoint(x, y);\n};\n/**\n * @hidden\n *\n * Checks whether the passed object has all of the listed properties.\n */\n\n\nconst hasProps = (obj, props) => {\n  if (!isPresent(obj)) {\n    return false;\n  }\n\n  return props.every(prop => obj.hasOwnProperty(prop));\n};\n/**\n * @hidden\n *\n * Checks whether an element is untouched by looking for the ng-untouched css class\n */\n\n\nconst isUntouched = element => element.className.includes('ng-untouched');\n/**\n * @hidden\n */\n\n\nconst noop = _ => {};\n/**\n * IE element `matches` polyfill.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\n */\n\n\nconst matches = (element, selector) => {\n  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;\n\n  if (!matcher) {\n    return false;\n  }\n\n  return matcher.call(element, selector);\n};\n/**\n * @hidden\n *\n * IE element `closest` polyfill.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n */\n\n\nconst closest = (element, selector) => {\n  let parent = element;\n\n  while (parent !== null && parent.nodeType === 1) {\n    if (matches(parent, selector)) {\n      return parent;\n    }\n\n    parent = parent.parentElement || parent.parentNode;\n  }\n\n  return null;\n};\n/**\n * @hidden\n *\n * Parses a provided value to its type 'number' representation.\n * If the parsed value (via Number(value)) is NaN, the provided default value is returned.\n * Uses 0 as default value if a second param is not provided.\n */\n\n\nconst parseNumber = (num, defaultValue = 0) => {\n  const normalizedValue = Number(num);\n  return isNaN(normalizedValue) ? defaultValue : normalizedValue;\n};\n/**\n * @hidden\n *\n * Checks whether the passed target element is inside the provided host or popupRef.\n */\n\n\nconst inDropDown = (host, target, popupRef) => {\n  return host.nativeElement.contains(target) || popupRef && popupRef.popupElement.contains(target);\n};\n/**\n * @hidden\n *\n * Calculates the hierarchical level of an item, based on the provided index.\n * The result level is zero-based (starts from 0).\n */\n\n\nconst getHierarchicalItemLevel = index => {\n  return (index || '').split('_').length - 1;\n};\n/**\n * @hidden\n *\n * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.\n */\n\n\nconst fetchDescendentNodes = (lookup, filterExpression) => {\n  if (!isPresent(lookup) || lookup.children.length === 0) {\n    return [];\n  }\n\n  let descendants = lookup.children;\n\n  if (isPresent(filterExpression)) {\n    descendants = descendants.filter(descendent => filterExpression(descendent.item));\n  }\n\n  descendants.forEach(child => descendants = descendants.concat(fetchDescendentNodes(child, filterExpression)));\n  return descendants;\n};\n/**\n * @hidden\n *\n * Retrieves the correct value based on the item's level and the provided value field/s.\n * Used in the MultiSelectTree component.\n */\n\n\nconst valueFrom = ({\n  dataItem,\n  index,\n  level\n}, valueField) => {\n  const fields = Array.isArray(valueField) ? valueField : [valueField]; // either use the explicitly provided value level, or infer it from the item index\n\n  const valueLevel = isPresent(level) ? level : getHierarchicalItemLevel(index); // fall-back to the last available one, if the current node is in a deeper level\n\n  const normalizedLevel = Math.min(valueLevel, fields.length - 1);\n  const field = fields[normalizedLevel];\n  return getter$1(field)(dataItem);\n};\n/**\n * @hidden\n * Returns the size class based on the component and size input.\n */\n\n\nconst getSizeClass = (component, size) => {\n  const SIZE_CLASSES = {\n    'small': `k-${component}-sm`,\n    'medium': `k-${component}-md`,\n    'large': `k-${component}-lg`\n  };\n  return SIZE_CLASSES[size];\n};\n/**\n * @hidden\n * Returns the rounded class based on the rounded input.\n */\n\n\nconst getRoundedClass = rounded => {\n  const ROUNDED_CLASSES = {\n    'small': 'k-rounded-sm',\n    'medium': 'k-rounded-md',\n    'large': 'k-rounded-lg',\n    'full': 'k-rounded-full'\n  };\n  return ROUNDED_CLASSES[rounded];\n};\n/**\n * @hidden\n * Return the fillMode class based on the component and fillMode input.\n */\n\n\nconst getFillModeClass = (component, fillMode) => {\n  const FILLMODE_CLASSES = {\n    'solid': `k-${component}-solid`,\n    'flat': `k-${component}-flat`,\n    'outline': `k-${component}-outline`\n  };\n  return FILLMODE_CLASSES[fillMode];\n};\n/**\n * @hidden\n */\n\n\nlet SearchBarComponent = /*#__PURE__*/(() => {\n  class SearchBarComponent {\n    constructor(localization, renderer) {\n      this.localization = localization;\n      this.valueChange = new EventEmitter();\n      this.onBlur = new EventEmitter();\n      this.onFocus = new EventEmitter();\n      this.onClick = new EventEmitter();\n      this.onNavigate = new EventEmitter();\n      this.searchBarClass = true;\n      this._userInput = \"\";\n      this._previousValue = \"\";\n      this._placeholder = \"\";\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.renderer = renderer;\n    }\n\n    get userInput() {\n      return this._userInput;\n    }\n\n    set userInput(userInput) {\n      this._userInput = userInput || \"\";\n    }\n\n    get value() {\n      return this.input.nativeElement.value;\n    }\n\n    set placeholder(text) {\n      this._placeholder = text || '';\n      this.setInputSize();\n    }\n\n    get placeholder() {\n      return this._placeholder;\n    }\n\n    get ariaExpanded() {\n      return this.role === 'combobox' ? this.popupOpen : null;\n    }\n\n    ngOnInit() {\n      this.localizationChangeSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n\n    ngOnChanges(changes) {\n      let previousUserInput;\n\n      if (this.input && (changes.userInput || changes.suggestedText)) {\n        if (changes.userInput && changes.userInput.previousValue) {\n          if (this._previousValue === changes.userInput.previousValue) {\n            previousUserInput = this._previousValue;\n          } else {\n            previousUserInput = changes.userInput.currentValue || \"\";\n          }\n        } else {\n          previousUserInput = this._previousValue;\n        }\n\n        const caretIndex = this.input.nativeElement.selectionStart;\n        const caretAtEnd = previousUserInput.length === caretIndex;\n        this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);\n\n        if (this.suggestedText) {\n          this.setInputSelection(this.userInput.length, this.suggestedText.length);\n        } else if (caretAtEnd) {\n          this.setInputSelection(this.userInput.length, this.userInput.length);\n        } else {\n          this.setInputSelection(caretIndex, caretIndex);\n        }\n\n        this._previousValue = this.userInput;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n    }\n\n    writeInputValue(text) {\n      if (isDocumentAvailable()) {\n        this.renderer.setProperty(this.input.nativeElement, 'value', text);\n      }\n    }\n\n    setInputSelection(start, end) {\n      if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {\n        try {\n          this.input.nativeElement.setSelectionRange(start, end);\n        } catch (e) {//Make sure that the element is in the DOM before you invoke its methods\n        }\n      }\n    }\n\n    handleInput(event) {\n      const value = event.target.value;\n\n      if (value !== this.userInput) {\n        this._previousValue = value;\n        this.valueChange.emit(value);\n      }\n    }\n\n    handleFocus(event) {\n      this.onFocus.emit(event);\n    }\n\n    handleBlur(event) {\n      this.onBlur.emit(event);\n    }\n\n    handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const keys = [Keys.ArrowUp, Keys.ArrowDown, Keys.ArrowLeft, Keys.ArrowRight, Keys.Enter, Keys.Escape, Keys.Delete, Keys.Backspace, Keys.Home, Keys.End];\n\n      if (keys.indexOf(keyCode) > -1) {\n        this.onNavigate.emit(event);\n      }\n    }\n\n    focus() {\n      if (isDocumentAvailable()) {\n        this.input.nativeElement.focus();\n      }\n    }\n\n    blur() {\n      if (isDocumentAvailable()) {\n        this.input.nativeElement.blur();\n      }\n    }\n\n    setInputSize() {\n      const lengthOf = x => x ? x.length : 0;\n\n      const input = this.input.nativeElement;\n      const placeholderLength = lengthOf(this.placeholder);\n      const textLength = lengthOf(this.value);\n      const size = Math.max(placeholderLength, textLength, 1);\n      this.renderer.setAttribute(input, 'size', size.toString());\n    }\n\n  }\n\n  SearchBarComponent.ɵfac = function SearchBarComponent_Factory(t) {\n    return new (t || SearchBarComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  SearchBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SearchBarComponent,\n    selectors: [[\"kendo-searchbar\"]],\n    viewQuery: function SearchBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function SearchBarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-searchbar\", ctx.searchBarClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      listId: \"listId\",\n      tagListId: \"tagListId\",\n      activeDescendant: \"activeDescendant\",\n      noDataLabel: \"noDataLabel\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      tabIndex: \"tabIndex\",\n      popupOpen: \"popupOpen\",\n      role: \"role\",\n      userInput: \"userInput\",\n      suggestedText: \"suggestedText\",\n      placeholder: \"placeholder\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      onBlur: \"onBlur\",\n      onFocus: \"onFocus\",\n      onClick: \"onClick\",\n      onNavigate: \"onNavigate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 21,\n    consts: [[\"autocomplete\", \"off\", \"aria-haspopup\", \"listbox\", 3, \"id\", \"disabled\", \"readonly\", \"placeholder\", \"kendoEventsOutsideAngular\", \"scope\", \"input\", \"keydown\"], [\"input\", \"\"]],\n    template: function SearchBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"input\", 0, 1);\n        i0.ɵɵlistener(\"input\", function SearchBarComponent_Template_input_input_0_listener($event) {\n          return ctx.handleInput($event);\n        })(\"keydown\", function SearchBarComponent_Template_input_keydown_0_listener($event) {\n          return ctx.handleKeydown($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMap(\"k-input-inner\");\n        i0.ɵɵproperty(\"id\", ctx.id)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"placeholder\", ctx.placeholder)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction2(18, _c1, ctx.handleFocus, ctx.handleBlur))(\"scope\", ctx);\n        i0.ɵɵattribute(\"tabIndex\", ctx.tabIndex)(\"dir\", ctx.direction)(\"role\", ctx.role)(\"aria-disabled\", ctx.disabled)(\"aria-readonly\", ctx.readonly)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-owns\", ctx.listId)(\"aria-describedby\", ctx.tagListId)(\"aria-activedescendant\", ctx.activeDescendant)(\"aria-label\", ctx.noDataLabel);\n      }\n    },\n    directives: [i9.EventsOutsideAngularDirective],\n    encapsulation: 2\n  });\n  return SearchBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the list item content. To define the item template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>ItemTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * - [Using `ItemTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-item-template)\n * - [Using `ItemTemplate` with the ComboBox]({% slug templates_combobox %}#toc-item-template)\n * - [Using `ItemTemplate` with the DropDownList]({% slug templates_ddl %}#toc-item-template)\n * - [Using `ItemTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-item-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet ItemTemplateDirective = /*#__PURE__*/(() => {\n  class ItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ItemTemplateDirective.ɵfac = function ItemTemplateDirective_Factory(t) {\n    return new (t || ItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  ItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ItemTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListItemTemplate\", \"\"], [\"\", \"kendoComboBoxItemTemplate\", \"\"], [\"\", \"kendoAutoCompleteItemTemplate\", \"\"], [\"\", \"kendoMultiSelectItemTemplate\", \"\"]]\n  });\n  return ItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the header content of the list. To define the header template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>HeaderTemplate` directive inside the component tag.\n *\n * - [Using `HeaderTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-header-template)\n * - [Using `HeaderTemplate` with the ComboBox]({% slug templates_combobox %}#toc-header-template)\n * - [Using `HeaderTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-header-template)\n * - [Using `HeaderTemplate` with the DropDownList]({% slug templates_ddl %}#toc-header-template)\n * - [Using `HeaderTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-header-template)\n * - [Using `HeaderTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-header-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxHeaderTemplate>\n *      <h4>Header template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet HeaderTemplateDirective = /*#__PURE__*/(() => {\n  class HeaderTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) {\n    return new (t || HeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  HeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HeaderTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListHeaderTemplate\", \"\"], [\"\", \"kendoComboBoxHeaderTemplate\", \"\"], [\"\", \"kendoDropDownTreeHeaderTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxHeaderTemplate\", \"\"], [\"\", \"kendoAutoCompleteHeaderTemplate\", \"\"], [\"\", \"kendoMultiSelectHeaderTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeHeaderTemplate\", \"\"]]\n  });\n  return HeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the footer content of the list. To define the footer template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FooterTemplate` directive inside the component tag.\n *\n * - [Using `FooterTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-footer-template)\n * - [Using `FooterTemplate` with the ComboBox]({% slug templates_combobox %}#toc-footer-template)\n * - [Using `FooterTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-footer-template)\n * - [Using `FooterTemplate` with the DropDownList]({% slug templates_ddl %}#toc-footer-template)\n * - [Using `FooterTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-footer-template)\n * - [Using `FooterTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-footer-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxFooterTemplate>\n *      <h4>Footer template</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet FooterTemplateDirective = /*#__PURE__*/(() => {\n  class FooterTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) {\n    return new (t || FooterTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  FooterTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FooterTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListFooterTemplate\", \"\"], [\"\", \"kendoComboBoxFooterTemplate\", \"\"], [\"\", \"kendoDropDownTreeFooterTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxFooterTemplate\", \"\"], [\"\", \"kendoAutoCompleteFooterTemplate\", \"\"], [\"\", \"kendoMultiSelectFooterTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeFooterTemplate\", \"\"]]\n  });\n  return FooterTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the group header content. To define the group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>GroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `GroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-group-template)\n * - [Using `GroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-group-template)\n * - [Using `GroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-group-template)\n * - [Using `GroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-group-template)\n * - [Using `GroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-group-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" textField=\"name\" valueField=\"name\">\n *    <ng-template kendoComboBoxGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\n\n\nlet GroupTemplateDirective = /*#__PURE__*/(() => {\n  class GroupTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  GroupTemplateDirective.ɵfac = function GroupTemplateDirective_Factory(t) {\n    return new (t || GroupTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  GroupTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListGroupTemplate\", \"\"], [\"\", \"kendoComboBoxGroupTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxGroupTemplate\", \"\"], [\"\", \"kendoAutoCompleteGroupTemplate\", \"\"], [\"\", \"kendoMultiSelectGroupTemplate\", \"\"]]\n  });\n  return GroupTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the fixed group header content. To define the fixed group template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>FixedGroupTemplate` directive inside the component tag. The template context is\n * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.\n *\n * - [Using `FixedGroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-fixed-group-template)\n * - [Using `FixedGroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-fixed-group-template)\n *\n * @example\n * ```ts\n * import { groupBy } from '@progress/kendo-data-query';\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"groupedData\" textField=\"name\" valueField=\"name\">\n *    <ng-template kendoComboBoxFixedGroupTemplate let-groupName>\n *      <span>Food type: {{groupName}} option</span>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public data = [\n *       { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *       { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *       { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n *   ];\n *   public groupedData = groupBy(this.data, [{field: \"subcategory\"}]);\n * }\n * ```\n */\n\n\nlet FixedGroupTemplateDirective = /*#__PURE__*/(() => {\n  class FixedGroupTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  FixedGroupTemplateDirective.ɵfac = function FixedGroupTemplateDirective_Factory(t) {\n    return new (t || FixedGroupTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  FixedGroupTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FixedGroupTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListFixedGroupTemplate\", \"\"], [\"\", \"kendoComboBoxFixedGroupTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxFixedGroupTemplate\", \"\"], [\"\", \"kendoAutoCompleteFixedGroupTemplate\", \"\"], [\"\", \"kendoMultiSelectFixedGroupTemplate\", \"\"]]\n  });\n  return FixedGroupTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SelectionService = /*#__PURE__*/(() => {\n  class SelectionService {\n    constructor() {\n      this.onSelect = new EventEmitter();\n      this.onChange = new EventEmitter();\n      this.onFocus = new EventEmitter();\n      this.total = 0;\n      this.selectedIndices = [];\n    }\n\n    getTotal() {\n      return this.total;\n    }\n\n    isSelected(index) {\n      return isPresent(this.selectedIndices.find(current => current === index));\n    }\n\n    isFocused(index) {\n      return index === this.focused;\n    }\n\n    focus(index) {\n      if (this.isFocused(index)) {\n        return;\n      }\n\n      this.focused = index;\n      this.onFocus.emit(index);\n    }\n\n    select(index) {\n      if (this.isSelected(index)) {\n        return;\n      }\n\n      this.selectedIndices = [index];\n      this.focused = index;\n      this.onSelect.emit({\n        indices: [index],\n        newSelection: isPresent(index)\n      });\n    }\n\n    add(index) {\n      if (this.isSelected(index)) {\n        return;\n      }\n\n      this.selectedIndices.push(index);\n      this.focused = index;\n      this.onChange.emit({\n        added: index,\n        indices: this.selectedIndices.slice()\n      });\n    }\n\n    unselect(index) {\n      if (!this.isSelected(index)) {\n        return;\n      }\n\n      const position = this.selectedIndices.indexOf(index);\n      this.selectedIndices.splice(position, 1);\n      this.focused = index;\n      this.onChange.emit({\n        indices: this.selectedIndices.slice(),\n        removed: index\n      });\n    }\n\n    change(index) {\n      const newSelection = isPresent(index) && !this.isSelected(index);\n      this.selectedIndices = [index];\n      this.focused = index;\n      this.onChange.emit({\n        indices: [index],\n        newSelection: newSelection\n      });\n    }\n\n    resetSelection(index) {\n      this.selectedIndices = index instanceof Array ? index : [index];\n      this.focused = this.selectedIndices[this.selectedIndices.length - 1];\n    }\n\n    get selected() {\n      return this.selectedIndices.slice();\n    }\n\n    get focused() {\n      return this.focusedIndex;\n    }\n\n    set focused(index) {\n      if (this.focusedIndex !== index) {\n        this.focusedIndex = index;\n        this.onFocus.emit(index);\n      }\n    }\n\n  }\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)();\n  };\n\n  SelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: SelectionService.ɵfac\n  });\n  return SelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar NavigationAction = /*#__PURE__*/(() => {\n  (function (NavigationAction) {\n    // eslint-disable-next-line id-denylist\n    NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n    NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n    NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n    NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n    NavigationAction[NavigationAction[\"Tab\"] = 4] = \"Tab\";\n    NavigationAction[NavigationAction[\"Esc\"] = 5] = \"Esc\";\n    NavigationAction[NavigationAction[\"Delete\"] = 6] = \"Delete\";\n    NavigationAction[NavigationAction[\"Backspace\"] = 7] = \"Backspace\";\n    NavigationAction[NavigationAction[\"Home\"] = 8] = \"Home\";\n    NavigationAction[NavigationAction[\"End\"] = 9] = \"End\";\n    NavigationAction[NavigationAction[\"Up\"] = 10] = \"Up\";\n    NavigationAction[NavigationAction[\"Down\"] = 11] = \"Down\";\n    NavigationAction[NavigationAction[\"Left\"] = 12] = \"Left\";\n    NavigationAction[NavigationAction[\"Right\"] = 13] = \"Right\";\n  })(NavigationAction || (NavigationAction = {}));\n\n  return NavigationAction;\n})();\n\n/**\n * @hidden\n */\nlet DataService = /*#__PURE__*/(() => {\n  class DataService {\n    constructor() {\n      this.grouped = false;\n      this.groupIndices = [];\n    }\n\n    set data(data) {\n      this._data = data;\n      this.grouped = this.isGrouped(data);\n\n      if (this.grouped) {\n        this.groupIndices = this.getGroupIndices(data);\n        this._flatData = this.flatten(data);\n      }\n    }\n\n    get data() {\n      if (this.grouped) {\n        return this._flatData;\n      }\n\n      return this._data;\n    }\n    /**\n     * @hidden\n     * Used to get the actual items count, i.e. excluding the header items in case of grouping.\n     */\n\n\n    get itemsCount() {\n      if (!isPresent(this.data) || this.data.length === 0) {\n        return 0;\n      }\n\n      const items = this.grouped ? this._flatData.filter(item => !item.header) : this.data;\n      return items.length;\n    }\n    /**\n     * @hidden\n     * Used to determine if the component received grouped data.\n     */\n\n\n    isGrouped(data) {\n      // GroupResult { aggregates: AggregateResult, field: string, items: object[], value: any }\n      // https://www.telerik.com/kendo-angular-ui/components/dataquery/api/GroupResult/\n      return isPresent(data) && data.length !== 0 && isPresent(data[0]) && hasProps(data[0], ['aggregates', 'field', 'items', 'value']);\n    }\n    /**\n     * @hidden\n     * Used to calculate the last item index of each group.\n     */\n\n\n    getGroupIndices(data) {\n      let groupIndices = [];\n\n      for (let i = 0; i <= data.length - 1; i++) {\n        groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;\n      }\n\n      return groupIndices;\n    }\n    /**\n     * @hidden\n     * Used to get a flat array containing all items matching certain criteria.\n     */\n\n\n    filter(predicate) {\n      let result = [];\n\n      if (this.isGrouped(this.data)) {\n        for (let i = 0; i <= this.groupIndices.length - 1; i++) {\n          const matches = this.data[i].items.filter(predicate);\n\n          if (matches) {\n            result = result.concat(matches);\n          }\n        }\n      } else {\n        result = this.data.filter(predicate);\n      }\n\n      return result;\n    }\n    /**\n     * @hidden\n     * Used to get the index of a given data item.\n     */\n\n\n    indexOf(item, startFrom = 0) {\n      let predicate = element => {\n        return element === item;\n      };\n\n      if (this.grouped) {\n        predicate = element => {\n          return element.value === item;\n        };\n      }\n\n      return this.findIndex(predicate, startFrom);\n    }\n    /**\n     * @hidden\n     * Used to get the index of a data item based on an expression.\n     */\n\n\n    findIndex(predicate, startFrom = 0) {\n      let index = -1;\n\n      if (this.grouped) {\n        const data = this._flatData.filter(item => !item.header && item.offsetIndex >= startFrom);\n\n        index = data.findIndex(predicate);\n        index = data[index] ? data[index].offsetIndex : -1;\n      } else {\n        const data = this.data.slice(startFrom);\n        const itemIndex = data.findIndex(predicate);\n        index = itemIndex !== -1 ? itemIndex + startFrom : -1;\n      }\n\n      return index;\n    }\n    /**\n     * @hidden\n     * Used to get the closest group header prior to an item index.\n     */\n\n\n    closestGroup(index) {\n      for (let i = index; i >= 0; i--) {\n        if (this._flatData[i].header) {\n          return this._flatData[i];\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Used to get the first item matching the criteria.\n     */\n\n\n    find(predicate) {\n      const index = this.findIndex(predicate);\n      return this.itemAt(index);\n    }\n    /**\n     * @hidden\n     * Used to get the true index in a flattened data array.\n     */\n\n\n    flatIndex(index) {\n      if (this.itemsCount === 0) {\n        return -1;\n      }\n\n      if (this.grouped) {\n        const match = this._flatData.find(item => !item.header && item.offsetIndex === index);\n\n        if (match) {\n          return match.index;\n        }\n      } else {\n        return index;\n      }\n\n      return -1;\n    }\n    /**\n     * @hidden\n     * Used to get the item at the provided index.\n     */\n\n\n    itemAt(index) {\n      let dataItem;\n\n      if (this.itemsCount === 0) {\n        return dataItem;\n      }\n\n      if (this.grouped) {\n        const match = this._flatData.find(item => !item.header && item.offsetIndex === index);\n\n        if (match) {\n          dataItem = match.value;\n        }\n      } else {\n        dataItem = this.data[index];\n      }\n\n      return dataItem;\n    }\n    /**\n     * @hidden\n     * Used to get the group at the provided index.\n     */\n\n\n    groupAt(index) {\n      if (this.itemsCount === 0 || !this.isGrouped) {\n        return;\n      }\n\n      return this._flatData.find(item => item.header && item.index === index);\n    }\n    /**\n     * @hidden\n     * Used to get the field by which the data is grouped.\n     */\n\n\n    groupField() {\n      if (this.itemsCount === 0 || !this.isGrouped) {\n        return null;\n      }\n\n      return this._data[0].field;\n    }\n    /**\n     * @hidden\n     * Used to get the group to which a dataItem belongs.\n     */\n\n\n    itemGroup(item) {\n      if (!item || this.itemsCount === 0 || !this.isGrouped) {\n        return;\n      }\n\n      const fieldName = this.groupField();\n\n      if (fieldName) {\n        return getter(item, fieldName);\n      }\n    }\n\n    flatten(data, group = undefined, offset = 0, groupIndex = 0) {\n      let flat = [];\n\n      if (isPresent(group)) {\n        flat.push({\n          header: true,\n          index: groupIndex + offset,\n          offsetIndex: groupIndex,\n          value: group\n        });\n      }\n\n      for (let i = 0; i < data.length; i++) {\n        let result = [];\n\n        if (data[i].items) {\n          result = this.flatten(data[i].items, data[i].value, offset, i);\n          offset = offset + data[i].items.length;\n        } else {\n          result.push({\n            header: false,\n            index: groupIndex + offset + i + 1,\n            offsetIndex: offset + i,\n            value: data[i]\n          });\n        }\n\n        flat = flat.concat(result);\n      }\n\n      return flat;\n    }\n\n  }\n\n  DataService.ɵfac = function DataService_Factory(t) {\n    return new (t || DataService)();\n  };\n\n  DataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DataService,\n    factory: DataService.ɵfac\n  });\n  return DataService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DisabledItemsService = /*#__PURE__*/(() => {\n  class DisabledItemsService {\n    constructor(dataService) {\n      this.dataService = dataService;\n      this.itemDisabled = null;\n    }\n\n    isIndexDisabled(index) {\n      if (this.itemDisabled) {\n        const item = this.dataService.itemAt(index);\n\n        if (isPresent(item)) {\n          return this.itemDisabled({\n            dataItem: item,\n            index\n          });\n        } else if (isPresent(this.defaultItem)) {\n          return this.itemDisabled({\n            dataItem: this.defaultItem,\n            index: -1\n          });\n        }\n      }\n    }\n\n    isItemDisabled(item) {\n      if (this.itemDisabled) {\n        const index = this.dataService.indexOf(item);\n\n        if (index !== -1) {\n          return this.itemDisabled({\n            dataItem: item,\n            index\n          });\n        } else if (isPresent(this.defaultItem)) {\n          return this.itemDisabled({\n            dataItem: this.defaultItem,\n            index: -1\n          });\n        }\n      }\n    }\n\n  }\n\n  DisabledItemsService.ɵfac = function DisabledItemsService_Factory(t) {\n    return new (t || DisabledItemsService)(i0.ɵɵinject(DataService));\n  };\n\n  DisabledItemsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DisabledItemsService,\n    factory: DisabledItemsService.ɵfac\n  });\n  return DisabledItemsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MIN_INDEX = 0;\n/**\n * @hidden\n */\n\nclass NavigationEvent {\n  /**\n   * The index of the item to which the user navigated.\n   */\n  constructor(index, originalEvent) {\n    this.index = index;\n    this.originalEvent = originalEvent;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(disabledItemsService, selectionService) {\n      this.disabledItemsService = disabledItemsService;\n      this.selectionService = selectionService;\n      this.open = new EventEmitter();\n      this.close = new EventEmitter();\n      this.enter = new EventEmitter();\n      this.tab = new EventEmitter();\n      this.esc = new EventEmitter();\n      this.up = new EventEmitter();\n      this.right = new EventEmitter();\n      this.down = new EventEmitter();\n      this.left = new EventEmitter();\n      this.delete = new EventEmitter();\n      this.backspace = new EventEmitter();\n      this.home = new EventEmitter();\n      this.end = new EventEmitter();\n    }\n\n    process(args) {\n      const keyCode = args.originalEvent.keyCode;\n      const altKey = args.originalEvent.altKey;\n      let index;\n      let action = NavigationAction.Undefined;\n\n      if (altKey && keyCode === Keys.ArrowDown) {\n        action = NavigationAction.Open;\n      } else if (altKey && keyCode === Keys.ArrowUp) {\n        action = NavigationAction.Close;\n      } else if (keyCode === Keys.Enter) {\n        action = NavigationAction.Enter;\n      } else if (keyCode === Keys.Escape) {\n        action = NavigationAction.Esc;\n      } else if (keyCode === Keys.Tab) {\n        action = NavigationAction.Tab;\n      } else if (keyCode === Keys.ArrowUp) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: -1\n        });\n        action = NavigationAction.Up;\n      } else if (keyCode === Keys.ArrowLeft) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: -1\n        });\n        action = NavigationAction.Left;\n      } else if (keyCode === Keys.ArrowDown) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: 1\n        });\n        action = NavigationAction.Down;\n      } else if (keyCode === Keys.ArrowRight) {\n        index = this.next({\n          current: args.current,\n          start: args.min,\n          end: args.max,\n          step: 1\n        });\n        action = NavigationAction.Right;\n      } else if (keyCode === Keys.Home) {\n        index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;\n        action = NavigationAction.Home;\n      } else if (keyCode === Keys.End) {\n        index = this.isDisabled(args.max) ? args.current : args.max;\n        action = NavigationAction.End;\n      } else if (keyCode === Keys.Delete) {\n        action = NavigationAction.Delete;\n      } else if (keyCode === Keys.Backspace) {\n        action = NavigationAction.Backspace;\n      }\n\n      const eventData = new NavigationEvent(index, args.originalEvent);\n\n      if (action !== NavigationAction.Undefined) {\n        this[NavigationAction[action].toLowerCase()].emit(eventData);\n      }\n\n      return action;\n    }\n\n    next(args) {\n      const {\n        current,\n        start,\n        end,\n        step\n      } = args;\n      const nextIndex = !isPresent(current) ? start : this.clampIndex(current + step, start, end);\n      const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);\n\n      if (isPresent(firstFocusableIndex)) {\n        return firstFocusableIndex;\n      }\n\n      if (this.selectionService.isSelected(current) && current >= start) {\n        return current;\n      }\n\n      const inversedStep = -1 * step;\n      return this.firstFocusableIndex(nextIndex, start, end, inversedStep);\n    }\n\n    clampIndex(index, min, max) {\n      if (!isPresent(index) || index < min) {\n        return min;\n      }\n\n      if (index > max) {\n        return max;\n      }\n\n      return index;\n    }\n\n    firstFocusableIndex(startIndex, min, max, step) {\n      while (min <= startIndex && startIndex <= max) {\n        if (!this.isDisabled(startIndex)) {\n          return startIndex;\n        }\n\n        startIndex += step;\n      }\n\n      return undefined;\n    }\n\n    isDisabled(index) {\n      if (this.disabledItemsService) {\n        return this.disabledItemsService.isIndexDisabled(index);\n      }\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(DisabledItemsService), i0.ɵɵinject(SelectionService));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders content when no data is available. To define the no-data template, nest a `<ng-template>` tag\n * with the `kendo<ComponentName>NoDataTemplate` directive inside the component tag.\n *\n * - [Using `NoDataTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the ComboBox]({% slug templates_combobox %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the DropDownList]({% slug templates_ddl %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-no-data-template)\n * - [Using `NoDataTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-no-data-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *    <ng-template kendoComboBoxNoDataTemplate>\n *      <h4>No data!</h4>\n *    </ng-template>\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [];\n * }\n * ```\n */\n\n\nlet NoDataTemplateDirective = /*#__PURE__*/(() => {\n  class NoDataTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  NoDataTemplateDirective.ɵfac = function NoDataTemplateDirective_Factory(t) {\n    return new (t || NoDataTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  NoDataTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NoDataTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListNoDataTemplate\", \"\"], [\"\", \"kendoDropDownTreeNoDataTemplate\", \"\"], [\"\", \"kendoComboBoxNoDataTemplate\", \"\"], [\"\", \"kendoMultiColumnComboBoxNoDataTemplate\", \"\"], [\"\", \"kendoAutoCompleteNoDataTemplate\", \"\"], [\"\", \"kendoMultiSelectNoDataTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeNoDataTemplate\", \"\"]]\n  });\n  return NoDataTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Defines the mandatory properties of the `kendoDropDownFilter` directive\n * so that `kendoDropDownFilter` can be used with any of the DropDowns components\n * which implement the `FilterableDropDownComponentBase` class.\n *\n * @hidden\n */\n\n\nclass FilterableComponent {}\n/**\n * @hidden\n */\n\n\nconst DEFAULTS = {\n  pageSize: 50,\n  itemHeight: 28\n};\n/**\n * @hidden\n */\n\nconst normalizeVirtualizationSettings = (settings, defaultOverrides) => {\n  const defaults = Object.assign({}, DEFAULTS, defaultOverrides);\n\n  if (settings === true) {\n    return defaults;\n  }\n\n  if (!settings) {\n    return null;\n  }\n\n  return Object.assign({\n    pageSize: DEFAULTS.pageSize\n  }, settings);\n};\n/**\n * @hidden\n */\n\n\nconst TOUCH_ENABLED = new InjectionToken('dropdowns-touch-enabled');\n/**\n * @hidden\n */\n\nlet ListItemDirective = /*#__PURE__*/(() => {\n  class ListItemDirective {\n    constructor(element) {\n      this.element = element;\n    }\n\n  }\n\n  ListItemDirective.ɵfac = function ListItemDirective_Factory(t) {\n    return new (t || ListItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  ListItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ListItemDirective,\n    selectors: [[\"li\", \"role\", \"option\"], [\"li\", \"role\", \"group\"]]\n  });\n  return ListItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet TemplateContextDirective = /*#__PURE__*/(() => {\n  class TemplateContextDirective {\n    constructor(viewContainerRef) {\n      this.viewContainerRef = viewContainerRef;\n    }\n\n    set templateContext(context) {\n      if (this.insertedViewRef) {\n        this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n        this.insertedViewRef = undefined;\n      }\n\n      if (context.templateRef) {\n        this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n      }\n    }\n\n  }\n\n  TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) {\n    return new (t || TemplateContextDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  TemplateContextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateContextDirective,\n    selectors: [[\"\", \"templateContext\", \"\"]],\n    inputs: {\n      templateContext: \"templateContext\"\n    }\n  });\n  return TemplateContextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SelectableDirective = /*#__PURE__*/(() => {\n  class SelectableDirective {\n    constructor(selectionService) {\n      this.checkboxes = {\n        enabled: false\n      }; // @HostBinding('attr.offset-index')\n      // @Input() public offsetIndex: number;\n\n      this.multipleSelection = false;\n      this.selectionService = selectionService;\n    }\n\n    get focusedClassName() {\n      return this.selectionService.isFocused(this.index);\n    }\n\n    get selectedClassName() {\n      return !this.checkboxes.enabled && this.selectionService.isSelected(this.index);\n    }\n\n    onClick(event) {\n      event.stopPropagation();\n\n      if (this.checkboxes.enabled && !this.checkboxes.checkOnClick) {\n        return;\n      }\n\n      if (this.multipleSelection) {\n        if (this.selectionService.isSelected(this.index)) {\n          this.selectionService.unselect(this.index);\n        } else {\n          this.selectionService.add(this.index);\n        }\n      } else {\n        this.selectionService.change(this.index);\n      }\n    }\n\n  }\n\n  SelectableDirective.ɵfac = function SelectableDirective_Factory(t) {\n    return new (t || SelectableDirective)(i0.ɵɵdirectiveInject(SelectionService));\n  };\n\n  SelectableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectableDirective,\n    selectors: [[\"\", \"kendoDropDownsSelectable\", \"\"]],\n    hostVars: 9,\n    hostBindings: function SelectableDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function SelectableDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"index\", ctx.index);\n        i0.ɵɵstyleProp(\"height\", ctx.height, \"px\")(\"min-height\", ctx.height, \"px\");\n        i0.ɵɵclassProp(\"k-focus\", ctx.focusedClassName)(\"k-selected\", ctx.selectedClassName);\n      }\n    },\n    inputs: {\n      index: \"index\",\n      checkboxes: \"checkboxes\",\n      height: \"height\",\n      multipleSelection: \"multipleSelection\"\n    }\n  });\n  return SelectableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ListComponent = /*#__PURE__*/(() => {\n  class ListComponent {\n    /* tslint:disable:member-ordering */\n    constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {\n      this.dataService = dataService;\n      this.wrapper = wrapper;\n      this.selectionService = selectionService;\n      this.disabledItemsService = disabledItemsService;\n      this.cdr = cdr;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.selected = [];\n      this.focused = -1;\n      this.show = true;\n      this.multipleSelection = false;\n      this.type = 'list';\n      this.checkboxes = {\n        enabled: false\n      };\n      this.rounded = 'medium';\n      this.onClick = new EventEmitter();\n      this.pageChange = new EventEmitter();\n      this.listResize = new EventEmitter();\n      this.startFrom = 0;\n      this.lastLoaded = 0;\n      this.lastScrollTop = 0;\n      this.scrollToFocused = false;\n      this._size = 'medium';\n      this.selectSubscription = merge(this.selectionService.onSelect.pipe(map(args => args.indices[0])), this.selectionService.onFocus).pipe( // handle only the very last onSelect/onFocus emission\n      switchMap(event => this.zone.onStable.pipe(take(1), map(() => event)))).subscribe(this.scrollToItem.bind(this));\n      this.prepareClasses();\n    }\n\n    set data(data) {\n      this._data = data[0] && data[0].header ? data.slice(0) : data;\n    }\n\n    get data() {\n      return this._data;\n    }\n\n    set size(size) {\n      if (this.type === 'list') {\n        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('list', this.size));\n\n        if (size) {\n          this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('list', size));\n        }\n\n        this._size = size;\n      }\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    get pageSize() {\n      if (this.virtual.pageSize) {\n        return this.virtual.pageSize;\n      }\n\n      let size = Math.round(this.height / this.virtual.itemHeight);\n      return size;\n    }\n\n    get scrollHeight() {\n      return (this.dataService.grouped ? this.virtual.total - 1 : this.virtual.total) * this.virtual.itemHeight;\n    }\n\n    get overflowY() {\n      if (isPresent(this.virtual)) {\n        const overflow = this.hasVirtualScrollbar() ? 'scroll' : 'hidden';\n        return overflow;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get checkboxClasses() {\n      return `${this.size ? getSizeClass('checkbox', this.size) : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('data', changes, false)) {\n        if (this.lastLoaded <= 0) {\n          this.lastLoaded = this.data.length - 1;\n          this.scrollToFocused = !changes.data.isFirstChange();\n        }\n\n        this.setOverflow();\n      }\n\n      if (isChanged('virtual', changes, false)) {\n        this.setOverflow();\n      }\n\n      if (isChanged('type', changes, false)) {\n        this.prepareClasses();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setComponentClasses();\n      this.zone.runOutsideAngular(() => {\n        this.scrollSubscription = fromEvent(this.content.nativeElement, \"scroll\").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {\n          this.lastScrollTop = this.content.nativeElement.scrollTop;\n        });\n      });\n      this.setOverflow();\n    }\n\n    ngAfterViewChecked() {\n      if (this.virtual) {\n        this.positionItems();\n      }\n\n      if (this.items && this.scrollToFocused) {\n        this.scrollToFocused = false;\n        const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;\n        this.scrollToItem(scrollTarget);\n      }\n\n      if (this.dataService.grouped) {\n        this.findCurrentGroup();\n      }\n    }\n\n    ngOnDestroy() {\n      this.selectSubscription.unsubscribe();\n\n      if (this.scrollSubscription) {\n        this.scrollSubscription.unsubscribe();\n      }\n    }\n\n    onCheckedChange(e, index) {\n      const isChecked = e.target['checked'];\n\n      if (isChecked && !this.selectionService.isSelected(index)) {\n        this.selectionService.add(index);\n      }\n\n      if (!isChecked && this.selectionService.isSelected(index)) {\n        this.selectionService.unselect(index);\n      }\n    }\n\n    prepareClasses() {\n      if (this.type === 'list') {\n        this.listContentClass = 'k-list-content';\n        this.listClass = 'k-list-ul';\n        this.listItemClass = 'k-list-item';\n        this.listVirtualClass = 'k-virtual-list';\n        this.listGroupStickyHeaderClass = 'k-list-group-sticky-header';\n        this.listGroupStickyHeaderTextClass = 'k-list-header-text';\n        this.listGroupItemClass = 'k-list-group-item';\n        this.listGroupItemTextClass = 'k-list-item-text';\n      } else {\n        this.listContentClass = 'k-table-body k-table-scroller';\n        this.listClass = 'k-table k-table-list';\n        this.listItemClass = 'k-table-row';\n        this.listVirtualClass = 'k-virtual-table';\n        this.listGroupStickyHeaderClass = 'k-table-group-sticky-header';\n        this.listGroupStickyHeaderTextClass = 'k-table-th';\n        this.listGroupItemClass = 'k-table-group-row';\n        this.listGroupItemTextClass = 'k-table-th';\n      }\n    }\n\n    isChecked(index) {\n      const normalizedIndex = this.virtual ? index + this.virtual.skip : index;\n      return this.selectionService.isSelected(normalizedIndex);\n    }\n\n    firstVisibleItem() {\n      const content = this.content.nativeElement;\n      const rect = content.getBoundingClientRect(); // IE9 hack\n\n      const disabled = Array.prototype.slice.call(content.querySelectorAll(\".k-disabled\")); // This is a workaround for finding elements with pointer-events: none;\n\n      disabled.forEach(el => this.renderer.setStyle(el, \"pointer-events\", \"auto\"));\n      const item = document.elementFromPoint(rect.left + 1, rect.top + 1);\n      disabled.forEach(el => this.renderer.setStyle(el, \"pointer-events\", \"none\")); // return the closest `li` item to cover the custom template scenario\n\n      return closest(item, 'li');\n    }\n\n    findCurrentGroup() {\n      if (!this.dataService.grouped) {\n        this.currentGroup = undefined;\n        return;\n      }\n\n      const item = this.firstVisibleItem();\n\n      if (item) {\n        let index;\n\n        if (item.getAttribute(\"role\") === \"group\") {\n          index = parseInt(item.getAttribute(\"group-index\"), 10);\n          this.currentGroup = this.dataService.groupAt(index).value;\n        } else {\n          index = parseInt(item.getAttribute(\"index\"), 10);\n          this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));\n        }\n      } else {\n        this.currentGroup = undefined;\n      }\n\n      this.cdr.detectChanges();\n    }\n\n    prefetchData() {\n      if (!this.virtual) {\n        return;\n      }\n\n      const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);\n      const offsetY = this.content.nativeElement.scrollTop;\n      const start = Math.trunc(offsetY / this.virtual.itemHeight);\n      const down = offsetY > this.lastScrollTop;\n      const nextPage = start + visibleItems >= this.lastLoaded && this.lastLoaded < this.virtual.total - 1;\n      const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);\n      const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;\n\n      if (down && nextPage) {\n        this.changePage(start);\n      }\n\n      if (!down && prevPage) {\n        this.changePage(start - this.pageSize + visibleItems + 1);\n      }\n    }\n\n    changePage(start) {\n      this.zone.run(() => {\n        let end = this.pageSize + start;\n\n        if (end > this.virtual.total) {\n          start--;\n          end = this.virtual.total;\n        }\n\n        if (start < 0) {\n          start = 0;\n        }\n\n        this.startFrom = start;\n        this.lastLoaded = end;\n        this.pageChange.emit({\n          skip: start,\n          take: this.pageSize\n        });\n      });\n    }\n\n    index(groupIndex, itemIndex) {\n      return groupIndex > 0 ? this.dataService.groupIndices[groupIndex - 1] + itemIndex : itemIndex;\n    }\n\n    getText(dataItem) {\n      return getter(dataItem, this.textField);\n    }\n\n    getValue(dataItem) {\n      return getter(dataItem, this.valueField);\n    }\n\n    isDisabled(index) {\n      if (isPresent(this.virtual)) {\n        index += this.virtual.skip;\n      }\n\n      return this.disabledItemsService.isIndexDisabled(index);\n    }\n\n    isAltRow(index) {\n      return this.type === 'dropdowngrid' && index % 2 !== 0;\n    }\n\n    scrollToItem(index) {\n      let flatIndex = index;\n\n      if (this.dataService.grouped) {\n        // takes into account the group header items\n        flatIndex = this.dataService.flatIndex(index);\n        /* The first group header item is not rendered in the list (see template), so subtract 1 when calulating the flat index.\n           With virtualization enabled, the first group header could be in a previous page, in which case don't subtract anything. */\n\n        const groupHeaderOffset = this.firstGroupHeaderInTargetedPage(flatIndex) ? -1 : 0;\n        flatIndex += groupHeaderOffset;\n      }\n\n      if (this.virtual && flatIndex > -1) {\n        this.scrollToIndex(flatIndex);\n        return;\n      }\n\n      const items = this.items.toArray();\n\n      if (isPresent(items[flatIndex]) && flatIndex !== -1) {\n        this.scroll(items[flatIndex].element);\n      }\n    }\n\n    scrollToIndex(index) {\n      let content = this.content.nativeElement;\n      let contentScrollTop = content.scrollTop;\n      const itemOffsetTop = index * this.virtual.itemHeight;\n      const itemOffsetHeight = this.virtual.itemHeight;\n      const contentOffsetHeight = content.clientHeight;\n      const bottomDistance = itemOffsetTop + itemOffsetHeight;\n\n      if (contentScrollTop > itemOffsetTop) {\n        contentScrollTop = itemOffsetTop;\n      } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {\n        contentScrollTop = bottomDistance - contentOffsetHeight;\n      }\n\n      content.scrollTop = contentScrollTop;\n    }\n\n    scroll(item) {\n      if (!item) {\n        return;\n      }\n\n      const nativeElement = item.nativeElement;\n      let content = this.content.nativeElement,\n          itemOffsetTop = nativeElement.offsetTop,\n          itemOffsetHeight = nativeElement.offsetHeight,\n          contentScrollTop = content.scrollTop,\n          contentOffsetHeight = content.clientHeight,\n          bottomDistance = itemOffsetTop + itemOffsetHeight;\n\n      if (contentScrollTop > itemOffsetTop) {\n        contentScrollTop = itemOffsetTop;\n      } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {\n        contentScrollTop = bottomDistance - contentOffsetHeight;\n      }\n\n      content.scrollTop = contentScrollTop;\n    }\n    /**\n     * Indicates whether a scrollbar is currently rendered in the list.\n     */\n\n\n    hasScrollbar() {\n      if (!(isPresent(this.items) && this.items.length && isPresent(this.list) && isPresent(this.content))) {\n        return false;\n      }\n\n      const hasVirtualScroll = isPresent(this.virtual) && this.hasVirtualScrollbar();\n      return hasVirtualScroll || this.list.nativeElement.scrollHeight > this.content.nativeElement.offsetHeight;\n    }\n    /**\n     * Sets the list's content overflow (hides/shows scrollbar)\n     */\n\n\n    setOverflow() {\n      if (this.virtual) {\n        const overflow = this.hasVirtualScrollbar() ? 'scroll' : 'hidden';\n        this.renderer.setStyle(this.content.nativeElement, 'overflow-y', overflow);\n      }\n    }\n    /**\n     * Indicates whether the scrollbar should be visible in virtual mode.\n     */\n\n\n    hasVirtualScrollbar() {\n      const contentOffsetHeight = this.content.nativeElement.offsetHeight;\n      const virtualOffsetHeight = this.virtualContainer && this.virtualContainer.nativeElement.offsetHeight;\n      return this.virtualContainer && virtualOffsetHeight > contentOffsetHeight;\n    }\n\n    positionItems() {\n      this.items.forEach((item, index) => {\n        const offsetY = (index + this.startFrom) * this.virtual.itemHeight;\n        this.renderer.setStyle(item.element.nativeElement, \"transform\", `translateY(${offsetY}px`);\n      });\n    }\n    /**\n     * Indicates whether the first group header from the data set is in the targeted virtual page.\n     */\n\n\n    firstGroupHeaderInTargetedPage(itemIndex) {\n      if (!isPresent(this.virtual)) {\n        return true;\n      }\n\n      return this.virtual.skip === 0 && this.virtual.pageSize > itemIndex;\n    }\n\n    setComponentClasses() {\n      if (this.type === 'list') {\n        this.renderer.addClass(this.wrapper.nativeElement, 'k-list');\n\n        if (this.size) {\n          this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('list', this.size));\n        }\n      }\n\n      if (isPresent(this.virtual)) {\n        this.renderer.addClass(this.wrapper.nativeElement, this.listVirtualClass);\n      }\n    }\n\n  }\n\n  ListComponent.ɵfac = function ListComponent_Factory(t) {\n    return new (t || ListComponent)(i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  ListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ListComponent,\n    selectors: [[\"kendo-list\"]],\n    viewQuery: function ListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c2, 7);\n        i0.ɵɵviewQuery(_c3, 7);\n        i0.ɵɵviewQuery(_c4, 5);\n        i0.ɵɵviewQuery(ListItemDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    inputs: {\n      selected: \"selected\",\n      focused: \"focused\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      height: \"height\",\n      template: \"template\",\n      groupTemplate: \"groupTemplate\",\n      fixedGroupTemplate: \"fixedGroupTemplate\",\n      show: \"show\",\n      id: \"id\",\n      optionPrefix: \"optionPrefix\",\n      multipleSelection: \"multipleSelection\",\n      virtual: \"virtual\",\n      type: \"type\",\n      checkboxes: \"checkboxes\",\n      data: \"data\",\n      size: \"size\",\n      rounded: \"rounded\"\n    },\n    outputs: {\n      onClick: \"onClick\",\n      pageChange: \"pageChange\",\n      listResize: \"listResize\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 15,\n    consts: [[3, \"class\", \"ngStyle\", 4, \"ngIf\"], [\"unselectable\", \"on\"], [\"content\", \"\"], [\"role\", \"listbox\"], [\"list\", \"\"], [4, \"ngIf\"], [3, \"resize\", 4, \"ngIf\"], [\"class\", \"k-height-container\", \"role\", \"presentation\", 4, \"ngIf\"], [3, \"ngStyle\"], [3, \"ngIf\"], [3, \"templateContext\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"checkboxes\", \"height\", \"index\", \"multipleSelection\", \"ngClass\"], [\"type\", \"checkbox\", \"class\", \"k-checkbox\", 3, \"ngClass\", \"checked\", \"change\", 4, \"ngIf\"], [\"type\", \"checkbox\", 1, \"k-checkbox\", 3, \"ngClass\", \"checked\", \"change\"], [1, \"k-list-item-text\"], [\"role\", \"group\", 3, \"class\", \"k-table-alt-row\", \"ngStyle\", 4, \"ngIf\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"height\", \"index\", \"multipleSelection\", \"class\", \"ngClass\", 4, \"ngIf\"], [\"role\", \"group\", 3, \"ngStyle\"], [\"role\", \"option\", \"kendoDropDownsSelectable\", \"\", 3, \"height\", \"index\", \"multipleSelection\", \"ngClass\"], [3, \"resize\"], [\"role\", \"presentation\", 1, \"k-height-container\"], [\"virtualContainer\", \"\"]],\n    template: function ListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ListComponent_div_0_Template, 3, 9, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"ul\", 3, 4);\n        i0.ɵɵtemplate(5, ListComponent_5_Template, 1, 1, null, 5);\n        i0.ɵɵtemplate(6, ListComponent_6_Template, 1, 1, null, 5);\n        i0.ɵɵtemplate(7, ListComponent_kendo_resize_sensor_7_Template, 1, 0, \"kendo-resize-sensor\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, ListComponent_div_8_Template, 4, 2, \"div\", 7);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.dataService.grouped);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMap(ctx.listContentClass);\n        i0.ɵɵstyleProp(\"overscroll-behavior\", \"none\")(\"max-height\", ctx.height, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassMap(ctx.listClass);\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-hidden\", !ctx.show);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.dataService.grouped && ctx.show);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.dataService.grouped);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.virtual);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.virtual);\n      }\n    },\n    directives: [i9.ResizeSensorComponent, i11.NgIf, i11.NgStyle, TemplateContextDirective, i11.NgForOf, ListItemDirective, SelectableDirective, i11.NgClass],\n    encapsulation: 2\n  });\n  return ListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet Messages = /*#__PURE__*/(() => {\n  class Messages extends ComponentMessages {}\n\n  Messages.ɵfac = /* @__PURE__ */function () {\n    let ɵMessages_BaseFactory;\n    return function Messages_Factory(t) {\n      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = i0.ɵɵgetInheritedFactory(Messages)))(t || Messages);\n    };\n  }();\n\n  Messages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Messages,\n    inputs: {\n      noDataText: \"noDataText\",\n      clearTitle: \"clearTitle\",\n      checkAllText: \"checkAllText\",\n      selectButtonText: \"selectButtonText\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return Messages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedMessagesDirective extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {\n    return new (t || LocalizedMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedMessagesDirective,\n    selectors: [[\"\", \"kendoDropDownListLocalizedMessages\", \"\"], [\"\", \"kendoDropDownTreeLocalizedMessages\", \"\"], [\"\", \"kendoComboBoxLocalizedMessages\", \"\"], [\"\", \"kendoMultiColumnComboBoxLocalizedMessages\", \"\"], [\"\", \"kendoAutoCompleteLocalizedMessages\", \"\"], [\"\", \"kendoMultiSelectLocalizedMessages\", \"\"], [\"\", \"kendoMultiSelectTreeLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => LocalizedMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NO_VALUE = \"\";\nconst DEFAULT_SIZE$5 = 'medium';\nconst DEFAULT_ROUNDED$5 = 'medium';\nconst DEFAULT_FILL_MODE$5 = 'solid';\n/**\n * @hidden\n */\n\nconst AUTOCOMPLETE_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => AutoCompleteComponent)\n};\n/**\n * Represents the [Kendo UI AutoComplete component for Angular]({% slug overview_autocomplete %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"listItems\"\n *      [placeholder]=\"placeholder\"\n *  >\n * `\n * })\n * class AppComponent {\n *   public placeholder: string = 'Type \"it\" for suggestions';\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\nlet AutoCompleteComponent = /*#__PURE__*/(() => {\n  class AutoCompleteComponent {\n    constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, hostElement, touchEnabled) {\n      this.localization = localization;\n      this.dataService = dataService;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this._zone = _zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.touchEnabled = touchEnabled;\n      /**\n       * Defines whether the first match from the suggestions list will be automatically focused.\n       * By default, `highlightFirst` is set to `true`.\n       */\n\n      this.highlightFirst = true;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n\n      this.placeholder = \"\";\n      /**\n       * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * @hidden\n       *\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n\n      this.clearButton = true;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.\n       * If set to `true`, the component emits the `filterChange` event.\n       */\n\n      this.filterable = false;\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example]({% slug overview_autocomplete %}#toc-events)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value\n       * ([see example]({% slug overview_autocomplete %}#toc-events)).\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires each time the user focuses the AutoComplete.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the AutoComplete gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      this.widgetClasses = true;\n      this.listBoxId = guid();\n      this.optionPrefix = guid();\n      this.onChangeCallback = noop;\n      this.onTouchedCallback = noop;\n\n      this.popupMouseDownHandler = event => event.preventDefault();\n\n      this._popupSettings = {\n        animate: true\n      };\n      this._open = false;\n      this._value = \"\";\n      this.valueChangeSubject = new Subject();\n      this._isFocused = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.wrapper = this.hostElement.nativeElement;\n      this.data = [];\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.selectionService.resetSelection([-1]);\n    }\n\n    get width() {\n      let wrapperOffsetWidth = 0;\n\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.offsetWidth;\n      }\n\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-reset'];\n\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n\n      return containerClasses;\n    }\n\n    get suggestion() {\n      if (!this.text || !this.suggestedText) {\n        this.suggestedText = undefined;\n        return;\n      }\n\n      const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());\n      const shouldSuggest = this.suggest && !this.backspacePressed;\n\n      if (shouldSuggest && hasMatch) {\n        return this.suggestedText;\n      }\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    get clearButtonVisiblity() {\n      if (this.touchEnabled) {\n        return 'visible';\n      }\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n\n        this._toggle(shouldOpen);\n      });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n\n    get activeDescendant() {\n      if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n        return null;\n      }\n\n      const dataItem = this.dataService.itemAt(this.selectionService.focused);\n      return this.optionPrefix + \"-\" + getter(dataItem, this.valueField);\n    }\n\n    get noDataLabel() {\n      if (this.data.length === 0) {\n        return this.messageFor('noDataText');\n      }\n    }\n    /**\n     * Sets the data of the AutoComplete.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n\n\n    set data(data) {\n      this.dataService.data = data || [];\n\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      if (this.filterable) {\n        this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;\n      }\n\n      if (this.suggest && this.dataService.itemsCount > 0) {\n        this.suggestedText = getter(this.dataService.itemAt(0), this.valueField);\n      }\n    }\n\n    get data() {\n      const virtual = this.virtual;\n\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize; // Use length instead of itemsCount because of the grouping.\n\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the AutoComplete.\n     */\n\n\n    set value(newValue) {\n      this.verifySettings(newValue);\n      this._value = newValue || NO_VALUE;\n      this.text = this.value;\n      this.cdr.markForCheck();\n    }\n\n    get value() {\n      return this._value || NO_VALUE;\n    }\n    /**\n     * Configures the popup of the AutoComplete.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_autocomplete %})).\n     * Determines whether the item will be disabled.\n     */\n\n\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.\n     */\n\n\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$5;\n      this.renderer.removeClass(this.wrapper, getSizeClass('input', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;\n      this.renderer.removeClass(this.wrapper, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$5;\n      this.renderer.removeClass(this.wrapper, getFillModeClass('input', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper, getFillModeClass('input', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper, \"k-focus\");\n      this._isFocused = isFocused;\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n      this.localizationChangeSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      });\n      this.setComponentClasses();\n    }\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n    }\n\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n    }\n    /**\n     * Resets the value of the AutoComplete.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n\n\n    reset() {\n      this.value = NO_VALUE;\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearValue(event) {\n      event.stopImmediatePropagation();\n      this.focus();\n      this.change(NO_VALUE);\n\n      if (this.filterable) {\n        this.filterChange.emit('');\n      }\n\n      this.selectionService.resetSelection([]);\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * Focuses a specific item of the AutoComplete based on a provided index.\n     * If null or invalid index is provided the focus will be removed.\n     */\n\n\n    focusItemAt(index) {\n      const isInRange = index >= 0 && index < this.data.length;\n\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(-1);\n      }\n    }\n    /**\n     * Focuses the AutoComplete.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * Blurs the AutoComplete.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (this._open) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n\n    emitChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n\n    verifySettings(newValue) {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (isPresent(newValue) && typeof newValue !== \"string\") {\n        throw new Error(\"Expected value of type string. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/value-binding/\");\n      }\n    }\n\n    search(text, startFrom = 0) {\n      let index;\n\n      if (text.length && this.dataService.itemsCount) {\n        index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);\n      } else {\n        index = -1;\n      }\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        if (index + 1 < this.dataService.itemsCount) {\n          this.search(text, index + 1);\n        } else {\n          this.selectionService.focus(-1);\n        }\n      } else {\n        this.selectionService.focus(index);\n\n        if (this.suggest) {\n          this.suggestedText = getter(this.dataService.itemAt(index), this.valueField);\n        }\n      }\n    }\n\n    navigate(index) {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.selectionService.focus(index);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigate(event) {\n      const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n\n      if (this.disabled || this.readonly || isNaN(focused)) {\n        return;\n      }\n\n      const action = this.navigationService.process({\n        current: focused,\n        max: this.dataService.itemsCount - 1,\n        min: 0,\n        originalEvent: event\n      });\n\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.Home && action !== NavigationAction.End && action !== NavigationAction.Left && action !== NavigationAction.Right && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {\n        event.preventDefault();\n      }\n    }\n\n    handleEnter(event) {\n      const focused = this.selectionService.focused;\n      let value;\n\n      if (this.isOpen) {\n        event.originalEvent.preventDefault();\n      }\n\n      if (focused >= 0) {\n        value = getter(this.dataService.itemAt(focused), this.valueField);\n      } else {\n        const match = this.suggest && this.suggestedText && this.data.length && getter(this.dataService.itemAt(0), this.valueField).toLowerCase() === this.searchbar.value.toLowerCase();\n\n        if (this.isOpen && match) {\n          value = this.suggestedText;\n        } else {\n          value = this.searchbar.value;\n        }\n      }\n\n      this.change(value);\n    }\n\n    handleEscape() {\n      this.togglePopup(false);\n      this.selectionService.focused = -1;\n      this.suggestedText = null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    searchBarChange(text) {\n      const currentTextLength = isPresent(this.text) ? this.text.length : 0;\n      this.backspacePressed = text.length < currentTextLength ? true : false;\n      this.text = text;\n      this.togglePopup(text.length > 0);\n\n      if (!this.highlightFirst) {\n        this.selectionService.focused = -1;\n      }\n\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      } else if (this.highlightFirst) {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      this.isFocused = true;\n\n      if (hasObservers(this.onFocus)) {\n        this._zone.run(() => {\n          this.onFocus.emit();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur() {\n      const focused = this.filterable ? this.selectionService.focused : -1;\n      this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers\n\n      let dataItem;\n      let text;\n\n      if (focused !== -1) {\n        dataItem = this.dataService.itemAt(focused);\n        text = getter(dataItem, this.valueField) || \"\";\n      } else {\n        text = this.searchbar.value;\n      }\n\n      const exactMatch = text === this.searchbar.value;\n      const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();\n\n      if (!exactMatch && insensitiveMatch) {\n        this.selectionService.resetSelection([]);\n      }\n\n      this.isFocused = false;\n      const valueHasChanged = this.value !== this.text;\n      const runInZone = hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper) || valueHasChanged;\n\n      if (runInZone) {\n        this._zone.run(() => {\n          if (valueHasChanged) {\n            this.change(this.searchbar.value);\n          }\n\n          this.onBlur.emit();\n          this.onTouchedCallback();\n          this.togglePopup(false);\n        });\n      } else {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n\n    change(value) {\n      this.togglePopup(false);\n      this.valueChangeSubject.next(value);\n    }\n\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.valueChangeSubscription = this.valueChangeSubject.subscribe(value => {\n        const hasChange = this.value !== value;\n        this.value = value;\n        this.text = value; // emit change after assigning `this.value` => allows the user to modify the component value on `valueChange`\n\n        if (hasChange) {\n          this.emitChange(value);\n        }\n      });\n      this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));\n      this.focusSubscription = this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this));\n      this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down).subscribe(event => this.navigate(event.index));\n      this.closeSubscription = this.navigationService.close.subscribe(() => this.togglePopup(false));\n      this.enterSubscription = this.navigationService.enter.subscribe(this.handleEnter.bind(this));\n      this.escSubscription = this.navigationService.esc.subscribe(this.handleEscape.bind(this));\n    }\n\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => // Roll up AutoComplete on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n\n        if (this.isFocused && !inDropDown(this.hostElement, target, this.popupRef)) {\n          this._zone.run(() => this.blur());\n        }\n      }));\n    }\n\n    unsubscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.changeSubscription.unsubscribe();\n      this.navigationSubscription.unsubscribe();\n      this.closeSubscription.unsubscribe();\n      this.enterSubscription.unsubscribe();\n      this.escSubscription.unsubscribe();\n      this.valueChangeSubscription.unsubscribe();\n      this.focusSubscription.unsubscribe();\n\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n\n    handleItemChange(event) {\n      const index = event.indices.length ? event.indices[0] : undefined;\n      this.selectionService.resetSelection([-1]);\n\n      if (!isPresent(index)) {\n        return;\n      }\n\n      let text = getter(this.dataService.itemAt(index), this.valueField);\n      this.change(text);\n    }\n\n    handleItemFocus(_event) {\n      const focused = this.selectionService.focused;\n      const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);\n\n      if (shouldSuggest) {\n        this.suggestedText = getter(this.dataService.itemAt(focused), this.valueField);\n      }\n    }\n\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupClass: this.listContainerClasses,\n        positionMode: 'absolute',\n        popupAlign: popupPosition,\n        anchorAlign: anchorPosition\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    firstFocusableIndex(index) {\n      const maxIndex = this.data.length - 1;\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n\n    findIndexPredicate(text) {\n      if (this.dataService.grouped) {\n        return item => {\n          let itemText = getter(item.value, this.valueField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      } else {\n        return item => {\n          let itemText = getter(item, this.valueField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      }\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper, getSizeClass('input', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper, getFillModeClass('input', this.fillMode));\n      }\n    }\n\n  }\n\n  AutoCompleteComponent.ɵfac = function AutoCompleteComponent_Factory(t) {\n    return new (t || AutoCompleteComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  AutoCompleteComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AutoCompleteComponent,\n    selectors: [[\"kendo-autocomplete\"]],\n    contentQueries: function AutoCompleteComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n      }\n    },\n    viewQuery: function AutoCompleteComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(_c10, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function AutoCompleteComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-autocomplete\", ctx.widgetClasses)(\"k-input\", ctx.widgetClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      highlightFirst: \"highlightFirst\",\n      focusableId: \"focusableId\",\n      data: \"data\",\n      value: \"value\",\n      valueField: \"valueField\",\n      placeholder: \"placeholder\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      loading: \"loading\",\n      clearButton: \"clearButton\",\n      suggest: \"suggest\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoAutoComplete\"],\n    features: [i0.ɵɵProvidersFeature([AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.autocomplete'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => AutoCompleteComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => AutoCompleteComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 15,\n    consts: function () {\n      let i18n_11;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.autocomplete.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_12 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_11 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_12;\n      } else {\n        i18n_11 = $localize`:kendo.autocomplete.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_13;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.autocomplete.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_14 = goog.getMsg(\"clear\");\n        i18n_13 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_14;\n      } else {\n        i18n_13 = $localize`:kendo.autocomplete.clearTitle|The title of the clear button:clear`;\n      }\n\n      return [[\"kendoAutoCompleteLocalizedMessages\", \"\", \"noDataText\", i18n_11, \"clearTitle\", i18n_13], [3, \"role\", \"id\", \"listId\", \"activeDescendant\", \"noDataLabel\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"popupOpen\", \"placeholder\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\"], [\"searchbar\", \"\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"visibility\", \"click\", \"mousedown\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [3, \"ngIf\"], [\"container\", \"\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"click\", \"mousedown\"], [1, \"k-icon\", \"k-i-x\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [4, \"ngIf\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"resize\"]];\n    },\n    template: function AutoCompleteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-searchbar\", 1, 2);\n        i0.ɵɵlistener(\"onNavigate\", function AutoCompleteComponent_Template_kendo_searchbar_onNavigate_1_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function AutoCompleteComponent_Template_kendo_searchbar_valueChange_1_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function AutoCompleteComponent_Template_kendo_searchbar_onBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function AutoCompleteComponent_Template_kendo_searchbar_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, AutoCompleteComponent_span_3_Template, 2, 3, \"span\", 3);\n        i0.ɵɵtemplate(4, AutoCompleteComponent_span_4_Template, 1, 0, \"span\", 4);\n        i0.ɵɵtemplate(5, AutoCompleteComponent_ng_template_5_Template, 5, 16, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, AutoCompleteComponent_ng_template_7_Template, 1, 0, \"ng-template\", 6);\n        i0.ɵɵelementContainer(8, null, 7);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"role\", \"combobox\")(\"id\", ctx.focusableId)(\"listId\", ctx.listBoxId)(\"activeDescendant\", ctx.activeDescendant)(\"noDataLabel\", ctx.noDataLabel)(\"userInput\", ctx.text)(\"suggestedText\", ctx.suggestion)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"tabIndex\", ctx.tabIndex)(\"popupOpen\", ctx.isOpen)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    directives: [SearchBarComponent, ListComponent, i9.ResizeSensorComponent, LocalizedMessagesDirective, i11.NgIf, TemplateContextDirective],\n    encapsulation: 2\n  });\n  return AutoCompleteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst MultiselectMessages = {\n  'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n  'object': 'Expected values of Object type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n  'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',\n  'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#toc-bind-to-arrays-of-complex-data'\n};\n/**\n * @hidden\n */\n\nconst MultiSelectTreeMessages = {\n  'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/#value-selection',\n  'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-primitive-values',\n  'object': 'Expected values of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-object-values',\n  'dataItems': 'Expected dataItems of type Object[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',\n  'dataItemsLength': 'Expected dataItems length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding',\n  'valueDepth': 'Expected valueDepth of type number[] to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth',\n  'valueDepthLength': 'Expected valueDepth length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth'\n};\n/**\n * @hidden\n */\n\nconst ComboBoxMessages = {\n  'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',\n  'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',\n  'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-bind-to-arrays-of-complex-data',\n  'noItemHeight': 'Expected virtual.itemHeight of type number.'\n};\n/**\n * @hidden\n */\n\nconst MultiColumnComboBoxMessages = {\n  'data': 'Provided data must consist only of objects. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/#toc-fields-configuration'\n};\n/**\n * @hidden\n */\n\nconst DropDownListMessages = {\n  'defaultItem': 'defaultItem and data items must be of same type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem',\n  'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',\n  'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',\n  'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-bind-to-arrays-of-complex-data'\n};\n/**\n * @hidden\n */\n\nconst DropDownTreeMessages = {\n  'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-primitive-values',\n  'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-object-values',\n  'dataItem': 'Expected dataItem of type Object to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-dataitem',\n  'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding',\n  'valueDepth': 'Expected valueDepth to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/DropDownTreeComponent/#toc-valuedepth'\n};\n/**\n * @hidden\n */\n\nconst COMBOBOX_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => ComboBoxComponent)\n};\nconst DEFAULT_SIZE$4 = 'medium';\nconst DEFAULT_ROUNDED$4 = 'medium';\nconst DEFAULT_FILL_MODE$4 = 'solid';\n/**\n * Represents the [Kendo UI ComboBox component for Angular]({% slug overview_combobox %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-combobox [data]=\"listItems\">\n *  </kendo-combobox>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\nlet ComboBoxComponent = /*#__PURE__*/(() => {\n  class ComboBoxComponent {\n    constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, cdr, renderer, touchEnabled) {\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.dataService = dataService;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.touchEnabled = touchEnabled;\n      this.selected = [];\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Specifies whether the ComboBox allows user-defined values that are not present in the dataset\n       * ([more information and examples]({% slug custom_values_combobox %})).\n       * Defaults to `false`.\n       */\n\n      this.allowCustom = false;\n      /**\n       * A user-defined callback which returns normalized custom values.\n       * Typically used when the data items are different from type `string`.\n       * @param { Any } value - The custom value defined by the user.\n       * @returns { Any }\n       *\n       * @example\n       * ```ts\n       * import { map } from 'rxjs/operators';\n       *\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *   <kendo-combobox\n       *       [allowCustom]=\"true\"\n       *       [data]=\"listItems\"\n       *       textField=\"text\"\n       *       valueField=\"value\"\n       *       [valueNormalizer]=\"valueNormalizer\"\n       *       (valueChange)=\"onValueChange($event)\"\n       *   >\n       *   </kendo-combobox>\n       * `\n       * })\n       *\n       * class AppComponent {\n       *   public listItems: Array<{ text: string, value: number }> = [\n       *       { text: \"Small\", value: 1 },\n       *       { text: \"Medium\", value: 2 },\n       *       { text: \"Large\", value: 3 }\n       *   ];\n       *\n       *   public onValueChange(value) {\n       *       console.log(\"valueChange : \", value);\n       *   }\n       *\n       *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n       *      return { ProductID: null, ProductName: text };\n       *   }));\n       *\n       * }\n       * ```\n       */\n\n      this.valueNormalizer = text => text.pipe(map(userInput => userInput));\n      /**\n       * The hint that is displayed when the component is empty.\n       *\n       */\n\n\n      this.placeholder = \"\";\n      /**\n       * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * Enables the auto-completion of the text based on the first data item.\n       */\n\n      this.suggest = false;\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n\n      this.clearButton = true;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Enables the [filtering]({% slug filtering_combobox %}) functionality.\n       * If set to `true`, the component emits the `filterChange` event.\n       */\n\n      this.filterable = false;\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example]({% slug overview_combobox %}#toc-events)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time an item selection is changed\n       * ([see example]({% slug overview_combobox %}#toc-events)).\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value\n       * ([see example]({% slug overview_combobox %}#toc-events)).\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires each time the user focuses the ComboBox.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the ComboBox gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      this.widgetClasses = true;\n      this._isFocused = false;\n      this.listBoxId = guid();\n      this.optionPrefix = guid();\n\n      this.onChangeCallback = _ => {};\n\n      this.onTouchedCallback = _ => {};\n      /**\n       * Used for the default virtualization settings config.\n       */\n\n\n      this.defaultVirtualItemHeight = 28;\n      /**\n       * Used for the default virtualization settings config.\n       */\n\n      this.defaultVirtualPageSize = 50;\n      this._filtering = false;\n      this._text = '';\n      this.filterText = '';\n      this._open = false;\n      this._popupSettings = {\n        animate: true\n      };\n\n      this.popupMouseDownHandler = event => event.preventDefault();\n\n      this.customValueSubject = new Subject();\n      this.valueSubject = new Subject();\n      this.clearValueSubject = new Subject();\n      this.subs = new Subscription();\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.data = [];\n    }\n\n    set text(text) {\n      this._text = isPresent(text) ? text.toString() : \"\";\n    }\n\n    get text() {\n      return this._text;\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n\n    get activeDescendant() {\n      if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {\n        return null;\n      }\n\n      const dataItem = this.dataService.itemAt(this.selectionService.focused);\n      return this.optionPrefix + \"-\" + (dataItem ? getter(dataItem, this.valueField) : \"\");\n    }\n\n    get noDataLabel() {\n      if (this.data.length === 0) {\n        return this.messageFor('noDataText');\n      }\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the ComboBox.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n\n\n    set data(data) {\n      this.dataService.data = data || [];\n\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      this.setState();\n\n      if (this._filtering) {\n        const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;\n        const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;\n        this.selectionService.focused = index;\n      }\n\n      if (this.suggest && this.dataService.itemsCount && this.text) {\n        this.suggestedText = getter(this.dataService.itemAt(0), this.textField);\n      }\n    }\n\n    get data() {\n      const virtual = this.virtual;\n\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize; // Use length instead of itemsCount because of the grouping.\n\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the ComboBox.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the dataset are considered custom values.\n     * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.\n     */\n\n\n    set value(newValue) {\n      this._value = newValue;\n      this.setState();\n      this.cdr.markForCheck();\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Specifies the type of the selected value.\n     * If set to `true`, the selected value has to be of the primitive type\n     * ([more information and example]({% slug valuebinding_combobox %}#toc-primitive-values-from-object-fields)).\n     */\n\n\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n\n      return this._valuePrimitive;\n    }\n    /**\n     * Configures the popup of the ComboBox.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.\n     */\n\n\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.\n     */\n\n\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings, {\n        itemHeight: this.defaultVirtualItemHeight,\n        pageSize: this.defaultVirtualPageSize\n      });\n    }\n\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    set isFocused(value) {\n      this.renderer[value ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, \"k-focus\");\n      this._isFocused = value;\n    }\n\n    get clearButtonVisiblity() {\n      if (this.touchEnabled) {\n        return 'visible';\n      }\n    }\n\n    get popupWidth() {\n      let wrapperOffsetWidth = 0;\n\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      }\n\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get popupHeight() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.attachStreams();\n      this.createValueStream();\n      this.subscribeTouchEvents();\n      this.attachSelectClickHandler();\n      this.setComponentClasses();\n    }\n\n    createValueStream() {\n      const valueStream = this.valueSubject.pipe(filter(candidate => {\n        const current = getter(this.value, this.valueField);\n        const newValue = getter(candidate, this.valueField);\n        let newText = getter(candidate, this.textField);\n\n        if (!isPresent(this.value) && !isPresent(newValue)) {\n          return false;\n        }\n\n        if (isPresent(newText)) {\n          newText = newText.toString();\n        }\n\n        if (current === newValue && this.text === newText) {\n          this.clearFilter();\n          return false;\n        } else {\n          return true;\n        }\n      }), map(candidate => {\n        const newValue = getter(candidate, this.valueField);\n        const newText = getter(candidate, this.textField);\n        return {\n          dataItem: candidate,\n          text: newText,\n          value: this.valuePrimitive ? newValue : candidate\n        };\n      }));\n      const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));\n      const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {\n        this.loading = true;\n        this.disabled = true;\n        this.cdr.detectChanges();\n      }), filter(() => {\n        const hasChange = this.text !== getter(this.value, this.valueField);\n        this.loading = hasChange;\n        this.disabled = hasChange;\n\n        if (!hasChange) {\n          this.clearFilter();\n        }\n\n        return hasChange;\n      }), this.valueNormalizer, map(normalizedValue => {\n        return {\n          custom: true,\n          dataItem: normalizedValue,\n          text: this.text,\n          value: normalizedValue\n        };\n      }));\n      const disableCustomValueStream = customValueStreams[1].pipe(map(() => {\n        return {\n          custom: true,\n          dataItem: undefined,\n          text: undefined,\n          value: undefined\n        };\n      }));\n      const clearValueStream = this.clearValueSubject.pipe(map(() => ({\n        dataItem: undefined,\n        text: undefined,\n        value: undefined\n      })));\n\n      if (this.valueSubscription) {\n        this.valueSubscription.unsubscribe();\n      }\n\n      const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);\n      this.valueSubscription = merged.pipe(catchError(() => {\n        const selectionChanged = getter(this.dataItem, this.valueField) !== undefined;\n        this.dataItem = undefined;\n        this.value = undefined;\n        this.text = undefined;\n        this.loading = false;\n        this.disabled = false;\n\n        if (selectionChanged) {\n          this.selectionChange.emit(undefined);\n        }\n\n        this.emitValueChange();\n        this.createValueStream();\n        return of(null);\n      })).subscribe(state => {\n        const selectionChanged = getter(this.dataItem, this.valueField) !== getter(state.dataItem, this.valueField);\n        this.dataItem = state.dataItem;\n        this.value = state.value;\n        this.text = state.text;\n        this.loading = false;\n        this.disabled = false;\n        this.clearFilter();\n\n        if (state.custom) {\n          this.selectionService.focused = -1;\n        }\n\n        if (selectionChanged) {\n          const selectionArgs = state.custom ? undefined : this.dataItem;\n          this.selectionChange.emit(selectionArgs);\n        }\n\n        this.emitValueChange();\n      });\n    }\n\n    attachStreams() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.subs.add(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      }));\n      this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end).pipe(filter(event => isPresent(event.index))).subscribe(event => this.navigate(event.index)));\n      this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));\n      this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));\n      this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));\n      this.subs.add(this.navigationService.enter.pipe(tap(event => {\n        if (this.isOpen) {\n          event.originalEvent.preventDefault();\n        }\n      })).subscribe(this.handleEnter.bind(this)));\n      this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(_ => !this.isOpen))).pipe(tap(_ => {\n        this._filtering = false;\n        this.togglePopup(false);\n      }), map(event => this.dataService.itemAt(event.indices[0]))).subscribe(dataItem => {\n        this.change(dataItem);\n      }));\n      this.subs.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), tap(_ => this._filtering = false), map(event => this.dataService.itemAt(event.indices[0]))).subscribe(dataItem => {\n        const selectionChanged = getter(dataItem, this.valueField) !== getter(this.dataItem, this.valueField);\n        this.updateState({\n          dataItem\n        });\n\n        if (selectionChanged) {\n          this.selectionChange.emit(dataItem);\n        }\n      }));\n    }\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.subs.unsubscribe();\n\n      if (isPresent(this.valueSubscription)) {\n        this.valueSubscription.unsubscribe();\n      }\n\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n\n      if (this.selectClickDisposeHandler) {\n        this.selectClickDisposeHandler();\n      }\n    }\n\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n\n      if (isChanged('valueNormalizer', changes)) {\n        this.createValueStream();\n      }\n\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.setState();\n      }\n    }\n\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * Focuses a specific item of the ComboBox based on a provided index.\n     * If null or invalid index is provided the focus will be removed.\n     */\n\n\n    focusItemAt(index) {\n      const isInRange = index >= 0 && index < this.data.length;\n\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(-1);\n      }\n    }\n    /**\n     * Focuses the ComboBox.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * Blurs the ComboBox.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to open or close the popup,\n     * the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n\n        this._toggle(shouldOpen);\n\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * Resets the value of the ComboBox.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n\n\n    reset() {\n      this.value = undefined;\n      this.clearState();\n      this.resetSelection();\n    }\n    /**\n     * @hidden\n     *\n     * Used by the TextBoxContainer to determine if the floating label\n     * should be rendered in the input when the component is not focused.\n     */\n\n\n    isEmpty() {\n      const textEmpty = !isPresent(this.text) || isEmptyString(this.text);\n      const valueEmpty = !isPresent(this.value) || isEmptyString(this.value);\n      return textEmpty && valueEmpty;\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearValue(event) {\n      event.stopImmediatePropagation();\n      this.focus();\n      this._filtering = true;\n      this._previousDataItem = undefined;\n      this.selectionService.resetSelection([]);\n      this.clearValueSubject.next();\n      this._filtering = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value === null ? undefined : value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get buttonClasses() {\n      return this.loading ? 'k-i-loading k-input-loading-icon' : this.iconClass || 'k-i-arrow-s';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}\n        `;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (this.isOpen) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.popupWidth;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(ComboBoxMessages.primitive);\n      }\n\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(ComboBoxMessages.object);\n      }\n\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n\n      if (valueOrText) {\n        throw new Error(ComboBoxMessages.textAndValue);\n      }\n\n      if (this.virtual && isNaN(this.virtual.itemHeight)) {\n        throw new Error(ComboBoxMessages.noItemHeight);\n      }\n    }\n\n    setState() {\n      // Filtering in process, do nothing.\n      if (this._filtering) {\n        return;\n      }\n\n      const value = this.value;\n      const valueField = this.valueField;\n      const resolved = this.findDataItem({\n        valueField,\n        value\n      });\n\n      if (isPresent(resolved.index) && resolved.index !== -1) {\n        this.updateState({\n          dataItem: resolved.dataItem,\n          confirm: true\n        });\n        this.resetSelection(resolved.index);\n      } else if (isPresent(value) && this.allowCustom) {\n        this.updateState({\n          dataItem: value\n        });\n        this.resetSelection(-1);\n      } else if (this._previousDataItem && this.value) {\n        this.updateState({\n          dataItem: this._previousDataItem\n        });\n        this.resetSelection();\n      } else {\n        this.clearState();\n        this.resetSelection(-1);\n      }\n    }\n\n    updateState({\n      dataItem,\n      confirm = false\n    }) {\n      this.dataItem = dataItem;\n      this.text = getter(dataItem, this.textField);\n\n      if (confirm) {\n        this._previousDataItem = dataItem;\n      }\n    }\n\n    clearState() {\n      this.text = undefined;\n      this.dataItem = undefined;\n    }\n\n    resetSelection(index) {\n      const clear = !isPresent(index) || index < 0;\n      this.selectionService.resetSelection(clear ? [] : [index]);\n      this.selectionService.focused = index;\n    }\n\n    firstFocusableIndex(index) {\n      const maxIndex = this.data.length - 1;\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n\n    findIndexPredicate(text) {\n      if (this.dataService.grouped) {\n        return item => {\n          let itemText = getter(item.value, this.textField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      } else {\n        return item => {\n          let itemText = getter(item, this.textField);\n          itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n          return itemText.startsWith(text.toLowerCase());\n        };\n      }\n    }\n\n    findDataItem({\n      valueField,\n      value\n    }) {\n      const result = {\n        dataItem: null,\n        index: -1\n      };\n\n      const comparer = element => {\n        const dataItem = this.dataService.grouped ? element.value : element;\n        return getter(dataItem, valueField) === getter(value, valueField);\n      };\n\n      const index = this.dataService.findIndex(comparer);\n      result.dataItem = this.dataService.itemAt(index);\n      result.index = index;\n      return result;\n    }\n\n    search(text, startFrom = 0) {\n      let index;\n\n      if (text.length && this.dataService.itemsCount) {\n        index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);\n      } else {\n        index = -1;\n      }\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        if (index + 1 < this.dataService.itemsCount) {\n          this.search(text, index + 1);\n        } else {\n          this.selectionService.focus(-1);\n        }\n      } else {\n        this.selectionService.focus(index);\n\n        if (this.suggest) {\n          this.suggestedText = getter(this.dataService.itemAt(index), this.textField);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getSuggestion() {\n      const hasSelected = !!this.selectionService.selected.length;\n      const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;\n\n      if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {\n        return this.suggestedText;\n      } else {\n        this.suggestedText = undefined;\n      }\n    }\n\n    navigate(index) {\n      if (this.dataService.itemsCount === 0) {\n        return;\n      }\n\n      this.text = getter(this.dataService.itemAt(index), this.textField);\n      this.selectionService.select(index);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigate(event) {\n      const hasSelected = isPresent(this.selectionService.selected[0]);\n      const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;\n      let offset = 0;\n\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      if (event.keyCode === Keys.Home || event.keyCode === Keys.End) {\n        return;\n      }\n\n      if (!hasSelected) {\n        if (event.keyCode === Keys.ArrowDown) {\n          offset = -1;\n        } else if (event.keyCode === Keys.ArrowUp) {\n          offset = 1;\n        }\n      }\n\n      const action = this.navigationService.process({\n        current: offset + focused,\n        max: this.dataService.itemsCount - 1,\n        min: 0,\n        originalEvent: event\n      });\n\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {\n        event.preventDefault();\n      }\n    }\n\n    handleEnter() {\n      const text = this.text;\n      const focused = this.selectionService.focused;\n      const hasFocused = isPresent(focused) && focused !== -1;\n      const previousText = getter(this._previousDataItem, this.textField) || \"\";\n      const focusedItemText = getter(this.dataService.itemAt(focused), this.textField);\n      const textHasChanged = text !== previousText;\n      this.togglePopup(false);\n      this._filtering = false;\n\n      if (this.allowCustom && textHasChanged) {\n        if (text === focusedItemText || this.useSuggestion()) {\n          this.selectionService.change(focused);\n        } else {\n          this.change(text, true);\n        }\n      }\n\n      if (!this.allowCustom) {\n        if (hasFocused) {\n          this.selectionService.change(focused);\n        } else if (textHasChanged) {\n          this.change(text, true);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur() {\n      this._filtering = false;\n      this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers\n\n      this.isFocused = false;\n      const unresolvedSelection = getter(this.dataItem, this.valueField) !== getter(this.value, this.valueField);\n      const currentText = this.searchbar.value;\n      const textHasChanged = currentText !== (getter(this.dataItem, this.textField) || '');\n      const valueHasChanged = unresolvedSelection || textHasChanged;\n      const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement);\n\n      if (runInZone) {\n        this.zone.run(() => {\n          if (valueHasChanged) {\n            const lowerCaseMatch = isPresent(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();\n\n            if (lowerCaseMatch || unresolvedSelection) {\n              this.selectionService.change(this.selectionService.focused);\n            } else {\n              this.change(currentText, true);\n            }\n          }\n\n          this.onBlur.emit();\n          this.onTouchedCallback();\n          this.togglePopup(false);\n        });\n      } else {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleEscape() {\n      this.togglePopup(false); // clear the focus only if the focused item is not selected\n\n      const hasSelected = this.selectionService.selected.length > 0;\n\n      if (!hasSelected) {\n        this.suggestedText = null;\n        this.selectionService.focused = -1;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigationOpen() {\n      this.restoreItemFocus();\n      this.togglePopup(true);\n    }\n    /**\n     * @hidden\n     */\n\n\n    searchBarChange(text) {\n      const currentTextLength = this.text ? this.text.length : 0;\n      this.backspacePressed = text.length < currentTextLength ? true : false;\n      this.text = text; // Reset the selection prior to filter. If a match is present, it will be resolved. If a match is not present, it is not needed.\n\n      this.selectionService.resetSelection([]);\n      this.togglePopup(true);\n      this._filtering = true;\n\n      if (this.filterable && this.filterText !== text) {\n        this.filterText = text;\n        this.filterChange.emit(text);\n      } else {\n        this.search(text);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus() {\n      this.isFocused = true;\n\n      if (hasObservers(this.onFocus)) {\n        this.zone.run(() => this.onFocus.emit());\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n\n    change(candidate, isCustom = false) {\n      if (isCustom) {\n        this.customValueSubject.next(candidate);\n      } else {\n        this.valueSubject.next(candidate);\n      }\n    }\n\n    emitValueChange() {\n      this.onChangeCallback(this.value);\n      this.valueChange.emit(this.value);\n      this._previousDataItem = this.dataItem;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectClick() {\n      if (!this.touchEnabled) {\n        this.searchbar.focus();\n      }\n\n      if (!this.isOpen) {\n        this.restoreItemFocus();\n      }\n\n      this.togglePopup(!this.isOpen);\n    }\n\n    get listContainerClasses() {\n      return ['k-list-container', 'k-reset'].concat(this.popupSettings.popupClass || []);\n    }\n    /**\n     * @hidden\n     */\n\n\n    preventEventDefault(event) {\n      event.preventDefault();\n    }\n\n    get focusedItemText() {\n      const focused = this.selectionService.focused;\n\n      if (!isPresent(focused) || focused === -1) {\n        return null;\n      }\n\n      const itemText = getter(this.dataService.itemAt(focused), this.textField);\n      return !isPresent(itemText) ? \"\" : itemText.toString();\n    }\n    /**\n     * Focuses the first match when there's text in the input field, but no focused item.\n     */\n\n\n    restoreItemFocus() {\n      const hasFocus = isPresent(this.selectionService.focused) && this.selectionService.focused > -1;\n\n      if (!hasFocus && this.text && this.dataService.itemsCount) {\n        if (this.filterable) {\n          this.selectionService.focused = this.firstFocusableIndex(0);\n        } else {\n          this.search(this.text);\n        }\n      }\n    }\n\n    useSuggestion() {\n      if (!(this.suggest && isPresent(this.searchbar.value))) {\n        return false;\n      }\n\n      const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);\n      const focusedItemText = getter(focusedDataItem, this.textField);\n\n      if (!isPresent(focusedItemText)) {\n        return false;\n      }\n\n      return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupClass: this.listContainerClasses,\n        positionMode: 'absolute',\n        anchorAlign: anchorPosition,\n        popupAlign: popupPosition\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.popupWidth;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.popupHeight;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n    }\n\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    clearFilter() {\n      if (!(this.filterable && this.filterText)) {\n        return;\n      }\n\n      this.filterText = '';\n      this.filterChange.emit(this.filterText);\n    }\n\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => // Roll up ComboBox on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n        const isInDropDown = inDropDown(this.wrapper, target, this.popupRef);\n\n        if (this.isFocused && !isInDropDown) {\n          // Close popup and mobile keyboard if searchbar is focused\n          this.zone.run(() => this.blur());\n        } else if (this.isOpen && !isInDropDown) {\n          // Close popup if the popup is opened via the select click\n          this.zone.run(() => this.togglePopup(false));\n        }\n      }));\n    }\n\n    attachSelectClickHandler() {\n      const selectElement = this.select.nativeElement;\n      const event = pointers ? 'pointerdown' : 'click';\n      this.selectClickDisposeHandler = this.renderer.listen(selectElement, event, this.selectClick.bind(this));\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n\n  }\n\n  ComboBoxComponent.ɵfac = function ComboBoxComponent_Factory(t) {\n    return new (t || ComboBoxComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  ComboBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ComboBoxComponent,\n    selectors: [[\"kendo-combobox\"]],\n    contentQueries: function ComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n      }\n    },\n    viewQuery: function ComboBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(_c10, 5);\n        i0.ɵɵviewQuery(_c16, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.select = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function ComboBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵclassProp(\"k-combobox\", ctx.widgetClasses)(\"k-input\", ctx.widgetClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      allowCustom: \"allowCustom\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valuePrimitive: \"valuePrimitive\",\n      valueNormalizer: \"valueNormalizer\",\n      placeholder: \"placeholder\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      iconClass: \"iconClass\",\n      loading: \"loading\",\n      suggest: \"suggest\",\n      clearButton: \"clearButton\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      selectionChange: \"selectionChange\",\n      filterChange: \"filterChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoComboBox\"],\n    features: [i0.ɵɵProvidersFeature([COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.combobox'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => ComboBoxComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => ComboBoxComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 12,\n    vars: 20,\n    consts: function () {\n      let i18n_17;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.combobox.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_18 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_17 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_18;\n      } else {\n        i18n_17 = $localize`:kendo.combobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_19;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.combobox.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_20 = goog.getMsg(\"clear\");\n        i18n_19 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_20;\n      } else {\n        i18n_19 = $localize`:kendo.combobox.clearTitle|The title of the clear button:clear`;\n      }\n\n      let i18n_21;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.combobox.selectButtonText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_22 = goog.getMsg(\"Select\");\n        i18n_21 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_22;\n      } else {\n        i18n_21 = $localize`:kendo.combobox.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n\n      return [[\"kendoComboBoxLocalizedMessages\", \"\", \"noDataText\", i18n_17, \"clearTitle\", i18n_19, \"selectButtonText\", i18n_21], [3, \"role\", \"id\", \"listId\", \"activeDescendant\", \"noDataLabel\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"popupOpen\", \"placeholder\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\"], [\"searchbar\", \"\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"kendoEventsOutsideAngular\", \"click\", 4, \"ngIf\"], [\"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [\"select\", \"\"], [1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"popupTemplate\", \"\"], [3, \"ngIf\"], [\"container\", \"\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"kendoEventsOutsideAngular\", \"click\"], [1, \"k-icon\", \"k-i-x\"], [4, \"ngIf\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"resize\"]];\n    },\n    template: function ComboBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-searchbar\", 1, 2);\n        i0.ɵɵlistener(\"onNavigate\", function ComboBoxComponent_Template_kendo_searchbar_onNavigate_1_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function ComboBoxComponent_Template_kendo_searchbar_valueChange_1_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function ComboBoxComponent_Template_kendo_searchbar_onBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function ComboBoxComponent_Template_kendo_searchbar_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, ComboBoxComponent_span_3_Template, 2, 6, \"span\", 3);\n        i0.ɵɵelementStart(4, \"button\", 4, 5);\n        i0.ɵɵelement(6, \"span\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, ComboBoxComponent_ng_template_7_Template, 5, 16, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, ComboBoxComponent_ng_template_9_Template, 1, 0, \"ng-template\", 8);\n        i0.ɵɵelementContainer(10, null, 9);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"role\", \"combobox\")(\"id\", ctx.focusableId)(\"listId\", ctx.listBoxId)(\"activeDescendant\", ctx.activeDescendant)(\"noDataLabel\", ctx.noDataLabel)(\"userInput\", ctx.text)(\"suggestedText\", ctx.getSuggestion())(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"tabIndex\", ctx.tabIndex)(\"popupOpen\", ctx.isOpen)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton && !ctx.loading && !ctx.disabled && !ctx.readonly && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(18, _c23, ctx.preventEventDefault));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", ctx.buttonClasses);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    directives: [SearchBarComponent, ListComponent, i9.ResizeSensorComponent, LocalizedMessagesDirective, i11.NgIf, i9.EventsOutsideAngularDirective, i11.NgClass, TemplateContextDirective],\n    encapsulation: 2\n  });\n  return ComboBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the selected value of the dropdown. To define the header template, nest an `<ng-template>` tag\n * with the `kendo<ComponentName>ValueTemplate` directive inside the component tag.\n *\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `ValueTemplate` directive can only be used with the DropDownList and DropDownTree components.\n *\n * - [Using `ValueTemplate` with the DropDownList]({% slug templates_ddl %}#toc-value-template)\n * - [Using `ValueTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-value-template)\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *    <ng-template kendoDropDownListValueTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet ValueTemplateDirective = /*#__PURE__*/(() => {\n  class ValueTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ValueTemplateDirective.ɵfac = function ValueTemplateDirective_Factory(t) {\n    return new (t || ValueTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  ValueTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ValueTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownListValueTemplate\", \"\"], [\"\", \"kendoDropDownTreeValueTemplate\", \"\"]]\n  });\n  return ValueTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet FilterInputDirective = /*#__PURE__*/(() => {\n  class FilterInputDirective {\n    constructor(element, zone) {\n      this.element = element;\n      this.zone = zone;\n    }\n\n    ngOnChanges() {\n      if (this.focused) {\n        this.nextTick(() => this.element.nativeElement.focus());\n      }\n    }\n\n    nextTick(fn) {\n      this.zone.runOutsideAngular(() => setTimeout(fn));\n    }\n\n  }\n\n  FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) {\n    return new (t || FilterInputDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  FilterInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterInputDirective,\n    selectors: [[\"\", \"filterInput\", \"\"]],\n    inputs: {\n      focused: [\"filterInput\", \"focused\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FilterInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst DROPDOWNLIST_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DropDownListComponent)\n};\nconst DEFAULT_SIZE$3 = 'medium';\nconst DEFAULT_ROUNDED$3 = 'medium';\nconst DEFAULT_FILL_MODE$3 = 'solid';\n/**\n * Represents the [Kendo UI DropDownList component for Angular]({% slug overview_ddl %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownlist [data]=\"listItems\">\n *  </kendo-dropdownlist>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\nlet DropDownListComponent = /*#__PURE__*/(() => {\n  class DropDownListComponent {\n    constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, cdr, touchEnabled) {\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.dataService = dataService;\n      this._zone = _zone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.touchEnabled = touchEnabled;\n      /**\n       * Sets the height of the options list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of options and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.\n       */\n\n      this.filterable = false;\n      /**\n       * Enables a case-insensitive search. When filtration is disabled, use this option.\n       */\n\n      this.ignoreCase = true;\n      /**\n       * Sets the delay before an item search is performed. When filtration is disabled, use this option.\n       */\n\n      this.delay = 500;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires each time the value is changed ([see example]({% slug overview_ddl %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the user types in the input field\n       * ([see example]({% slug overview_ddl %}#toc-events)).\n       * You can filter the source based on the passed filtration value.\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires each time the item selection is changed\n       * ([see example]({% slug overview_ddl %}#toc-events)).\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires each time the user focuses the DropDownList.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the DropDownList gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      this.hostClasses = true;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      this.role = 'listbox';\n      this.groupIndices = [];\n      this.listBoxId = guid();\n      this.optionPrefix = guid();\n      this.filterText = \"\";\n      this._isFocused = false;\n\n      this.onTouchedCallback = _ => {};\n\n      this.onChangeCallback = _ => {};\n\n      this.word = \"\";\n      this.last = \"\";\n      this.filterFocused = new EventEmitter();\n      this.filterBlurred = new EventEmitter();\n      this.hostElementFocused = new EventEmitter();\n      this.hostElementBlurred = new EventEmitter();\n      this.selectionSubscription = new Subscription();\n      this._open = false;\n      this._popupSettings = {\n        animate: true\n      };\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.data = [];\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.subscribeFocusEvents();\n      this.popupMouseDownHandler = this.onMouseDown.bind(this);\n    }\n\n    get width() {\n      const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n\n    get widgetTabIndex() {\n      if (this.disabled) {\n        return undefined;\n      }\n\n      const providedTabIndex = Number(this.tabIndex);\n      const defaultTabIndex = 0;\n      return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n\n    get ariaExpanded() {\n      return this.isOpen;\n    }\n\n    get ariaOwns() {\n      if (!this.isOpen) {\n        return;\n      }\n\n      return this.listBoxId;\n    }\n\n    get ariaActivedescendant() {\n      if (!isPresent(this.dataItem) || !this.isOpen) {\n        return;\n      }\n\n      return this.optionPrefix + \"-\" + getter(this.dataItem, this.valueField);\n    }\n\n    get noDataLabel() {\n      if (this.dataService.itemsCount === 0) {\n        return this.messageFor('noDataText');\n      }\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the DropDownList.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n\n\n    set data(data) {\n      this.dataService.data = data || [];\n\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      this.setState();\n    }\n\n    get data() {\n      const virtual = this.virtual;\n\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize; // Use length instead of itemsCount because of the grouping.\n\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the DropDownList.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n\n\n    set value(newValue) {\n      if (!isPresent(newValue)) {\n        this._previousDataItem = undefined;\n      }\n\n      this._value = newValue;\n      this.setState();\n      this.cdr.markForCheck();\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Configures the popup of the DropDownList.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.\n     */\n\n\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.\n     */\n\n\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Specifies the type of the selected value\n     * ([more information and example]({% slug valuebinding_ddl %}#toc-primitive-values-from-object-fields)).\n     * If set to `true`, the selected value has to be of a primitive value.\n     */\n\n\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n\n      return this._valuePrimitive;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = rounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$3;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * @hidden\n     */\n\n\n    blurComponent(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n      this.hostElementBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    blurFilterInput() {\n      this.filterBlurred.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    focusComponent(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n      this.hostElementFocused.emit();\n\n      if (!this.isFocused) {\n        this.isFocused = true;\n\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (this._open) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    get hostTabIndex() {\n      return this.widgetTabIndex;\n    }\n\n    get isReadonly() {\n      return this.readonly;\n    }\n\n    get isAriaExpanded() {\n      return this.ariaExpanded;\n    }\n\n    get hostAriaOwns() {\n      return this.ariaOwns;\n    }\n\n    get hostAriaActivedescendant() {\n      return this.ariaActivedescendant;\n    }\n\n    get hostNoDataLabel() {\n      return this.noDataLabel;\n    }\n    /**\n     * @hidden\n     */\n\n\n    keydown(event) {\n      const firstIndex = isPresent(this.defaultItem) ? -1 : 0;\n      let focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;\n      let offset = 0;\n\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      const isHomeEnd = event.keyCode === Keys.Home || event.keyCode === Keys.End;\n      const isFilterFocused = this.filterable && this.isFocused && this.isOpen;\n\n      if (isFilterFocused && isHomeEnd) {\n        return;\n      }\n\n      const hasSelected = isPresent(this.selectionService.selected[0]);\n      const focusedItemNotSelected = isPresent(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);\n\n      if (!hasSelected || focusedItemNotSelected) {\n        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowRight) {\n          offset = -1;\n        } else if (event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowLeft) {\n          offset = 1;\n        }\n      }\n\n      const eventData = event;\n      const action = this.navigationService.process({\n        current: focused + offset,\n        max: this.dataService.itemsCount - 1,\n        min: this.defaultItem ? -1 : 0,\n        originalEvent: eventData\n      });\n      const leftRightKeys = action === NavigationAction.Left || action === NavigationAction.Right;\n\n      if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && !(leftRightKeys && this.filterable) && action !== NavigationAction.Enter //enter when popup is opened is handled before `handleEnter`\n      ) {\n        eventData.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    keypress(event) {\n      if (this.disabled || this.readonly || this.filterable) {\n        return;\n      }\n\n      this.onKeyPress(event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    click(event) {\n      event.preventDefault();\n      this.focus();\n      this.togglePopup(!this.isOpen);\n    }\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, \"tabindex\");\n      this.localizationChangesSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.detectChanges();\n      });\n      this.assignAriaDescribedBy();\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n\n\n    isEmpty() {\n      const value = this.value;\n      return !(value === 0 || value === false || value || this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFilterFocus() {\n      this.filterFocused.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n\n      if (this.localizationChangesSubscription) {\n        this.localizationChangesSubscription.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n\n      if (isChanged('defaultItem', changes, false)) {\n        this.disabledItemsService.defaultItem = this.defaultItem;\n      }\n\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive', 'defaultItem', 'itemDisabled'], changes, false)) {\n        this.setState();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * Focuses a specific item of the DropDownList based on a provided index.\n     * If there is a default item it is positioned at index -1.\n     * If null or invalid index is provided the focus will be removed.\n     */\n\n\n    focusItemAt(index) {\n      const minIndex = isPresent(this.defaultItem) ? -1 : 0;\n      const isInRange = minIndex <= index && index < this.data.length;\n\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(null);\n      }\n    }\n    /**\n     * Focuses the DropDownList.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownList.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n      }\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"Expression has changed...\" type error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n\n        this._toggle(shouldOpen);\n      });\n    }\n\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n\n      if (!isDefaultPrevented) {\n        if (!open && this.filterable && this.isFocused) {\n          this.focus();\n        }\n\n        this._toggle(open);\n      }\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * Resets the value of the DropDownList.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n\n\n    reset() {\n      this.value = undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value === null ? undefined : value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get buttonClasses() {\n      return this.loading ? 'k-i-loading k-input-loading-icon' : this.iconClass || 'k-i-arrow-s';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get optionLabelSizeClass() {\n      return `${this.size ? getSizeClass('list', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-reset'];\n\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDisabledDefaultItem() {\n      return this.disabledItemsService.isItemDisabled(this.defaultItem);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getText() {\n      return this.text;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getDefaultItemText() {\n      return getter(this.defaultItem, this.textField);\n    }\n\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        popupClass: this.listContainerClasses,\n        positionMode: 'absolute'\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n\n      if (!this.filterable) {\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));\n      }\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    updateState({\n      dataItem,\n      confirm = false\n    }) {\n      this.dataItem = dataItem;\n      this.text = getter(dataItem, this.textField);\n\n      if (confirm) {\n        this._previousDataItem = dataItem;\n      }\n    }\n\n    clearState() {\n      this.text = undefined;\n      this.dataItem = undefined;\n    }\n\n    resetSelection(index) {\n      const clear = !isPresent(index);\n      this.selectionService.resetSelection(clear ? [] : [index]);\n      this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;\n    }\n\n    onSelectionChange({\n      dataItem\n    }) {\n      this.updateState({\n        dataItem\n      });\n      this.selectionChange.emit(dataItem); // reassigning the value label ID as aria-deascibedby forces firefox/nvda, forefox/jaws to read\n      // the new value when the popup is closed and the value is changed with the arrow keys (up/down)\n\n      this.assignAriaDescribedBy();\n    }\n\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      } // Item selection when the popup is open.\n\n\n      this.selectionSubscription.add(this.selectionService.onSelect.pipe(filter(_ => this.isOpen), map(this.itemFromEvent.bind(this))).subscribe(this.onSelectionChange.bind(this))); // Item selection when the popup is closed | clicked | enter, and so on.\n\n      this.selectionSubscription.add(merge(this.selectionService.onSelect.pipe(filter(_ => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(_ => this.togglePopup(false))).subscribe(({\n        dataItem,\n        value: newValue,\n        newSelection\n      }) => {\n        if (newSelection) {\n          this.onSelectionChange({\n            dataItem\n          });\n        }\n\n        const shouldUsePrevious = !isPresent(dataItem) && this._previousDataItem;\n        const shouldUseNewValue = newValue !== getter(this.value, this.valueField);\n\n        if (shouldUsePrevious) {\n          this.updateState({\n            dataItem: this._previousDataItem\n          });\n          this.resetSelection();\n        } else if (shouldUseNewValue) {\n          this.value = this.valuePrimitive ? newValue : dataItem;\n          this._previousDataItem = dataItem;\n          this.emitChange(this.value);\n        }\n\n        this.clearFilter();\n      }));\n      this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(skipWhile(() => this.filterable)), this.navigationService.right.pipe(skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end).pipe(filter(event => !isNaN(event.index))).subscribe(event => this.selectionService.select(event.index));\n      this.openSubscription = this.navigationService.open.subscribe(() => this.togglePopup(true));\n      this.closeSubscription = this.navigationService.close.subscribe(() => {\n        this.togglePopup(false);\n        this.focus();\n      });\n      this.enterSubscription = this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(this.handleEnter.bind(this));\n      this.escSubscription = this.navigationService.esc.subscribe(this.handleEscape.bind(this));\n      this.filterBlurredSubscription = this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.hostElementFocused)))).subscribe(() => {\n        this.hostElementBlurred.emit();\n      });\n\n      this._zone.runOutsideAngular(() => {\n        this.componentBlurredSubscription = merge(this.hostElementBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap(event => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused)).subscribe(() => this.componentBlur());\n      });\n    }\n\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => // Roll up DropDownList on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n\n        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            if (this.filterFocused) {\n              // Close popup if filter is focused\n              this.togglePopup(false);\n            }\n\n            this.blur();\n          });\n        }\n      }));\n    }\n\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.focusComponent = this.focusComponent.bind(this);\n        this.blurComponent = this.blurComponent.bind(this);\n\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.focusComponent, useCapture);\n          document.addEventListener('blur', this.blurComponent, useCapture);\n        });\n      }\n    }\n\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.focusComponent, useCapture);\n        document.removeEventListener('blur', this.blurComponent, useCapture);\n      }\n    }\n\n    unsubscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.navigationSubscription.unsubscribe();\n      this.openSubscription.unsubscribe();\n      this.closeSubscription.unsubscribe();\n      this.enterSubscription.unsubscribe();\n      this.escSubscription.unsubscribe();\n      this.componentBlurredSubscription.unsubscribe();\n      this.filterBlurredSubscription.unsubscribe();\n      this.unSubscribeFocusEvents();\n\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n\n      if (this.selectionSubscription) {\n        this.selectionSubscription.unsubscribe();\n      }\n    }\n\n    itemFromEvent(event) {\n      const index = event.indices[0];\n      let dataItem = this.dataService.itemAt(index);\n      dataItem = isPresent(dataItem) ? dataItem : this.currentOrDefault(index);\n      const value = getter(dataItem, this.valueField);\n      const newSelection = event.newSelection;\n      return {\n        dataItem,\n        index,\n        newSelection,\n        value\n      };\n    }\n\n    currentOrDefault(selectedIndex) {\n      const defaultItemIndex = -1;\n\n      if (isPresent(this.dataItem) && selectedIndex !== defaultItemIndex) {\n        return this.dataItem;\n      } else {\n        return this.defaultItem;\n      }\n    }\n\n    firstFocusableIndex(index) {\n      const maxIndex = this.dataService.itemsCount - 1;\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index < maxIndex ? this.firstFocusableIndex(index + 1) : undefined;\n      } else {\n        return index;\n      }\n    }\n\n    handleEnter() {\n      if (this.isOpen) {\n        this.selectionService.change(this.selectionService.focused);\n        this.focus();\n      } else {\n        this.togglePopup(true);\n      }\n    }\n\n    handleEscape() {\n      if (isPresent(this.selectionService.selected[0])) {\n        this.selectionService.change(this.selectionService.selected[0]);\n      } else {\n        this.togglePopup(false);\n        this.clearFilter();\n      }\n\n      this.focus();\n    }\n\n    clearFilter() {\n      if (!(this.filterable && this.filterText)) {\n        return;\n      }\n\n      this.filterText = \"\";\n      this.cdr.markForCheck();\n      this.filterChange.emit(this.filterText);\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.defaultItem && this.valueField && typeof this.defaultItem !== \"object\") {\n        throw new Error(DropDownListMessages.defaultItem);\n      }\n\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(DropDownListMessages.primitive);\n      }\n\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(DropDownListMessages.object);\n      }\n\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n\n      if (valueOrText) {\n        throw new Error(DropDownListMessages.textAndValue);\n      }\n    }\n\n    componentBlur() {\n      this.isFocused = false;\n      const selectionPresent = isPresent(this.selectionService.selected[0]);\n      const valueHasChanged = selectionPresent && getter(this.value, this.valueField) !== getter(this.dataService.itemAt(this.selectionService.selected[0]), this.valueField);\n\n      if (valueHasChanged || hasObservers(this.close) || hasObservers(this.onBlur) || hasObservers(this.filterChange) || isUntouched(this.wrapper.nativeElement)) {\n        this._zone.run(() => {\n          if (valueHasChanged) {\n            this.selectionService.change(this.selectionService.selected[0]);\n          }\n\n          this.togglePopup(false);\n          this.clearFilter();\n          this.onBlur.emit();\n          this.onTouchedCallback();\n        });\n      } else {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseDown(event) {\n      const tagName = event.target.tagName.toLowerCase();\n\n      if (tagName !== \"input\") {\n        event.preventDefault();\n      }\n    }\n\n    onKeyPress(event) {\n      if (event.which === 0 || event.keyCode === Keys.Enter) {\n        return;\n      }\n\n      let character = String.fromCharCode(event.charCode || event.keyCode);\n\n      if (this.ignoreCase) {\n        character = character.toLowerCase();\n      }\n\n      if (character === \" \") {\n        event.preventDefault();\n      }\n\n      this.word += character;\n      this.last = character;\n      this.search();\n    }\n\n    search() {\n      clearTimeout(this.typingTimeout);\n\n      if (!this.filterable) {\n        this.typingTimeout = setTimeout(() => {\n          this.word = \"\";\n        }, this.delay);\n        this.selectNext();\n      }\n    }\n\n    selectNext() {\n      let data = this.dataService.filter(item => isPresent(item) && !item.header && !this.disabledItemsService.isItemDisabled(item)).map(item => {\n        if (this.dataService.grouped) {\n          return {\n            item: item.value,\n            itemIndex: item.offsetIndex\n          };\n        }\n\n        return {\n          item: item,\n          itemIndex: this.dataService.indexOf(item)\n        };\n      });\n      const isInLoop = sameCharsOnly(this.word, this.last);\n      let dataLength = data.length;\n      let hasSelected = !isNaN(this.selectionService.selected[0]);\n      let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];\n      let text, index, defaultItem;\n\n      if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {\n        defaultItem = {\n          item: this.defaultItem,\n          itemIndex: -1\n        };\n        dataLength += 1;\n        startIndex += 1;\n      }\n\n      startIndex += isInLoop && hasSelected ? 1 : 0;\n      data = shuffleData(data, startIndex, defaultItem);\n      index = 0;\n\n      for (; index < dataLength; index++) {\n        text = getter(data[index].item, this.textField);\n        const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));\n        const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));\n\n        if (loopMatch || nextMatch) {\n          index = data[index].itemIndex;\n          break;\n        }\n      }\n\n      if (index !== dataLength) {\n        this.navigate(index);\n      }\n    }\n\n    emitChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n\n    navigate(index) {\n      this.selectionService.select(index);\n    }\n\n    findDataItem({\n      valueField,\n      value\n    }) {\n      const result = {\n        dataItem: null,\n        index: -1\n      };\n\n      const prop = dataItem => getter(dataItem, valueField);\n\n      let comparer;\n\n      if (this.dataService.grouped) {\n        comparer = element => {\n          return prop(element.value) === prop(value);\n        };\n      } else {\n        comparer = element => {\n          return prop(element) === prop(value);\n        };\n      }\n\n      const index = this.dataService.findIndex(comparer);\n      result.dataItem = this.dataService.itemAt(index);\n      result.index = index;\n      return result;\n    }\n\n    setState() {\n      const value = this.value;\n      const valueField = this.valueField;\n      const textField = this.textField;\n      const primitive = this.valuePrimitive;\n\n      if (this.defaultItem) {\n        const defaultValue = getter(this.defaultItem, valueField);\n        const currentValue = getter(value, valueField);\n\n        if (!isPresent(value) || currentValue === defaultValue) {\n          this.updateState({\n            dataItem: this.defaultItem,\n            confirm: true\n          });\n          this.resetSelection(-1);\n\n          if (this.filterable && this.filterText && this.dataService.itemsCount) {\n            this.selectionService.focused = this.firstFocusableIndex(0);\n          }\n\n          return;\n        }\n      }\n\n      const resolved = this.findDataItem({\n        valueField,\n        value\n      }); // The data and value are of same shape,\n      // for example, value: 'foo', data: ['foo', 'bar']\n      // or value: { value: 1, text: 'foo' }, data: [{ value: 1, text: 'foo' }].\n\n      const ofSameType = !(primitive && textField);\n\n      if (resolved.dataItem) {\n        this.updateState({\n          dataItem: resolved.dataItem,\n          confirm: true\n        });\n        this.resetSelection(resolved.index);\n      } else if (isPresent(value) && ofSameType) {\n        this.updateState({\n          dataItem: value\n        });\n        this.resetSelection();\n      } else if (this._previousDataItem) {\n        this.updateState({\n          dataItem: this._previousDataItem\n        });\n        this.resetSelection();\n      } else {\n        this.clearState();\n        this.resetSelection();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilter(event) {\n      this.filterChange.emit(event.target.value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n\n    assignAriaDescribedBy() {\n      const currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || '';\n      const trimmed = currentValue.replace(this.valueLabelId, '').trim(); // reset the value label ID to force readers to read the new value\n\n      this.valueLabelId = guid(); // add to the current value - don't replace it\n\n      const newValue = `${this.valueLabelId} ${trimmed}`.trim();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      }\n    }\n\n  }\n\n  DropDownListComponent.ɵfac = function DropDownListComponent_Factory(t) {\n    return new (t || DropDownListComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  DropDownListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropDownListComponent,\n    selectors: [[\"kendo-dropdownlist\"]],\n    contentQueries: function DropDownListComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n      }\n    },\n    viewQuery: function DropDownListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(_c10, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 20,\n    hostBindings: function DropDownListComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function DropDownListComponent_keydown_HostBindingHandler($event) {\n          return ctx.keydown($event);\n        })(\"keypress\", function DropDownListComponent_keypress_HostBindingHandler($event) {\n          return ctx.keypress($event);\n        })(\"click\", function DropDownListComponent_click_HostBindingHandler($event) {\n          return ctx.click($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"id\", ctx.focusableId)(\"dir\", ctx.dir)(\"tabindex\", ctx.hostTabIndex)(\"readonly\", ctx.isReadonly)(\"aria-readonly\", ctx.isReadonly)(\"role\", ctx.role)(\"aria-haspopup\", ctx.role)(\"aria-expanded\", ctx.isAriaExpanded)(\"aria-owns\", ctx.hostAriaOwns)(\"aria-activedescendant\", ctx.hostAriaActivedescendant)(\"aria-label\", ctx.hostNoDataLabel);\n        i0.ɵɵclassProp(\"k-dropdownlist\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      iconClass: \"iconClass\",\n      loading: \"loading\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      defaultItem: \"defaultItem\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      readonly: \"readonly\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      ignoreCase: \"ignoreCase\",\n      delay: \"delay\",\n      valuePrimitive: \"valuePrimitive\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      focusableId: [\"id\", \"focusableId\"]\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\",\n      selectionChange: \"selectionChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\"\n    },\n    exportAs: [\"kendoDropDownList\"],\n    features: [i0.ɵɵProvidersFeature([DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdownlist'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => DropDownListComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => DropDownListComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 12,\n    vars: 10,\n    consts: function () {\n      let i18n_24;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.dropdownlist.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_25 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_24 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_25;\n      } else {\n        i18n_24 = $localize`:kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_26;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.dropdownlist.selectButtonText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_27 = goog.getMsg(\"Select\");\n        i18n_26 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_27;\n      } else {\n        i18n_26 = $localize`:kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n\n      return [[\"kendoDropDownListLocalizedMessages\", \"\", \"noDataText\", i18n_24, \"selectButtonText\", i18n_26], [\"unselectable\", \"on\", \"role\", \"option\", 1, \"k-input-inner\", 3, \"id\"], [1, \"k-input-value-text\"], [4, \"ngIf\"], [3, \"ngIf\"], [\"tabindex\", \"-1\", \"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [\"unselectable\", \"on\", 1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"templateContext\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\", 3, \"click\"], [1, \"k-searchbox\", \"k-input\", 3, \"ngClass\"], [\"unselectable\", \"on\", 1, \"k-input-icon\", \"k-icon\", \"k-i-search\"], [\"tabindex\", \"-1\", 1, \"k-input-inner\", 3, \"filterInput\", \"dir\", \"ngModel\", \"ngModelChange\", \"keydown\", \"input\", \"focus\", \"blur\"], [1, \"k-list\", 3, \"ngClass\"], [\"kendoDropDownsSelectable\", \"\", 1, \"k-list-optionlabel\", 3, \"ngClass\", \"index\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"resize\"]];\n    },\n    template: function DropDownListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1)(2, \"span\", 2);\n        i0.ɵɵtemplate(3, DropDownListComponent_3_Template, 1, 4, null, 3);\n        i0.ɵɵtemplate(4, DropDownListComponent_ng_template_4_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(5, \"button\", 5);\n        i0.ɵɵelement(6, \"span\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, DropDownListComponent_ng_template_7_Template, 8, 19, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, DropDownListComponent_ng_template_9_Template, 1, 0, \"ng-template\", 4);\n        i0.ɵɵelementContainer(10, null, 8);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.valueLabelId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(8, _c23, ctx.onMouseDown));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.buttonClasses);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    directives: [ListComponent, i9.ResizeSensorComponent, LocalizedMessagesDirective, i11.NgIf, TemplateContextDirective, i11.NgClass, i9.EventsOutsideAngularDirective, i8.DefaultValueAccessor, FilterInputDirective, i8.NgControlStatus, i8.NgModel, SelectableDirective],\n    encapsulation: 2\n  });\n  return DropDownListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the content of the custom list item in the MultiSelect\n * ([see example]({% slug templates_multiselect %}#toc-customizing-the-item-content)).\n * The template context is set to the current component.\n * To get a reference to the current text that is typed by the\n * user, use the `let-customItem` directive.\n *\n * > The `CustomItemTemplate` directive can only be used with the MultiSelect component.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\" [allowCustom]=\"true\">\n *    <ng-template kendoMultiSelectCustomItemTemplate let-customItem>\n *      <span>New Item: {{customItem}}</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n *\n */\n\n\nlet CustomItemTemplateDirective = /*#__PURE__*/(() => {\n  class CustomItemTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  CustomItemTemplateDirective.ɵfac = function CustomItemTemplateDirective_Factory(t) {\n    return new (t || CustomItemTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  CustomItemTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CustomItemTemplateDirective,\n    selectors: [[\"\", \"kendoMultiSelectCustomItemTemplate\", \"\"]]\n  });\n  return CustomItemTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the selected tag value of the MultiSelect\n * ([see example]({% slug templates_multiselect %}#toc-tag-template)).\n * The template context is set to the current component.\n * To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * > The `TagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"items\">\n *    <ng-template kendoMultiSelectTagTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet TagTemplateDirective = /*#__PURE__*/(() => {\n  class TagTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  TagTemplateDirective.ɵfac = function TagTemplateDirective_Factory(t) {\n    return new (t || TagTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  TagTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TagTemplateDirective,\n    selectors: [[\"\", \"kendoMultiSelectTagTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeTagTemplate\", \"\"]]\n  });\n  return TagTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the grouped tag values in the MultiSelect\n * ([see example]({% slug summarytagmode_multiselect %})).\n * The template context is set to the current component.\n * To get a reference to the current grouped\n * data items collection, use the `let-dataItems` directive.\n *\n * > The `GroupTagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"items\">\n *    <ng-template kendoMultiSelectGroupTagTemplate let-dataItems>\n *      <span>{{dataItems.length}} item(s) selected</span>\n *    </ng-template>\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public items: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\n\nlet GroupTagTemplateDirective = /*#__PURE__*/(() => {\n  class GroupTagTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  GroupTagTemplateDirective.ɵfac = function GroupTagTemplateDirective_Factory(t) {\n    return new (t || GroupTagTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  GroupTagTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: GroupTagTemplateDirective,\n    selectors: [[\"\", \"kendoMultiSelectGroupTagTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeGroupTagTemplate\", \"\"]]\n  });\n  return GroupTagTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Arguments for the `removeTag` event. The `removeTag` event fires when a tag is about\n * to the removed. If you cancel the event, the removal is prevented.\n */\n\n\nclass RemoveTagEvent extends PreventableEvent {\n  /**\n   * Constructs the event arguments for the `remove` event.\n   * @param dataItem - The data item or an array of data items that will be removed.\n   */\n  constructor(dataItem) {\n    super();\n    this.dataItem = dataItem;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst normalizeCheckboxesSettings = settings => {\n  if (isObject(settings)) {\n    const defaultSettings = {\n      enabled: true,\n      checkOnClick: true\n    };\n    return Object.assign({}, defaultSettings, settings);\n  }\n\n  return {\n    enabled: Boolean(settings),\n    checkOnClick: true\n  };\n};\n/**\n * @hidden\n */\n\n\nlet TagListComponent = /*#__PURE__*/(() => {\n  class TagListComponent {\n    constructor(renderer, hostElement) {\n      this.renderer = renderer;\n      this.hostElement = hostElement;\n      this.rounded = 'medium';\n      this.fillMode = 'solid';\n      /**\n       * A collection with the disabled tags' indices.\n       */\n\n      this.disabledIndices = new Set();\n      this.removeTag = new EventEmitter();\n      this.hostClasses = true;\n      this._size = 'medium';\n    }\n\n    set size(size) {\n      this.renderer.removeClass(this.hostElement.nativeElement, getSizeClass('chip-list', this.size));\n\n      if (size) {\n        this.renderer.addClass(this.hostElement.nativeElement, getSizeClass('chip-list', size));\n      }\n\n      this._size = size;\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    get hostId() {\n      return this.id;\n    }\n\n    tagProp(tag, prop, index) {\n      const propField = prop && this.getPropField(tag, prop, index);\n      return getter(tag, propField);\n    }\n\n    isTagDisabled(tag, positionIndex) {\n      if (this.isGroupTag(tag)) {\n        /** The `positionIndex` is used to determine after how many single tags is the group tag displayed =>\n         * => it is used to increment the indices inside the group tag so that we determine the actual position index\n         * of each group tag item as they appear in the `value` (important to check against `disabledIndices`)\n         * e.g. `disabledIndices = [0, 1]` && `tags = ['Small', ['Medium', 'Large']]` => without the incrementation with\n         * `positionIndex`, the group tag would yield [0, 1] as indices, while it should yield [1, 2]\n         */\n        return tag.every((_tag, index) => this.disabledIndices.has(index + positionIndex));\n      }\n\n      return this.disabledIndices.has(positionIndex);\n    }\n\n    deleteTag(event, tag, index) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n\n      if (!this.disabled && event.which === 1) {\n        this.removeTag.emit({\n          tag,\n          index\n        });\n      }\n    }\n\n    itemId(tag, index) {\n      if (tag) {\n        //because of custom values\n        return this.tagPrefix + \"-\" + this.tagProp(tag, this.valueField, index);\n      }\n    }\n\n    isGroupTag(tag) {\n      return tag instanceof Array;\n    }\n\n    tagAriaHidden(index) {\n      return isPresent(this.focused) && this.focused !== index;\n    }\n\n    getPropField(tag, prop, index) {\n      // Needed for MultiSelectTree value binding (Heterogeneous Data)\n      const fieldsCount = prop.length - 1;\n\n      if (typeof prop === 'string') {\n        return prop;\n      } else if (this.valueDepth) {\n        const depth = this.valueDepth[index];\n        return fieldsCount < depth ? prop[fieldsCount] : prop[depth];\n      } else {\n        return prop.find(item => item in tag);\n      }\n    }\n\n  }\n\n  TagListComponent.ɵfac = function TagListComponent_Factory(t) {\n    return new (t || TagListComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  TagListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TagListComponent,\n    selectors: [[\"kendo-taglist\"]],\n    hostVars: 7,\n    hostBindings: function TagListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.hostId);\n        i0.ɵɵclassProp(\"k-input-values\", ctx.hostClasses)(\"k-chip-list\", ctx.hostClasses)(\"k-selection-multiple\", ctx.hostClasses);\n      }\n    },\n    inputs: {\n      tags: \"tags\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      focused: \"focused\",\n      template: \"template\",\n      groupTemplate: \"groupTemplate\",\n      disabled: \"disabled\",\n      tagPrefix: \"tagPrefix\",\n      id: \"id\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      disabledIndices: \"disabledIndices\"\n    },\n    outputs: {\n      removeTag: \"removeTag\"\n    },\n    ngContentSelectors: _c30,\n    decls: 2,\n    vars: 1,\n    consts: [[\"class\", \"k-chip\", 3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [1, \"k-chip\", 3, \"ngClass\"], [1, \"k-chip-content\"], [4, \"ngIf\", \"ngIfThen\", \"ngIfElse\"], [\"groupTag\", \"\"], [\"singleTag\", \"\"], [1, \"k-chip-actions\"], [\"aria-label\", \"delete\", 1, \"k-chip-action\", \"k-chip-remove-action\"], [1, \"k-icon\", \"k-i-x-circle\", 3, \"mousedown\"], [1, \"k-chip-label\", \"k-text-ellipsis\"], [4, \"ngIf\"], [3, \"ngIf\"], [3, \"templateContext\"]],\n    template: function TagListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, TagListComponent_div_0_Template, 10, 20, \"div\", 0);\n        i0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.tags);\n      }\n    },\n    directives: [i11.NgForOf, i11.NgClass, i11.NgIf, TemplateContextDirective],\n    encapsulation: 2\n  });\n  return TagListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MULTISELECT_VALUE_ACCESSOR = {\n  multi: true,\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MultiSelectComponent)\n};\nconst DEFAULT_SIZE$2 = 'medium';\nconst DEFAULT_ROUNDED$2 = 'medium';\nconst DEFAULT_FILL_MODE$2 = 'solid';\n/**\n * Represents the [Kendo UI MultiSelect component for Angular]({% slug overview_multiselect %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-multiselect [data]=\"listItems\">\n *  </kendo-multiselect>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\n\nlet MultiSelectComponent = /*#__PURE__*/(() => {\n  class MultiSelectComponent {\n    constructor(wrapper, localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, _zone, touchEnabled) {\n      this.wrapper = wrapper;\n      this.localization = localization;\n      this.popupService = popupService;\n      this.dataService = dataService;\n      this.selectionService = selectionService;\n      this.navigationService = navigationService;\n      this.disabledItemsService = disabledItemsService;\n      this.cdr = cdr;\n      this.differs = differs;\n      this.renderer = renderer;\n      this._zone = _zone;\n      this.touchEnabled = touchEnabled;\n      this.listBoxId = guid();\n      this.tagListId = guid();\n      this.tagPrefix = \"tag-\" + guid();\n      this.optionPrefix = \"option-\" + guid();\n      this.focusedTagIndex = undefined;\n      /**\n       * @hidden\n       */\n\n      this.focusableId = `k-${guid()}`;\n      /**\n       * Determines whether to close the options list of the MultiSelect after the item selection is finished\n       * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).\n       * @default true\n       */\n\n      this.autoClose = true;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.\n       */\n\n      this.filterable = false;\n      /**\n       * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to an empty array and triggers the `change` event.\n       */\n\n      this.clearButton = true;\n      /**\n       * A user-defined callback function which receives an array of selected data items and maps them to an array of tags\n       * ([see examples]({% slug summarytagmode_multiselect %}#toc-rendering-of-tags)).\n       *\n       * @param { Any[] } dataItems - The selected data items from the list.\n       * @returns { Any[] } - The tags that will be rendered by the component.\n       */\n\n      this.tagMapper = tags => tags || [];\n      /**\n       * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset\n       * ([more information and examples]({% slug custom_values_multiselect %})).\n       * Defaults to `false`.\n       */\n\n\n      this.allowCustom = false;\n      /**\n       * A user-defined callback function which returns normalized custom values.\n       * Typically used when the data items are different from type `string`.\n       *\n       * @param { Any } value - The custom value that is defined by the user.\n       * @returns { Any }\n       *\n       * @example\n       * ```ts\n       * import { map } from 'rxjs/operators';\n       *\n       * _@Component({\n       * selector: 'my-app',\n       * template: `\n       *   <kendo-multiselect\n       *       [allowCustom]=\"true\"\n       *       [data]=\"listItems\"\n       *       textField=\"text\"\n       *       valueField=\"value\"\n       *       [valueNormalizer]=\"valueNormalizer\"\n       *       (valueChange)=\"onValueChange($event)\"\n       *   >\n       *   </kendo-multiselect>\n       * `\n       * })\n       *\n       * class AppComponent {\n       *   public listItems: Array<{ text: string, value: number }> = [\n       *       { text: \"Small\", value: 1 },\n       *       { text: \"Medium\", value: 2 },\n       *       { text: \"Large\", value: 3 }\n       *   ];\n       *\n       *   public onValueChange(value) {\n       *       console.log(\"valueChange : \", value);\n       *   }\n       *\n       *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {\n       *      return {\n       *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField\n       *         text: text };\n       *   }));\n       *\n       * }\n       * ```\n       */\n\n      this.valueNormalizer = text => text.pipe(map(userInput => {\n        const comparer = item => typeof item === 'string' && userInput.toLowerCase() === item.toLowerCase();\n\n        const matchingValue = this.value.find(comparer);\n\n        if (matchingValue) {\n          return matchingValue;\n        }\n\n        const matchingItem = this.dataService.find(comparer);\n        return matchingItem ? matchingItem : userInput;\n      }));\n      /**\n       * Fires each time the user types in the input field.\n       * You can filter the source based on the passed filtration value.\n       */\n\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires each time the value is changed&mdash;\n       * when the component is blurred or the value is cleared through the **Clear** button\n       * ([see example]({% slug overview_multiselect %}#toc-events)).\n       * When the value of the component is programmatically changed to `ngModel` or `formControl`\n       * through its API or form binding, the `valueChange` event is not triggered because it\n       * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires each time the user focuses the MultiSelect.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the MultiSelect gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselecttree %}#toc-notifying-on-removing-group-tags)).\n       * This event is preventable. If you cancel it, the tag will not be removed.\n       */\n\n      this.removeTag = new EventEmitter();\n      this.hostClasses = true;\n      this.role = 'combobox';\n      this.initialized = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n\n      this.onChangeCallback = _ => {};\n\n      this.onTouchedCallback = _ => {};\n\n      this._placeholder = '';\n      this._open = false;\n      this._value = [];\n      this._popupSettings = {\n        animate: true\n      };\n      this._checkboxes = {\n        enabled: false\n      };\n      this._isFocused = false;\n      this.selectedDataItems = [];\n      this.customValueSubject = new Subject();\n      this.observableSubscriptions = new Subscription();\n      validatePackage(packageMetadata);\n      this.popupMouseDownHandler = this.onMouseDown.bind(this);\n      this.data = [];\n      this.direction = this.localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n    }\n    /**\n     * Focuses a specific item of the MultiSelect based on a provided index.\n     * If there is a custom item it is positioned at index -1.\n     * If null or invalid index is provided the focus will be removed.\n     */\n\n\n    focusItemAt(index) {\n      const minIndex = this.allowCustom ? -1 : 0;\n      const isInRange = minIndex <= 0 && index < this.data.length;\n\n      if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {\n        this.selectionService.focus(index);\n      } else {\n        this.selectionService.focus(null);\n      }\n    }\n    /**\n     * Focuses the MultiSelect.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.searchbar.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onSearchBarFocus() {\n      if (!this.isFocused) {\n        this.isFocused = true;\n\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      }\n    }\n    /**\n     * Blurs the MultiSelect.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.searchbar.blur();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onSearchBarBlur() {\n      if (!this.isFocused) {\n        return;\n      }\n\n      this.isFocused = false;\n\n      if (hasObservers(this.onBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched(this.wrapper.nativeElement)) {\n        this._zone.run(() => {\n          this.closePopup();\n\n          if (!(this.isOpen && this.allowCustom)) {\n            this.clearFilter();\n          }\n\n          this.onBlur.emit();\n          this.onTouchedCallback();\n        });\n      } else {\n        if (!this.allowCustom) {\n          this.clearFilter();\n        }\n\n        this.closePopup();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseDown(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (this._open) {\n        const popupWrapper = this.popupRef.popupElement;\n        const {\n          min,\n          max\n        } = this.width;\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n      }\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * Sets the data of the MultiSelect.\n     *\n     * > The data has to be provided in an array-like list of items.\n     */\n\n\n    set data(data) {\n      this.dataService.data = data || [];\n\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      if (this.initialized) {\n        this.setState(this.value);\n      }\n    }\n\n    get data() {\n      const virtual = this.virtual;\n\n      if (virtual) {\n        const start = virtual.skip || 0;\n        const end = start + virtual.pageSize; //Use length instead of itemsCount because of grouping\n\n        virtual.total = this.dataService.data.length;\n        return this.dataService.data.slice(start, end);\n      }\n\n      return this.dataService.data;\n    }\n    /**\n     * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     * > All selected values which are not present in the source are ignored.\n     */\n\n\n    set value(values) {\n      this._value = values ? values : [];\n\n      if (!this.differ && this.value) {\n        this.differ = this.differs.find(this.value).create();\n      }\n\n      this.valueChangeDetected = true;\n\n      if (this.initialized) {\n        this.setState(this.value);\n      }\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$2;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * The hint which is displayed when the component is empty.\n     * When the values are selected, it disappears.\n     */\n\n\n    set placeholder(text) {\n      this._placeholder = text || '';\n    }\n\n    get placeholder() {\n      return this.selectedDataItems.length ? '' : this._placeholder;\n    }\n    /**\n     * Defines a Boolean function that is executed for each data item in the component\n     * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.\n     */\n\n\n    set itemDisabled(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n\n      this.disabledItemsService.itemDisabled = fn;\n    }\n    /**\n     * Specifies whether checkboxes will be rendered before each item in the popup list.\n     */\n\n\n    set checkboxes(settings) {\n      this._checkboxes = normalizeCheckboxesSettings(settings);\n    }\n\n    get checkboxes() {\n      return this._checkboxes;\n    }\n    /**\n     * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.\n     */\n\n\n    set virtual(settings) {\n      this._virtualSettings = normalizeVirtualizationSettings(settings);\n    }\n\n    get virtual() {\n      return this._virtualSettings;\n    }\n    /**\n     * Configures the popup of the MultiSelect.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Specifies the type of the selected value.\n     * If set to `true`, the selected value has to be of the primitive type\n     * ([more information and example]({% slug valuebinding_multiselect %}#toc-primitive-values-from-object-fields)).\n     */\n\n\n    set valuePrimitive(isPrimitive) {\n      this._valuePrimitive = isPrimitive;\n    }\n\n    get valuePrimitive() {\n      if (!isPresent(this._valuePrimitive)) {\n        return !isPresent(this.valueField);\n      }\n\n      return this._valuePrimitive;\n    }\n\n    get dir() {\n      return this.direction;\n    }\n\n    get disabledClass() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get isAriaExpanded() {\n      return this.isOpen;\n    }\n    /**\n     * @hidden\n     */\n\n\n    hostMousedown(event) {\n      const inputElement = this.searchbar.input.nativeElement;\n\n      if (event.button === 0) {\n        if (this.isFocused && this.isOpen && event.target === inputElement) {\n          return;\n        }\n\n        if (!this.touchEnabled || this.touchEnabled && event.target.tagName !== 'SPAN') {\n          this.searchbar.focus();\n        }\n\n        this.togglePopup(!this.isOpen);\n        event.preventDefault();\n      }\n    }\n\n    get listContainerClasses() {\n      const containerClasses = ['k-list-container', 'k-reset'];\n\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get customItemSizeClass() {\n      return `${this.size ? getSizeClass('list', this.size) : ''}`;\n    }\n\n    get width() {\n      let wrapperOffsetWidth = 0;\n\n      if (isDocumentAvailable()) {\n        wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      }\n\n      const width = this.popupSettings.width || wrapperOffsetWidth;\n      const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n\n    get activeDescendant() {\n      const focusedTagIndex = this.focusedTagIndex;\n      const focusedListIndex = this.selectionService.focused;\n      let prefix;\n      let item;\n\n      if (isPresent(focusedTagIndex) && !this.isOpen) {\n        item = this.tags[focusedTagIndex];\n        prefix = this.tagPrefix;\n      } else if (isPresent(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {\n        item = this.dataService.itemAt(focusedListIndex);\n        prefix = this.optionPrefix;\n      } else {\n        return null;\n      }\n\n      return prefix + \"-\" + getter(item, this.valueField);\n    }\n\n    get noDataLabel() {\n      if (this.dataService.itemsCount === 0) {\n        return this.messageFor('noDataText');\n      }\n    }\n\n    get clearButtonVisiblity() {\n      if (this.touchEnabled) {\n        return 'visible';\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    verifySettings() {\n      if (!isDevMode() || this.value.length === 0) {\n        return;\n      }\n\n      if (!isArray(this.value)) {\n        throw new Error(MultiselectMessages.array);\n      }\n\n      if (this.valuePrimitive === true && isObjectArray(this.value)) {\n        throw new Error(MultiselectMessages.primitive);\n      }\n\n      if (this.valuePrimitive === false && !isObjectArray(this.value)) {\n        throw new Error(MultiselectMessages.object);\n      }\n\n      const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);\n\n      if (valueOrText) {\n        throw new Error(MultiselectMessages.textAndValue);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    change(event) {\n      const isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);\n\n      if (isCustomItem) {\n        this.addCustomValue(this.text);\n        return; // The change is emited asynchronosly.\n      } // Existing items.\n\n\n      if (isPresent(event.added)) {\n        const dataItem = this.dataService.itemAt(event.added);\n        const newItem = this.valuePrimitive && isPresent(dataItem) && isPresent(dataItem[this.valueField]) ? dataItem[this.valueField] : dataItem;\n        this.value = [...this.value, newItem];\n      }\n\n      if (isPresent(event.removed)) {\n        const dataItem = this.dataService.itemAt(event.removed);\n\n        const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);\n\n        this.value = this.value.filter(filter);\n        this.selectionService.focused = event.removed;\n        this.cdr.detectChanges();\n      }\n\n      this.emitValueChange();\n    }\n    /**\n     * @hidden\n     */\n\n\n    setState(value) {\n      let data = this.dataService.data;\n\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n\n      const selection = selectedIndices(this.value, data, this.valueField);\n      this.selectionService.resetSelection(selection);\n\n      if (this.disabledItemsService.isIndexDisabled(this.selectionService.focused)) {\n        this.selectionService.focused = this.firstFocusableIndex(0);\n      }\n\n      if (this.isOpen && this.selectionService.focused === undefined) {\n        if (this.dataService.itemsCount > 0) {\n          this.selectionService.focused = this.firstFocusableIndex(0);\n        } else if (this.allowCustom) {\n          this.selectionService.focused = -1;\n        }\n      }\n\n      if (this.valuePrimitive && !this.valueField) {\n        this.selectedDataItems = value.slice();\n      }\n\n      if (isObjectArray(value) || this.valuePrimitive && this.valueField) {\n        this.selectedDataItems = resolveAllValues(value, data, this.valueField);\n      }\n\n      if (this.selectedDataItems.length < value.length) {\n        this.selectedDataItems = value.map(current => {\n          const dataItem = this.selectedDataItems.find(item => getter(item, this.valueField) === getter(current, this.valueField));\n          return isPresent(dataItem) ? dataItem : this.resolveDataItemFromTags(current);\n        }).filter(dataItem => isPresent(dataItem));\n      }\n\n      this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n      this.disabledIndices = this.disabledItemsMapper();\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilter(text) {\n      this.text = text;\n\n      if (text && !this.isOpen) {\n        this.openPopup();\n      }\n\n      if (this.filterable) {\n        this.filterChange.emit(text);\n      } else {\n        this.searchTextAndFocus(text);\n      }\n\n      this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n\n\n    pageChange(event) {\n      const virtual = this.virtual;\n      virtual.skip = event.skip;\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearFilter() {\n      if (this.filterable && this.text) {\n        this.filterChange.emit(\"\");\n      }\n\n      this.text = \"\";\n      /* Clearing the value from the input as the setInputSize calculation will be incorrect otherwise.\n       Calling cdr.detectChanges to clear the input value as a result of property binding\n       causes JAWS to read outdated tag values in IE upon tag selection for some reason. */\n\n      this.searchbar.input.nativeElement.value = \"\";\n      this.searchbar.setInputSize();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNavigate(event) {\n      const navigateInput = this.text && event.keyCode !== Keys.ArrowDown && event.keyCode !== Keys.ArrowUp;\n      const selectValue = this.text && event.keyCode === Keys.Enter || event.keyCode === Keys.Escape;\n      const deleteTag = !this.text && event.keyCode === Keys.Backspace && this.tags.length > 0;\n\n      if (deleteTag) {\n        this.handleBackspace();\n        return;\n      }\n\n      if (this.disabled || navigateInput && !selectValue) {\n        return;\n      }\n\n      const eventData = event;\n      const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;\n      const action = this.navigationService.process({\n        current: focused,\n        max: this.dataService.itemsCount - 1,\n        min: this.allowCustom && this.text ? -1 : 0,\n        open: this.isOpen,\n        originalEvent: eventData\n      });\n\n      if (action !== NavigationAction.Undefined && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleRemoveTag({\n      tag\n    }) {\n      const eventArgs = new RemoveTagEvent(tag);\n\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      this.focus();\n      this.removeTag.emit(eventArgs);\n\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      }\n\n      if (tag instanceof Array) {\n        this.removeGroupTag(tag);\n      } else {\n        this.removeSingleTag(tag);\n      }\n\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearAll(event) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      this.focus();\n      this.clearFilter();\n      const selected = this.selectionService.selected;\n      this.value = this.value.filter((_item, index) => this.disabledItemsService.isIndexDisabled(selected[index]));\n      this.emitValueChange();\n    }\n    /**\n     * @hidden\n     */\n\n\n    addCustomValue(text) {\n      this.customValueSubject.next(text);\n    }\n\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n\n    ngDoCheck() {\n      const valueChanges = this.differ && this.differ.diff(this.value);\n\n      if (valueChanges && !this.valueChangeDetected) {\n        this.setState(this.value);\n      }\n\n      this.valueChangeDetected = false;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, \"tabindex\");\n      this.createCustomValueStream();\n      this.localizationChangeSubscription = this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      });\n      this.setState(this.value);\n      this.setComponentClasses();\n      this.initialized = true;\n    }\n\n    ngOnChanges(changes) {\n      const virtual = this.virtual;\n      const requestInitialData = virtual && changes.data && changes.data.isFirstChange();\n\n      if (requestInitialData) {\n        this.pageChange({\n          skip: 0,\n          take: virtual.pageSize\n        });\n      }\n\n      if (isChanged('valueNormalizer', changes)) {\n        this.createCustomValueStream();\n      }\n\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes)) {\n        this.setState(this.value);\n      }\n    }\n\n    ngAfterViewInit() {\n      this.searchbar.setInputSize();\n    }\n\n    ngOnDestroy() {\n      this._toggle(false);\n\n      this.unsubscribeEvents();\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).\n     * If you use the `toggle` method to open or close the popup, the respective `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      // The Promise is required for opening the popup on load.\n      // Otherwise, the \"Expression has changed...\" type error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !this._open;\n\n        this._toggle(shouldOpen);\n\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return this._open;\n    }\n    /**\n     * Resets the value of the MultiSelect.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n\n\n    reset() {\n      this.text = \"\";\n      this.value = [];\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    } // NG MODEL BINDINGS\n\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value || [];\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onTagMapperChange() {\n      this.tags = this.tagMapper(this.selectedDataItems.slice(0));\n      this.cdr.markForCheck();\n    }\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    subscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const isOpen = () => this.isOpen;\n\n      const isClosed = () => !this.isOpen;\n\n      const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== undefined;\n\n      [this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)), this.navigationService.esc.subscribe(this.closePopup.bind(this)), this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)), this.navigationService.open.subscribe(this.openPopup.bind(this)), this.navigationService.close.subscribe(this.handleClose.bind(this)), this.navigationService.up.pipe(filter(isOpen)).subscribe(event => this.handleUp(event.index)), this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)), this.navigationService.left.subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.down.subscribe(event => this.handleDownKey(event.index))].forEach(s => this.observableSubscriptions.add(s));\n    }\n\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => // Roll up MultiSelect on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n\n        if ((this.isFocused || this.isOpen) && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            this.blur();\n\n            if (this.isOpen) {\n              this.togglePopup(false);\n            }\n          });\n        }\n      }));\n    }\n\n    unsubscribeEvents() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.observableSubscriptions.unsubscribe();\n\n      if (this.customValueSubscription) {\n        this.customValueSubscription.unsubscribe();\n      }\n\n      if (this.localizationChangeSubscription) {\n        this.localizationChangeSubscription.unsubscribe();\n      }\n\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n\n    removeGroupTag(dataItems) {\n      let data = this.dataService.data;\n\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n\n      const dataItemValues = new Set(dataItems.map(item => getter(item, this.valueField)));\n      this.value = this.value.filter(value => {\n        const index = selectedIndices([value], data, this.valueField)[0];\n        const isDataItemDisabled = this.disabledItemsService.isIndexDisabled(index);\n        return !dataItemValues.has(getter(value, this.valueField)) || isDataItemDisabled;\n      });\n      this.emitValueChange();\n    }\n\n    removeSingleTag(dataItem) {\n      let data = this.dataService.data;\n\n      if (this.dataService.grouped) {\n        data = data.filter(item => !item.header).map(item => item.value);\n      }\n\n      const index = selectedIndices([dataItem], data, this.valueField)[0];\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return;\n      }\n\n      if (isNumber(index)) {\n        this.selectionService.unselect(index);\n        this.selectionService.focused = index;\n        this.togglePopup(false);\n      } else {\n        // the deleted item is not present in the source\n        const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);\n\n        this.value = this.value.filter(filter);\n        this.emitValueChange();\n      }\n    }\n    /**\n     * @hidden\n     *\n     * Determines which of the provided tags should be disabled and stores their position indices\n     */\n\n\n    disabledItemsMapper() {\n      const {\n        selected\n      } = this.selectionService;\n      return new Set(this.selectedDataItems.reduce((indices, _item, index) => {\n        if (this.disabledItemsService.isIndexDisabled(selected[index])) {\n          indices.push(index);\n        }\n\n        return indices;\n      }, []));\n    }\n\n    createCustomValueStream() {\n      if (this.customValueSubscription) {\n        this.customValueSubscription.unsubscribe();\n      }\n\n      this.customValueSubscription = this.customValueSubject.pipe(tap(() => {\n        this.loading = true;\n        this.disabled = true;\n        this.cdr.detectChanges();\n      }), this.valueNormalizer, catchError(() => {\n        this.loading = false;\n        this.disabled = false;\n\n        if (this.autoClose) {\n          this.togglePopup(false);\n        }\n\n        if (this.autoClose || !this.filterable) {\n          this.clearFilter();\n        }\n\n        this.nextTick(() => {\n          this.searchbar.focus();\n        });\n        this.createCustomValueStream();\n        return of(null);\n      })).subscribe(normalizedValue => {\n        this.loading = false;\n        this.disabled = false;\n\n        if (isPresent(normalizedValue)) {\n          // if valueNormalizer returns `null` or `undefined` custom value is discarded\n          const newValue = this.valuePrimitive ? getter(normalizedValue, this.valueField) : normalizedValue;\n          const itemIndex = this.dataService.indexOf(newValue);\n          const customItem = itemIndex === -1;\n\n          if (this.value.indexOf(newValue) === -1) {\n            this.tags = this.tagMapper([...this.selectedDataItems, normalizedValue]);\n\n            if (!customItem) {\n              this.selectionService.add(itemIndex);\n            } else {\n              this.value = [...this.value, newValue];\n            }\n          } else {\n            if (!customItem && this.selectionService.isSelected(itemIndex)) {\n              this.selectionService.unselect(itemIndex);\n              this.selectionService.focused = itemIndex;\n            } else {\n              this.value = this.value.filter(item => getter(item, this.valueField) !== newValue);\n            }\n          }\n\n          this.emitValueChange();\n        }\n\n        if (this.autoClose) {\n          this.togglePopup(false);\n        }\n\n        if (this.autoClose || !this.filterable) {\n          this.clearFilter();\n        }\n\n        this.nextTick(() => {\n          this.searchbar.focus();\n        });\n      });\n    }\n\n    handleItemChange(event) {\n      this.change(event);\n\n      if (this.autoClose) {\n        this.togglePopup(false);\n      }\n\n      if (this.autoClose || !this.filterable) {\n        this.clearFilter();\n      }\n    }\n\n    handleEnter(event) {\n      const service = this.selectionService;\n      const focusedIndex = this.selectionService.focused;\n\n      if (this.isOpen) {\n        event.originalEvent.preventDefault();\n      }\n\n      if (focusedIndex === -1) {\n        if (this.allowCustom && this.text) {\n          this.addCustomValue(this.text);\n        }\n\n        return; // Clear filter & close are done at customValueSubscription due to race conditions.\n      }\n\n      if (service.isSelected(focusedIndex)) {\n        service.unselect(focusedIndex);\n        service.focused = focusedIndex;\n      } else {\n        service.add(focusedIndex);\n      }\n\n      if (this.autoClose) {\n        this.togglePopup(false);\n      }\n\n      if (this.autoClose || !this.filterable) {\n        this.clearFilter();\n      }\n    }\n\n    handleClose() {\n      this.closePopup();\n      this.searchbar.focus();\n    }\n\n    handleEnd() {\n      this.focusedTagIndex = this.tags.length - 1;\n    }\n\n    handleHome() {\n      this.focusedTagIndex = 0;\n    }\n\n    handleUp(index) {\n      this.selectionService.focused = index;\n    }\n\n    handleBackspace() {\n      if (this.focusedTagIndex !== undefined) {\n        this.handleDelete();\n      } else {\n        this.handleRemoveTag({\n          tag: this.tags[this.tags.length - 1]\n        });\n        this.searchbar.focus();\n      }\n    }\n\n    handleDelete() {\n      this.handleRemoveTag({\n        tag: this.tags[this.focusedTagIndex]\n      });\n\n      if (this.focusedTagIndex === this.tags.length) {\n        this.focusedTagIndex = undefined;\n      }\n    }\n\n    handleLeftKey() {\n      if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {\n        this.focusedTagIndex = this.tags.length - 1;\n      } else if (this.focusedTagIndex !== 0) {\n        this.focusedTagIndex--;\n      }\n    }\n\n    handleDownKey(index) {\n      if (this.isOpen) {\n        this.selectionService.focused = index || this.firstFocusableIndex(0);\n      } else {\n        this.openPopup();\n      }\n    }\n\n    handleRightKey() {\n      const last = this.tags.length - 1;\n\n      if (this.focusedTagIndex === last) {\n        this.focusedTagIndex = undefined;\n      } else if (this.focusedTagIndex < last) {\n        this.focusedTagIndex++;\n      }\n    }\n\n    findIndex(text, startsFrom = 0) {\n      let itemText;\n      text = text.toLowerCase();\n      let index = this.dataService.findIndex(item => {\n        if (this.dataService.grouped) {\n          itemText = getter(item.value, this.textField);\n        } else {\n          itemText = getter(item, this.textField);\n        }\n\n        itemText = !isPresent(itemText) ? \"\" : itemText.toString().toLowerCase();\n        return text && itemText.startsWith(text);\n      }, startsFrom);\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        return index + 1 > this.dataService.itemsCount ? -1 : this.findIndex(text, index + 1);\n      } else {\n        return index;\n      }\n    }\n\n    searchTextAndFocus(text) {\n      const index = this.findIndex(text);\n      this.selectionService.focused = index;\n    }\n\n    closePopup() {\n      this.togglePopup(false);\n      this.focusedTagIndex = undefined;\n    }\n\n    openPopup() {\n      this.togglePopup(true);\n      this.focusedTagIndex = undefined;\n    }\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const isDefaultPrevented = this.triggerPopupEvents(open);\n\n      if (!isDefaultPrevented) {\n        this._toggle(open);\n      }\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    _toggle(open) {\n      this._open = open;\n      this.destroyPopup();\n\n      if (this._open) {\n        this.createPopup();\n      }\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.popupElement.removeEventListener('mousedown', this.popupMouseDownHandler);\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n    createPopup() {\n      if (this.virtual) {\n        this.virtual.skip = 0;\n      }\n\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"bottom\"\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: \"top\"\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        anchorAlign: anchorPosition,\n        animate: this.popupSettings.animate,\n        appendTo: this.appendTo,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        popupClass: this.listContainerClasses,\n        positionMode: 'absolute'\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.optionsList.scrollToItem(this.selectionService.focused);\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n      this.popupRef.popupAnchorViewportLeave.subscribe(() => {\n        this.togglePopup(false);\n      });\n    }\n\n    emitValueChange() {\n      this.onChangeCallback(this.value);\n      this.valueChange.emit(this.value);\n    }\n\n    resolveDataItemFromTags(value) {\n      if (!(this.tags && this.tags.length && isPresent(value))) {\n        return undefined;\n      } // Flattening the tags array in case of a summary tag occurrence.\n\n\n      const tags = this.tags.reduce((acc, tag) => {\n        const items = isArray(tag) ? tag : [tag];\n        acc.push(...items);\n        return acc;\n      }, []);\n      return tags.find(tag => getter(tag, this.valueField) === getter(value, this.valueField));\n    }\n\n    firstFocusableIndex(index) {\n      const maxIndex = this.dataService.itemsCount;\n\n      if (this.disabledItemsService.isIndexDisabled(index)) {\n        const nextIndex = index + 1;\n        return nextIndex < maxIndex ? this.firstFocusableIndex(nextIndex) : undefined;\n      } else {\n        return index;\n      }\n    }\n\n    nextTick(f) {\n      this._zone.runOutsideAngular(() => {\n        // Use `setTimeout` instead of a resolved promise\n        // because the latter does not wait long enough.\n        setTimeout(() => this._zone.run(f));\n      });\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n\n  }\n\n  MultiSelectComponent.ɵfac = function MultiSelectComponent_Factory(t) {\n    return new (t || MultiSelectComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  MultiSelectComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MultiSelectComponent,\n    selectors: [[\"kendo-multiselect\"]],\n    contentQueries: function MultiSelectComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, CustomItemTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n      }\n    },\n    viewQuery: function MultiSelectComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(SearchBarComponent, 7);\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(_c10, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsList = _t.first);\n      }\n    },\n    hostVars: 11,\n    hostBindings: function MultiSelectComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function MultiSelectComponent_mousedown_HostBindingHandler($event) {\n          return ctx.hostMousedown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx.dir)(\"role\", ctx.role)(\"aria-expanded\", ctx.isAriaExpanded);\n        i0.ɵɵclassProp(\"k-multiselect\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-disabled\", ctx.disabledClass)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      focusableId: \"focusableId\",\n      autoClose: \"autoClose\",\n      loading: \"loading\",\n      data: \"data\",\n      value: \"value\",\n      valueField: \"valueField\",\n      textField: \"textField\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      placeholder: \"placeholder\",\n      disabled: \"disabled\",\n      itemDisabled: \"itemDisabled\",\n      checkboxes: \"checkboxes\",\n      readonly: \"readonly\",\n      filterable: \"filterable\",\n      virtual: \"virtual\",\n      popupSettings: \"popupSettings\",\n      listHeight: \"listHeight\",\n      valuePrimitive: \"valuePrimitive\",\n      clearButton: \"clearButton\",\n      tagMapper: \"tagMapper\",\n      allowCustom: \"allowCustom\",\n      valueNormalizer: \"valueNormalizer\"\n    },\n    outputs: {\n      filterChange: \"filterChange\",\n      valueChange: \"valueChange\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      removeTag: \"removeTag\"\n    },\n    exportAs: [\"kendoMultiSelect\"],\n    features: [i0.ɵɵProvidersFeature([MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiselect'\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => MultiSelectComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => MultiSelectComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 11,\n    vars: 27,\n    consts: function () {\n      let i18n_31;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multiselect.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_32 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_31 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_32;\n      } else {\n        i18n_31 = $localize`:kendo.multiselect.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_33;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multiselect.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_34 = goog.getMsg(\"clear\");\n        i18n_33 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_34;\n      } else {\n        i18n_33 = $localize`:kendo.multiselect.clearTitle|The title of the clear button:clear`;\n      }\n\n      return [[\"kendoMultiSelectLocalizedMessages\", \"\", \"noDataText\", i18n_31, \"clearTitle\", i18n_33], [3, \"size\", \"rounded\", \"fillMode\", \"id\", \"tags\", \"textField\", \"valueField\", \"focused\", \"disabled\", \"template\", \"groupTemplate\", \"tagPrefix\", \"disabledIndices\", \"removeTag\"], [3, \"id\", \"role\", \"tagListId\", \"activeDescendant\", \"noDataLabel\", \"userInput\", \"disabled\", \"readonly\", \"tabIndex\", \"popupOpen\", \"placeholder\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\"], [\"searchbar\", \"\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"visibility\", \"mousedown\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [3, \"ngIf\"], [\"container\", \"\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"mousedown\"], [1, \"k-icon\", \"k-i-x\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [4, \"ngIf\"], [\"class\", \"k-list\", 3, \"ngClass\", 4, \"ngIf\"], [3, \"size\", \"rounded\", \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"height\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"show\", \"multipleSelection\", \"virtual\", \"checkboxes\", \"pageChange\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [1, \"k-list\", 3, \"ngClass\"], [\"kendoDropDownsSelectable\", \"\", 1, \"k-list-item\", \"k-custom-item\", 3, \"multipleSelection\", \"index\"], [4, \"ngIf\", \"ngIfElse\"], [\"default_custom_item_template\", \"\"], [1, \"k-icon\", \"k-i-plus\", 2, \"float\", \"right\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"resize\"]];\n    },\n    template: function MultiSelectComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-taglist\", 1);\n        i0.ɵɵlistener(\"removeTag\", function MultiSelectComponent_Template_kendo_taglist_removeTag_1_listener($event) {\n          return ctx.handleRemoveTag($event);\n        });\n        i0.ɵɵelementStart(2, \"kendo-searchbar\", 2, 3);\n        i0.ɵɵlistener(\"onNavigate\", function MultiSelectComponent_Template_kendo_searchbar_onNavigate_2_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function MultiSelectComponent_Template_kendo_searchbar_valueChange_2_listener($event) {\n          return ctx.handleFilter($event);\n        })(\"onBlur\", function MultiSelectComponent_Template_kendo_searchbar_onBlur_2_listener() {\n          return ctx.onSearchBarBlur();\n        })(\"onFocus\", function MultiSelectComponent_Template_kendo_searchbar_onFocus_2_listener() {\n          return ctx.onSearchBarFocus();\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(4, MultiSelectComponent_span_4_Template, 2, 3, \"span\", 4);\n        i0.ɵɵtemplate(5, MultiSelectComponent_span_5_Template, 1, 0, \"span\", 5);\n        i0.ɵɵtemplate(6, MultiSelectComponent_ng_template_6_Template, 6, 19, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, MultiSelectComponent_ng_template_8_Template, 1, 0, \"ng-template\", 7);\n        i0.ɵɵelementContainer(9, null, 8);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"id\", ctx.tagListId)(\"tags\", ctx.tags)(\"textField\", ctx.textField)(\"valueField\", ctx.valueField)(\"focused\", ctx.focusedTagIndex)(\"disabled\", ctx.disabled)(\"template\", ctx.tagTemplate)(\"groupTemplate\", ctx.groupTagTemplate)(\"tagPrefix\", ctx.tagPrefix)(\"disabledIndices\", ctx.disabledIndices);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.focusableId)(\"role\", \"textbox\")(\"tagListId\", ctx.tagListId)(\"activeDescendant\", ctx.activeDescendant)(\"noDataLabel\", ctx.noDataLabel)(\"userInput\", ctx.text)(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"tabIndex\", ctx.tabIndex)(\"popupOpen\", ctx.isOpen)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && ((ctx.tags == null ? null : ctx.tags.length) || (ctx.text == null ? null : ctx.text.length)));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    directives: [TagListComponent, SearchBarComponent, ListComponent, i9.ResizeSensorComponent, LocalizedMessagesDirective, i11.NgIf, TemplateContextDirective, i11.NgClass, SelectableDirective],\n    encapsulation: 2\n  });\n  return MultiSelectComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the column cell content of the MultiColumnComboBox. To define a column cell template, nest an `<ng-template>` tag\n * with the `kendoMultiColumnComboBoxColumnCellTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag\n * ([see example]({% slug templates_multicolumncombobox %})).\n *\n * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) and data item are available as context variables:\n *\n * - `let-dataItem=\"dataItem\"` (`any`) - The current data item. Also available as implicit context variable.\n * - `let-column=\"column\"` ([`ColumnComponent`]({% slug api_dropdowns_comboboxcolumncomponent %})) - The current column configuration obejct.\n */\n\n\nlet ColumnCellTemplateDirective = /*#__PURE__*/(() => {\n  class ColumnCellTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ColumnCellTemplateDirective.ɵfac = function ColumnCellTemplateDirective_Factory(t) {\n    return new (t || ColumnCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  ColumnCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnCellTemplateDirective,\n    selectors: [[\"\", \"kendoMultiColumnComboBoxColumnCellTemplate\", \"\"]]\n  });\n  return ColumnCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the column header content of the MultiColumnComboBox. To define a column header template, nest an `<ng-template>` tag\n * with the `kendoMultiColumnComboBoxColumnHeaderTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag\n * ([see example]({% slug templates_multicolumncombobox %})).\n *\n * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) is available as implicit context variable.\n */\n\n\nlet ColumnHeaderTemplateDirective = /*#__PURE__*/(() => {\n  class ColumnHeaderTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  ColumnHeaderTemplateDirective.ɵfac = function ColumnHeaderTemplateDirective_Factory(t) {\n    return new (t || ColumnHeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  ColumnHeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ColumnHeaderTemplateDirective,\n    selectors: [[\"\", \"kendoMultiColumnComboBoxColumnHeaderTemplate\", \"\"]]\n  });\n  return ColumnHeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the column definition of the [MultiColumnComboBox]({% slug overview_multicolumncombobox %})\n * ([see example]({% slug columns_multicolumncombobox %})).\n */\n\n\nlet ComboBoxColumnComponent = /*#__PURE__*/(() => {\n  class ComboBoxColumnComponent {\n    constructor() {\n      /**\n       * Sets the visibility of the column.\n       *\n       * @default false\n       */\n      this.hidden = false;\n      /**\n       * @hidden\n       */\n\n      this.matchesMedia = true;\n    }\n\n  }\n\n  ComboBoxColumnComponent.ɵfac = function ComboBoxColumnComponent_Factory(t) {\n    return new (t || ComboBoxColumnComponent)();\n  };\n\n  ComboBoxColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ComboBoxColumnComponent,\n    selectors: [[\"kendo-combobox-column\"]],\n    contentQueries: function ComboBoxColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ColumnCellTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ColumnHeaderTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n      }\n    },\n    inputs: {\n      field: \"field\",\n      title: \"title\",\n      width: \"width\",\n      hidden: \"hidden\",\n      style: \"style\",\n      headerStyle: \"headerStyle\",\n      class: \"class\",\n      headerClass: \"headerClass\",\n      media: \"media\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ComboBoxColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ComboBoxColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Persists the intially resolved scrollbar width value.\n */\n\n\nlet SCROLLBAR_WIDTH;\n/**\n * @hidden\n *\n * Gets the default scrollbar width accoring to the current environment.\n */\n\nconst scrollbarWidth = () => {\n  // calculate scrollbar width only once, then return the memoized value\n  if (isNaN(SCROLLBAR_WIDTH)) {\n    const div = document.createElement('div');\n    div.style.cssText = 'overflow: scroll; overflow-x: hidden; zoom: 1; clear: both; display: block;';\n    div.innerHTML = '&nbsp;';\n    document.body.appendChild(div);\n    SCROLLBAR_WIDTH = div.offsetWidth - div.scrollWidth;\n    document.body.removeChild(div);\n  }\n\n  return SCROLLBAR_WIDTH;\n};\n/**\n * Checks if all columns have a valid user-defined width.\n */\n\n\nconst allColumnsWidthsSet = columns => {\n  if (!isPresent(columns) || columns.length === 0) {\n    return false;\n  }\n\n  return columns.toArray().every(column => !isNaN(column.width) && column.width > 0);\n};\n/**\n * @hidden\n *\n * Calculates the row width according to the passed columns width configuration.\n * Hidden columns and such that don't match the provided media query are ignored.\n * If some of the columns don't have a preset width or have an invalid width value, the function returns `null`.\n */\n\n\nconst getRowWidthFromColumnsMeta = columns => {\n  if (!allColumnsWidthsSet(columns)) {\n    return null;\n  }\n\n  const bordersWidth = 2;\n  const initialRowWidht = scrollbarWidth() + bordersWidth;\n  return columns.reduce((totalWidth, column) => {\n    if (!column.hidden && column.matchesMedia) {\n      totalWidth += parseInt(column.width, 10);\n    }\n\n    return totalWidth;\n  }, initialRowWidht);\n};\n/**\n * Represents the [Kendo UI MultiColumnComboBox component for Angular]({% slug overview_multicolumncombobox %}).\n */\n\n\nlet MultiColumnComboBoxComponent = /*#__PURE__*/(() => {\n  class MultiColumnComboBoxComponent extends ComboBoxComponent {\n    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, wrapper, touchEnabled) {\n      super(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, touchEnabled);\n      /**\n       * @hidden\n       */\n\n      this.hostClasses = true;\n      this.removeWindowResizeListener = noop; // the row height in @progress/kendo-theme-default\n\n      this.defaultVirtualItemHeight = 36; // use a smaller virtual page size as columns with multiple cells can cause poor performance\n\n      this.defaultVirtualPageSize = 30;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDisabled() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set header(header) {\n      // updates the header padding on initial render as the resize senzor doesn't kick in as early\n      this.updateHeaderPadding(header && header.nativeElement);\n    }\n\n    get popupWidth() {\n      const wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;\n      const min = `${wrapperOffsetWidth}px`;\n      const width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;\n      const max = isNaN(width) ? width : `${width}px`;\n      return {\n        min,\n        max\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get tableSizeClass() {\n      return `${this.size ? getSizeClass('table', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get listContainerClasses() {\n      return ['k-popup', 'k-dropdowngrid-popup'].concat(this.popupSettings.popupClass || []);\n    }\n\n    ngAfterViewInit() {\n      this.updateColumnsMediaState();\n      this.addWindowResizeListener();\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.removeWindowResizeListener();\n    }\n    /**\n     * @hidden\n     */\n\n\n    textFrom(dataItem, field) {\n      return getter(dataItem, field);\n    }\n    /**\n     * @hidden\n     *\n     * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.\n     * As when the items container has a scrollbar, the column headers and the cells are misaligned.\n     * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.\n     */\n\n\n    updateHeaderPadding(header) {\n      if (!isPresent(header)) {\n        return;\n      } // the scrollbar is rendered on the left in rtl\n\n\n      const headerPaddingPosition = this.localization.rtl ? 'padding-left' : 'padding-right';\n\n      if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {\n        this.renderer.setStyle(header, headerPaddingPosition, `${scrollbarWidth()}px`);\n      } else {\n        this.renderer.removeStyle(header, headerPaddingPosition);\n      }\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (isPresent(this.data) && this.data.length > 0 && this.data.some(item => !isObject(item))) {\n        throw new Error(MultiColumnComboBoxMessages.data);\n      }\n\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(MultiColumnComboBoxMessages.textAndValue);\n      }\n\n      super.verifySettings();\n    }\n\n    addWindowResizeListener() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => this.removeWindowResizeListener = this.renderer.listen(window, 'resize', this.updateColumnsMediaState.bind(this)));\n    }\n\n    updateColumnsMediaState() {\n      if (!(isPresent(this.columns) && isDocumentAvailable())) {\n        return;\n      }\n\n      this.columns.forEach(column => {\n        const matchesMedia = !column.media || window.matchMedia(column.media).matches;\n\n        if (column.matchesMedia !== matchesMedia) {\n          column.matchesMedia = matchesMedia;\n\n          if (this.isOpen) {\n            // enter the zone only if the popup is actually open\n            // update its width in case it's dependent on the columns' width\n            this.zone.run(() => this.popupRef.popupElement.style.width = this.popupWidth.max);\n          }\n        }\n      });\n    }\n\n  }\n\n  MultiColumnComboBoxComponent.ɵfac = function MultiColumnComboBoxComponent_Factory(t) {\n    return new (t || MultiColumnComboBoxComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(DisabledItemsService), i0.ɵɵdirectiveInject(DataService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TOUCH_ENABLED));\n  };\n\n  MultiColumnComboBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MultiColumnComboBoxComponent,\n    selectors: [[\"kendo-multicolumncombobox\"]],\n    contentQueries: function MultiColumnComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ComboBoxColumnComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columns = _t);\n      }\n    },\n    viewQuery: function MultiColumnComboBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function MultiColumnComboBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-dropdowngrid\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([SelectionService, DataService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multicolumncombobox'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultiColumnComboBoxComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => MultiColumnComboBoxComponent)\n    }, {\n      provide: FilterableComponent,\n      useExisting: forwardRef(() => MultiColumnComboBoxComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 12,\n    vars: 20,\n    consts: function () {\n      let i18n_36;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multicolumncombobox.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_37 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_36 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_37;\n      } else {\n        i18n_36 = $localize`:kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_38;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multicolumncombobox.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_39 = goog.getMsg(\"clear\");\n        i18n_38 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_39;\n      } else {\n        i18n_38 = $localize`:kendo.multicolumncombobox.clearTitle|The title of the clear button:clear`;\n      }\n\n      return [[\"kendoMultiColumnComboBoxLocalizedMessages\", \"\", \"noDataText\", i18n_36, \"clearTitle\", i18n_38], [3, \"role\", \"id\", \"listId\", \"activeDescendant\", \"noDataLabel\", \"userInput\", \"suggestedText\", \"disabled\", \"readonly\", \"tabIndex\", \"popupOpen\", \"placeholder\", \"onNavigate\", \"valueChange\", \"onBlur\", \"onFocus\"], [\"searchbar\", \"\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"kendoEventsOutsideAngular\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"aria-hidden\", \"true\", \"unselectable\", \"on\", \"type\", \"button\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\", \"kendoEventsOutsideAngular\"], [\"select\", \"\"], [1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"popupTemplate\", \"\"], [3, \"resize\", 4, \"ngIf\"], [\"container\", \"\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"kendoEventsOutsideAngular\", \"click\"], [1, \"k-icon\", \"k-i-x\"], [4, \"ngIf\"], [1, \"k-data-table\", 3, \"ngClass\"], [1, \"k-table-header\"], [\"header\", \"\"], [1, \"k-table-header-wrap\"], [\"role\", \"presentation\", 1, \"k-table\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-table-thead\"], [1, \"k-table-row\"], [\"rowTemplate\", \"\"], [3, \"id\", \"optionPrefix\", \"data\", \"textField\", \"valueField\", \"template\", \"groupTemplate\", \"fixedGroupTemplate\", \"height\", \"show\", \"virtual\", \"type\", \"pageChange\", \"listResize\"], [\"optionsList\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [3, \"templateContext\"], [3, \"width\", 4, \"ngIf\"], [\"class\", \"k-table-th\", 3, \"ngStyle\", \"ngClass\", 4, \"ngIf\"], [1, \"k-table-th\", 3, \"ngStyle\", \"ngClass\"], [\"class\", \"k-table-td\", 3, \"ngClass\", \"width\", \"ngStyle\", 4, \"ngIf\"], [1, \"k-table-td\", 3, \"ngClass\", \"ngStyle\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"], [1, \"k-table-footer\"], [1, \"k-table\"], [1, \"k-table-tfoot\"], [1, \"k-table-td\"], [3, \"resize\"]];\n    },\n    template: function MultiColumnComboBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-searchbar\", 1, 2);\n        i0.ɵɵlistener(\"onNavigate\", function MultiColumnComboBoxComponent_Template_kendo_searchbar_onNavigate_1_listener($event) {\n          return ctx.handleNavigate($event);\n        })(\"valueChange\", function MultiColumnComboBoxComponent_Template_kendo_searchbar_valueChange_1_listener($event) {\n          return ctx.searchBarChange($event);\n        })(\"onBlur\", function MultiColumnComboBoxComponent_Template_kendo_searchbar_onBlur_1_listener() {\n          return ctx.handleBlur();\n        })(\"onFocus\", function MultiColumnComboBoxComponent_Template_kendo_searchbar_onFocus_1_listener() {\n          return ctx.handleFocus();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, MultiColumnComboBoxComponent_span_3_Template, 2, 6, \"span\", 3);\n        i0.ɵɵelementStart(4, \"button\", 4, 5);\n        i0.ɵɵelement(6, \"span\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, MultiColumnComboBoxComponent_ng_template_7_Template, 17, 20, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, MultiColumnComboBoxComponent_kendo_resize_sensor_9_Template, 1, 0, \"kendo-resize-sensor\", 8);\n        i0.ɵɵelementContainer(10, null, 9);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"role\", \"combobox\")(\"id\", ctx.focusableId)(\"listId\", ctx.listBoxId)(\"activeDescendant\", ctx.activeDescendant)(\"noDataLabel\", ctx.noDataLabel)(\"userInput\", ctx.text)(\"suggestedText\", ctx.getSuggestion())(\"disabled\", ctx.disabled)(\"readonly\", ctx.readonly)(\"tabIndex\", ctx.tabIndex)(\"popupOpen\", ctx.isOpen)(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.clearButton && !ctx.loading && !ctx.disabled && !ctx.readonly && (ctx.text == null ? null : ctx.text.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses)(\"kendoEventsOutsideAngular\", i0.ɵɵpureFunction1(18, _c23, ctx.preventEventDefault));\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", ctx.buttonClasses);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isOpen);\n      }\n    },\n    directives: [SearchBarComponent, ListComponent, i9.ResizeSensorComponent, LocalizedMessagesDirective, i11.NgIf, i9.EventsOutsideAngularDirective, i11.NgClass, TemplateContextDirective, i11.NgForOf, i11.NgStyle],\n    encapsulation: 2\n  });\n  return MultiColumnComboBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Renders the content of each node in the DropDownTree. To define a node template, nest an `<ng-template>` tag\n * with the `kendoDropDownTreeNodeTemplate` directive inside the `<kendo-dropdowntree>` tag.\n *\n * The current data item and hierarchical index are available as context variables:\n *\n * - `let-dataItem` (`any`) - The current data item. Available as implicit context variable.\n * - `let-index=\"index\"` (`string`) - The current item hierarchical index.\n */\n\n\nlet NodeTemplateDirective = /*#__PURE__*/(() => {\n  class NodeTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  NodeTemplateDirective.ɵfac = function NodeTemplateDirective_Factory(t) {\n    return new (t || NodeTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  NodeTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NodeTemplateDirective,\n    selectors: [[\"\", \"kendoDropDownTreeNodeTemplate\", \"\"], [\"\", \"kendoMultiSelectTreeNodeTemplate\", \"\"]]\n  });\n  return NodeTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_POPUP_SETTINGS$1 = {\n  animate: true\n};\n\nconst hasChildren$1 = () => false;\n\nconst fetchChildren$1 = () => of([]);\n\nconst itemDisabled$1 = () => false;\n\nconst isNodeVisible$1 = () => true;\n\nconst DEFAULT_SIZE$1 = 'medium';\nconst DEFAULT_ROUNDED$1 = 'medium';\nconst DEFAULT_FILL_MODE$1 = 'solid';\n/**\n * Represents the [Kendo UI DropDownTree component for Angular]({% slug overview_ddt %}).\n */\n\nlet DropDownTreeComponent = /*#__PURE__*/(() => {\n  class DropDownTreeComponent {\n    constructor(wrapper, popupService, navigationService, renderer, _zone, cdr, localization, touchEnabled) {\n      this.wrapper = wrapper;\n      this.popupService = popupService;\n      this.navigationService = navigationService;\n      this.renderer = renderer;\n      this._zone = _zone;\n      this.cdr = cdr;\n      this.localization = localization;\n      this.touchEnabled = touchEnabled;\n      this.hostClasses = true;\n      this.role = 'listbox';\n      this.ariaHasPopup = 'tree';\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_ddt %})).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_ddt %})).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires when the user expands a node in the popup TreeView.\n       */\n\n      this.nodeExpand = new EventEmitter();\n      /**\n       * Fires when the user collapses a node in the popup TreeView.\n       */\n\n      this.nodeCollapse = new EventEmitter();\n      /**\n       * Fires each time the user focuses the DropDownTree.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the DropDownTree gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the value is changed\n       * ([see example]({% slug overview_ddt %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       */\n\n      this.clearButton = true;\n      /**\n       * A function which determines if a specific node has child nodes.\n       */\n\n      this.hasChildren = hasChildren$1;\n      /**\n       * A function which provides the child nodes for a given parent node.\n       */\n\n      this.fetchChildren = fetchChildren$1;\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n\n      this.placeholder = \"\";\n      /**\n       * Sets the height of the options list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of options and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the type of the selected value\n       * ([more information and example]({% slug valuebinding_ddt %}#toc-primitive-values)).\n       * If set to `true`, the selected value has to be of a primitive value.\n       */\n\n      this.valuePrimitive = false;\n      /**\n       * A function that is executed for each data item and determines if a specific item is disabled.\n       */\n\n      this.itemDisabled = itemDisabled$1;\n      /**\n       * A callback which determines whether a tree node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n\n      this.isNodeVisible = isNodeVisible$1;\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default true\n       */\n\n      this.loadOnDemand = true;\n      /**\n       * Renders the built-in input element for filtering the DropDownTree.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the DropDownTree manually]({% slug filtering_ddt %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoDropDownTreeHierarchyBinding`]({% slug api_dropdowns_dropdowntreehierarchybindingdirective %}) and [`kendoDropDownTreeFlatBinding`]({% slug api_dropdowns_dropdowntreeflatbindingdirective %}) directives.\n       */\n\n      this.filterable = false;\n      /**\n       * @hidden\n       */\n\n      this.filter = '';\n      /**\n       * @hidden\n       *\n       * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.\n       */\n\n      this.focusableId = `k-${guid$1()}`;\n      /**\n       * @hidden\n       */\n\n      this.selectedKeys = [];\n      /**\n       * @hidden\n       */\n\n      this.filterStateChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.allNodesHidden = false;\n      /**\n       * @hidden\n       *\n       * Used to associate the value label with the wrapper via aria-describedby.\n       */\n\n      this.valueLabelId = `k-${guid$1()}`;\n      this._popupSettings = DEFAULT_POPUP_SETTINGS$1;\n      this._tabindex = 0;\n      this._isFocused = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      this.subscriptions = [];\n      this.onTouchedCallback = noop;\n      this.onChangeCallback = noop;\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeTouchEvents();\n      this.subscribeFocusEvents();\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get id() {\n      return this.focusableId;\n    }\n\n    get hostTabIndex() {\n      return this.tabindex;\n    }\n\n    get isAriaExpanded() {\n      return this.isOpen;\n    }\n\n    get isReadonly() {\n      return this.readonly;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleClick() {\n      this.togglePopup(!this.isOpen);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeydown(event) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      const eventData = event;\n      this.navigationService.process({\n        originalEvent: eventData\n      });\n    }\n\n    set treeview(treeview) {\n      if (treeview) {\n        if (this.isFocused && !this.filterable || this.touchEnabled) {\n          treeview.focus();\n        } // the treeview animations are initially disabled (we don't want expand animations during popup opening)\n        // re-enables the animations for user interaction\n\n\n        treeview.animate = true;\n        this._treeview = treeview;\n      }\n    }\n\n    get treeview() {\n      return this._treeview;\n    }\n    /**\n     * Sets the data of the DropDownTree.\n     *\n     * > The data has to be provided in an array-like list with objects.\n     */\n\n\n    set data(data) {\n      this._nodes = data;\n      this.setState();\n    }\n\n    get data() {\n      return this._nodes;\n    }\n    /**\n     * Sets the value of the DropDownTree.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     */\n\n\n    set value(newValue) {\n      this._value = newValue;\n      this.setState();\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Configures the popup of the DropDownTree.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS$1, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Keeps the current `dataItem` object in order to resolve selection.\n     * Needs to be provided when `value` is bound in and `valuePrimitive` is set to true.\n     */\n\n\n    set dataItem(item) {\n      this._dataItem = item;\n      this.setState();\n    }\n\n    get dataItem() {\n      return this._dataItem ? this._dataItem : this.value;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n\n    set tabindex(value) {\n      const providedTabIndex = Number(value);\n      const defaultTabIndex = 0;\n      this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n\n    get tabindex() {\n      return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n\n    get width() {\n      const wrapperWidth = this.wrapper.nativeElement.offsetWidth;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n\n    get clearButtonVisiblity() {\n      if (this.touchEnabled) {\n        return 'visible';\n      }\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    set isExpanded(callback) {\n      this.isNodeExpanded = callback;\n    }\n\n    get isExpanded() {\n      return this.isNodeExpanded;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    get expand() {\n      return this.nodeExpand;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    get collapse() {\n      return this.nodeCollapse;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives.\n     */\n\n\n    set nodes(nodes) {\n      this.data = nodes;\n    }\n\n    get nodes() {\n      return this.data;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives\n     */\n\n\n    set children(callback) {\n      this.fetchChildren = callback;\n    }\n\n    get children() {\n      return this.fetchChildren;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.\n     * The `DataBoundComponent` interface is used in the data-binding directives.\n     */\n\n\n    set isVisible(callback) {\n      this.isNodeVisible = callback;\n    }\n\n    get isVisible() {\n      return this.isNodeVisible;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.assignAriaDescribedBy();\n      this.subscriptions.push(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      }));\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.setState();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * @hidden\n     *\n     * Used by the kendo-floatinglabel component to determine if the floating label\n     * should be rendered inside the input when the component is not focused.\n     */\n\n\n    isEmpty() {\n      return !this.text && !this.placeholder;\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const togglePrevented = this.triggerPopupEvents(open);\n\n      if (!togglePrevented) {\n        if (open) {\n          this.createPopup();\n        } else {\n          this.destroyPopup();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n\n      if (!this.isFocused) {\n        this.isFocused = true;\n\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(e) {\n      const relatedTarget = e && e.relatedTarget;\n\n      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {\n        return;\n      }\n\n      this.isFocused = false;\n\n      if (hasObservers(this.onBlur) || isUntouched(this.wrapper.nativeElement)) {\n        this._zone.run(() => {\n          this.togglePopup(false);\n          this.onBlur.emit();\n          this.onTouchedCallback();\n        });\n      } else {\n        this.togglePopup(false);\n      }\n    }\n    /**\n     * Focuses a specific item of the DropDownTree based on a provided index in the format of `1_1`.\n     * The targeted item should be expanded in order for it to be focused.\n     * If null or invalid index is provided the focus will be set on the first item.\n     */\n\n\n    focusItemAt(index) {\n      if (this.treeview) {\n        const lookup = this.treeview.itemLookup(index);\n        let isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);\n\n        if (!isItemDisabled) {\n          this.treeview.focus(index);\n        }\n      }\n    }\n    /**\n     * Focuses the DropDownTree.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the DropDownTree.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n      }\n    }\n    /**\n     * Resets the value of the DropDownTree.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `valueChange` event will not be fired.\n     */\n\n\n    reset() {\n      this.value = undefined;\n      this.dataItem = undefined;\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_ddt %})).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"ViewContainerRef not found...\" error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !isPresent(this.popupRef);\n        this.destroyPopup();\n\n        if (shouldOpen) {\n          this.createPopup();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    get popupContainerClasses() {\n      const containerClasses = ['k-popup-dropdowntree'];\n\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onSelectionChange({\n      dataItem,\n      index\n    }) {\n      this.valueDepth = index.split('_').length - 1;\n      const valueField = this.getField(this.valueField, dataItem);\n      const newValue = this.valuePrimitive ? getter$1(valueField)(dataItem) : dataItem;\n      const shouldUpdateValue = newValue !== this.value;\n\n      if (shouldUpdateValue) {\n        this.value = newValue;\n        this.dataItem = dataItem;\n        this.emitValueChange(this.value);\n      }\n\n      this.togglePopup(false);\n      this.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearValue(event) {\n      event.stopImmediatePropagation();\n      this.focus();\n      this.value = undefined;\n      this.dataItem = undefined;\n      this.clearState();\n      this.valueChange.emit(undefined);\n      this.emitValueChange();\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n\n\n    preventEventDefault(event) {\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      // If the user resets the value by providing null/undefined we need to reset the `dataItem`\n      // Because upon initialization of the component the `writeValue` is being called twice -\n      // first time with `null` value regardless of sync/async value - an extra check is added to\n      // distinguish between client reset and initial phanotm 'null' value\n      if (!isPresent(value) && isPresent(this.value)) {\n        this.dataItem = null;\n      }\n\n      this.value = value === null ? undefined : value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilterInputChange(input) {\n      this.filterChange.next(input.value);\n      this.allNodesHidden = this.nodes.every((node, index) => !this.isVisible(node, String(index)));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get buttonClasses() {\n      return this.loading ? 'k-i-loading k-input-loading-icon' : 'k-i-arrow-s';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selectButtonClasses() {\n      return `${this.size ? getSizeClass('button', this.size) : ''} ${this.fillMode ? 'k-button-' + this.fillMode : ''} ${this.fillMode ? 'k-button-' + this.fillMode + '-base' : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === \"object\") {\n        throw new Error(DropDownTreeMessages.primitive);\n      }\n\n      if (this.valuePrimitive === true && isPresent(this.value) && typeof this.dataItem !== \"object\") {\n        throw new Error(DropDownTreeMessages.dataItem);\n      }\n\n      if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== \"object\") {\n        throw new Error(DropDownTreeMessages.object);\n      }\n\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(DropDownTreeMessages.textAndValue);\n      }\n\n      if ((isArray(this.valueField) || isArray(this.textField)) && isPresent(this.value) && !isPresent(this.valueDepth)) {\n        throw new Error(DropDownTreeMessages.valueDepth);\n      }\n    }\n\n    emitValueChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n\n    getText(textField, dataItem) {\n      if (isPresent(dataItem) && isPresent(textField)) {\n        const field = this.getField(textField, dataItem);\n        return getter$1(field)(dataItem);\n      }\n\n      return null;\n    }\n    /**\n     * @hidden\n     *\n     * Determines the `valueField` and `textField` for a specific level in the data set\n     *  @param field - the field value (string | string[])\n     *  @param value - current value\n     */\n\n\n    getField(field, value) {\n      const fieldsCount = field.length - 1;\n\n      if (typeof field === 'string') {\n        // If the `valueField` | `textField` is the same for all levels\n        return field;\n      } else if (isPresent(this.valueDepth)) {\n        // When `valueDepth` can be defined from the index on selectionChange or provided by the user\n        return fieldsCount < this.valueDepth ? field[fieldsCount] : field[this.valueDepth];\n      } else {\n        // Fallback: Look to find a match of each field in the current data item\n        // Side effect may occur if all of the listed fields are present in the data item\n        return field.find(item => item in value);\n      }\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    createPopup() {\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'bottom'\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'top'\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        appendTo: this.appendTo,\n        anchorAlign: anchorPosition,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        positionMode: 'absolute',\n        popupClass: this.popupContainerClasses\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      popupWrapper.setAttribute(\"dir\", this.direction);\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n\n        if (this.filter !== \"\") {\n          this.filter = \"\";\n          this.allNodesHidden = false;\n\n          if (hasObservers(this.filterChange)) {\n            this._zone.run(() => {\n              this.filterChange.emit(\"\");\n            });\n          }\n        }\n      }\n    }\n\n    handleEscape() {\n      this.togglePopup(false);\n      this.focus();\n    }\n\n    setState() {\n      if (isPresent(this.value) && isPresent(this.dataItem) && isPresent(this.valueField)) {\n        this.text = this.getText(this.textField, this.dataItem);\n        const valueField = this.getField(this.valueField, this.dataItem);\n        this.selectBy = valueField;\n        this.selectedKeys = [getter$1(valueField)(this.dataItem)];\n      } else {\n        this.clearState();\n      }\n\n      this.cdr.markForCheck();\n    }\n\n    clearState() {\n      this.text = undefined;\n      this.selectedKeys = [];\n    }\n\n    subscribeEvents() {\n      this.subscriptions.push(this.navigationService.open.subscribe(() => this.togglePopup(true)), this.navigationService.close.subscribe(() => {\n        this.togglePopup(false);\n        this.focus();\n      }), this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(() => this.togglePopup(true)), this.navigationService.esc.subscribe(() => this.handleEscape()), this.navigationService.tab.subscribe(() => this.focus()), this.navigationService.down.subscribe(event => {\n        if (!this.treeview) {\n          return;\n        }\n\n        event.originalEvent.preventDefault();\n\n        if (!this.treeview.isActive) {\n          this.treeview.focus();\n        }\n      }), this.navigationService.up.subscribe(event => {\n        if (!this.treeview) {\n          return;\n        }\n\n        event.originalEvent.preventDefault();\n\n        if (this.filterable && this.treeview['navigationService']['activeIndex'] === '0') {\n          this.filterInput.nativeElement.focus();\n        }\n      }));\n    }\n\n    subscribeTouchEvents() {\n      if (!isDocumentAvailable() || !this.touchEnabled) {\n        return;\n      }\n\n      this._zone.runOutsideAngular(() => // Roll up DropDownTree on iOS when tapped outside\n      this.touchstartDisposeHandler = this.renderer.listen(document, 'touchstart', e => {\n        const target = e.target;\n\n        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {\n          this._zone.run(() => {\n            if (this.isOpen) {\n              this.treeview.blur();\n            }\n\n            this.blur();\n          });\n        }\n      }));\n    }\n\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.handleFocus = this.handleFocus.bind(this);\n        this.handleDocumentBlur = this.handleDocumentBlur.bind(this);\n\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.handleFocus, useCapture);\n          document.addEventListener('blur', this.handleDocumentBlur, useCapture);\n        });\n      }\n    }\n\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.handleFocus, useCapture);\n        document.removeEventListener('blur', this.handleDocumentBlur, useCapture);\n      }\n    }\n\n    unsubscribeEvents() {\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n      this.unSubscribeFocusEvents();\n\n      if (this.touchstartDisposeHandler) {\n        this.touchstartDisposeHandler();\n      }\n    }\n\n    handleDocumentBlur(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n      this.handleBlur(event);\n    }\n\n    assignAriaDescribedBy() {\n      const currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || ''; // add to the current value - don't replace it (the aria-describedby is used by the FormField component as well)\n\n      const newValue = `${this.valueLabelId} ${currentValue.trim()}`.trim();\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('picker', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('picker', this.fillMode));\n      }\n    }\n\n  }\n\n  DropDownTreeComponent.ɵfac = function DropDownTreeComponent_Factory(t) {\n    return new (t || DropDownTreeComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  DropDownTreeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropDownTreeComponent,\n    selectors: [[\"kendo-dropdowntree\"]],\n    contentQueries: function DropDownTreeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);\n      }\n    },\n    viewQuery: function DropDownTreeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c42, 5);\n        i0.ɵɵviewQuery(_c43, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeview = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);\n      }\n    },\n    hostVars: 17,\n    hostBindings: function DropDownTreeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function DropDownTreeComponent_click_HostBindingHandler() {\n          return ctx.handleClick();\n        })(\"keydown\", function DropDownTreeComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"id\", ctx.id)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabIndex)(\"role\", ctx.role)(\"aria-haspopup\", ctx.ariaHasPopup)(\"aria-expanded\", ctx.isAriaExpanded)(\"readonly\", ctx.isReadonly)(\"aria-readonly\", ctx.isReadonly);\n        i0.ɵɵclassProp(\"k-dropdowntree\", ctx.hostClasses)(\"k-picker\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      loading: \"loading\",\n      clearButton: \"clearButton\",\n      data: \"data\",\n      value: \"value\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      hasChildren: \"hasChildren\",\n      fetchChildren: \"fetchChildren\",\n      placeholder: \"placeholder\",\n      popupSettings: \"popupSettings\",\n      dataItem: \"dataItem\",\n      listHeight: \"listHeight\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      valuePrimitive: \"valuePrimitive\",\n      tabindex: \"tabindex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      itemDisabled: \"itemDisabled\",\n      isNodeExpanded: \"isNodeExpanded\",\n      isNodeVisible: \"isNodeVisible\",\n      loadOnDemand: \"loadOnDemand\",\n      filterable: \"filterable\",\n      filter: \"filter\",\n      focusableId: \"focusableId\"\n    },\n    outputs: {\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      nodeExpand: \"nodeExpand\",\n      nodeCollapse: \"nodeCollapse\",\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      valueChange: \"valueChange\",\n      filterChange: \"filterChange\"\n    },\n    exportAs: [\"kendoDropDownTree\"],\n    features: [i0.ɵɵProvidersFeature([DataService, SelectionService, NavigationService, DisabledItemsService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.dropdowntree'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => DropDownTreeComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => DropDownTreeComponent)\n    }, {\n      provide: DataBoundComponent,\n      useExisting: forwardRef(() => DropDownTreeComponent)\n    }, {\n      provide: ExpandableComponent,\n      useExisting: forwardRef(() => DropDownTreeComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 12,\n    vars: 7,\n    consts: function () {\n      let i18n_44;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.dropdowntree.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_45 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_44 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_45;\n      } else {\n        i18n_44 = $localize`:kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_46;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.dropdowntree.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_47 = goog.getMsg(\"clear\");\n        i18n_46 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_47;\n      } else {\n        i18n_46 = $localize`:kendo.dropdowntree.clearTitle|The title of the clear button:clear`;\n      }\n\n      let i18n_48;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text set as aria-label on the select button\n         * @meaning kendo.dropdowntree.selectButtonText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_49 = goog.getMsg(\"Select\");\n        i18n_48 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_49;\n      } else {\n        i18n_48 = $localize`:kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button:Select`;\n      }\n\n      return [[\"kendoDropDownTreeLocalizedMessages\", \"\", \"noDataText\", i18n_44, \"clearTitle\", i18n_46, \"selectButtonText\", i18n_48], [\"role\", \"option\", 1, \"k-input-inner\"], [1, \"k-input-value-text\"], [4, \"ngIf\"], [3, \"ngIf\"], [\"class\", \"k-clear-value\", \"aria-hidden\", \"true\", 3, \"visibility\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"-1\", \"type\", \"button\", \"aria-hidden\", \"true\", 1, \"k-input-button\", \"k-button\", \"k-icon-button\", 3, \"ngClass\"], [1, \"k-button-icon\", \"k-icon\", 3, \"ngClass\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [3, \"templateContext\"], [\"aria-hidden\", \"true\", 1, \"k-clear-value\", 3, \"click\"], [1, \"k-icon\", \"k-i-x\"], [\"class\", \"k-list-filter\", 4, \"ngIf\"], [\"kendoTreeViewSelectable\", \"\", 3, \"size\", \"nodes\", \"maxHeight\", \"animate\", \"selectedKeys\", \"selectBy\", \"textField\", \"children\", \"hasChildren\", \"loadOnDemand\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"filter\", \"isVisible\", \"selectedKeysChange\", \"focusout\", \"keydown\", \"selectionChange\", \"expand\", \"collapse\", 4, \"ngIf\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\"], [1, \"k-textbox\", \"k-input\", 3, \"ngClass\"], [1, \"k-input-prefix\"], [1, \"k-input-icon\", \"k-icon\", \"k-i-search\"], [\"role\", \"textbox\", \"aria-haspopup\", \"true\", \"aria-expanded\", \"false\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"aria-readonly\", \"false\", 1, \"k-input-inner\", 3, \"filterInput\", \"ngModel\", \"kendoEventsOutsideAngular\", \"scope\", \"input\", \"keydown.arrowdown\", \"keydown.alt.arrowup\", \"ngModelChange\"], [\"filterInput\", \"\"], [\"kendoTreeViewSelectable\", \"\", 3, \"size\", \"nodes\", \"animate\", \"selectedKeys\", \"selectBy\", \"textField\", \"children\", \"hasChildren\", \"loadOnDemand\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"filter\", \"isVisible\", \"selectedKeysChange\", \"focusout\", \"keydown\", \"selectionChange\", \"expand\", \"collapse\"], [\"treeview\", \"\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"]];\n    },\n    template: function DropDownTreeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"span\", 1)(2, \"span\", 2);\n        i0.ɵɵtemplate(3, DropDownTreeComponent_3_Template, 1, 4, null, 3);\n        i0.ɵɵtemplate(4, DropDownTreeComponent_ng_template_4_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(5, DropDownTreeComponent_span_5_Template, 2, 3, \"span\", 5);\n        i0.ɵɵelementStart(6, \"button\", 6);\n        i0.ɵɵelement(7, \"span\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, DropDownTreeComponent_ng_template_8_Template, 5, 5, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(10, null, 9);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"id\", ctx.valueLabelId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.valueTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length) && !ctx.disabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectButtonClasses);\n        i0.ɵɵattribute(\"aria-label\", ctx.messageFor(\"selectButtonText\"));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.buttonClasses);\n      }\n    },\n    directives: [i1$1.TreeViewComponent, LocalizedMessagesDirective, i11.NgIf, TemplateContextDirective, i11.NgClass, i8.DefaultValueAccessor, FilterInputDirective, i8.NgControlStatus, i8.NgModel, i9.EventsOutsideAngularDirective, i1$1.SelectDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DropDownTreeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\n\n\nlet BaseCheckDirective = /*#__PURE__*/(() => {\n  class BaseCheckDirective {\n    addItem(item) {\n      if (this.isItemChecked(item)) {\n        return;\n      }\n\n      const level = getHierarchicalItemLevel(item.index);\n      const candidate = Object.assign(Object.assign({}, item), {\n        level\n      });\n      this.checkedItems.push(candidate);\n      this.checkedKeys.add(this.getKey(candidate));\n    }\n\n    removeItem(item) {\n      if (!this.isItemChecked(item)) {\n        return;\n      }\n\n      const level = getHierarchicalItemLevel(item.index);\n      const candidate = Object.assign(Object.assign({}, item), {\n        level\n      });\n      this.checkedItems = this.checkedItems.filter(item => valueFrom(item, this.valueField) !== valueFrom(candidate, this.valueField));\n      this.checkedKeys.delete(this.getKey(candidate));\n    }\n\n    isItemChecked(item) {\n      const level = item.index.split('_').length - 1;\n      item.level = level;\n      return this.checkedKeys.has(this.getKey(item));\n    }\n\n    updateItems() {\n      this.checkedItems = this.checkedItems || [];\n      this.checkedKeys = new Set(this.checkedItems.map(item => this.getKey(item)));\n    }\n    /**\n     * Adds the item's depth to the item's value to allow duplicate values on different levels.\n     *\n     * @param item - The checked key.\n     * @returns { string } - A string key consisting of the item's `valueField` value and its depth.\n     */\n\n\n    getKey(item) {\n      if (isArray(this.valueField)) {\n        return valueFrom(item, this.valueField) + '_' + item.level;\n      }\n\n      return valueFrom(item, this.valueField);\n    }\n\n  }\n\n  BaseCheckDirective.ɵfac = function BaseCheckDirective_Factory(t) {\n    return new (t || BaseCheckDirective)();\n  };\n\n  BaseCheckDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseCheckDirective,\n    inputs: {\n      valueField: \"valueField\",\n      checkedItems: \"checkedItems\"\n    }\n  });\n  return BaseCheckDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\n\n\nlet CheckAllDirective = /*#__PURE__*/(() => {\n  class CheckAllDirective extends BaseCheckDirective {\n    constructor(element, zone, cdr, renderer) {\n      super();\n      this.element = element;\n      this.zone = zone;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      /**\n       * Fires when the `checkedItems` collection was updated.\n       */\n\n      this.checkedItemsChange = new EventEmitter();\n      /**\n       * Holds a Set with just the checked item keys.\n       *\n       * Should be updated each time the `checkedItems` value or content is changed.\n       * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).\n       */\n\n      this.checkedKeys = new Set();\n    }\n\n    handleChange(event) {\n      // Need to store the current checkbox state at the moment of click\n      this.currentCheckedState = event.checked;\n      this.currentIndeterminateState = this.isIndeterminate;\n      this.treeview.nodes.map((_value, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        this.checkNode(itemLookup);\n      });\n      this.checkedItemsChange.emit(this.checkedItems.slice());\n    }\n\n    get isIndeterminate() {\n      const isIndeterminate = this.treeview.nodes.some((_node, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        return this.someChecked(itemLookup);\n      });\n      return this.isChecked ? false : isIndeterminate;\n    }\n\n    get isChecked() {\n      const isChecked = this.treeview.nodes.every((_node, index) => {\n        const itemIndex = String(index);\n        const itemLookup = this.treeview.itemLookup(itemIndex);\n        return this.allChecked(itemLookup);\n      });\n      return isChecked;\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.checkedItems)) {\n        this.updateItems();\n        this.renderer.setProperty(this.element.nativeElement, 'checked', this.isChecked);\n        this.renderer.setProperty(this.element.nativeElement, 'indeterminate', this.isIndeterminate);\n      }\n    }\n\n    ngOnInit() {\n      if (this.focused) {\n        this.nextTick(() => this.element.nativeElement.focus());\n      }\n    }\n\n    nextTick(fn) {\n      this.zone.runOutsideAngular(() => setTimeout(fn));\n    }\n\n    checkNode(itemLookup) {\n      if (this.treeview.isDisabled(itemLookup.item.dataItem, itemLookup.item.index)) {\n        return;\n      }\n\n      const pendingCheck = [];\n\n      const filter = item => this.treeview.isVisible(item.dataItem, item.index) && !this.treeview.isDisabled(item.dataItem, item.index);\n\n      pendingCheck.push(itemLookup.item);\n      fetchDescendentNodes(itemLookup, filter).forEach(lookup => pendingCheck.push(lookup.item));\n      pendingCheck.forEach(item => {\n        if (this.currentIndeterminateState) {\n          if (this.lastAction === 'check') {\n            this.addItem(item);\n          } else {\n            this.removeItem(item);\n          }\n\n          return;\n        }\n\n        if (this.currentCheckedState) {\n          this.addItem(item);\n        } else {\n          this.removeItem(item);\n        }\n      });\n    }\n\n    allChecked(lookup) {\n      const children = lookup && lookup.children;\n\n      if (!Array.isArray(children)) {\n        return;\n      }\n\n      const childrenChecked = children.every(child => {\n        if (child.children.length) {\n          return this.isItemChecked(child.item) && this.allChecked(child);\n        }\n\n        return this.isItemChecked(child.item);\n      });\n      return childrenChecked && this.isItemChecked(lookup.item);\n    }\n\n    someChecked(lookup) {\n      const children = lookup && lookup.children;\n\n      if (!Array.isArray(children)) {\n        return;\n      }\n\n      const childrenChecked = children.some(child => {\n        if (child.children.length) {\n          return this.isItemChecked(child.item) || this.someChecked(child);\n        }\n\n        return this.isItemChecked(child.item);\n      });\n      return childrenChecked || this.isItemChecked(lookup.item);\n    }\n\n  }\n\n  CheckAllDirective.ɵfac = function CheckAllDirective_Factory(t) {\n    return new (t || CheckAllDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  CheckAllDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CheckAllDirective,\n    selectors: [[\"\", \"checkAll\", \"\"]],\n    hostBindings: function CheckAllDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function CheckAllDirective_change_HostBindingHandler($event) {\n          return ctx.handleChange($event.target);\n        });\n      }\n    },\n    inputs: {\n      lastAction: \"lastAction\",\n      treeview: \"treeview\",\n      checkedItems: \"checkedItems\",\n      valueField: \"valueField\",\n      focused: [\"checkAll\", \"focused\"]\n    },\n    outputs: {\n      checkedItemsChange: \"checkedItemsChange\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return CheckAllDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * A directive which manages the in-memory checked state of the MultiSelectTree nodes.\n */\n\n\nlet CheckDirective = /*#__PURE__*/(() => {\n  class CheckDirective extends BaseCheckDirective {\n    constructor(treeView) {\n      super();\n      this.treeView = treeView;\n      /**\n       * Fires when the `checkedItems` collection was updated.\n       */\n\n      this.checkedItemsChange = new EventEmitter();\n      /**\n       * Holds a Set with just the checked item keys.\n       *\n       * Should be updated each time the `checkedItems` value or content is changed.\n       * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).\n       */\n\n      this.checkedKeys = new Set();\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.treeView.checkedChange.subscribe(this.handleCheckedChange.bind(this)));\n      this.treeView.isChecked = this.getCheckedState.bind(this);\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.checkable)) {\n        this.toggleCheckOnClick();\n      }\n\n      if (isPresent(changes.checkedItems)) {\n        this.updateItems();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.unsubscribeClick();\n    }\n\n    getCheckedState(dataItem, index) {\n      if (this.isItemChecked({\n        dataItem,\n        index\n      })) {\n        return 'checked';\n      } else if (this.checkable.checkChildren && this.isItemIndeterminate(this.treeView.itemLookup(index))) {\n        return 'indeterminate';\n      } else {\n        return 'none';\n      }\n    }\n\n    handleCheckedChange(node) {\n      this.checkNode(node); // parents should be checked if `checkChildren` is set to `true` (single config option for both)\n\n      const checkParents = this.checkable.checkChildren;\n\n      if (checkParents) {\n        this.checkParents(node.parent);\n      }\n\n      this.checkedItemsChange.emit(this.checkedItems.slice());\n    }\n\n    toggleCheckOnClick() {\n      this.unsubscribeClick();\n\n      if (this.checkable.checkOnClick) {\n        this.clickSubscription = this.treeView.nodeClick.pipe(filter(event => event.type === 'click')).subscribe(event => {\n          const lookup = this.treeView.itemLookup(event.item.index);\n          this.handleCheckedChange(lookup);\n        });\n      }\n    }\n\n    unsubscribeClick() {\n      if (this.clickSubscription) {\n        this.clickSubscription.unsubscribe();\n        this.clickSubscription = null;\n      }\n    }\n\n    checkNode(lookup) {\n      if (this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index)) {\n        return;\n      }\n\n      const target = lookup.item;\n      const pendingCheck = [target]; // TODO: extract in a separate `checkChildren` method?\n\n      if (this.checkable.checkChildren) {\n        const filter = item => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index);\n\n        fetchDescendentNodes(lookup, filter).forEach(lookup => pendingCheck.push(lookup.item));\n      }\n\n      const shouldCheck = !this.isItemChecked(target);\n      pendingCheck.forEach(item => {\n        if (shouldCheck) {\n          this.addItem(item);\n        } else {\n          this.removeItem(item);\n        }\n      });\n    }\n\n    checkParents(parent) {\n      let currentParent = parent;\n\n      while (currentParent) {\n        const allChildrenSelected = currentParent.children.every(item => this.isItemChecked(item));\n\n        if (allChildrenSelected) {\n          this.addItem(currentParent.item);\n        } else {\n          this.removeItem(currentParent.item);\n        }\n\n        currentParent = currentParent.parent;\n      }\n    }\n\n    isItemIndeterminate(lookup) {\n      const children = lookup.children;\n\n      if (!Array.isArray(children) || children.length === 0) {\n        return false;\n      }\n\n      let index = 0;\n      let child = children[index];\n\n      while (isPresent(child)) {\n        if (this.isItemChecked(child.item) || this.isItemIndeterminate(child)) {\n          return true;\n        }\n\n        index += 1;\n        child = children[index];\n      }\n\n      return false;\n    }\n\n  }\n\n  CheckDirective.ɵfac = function CheckDirective_Factory(t) {\n    return new (t || CheckDirective)(i0.ɵɵdirectiveInject(i1$1.TreeViewComponent));\n  };\n\n  CheckDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CheckDirective,\n    selectors: [[\"\", \"kendoMultiSelectTreeCheckable\", \"\"]],\n    inputs: {\n      checkable: \"checkable\",\n      valueField: \"valueField\",\n      checkedItems: \"checkedItems\"\n    },\n    outputs: {\n      checkedItemsChange: \"checkedItemsChange\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return CheckDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_POPUP_SETTINGS = {\n  animate: true\n};\nconst DEFAULT_CHECKABLE_SETTINGS = {\n  checkChildren: true,\n  checkOnClick: true\n};\n\nconst hasChildren = () => false;\n\nconst fetchChildren = () => of([]);\n\nconst itemDisabled = () => false;\n\nconst isNodeVisible = () => true;\n\nconst DEFAULT_SIZE = 'medium';\nconst DEFAULT_ROUNDED = 'medium';\nconst DEFAULT_FILL_MODE = 'solid';\n/**\n * Represents the [Kendo UI MultiSelectTree component for Angular]({% slug overview_multiselecttree %}).\n */\n\nlet MultiSelectTreeComponent = /*#__PURE__*/(() => {\n  class MultiSelectTreeComponent {\n    constructor(wrapper, popupService, renderer, navigationService, _zone, localization, cdr, touchEnabled) {\n      this.wrapper = wrapper;\n      this.popupService = popupService;\n      this.renderer = renderer;\n      this.navigationService = navigationService;\n      this._zone = _zone;\n      this.localization = localization;\n      this.cdr = cdr;\n      this.touchEnabled = touchEnabled;\n      this.hostClasses = true;\n      this.role = 'combobox';\n      this.ariaHasPopup = 'tree';\n      /**\n       * Sets the levels in the data set where the values can be found when `valueField` is an Array.\n       * The field serves to correctly allocate a data item used when the MultiSelectTree is initialized with a value.\n       */\n\n      this.valueDepth = [];\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n\n      this.placeholder = \"\";\n      /**\n       * Sets the height of the options list. By default, `listHeight` is 200px.\n       *\n       * > The `listHeight` property affects only the list of options and not the whole popup container.\n       * > To set the height of the popup container, use `popupSettings.height`.\n       */\n\n      this.listHeight = 200;\n      /**\n       * Sets the disabled state of the component.\n       */\n\n      this.disabled = false;\n      /**\n       * Sets the read-only state of the component.\n       */\n\n      this.readonly = false;\n      /**\n       * Specifies the type of the selected value\n       * ([more information and example]({% slug valuebinding_multiselecttree %}#toc-primitive-values)).\n       * If set to `true`, the selected value has to be a primitive one.\n       */\n\n      this.valuePrimitive = false;\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default false\n       */\n\n      this.loadOnDemand = false;\n      /**\n       * @hidden\n       *\n       * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.\n       */\n\n      this.focusableId = `k-${guid$1()}`;\n      /**\n       * If set to `true`, renders a button on hovering over the component.\n       * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n       * @default true\n       */\n\n      this.clearButton = true;\n      /**\n       * Renders the built-in input element for filtering the MultiSelectTree.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the MultiSelectTree manually]({% slug filtering_multiselecttree %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoMultiSelectTreeHierarchyBinding`]({% slug api_dropdowns_multiselecttreehierarchybindingdirective %}) and [`kendoMultiSelectTreeFlatBinding`]({% slug api_dropdowns_multiselecttreeflatbindingdirective %}) directives.\n       * @default false\n       */\n\n      this.filterable = false;\n      /**\n       * If `checkАll` is set to `true` and the checkboxes are enabled, a tri-state checkbox appears above the embedded treeview.\n       * Clicking the checkbox checks or unchecks all enabled items of the treeview that are loaded.\n       * @default false\n       */\n\n      this.checkAll = false;\n      /**\n       * A function which determines if a specific node has child nodes.\n       */\n\n      this.hasChildren = hasChildren;\n      /**\n       * A function which provides the child nodes for a given parent node.\n       */\n\n      this.fetchChildren = fetchChildren;\n      /**\n       * A callback which determines whether a tree node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n\n      this.isNodeVisible = isNodeVisible;\n      /**\n       * A function that is executed for each data item and determines if a specific item is disabled.\n       */\n\n      this.itemDisabled = itemDisabled;\n      /**\n       * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.\n       *\n       * @param { Any[] } dataItems - The selected data items from the list.\n       * @returns { Any[] } - The tags that will be rendered by the component.\n       */\n\n      this.tagMapper = tags => tags || [];\n      /**\n       * Fires each time the user focuses the MultiSelectTree.\n       */\n\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires each time the MultiSelectTree gets blurred.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open\n       * ([see example]({% slug openstate_multiselecttree %})).\n       * This event is preventable. If you cancel it, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires after the popup has been opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close\n       * ([see example]({% slug openstate_multiselecttree %})).\n       * This event is preventable. If you cancel it, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Fires after the popup has been closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires when the user expands a node in the popup TreeView.\n       */\n\n      this.nodeExpand = new EventEmitter();\n      /**\n       * Fires when the user collapses a node in the popup TreeView.\n       */\n\n      this.nodeCollapse = new EventEmitter();\n      /**\n       * Fires each time the value is changed\n       * ([see example]({% slug overview_multiselecttree %}#toc-events)).\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Fires each time a tag is about to be removed([see examples]({% slug summarytagmode_multiselect %}#toc-notifying-on-removing-group-tags)).\n       * This event is preventable. If you cancel it, the tag will not be removed.\n       */\n\n      this.removeTag = new EventEmitter();\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.filterStateChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.checkedItems = [];\n      /**\n       * @hidden\n       */\n\n      this.checkBy = item => item;\n      /**\n       * @hidden\n       */\n\n\n      this.showAfter = 0;\n      /**\n       * @hidden\n       */\n\n      this.allNodesHidden = false;\n      this.tagListId = guid$1();\n      this.tagPrefix = \"tag-\" + guid$1();\n      this.focusedTagIndex = undefined;\n      this._value = [];\n      this._tabindex = 0;\n      this._popupSettings = DEFAULT_POPUP_SETTINGS;\n      this._checkableSettings = DEFAULT_CHECKABLE_SETTINGS;\n      this._isFocused = false;\n      this._size = 'medium';\n      this._rounded = 'medium';\n      this._fillMode = 'solid';\n      this.subscriptions = [];\n      this.lastAction = 'check';\n      this.onTouchedCallback = noop;\n      this.onChangeCallback = noop;\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n      this.subscribeEvents();\n      this.subscribeFocusEvents();\n    }\n\n    get isDisabled() {\n      return this.disabled;\n    }\n\n    get isLoading() {\n      return this.loading;\n    }\n\n    get id() {\n      return this.focusableId;\n    }\n\n    get hostTabIndex() {\n      return this.tabindex;\n    }\n\n    get isAriaExpanded() {\n      return this.isOpen;\n    }\n\n    get isReadonly() {\n      return this.readonly;\n    }\n\n    get ariaDescribedBy() {\n      return this.tagListId;\n    }\n\n    get ariaActiveDescendant() {\n      return this.focusedTagId;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleClick() {\n      this.togglePopup(!this.isOpen);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKeydown(event) {\n      const deleteTag = this.isWrapperActive && event.keyCode === Keys.Backspace && this.tags.length > 0;\n\n      if (deleteTag) {\n        this.handleBackspace();\n        return;\n      }\n\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      const eventData = event;\n      const action = this.navigationService.process({\n        originalEvent: eventData\n      });\n\n      if (action === NavigationAction.Open) {\n        eventData.preventDefault();\n      }\n    }\n\n    set treeview(treeview) {\n      this._treeview = treeview;\n\n      if (treeview) {\n        // If filtering is enabled, focus the TreeView on mobile devices instead of the filter input\n        if (this.isFocused && !this.filterable && !this.checkAll || this.touchEnabled) {\n          treeview.focus();\n        }\n        /**\n         * the treeview animations are initially disabled (we don't want expand animations during popup opening)\n         * re-enables the animations for user interaction\n         * The Promise is required to properly change the `animate` property when\n         * the popup is appended to a container and opened upon initialization.\n         * Otherwise, the \"Expression has changed...\" type error will be thrown.\n         */\n\n\n        Promise.resolve(null).then(() => this.treeview.animate = true);\n      }\n    }\n\n    get treeview() {\n      return this._treeview;\n    }\n    /**\n     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n\n\n    set tabindex(value) {\n      const providedTabIndex = parseNumber(value);\n      const defaultTabIndex = 0;\n      this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;\n    }\n\n    get tabindex() {\n      return this.disabled ? -1 : this._tabindex;\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     *\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : DEFAULT_SIZE;\n      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n\n      if (size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));\n      }\n\n      this._size = newSize;\n    }\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the border radius of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `full`\n     * * `none`\n     *\n     */\n\n\n    set rounded(rounded) {\n      const newRounded = rounded ? rounded : DEFAULT_ROUNDED;\n      this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n\n      if (rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));\n      }\n\n      this._rounded = newRounded;\n    }\n\n    get rounded() {\n      return this._rounded;\n    }\n    /**\n     * Sets the fillMode of the component.\n     *\n     * The possible values are:\n     * * `flat`\n     * * `solid` (default)\n     * * `outline`\n     * * `none`\n     *\n     */\n\n\n    set fillMode(fillMode) {\n      const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;\n      this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n\n      if (fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));\n      }\n\n      this._fillMode = newFillMode;\n    }\n\n    get fillMode() {\n      return this._fillMode;\n    }\n    /**\n     * Configures the popup of the MultiSelectTree.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.\n     * - `height: Number`&mdash;Sets the height of the popup container.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS, settings); // `detectChanges` needed, otherwise upon value initialization and `appendTo` property\n      // an error is thrown => ExpressionChangedAfterItHasBeenCheckedError\n\n      this.cdr.detectChanges();\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * Defines the checkable settings of the MultiSelecTree nodes.\n     * If no value is provided, the default [`CheckableSettings`]({% slug api_dropdowns_multiselecttreecheckablesettings %}) are applied.\n     */\n\n\n    set checkableSettings(settings) {\n      this._checkableSettings = Object.assign({}, DEFAULT_CHECKABLE_SETTINGS, settings);\n    }\n\n    get checkableSettings() {\n      return this._checkableSettings;\n    }\n    /**\n     * Sets the data of the MultiSelectTree.\n     *\n     * > The data has to be provided in an array-like list with objects.\n     */\n\n\n    set data(data) {\n      this._nodes = data;\n      this.setState();\n    }\n\n    get data() {\n      return this._nodes;\n    }\n    /**\n     * Sets the value of the MultiSelectTree.\n     * It can either be of the primitive (string, numbers) or of the complex (objects) type.\n     * To define the type, use the `valuePrimitive` option.\n     *\n     */\n\n\n    set value(value) {\n      this._value = value ? value : [];\n      this.setState();\n    }\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Keeps the current `dataItems` object in order to resolve selection.\n     * Needs to be provided when when programmatically setting a `value` and `valuePrimitive` is set to `true`.\n     */\n\n\n    set dataItems(items) {\n      this._dataItems = (items || []).map((item, index) => {\n        if (hasProps(item, ['dataItem', 'index', 'level'])) {\n          return item;\n        }\n\n        return {\n          dataItem: item,\n          index: null,\n          level: this.valueDepth[index] || 0\n        };\n      });\n      this.setState();\n    }\n\n    get dataItems() {\n      return this._dataItems || this.value.map((value, index) => ({\n        dataItem: value,\n        index: null,\n        level: this.valueDepth[index] || 0\n      }));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get focusedTagId() {\n      if (!isPresent(this.focusedTagIndex) || this.isOpen) {\n        return null;\n      }\n\n      const dataItem = this.tags[this.focusedTagIndex];\n      return `${this.tagPrefix}-${valueFrom({\n        dataItem\n      }, this.valueField)}`;\n    }\n\n    set isFocused(isFocused) {\n      this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-focus');\n      this._isFocused = isFocused;\n    }\n\n    get isFocused() {\n      return this._isFocused;\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n\n\n    get isOpen() {\n      return isPresent(this.popupRef);\n    }\n\n    get width() {\n      const wrapperWidth = this.wrapper.nativeElement.offsetWidth;\n      const width = this.popupSettings.width || wrapperWidth;\n      const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;\n      const maxWidth = isNaN(width) ? width : `${width}px`;\n      return {\n        min: minWidth,\n        max: maxWidth\n      };\n    }\n\n    get height() {\n      const popupHeight = this.popupSettings.height;\n      return isPresent(popupHeight) ? `${popupHeight}px` : 'auto';\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get popupContainerClasses() {\n      const containerClasses = ['k-popup-dropdowntree'];\n\n      if (this.popupSettings.popupClass) {\n        containerClasses.push(this.popupSettings.popupClass);\n      }\n\n      return containerClasses;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives.\n     */\n\n\n    set nodes(nodes) {\n      this.data = nodes;\n    }\n\n    get nodes() {\n      return this.data;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.\n     * Required for the data-binding directives\n     */\n\n\n    set children(callback) {\n      this.fetchChildren = callback;\n    }\n\n    get children() {\n      return this.fetchChildren;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    get expand() {\n      return this.nodeExpand;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    get collapse() {\n      return this.nodeCollapse;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.\n     * Required for the expand-directive.\n     */\n\n\n    set isExpanded(callback) {\n      this.isNodeExpanded = callback;\n    }\n\n    get isExpanded() {\n      return this.isNodeExpanded;\n    }\n    /**\n     * @hidden\n     *\n     * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.\n     * The `DataBoundComponent` interface is used in the data-binding directives.\n     */\n\n\n    set isVisible(callback) {\n      this.isNodeVisible = callback;\n    }\n\n    get isVisible() {\n      return this.isNodeVisible;\n    }\n\n    get isTagFocused() {\n      return !this.isOpen && this.focusedTagIndex !== undefined;\n    }\n\n    get isTreeViewActive() {\n      return this.treeview && this.treeview.isActive;\n    }\n\n    get isWrapperActive() {\n      return document.activeElement === this.wrapper.nativeElement;\n    }\n\n    get isFilterActive() {\n      return this.filterInput && document.activeElement === this.filterInput.nativeElement;\n    }\n\n    get isCheckAllActive() {\n      return this.checkAllInput && document.activeElement === this.checkAllInput.nativeElement;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', String(this.isOpen));\n      this.subscriptions.push(this.localization.changes.subscribe(({\n        rtl\n      }) => {\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.cdr.markForCheck();\n      }));\n      this.setComponentClasses();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroyPopup();\n      this.unsubscribeEvents();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {\n        this.setState();\n      }\n\n      if (anyChanged(['valueDepth', 'value', 'dataItems'], changes, false)) {\n        if (changes.value && !changes.dataItems && !this.valuePrimitive) {\n          // Update the dataItems if the value is updated programmatically (non-primitive values only)\n          // In the primitive case, the client should update the dataItems as well\n          this.dataItems = this.value;\n        } else {\n          // Re-map the dataItems because `valueDepth` is not yet available when the check directive parses the items\n          this.dataItems = this.dataItems.map((item, index) => Object.assign(Object.assign({}, item), {\n            level: this.valueDepth[index] || 0\n          }));\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentChecked() {\n      this.verifySettings();\n    }\n    /**\n     * @hidden\n     *\n     * Used by the kendo-floatinglabel component to determine if the floating label\n     * should be rendered inside the input when the component is not focused.\n     */\n\n\n    isEmpty() {\n      return !Boolean(this.placeholder) && (!isPresent(this.value) || this.value.length === 0);\n    }\n    /**\n     * Focuses the MultiSelectTree.\n     */\n\n\n    focus() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.focus();\n      }\n    }\n    /**\n     * Blurs the MultiSelectTree.\n     */\n\n\n    blur() {\n      if (!this.disabled) {\n        this.wrapper.nativeElement.blur();\n      }\n    }\n    /**\n     * Focuses a specific item of the MultiSelectTree based on a provided index in the format of `1_1`.\n     * The targeted item should be expanded in order for it to be focused.\n     * If null or invalid index is provided the focus will be set on the first item.\n     */\n\n\n    focusItemAt(index) {\n      if (this.treeview) {\n        const lookup = this.treeview.itemLookup(index);\n        const isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);\n\n        if (!isItemDisabled) {\n          this.treeview.focus(index);\n        }\n      }\n    }\n    /**\n     * Resets the value of the MultiSelectTree.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `valueChange` event will not be fired.\n     */\n\n\n    reset() {\n      this.value = [];\n      this.dataItems = [];\n      this.valueDepth = [];\n    }\n    /**\n     * Toggles the visibility of the popup\n     * ([see example]({% slug openstate_multiselecttree %})).\n     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n\n\n    toggle(open) {\n      // The Promise is required to open the popup on load.\n      // Otherwise, the \"ViewContainerRef not found...\" error will be thrown.\n      Promise.resolve(null).then(() => {\n        const shouldOpen = isPresent(open) ? open : !isPresent(this.popupRef);\n        this.destroyPopup();\n\n        if (shouldOpen) {\n          this.createPopup();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFocus(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n\n      if (!this.isFocused) {\n        this.isFocused = true;\n\n        if (hasObservers(this.onFocus)) {\n          this._zone.run(() => {\n            this.onFocus.emit();\n          });\n        } // Re-focus the treeview if `close` is prevented\n\n\n        if (this.isOpen && this.treeview) {\n          if (this.lastNodeOnFocus) {\n            this.lastNodeOnFocus.setAttribute('tabindex', '0');\n          }\n\n          this.treeview.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleBlur(e) {\n      const relatedTarget = e && e.relatedTarget;\n\n      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {\n        return;\n      }\n\n      this.isFocused = false;\n      this.togglePopup(false);\n\n      if (hasObservers(this.onBlur) || isUntouched(this.wrapper.nativeElement)) {\n        this._zone.run(() => {\n          this.onBlur.emit();\n          this.onTouchedCallback();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleNodeClick(node) {\n      if (!this.isFocused) {\n        // Re-focus the MultiSelectTree when popup close is prevented and a node is clicked\n        // On click the focus should be on the clicked element which is why we need to update the lastNodeOnFocus\n        const parent = node.originalEvent.target.parentElement.parentElement;\n        this.lastNodeOnFocus = parent;\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    togglePopup(open) {\n      const isDisabled = this.disabled || this.readonly;\n      const sameState = this.isOpen === open;\n\n      this._zone.run(() => {\n        this.focusedTagIndex = undefined;\n      });\n\n      if (isDisabled || sameState) {\n        return;\n      }\n\n      const togglePrevented = this.triggerPopupEvents(open);\n\n      if (!togglePrevented) {\n        if (open) {\n          this.createPopup();\n        } else {\n          this.destroyPopup();\n        }\n      } else {\n        this.removeTreeViewFromTabOrder();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    messageFor(key) {\n      return this.localization.get(key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleCheckedItemsChange(items) {\n      this.valueDepth = items.map(item => item.level);\n      this.lastAction = items.length > this.dataItems.length ? 'check' : 'uncheck';\n      this.dataItems = items.slice();\n      this.updateValue(this.dataItems);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleRemoveTag({\n      tag,\n      index\n    }) {\n      if (this.disabled || this.readonly) {\n        return;\n      }\n\n      const eventArgs = new RemoveTagEvent(tag);\n      this.removeTag.emit(eventArgs);\n\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      } // Remove tags based on their position index\n\n\n      if (tag instanceof Array) {\n        // Remove group tag\n        this.dataItems = this.dataItems.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));\n        this.valueDepth = this.valueDepth.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));\n      } else {\n        // Remove single tag\n        this.dataItems = this.dataItems.filter((_item, i) => i !== index || this.disabledIndices.has(i));\n        this.valueDepth = this.valueDepth.filter((_item, i) => i !== index || this.disabledIndices.has(i));\n      }\n\n      this.updateValue(this.dataItems); // focus the wrapper if the component is not focused - the floating label reacts to focus/blur\n\n      if (!this.isFocused) {\n        this.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleTagMapperChange(showAfter) {\n      this.showAfter = parseNumber(showAfter);\n      this.setTags();\n    }\n    /**\n     * @hidden\n     */\n\n\n    clearAll(event) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      this.focus();\n      this.value = this.value.filter((_item, index) => this.disabledIndices.has(index));\n      this.dataItems = this.dataItems.filter((_item, index) => this.disabledIndices.has(index));\n      this.valueDepth = this.valueDepth.filter((_depth, index) => this.disabledIndices.has(index));\n      this.emitValueChange(this.value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.value = value || []; // Update the dataItems if the value is updated programmatically (non-primitive values only)\n      // In the primitive case, the client should update the dataItems as well\n\n      if (!this.valuePrimitive) {\n        this.dataItems = this.value;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilterInputChange(input) {\n      this.filterChange.next(input.value);\n      this.allNodesHidden = this.nodes.every((node, index) => !this.isVisible(node, String(index)));\n    }\n    /**\n     * @hidden\n     */\n\n\n    get filterInputClasses() {\n      return `${this.size ? getSizeClass('input', this.size) : ''} ${this.fillMode ? 'k-input-' + this.fillMode : ''} ${this.rounded ? getRoundedClass(this.rounded) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get checkAllCheckboxClasses() {\n      return `${this.size ? getSizeClass('checkbox', this.size) : ''}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleCheckAll() {\n      this.checkAllInput.nativeElement.focus();\n      this.checkAllInput.nativeElement.click();\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isPresent(this.valueField) || !isPresent(this.textField)) {\n        throw new Error(MultiSelectTreeMessages.textAndValue);\n      }\n\n      if (!isArray(this.value)) {\n        throw new Error(MultiSelectTreeMessages.array);\n      }\n\n      if (this.value.length > 0) {\n        if (this.valuePrimitive && this.value.some(item => isObject(item))) {\n          throw new Error(MultiSelectTreeMessages.primitive);\n        }\n\n        const isEveryDataItemObject = this.dataItems.every(item => isObject(item.dataItem));\n\n        if (this.valuePrimitive && !isArray(this.dataItems)) {\n          throw new Error(MultiSelectTreeMessages.dataItems);\n        }\n\n        if (this.valuePrimitive && !isEveryDataItemObject) {\n          throw new Error(MultiSelectTreeMessages.dataItems);\n        }\n\n        if (this.valuePrimitive && this.dataItems.length !== this.value.length) {\n          throw new Error(MultiSelectTreeMessages.dataItemsLength);\n        }\n\n        if (!this.valuePrimitive && !isObjectArray(this.value)) {\n          throw new Error(MultiSelectTreeMessages.object);\n        }\n\n        if ((isArray(this.valueField) || isArray(this.textField)) && !isArray(this.valueDepth)) {\n          throw new Error(MultiSelectTreeMessages.valueDepth);\n        }\n\n        if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length === 0) {\n          throw new Error(MultiSelectTreeMessages.valueDepth);\n        }\n\n        if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length !== this.value.length) {\n          throw new Error(MultiSelectTreeMessages.valueDepthLength);\n        }\n      }\n    }\n\n    emitValueChange(value) {\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n\n    triggerPopupEvents(open) {\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      return eventArgs.isDefaultPrevented();\n    }\n\n    createPopup() {\n      const horizontalAlign = this.direction === \"rtl\" ? \"right\" : \"left\";\n      const anchorPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'bottom'\n      };\n      const popupPosition = {\n        horizontal: horizontalAlign,\n        vertical: 'top'\n      };\n      this.popupRef = this.popupService.open({\n        anchor: this.wrapper,\n        appendTo: this.appendTo,\n        anchorAlign: anchorPosition,\n        content: this.popupTemplate,\n        popupAlign: popupPosition,\n        positionMode: 'absolute',\n        popupClass: this.popupContainerClasses\n      });\n      const popupWrapper = this.popupRef.popupElement;\n      const {\n        min,\n        max\n      } = this.width;\n      popupWrapper.style.minWidth = min;\n      popupWrapper.style.width = max;\n      popupWrapper.style.height = this.height;\n      this.renderer.setAttribute(popupWrapper, 'dir', this.direction);\n      this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');\n      this.popupRef.popupOpen.subscribe(() => {\n        this.cdr.detectChanges();\n        this.opened.emit();\n      });\n      this.popupRef.popupClose.subscribe(() => {\n        this.closed.emit();\n      });\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');\n\n        if (this.filter !== \"\") {\n          this.filter = \"\";\n          this.allNodesHidden = false;\n\n          if (hasObservers(this.filterChange)) {\n            this._zone.run(() => {\n              this.filterChange.emit(\"\");\n            });\n          }\n        }\n      }\n    }\n\n    subscribeEvents() {\n      this.subscriptions.push(this.navigationService.open.subscribe(() => this.togglePopup(true)), this.navigationService.enter.pipe(tap(event => event.originalEvent.preventDefault())).subscribe(() => this.togglePopup(true)), merge(this.navigationService.close, this.navigationService.esc).subscribe(() => {\n        this.focus();\n        this.togglePopup(false);\n      }), this.navigationService.tab.subscribe(this.handleTabKey.bind(this)), this.navigationService.up.subscribe(this.handleUpKey.bind(this)), this.navigationService.down.subscribe(this.handleDownKey.bind(this)), this.navigationService.left.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.home.pipe(filter(() => !this.isOpen)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => !this.isOpen)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(() => this.isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(() => this.isTagFocused)).subscribe(this.handleDelete.bind(this)));\n    }\n\n    subscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        this.handleFocus = this.handleFocus.bind(this);\n        this.handleDocumentBlur = this.handleDocumentBlur.bind(this);\n\n        this._zone.runOutsideAngular(() => {\n          const useCapture = true;\n          document.addEventListener('focus', this.handleFocus, useCapture);\n          document.addEventListener('blur', this.handleDocumentBlur, useCapture);\n        });\n      }\n    }\n\n    unSubscribeFocusEvents() {\n      if (isDocumentAvailable()) {\n        const useCapture = true;\n        document.removeEventListener('focus', this.handleFocus, useCapture);\n        document.removeEventListener('blur', this.handleDocumentBlur, useCapture);\n      }\n    }\n\n    handleDocumentBlur(event) {\n      if (event.target !== this.wrapper.nativeElement) {\n        return;\n      }\n\n      event.stopImmediatePropagation();\n      this.handleBlur(event);\n    }\n\n    handleTabKey() {\n      this.focus();\n\n      if (this.isOpen) {\n        this.treeview.blur();\n        this.removeTreeViewFromTabOrder();\n      }\n    }\n\n    handleUpKey(event) {\n      if (!this.treeview) {\n        return;\n      }\n\n      event.originalEvent.preventDefault(); // Prevent toggling the focus between the filterInput and the wrapper elements with `up` key\n\n      if (this.isWrapperActive) {\n        return;\n      }\n\n      const isFirstNodeActive = this.treeview['navigationService']['activeIndex'] === '0'; // Current focus is on the filter input => should focus the wrapper\n\n      if (this.filterable && this.isFilterActive) {\n        this.focus(); // Current focus is on the treeview first node => should focus the check all checkbox if enabled\n      } else if (this.checkAll && !this.isCheckAllActive && isFirstNodeActive) {\n        this.checkAllInput.nativeElement.focus(); // Current focus is either on the check all checkbox or the treeview's first node\n        // => should focus either the filter input (if enabled) or the wrapper\n      } else if (this.isCheckAllActive || isFirstNodeActive) {\n        if (this.filterable) {\n          this.filterInput.nativeElement.focus();\n        } else {\n          this.focus();\n        }\n      }\n    }\n\n    handleDownKey(event) {\n      if (!this.treeview) {\n        return;\n      }\n\n      event.originalEvent.preventDefault(); // Current focus is on the wrapper => should focus the filter input\n\n      if (this.filterable && this.isWrapperActive) {\n        this.filterInput.nativeElement.focus(); // Current focus is on the wrapper/filter input => should focus check all checkbox if enabled\n      } else if (this.checkAll && (this.isWrapperActive || this.isFilterActive)) {\n        this.checkAllInput.nativeElement.focus(); // Should focus the treeview if filterable and check all are disabled\n      } else if (!this.treeview.isActive) {\n        this.treeview.focus();\n      }\n\n      this.focusedTagIndex = undefined;\n    }\n\n    handleRightKey(event) {\n      event.originalEvent.preventDefault();\n      const last = this.tags.length - 1;\n\n      if (this.focusedTagIndex === last) {\n        this.focusedTagIndex = undefined;\n      } else if (this.focusedTagIndex < last) {\n        this.focusedTagIndex++;\n      } else if (!this.focusedTagIndex) {\n        this.focusedTagIndex = 0;\n      }\n    }\n\n    handleLeftKey(event) {\n      event.originalEvent.preventDefault();\n\n      if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {\n        this.focusedTagIndex = this.tags.length - 1;\n      } else if (this.focusedTagIndex !== 0) {\n        this.focusedTagIndex--;\n      }\n    }\n\n    handleEnd(event) {\n      event.originalEvent.preventDefault();\n      this.focusedTagIndex = this.tags.length - 1;\n    }\n\n    handleHome(event) {\n      event.originalEvent.preventDefault();\n      this.focusedTagIndex = 0;\n    }\n\n    handleBackspace() {\n      if (this.focusedTagIndex !== undefined) {\n        this.handleDelete();\n      } else {\n        const tag = this.tags[this.tags.length - 1];\n        const index = this.tags.length - 1;\n        this.handleRemoveTag({\n          tag,\n          index\n        });\n      }\n    }\n\n    handleDelete() {\n      const tag = this.tags[this.focusedTagIndex];\n      const index = this.focusedTagIndex;\n      this.handleRemoveTag({\n        tag,\n        index\n      });\n\n      if (this.focusedTagIndex === this.tags.length) {\n        this.focusedTagIndex = undefined;\n      }\n    }\n\n    unsubscribeEvents() {\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n      this.unSubscribeFocusEvents();\n    }\n    /**\n     * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur\n     * and the user will not be able to tab to the rest of the browser elements\n     */\n\n\n    removeTreeViewFromTabOrder() {\n      const nodes = this.treeview.element.nativeElement.querySelectorAll('li');\n      nodes.forEach(item => {\n        if (item.getAttribute('tabindex') === '0') {\n          this.lastNodeOnFocus = item;\n          this.lastNodeOnFocus.setAttribute('tabindex', '-1');\n        }\n      });\n    }\n\n    setState() {\n      if (isPresent(this.dataItems) && isPresent(this.valueField)) {\n        this.setTags();\n        this.checkedItems = this.dataItems.slice();\n      }\n\n      this.cdr.markForCheck();\n    }\n\n    setTags() {\n      const source = this.dataItems.map(item => item.dataItem);\n      this.tags = this.tagMapper(source);\n      this.disabledIndices = this.disabledItemsMapper();\n    }\n\n    updateValue(value) {\n      const newValue = this.valuePrimitive ? value.map(item => valueFrom(item, this.valueField)) : value.map(item => item.dataItem);\n      this.value = newValue;\n      this.emitValueChange(this.value);\n    }\n    /**\n     * @hidden\n     *\n     * Determines which of the provided tags should be disabled and stores their position indices\n     */\n\n\n    disabledItemsMapper() {\n      return new Set(this.dataItems.reduce((indices, item, index) => {\n        if (this.itemDisabled(item.dataItem, item.index)) {\n          indices.push(index);\n        }\n\n        return indices;\n      }, []));\n    }\n\n    setComponentClasses() {\n      if (this.size !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));\n      }\n\n      if (this.rounded !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));\n      }\n\n      if (this.fillMode !== 'none') {\n        this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));\n      }\n    }\n\n  }\n\n  MultiSelectTreeComponent.ɵfac = function MultiSelectTreeComponent_Factory(t) {\n    return new (t || MultiSelectTreeComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TOUCH_ENABLED, 8));\n  };\n\n  MultiSelectTreeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MultiSelectTreeComponent,\n    selectors: [[\"kendo-multiselecttree\"]],\n    contentQueries: function MultiSelectTreeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);\n      }\n    },\n    viewQuery: function MultiSelectTreeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c9, 7);\n        i0.ɵɵviewQuery(_c8, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c42, 5);\n        i0.ɵɵviewQuery(_c43, 5);\n        i0.ɵɵviewQuery(_c51, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeview = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.checkAllInput = _t.first);\n      }\n    },\n    hostVars: 19,\n    hostBindings: function MultiSelectTreeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MultiSelectTreeComponent_click_HostBindingHandler() {\n          return ctx.handleClick();\n        })(\"keydown\", function MultiSelectTreeComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-disabled\", ctx.isDisabled)(\"id\", ctx.id)(\"dir\", ctx.direction)(\"tabindex\", ctx.hostTabIndex)(\"role\", ctx.role)(\"aria-expanded\", ctx.isAriaExpanded)(\"aria-haspopup\", ctx.ariaHasPopup)(\"readonly\", ctx.isReadonly)(\"aria-readonly\", ctx.isReadonly)(\"aria-describedby\", ctx.ariaDescribedBy)(\"aria-activedescendant\", ctx.ariaActiveDescendant);\n        i0.ɵɵclassProp(\"k-dropdowntree\", ctx.hostClasses)(\"k-input\", ctx.hostClasses)(\"k-disabled\", ctx.isDisabled)(\"k-loading\", ctx.isLoading);\n      }\n    },\n    inputs: {\n      tabindex: \"tabindex\",\n      size: \"size\",\n      rounded: \"rounded\",\n      fillMode: \"fillMode\",\n      popupSettings: \"popupSettings\",\n      checkableSettings: \"checkableSettings\",\n      data: \"data\",\n      value: \"value\",\n      dataItems: \"dataItems\",\n      textField: \"textField\",\n      valueField: \"valueField\",\n      valueDepth: \"valueDepth\",\n      loading: \"loading\",\n      placeholder: \"placeholder\",\n      listHeight: \"listHeight\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      valuePrimitive: \"valuePrimitive\",\n      loadOnDemand: \"loadOnDemand\",\n      focusableId: \"focusableId\",\n      clearButton: \"clearButton\",\n      filterable: \"filterable\",\n      checkAll: \"checkAll\",\n      hasChildren: \"hasChildren\",\n      fetchChildren: \"fetchChildren\",\n      isNodeExpanded: \"isNodeExpanded\",\n      isNodeVisible: \"isNodeVisible\",\n      itemDisabled: \"itemDisabled\",\n      tagMapper: \"tagMapper\"\n    },\n    outputs: {\n      onFocus: \"focus\",\n      onBlur: \"blur\",\n      open: \"open\",\n      opened: \"opened\",\n      close: \"close\",\n      closed: \"closed\",\n      nodeExpand: \"nodeExpand\",\n      nodeCollapse: \"nodeCollapse\",\n      valueChange: \"valueChange\",\n      removeTag: \"removeTag\",\n      filterChange: \"filterChange\"\n    },\n    exportAs: [\"kendoMultiSelectTree\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, NavigationService, DataService, DisabledItemsService, SelectionService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.multiselecttree'\n    }, {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MultiSelectTreeComponent)\n    }, {\n      provide: DataBoundComponent,\n      useExisting: forwardRef(() => MultiSelectTreeComponent)\n    }, {\n      provide: ExpandableComponent,\n      useExisting: forwardRef(() => MultiSelectTreeComponent)\n    }, {\n      provide: KendoInput,\n      useExisting: forwardRef(() => MultiSelectTreeComponent)\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 17,\n    consts: function () {\n      let i18n_52;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed in the popup when there are no items\n         * @meaning kendo.multiselecttree.noDataText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_53 = goog.getMsg(\"NO DATA FOUND\");\n        i18n_52 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_53;\n      } else {\n        i18n_52 = $localize`:kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;\n      }\n\n      let i18n_54;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the clear button\n         * @meaning kendo.multiselecttree.clearTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_55 = goog.getMsg(\"clear\");\n        i18n_54 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_55;\n      } else {\n        i18n_54 = $localize`:kendo.multiselecttree.clearTitle|The title of the clear button:clear`;\n      }\n\n      let i18n_56;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The text displayed for the check-all checkbox\n         * @meaning kendo.multiselecttree.checkAllText\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_57 = goog.getMsg(\"Check all\");\n        i18n_56 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2015_KENDO_ANGULAR_DROPDOWNS_JS_57;\n      } else {\n        i18n_56 = $localize`:kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox:Check all`;\n      }\n\n      return [[\"kendoMultiSelectTreeLocalizedMessages\", \"\", \"noDataText\", i18n_52, \"clearTitle\", i18n_54, \"checkAllText\", i18n_56], [3, \"size\", \"rounded\", \"fillMode\", \"id\", \"tags\", \"focused\", \"textField\", \"valueField\", \"valueDepth\", \"disabled\", \"tagPrefix\", \"template\", \"groupTemplate\", \"disabledIndices\", \"removeTag\"], [\"class\", \"k-input-inner k-readonly\", 4, \"ngIf\"], [\"class\", \"k-clear-value\", \"role\", \"button\", \"tabindex\", \"-1\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"k-icon k-i-loading k-input-loading-icon\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [1, \"k-input-inner\", \"k-readonly\"], [1, \"k-input-value-text\"], [\"role\", \"button\", \"tabindex\", \"-1\", 1, \"k-clear-value\", 3, \"click\"], [1, \"k-icon\", \"k-i-x\"], [1, \"k-icon\", \"k-i-loading\", \"k-input-loading-icon\"], [\"class\", \"k-list-filter\", 4, \"ngIf\"], [4, \"ngIf\"], [\"class\", \"k-check-all\", 4, \"ngIf\"], [\"kendoMultiSelectTreeCheckable\", \"\", 3, \"size\", \"nodes\", \"animate\", \"checkable\", \"checkedItems\", \"valueField\", \"textField\", \"children\", \"hasChildren\", \"isExpanded\", \"isDisabled\", \"nodeTemplate\", \"loadOnDemand\", \"filter\", \"isVisible\", \"kendoEventsOutsideAngular\", \"scope\", \"keydown\", \"nodeClick\", \"expand\", \"collapse\", \"checkedItemsChange\"], [\"treeview\", \"\"], [\"class\", \"k-no-data\", 4, \"ngIf\"], [1, \"k-list-filter\"], [1, \"k-textbox\", \"k-input\", 3, \"ngClass\"], [1, \"k-input-prefix\"], [1, \"k-input-icon\", \"k-icon\", \"k-i-search\"], [\"role\", \"textbox\", \"aria-haspopup\", \"true\", \"aria-expanded\", \"false\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"aria-readonly\", \"false\", 1, \"k-input-inner\", 3, \"filterInput\", \"ngModel\", \"kendoEventsOutsideAngular\", \"scope\", \"input\", \"keydown\", \"ngModelChange\"], [\"filterInput\", \"\"], [3, \"templateContext\"], [1, \"k-check-all\"], [\"type\", \"checkbox\", \"role\", \"checkbox\", \"tabindex\", \"0\", \"aria-disabled\", \"false\", \"aria-readonly\", \"false\", 1, \"k-checkbox\", 3, \"checkAll\", \"ngClass\", \"treeview\", \"checkedItems\", \"valueField\", \"lastAction\", \"kendoEventsOutsideAngular\", \"scope\", \"checkedItemsChange\", \"keydown\"], [\"checkAllInput\", \"\"], [1, \"k-checkbox-label\", 3, \"click\", \"mousedown\"], [1, \"k-no-data\"], [3, \"ngIf\", \"templateContext\"], [3, \"ngIf\"]];\n    },\n    template: function MultiSelectTreeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵelementStart(1, \"kendo-taglist\", 1);\n        i0.ɵɵlistener(\"removeTag\", function MultiSelectTreeComponent_Template_kendo_taglist_removeTag_1_listener($event) {\n          return ctx.handleRemoveTag($event);\n        });\n        i0.ɵɵtemplate(2, MultiSelectTreeComponent_span_2_Template, 3, 1, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, MultiSelectTreeComponent_span_3_Template, 2, 1, \"span\", 3);\n        i0.ɵɵtemplate(4, MultiSelectTreeComponent_span_4_Template, 1, 0, \"span\", 4);\n        i0.ɵɵtemplate(5, MultiSelectTreeComponent_ng_template_5_Template, 7, 26, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(7, null, 6);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"rounded\", ctx.rounded)(\"fillMode\", ctx.fillMode)(\"id\", ctx.tagListId)(\"tags\", ctx.tags)(\"focused\", ctx.focusedTagIndex)(\"textField\", ctx.textField)(\"valueField\", ctx.valueField)(\"valueDepth\", ctx.valueDepth)(\"disabled\", ctx.disabled)(\"tagPrefix\", ctx.tagPrefix)(\"template\", ctx.tagTemplate)(\"groupTemplate\", ctx.groupTagTemplate)(\"disabledIndices\", ctx.disabledIndices);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.tags || !ctx.tags.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.disabled && !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.tags == null ? null : ctx.tags.length));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.loading);\n      }\n    },\n    directives: [TagListComponent, i1$1.TreeViewComponent, LocalizedMessagesDirective, i11.NgIf, i11.NgClass, i8.DefaultValueAccessor, FilterInputDirective, i8.NgControlStatus, i8.NgModel, i9.EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, CheckDirective],\n    encapsulation: 2\n  });\n  return MultiSelectTreeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the retrieval of the child nodes when flat data is provided.\n */\n\n\nlet DropDownTreeFlatBindingDirective = /*#__PURE__*/(() => {\n  class DropDownTreeFlatBindingDirective extends FlatDataBindingDirective {\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      this.dropDownTree = dropDownTree;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set filter(term) {\n      super.filter = term;\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.dropDownTree.nodes = changes.nodes.currentValue;\n        super.nodes = changes.nodes.currentValue;\n      }\n\n      super.ngOnChanges(changes);\n    }\n\n  }\n\n  DropDownTreeFlatBindingDirective.ɵfac = function DropDownTreeFlatBindingDirective_Factory(t) {\n    return new (t || DropDownTreeFlatBindingDirective)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  };\n\n  DropDownTreeFlatBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropDownTreeFlatBindingDirective,\n    selectors: [[\"\", \"kendoDropDownTreeFlatBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoDropDownTreeFlatBinding\", \"nodes\"],\n      idField: [\"valueField\", \"idField\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return DropDownTreeFlatBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INDEX_SEPARATOR = '_';\n\nconst nodeIndex = (index = '', parentIndex = '') => {\n  return `${parentIndex}${parentIndex ? INDEX_SEPARATOR : ''}${index}`;\n};\n\nconst isArrayWithAtLeastOneItem = v => v && Array.isArray(v) && v.length !== 0;\n\nconst mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n\n  return currentLevelNodes.map((node, idx) => {\n    const index = nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToWrappers(getter$1(childrenField)(node), childrenField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.\n */\n\n\nlet DropDownTreeHierarchyBindingDirective = /*#__PURE__*/(() => {\n  class DropDownTreeHierarchyBindingDirective extends HierarchyBindingDirective {\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      this.dropDownTree = dropDownTree;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set filter(term) {\n      super.filter = term;\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.dropDownTree.nodes = changes.nodes.currentValue;\n        super.nodes = changes.nodes.currentValue;\n      }\n\n      super.ngOnChanges(changes);\n    }\n\n  }\n\n  DropDownTreeHierarchyBindingDirective.ɵfac = function DropDownTreeHierarchyBindingDirective_Factory(t) {\n    return new (t || DropDownTreeHierarchyBindingDirective)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  };\n\n  DropDownTreeHierarchyBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropDownTreeHierarchyBindingDirective,\n    selectors: [[\"\", \"kendoDropDownTreeHierarchyBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoDropDownTreeHierarchyBinding\", \"nodes\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return DropDownTreeHierarchyBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the retrieval of the child nodes when flat data is provided.\n */\n\n\nlet MultiSelectTreeFlatBindingDirective = /*#__PURE__*/(() => {\n  class MultiSelectTreeFlatBindingDirective extends FlatDataBindingDirective {\n    constructor(multiSelectTree) {\n      super(multiSelectTree);\n      this.multiSelectTree = multiSelectTree;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set filter(term) {\n      super.filter = term;\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.multiSelectTree.nodes = changes.nodes.currentValue;\n        super.nodes = changes.nodes.currentValue;\n      }\n\n      super.ngOnChanges(changes);\n    }\n\n  }\n\n  MultiSelectTreeFlatBindingDirective.ɵfac = function MultiSelectTreeFlatBindingDirective_Factory(t) {\n    return new (t || MultiSelectTreeFlatBindingDirective)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  };\n\n  MultiSelectTreeFlatBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MultiSelectTreeFlatBindingDirective,\n    selectors: [[\"\", \"kendoMultiSelectTreeFlatBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoMultiSelectTreeFlatBinding\", \"nodes\"],\n      idField: [\"valueField\", \"idField\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return MultiSelectTreeFlatBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.\n */\n\n\nlet MultiSelectTreeHierarchyBindingDirective = /*#__PURE__*/(() => {\n  class MultiSelectTreeHierarchyBindingDirective extends HierarchyBindingDirective {\n    constructor(multiSelectTree) {\n      super(multiSelectTree);\n      this.multiSelectTree = multiSelectTree;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set filter(term) {\n      super.filter = term;\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('nodes', changes, false)) {\n        this.multiSelectTree.nodes = changes.nodes.currentValue;\n        super.nodes = changes.nodes.currentValue;\n      }\n\n      super.ngOnChanges(changes);\n    }\n\n  }\n\n  MultiSelectTreeHierarchyBindingDirective.ɵfac = function MultiSelectTreeHierarchyBindingDirective_Factory(t) {\n    return new (t || MultiSelectTreeHierarchyBindingDirective)(i0.ɵɵdirectiveInject(i1$1.DataBoundComponent));\n  };\n\n  MultiSelectTreeHierarchyBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MultiSelectTreeHierarchyBindingDirective,\n    selectors: [[\"\", \"kendoMultiSelectTreeHierarchyBinding\", \"\"]],\n    inputs: {\n      nodes: [\"kendoMultiSelectTreeHierarchyBinding\", \"nodes\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return MultiSelectTreeHierarchyBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which manages the expanded state of the popup TreeView.\n */\n\n\nlet DropDownTreesExpandDirective = /*#__PURE__*/(() => {\n  class DropDownTreesExpandDirective extends ExpandDirective {\n    constructor(dropDownTree) {\n      super(dropDownTree);\n      this.dropDownTree = dropDownTree;\n    }\n    /**\n     * @hidden\n     *\n     * Ensures a user-defined `isNodeExpanded` callback will not be overriden by the default directive setup.\n     * Implemented as a value setter in the base directive, this just overrides the input name.\n     */\n\n\n    set isExpanded(value) {\n      this.dropDownTree.isExpanded = value;\n    }\n\n  }\n\n  DropDownTreesExpandDirective.ɵfac = function DropDownTreesExpandDirective_Factory(t) {\n    return new (t || DropDownTreesExpandDirective)(i0.ɵɵdirectiveInject(i1$1.ExpandableComponent));\n  };\n\n  DropDownTreesExpandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropDownTreesExpandDirective,\n    selectors: [[\"\", \"kendoDropDownTreeExpandable\", \"\"], [\"\", \"kendoMultiSelectTreeExpandable\", \"\"]],\n    inputs: {\n      isExpanded: [\"isNodeExpanded\", \"isExpanded\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return DropDownTreesExpandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages\n * ([see example]({% slug rtl_dropdowns %}#toc-messages)).\n */\n\n\nlet CustomMessagesComponent = /*#__PURE__*/(() => {\n  class CustomMessagesComponent extends Messages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) {\n    return new (t || CustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  CustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CustomMessagesComponent,\n    selectors: [[\"kendo-dropdownlist-messages\"], [\"kendo-combobox-messages\"], [\"kendo-multicolumncombobox-messages\"], [\"kendo-autocomplete-messages\"], [\"kendo-multiselect-messages\"], [\"kendo-dropdowntree-messages\"], [\"kendo-multiselecttree-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Messages,\n      useExisting: forwardRef(() => CustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_FILTER_SETTINGS = {\n  caseSensitive: false,\n  operator: 'startsWith'\n};\n/**\n * Implements an event handler for the `filterChange` event of a DropDowns component\n * which performs simple data filtering.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"data\"\n *      kendoDropDownFilter\n *      placeholder=\"e.g. Andorra\"\n *  >\n *  </kendo-autocomplete>\n * `\n * })\n * class AppComponent {\n *     public data: Array<string> = [\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\"];\n * }\n * ```\n * > Currently, the built-in filtering does not work with [grouped data]({% slug api_kendo-data-query_groupby %}).\n */\n\nlet FilterDirective = /*#__PURE__*/(() => {\n  class FilterDirective {\n    constructor(component) {\n      this.component = component;\n      /**\n       * @hidden\n       *\n       * Sets whether the filtering functionality is enabled on component init.\n       */\n\n      this.filterable = true;\n      this._data = [];\n    }\n    /**\n     * The initial data that will be used as a source array for the filtering operations.\n     */\n\n\n    set data(data) {\n      this._data = data || [];\n    }\n\n    get data() {\n      return this._data;\n    }\n\n    ngOnInit() {\n      this.component.filterable = this.filterable;\n      this.filterChangeSubscription = this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n    }\n\n    ngOnDestroy() {\n      if (isPresent(this.filterChangeSubscription)) {\n        this.filterChangeSubscription.unsubscribe();\n      }\n    }\n\n    handleFilterChange(query) {\n      this.component.data = this.data.filter(item => this.matchesAnyField(item, query));\n    }\n\n    matchesAnyField(item, query) {\n      const normalizedQuery = this.normalizeValue(query);\n      const {\n        fields\n      } = this.filterSettings; // if no filter fields are present, we are dealing with primitive data\n\n      if (fields.length === 0) {\n        return this.checkItem(item, normalizedQuery);\n      }\n\n      return fields.some(field => this.checkItem(getter(item, field), normalizedQuery));\n    }\n\n    checkItem(target, query) {\n      target = this.normalizeValue(target);\n\n      if (this.filterSettings.operator === 'contains') {\n        return target.indexOf(query) !== -1;\n      } else {\n        return target.indexOf(query) === 0;\n      }\n    }\n\n    normalizeValue(value) {\n      const normalizedValue = isPresent(value) ? value.toString() : '';\n      return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();\n    }\n\n    getFilterFields(providedFields) {\n      // ignore provided fields if the component deals with primitive data\n      if (!this.component.textField && !this.component.valueField) {\n        return [];\n      }\n\n      if (isArray(providedFields) && providedFields.length > 0) {\n        return providedFields;\n      } else {\n        // the autocomplete uses `valueField` for text extraction\n        const textField = this.component.textField || this.component.valueField;\n        return [textField];\n      }\n    }\n\n    get filterSettings() {\n      const settings = this.rawSettings;\n      const providedFields = isPresent(settings) && typeof settings === 'object' ? settings.fields : [];\n      return Object.assign({}, DEFAULT_FILTER_SETTINGS, settings, {\n        fields: this.getFilterFields(providedFields)\n      });\n    }\n\n  }\n\n  FilterDirective.ɵfac = function FilterDirective_Factory(t) {\n    return new (t || FilterDirective)(i0.ɵɵdirectiveInject(FilterableComponent));\n  };\n\n  FilterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilterDirective,\n    selectors: [[\"\", \"kendoDropDownFilter\", \"\"]],\n    inputs: {\n      data: \"data\",\n      rawSettings: [\"kendoDropDownFilter\", \"rawSettings\"],\n      filterable: \"filterable\"\n    }\n  });\n  return FilterDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SHARED_DIRECTIVES = [HeaderTemplateDirective, FooterTemplateDirective, ItemTemplateDirective, GroupTemplateDirective, FixedGroupTemplateDirective, NoDataTemplateDirective, ValueTemplateDirective, TagTemplateDirective, GroupTagTemplateDirective, LocalizedMessagesDirective, CustomMessagesComponent, FilterDirective, FilterInputDirective];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `ValueTemplateDirective`&mdash;The value template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The noData template directive.\n * - `TagTemplateDirective`&mdash;The tag template directive.\n * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.\n */\n\nlet SharedDirectivesModule = /*#__PURE__*/(() => {\n  class SharedDirectivesModule {}\n\n  SharedDirectivesModule.ɵfac = function SharedDirectivesModule_Factory(t) {\n    return new (t || SharedDirectivesModule)();\n  };\n\n  SharedDirectivesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedDirectivesModule\n  });\n  SharedDirectivesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return SharedDirectivesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INTERNAL_DIRECTIVES = [ListComponent, ListItemDirective, SelectableDirective, SearchBarComponent, TemplateContextDirective, TagListComponent, CheckDirective, CheckAllDirective];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {}\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule, EventsModule], CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule, EventsModule]\n  });\n  return SharedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which configures the MultiSelectTree to show one single summary tag for all selected data items.\n * When a number is provided, the summary tag is displayed after the given amount of data items are selected\n * ([more information and examples]({% slug api_dropdowns_multiselecttreesummarytagdirective %})).\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselecttree kendoMultiSelectTreeSummaryTag [data]=\"data\"></kendo-multiselecttree>\n * ```\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselecttree [kendoMultiSelectTreeSummaryTag]=\"2\" [data]=\"data\"></kendo-multiselecttree>\n * ```\n */\n\n\nlet MultiSelectTreeSummaryTagDirective = /*#__PURE__*/(() => {\n  class MultiSelectTreeSummaryTagDirective {\n    constructor(multiSelectTreeComponent) {\n      this.multiSelectTreeComponent = multiSelectTreeComponent;\n      /**\n       * A numeric value that indicates the number of selected data items after which the summary tag will appear.\n       */\n\n      this.showAfter = 0;\n      this.createTagMapper();\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.showAfter)) {\n        this.createTagMapper();\n        this.multiSelectTreeComponent.handleTagMapperChange(this.showAfter);\n      }\n    }\n\n    createTagMapper() {\n      const showAfter = parseNumber(this.showAfter);\n\n      this.multiSelectTreeComponent.tagMapper = tags => {\n        if (tags.length > showAfter) {\n          // tags provided in an array are rendered as a single group tag\n          return [...tags.slice(0, showAfter), tags.slice(showAfter)];\n        } else {\n          return tags;\n        }\n      };\n    }\n\n  }\n\n  MultiSelectTreeSummaryTagDirective.ɵfac = function MultiSelectTreeSummaryTagDirective_Factory(t) {\n    return new (t || MultiSelectTreeSummaryTagDirective)(i0.ɵɵdirectiveInject(MultiSelectTreeComponent));\n  };\n\n  MultiSelectTreeSummaryTagDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MultiSelectTreeSummaryTagDirective,\n    selectors: [[\"\", \"kendoMultiSelectTreeSummaryTag\", \"\"]],\n    inputs: {\n      showAfter: [\"kendoMultiSelectTreeSummaryTag\", \"showAfter\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MultiSelectTreeSummaryTagDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DROPDOWNTREE_DIRECTIVES = [DropDownTreeComponent, MultiSelectTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective, MultiSelectTreeSummaryTagDirective];\n/**\n * @hidden\n */\n\nlet DropDownTreesModule = /*#__PURE__*/(() => {\n  class DropDownTreesModule {}\n\n  DropDownTreesModule.ɵfac = function DropDownTreesModule_Factory(t) {\n    return new (t || DropDownTreesModule)();\n  };\n\n  DropDownTreesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DropDownTreesModule\n  });\n  DropDownTreesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedModule, TreeViewModule], SharedDirectivesModule]\n  });\n  return DropDownTreesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which configures the MultiSelect to show one single summary tag for all selected data items.\n * When a number is provided, the summary tag is displayed after the given amount of data items are selected\n * ([more information and examples]({% slug summarytagmode_multiselect %})).\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect kendoMultiSelectSummaryTag [data]=\"data\"></kendo-multiselect>\n * ```\n *\n * @example\n * ```ts-no-run\n * <kendo-multiselect [kendoMultiSelectSummaryTag]=\"2\" [data]=\"data\"></kendo-multiselect>\n * ```\n */\n\n\nlet SummaryTagDirective = /*#__PURE__*/(() => {\n  class SummaryTagDirective {\n    constructor(multiSelectComponent) {\n      this.multiSelectComponent = multiSelectComponent;\n      /**\n       * A numeric value that indicates the number of selected data items after which the summary tag will appear.\n       */\n\n      this.showAfter = 0;\n      this.createTagMapper();\n    }\n\n    ngOnChanges(changes) {\n      if (isPresent(changes.showAfter)) {\n        this.createTagMapper();\n        this.multiSelectComponent.onTagMapperChange();\n      }\n    }\n\n    createTagMapper() {\n      const showAfter = parseNumber(this.showAfter);\n\n      this.multiSelectComponent.tagMapper = tags => {\n        if (tags.length > showAfter) {\n          let result;\n          result = tags.slice(0, showAfter);\n          result.push(tags.slice(showAfter, tags.length));\n          return result;\n        } else {\n          return tags;\n        }\n      };\n    }\n\n  }\n\n  SummaryTagDirective.ɵfac = function SummaryTagDirective_Factory(t) {\n    return new (t || SummaryTagDirective)(i0.ɵɵdirectiveInject(MultiSelectComponent));\n  };\n\n  SummaryTagDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SummaryTagDirective,\n    selectors: [[\"\", \"kendoMultiSelectSummaryTag\", \"\"]],\n    inputs: {\n      showAfter: [\"kendoMultiSelectSummaryTag\", \"showAfter\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return SummaryTagDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst AUTOCOMPLETE_DIRECTIVES = [AutoCompleteComponent];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `AutoCompleteComponent`&mdash;The AutoComplete component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n */\n\nlet AutoCompleteModule = /*#__PURE__*/(() => {\n  class AutoCompleteModule {}\n\n  AutoCompleteModule.ɵfac = function AutoCompleteModule_Factory(t) {\n    return new (t || AutoCompleteModule)();\n  };\n\n  AutoCompleteModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AutoCompleteModule\n  });\n  AutoCompleteModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedModule], SharedDirectivesModule]\n  });\n  return AutoCompleteModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMBOBOX_DIRECTIVES = [ComboBoxComponent, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ComboBoxComponent`&mdash;The ComboBox component class.\n * - `MultiColumnComboBoxComponent`&mdash;The MultiColumnComboBox component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `ColumnHeaderTemplateDirective`&mdash;The column header template directive.\n * - `ColumnCellTemplateDirective`&mdash;The column cell template directive.\n */\n\nlet ComboBoxModule = /*#__PURE__*/(() => {\n  class ComboBoxModule {}\n\n  ComboBoxModule.ɵfac = function ComboBoxModule_Factory(t) {\n    return new (t || ComboBoxModule)();\n  };\n\n  ComboBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ComboBoxModule\n  });\n  ComboBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: touchEnabled\n    }],\n    imports: [[SharedModule], SharedDirectivesModule]\n  });\n  return ComboBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DROPDOWNLIST_DIRECTIVES = [DropDownListComponent];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownListComponent`&mdash;The DropDownList component class.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `ValueTemplateDirective`&mdash;The value template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n */\n\nlet DropDownListModule = /*#__PURE__*/(() => {\n  class DropDownListModule {}\n\n  DropDownListModule.ɵfac = function DropDownListModule_Factory(t) {\n    return new (t || DropDownListModule)();\n  };\n\n  DropDownListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DropDownListModule\n  });\n  DropDownListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedModule], SharedDirectivesModule]\n  });\n  return DropDownListModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MULTISELECT_DIRECTIVES = [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective];\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `MultiSelectComponent`&mdash;The MultiSelect component class.\n * - `SummaryTagDirective`&mdash;The MultiSelect summary tag directive.\n * - `ItemTemplateDirective`&mdash;The item template directive.\n * - `CustomItemTemplateDirective`&mdash;The custom item template directive.\n * - `TagTemplateDirective`&mdash;The tag template directive.\n * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.\n * - `HeaderTemplateDirective`&mdash;The header template directive.\n * - `FooterTemplateDirective`&mdash;The footer template directive.\n * - `NoDataTemplateDirective`&mdash;The no-data template directive.\n */\n\nlet MultiSelectModule = /*#__PURE__*/(() => {\n  class MultiSelectModule {}\n\n  MultiSelectModule.ɵfac = function MultiSelectModule_Factory(t) {\n    return new (t || MultiSelectModule)();\n  };\n\n  MultiSelectModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MultiSelectModule\n  });\n  MultiSelectModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: TOUCH_ENABLED,\n      useValue: touchEnabled\n    }],\n    imports: [[SharedModule], SharedDirectivesModule]\n  });\n  return MultiSelectModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Dropdowns components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Dropdowns module\n * import { DropDownsModule } from '@progress/kendo-angular-dropdowns';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare the app component\n *     imports:      [BrowserModule, DropDownsModule], // import the Dropdowns module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\n\n\nlet DropDownsModule = /*#__PURE__*/(() => {\n  class DropDownsModule {}\n\n  DropDownsModule.ɵfac = function DropDownsModule_Factory(t) {\n    return new (t || DropDownsModule)();\n  };\n\n  DropDownsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DropDownsModule\n  });\n  DropDownsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [AutoCompleteModule, ComboBoxModule, DropDownListModule, MultiSelectModule, DropDownTreesModule]\n  });\n  return DropDownsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AutoCompleteComponent, AutoCompleteModule, CheckAllDirective, CheckDirective, ColumnCellTemplateDirective, ColumnHeaderTemplateDirective, ComboBoxColumnComponent, ComboBoxComponent, ComboBoxModule, CustomItemTemplateDirective, CustomMessagesComponent, DropDownListComponent, DropDownListModule, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, DropDownTreesModule, DropDownsModule, FilterDirective, FilterInputDirective, FilterableComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTagTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ListComponent, ListItemDirective, LocalizedMessagesDirective, MultiColumnComboBoxComponent, MultiSelectComponent, MultiSelectModule, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, MultiSelectTreeSummaryTagDirective, NoDataTemplateDirective, NodeTemplateDirective, PreventableEvent, RemoveTagEvent, SearchBarComponent, SelectableDirective, SharedDirectivesModule, SharedModule, SummaryTagDirective, TagListComponent, TagTemplateDirective, TemplateContextDirective, ValueTemplateDirective };","map":null,"metadata":{},"sourceType":"module"}