{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(912);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  891:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  912:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(913), __webpack_require__(891)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            dataviz = kendo.dataviz,\n            Utils = diagram.Utils,\n            Point = dataviz.Point2D,\n            isFunction = kendo.isFunction,\n            contains = Utils.contains,\n            map = $.map; // Constants ==============================================================\n\n        var HITTESTAREA = 3,\n            EPSILON = 1e-06;\n        deepExtend(Point.fn, {\n          plus: function (p) {\n            return new Point(this.x + p.x, this.y + p.y);\n          },\n          minus: function (p) {\n            return new Point(this.x - p.x, this.y - p.y);\n          },\n          offset: function (value) {\n            return new Point(this.x - value, this.y - value);\n          },\n          times: function (s) {\n            return new Point(this.x * s, this.y * s);\n          },\n          normalize: function () {\n            if (this.length() === 0) {\n              return new Point();\n            }\n\n            return this.times(1 / this.length());\n          },\n          length: function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n          },\n          toString: function () {\n            return \"(\" + this.x + \",\" + this.y + \")\";\n          },\n          lengthSquared: function () {\n            return this.x * this.x + this.y * this.y;\n          },\n          middleOf: function MiddleOf(p, q) {\n            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n          },\n          toPolar: function (useDegrees) {\n            var factor = 1;\n\n            if (useDegrees) {\n              factor = 180 / Math.PI;\n            }\n\n            var a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            var halfpi = Math.PI / 2;\n            var len = this.length();\n\n            if (this.x === 0) {\n              // note that the angle goes down and not the usual mathematical convention\n              if (this.y === 0) {\n                return new Polar(0, 0);\n              }\n\n              if (this.y > 0) {\n                return new Polar(len, factor * halfpi);\n              }\n\n              if (this.y < 0) {\n                return new Polar(len, factor * 3 * halfpi);\n              }\n            } else if (this.x > 0) {\n              if (this.y === 0) {\n                return new Polar(len, 0);\n              }\n\n              if (this.y > 0) {\n                return new Polar(len, factor * a);\n              }\n\n              if (this.y < 0) {\n                return new Polar(len, factor * (4 * halfpi - a));\n              }\n            } else {\n              if (this.y === 0) {\n                return new Polar(len, 2 * halfpi);\n              }\n\n              if (this.y > 0) {\n                return new Polar(len, factor * (2 * halfpi - a));\n              }\n\n              if (this.y < 0) {\n                return new Polar(len, factor * (2 * halfpi + a));\n              }\n            }\n          },\n          isOnLine: function (from, to) {\n            if (from.x > to.x) {\n              // from must be the leftmost point\n              var temp = to;\n              to = from;\n              from = temp;\n            }\n\n            var r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA),\n                r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA),\n                o1,\n                u1;\n\n            if (r1.union(r2).contains(this)) {\n              if (from.x === to.x || from.y === to.y) {\n                return true;\n              } else if (from.y < to.y) {\n                o1 = r1.x + (r2.x - r1.x) * (this.y - (r1.y + r1.height)) / (r2.y + r2.height - (r1.y + r1.height));\n                u1 = r1.x + r1.width + (r2.x + r2.width - (r1.x + r1.width)) * (this.y - r1.y) / (r2.y - r1.y);\n              } else {\n                o1 = r1.x + (r2.x - r1.x) * (this.y - r1.y) / (r2.y - r1.y);\n                u1 = r1.x + r1.width + (r2.x + r2.width - (r1.x + r1.width)) * (this.y - (r1.y + r1.height)) / (r2.y + r2.height - (r1.y + r1.height));\n              }\n\n              return this.x > o1 && this.x < u1;\n            }\n\n            return false;\n          }\n        });\n        deepExtend(Point, {\n          parse: function (str) {\n            var tempStr = str.slice(1, str.length - 1),\n                xy = tempStr.split(\",\"),\n                x = parseInt(xy[0], 10),\n                y = parseInt(xy[1], 10);\n\n            if (!isNaN(x) && !isNaN(y)) {\n              return new Point(x, y);\n            }\n          }\n        });\n        /**\n         * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n         * If the additional points are null or equal to the first point the path will be sharp.\n         * Left and right correspond to the direction of the underlying path.\n         */\n\n        var PathDefiner = Class.extend({\n          init: function (p, left, right) {\n            this.point = p;\n            this.left = left;\n            this.right = right;\n          }\n        });\n        /**\n         * Defines a rectangular region.\n         */\n\n        var Rect = Class.extend({\n          init: function (x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n          },\n          contains: function (point) {\n            return point.x >= this.x && point.x <= this.x + this.width && point.y >= this.y && point.y <= this.y + this.height;\n          },\n          inflate: function (dx, dy) {\n            if (dy === undefined) {\n              dy = dx;\n            }\n\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n          },\n          offset: function (dx, dy) {\n            var x = dx,\n                y = dy;\n\n            if (dx instanceof Point) {\n              x = dx.x;\n              y = dx.y;\n            }\n\n            this.x += x;\n            this.y += y;\n            return this;\n          },\n          union: function (r) {\n            var x1 = Math.min(this.x, r.x);\n            var y1 = Math.min(this.y, r.y);\n            var x2 = Math.max(this.x + this.width, r.x + r.width);\n            var y2 = Math.max(this.y + this.height, r.y + r.height);\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n          },\n          center: function () {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n          },\n          top: function () {\n            return new Point(this.x + this.width / 2, this.y);\n          },\n          right: function () {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n          },\n          bottom: function () {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n          },\n          left: function () {\n            return new Point(this.x, this.y + this.height / 2);\n          },\n          topLeft: function () {\n            return new Point(this.x, this.y);\n          },\n          topRight: function () {\n            return new Point(this.x + this.width, this.y);\n          },\n          bottomLeft: function () {\n            return new Point(this.x, this.y + this.height);\n          },\n          bottomRight: function () {\n            return new Point(this.x + this.width, this.y + this.height);\n          },\n          clone: function () {\n            return new Rect(this.x, this.y, this.width, this.height);\n          },\n          isEmpty: function () {\n            return !this.width && !this.height;\n          },\n          equals: function (rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n          },\n          rotatedBounds: function (angle) {\n            var rect = this.clone(),\n                points = this.rotatedPoints(angle),\n                tl = points[0],\n                tr = points[1],\n                br = points[2],\n                bl = points[3];\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n            return rect;\n          },\n          rotatedPoints: function (angle) {\n            var rect = this,\n                c = rect.center(),\n                br = rect.bottomRight().rotate(c, 360 - angle),\n                tl = rect.topLeft().rotate(c, 360 - angle),\n                tr = rect.topRight().rotate(c, 360 - angle),\n                bl = rect.bottomLeft().rotate(c, 360 - angle);\n            return [tl, tr, br, bl];\n          },\n          toString: function (delimiter) {\n            delimiter = delimiter || \" \";\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n          },\n          scale: function (scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            var tl = this.topLeft();\n            var thisCenter = this.center();\n            tl.rotate(thisCenter, 360 - angle).rotate(adornerCenter, angle);\n            var delta = staicPoint.minus(tl);\n            var scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n            var position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(adornerCenter, 360 - angle).rotate(thisCenter, angle);\n            this.x = tl.x;\n            this.y = tl.y;\n            this.width *= scaleX;\n            this.height *= scaleY;\n          },\n          zoom: function (zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n          },\n          overlaps: function (rect) {\n            var bottomRight = this.bottomRight();\n            var rectBottomRight = rect.bottomRight();\n            var overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y || rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n          }\n        });\n        var Size = Class.extend({\n          init: function (width, height) {\n            this.width = width;\n            this.height = height;\n          }\n        });\n        Size.prototype.Empty = new Size(0, 0);\n\n        Rect.toRect = function (rect) {\n          if (!(rect instanceof Rect)) {\n            rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n          }\n\n          return rect;\n        };\n\n        Rect.empty = function () {\n          return new Rect(0, 0, 0, 0);\n        };\n\n        Rect.fromPoints = function (p, q) {\n          if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n            throw \"Some values are NaN.\";\n          }\n\n          return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n        };\n\n        function isNearZero(num) {\n          return Math.abs(num) < EPSILON;\n        }\n\n        function intersectLine(start1, end1, start2, end2, isSegment) {\n          var tangensdiff = (end1.x - start1.x) * (end2.y - start2.y) - (end1.y - start1.y) * (end2.x - start2.x);\n\n          if (isNearZero(tangensdiff)) {\n            //parallel lines\n            return;\n          }\n\n          var num1 = (start1.y - start2.y) * (end2.x - start2.x) - (start1.x - start2.x) * (end2.y - start2.y);\n          var num2 = (start1.y - start2.y) * (end1.x - start1.x) - (start1.x - start2.x) * (end1.y - start1.y);\n          var r = num1 / tangensdiff;\n          var s = num2 / tangensdiff;\n\n          if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            //r < 0 => line 1 is below line 2\n            //r > 1 => line 1 is above line 2\n            //s < 0 => line 2 is below line 1\n            //s > 1 => line 2 is above line 1\n            return;\n          }\n\n          return new Point(start1.x + r * (end1.x - start1.x), start1.y + r * (end1.y - start1.y));\n        }\n\n        var Intersect = {\n          lines: function (start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n          },\n          segments: function (start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n          },\n          rectWithLine: function (rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) || Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) || Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) || Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n          },\n          rects: function (rect1, rect2, angle) {\n            var tl = rect2.topLeft(),\n                tr = rect2.topRight(),\n                bl = rect2.bottomLeft(),\n                br = rect2.bottomRight();\n            var center = rect2.center();\n\n            if (angle) {\n              tl = tl.rotate(center, angle);\n              tr = tr.rotate(center, angle);\n              bl = bl.rotate(center, angle);\n              br = br.rotate(center, angle);\n            }\n\n            var intersect = rect1.contains(tl) || rect1.contains(tr) || rect1.contains(bl) || rect1.contains(br) || Intersect.rectWithLine(rect1, tl, tr) || Intersect.rectWithLine(rect1, tl, bl) || Intersect.rectWithLine(rect1, tr, br) || Intersect.rectWithLine(rect1, bl, br);\n\n            if (!intersect) {\n              //last possible case is rect1 to be completely within rect2\n              tl = rect1.topLeft();\n              tr = rect1.topRight();\n              bl = rect1.bottomLeft();\n              br = rect1.bottomRight();\n\n              if (angle) {\n                var reverseAngle = 360 - angle;\n                tl = tl.rotate(center, reverseAngle);\n                tr = tr.rotate(center, reverseAngle);\n                bl = bl.rotate(center, reverseAngle);\n                br = br.rotate(center, reverseAngle);\n              }\n\n              intersect = rect2.contains(tl) || rect2.contains(tr) || rect2.contains(bl) || rect2.contains(br);\n            }\n\n            return intersect;\n          }\n        };\n        /**\n         * Aligns two rectangles, where one is the container and the other is content.\n         */\n\n        var RectAlign = Class.extend({\n          init: function (container) {\n            this.container = Rect.toRect(container);\n          },\n          align: function (content, alignment) {\n            var alignValues = alignment.toLowerCase().split(\" \");\n\n            for (var i = 0; i < alignValues.length; i++) {\n              content = this._singleAlign(content, alignValues[i]);\n            }\n\n            return content;\n          },\n          _singleAlign: function (content, alignment) {\n            if (isFunction(this[alignment])) {\n              return this[alignment](content);\n            } else {\n              return content;\n            }\n          },\n          left: function (content) {\n            return this._align(content, this._left);\n          },\n          center: function (content) {\n            return this._align(content, this._center);\n          },\n          right: function (content) {\n            return this._align(content, this._right);\n          },\n          stretch: function (content) {\n            return this._align(content, this._stretch);\n          },\n          top: function (content) {\n            return this._align(content, this._top);\n          },\n          middle: function (content) {\n            return this._align(content, this._middle);\n          },\n          bottom: function (content) {\n            return this._align(content, this._bottom);\n          },\n          _left: function (container, content) {\n            content.x = container.x;\n          },\n          _center: function (container, content) {\n            content.x = (container.width - content.width) / 2 || 0;\n          },\n          _right: function (container, content) {\n            content.x = container.width - content.width;\n          },\n          _top: function (container, content) {\n            content.y = container.y;\n          },\n          _middle: function (container, content) {\n            content.y = (container.height - content.height) / 2 || 0;\n          },\n          _bottom: function (container, content) {\n            content.y = container.height - content.height;\n          },\n          _stretch: function (container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n          },\n          _align: function (content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n            return content;\n          }\n        });\n        var Polar = Class.extend({\n          init: function (r, a) {\n            this.r = r;\n            this.angle = a;\n          }\n        });\n        /**\n         * SVG transformation matrix.\n         */\n\n        var Matrix = Class.extend({\n          init: function (a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n          },\n          plus: function (m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n          },\n          minus: function (m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n          },\n          times: function (m) {\n            return new Matrix(this.a * m.a + this.c * m.b, this.b * m.a + this.d * m.b, this.a * m.c + this.c * m.d, this.b * m.c + this.d * m.d, this.a * m.e + this.c * m.f + this.e, this.b * m.e + this.d * m.f + this.f);\n          },\n          apply: function (p) {\n            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n          },\n          applyRect: function (r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n          },\n          toString: function () {\n            return \"matrix(\" + this.a + \" \" + this.b + \" \" + this.c + \" \" + this.d + \" \" + this.e + \" \" + this.f + \")\";\n          }\n        });\n        deepExtend(Matrix, {\n          fromSVGMatrix: function (vm) {\n            var m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n          },\n          fromMatrixVector: function (v) {\n            var m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n          },\n          fromList: function (v) {\n            if (v.length !== 6) {\n              throw \"The given list should consist of six elements.\";\n            }\n\n            var m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n          },\n          translation: function (x, y) {\n            var m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n          },\n          unit: function () {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n          },\n          rotation: function (angle, x, y) {\n            var m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = x - x * m.a + y * m.b || 0;\n            m.f = y - y * m.a - x * m.b || 0;\n            return m;\n          },\n          scaling: function (scaleX, scaleY) {\n            var m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n          },\n          parse: function (v) {\n            var parts, nums;\n\n            if (v) {\n              v = v.trim(); // of the form \"matrix(...)\"\n\n              if (v.slice(0, 6).toLowerCase() === \"matrix\") {\n                nums = v.slice(7, v.length - 1).trim();\n                parts = nums.split(\",\");\n\n                if (parts.length === 6) {\n                  return Matrix.fromList(map(parts, function (p) {\n                    return parseFloat(p);\n                  }));\n                }\n\n                parts = nums.split(\" \");\n\n                if (parts.length === 6) {\n                  return Matrix.fromList(map(parts, function (p) {\n                    return parseFloat(p);\n                  }));\n                }\n              } // of the form \"(...)\"\n\n\n              if (v.slice(0, 1) === \"(\" && v.slice(v.length - 1) === \")\") {\n                v = v.substr(1, v.length - 1);\n              }\n\n              if (v.indexOf(\",\") > 0) {\n                parts = v.split(\",\");\n\n                if (parts.length === 6) {\n                  return Matrix.fromList(map(parts, function (p) {\n                    return parseFloat(p);\n                  }));\n                }\n              }\n\n              if (v.indexOf(\" \") > 0) {\n                parts = v.split(\" \");\n\n                if (parts.length === 6) {\n                  return Matrix.fromList(map(parts, function (p) {\n                    return parseFloat(p);\n                  }));\n                }\n              }\n            }\n\n            return parts;\n          }\n        });\n        /**\n         * SVG transformation represented as a vector.\n         */\n\n        var MatrixVector = Class.extend({\n          init: function (a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n          },\n          fromMatrix: function FromMatrix(m) {\n            var v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n          }\n        });\n        /**\n         * Returns a value with Gaussian (normal) distribution.\n         * @param mean The mean value of the distribution.\n         * @param deviation The deviation (spreading at half-height) of the distribution.\n         * @returns {number}\n         */\n\n        function normalVariable(mean, deviation) {\n          var x, y, r;\n\n          do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n          } while (!r || r > 1);\n\n          return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n        }\n        /**\n         * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n         * @returns {string}\n         */\n\n\n        function randomId(length) {\n          if (Utils.isUndefined(length)) {\n            length = 10;\n          } // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n\n\n          var result = '';\n          var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n          for (var i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n          }\n\n          return result;\n        }\n\n        var Geometry = {\n          /**\n           * Returns the squared distance to the line defined by the two given Points.\n           * @param p An arbitrary Point.\n           * @param a An endpoint of the line or segment.\n           * @param b The complementary endpoint of the line or segment.\n           */\n          _distanceToLineSquared: function (p, a, b) {\n            function d2(pt1, pt2) {\n              return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n\n            if (a === b) {\n              // returns the distance of p to a\n              return d2(p, a);\n            }\n\n            var vx = b.x - a.x,\n                vy = b.y - a.y,\n                dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n\n            if (dot < 0) {\n              return d2(a, p); // sits on side of a\n            }\n\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n\n            if (dot < 0) {\n              return d2(b, p); // sits on side of b\n            } // regular case, use crossproduct to get the sine out\n\n\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n          },\n\n          /**\n           * Returns the distance to the line defined by the two given Points.\n           * @param p An arbitrary Point.\n           * @param a An endpoint of the line or segment.\n           * @param b The complementary endpoint of the line or segment.\n           */\n          distanceToLine: function (p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n          },\n\n          /**\n           * Returns the distance of the given points to the polyline defined by the points.\n           * @param p An arbitrary point.\n           * @param points The points defining the polyline.\n           * @returns {Number}\n           */\n          distanceToPolyline: function (p, points) {\n            var minimum = Number.MAX_VALUE;\n\n            if (Utils.isUndefined(points) || points.length === 0) {\n              return Number.MAX_VALUE;\n            }\n\n            for (var s = 0; s < points.length - 1; s++) {\n              var p1 = points[s];\n              var p2 = points[s + 1];\n\n              var d = this._distanceToLineSquared(p, p1, p2);\n\n              if (d < minimum) {\n                minimum = d;\n              }\n            }\n\n            return Math.sqrt(minimum);\n          }\n        };\n        /*---------------The HashTable structure--------------------------------*/\n\n        /**\n         * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n         * _buckets[hashId] = {key: key, value:...}\n         * Important: do not use the standard Array access method, use the get/set methods instead.\n         * See http://en.wikipedia.org/wiki/Hash_table\n         */\n\n        var HashTable = kendo.Class.extend({\n          init: function () {\n            this._buckets = [];\n            this.length = 0;\n          },\n\n          /**\n           * Adds the literal object with the given key (of the form {key: key,....}).\n           */\n          add: function (key, value) {\n            var obj = this._createGetBucket(key);\n\n            if (Utils.isDefined(value)) {\n              obj.value = value;\n            }\n\n            return obj;\n          },\n\n          /**\n           * Gets the literal object with the given key.\n           */\n          get: function (key) {\n            if (this._bucketExists(key)) {\n              return this._createGetBucket(key);\n            }\n\n            return null;\n          },\n\n          /**\n           * Set the key-value pair.\n           * @param key The key of the entry.\n           * @param value The value to set. If the key already exists the value will be overwritten.\n           */\n          set: function (key, value) {\n            this.add(key, value);\n          },\n\n          /**\n           * Determines whether the HashTable contains a specific key.\n           */\n          containsKey: function (key) {\n            return this._bucketExists(key);\n          },\n\n          /**\n           * Removes the element with the specified key from the hashtable.\n           * Returns the removed bucket.\n           */\n          remove: function (key) {\n            if (this._bucketExists(key)) {\n              var hashId = this._hash(key);\n\n              delete this._buckets[hashId];\n              this.length--;\n              return key;\n            }\n          },\n\n          /**\n           * Foreach with an iterator working on the key-value pairs.\n           * @param func\n           */\n          forEach: function (func) {\n            var hashes = this._hashes();\n\n            for (var i = 0, len = hashes.length; i < len; i++) {\n              var hash = hashes[i];\n              var bucket = this._buckets[hash];\n\n              if (Utils.isUndefined(bucket)) {\n                continue;\n              }\n\n              func(bucket);\n            }\n          },\n\n          /**\n           * Returns a (shallow) clone of the current HashTable.\n           * @returns {HashTable}\n           */\n          clone: function () {\n            var ht = new HashTable();\n\n            var hashes = this._hashes();\n\n            for (var i = 0, len = hashes.length; i < len; i++) {\n              var hash = hashes[i];\n              var bucket = this._buckets[hash];\n\n              if (Utils.isUndefined(bucket)) {\n                continue;\n              }\n\n              ht.add(bucket.key, bucket.value);\n            }\n\n            return ht;\n          },\n\n          /**\n           * Returns the hashes of the buckets.\n           * @returns {Array}\n           * @private\n           */\n          _hashes: function () {\n            var hashes = [];\n\n            for (var hash in this._buckets) {\n              if (this._buckets.hasOwnProperty(hash)) {\n                hashes.push(hash);\n              }\n            }\n\n            return hashes;\n          },\n          _bucketExists: function (key) {\n            var hashId = this._hash(key);\n\n            return Utils.isDefined(this._buckets[hashId]);\n          },\n\n          /**\n           * Returns-adds the createGetBucket with the given key. If not present it will\n           * be created and returned.\n           * A createGetBucket is a literal object of the form {key: key, ...}.\n           */\n          _createGetBucket: function (key) {\n            var hashId = this._hash(key);\n\n            var bucket = this._buckets[hashId];\n\n            if (Utils.isUndefined(bucket)) {\n              bucket = {\n                key: key\n              };\n              this._buckets[hashId] = bucket;\n              this.length++;\n            }\n\n            return bucket;\n          },\n\n          /**\n           * Hashing of the given key.\n           */\n          _hash: function (key) {\n            if (Utils.isNumber(key)) {\n              return key;\n            }\n\n            if (Utils.isString(key)) {\n              return this._hashString(key);\n            }\n\n            if (Utils.isObject(key)) {\n              return this._objectHashId(key);\n            }\n\n            throw \"Unsupported key type.\";\n          },\n\n          /**\n           * Hashing of a string.\n           */\n          _hashString: function (s) {\n            // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n            var result = 0;\n\n            if (s.length === 0) {\n              return result;\n            }\n\n            for (var i = 0; i < s.length; i++) {\n              var ch = s.charCodeAt(i);\n              result = result * 32 - result + ch;\n            }\n\n            return result;\n          },\n\n          /**\n           * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n           */\n          _objectHashId: function (key) {\n            var id = key._hashId;\n\n            if (Utils.isUndefined(id)) {\n              id = randomId();\n              key._hashId = id;\n            }\n\n            return id;\n          }\n        });\n        /*---------------The Dictionary structure--------------------------------*/\n\n        /**\n         * Represents a collection of key-value pairs.\n         * Important: do not use the standard Array access method, use the get/Set methods instead.\n         */\n\n        var Dictionary = kendo.Observable.extend({\n          /**\n           * Initializes a new instance of the Dictionary class.\n           * @param dictionary Loads the content of the given dictionary into this new one.\n           */\n          init: function (dictionary) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n\n            if (Utils.isDefined(dictionary)) {\n              if (Array.isArray(dictionary)) {\n                for (var i = 0; i < dictionary.length; i++) {\n                  this.add(dictionary[i]);\n                }\n              } else {\n                dictionary.forEach(function (k, v) {\n                  this.add(k, v);\n                }, this);\n              }\n            }\n          },\n\n          /**\n           * Adds a key-value to the dictionary.\n           * If the key already exists this will assign the given value to the existing entry.\n           */\n          add: function (key, value) {\n            var entry = this._hashTable.get(key);\n\n            if (!entry) {\n              entry = this._hashTable.add(key);\n              this.length++;\n              this.trigger('changed');\n            }\n\n            entry.value = value;\n          },\n\n          /**\n           * Set the key-value pair.\n           * @param key The key of the entry.\n           * @param value The value to set. If the key already exists the value will be overwritten.\n           */\n          set: function (key, value) {\n            this.add(key, value);\n          },\n\n          /**\n           * Gets the value associated with the given key in the dictionary.\n           */\n          get: function (key) {\n            var entry = this._hashTable.get(key);\n\n            if (entry) {\n              return entry.value;\n            }\n\n            throw new Error(\"Cannot find key \" + key);\n          },\n\n          /**\n           * Returns whether the dictionary contains the given key.\n           */\n          containsKey: function (key) {\n            return this._hashTable.containsKey(key);\n          },\n\n          /**\n           * Removes the element with the specified key from the dictionary.\n           */\n          remove: function (key) {\n            if (this.containsKey(key)) {\n              this.trigger(\"changed\");\n              this.length--;\n              return this._hashTable.remove(key);\n            }\n          },\n\n          /**\n           * The functional gets the key and value as parameters.\n           */\n          forEach: function (func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n              func.call(thisRef, entry.key, entry.value);\n            });\n          },\n\n          /**\n           * Same as forEach except that only the value is passed to the functional.\n           */\n          forEachValue: function (func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n              func.call(thisRef, entry.value);\n            });\n          },\n\n          /**\n           * Calls a defined callback function for each key in the dictionary.\n           */\n          forEachKey: function (func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n              func.call(thisRef, entry.key);\n            });\n          },\n\n          /**\n           * Gets an array with all keys in the dictionary.\n           */\n          keys: function () {\n            var keys = [];\n            this.forEachKey(function (key) {\n              keys.push(key);\n            });\n            return keys;\n          }\n        });\n        /*---------------Queue structure--------------------------------*/\n\n        var Queue = kendo.Class.extend({\n          init: function () {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n          },\n\n          /**\n           * Enqueues an object to the end of the queue.\n           */\n          enqueue: function (value) {\n            var entry = {\n              value: value,\n              next: null\n            };\n\n            if (!this._head) {\n              this._head = entry;\n              this._tail = this._head;\n            } else {\n              this._tail.next = entry;\n              this._tail = this._tail.next;\n            }\n\n            this.length++;\n          },\n\n          /**\n           * Removes and returns the object at top of the queue.\n           */\n          dequeue: function () {\n            if (this.length < 1) {\n              throw new Error(\"The queue is empty.\");\n            }\n\n            var value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n          },\n          contains: function (item) {\n            var current = this._head;\n\n            while (current) {\n              if (current.value === item) {\n                return true;\n              }\n\n              current = current.next;\n            }\n\n            return false;\n          }\n        });\n        /**\n         * While other data structures can have multiple times the same item a Set owns only\n         * once a particular item.\n         * @type {*}\n         */\n\n        var Set = kendo.Observable.extend({\n          init: function (resource) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n\n            if (Utils.isDefined(resource)) {\n              if (resource instanceof HashTable) {\n                resource.forEach(function (d) {\n                  this.add(d);\n                });\n              } else if (resource instanceof Dictionary) {\n                resource.forEach(function (k, v) {\n                  this.add({\n                    key: k,\n                    value: v\n                  });\n                }, this);\n              }\n            }\n          },\n          contains: function (item) {\n            return this._hashTable.containsKey(item);\n          },\n          add: function (item) {\n            var entry = this._hashTable.get(item);\n\n            if (!entry) {\n              this._hashTable.add(item, item);\n\n              this.length++;\n              this.trigger('changed');\n            }\n          },\n          get: function (item) {\n            if (this.contains(item)) {\n              return this._hashTable.get(item).value;\n            } else {\n              return null;\n            }\n          },\n\n          /**\n           * Returns the hash of the item.\n           * @param item\n           * @returns {*}\n           */\n          hash: function (item) {\n            return this._hashTable._hash(item);\n          },\n\n          /**\n           * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n           * @param item\n           */\n          remove: function (item) {\n            if (this.contains(item)) {\n              this._hashTable.remove(item);\n\n              this.length--;\n              this.trigger('changed');\n            }\n          },\n\n          /**\n           * Foreach with an iterator working on the key-value pairs.\n           * @param func\n           */\n          forEach: function (func, context) {\n            this._hashTable.forEach(function (kv) {\n              func(kv.value);\n            }, context);\n          },\n          toArray: function () {\n            var r = [];\n            this.forEach(function (d) {\n              r.push(d);\n            });\n            return r;\n          }\n        });\n        /*----------------Node-------------------------------*/\n\n        /**\n         * Defines the node (vertex) of a Graph.\n         */\n\n        var Node = kendo.Class.extend({\n          init: function (id, shape) {\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n\n            this.outgoing = [];\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n\n            this.incoming = [];\n            /**\n             * Holds the weight of this Node.\n             */\n\n            this.weight = 1;\n\n            if (Utils.isDefined(id)) {\n              this.id = id;\n            } else {\n              this.id = randomId();\n            }\n\n            if (Utils.isDefined(shape)) {\n              this.associatedShape = shape; // transfer the shape's bounds to the runtime props\n\n              var b = shape.bounds();\n              this.width = b.width;\n              this.height = b.height;\n              this.x = b.x;\n              this.y = b.y;\n            } else {\n              this.associatedShape = null;\n            }\n            /**\n             * The payload of the node.\n             * @type {null}\n             */\n\n\n            this.data = null;\n            this.type = \"Node\";\n            this.shortForm = \"Node '\" + this.id + \"'\";\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             * @type {boolean}\n             */\n\n            this.isVirtual = false;\n          },\n\n          /**\n           * Returns whether this node has no links attached.\n           */\n          isIsolated: function () {\n            return Utils.isEmpty(this.links);\n          },\n\n          /**\n           * Gets or sets the bounding rectangle of this node.\n           * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n           */\n          bounds: function (r) {\n            if (!Utils.isDefined(r)) {\n              return new diagram.Rect(this.x, this.y, this.width, this.height);\n            }\n\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n          },\n\n          /**\n           * Returns whether there is at least one link with the given (complementary) node. This can be either an\n           * incoming or outgoing link.\n           */\n          isLinkedTo: function (node) {\n            var that = this;\n            return Utils.any(that.links, function (link) {\n              return link.getComplement(that) === node;\n            });\n          },\n\n          /**\n           * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n           * @returns {Array}\n           */\n          getChildren: function () {\n            if (this.outgoing.length === 0) {\n              return [];\n            }\n\n            var children = [];\n\n            for (var i = 0, len = this.outgoing.length; i < len; i++) {\n              var link = this.outgoing[i];\n              children.push(link.getComplement(this));\n            }\n\n            return children;\n          },\n\n          /**\n           * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n           * @returns {Array}\n           */\n          getParents: function () {\n            if (this.incoming.length === 0) {\n              return [];\n            }\n\n            var parents = [];\n\n            for (var i = 0, len = this.incoming.length; i < len; i++) {\n              var link = this.incoming[i];\n              parents.push(link.getComplement(this));\n            }\n\n            return parents;\n          },\n\n          /**\n           * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n           * @returns {Node}\n           */\n          clone: function () {\n            var copy = new Node();\n\n            if (Utils.isDefined(this.weight)) {\n              copy.weight = this.weight;\n            }\n\n            if (Utils.isDefined(this.balance)) {\n              copy.balance = this.balance;\n            }\n\n            if (Utils.isDefined(this.owner)) {\n              copy.owner = this.owner;\n            }\n\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n          },\n\n          /**\n           * Returns whether there is a link from the current node to the given node.\n           */\n          adjacentTo: function (node) {\n            return this.isLinkedTo(node) !== null;\n          },\n\n          /**\n           * Removes the given link from the link collection this node owns.\n           * @param link\n           */\n          removeLink: function (link) {\n            if (link.source === this) {\n              Utils.remove(this.links, link);\n              Utils.remove(this.outgoing, link);\n              link.source = null;\n            }\n\n            if (link.target === this) {\n              Utils.remove(this.links, link);\n              Utils.remove(this.incoming, link);\n              link.target = null;\n            }\n          },\n\n          /**\n           * Returns whether there is a (outgoing) link from the current node to the given one.\n           */\n          hasLinkTo: function (node) {\n            return Utils.any(this.outgoing, function (link) {\n              return link.target === node;\n            });\n          },\n\n          /**\n           * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n           */\n          degree: function () {\n            return this.links.length;\n          },\n\n          /**\n           * Returns whether this node is either the source or the target of the given link.\n           */\n          incidentWith: function (link) {\n            return contains(this.links, link);\n          },\n\n          /**\n           * Returns the links between this node and the given one.\n           */\n          getLinksWith: function (node) {\n            return Utils.all(this.links, function (link) {\n              return link.getComplement(this) === node;\n            }, this);\n          },\n\n          /**\n           * Returns the nodes (either parent or child) which are linked to the current one.\n           */\n          getNeighbors: function () {\n            var neighbors = [];\n            Utils.forEach(this.incoming, function (e) {\n              neighbors.push(e.getComplement(this));\n            }, this);\n            Utils.forEach(this.outgoing, function (e) {\n              neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n          }\n        });\n        /**\n         * Defines a directed link (edge, connection) of a Graph.\n         */\n\n        var Link = kendo.Class.extend({\n          init: function (source, target, id, connection) {\n            if (Utils.isUndefined(source)) {\n              throw \"The source of the new link is not set.\";\n            }\n\n            if (Utils.isUndefined(target)) {\n              throw \"The target of the new link is not set.\";\n            }\n\n            var sourceFound, targetFound;\n\n            if (Utils.isString(source)) {\n              sourceFound = new Node(source);\n            } else {\n              sourceFound = source;\n            }\n\n            if (Utils.isString(target)) {\n              targetFound = new Node(target);\n            } else {\n              targetFound = target;\n            }\n\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n\n            if (Utils.isDefined(id)) {\n              this.id = id;\n            } else {\n              this.id = randomId();\n            }\n\n            if (Utils.isDefined(connection)) {\n              this.associatedConnection = connection;\n            } else {\n              this.associatedConnection = null;\n            }\n\n            this.type = \"Link\";\n            this.shortForm = \"Link '\" + this.source.id + \"->\" + this.target.id + \"'\";\n          },\n\n          /**\n           * Returns the complementary node of the given one, if any.\n           */\n          getComplement: function (node) {\n            if (this.source !== node && this.target !== node) {\n              throw \"The given node is not incident with this link.\";\n            }\n\n            return this.source === node ? this.target : this.source;\n          },\n\n          /**\n           * Returns the overlap of the current link with the given one, if any.\n           */\n          getCommonNode: function (link) {\n            if (this.source === link.source || this.source === link.target) {\n              return this.source;\n            }\n\n            if (this.target === link.source || this.target === link.target) {\n              return this.target;\n            }\n\n            return null;\n          },\n\n          /**\n           * Returns whether the current link is bridging the given nodes.\n           */\n          isBridging: function (v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n          },\n\n          /**\n           * Returns the source and target of this link as a tuple.\n           */\n          getNodes: function () {\n            return [this.source, this.target];\n          },\n\n          /**\n           * Returns whether the given node is either the source or the target of the current link.\n           */\n          incidentWith: function (node) {\n            return this.source === node || this.target === node;\n          },\n\n          /**\n           * Returns whether the given link is a continuation of the current one. This can be both\n           * via an incoming or outgoing link.\n           */\n          adjacentTo: function (link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n          },\n\n          /**\n           * Changes the source-node of this link.\n           */\n          changeSource: function (node) {\n            Utils.remove(this.source.links, this);\n            Utils.remove(this.source.outgoing, this);\n            node.links.push(this);\n            node.outgoing.push(this);\n            this.source = node;\n          },\n\n          /**\n           * Changes the target-node of this link.\n           * @param node\n           */\n          changeTarget: function (node) {\n            Utils.remove(this.target.links, this);\n            Utils.remove(this.target.incoming, this);\n            node.links.push(this);\n            node.incoming.push(this);\n            this.target = node;\n          },\n\n          /**\n           * Changes both the source and the target nodes of this link.\n           */\n          changesNodes: function (v, w) {\n            if (this.source === v) {\n              this.changeSource(w);\n            } else if (this.target === v) {\n              this.changeTarget(w);\n            }\n          },\n\n          /**\n           * Reverses the direction of this link.\n           */\n          reverse: function () {\n            var oldSource = this.source;\n            var oldTarget = this.target;\n            this.source = oldTarget;\n            Utils.remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n            this.target = oldSource;\n            Utils.remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n          },\n\n          /**\n           * Ensures that the given target defines the endpoint of this link.\n           */\n          directTo: function (target) {\n            if (this.source !== target && this.target !== target) {\n              throw \"The given node is not incident with this link.\";\n            }\n\n            if (this.target !== target) {\n              this.reverse();\n            }\n          },\n\n          /**\n           * Returns a reversed clone of this link.\n           */\n          createReverseEdge: function () {\n            var r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n          },\n\n          /**\n           * Returns a clone of this link.\n           */\n          clone: function () {\n            var clone = new Link(this.source, this.target);\n            return clone;\n          }\n        });\n        /*--------------Graph structure---------------------------------*/\n\n        /**\n         * Defines a directed graph structure.\n         * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n         * inside the Graph.\n         */\n\n        var Graph = kendo.Class.extend({\n          init: function (idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             * @type {Array}\n             */\n\n            this.nodes = [];\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             * @type {null}\n             */\n\n            this.diagram = null;\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             * @type {null}\n             * @private\n             */\n\n            this._root = null;\n\n            if (Utils.isDefined(idOrDiagram)) {\n              if (Utils.isString(idOrDiagram)) {\n                this.id = idOrDiagram;\n              } else {\n                this.diagram = idOrDiagram;\n                this.id = idOrDiagram.id;\n              }\n            } else {\n              this.id = randomId();\n            }\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             * @type {Rect}\n             */\n\n\n            this.bounds = new Rect(); // keeps track whether the children & parents have been created\n\n            this._hasCachedRelationships = false;\n            this.type = \"Graph\";\n          },\n\n          /**\n           * Caches the relational information of parents and children in the 'parents' and 'children'\n           * properties.\n           * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n           */\n          cacheRelationships: function (forceRebuild) {\n            if (Utils.isUndefined(forceRebuild)) {\n              forceRebuild = false;\n            }\n\n            if (this._hasCachedRelationships && !forceRebuild) {\n              return;\n            }\n\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n              var node = this.nodes[i];\n              node.children = this.getChildren(node);\n              node.parents = this.getParents(node);\n            }\n\n            this._hasCachedRelationships = true;\n          },\n\n          /**\n           * Assigns tree-levels to the nodes assuming this is a tree graph.\n           * If not connected or not a tree the process will succeed but\n           * will have little meaning.\n           * @param startNode The node from where the level numbering starts, usually the root of the tree.\n           * @param visited The collection of visited nodes.\n           * @param offset The offset or starting counter of the level info.\n           */\n          assignLevels: function (startNode, offset, visited) {\n            if (!startNode) {\n              throw \"Start node not specified.\";\n            }\n\n            if (Utils.isUndefined(offset)) {\n              offset = 0;\n            } // if not done before, cache the parents and children\n\n\n            this.cacheRelationships();\n\n            if (Utils.isUndefined(visited)) {\n              visited = new Dictionary();\n              Utils.forEach(this.nodes, function (n) {\n                visited.add(n, false);\n              });\n            }\n\n            visited.set(startNode, true);\n            startNode.level = offset;\n            var children = startNode.children;\n\n            for (var i = 0, len = children.length; i < len; i++) {\n              var child = children[i];\n\n              if (!child || visited.get(child)) {\n                continue;\n              }\n\n              this.assignLevels(child, offset + 1, visited);\n            }\n          },\n\n          /**\n           * Gets or set the root of this graph.\n           * If not set explicitly the first Node with zero incoming links will be taken.\n           * @param value\n           * @returns {*}\n           */\n          root: function (value) {\n            if (Utils.isUndefined(value)) {\n              if (!this._root) {\n                // TODO: better to use the longest path for the most probable root?\n                var found = Utils.first(this.nodes, function (n) {\n                  return n.incoming.length === 0;\n                });\n\n                if (found) {\n                  return found;\n                }\n\n                return Utils.first(this.nodes);\n              } else {\n                return this._root;\n              }\n            } else {\n              this._root = value;\n            }\n          },\n\n          /**\n           * Returns the connected components of this graph.\n           * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n           * If you alter the items of the components you'll alter the original graph and vice versa.\n           * @returns {Array}\n           */\n          getConnectedComponents: function () {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            var componentId = Utils.initArray(this.nodes.length, -1);\n\n            for (var v = 0; v < this.nodes.length; v++) {\n              if (componentId[v] === -1) {\n                this._collectConnectedNodes(componentId, v);\n\n                this.componentIndex++;\n              }\n            }\n\n            var components = [],\n                i;\n\n            for (i = 0; i < this.componentIndex; ++i) {\n              components[i] = new Graph();\n            }\n\n            for (i = 0; i < componentId.length; ++i) {\n              var graph = components[componentId[i]];\n              graph.addNodeAndOutgoings(this.nodes[i]);\n            } // sorting the components in decreasing order of node count\n\n\n            components.sort(function (a, b) {\n              return b.nodes.length - a.nodes.length;\n            });\n            return components;\n          },\n          _collectConnectedNodes: function (setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n\n            var node = this.nodes[nodeIndex];\n            Utils.forEach(node.links, function (link) {\n              var next = link.getComplement(node);\n              var nextId = next.index;\n\n              if (setIds[nextId] === -1) {\n                this._collectConnectedNodes(setIds, nextId);\n              }\n            }, this);\n          },\n\n          /**\n           * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n           * @returns {Rect}\n           */\n          calcBounds: function () {\n            if (this.isEmpty()) {\n              this.bounds = new Rect();\n              return this.bounds;\n            }\n\n            var b = null;\n\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n              var node = this.nodes[i];\n\n              if (!b) {\n                b = node.bounds();\n              } else {\n                b = b.union(node.bounds());\n              }\n            }\n\n            this.bounds = b;\n            return this.bounds;\n          },\n\n          /**\n           * Creates a spanning tree for the current graph.\n           * Important: this will not return a spanning forest if the graph is disconnected.\n           * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n           * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n           * @param root The root of the spanning tree.\n           * @returns {Graph}\n           */\n          getSpanningTree: function (root) {\n            var tree = new Graph();\n            var map = new Dictionary(),\n                source,\n                target;\n            tree.root = root.clone();\n            tree.root.level = 0;\n            tree.root.id = root.id;\n            map.add(root, tree.root);\n            root.level = 0;\n            var visited = [];\n            var remaining = [];\n\n            tree._addNode(tree.root);\n\n            visited.push(root);\n            remaining.push(root);\n            var levelCount = 1;\n\n            while (remaining.length > 0) {\n              var next = remaining.pop();\n\n              for (var ni = 0; ni < next.links.length; ni++) {\n                var link = next.links[ni];\n                var cn = link.getComplement(next);\n\n                if (contains(visited, cn)) {\n                  continue;\n                }\n\n                cn.level = next.level + 1;\n\n                if (levelCount < cn.level + 1) {\n                  levelCount = cn.level + 1;\n                }\n\n                if (!contains(remaining, cn)) {\n                  remaining.push(cn);\n                }\n\n                if (!contains(visited, cn)) {\n                  visited.push(cn);\n                }\n\n                if (map.containsKey(next)) {\n                  source = map.get(next);\n                } else {\n                  source = next.clone();\n                  source.level = next.level;\n                  source.id = next.id;\n                  map.add(next, source);\n                }\n\n                if (map.containsKey(cn)) {\n                  target = map.get(cn);\n                } else {\n                  target = cn.clone();\n                  target.level = cn.level;\n                  target.id = cn.id;\n                  map.add(cn, target);\n                }\n\n                var newLink = new Link(source, target);\n                tree.addLink(newLink);\n              }\n            }\n\n            var treeLevels = [];\n\n            for (var i = 0; i < levelCount; i++) {\n              treeLevels.push([]);\n            }\n\n            Utils.forEach(tree.nodes, function (node) {\n              treeLevels[node.level].push(node);\n            });\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n          },\n\n          /**\n           * Returns a random node in this graph.\n           * @param excludedNodes The collection of nodes which should not be considered.\n           * @param incidenceLessThan The maximum degree or incidence the random node should have.\n           * @returns {*}\n           */\n          takeRandomNode: function (excludedNodes, incidenceLessThan) {\n            if (Utils.isUndefined(excludedNodes)) {\n              excludedNodes = [];\n            }\n\n            if (Utils.isUndefined(incidenceLessThan)) {\n              incidenceLessThan = 4;\n            }\n\n            if (this.nodes.length === 0) {\n              return null;\n            }\n\n            if (this.nodes.length === 1) {\n              return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n\n            var pool = $.grep(this.nodes, function (node) {\n              return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n\n            if (Utils.isEmpty(pool)) {\n              return null;\n            }\n\n            return pool[Utils.randomInteger(0, pool.length)];\n          },\n\n          /**\n           * Returns whether this is an empty graph.\n           */\n          isEmpty: function () {\n            return Utils.isEmpty(this.nodes);\n          },\n\n          /**\n           * Checks whether the endpoints of the links are all in the nodes collection.\n           */\n          isHealthy: function () {\n            return Utils.all(this.links, function (link) {\n              return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n          },\n\n          /**\n           * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n           * @returns {Array}\n           */\n          getParents: function (n) {\n            if (!this.hasNode(n)) {\n              throw \"The given node is not part of this graph.\";\n            }\n\n            return n.getParents();\n          },\n\n          /**\n           * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n           * @returns {Array}\n           */\n          getChildren: function (n) {\n            if (!this.hasNode(n)) {\n              throw \"The given node is not part of this graph.\";\n            }\n\n            return n.getChildren();\n          },\n\n          /**\n           * Adds a new link to the graph between the given nodes.\n           */\n          addLink: function (sourceOrLink, target, owner) {\n            if (Utils.isUndefined(sourceOrLink)) {\n              throw \"The source of the link is not defined.\";\n            }\n\n            if (Utils.isUndefined(target)) {\n              // can only be undefined if the first one is a Link\n              if (Utils.isDefined(sourceOrLink.type) && sourceOrLink.type === \"Link\") {\n                this.addExistingLink(sourceOrLink);\n                return;\n              } else {\n                throw \"The target of the link is not defined.\";\n              }\n            }\n\n            var foundSource = this.getNode(sourceOrLink);\n\n            if (Utils.isUndefined(foundSource)) {\n              foundSource = this.addNode(sourceOrLink);\n            }\n\n            var foundTarget = this.getNode(target);\n\n            if (Utils.isUndefined(foundTarget)) {\n              foundTarget = this.addNode(target);\n            }\n\n            var newLink = new Link(foundSource, foundTarget);\n\n            if (Utils.isDefined(owner)) {\n              newLink.owner = owner;\n            }\n            /*newLink.source.outgoing.push(newLink);\n             newLink.source.links.push(newLink);\n             newLink.target.incoming.push(newLink);\n             newLink.target.links.push(newLink);*/\n\n\n            this.links.push(newLink);\n            return newLink;\n          },\n\n          /**\n           * Removes all the links in this graph.\n           */\n          removeAllLinks: function () {\n            while (this.links.length > 0) {\n              var link = this.links[0];\n              this.removeLink(link);\n            }\n          },\n\n          /**\n           * Adds the given link to the current graph.\n           */\n          addExistingLink: function (link) {\n            if (this.hasLink(link)) {\n              return;\n            }\n\n            this.links.push(link);\n\n            if (this.hasNode(link.source.id)) {\n              // priority to the existing node with the id even if other props are different\n              var s = this.getNode(link.source.id);\n              link.changeSource(s);\n            } else {\n              this.addNode(link.source);\n            }\n\n            if (this.hasNode(link.target.id)) {\n              var t = this.getNode(link.target.id);\n              link.changeTarget(t);\n            } else {\n              this.addNode(link.target);\n            }\n            /*  if (!link.source.outgoing.contains(link)) {\n             link.source.outgoing.push(link);\n             }\n             if (!link.source.links.contains(link)) {\n             link.source.links.push(link);\n             }\n             if (!link.target.incoming.contains(link)) {\n             link.target.incoming.push(link);\n             }\n             if (!link.target.links.contains(link)) {\n             link.target.links.push(link);\n             }*/\n\n          },\n\n          /**\n           * Returns whether the given identifier or Link is part of this graph.\n           * @param linkOrId An identifier or a Link object.\n           * @returns {*}\n           */\n          hasLink: function (linkOrId) {\n            if (Utils.isString(linkOrId)) {\n              return Utils.any(this.links, function (link) {\n                return link.id === linkOrId;\n              });\n            }\n\n            if (linkOrId.type === \"Link\") {\n              return contains(this.links, linkOrId);\n            }\n\n            throw \"The given object is neither an identifier nor a Link.\";\n          },\n\n          /**\n           * Gets the node with the specified Id or null if not part of this graph.\n           */\n          getNode: function (nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n\n            if (this._nodeMap.containsKey(id)) {\n              return this._nodeMap.get(id);\n            }\n          },\n\n          /**\n           * Returns whether the given node or node Id is part of this graph.\n           */\n          hasNode: function (nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n          },\n          _addNode: function (node) {\n            this.nodes.push(node);\n\n            this._nodeMap.add(node.id, node);\n          },\n          _removeNode: function (node) {\n            Utils.remove(this.nodes, node);\n\n            this._nodeMap.remove(node.id);\n          },\n\n          /**\n           * Removes the given node from this graph.\n           * The node can be specified as an object or as an identifier (string).\n           */\n          removeNode: function (nodeOrId) {\n            var n = nodeOrId;\n\n            if (Utils.isString(nodeOrId)) {\n              n = this.getNode(nodeOrId);\n            }\n\n            if (Utils.isDefined(n)) {\n              var links = n.links;\n              n.links = [];\n\n              for (var i = 0, len = links.length; i < len; i++) {\n                var link = links[i];\n                this.removeLink(link);\n              }\n\n              this._removeNode(n);\n            } else {\n              throw \"The identifier should be a Node or the Id (string) of a node.\";\n            }\n          },\n\n          /**\n           * Returns whether the given nodes are connected with a least one link independently of the direction.\n           */\n          areConnected: function (n1, n2) {\n            return Utils.any(this.links, function (link) {\n              return link.source == n1 && link.target == n2 || link.source == n2 && link.target == n1;\n            });\n          },\n\n          /**\n           * Removes the given link from this graph.\n           */\n          removeLink: function (link) {\n            /*    if (!this.links.contains(link)) {\n             throw \"The given link is not part of the Graph.\";\n             }\n             */\n            Utils.remove(this.links, link);\n            Utils.remove(link.source.outgoing, link);\n            Utils.remove(link.source.links, link);\n            Utils.remove(link.target.incoming, link);\n            Utils.remove(link.target.links, link);\n          },\n\n          /**\n           * Adds a new node to this graph, if not already present.\n           * The node can be an existing Node or the identifier of a new node.\n           * No error is thrown if the node is already there and the existing one is returned.\n           */\n          addNode: function (nodeOrId, layoutRect, owner) {\n            var newNode = null;\n\n            if (!Utils.isDefined(nodeOrId)) {\n              throw \"No Node or identifier for a new Node is given.\";\n            }\n\n            if (Utils.isString(nodeOrId)) {\n              if (this.hasNode(nodeOrId)) {\n                return this.getNode(nodeOrId);\n              }\n\n              newNode = new Node(nodeOrId);\n            } else {\n              if (this.hasNode(nodeOrId)) {\n                return this.getNode(nodeOrId);\n              } // todo: ensure that the param is a Node?\n\n\n              newNode = nodeOrId;\n            }\n\n            if (Utils.isDefined(layoutRect)) {\n              newNode.bounds(layoutRect);\n            }\n\n            if (Utils.isDefined(owner)) {\n              newNode.owner = owner;\n            }\n\n            this._addNode(newNode);\n\n            return newNode;\n          },\n\n          /**\n           * Adds the given Node and its outgoing links.\n           */\n          addNodeAndOutgoings: function (node) {\n            if (!this.hasNode(node)) {\n              this._addNode(node);\n            }\n\n            var newLinks = node.outgoing;\n            node.outgoing = [];\n            Utils.forEach(newLinks, function (link) {\n              this.addExistingLink(link);\n            }, this);\n          },\n\n          /**\n           * Sets the 'index' property on the links and nodes of this graph.\n           */\n          setItemIndices: function () {\n            var i;\n\n            for (i = 0; i < this.nodes.length; ++i) {\n              this.nodes[i].index = i;\n            }\n\n            for (i = 0; i < this.links.length; ++i) {\n              this.links[i].index = i;\n            }\n          },\n\n          /**\n           * Returns a clone of this graph.\n           */\n          clone: function (saveMapping) {\n            var copy = new Graph();\n            var save = Utils.isDefined(saveMapping) && saveMapping === true;\n\n            if (save) {\n              copy.nodeMap = new Dictionary();\n              copy.linkMap = new Dictionary();\n            } // we need a map even if the saveMapping is not set\n\n\n            var map = new Dictionary();\n            Utils.forEach(this.nodes, function (nOriginal) {\n              var nCopy = nOriginal.clone();\n              map.set(nOriginal, nCopy);\n\n              copy._addNode(nCopy);\n\n              if (save) {\n                copy.nodeMap.set(nCopy, nOriginal);\n              }\n            });\n            Utils.forEach(this.links, function (linkOriginal) {\n              if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                var linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n\n                if (save) {\n                  copy.linkMap.set(linkCopy, linkOriginal);\n                }\n              }\n            });\n            return copy;\n          },\n\n          /**\n           * The parsing allows a quick way to create graphs.\n           *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n           *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n           */\n          linearize: function (addIds) {\n            return Graph.Utils.linearize(this, addIds);\n          },\n\n          /**\n           * Performs a depth-first traversal starting at the given node.\n           * @param startNode a node or id of a node in this graph\n           * @param action\n           */\n          depthFirstTraversal: function (startNode, action) {\n            if (Utils.isUndefined(startNode)) {\n              throw \"You need to supply a starting node.\";\n            }\n\n            if (Utils.isUndefined(action)) {\n              throw \"You need to supply an action.\";\n            }\n\n            if (!this.hasNode(startNode)) {\n              throw \"The given start-node is not part of this graph\";\n            }\n\n            var foundNode = this.getNode(startNode); // case the given one is an Id\n\n            var visited = [];\n\n            this._dftIterator(foundNode, action, visited);\n          },\n          _dftIterator: function (node, action, visited) {\n            action(node);\n            visited.push(node);\n            var children = node.getChildren();\n\n            for (var i = 0, len = children.length; i < len; i++) {\n              var child = children[i];\n\n              if (contains(visited, child)) {\n                continue;\n              }\n\n              this._dftIterator(child, action, visited);\n            }\n          },\n\n          /**\n           * Performs a breadth-first traversal starting at the given node.\n           * @param startNode a node or id of a node in this graph\n           * @param action\n           */\n          breadthFirstTraversal: function (startNode, action) {\n            if (Utils.isUndefined(startNode)) {\n              throw \"You need to supply a starting node.\";\n            }\n\n            if (Utils.isUndefined(action)) {\n              throw \"You need to supply an action.\";\n            }\n\n            if (!this.hasNode(startNode)) {\n              throw \"The given start-node is not part of this graph\";\n            }\n\n            var foundNode = this.getNode(startNode); // case the given one is an Id\n\n            var queue = new Queue();\n            var visited = [];\n            queue.enqueue(foundNode);\n\n            while (queue.length > 0) {\n              var node = queue.dequeue();\n              action(node);\n              visited.push(node);\n              var children = node.getChildren();\n\n              for (var i = 0, len = children.length; i < len; i++) {\n                var child = children[i];\n\n                if (contains(visited, child) || contains(queue, child)) {\n                  continue;\n                }\n\n                queue.enqueue(child);\n              }\n            }\n          },\n\n          /**\n           * This is the classic Tarjan algorithm for strongly connected components.\n           * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n           * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n           * @param node The start node from which the analysis starts.\n           * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n           * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n           * @param connected The current component.\n           * @param stack The bookkeeping stack of things to visit.\n           * @param index The counter of visited nodes used to assign the indices.\n           * @private\n           */\n          _stronglyConnectedComponents: function (excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n            stack.push(node);\n            var children = node.getChildren(),\n                next;\n\n            for (var i = 0, len = children.length; i < len; i++) {\n              next = children[i];\n\n              if (!indices.containsKey(next)) {\n                this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n\n                lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n              } else if (contains(stack, next)) {\n                lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n              }\n            } // If v is a root node, pop the stack and generate a strong component\n\n\n            if (lowLinks.get(node) === indices.get(node)) {\n              var component = [];\n\n              do {\n                next = stack.pop();\n                component.push(next);\n              } while (next !== node);\n\n              if (!excludeSingleItems || component.length > 1) {\n                connected.push(component);\n              }\n            }\n          },\n\n          /**\n           * Returns the cycles found in this graph.\n           * The returned arrays consist of the nodes which are strongly coupled.\n           * @param excludeSingleItems Whether isolated nodes should be excluded.\n           * @returns {Array} The array of cycles found.\n           */\n          findCycles: function (excludeSingleItems) {\n            if (Utils.isUndefined(excludeSingleItems)) {\n              excludeSingleItems = true;\n            }\n\n            var indices = new Dictionary();\n            var lowLinks = new Dictionary();\n            var connected = [];\n            var stack = [];\n\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n              var node = this.nodes[i];\n\n              if (indices.containsKey(node)) {\n                continue;\n              }\n\n              this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n\n            return connected;\n          },\n\n          /**\n           * Returns whether this graph is acyclic.\n           * @returns {*}\n           */\n          isAcyclic: function () {\n            return Utils.isEmpty(this.findCycles());\n          },\n\n          /**\n           * Returns whether the given graph is a subgraph of this one.\n           * @param other Another graph instance.\n           */\n          isSubGraph: function (other) {\n            var otherArray = other.linearize();\n            var thisArray = this.linearize();\n            return Utils.all(otherArray, function (s) {\n              return contains(thisArray, s);\n            });\n          },\n\n          /**\n           *  Makes an acyclic graph from the current (connected) one.\n           * * @returns {Array} The reversed links.\n           */\n          makeAcyclic: function () {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n              return [];\n            } // singular case of just two nodes\n\n\n            if (this.nodes.length == 2) {\n              var result = [];\n\n              if (this.links.length > 1) {\n                var oneLink = this.links[0];\n                var oneNode = oneLink.source;\n\n                for (var i = 0, len = this.links.length; i < len; i++) {\n                  var link = this.links[i];\n\n                  if (link.source == oneNode) {\n                    continue;\n                  }\n\n                  var rev = link.reverse();\n                  result.push(rev);\n                }\n              }\n\n              return result;\n            }\n\n            var copy = this.clone(true); // copy.nodeMap tells you the mapping\n\n            var N = this.nodes.length;\n            var intensityCatalog = new Dictionary();\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             * @param node\n             * @returns {number}\n             */\n\n            var flowIntensity = function (node) {\n              if (node.outgoing.length === 0) {\n                return 2 - N;\n              } else if (node.incoming.length === 0) {\n                return N - 2;\n              } else {\n                return node.outgoing.length - node.incoming.length;\n              }\n            };\n            /**\n             * Collects the nodes with the same intensity.\n             * @param node\n             * @param intensityCatalog\n             */\n\n\n            var catalogEqualIntensity = function (node, intensityCatalog) {\n              var intensity = flowIntensity(node, N);\n\n              if (!intensityCatalog.containsKey(intensity)) {\n                intensityCatalog.set(intensity, []);\n              }\n\n              intensityCatalog.get(intensity).push(node);\n            };\n\n            Utils.forEach(copy.nodes, function (v) {\n              catalogEqualIntensity(v, intensityCatalog);\n            });\n            var sourceStack = [];\n            var targetStack = [];\n\n            while (copy.nodes.length > 0) {\n              var source, target, intensity;\n\n              if (intensityCatalog.containsKey(2 - N)) {\n                var targets = intensityCatalog.get(2 - N); // nodes without outgoings\n\n                while (targets.length > 0) {\n                  target = targets.pop();\n\n                  for (var li = 0; li < target.links.length; li++) {\n                    var targetLink = target.links[li];\n                    source = targetLink.getComplement(target);\n                    intensity = flowIntensity(source, N);\n                    Utils.remove(intensityCatalog.get(intensity), source);\n                    source.removeLink(targetLink);\n                    catalogEqualIntensity(source, intensityCatalog);\n                  }\n\n                  copy._removeNode(target);\n\n                  targetStack.unshift(target);\n                }\n              } // move sources to sourceStack\n\n\n              if (intensityCatalog.containsKey(N - 2)) {\n                var sources = intensityCatalog.get(N - 2); // nodes without incomings\n\n                while (sources.length > 0) {\n                  source = sources.pop();\n\n                  for (var si = 0; si < source.links.length; si++) {\n                    var sourceLink = source.links[si];\n                    target = sourceLink.getComplement(source);\n                    intensity = flowIntensity(target, N);\n                    Utils.remove(intensityCatalog.get(intensity), target);\n                    target.removeLink(sourceLink);\n                    catalogEqualIntensity(target, intensityCatalog);\n                  }\n\n                  sourceStack.push(source);\n\n                  copy._removeNode(source);\n                }\n              }\n\n              if (copy.nodes.length > 0) {\n                for (var k = N - 3; k > 2 - N; k--) {\n                  if (intensityCatalog.containsKey(k) && intensityCatalog.get(k).length > 0) {\n                    var maxdiff = intensityCatalog.get(k);\n                    var v = maxdiff.pop();\n\n                    for (var ri = 0; ri < v.links.length; ri++) {\n                      var ril = v.links[ri];\n                      var u = ril.getComplement(v);\n                      intensity = flowIntensity(u, N);\n                      Utils.remove(intensityCatalog.get(intensity), u);\n                      u.removeLink(ril);\n                      catalogEqualIntensity(u, intensityCatalog);\n                    }\n\n                    sourceStack.push(v);\n\n                    copy._removeNode(v);\n\n                    break;\n                  }\n                }\n              }\n            }\n\n            sourceStack = sourceStack.concat(targetStack);\n            var vertexOrder = new Dictionary();\n\n            for (var kk = 0; kk < this.nodes.length; kk++) {\n              vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n\n            var reversedEdges = [];\n            Utils.forEach(this.links, function (link) {\n              if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                link.reverse();\n                reversedEdges.push(link);\n              }\n            });\n            return reversedEdges;\n          }\n        });\n        /**\n         * A collection of predefined graphs for demo and testing purposes.\n         */\n\n        Graph.Predefined = {\n          /**\n           * Eight-shapes graph all connected in a cycle.\n           * @returns {*}\n           * @constructor\n           */\n          EightGraph: function () {\n            return Graph.Utils.parse([\"1->2\", \"2->3\", \"3->4\", \"4->1\", \"3->5\", \"5->6\", \"6->7\", \"7->3\"]);\n          },\n\n          /**\n           * Creates a typical mindmap diagram.\n           * @returns {*}\n           * @constructor\n           */\n          Mindmap: function () {\n            return Graph.Utils.parse([\"0->1\", \"0->2\", \"0->3\", \"0->4\", \"0->5\", \"1->6\", \"1->7\", \"7->8\", \"2->9\", \"9->10\", \"9->11\", \"3->12\", \"12->13\", \"13->14\", \"4->15\", \"4->16\", \"15->17\", \"15->18\", \"18->19\", \"18->20\", \"14->21\", \"14->22\", \"5->23\", \"23->24\", \"23->25\", \"6->26\"]);\n          },\n\n          /**\n           * Three nodes connected in a cycle.\n           * @returns {*}\n           * @constructor\n           */\n          ThreeGraph: function () {\n            return Graph.Utils.parse([\"1->2\", \"2->3\", \"3->1\"]);\n          },\n\n          /**\n           * A tree with each node having two children.\n           * @param levels How many levels the binary tree should have.\n           * @returns {diagram.Graph}\n           * @constructor\n           */\n          BinaryTree: function (levels) {\n            if (Utils.isUndefined(levels)) {\n              levels = 5;\n            }\n\n            return Graph.Utils.createBalancedTree(levels, 2);\n          },\n\n          /**\n           * A linear graph (discrete line segment).\n           * @param length How many segments (the node count is hence (length+1)).\n           * @returns {diagram.Graph}\n           * @constructor\n           */\n          Linear: function (length) {\n            if (Utils.isUndefined(length)) {\n              length = 10;\n            }\n\n            return Graph.Utils.createBalancedTree(length, 1);\n          },\n\n          /**\n           * A standard tree-graph with the specified levels and children (siblings) count.\n           * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n           *  - NodeCount = (1-s^(N+1))/(1-s)]\n           *  - LinkCount = s.(1-s^N)/(1-s)\n           * @param levels How many levels the tree should have.\n           * @param siblingsCount How many siblings each level should have.\n           * @returns {diagram.Graph}\n           * @constructor\n           */\n          Tree: function (levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n          },\n\n          /**\n           * Creates a forest.\n           * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n           *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n           *  - LinkCount = t.s.(1-s^N)/(1-s)\n           * @param levels How many levels the tree should have.\n           * @param siblingsCount How many siblings each level should have.\n           * @param trees The amount of trees the forest should have.\n           * @returns {diagram.Graph}\n           * @constructor\n           */\n          Forest: function (levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n          },\n\n          /**\n           * A workflow-like graph with cycles.\n           * @returns {*}\n           * @constructor\n           */\n          Workflow: function () {\n            return Graph.Utils.parse([\"0->1\", \"1->2\", \"2->3\", \"1->4\", \"4->3\", \"3->5\", \"5->6\", \"6->3\", \"6->7\", \"5->4\"]);\n          },\n\n          /**\n           * A grid graph with the direction of the links avoiding cycles.\n           * Node count: (n+1).(m+1)\n           * Link count: n.(m+1) + m.(n+1)\n           * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n           * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n           * @constructor\n           */\n          Grid: function (n, m) {\n            var g = new diagram.Graph();\n\n            if (n <= 0 && m <= 0) {\n              return g;\n            }\n\n            for (var i = 0; i < n + 1; i++) {\n              var previous = null;\n\n              for (var j = 0; j < m + 1; j++) {\n                // using x-y coordinates to name the nodes\n                var node = new Node(i.toString() + \".\" + j.toString());\n                g.addNode(node);\n\n                if (previous) {\n                  g.addLink(previous, node);\n                }\n\n                if (i > 0) {\n                  var left = g.getNode((i - 1).toString() + \".\" + j.toString());\n                  g.addLink(left, node);\n                }\n\n                previous = node;\n              }\n            }\n\n            return g;\n          }\n        };\n        /**\n         * Graph generation and other utilities.\n         */\n\n        Graph.Utils = {\n          /**\n           * The parsing allows a quick way to create graphs.\n           *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n           *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n           */\n          parse: function (graphString) {\n            var previousLink,\n                graph = new diagram.Graph(),\n                parts = graphString.slice();\n\n            for (var i = 0, len = parts.length; i < len; i++) {\n              var part = parts[i];\n\n              if (Utils.isString(part)) // link spec\n                {\n                  if (part.indexOf(\"->\") < 0) {\n                    throw \"The link should be specified as 'a->b'.\";\n                  }\n\n                  var p = part.split(\"->\");\n\n                  if (p.length != 2) {\n                    throw \"The link should be specified as 'a->b'.\";\n                  }\n\n                  previousLink = new Link(p[0], p[1]);\n                  graph.addLink(previousLink);\n                }\n\n              if (Utils.isObject(part)) {\n                if (!previousLink) {\n                  throw \"Specification found before Link definition.\";\n                }\n\n                kendo.deepExtend(previousLink, part);\n              }\n            }\n\n            return graph;\n          },\n\n          /**\n           * Returns a linearized representation of the given Graph.\n           * See also the Graph.Utils.parse method for the inverse operation.\n           */\n          linearize: function (graph, addIds) {\n            if (Utils.isUndefined(graph)) {\n              throw \"Expected an instance of a Graph object in slot one.\";\n            }\n\n            if (Utils.isUndefined(addIds)) {\n              addIds = false;\n            }\n\n            var lin = [];\n\n            for (var i = 0, len = graph.links.length; i < len; i++) {\n              var link = graph.links[i];\n              lin.push(link.source.id + \"->\" + link.target.id);\n\n              if (addIds) {\n                lin.push({\n                  id: link.id\n                });\n              }\n            }\n\n            return lin;\n          },\n\n          /**\n           * The method used by the diagram creation to instantiate a shape.\n           * @param kendoDiagram The Kendo diagram where the diagram will be created.\n           * @param p The position at which to place the shape.\n           * @param shapeDefaults Optional Shape options.\n           * @param id Optional identifier of the shape.\n           * @returns {*}\n           * @private\n           */\n          _addShape: function (kendoDiagram, p, id, shapeDefaults) {\n            if (Utils.isUndefined(p)) {\n              p = new diagram.Point(0, 0);\n            }\n\n            if (Utils.isUndefined(id)) {\n              id = randomId();\n            }\n\n            shapeDefaults = kendo.deepExtend({\n              width: 20,\n              height: 20,\n              id: id,\n              radius: 10,\n              fill: \"#778899\",\n              data: \"circle\",\n              undoable: false,\n              x: p.x,\n              y: p.y\n            }, shapeDefaults);\n            return kendoDiagram.addShape(shapeDefaults);\n          },\n\n          /**\n           * The method used by the diagram creation to instantiate a connection.\n           * @param diagram he Kendo diagram where the diagram will be created.\n           * @param from The source shape.\n           * @param to The target shape.\n           * @param options Optional Connection options.\n           * @returns {*}\n           * @private\n           */\n          _addConnection: function (diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n          },\n\n          /**\n           * Creates a diagram from the given Graph.\n           * @param diagram The Kendo diagram where the diagram will be created.\n           * @param graph The graph structure defining the diagram.\n           */\n          createDiagramFromGraph: function (diagram, graph, doLayout, randomSize) {\n            if (Utils.isUndefined(diagram)) {\n              throw \"The diagram surface is undefined.\";\n            }\n\n            if (Utils.isUndefined(graph)) {\n              throw \"No graph specification defined.\";\n            }\n\n            if (Utils.isUndefined(doLayout)) {\n              doLayout = true;\n            }\n\n            if (Utils.isUndefined(randomSize)) {\n              randomSize = false;\n            }\n\n            var width = diagram.element.clientWidth || 200;\n            var height = diagram.element.clientHeight || 200;\n            var map = [],\n                node,\n                shape;\n\n            for (var i = 0, len = graph.nodes.length; i < len; i++) {\n              node = graph.nodes[i];\n              var p = node.position;\n\n              if (Utils.isUndefined(p)) {\n                if (Utils.isDefined(node.x) && Utils.isDefined(node.y)) {\n                  p = new Point(node.x, node.y);\n                } else {\n                  p = new Point(Utils.randomInteger(10, width - 20), Utils.randomInteger(10, height - 20));\n                }\n              }\n\n              var opt = {};\n\n              if (node.id === \"0\") {\n                /* kendo.deepExtend(opt,\n                 {\n                 fill: \"Orange\",\n                 data: 'circle',\n                 width: 100,\n                 height: 100,\n                 center: new Point(50, 50)\n                 });*/\n              } else if (randomSize) {\n                kendo.deepExtend(opt, {\n                  width: Math.random() * 150 + 20,\n                  height: Math.random() * 80 + 50,\n                  data: 'rectangle',\n                  fill: {\n                    color: \"#778899\"\n                  }\n                });\n              }\n\n              shape = this._addShape(diagram, p, node.id, opt); //shape.content(node.id);\n\n              var bounds = shape.bounds();\n\n              if (Utils.isDefined(bounds)) {\n                node.x = bounds.x;\n                node.y = bounds.y;\n                node.width = bounds.width;\n                node.height = bounds.height;\n              }\n\n              map[node.id] = shape;\n            }\n\n            for (var gli = 0; gli < graph.links.length; gli++) {\n              var link = graph.links[gli];\n              var sourceShape = map[link.source.id];\n\n              if (Utils.isUndefined(sourceShape)) {\n                continue;\n              }\n\n              var targetShape = map[link.target.id];\n\n              if (Utils.isUndefined(targetShape)) {\n                continue;\n              }\n\n              this._addConnection(diagram, sourceShape, targetShape, {\n                id: link.id\n              });\n            }\n\n            if (doLayout) {\n              var l = new diagram.SpringLayout(diagram);\n              l.layoutGraph(graph, {\n                limitToView: false\n              });\n\n              for (var shi = 0; shi < graph.nodes.length; shi++) {\n                node = graph.nodes[shi];\n                shape = map[node.id];\n                shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n              }\n            }\n          },\n\n          /**\n           * Creates a balanced tree with the specified number of levels and siblings count.\n           * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n           *  - NodeCount = (1-s^(N+1))/(1-s)]\n           *  - LinkCount = s.(1-s^N)/(1-s)\n           * @param levels How many levels the tree should have.\n           * @param siblingsCount How many siblings each level should have.\n           * @returns {diagram.Graph}\n           */\n          createBalancedTree: function (levels, siblingsCount) {\n            if (Utils.isUndefined(levels)) {\n              levels = 3;\n            }\n\n            if (Utils.isUndefined(siblingsCount)) {\n              siblingsCount = 3;\n            }\n\n            var g = new diagram.Graph(),\n                counter = -1,\n                lastAdded = [],\n                news;\n\n            if (levels <= 0 || siblingsCount <= 0) {\n              return g;\n            }\n\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n            g.root = root;\n            lastAdded.push(root);\n\n            for (var i = 0; i < levels; i++) {\n              news = [];\n\n              for (var j = 0; j < lastAdded.length; j++) {\n                var parent = lastAdded[j];\n\n                for (var k = 0; k < siblingsCount; k++) {\n                  var item = new Node((++counter).toString());\n                  g.addLink(parent, item);\n                  news.push(item);\n                }\n              }\n\n              lastAdded = news;\n            }\n\n            return g;\n          },\n\n          /**\n           * Creates a balanced tree with the specified number of levels and siblings count.\n           * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n           *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n           *  - LinkCount = t.s.(1-s^N)/(1-s)\n           * @param levels How many levels the tree should have.\n           * @param siblingsCount How many siblings each level should have.\n           * @returns {diagram.Graph}\n           * @param treeCount The number of trees the forest should have.\n           */\n          createBalancedForest: function (levels, siblingsCount, treeCount) {\n            if (Utils.isUndefined(levels)) {\n              levels = 3;\n            }\n\n            if (Utils.isUndefined(siblingsCount)) {\n              siblingsCount = 3;\n            }\n\n            if (Utils.isUndefined(treeCount)) {\n              treeCount = 5;\n            }\n\n            var g = new diagram.Graph(),\n                counter = -1,\n                lastAdded = [],\n                news;\n\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n              return g;\n            }\n\n            for (var t = 0; t < treeCount; t++) {\n              var root = new Node((++counter).toString());\n              g.addNode(root);\n              lastAdded = [root];\n\n              for (var i = 0; i < levels; i++) {\n                news = [];\n\n                for (var j = 0; j < lastAdded.length; j++) {\n                  var parent = lastAdded[j];\n\n                  for (var k = 0; k < siblingsCount; k++) {\n                    var item = new Node((++counter).toString());\n                    g.addLink(parent, item);\n                    news.push(item);\n                  }\n                }\n\n                lastAdded = news;\n              }\n            }\n\n            return g;\n          },\n\n          /**\n           * Creates a random graph (uniform distribution) with the specified amount of nodes.\n           * @param nodeCount The amount of nodes the random graph should have.\n           * @param maxIncidence The maximum allowed degree of the nodes.\n           * @param isTree Whether the return graph should be a tree (default: false).\n           * @returns {diagram.Graph}\n           */\n          createRandomConnectedGraph: function (nodeCount, maxIncidence, isTree) {\n            /* Swa's Mathematica export of random Bernoulli graphs\n             gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n             While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n             project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n             export[g_]:=project/@ EdgeList[g]\n             g = gr[12,.1]\n             export [g]\n             */\n            if (Utils.isUndefined(nodeCount)) {\n              nodeCount = 40;\n            }\n\n            if (Utils.isUndefined(maxIncidence)) {\n              maxIncidence = 4;\n            }\n\n            if (Utils.isUndefined(isTree)) {\n              isTree = false;\n            }\n\n            var g = new diagram.Graph(),\n                counter = -1;\n\n            if (nodeCount <= 0) {\n              return g;\n            }\n\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n\n            if (nodeCount === 1) {\n              return g;\n            }\n\n            if (nodeCount > 1) {\n              // random tree\n              for (var i = 1; i < nodeCount; i++) {\n                var poolNode = g.takeRandomNode([], maxIncidence);\n\n                if (!poolNode) {\n                  //failed to find one so the graph will have less nodes than specified\n                  break;\n                }\n\n                var newNode = g.addNode(i.toString());\n                g.addLink(poolNode, newNode);\n              }\n\n              if (!isTree && nodeCount > 1) {\n                var randomAdditions = Utils.randomInteger(1, nodeCount);\n\n                for (var ri = 0; ri < randomAdditions; ri++) {\n                  var n1 = g.takeRandomNode([], maxIncidence);\n                  var n2 = g.takeRandomNode([], maxIncidence);\n\n                  if (n1 && n2 && !g.areConnected(n1, n2)) {\n                    g.addLink(n1, n2);\n                  }\n                }\n              }\n\n              return g;\n            }\n          },\n\n          /**\n           * Generates a random diagram.\n           * @param diagram The host diagram.\n           * @param shapeCount The number of shapes the random diagram should contain.\n           * @param maxIncidence The maximum degree the shapes can have.\n           * @param isTree Whether the generated diagram should be a tree\n           * @param layoutType The optional layout type to apply after the diagram is generated.\n           */\n          randomDiagram: function (diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            var g = kendo.dataviz.diagram.Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n          }\n        };\n        kendo.deepExtend(diagram, {\n          init: function (element) {\n            kendo.init(element, diagram.ui);\n          },\n          Point: Point,\n          Intersect: Intersect,\n          Geometry: Geometry,\n          Rect: Rect,\n          Size: Size,\n          RectAlign: RectAlign,\n          Matrix: Matrix,\n          MatrixVector: MatrixVector,\n          normalVariable: normalVariable,\n          randomId: randomId,\n          Dictionary: Dictionary,\n          HashTable: HashTable,\n          Queue: Queue,\n          Set: Set,\n          Node: Node,\n          Link: Link,\n          Graph: Graph,\n          PathDefiner: PathDefiner\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  913:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./utils\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}