{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1731);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1678:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./runtime\");\n    /***/\n  },\n\n  /***/\n  1731:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1678)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\";\n\n      var $ = kendo.jQuery;\n      var spreadsheet = kendo.spreadsheet;\n      var exports = {};\n      spreadsheet.validation = exports;\n      var calc = spreadsheet.calc;\n      var Class = kendo.Class;\n      var TRANSPOSE_FORMAT = \"_matrix({0})\";\n      var DATE_FORMAT = 'DATEVALUE(\"{0}\")';\n      calc.runtime.defineFunction(\"_matrix\", function (m) {\n        if (typeof m == \"string\") {\n          // for constant list validation, Excel includes a string\n          // with comma-separated values â€” make a Matrix from it.\n          m = this.asMatrix([m.split(/\\s*,\\s*/)]);\n        }\n\n        return m;\n      }).args([[\"m\", [\"or\", \"matrix\", \"string\"]]]);\n\n      function compileValidation(sheet, row, col, validation) {\n        var validationHandler;\n        var comparer;\n        var parsedFromDate;\n        var parsedToDate;\n\n        if (typeof validation === \"string\") {\n          validation = JSON.parse(validation);\n        }\n\n        if (validation.from) {\n          if (validation.dataType === \"list\" && !validation.fromIsListValue) {\n            // We need to convert the {...} validation.from value to a string, so that it would work when exported to XLSX\n            if (validation.from.indexOf(\"{\") > -1) {\n              validation.from = validation.from.replace(/\\\"/g, \"\").replace(\"{\", \"\\\"\").replace(\"}\", \"\\\"\");\n            }\n\n            validation.from = kendo.format(TRANSPOSE_FORMAT, validation.from);\n            validation.fromIsListValue = true;\n          }\n\n          if (validation.dataType === \"date\") {\n            parsedFromDate = calc.runtime.parseDate(validation.from);\n\n            if (parsedFromDate) {\n              validation.from = kendo.format(DATE_FORMAT, validation.from);\n              validation.fromIsDateValue = true;\n            }\n          }\n\n          validation.from = calc.compile(calc.parseFormula(sheet, row, col, validation.from));\n        }\n\n        if (validation.to) {\n          if (validation.dataType === \"date\") {\n            parsedToDate = calc.runtime.parseDate(validation.to);\n\n            if (parsedToDate) {\n              validation.to = kendo.format(DATE_FORMAT, validation.to);\n              validation.toIsDateValue = true;\n            }\n          }\n\n          validation.to = calc.compile(calc.parseFormula(sheet, row, col, validation.to));\n        }\n\n        if (validation.dataType == \"custom\") {\n          comparer = exports.validationComparers.custom;\n        } else if (validation.dataType == \"list\") {\n          comparer = exports.validationComparers.list;\n        } else {\n          comparer = exports.validationComparers[validation.comparerType];\n        }\n\n        if (!comparer) {\n          throw kendo.format(\"'{0}' comparer is not implemented.\", validation.comparerType);\n        }\n\n        validationHandler = function (valueToCompare) {\n          //add 'valueFormat' arg when add isDate comparer\n          var toValue = this.to && (this.to_value || this.to_value === 0) ? this.to_value : undefined;\n\n          if (valueToCompare === null || valueToCompare === \"\") {\n            if (this.allowNulls) {\n              this.value = true;\n            } else {\n              this.value = false;\n            }\n          } else if (this.dataType == \"custom\") {\n            this.value = comparer(valueToCompare, this.from_value, toValue);\n          } else if (this.dataType == \"list\") {\n            var data = this._getListData();\n\n            this.value = comparer(valueToCompare, data, toValue);\n          } else {\n            //TODO: TYPE CHECK IS REQUIRED ONLY FOR DATE TYPE WHEN SPECIAL COMPARER (ISDATE) IS USED\n            this.value = comparer(valueToCompare, this.from_value, toValue);\n          }\n\n          return this.value;\n        };\n\n        return new kendo.spreadsheet.validation.Validation($.extend(validation, {\n          handler: validationHandler,\n          sheet: sheet,\n          row: row,\n          col: col\n        }));\n      }\n\n      var Validation = Class.extend({\n        init: function Validation(options) {\n          this.handler = options.handler;\n          this.from = options.from;\n          this.to = options.to;\n          this.dataType = options.dataType; //date, time etc\n\n          this.comparerType = options.comparerType; //greaterThan, EqaulTo etc\n\n          this.type = options.type ? options.type : \"warning\"; //info, warning, reject\n\n          this.allowNulls = options.allowNulls ? true : false;\n          this.fromIsDateValue = options.fromIsDateValue ? true : false;\n          this.toIsDateValue = options.toIsDateValue ? true : false;\n          this.showButton = options.showButton;\n          this.fromIsListValue = options.fromIsListValue ? true : false; //TODO: address to be range / cell ref, and adjust it based on it\n\n          this.sheet = options.sheet;\n          this.row = options.row;\n          this.col = options.col;\n\n          if (options.tooltipMessageTemplate) {\n            this.tooltipMessageTemplate = options.tooltipMessageTemplate;\n          }\n\n          if (options.tooltipTitleTemplate) {\n            this.tooltipTitleTemplate = options.tooltipTitleTemplate;\n          }\n\n          if (options.messageTemplate) {\n            this.messageTemplate = options.messageTemplate;\n          }\n\n          if (options.titleTemplate) {\n            this.titleTemplate = options.titleTemplate;\n          }\n        },\n        _formatMessages: function (format) {\n          var from = this.from ? this.from_value : \"\";\n          var to = this.to ? this.to_value : \"\";\n          var fromFormula = this.from ? this.from.toString() : \"\";\n          var toFormula = this.to ? this.to.toString() : \"\";\n          var dataType = this.dataType;\n          var type = this.type;\n          var comparerType = this.comparerType;\n          return kendo.format(format, from, to, fromFormula, toFormula, dataType, type, comparerType);\n        },\n        _setMessages: function () {\n          this.title = \"\";\n          this.message = \"\";\n\n          if (this.tooltipTitleTemplate) {\n            this.tooltipTitle = this._formatMessages(this.tooltipTitleTemplate);\n          }\n\n          if (this.tooltipMessageTemplate) {\n            this.tooltipMessage = this._formatMessages(this.tooltipMessageTemplate);\n          }\n\n          if (this.titleTemplate) {\n            this.title = this._formatMessages(this.titleTemplate);\n          }\n\n          if (this.messageTemplate) {\n            this.message = this._formatMessages(this.messageTemplate);\n          }\n        },\n        _getListData: function () {\n          if (!this.from_value || !this.from_value.data) {\n            return [];\n          }\n\n          var cube = this.from_value.data;\n          var i;\n          var y;\n          var data = [];\n\n          for (i = 0; i < cube.length; i++) {\n            var array = cube[i];\n\n            if (array) {\n              for (y = 0; y < array.length; y++) {\n                data.push(array[y]);\n              }\n            }\n          }\n\n          return data;\n        },\n        clone: function (sheet, row, col) {\n          var options = this._getOptions();\n\n          if (options.from) {\n            options.from = options.from.clone(sheet, row, col);\n          }\n\n          if (options.to) {\n            options.to = options.to.clone(sheet, row, col);\n          }\n\n          return new Validation($.extend(options, {\n            handler: this.handler\n          }, {\n            sheet: sheet,\n            row: row,\n            col: col\n          }));\n        },\n        deepClone: function () {\n          var v = new Validation(this);\n          v.from = v.from.deepClone();\n\n          if (v.to) {\n            v.to = v.to.deepClone();\n          }\n\n          return v;\n        },\n        exec: function (ss, compareValue, compareFormat, callback) {\n          var self = this;\n\n          function getValue(val) {\n            if (val instanceof kendo.spreadsheet.Ref) {\n              val = ss.getData(val);\n\n              if (Array.isArray(val)) {\n                val = val[0];\n              }\n            }\n\n            return val;\n          }\n\n          var calculateFromCallBack = function (val) {\n            self.from_value = getValue(val);\n            self.value = self.handler.call(self, compareValue, compareFormat);\n\n            self._setMessages();\n\n            if (callback) {\n              callback(self.value);\n            }\n          };\n\n          if (self.to) {\n            self.to.exec(ss, function (val) {\n              self.to_value = getValue(val);\n              self.from.exec(ss, calculateFromCallBack);\n            });\n          } else {\n            self.from.exec(ss, calculateFromCallBack);\n          }\n        },\n        reset: function () {\n          if (this.from) {\n            this.from.reset();\n          }\n\n          if (this.to) {\n            this.to.reset();\n          }\n\n          delete this.value;\n        },\n        adjust: function (affectedSheet, operation, start, delta) {\n          var prevFrom, prevTo, modified;\n          var formulaRow = this.row;\n          var formulaCol = this.col;\n\n          if (this.from) {\n            prevFrom = this.from.adjust(affectedSheet, operation, start, delta);\n          }\n\n          if (this.to) {\n            prevTo = this.to.adjust(affectedSheet, operation, start, delta);\n          }\n\n          if (this.sheet.toLowerCase() == affectedSheet.toLowerCase()) {\n            switch (operation) {\n              case \"row\":\n                if (formulaRow >= start) {\n                  modified = true;\n                  this.row += delta;\n                }\n\n                break;\n\n              case \"col\":\n                if (formulaCol >= start) {\n                  modified = true;\n                  this.col += delta;\n                }\n\n                break;\n            }\n          }\n\n          if (modified || prevFrom || prevTo) {\n            var v = new Validation(this);\n            v.from = prevFrom;\n            v.to = prevTo;\n            v.row = formulaRow;\n            v.col = formulaCol;\n            return v;\n          }\n        },\n        toJSON: function () {\n          var options = this._getOptions();\n\n          if (options.from) {\n            options.from = options.from.toString();\n\n            if (options.dataType === \"list\") {\n              options.from = options.from.replace(/^_matrix\\((.*)\\)$/i, \"$1\");\n              delete options.fromIsListValue;\n            }\n\n            if (options.dataType === \"date\") {\n              if (this.fromIsDateValue) {\n                options.from = options.from.replace(/^DATEVALUE\\(\"(.*)\"\\)$/i, \"$1\");\n                delete options.fromIsDateValue;\n              }\n            }\n          }\n\n          if (options.to) {\n            options.to = options.to.toString();\n\n            if (options.dataType === \"date\") {\n              if (this.toIsDateValue) {\n                options.to = options.to.replace(/^DATEVALUE\\(\"(.*)\"\\)$/i, \"$1\");\n                delete options.toIsDateValue;\n              }\n            }\n          }\n\n          return options;\n        },\n        _getOptions: function () {\n          return {\n            from: this.from,\n            to: this.to,\n            dataType: this.dataType,\n            type: this.type,\n            comparerType: this.comparerType,\n            row: this.row,\n            col: this.col,\n            sheet: this.sheet,\n            allowNulls: this.allowNulls,\n            fromIsListValue: this.fromIsListValue,\n            fromIsDateValue: this.fromIsDateValue,\n            toIsDateValue: this.toIsDateValue,\n            tooltipMessageTemplate: this.tooltipMessageTemplate,\n            tooltipTitleTemplate: this.tooltipTitleTemplate,\n            //TODO: export generated messages instead?\n            messageTemplate: this.messageTemplate,\n            titleTemplate: this.titleTemplate,\n            showButton: this.showButton\n          };\n        }\n      });\n      exports.compile = compileValidation;\n      exports.validationComparers = {\n        greaterThan: function (valueToCompare, from) {\n          return valueToCompare > from;\n        },\n        lessThan: function (valueToCompare, from) {\n          return valueToCompare < from;\n        },\n        between: function (valueToCompare, from, to) {\n          return valueToCompare >= from && valueToCompare <= to;\n        },\n        equalTo: function (valueToCompare, from) {\n          return valueToCompare == from;\n        },\n        notEqualTo: function (valueToCompare, from) {\n          return valueToCompare != from;\n        },\n        greaterThanOrEqualTo: function (valueToCompare, from) {\n          return valueToCompare >= from;\n        },\n        lessThanOrEqualTo: function (valueToCompare, from) {\n          return valueToCompare <= from;\n        },\n        notBetween: function (valueToCompare, from, to) {\n          return valueToCompare < from || valueToCompare > to;\n        },\n        custom: function (valueToCompare, from) {\n          return from;\n        },\n        list: function (valueToCompare, data) {\n          return data.indexOf(valueToCompare) > -1;\n        }\n      };\n      exports.Validation = Validation;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}