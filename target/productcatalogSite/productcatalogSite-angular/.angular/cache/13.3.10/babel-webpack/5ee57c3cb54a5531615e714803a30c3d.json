{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { ChartElement, Point, Box } from '../../core';\nimport { FADEIN, INITIAL_ANIMATION_DURATION } from '../constants';\nimport { setDefaultOptions, alignPathToPixel } from '../../common';\nconst DEFAULT_ERROR_BAR_WIDTH = 4;\n\nclass ErrorBarBase extends ChartElement {\n  constructor(low, high, isVertical, chart, series, options) {\n    super(options);\n    this.low = low;\n    this.high = high;\n    this.isVertical = isVertical;\n    this.chart = chart;\n    this.series = series;\n  }\n\n  reflow(targetBox) {\n    const endCaps = this.options.endCaps;\n    const isVertical = this.isVertical;\n    const axis = this.getAxis();\n    const valueBox = axis.getSlot(this.low, this.high);\n    const centerBox = targetBox.center();\n    const capsWidth = this.getCapsWidth(targetBox, isVertical);\n    const capValue = isVertical ? centerBox.x : centerBox.y;\n    const capStart = capValue - capsWidth;\n    const capEnd = capValue + capsWidth;\n    let linePoints;\n\n    if (isVertical) {\n      linePoints = [new Point(centerBox.x, valueBox.y1), new Point(centerBox.x, valueBox.y2)];\n\n      if (endCaps) {\n        linePoints.push(new Point(capStart, valueBox.y1), new Point(capEnd, valueBox.y1), new Point(capStart, valueBox.y2), new Point(capEnd, valueBox.y2));\n      }\n\n      this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);\n    } else {\n      linePoints = [new Point(valueBox.x1, centerBox.y), new Point(valueBox.x2, centerBox.y)];\n\n      if (endCaps) {\n        linePoints.push(new Point(valueBox.x1, capStart), new Point(valueBox.x1, capEnd), new Point(valueBox.x2, capStart), new Point(valueBox.x2, capEnd));\n      }\n\n      this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);\n    }\n\n    this.linePoints = linePoints;\n  }\n\n  getCapsWidth(box, isVertical) {\n    const boxSize = isVertical ? box.width() : box.height();\n    const capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n    return capsWidth;\n  }\n\n  createVisual() {\n    const options = this.options;\n    const visual = options.visual;\n\n    if (visual) {\n      this.visual = visual({\n        low: this.low,\n        high: this.high,\n        rect: this.box.toRect(),\n        sender: this.getSender(),\n        options: {\n          endCaps: options.endCaps,\n          color: options.color,\n          line: options.line\n        },\n        createVisual: () => {\n          this.createDefaultVisual();\n          const defaultVisual = this.visual;\n          delete this.visual;\n          return defaultVisual;\n        }\n      });\n    } else {\n      this.createDefaultVisual();\n    }\n  }\n\n  createDefaultVisual() {\n    const {\n      options,\n      linePoints\n    } = this;\n    const lineOptions = {\n      stroke: {\n        color: options.color,\n        width: options.line.width,\n        dashType: options.line.dashType\n      }\n    };\n    super.createVisual();\n\n    for (let idx = 0; idx < linePoints.length; idx += 2) {\n      const line = new draw.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n      alignPathToPixel(line);\n      this.visual.append(line);\n    }\n  }\n\n}\n\nsetDefaultOptions(ErrorBarBase, {\n  animation: {\n    type: FADEIN,\n    delay: INITIAL_ANIMATION_DURATION\n  },\n  endCaps: true,\n  line: {\n    width: 2\n  },\n  zIndex: 1\n});\nexport default ErrorBarBase;","map":null,"metadata":{},"sourceType":"module"}