{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, Directive, Optional, Component, HostBinding, Input, Output, forwardRef, isDevMode, ViewContainerRef, ChangeDetectionStrategy, ViewChild, ContentChild, Host, NgModule } from '@angular/core';\nimport { isDocumentAvailable, Keys, guid, anyChanged, hasObservers, isChanged } from '@progress/kendo-angular-common';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { Subject, of, Subscription, EMPTY, BehaviorSubject, merge } from 'rxjs';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { getter, setter } from '@progress/kendo-common';\nimport * as i8 from '@progress/kendo-angular-inputs';\nimport { InputsModule } from '@progress/kendo-angular-inputs';\nimport { trigger, transition, style, animate } from '@angular/animations';\nimport { filter, tap, switchMap, delay, takeUntil, catchError, finalize, take, map } from 'rxjs/operators';\nimport * as i9 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport Draggable from '@progress/kendo-draggable';\n/**\n * @hidden\n */\n\nconst _c0 = [\"kendoTreeViewGroup\", \"\"];\n\nfunction TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 12);\n    i0.ɵɵlistener(\"click\", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      const index_r3 = ctx_r10.index;\n      const node_r2 = ctx_r10.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.expandNode(ctx_r9.nodeIndex(index_r3), node_r2, !ctx_r9.isExpanded(node_r2, ctx_r9.nodeIndex(index_r3)));\n    });\n    i0.ɵɵelement(1, \"span\", 13);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext();\n    const index_r3 = ctx_r12.index;\n    const node_r2 = ctx_r12.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"kendoTreeViewLoading\", ctx_r4.nodeIndex(index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"k-i-collapse\", ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)))(\"k-i-expand\", !ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)));\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-checkbox\", 14);\n    i0.ɵɵlistener(\"checkStateChange\", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkStateChange_0_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const index_r3 = i0.ɵɵnextContext().index;\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.checkNode(ctx_r13.nodeIndex(index_r3));\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r16.$implicit;\n    const index_r3 = ctx_r16.index;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"size\", ctx_r5.size)(\"node\", node_r2)(\"index\", ctx_r5.nodeIndex(index_r3))(\"isChecked\", ctx_r5.isChecked)(\"tabindex\", -1);\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template(rf, ctx) {}\n\nconst _c1 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    index: a1\n  };\n};\n\nfunction TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template, 0, 0, \"ng-template\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r18.$implicit;\n    const index_r3 = ctx_r18.index;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.nodeTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c1, node_r2, ctx_r6.nodeIndex(index_r3)));\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const node_r2 = i0.ɵɵnextContext().$implicit;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.nodeText(node_r2), \" \");\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_ul_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ul\", 16);\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext();\n    const node_r2 = ctx_r20.$implicit;\n    const index_r3 = ctx_r20.index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"nodes\", ctx_r8.fetchChildren)(\"loadOnDemand\", ctx_r8.loadOnDemand)(\"checkboxes\", ctx_r8.checkboxes)(\"expandIcons\", ctx_r8.expandIcons)(\"selectable\", ctx_r8.selectable)(\"touchActions\", ctx_r8.touchActions)(\"children\", ctx_r8.children)(\"hasChildren\", ctx_r8.hasChildren)(\"isChecked\", ctx_r8.isChecked)(\"isDisabled\", ctx_r8.isDisabled)(\"disabled\", ctx_r8.disabled || ctx_r8.isDisabled(node_r2, ctx_r8.nodeIndex(index_r3)))(\"isExpanded\", ctx_r8.isExpanded)(\"isSelected\", ctx_r8.isSelected)(\"isVisible\", ctx_r8.isVisible)(\"nodeTemplateRef\", ctx_r8.nodeTemplateRef)(\"loadMoreButtonTemplateRef\", ctx_r8.loadMoreButtonTemplateRef)(\"parentIndex\", ctx_r8.nodeIndex(index_r3))(\"parentDataItem\", node_r2)(\"textField\", ctx_r8.nextFields)(\"loadMoreService\", ctx_r8.loadMoreService)(\"@toggle\", true)(\"trackBy\", ctx_r8.trackBy);\n  }\n}\n\nfunction TreeViewGroupComponent_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 2)(1, \"div\", 3);\n    i0.ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 2, 5, \"span\", 4);\n    i0.ɵɵtemplate(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 1, 5, \"kendo-checkbox\", 5);\n    i0.ɵɵelementStart(4, \"span\", 6)(5, \"span\", 7);\n    i0.ɵɵelementContainerStart(6, 8);\n    i0.ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 5, \"ng-container\", 9);\n    i0.ɵɵtemplate(8, TreeViewGroupComponent_li_0_ng_container_8_Template, 2, 1, \"ng-container\", 10);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵtemplate(9, TreeViewGroupComponent_li_0_ul_9_Template, 1, 22, \"ul\", 11);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r2 = ctx.$implicit;\n    const index_r3 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-display-none\", !ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)));\n    i0.ɵɵproperty(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"parentDataItem\", ctx_r0.parentDataItem)(\"parentIndex\", ctx_r0.parentIndex)(\"loadOnDemand\", ctx_r0.loadOnDemand)(\"checkable\", ctx_r0.checkboxes)(\"isChecked\", ctx_r0.isChecked(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isDisabled\", ctx_r0.disabled || ctx_r0.isDisabled(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isVisible\", ctx_r0.isVisible(node_r2, ctx_r0.nodeIndex(index_r3)))(\"expandable\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2))(\"isExpanded\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)))(\"selectable\", ctx_r0.selectable)(\"isSelected\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)));\n    i0.ɵɵattribute(\"aria-setsize\", ctx_r0.totalNodesCount)(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.setItemClasses(ctx_r0.data.length, index_r3));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.expandIcons && ctx_r0.hasChildren(node_r2));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.checkboxes);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"touch-action\", ctx_r0.touchActions ? \"\" : \"none\");\n    i0.ɵɵproperty(\"dataItem\", node_r2)(\"index\", ctx_r0.nodeIndex(index_r3))(\"initialSelection\", ctx_r0.isSelected(node_r2, ctx_r0.nodeIndex(index_r3)))(\"isSelected\", ctx_r0.isSelected);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r0.nodeIndex(index_r3));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r0.hasTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isExpanded(node_r2, ctx_r0.nodeIndex(index_r3)) && ctx_r0.hasChildren(node_r2));\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 22);\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_5_ng_template_0_Template(rf, ctx) {}\n\nconst _c2 = function (a0) {\n  return {\n    index: a0\n  };\n};\n\nfunction TreeViewGroupComponent_li_1_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TreeViewGroupComponent_li_1_5_ng_template_0_Template, 0, 0, \"ng-template\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.loadMoreButtonTemplateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c2, ctx_r22.loadMoreButtonIndex));\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1, \" Load more \");\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction TreeViewGroupComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 17)(1, \"div\", 18);\n    i0.ɵɵtemplate(2, TreeViewGroupComponent_li_1_span_2_Template, 1, 0, \"span\", 19);\n    i0.ɵɵelementStart(3, \"span\", 20)(4, \"span\", 7);\n    i0.ɵɵtemplate(5, TreeViewGroupComponent_li_1_5_Template, 1, 4, null, 21);\n    i0.ɵɵtemplate(6, TreeViewGroupComponent_li_1_ng_container_6_Template, 2, 0, \"ng-container\", 21);\n    i0.ɵɵelementEnd()()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"k-treeview-load-more-checkboxes-container\", ctx_r1.checkboxes);\n    i0.ɵɵproperty(\"selectable\", false)(\"checkable\", false)(\"expandable\", false)(\"index\", ctx_r1.loadMoreButtonIndex)(\"parentDataItem\", ctx_r1.parentDataItem)(\"parentIndex\", ctx_r1.parentIndex);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loadingMoreNodes);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"index\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵattribute(\"data-treeindex\", ctx_r1.loadMoreButtonIndex);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.loadMoreButtonTemplateRef);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.loadMoreButtonTemplateRef);\n  }\n}\n\nconst _c3 = [\"assetsContainer\"];\n\nfunction TreeViewComponent_span_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 6);\n  }\n}\n\nfunction TreeViewComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 3)(1, \"kendo-textbox\", 4);\n    i0.ɵɵlistener(\"valueChange\", function TreeViewComponent_span_0_Template_kendo_textbox_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.filterChange.emit($event);\n    });\n    i0.ɵɵtemplate(2, TreeViewComponent_span_0_ng_template_2_Template, 1, 0, \"ng-template\", 5);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"size\", ctx_r0.size)(\"value\", ctx_r0.filter)(\"clearButton\", true)(\"placeholder\", ctx_r0.filterInputPlaceholder);\n  }\n}\n\nfunction DragClueComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\");\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMapInterpolate1(\"k-icon \", ctx_r0.statusIconClass, \" k-drag-status\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.text);\n  }\n}\n\nfunction DragClueComponent_1_ng_template_0_Template(rf, ctx) {}\n\nconst _c4 = function (a0, a1, a2, a3) {\n  return {\n    text: a0,\n    action: a1,\n    sourceItem: a2,\n    destinationItem: a3\n  };\n};\n\nfunction DragClueComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c4, ctx_r1.text, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\n\nfunction DropHintComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelement(1, \"div\", 3)(2, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) {}\n\nfunction DropHintComponent_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nconst _c5 = function (a0, a1, a2) {\n  return {\n    action: a0,\n    sourceItem: a1,\n    destinationItem: a2\n  };\n};\n\nfunction DropHintComponent_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, \"ng-template\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(2, _c5, ctx_r1.action, ctx_r1.sourceItem, ctx_r1.destinationItem));\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-treeview',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654846348,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nclass DataChangeNotificationService {\n  constructor() {\n    this.changes = new EventEmitter();\n  }\n\n  notify() {\n    this.changes.emit();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst hasChildren = () => false;\n/**\n * @hidden\n */\n\n\nconst isChecked = () => 'none';\n/**\n * @hidden\n */\n\n\nconst isDisabled = () => false;\n/**\n * @hidden\n */\n\n\nconst isExpanded = () => true;\n/**\n * @hidden\n */\n\n\nconst isSelected = () => false;\n/**\n * @hidden\n */\n\n\nconst isVisible = () => true;\n/**\n * @hidden\n */\n\n\nconst trackBy = (_, item) => item;\n/**\n * @hidden\n */\n\n\nlet ExpandStateService = /*#__PURE__*/(() => {\n  class ExpandStateService {\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    expand(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: true\n      });\n    }\n\n    collapse(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index,\n        expand: false\n      });\n    }\n\n  }\n\n  ExpandStateService.ɵfac = function ExpandStateService_Factory(t) {\n    return new (t || ExpandStateService)();\n  };\n\n  ExpandStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExpandStateService,\n    factory: ExpandStateService.ɵfac\n  });\n  return ExpandStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IndexBuilderService = /*#__PURE__*/(() => {\n  class IndexBuilderService {\n    constructor() {\n      this.INDEX_SEPARATOR = '_';\n    }\n\n    nodeIndex(index = '', parentIndex = '') {\n      return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ''}${index}`;\n    }\n\n    indexForLevel(index, level) {\n      return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);\n    }\n\n    lastLevelIndex(index = '') {\n      const parts = index.split(this.INDEX_SEPARATOR);\n\n      if (!parts.length) {\n        return NaN;\n      }\n\n      return parseInt(parts[parts.length - 1], 10);\n    }\n\n    level(index) {\n      return index.split(this.INDEX_SEPARATOR).length;\n    }\n\n  }\n\n  IndexBuilderService.ɵfac = function IndexBuilderService_Factory(t) {\n    return new (t || IndexBuilderService)();\n  };\n\n  IndexBuilderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IndexBuilderService,\n    factory: IndexBuilderService.ɵfac\n  });\n  return IndexBuilderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LoadingNotificationService = /*#__PURE__*/(() => {\n  class LoadingNotificationService {\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    notifyLoaded(index) {\n      this.changes.next(index);\n    }\n\n  }\n\n  LoadingNotificationService.ɵfac = function LoadingNotificationService_Factory(t) {\n    return new (t || LoadingNotificationService)();\n  };\n\n  LoadingNotificationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoadingNotificationService,\n    factory: LoadingNotificationService.ɵfac\n  });\n  return LoadingNotificationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n/**\n * @hidden\n */\n\nconst match = (element, selector) => {\n  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;\n\n  if (!matcher) {\n    return false;\n  }\n\n  return matcher.call(element, selector);\n};\n/**\n * @hidden\n */\n\n\nconst closestWithMatch = (element, selector) => {\n  if (!document.documentElement.contains(element)) {\n    return null;\n  }\n\n  let parent = element;\n\n  while (parent !== null && parent.nodeType === 1) {\n    if (match(parent, selector)) {\n      return parent;\n    }\n\n    parent = parent.parentElement || parent.parentNode;\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nconst noop = () => {};\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst isBlank = value => value === null || value === undefined;\n/**\n * @hidden\n */\n\n\nconst isArray = value => Array.isArray(value);\n/**\n * @hidden\n */\n\n\nconst isNullOrEmptyString = value => isBlank(value) || value.trim().length === 0;\n/**\n * @hidden\n */\n\n\nconst isBoolean = value => typeof value === 'boolean';\n/**\n * @hidden\n */\n\n\nconst closestNode = element => {\n  const selector = 'li.k-treeview-item';\n\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  if (element.closest) {\n    return element.closest(selector);\n  } else {\n    return closestWithMatch(element, selector);\n  }\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = element => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    const skipTab = tabIndex === '-1';\n    let focusable = tabIndex !== null && !skipTab;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled && !skipTab;\n    }\n\n    return focusable;\n  }\n\n  return false;\n};\n/**\n * @hidden\n */\n\n\nconst isContent = element => {\n  const scopeSelector = '.k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';\n\n  if (!isDocumentAvailable()) {\n    return null;\n  }\n\n  let node = element;\n\n  while (node && !match(node, scopeSelector)) {\n    node = node.parentNode;\n  }\n\n  if (node) {\n    return match(node, '.k-treeview-leaf:not(.k-treeview-load-more-button)');\n  }\n};\n/**\n * @hidden\n *\n * Returns the nested .k-treeview-leaf:not(.k-treeview-load-more-button) element.\n * If the passed parent item is itself a content node, it is returned.\n */\n\n\nconst getContentElement = parent => {\n  if (!isPresent(parent)) {\n    return null;\n  }\n\n  const selector = '.k-treeview-leaf:not(.k-treeview-load-more-button)';\n\n  if (match(parent, selector)) {\n    return parent;\n  }\n\n  return parent.querySelector(selector);\n};\n/**\n * @hidden\n */\n\n\nconst isLoadMoreButton = element => {\n  return isPresent(closestWithMatch(element, '.k-treeview-leaf.k-treeview-load-more-button'));\n};\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst hasParent = (element, container) => {\n  return Boolean(closest(element, node => node === container));\n};\n/**\n * @hidden\n */\n\n\nconst focusableNode = element => element.nativeElement.querySelector('li[tabindex=\"0\"]');\n/**\n * @hidden\n */\n\n\nconst hasActiveNode = (target, node) => {\n  const closestItem = node || closestNode(target);\n  return closestItem && (closestItem === target || target.tabIndex < 0);\n};\n/**\n * @hidden\n */\n\n\nconst nodeId = node => node ? node.getAttribute('data-treeindex') : '';\n/**\n * @hidden\n */\n\n\nconst nodeIndex = item => (item || {}).index;\n/**\n * @hidden\n */\n\n\nconst dataItemsEqual = (first, second) => {\n  if (!isPresent(first) && !isPresent(second)) {\n    return true;\n  }\n\n  return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;\n};\n/**\n * @hidden\n */\n\n\nconst getDataItem = lookup => {\n  if (!isPresent(lookup)) {\n    return lookup;\n  }\n\n  return lookup.item.dataItem;\n};\n/**\n * @hidden\n */\n\n\nconst isArrayWithAtLeastOneItem = v => v && Array.isArray(v) && v.length !== 0;\n/**\n * @hidden\n * A recursive tree-filtering algorithm that returns:\n * - all child nodes of matching nodes\n * - a chain parent nodes from the match to the root node\n */\n\n\nconst filterTree = (items, term, {\n  operator,\n  ignoreCase,\n  mode\n}, textField, depth = 0) => {\n  const field = typeof textField === \"string\" ? textField : textField[depth];\n  items.forEach(wrapper => {\n    const matcher = typeof operator === \"string\" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;\n    const isMatch = matcher(wrapper.dataItem, term);\n    wrapper.isMatch = isMatch;\n    wrapper.visible = isMatch;\n    wrapper.containsMatches = false;\n\n    if (isMatch) {\n      setParentChain(wrapper.parent);\n    }\n\n    if (wrapper.children && wrapper.children.length > 0) {\n      if (mode === \"strict\" || !isMatch) {\n        filterTree(wrapper.children, term, {\n          operator,\n          ignoreCase,\n          mode\n        }, textField, depth + 1);\n      } else {\n        makeAllVisible(wrapper.children);\n      }\n    }\n  });\n};\n\nconst setParentChain = node => {\n  if (!isPresent(node)) {\n    return;\n  }\n\n  node.containsMatches = true;\n  node.visible = true;\n\n  if (isPresent(node.parent) && !node.parent.containsMatches) {\n    setParentChain(node.parent);\n  }\n};\n\nconst makeAllVisible = nodes => {\n  nodes.forEach(node => {\n    node.visible = true;\n\n    if (node.children) {\n      makeAllVisible(node.children);\n    }\n  });\n};\n\nconst operators = {\n  contains: (a, b) => a.indexOf(b) >= 0,\n  doesnotcontain: (a, b) => a.indexOf(b) === -1,\n  startswith: (a, b) => a.lastIndexOf(b, 0) === 0,\n  doesnotstartwith: (a, b) => a.lastIndexOf(b, 0) === -1,\n  endswith: (a, b) => a.indexOf(b, a.length - b.length) >= 0,\n  doesnotendwith: (a, b) => a.indexOf(b, a.length - b.length) < 0\n};\n\nconst matchByCase = (matcher, ignoreCase) => (a, b) => {\n  if (ignoreCase) {\n    return matcher(a.toLowerCase(), b.toLowerCase());\n  }\n\n  return matcher(a, b);\n};\n\nconst matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);\n/**\n * @hidden\n */\n\n\nconst buildTreeIndex = (parentIndex, itemIndex) => {\n  return [parentIndex, itemIndex].filter(part => isPresent(part)).join('_');\n};\n/**\n * @hidden\n */\n\n\nconst buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {\n  if (!isPresent(dataItem)) {\n    return null;\n  }\n\n  return {\n    dataItem,\n    index: buildTreeIndex(parentIndex, currentLevelIndex)\n  };\n};\n/**\n * @hidden\n *\n * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.\n */\n\n\nconst fetchLoadedDescendants = (lookup, filterExpression) => {\n  if (!isPresent(lookup) || lookup.children.length === 0) {\n    return [];\n  }\n\n  let descendants = lookup.children;\n\n  if (isPresent(filterExpression)) {\n    descendants = descendants.filter(filterExpression);\n  }\n\n  descendants.forEach(child => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));\n  return descendants;\n};\n/**\n * @hidden\n *\n * Compares two Seets to determine whether all unique elements in one, are present in the other.\n * Important:\n *  - it disregards the element order\n */\n\n\nconst sameValues = (as, bs) => {\n  if (as.size !== bs.size) {\n    return false;\n  }\n\n  return Array.from(as).every(v => bs.has(v));\n};\n/**\n * @hidden\n * Returns the size class based on the component and size input.\n */\n\n\nconst getSizeClass = (component, size) => {\n  const SIZE_CLASSES = {\n    'small': `k-${component}-sm`,\n    'medium': `k-${component}-md`,\n    'large': `k-${component}-lg`\n  };\n  return SIZE_CLASSES[size];\n};\n\nconst safe = node => node || {};\n\nconst safeChildren = node => safe(node).children || [];\n\nconst lastVisibleNode = nodes => {\n  if (!Array.isArray(nodes) || nodes.length === 0) {\n    return null;\n  }\n\n  const nodesCount = nodes.length;\n  const lastIndex = nodesCount - 1;\n\n  for (let index = lastIndex; index >= 0; index -= 1) {\n    const node = nodes[index];\n\n    if (node.visible) {\n      return node;\n    }\n  }\n\n  return null;\n};\n/**\n * @hidden\n */\n\n\nclass NavigationModel {\n  constructor() {\n    this.ib = new IndexBuilderService();\n    this.nodes = [];\n  }\n\n  firstVisibleNode() {\n    return (this.nodes || []).find(node => node.visible);\n  }\n\n  lastVisibleNode() {\n    let node = lastVisibleNode(this.nodes);\n\n    while (isPresent(node) && safeChildren(node).length > 0) {\n      const children = safeChildren(node);\n      const lastVisibleChild = lastVisibleNode(children);\n\n      if (!isPresent(lastVisibleChild)) {\n        return node;\n      }\n\n      node = lastVisibleChild;\n    }\n\n    return node;\n  }\n\n  closestNode(index) {\n    const {\n      prev\n    } = safe(this.findNode(index));\n    const sibling = prev || this.firstVisibleNode();\n    return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;\n  }\n\n  firstFocusableNode() {\n    return this.nodes.find(node => {\n      return !node.disabled && node.visible;\n    });\n  }\n\n  findNode(index) {\n    return this.find(index, this.nodes);\n  }\n\n  findParent(index) {\n    const parentLevel = this.ib.level(index) - 1;\n    return this.findNode(this.ib.indexForLevel(index, parentLevel));\n  }\n\n  findVisibleChild(index) {\n    const node = this.findNode(index);\n    const children = safeChildren(node);\n    return children.find(child => child.visible);\n  }\n\n  findVisiblePrev(item) {\n    const index = item.index;\n    const parent = this.findParent(index);\n    const levelIndex = this.ib.lastLevelIndex(index);\n    const prevNodes = this.container(parent).slice(0, levelIndex);\n    const prevNodesHidden = prevNodes.every(node => !node.visible);\n\n    if (levelIndex === 0 || prevNodesHidden) {\n      return parent;\n    }\n\n    const currentNode = this.findNode(index);\n    let prev = this.visibleSibling(currentNode, -1);\n\n    if (prev) {\n      let children = this.container(prev);\n\n      while (children.length > 0 && children.some(node => node.visible)) {\n        prev = lastVisibleNode(children);\n        children = this.container(prev);\n      }\n    }\n\n    return prev;\n  }\n\n  findVisibleNext(item) {\n    const children = this.container(item);\n    const hasVisibleChildren = children.some(child => child.visible);\n\n    if (children.length === 0 || !hasVisibleChildren) {\n      return this.visibleSibling(item, 1);\n    }\n\n    return children.find(child => child.visible);\n  }\n\n  registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n    const children = [];\n    const level = this.ib.level(index);\n    const parent = this.findParent(index);\n\n    if (parent || level === 1) {\n      const node = {\n        id,\n        children,\n        index,\n        parent,\n        disabled,\n        loadMoreButton,\n        visible\n      };\n      this.insert(node, parent);\n    }\n  }\n\n  unregisterItem(id, index) {\n    const node = this.find(index, this.nodes);\n\n    if (!node || node.id !== id) {\n      return;\n    }\n\n    const children = this.container(node.parent);\n    children.splice(children.indexOf(node), 1);\n  }\n\n  childLevel(nodes) {\n    const children = nodes.filter(node => isPresent(node));\n\n    if (!children || !children.length) {\n      return 1;\n    }\n\n    return this.ib.level(children[0].index);\n  }\n\n  container(node) {\n    return node ? node.children : this.nodes;\n  }\n\n  find(index, nodes) {\n    const childLevel = this.childLevel(nodes);\n    const indexToMatch = this.ib.indexForLevel(index, childLevel);\n    const isLeaf = childLevel === this.ib.level(index);\n    const node = nodes.find(n => n && n.index === indexToMatch);\n\n    if (!node) {\n      return null;\n    }\n\n    return isLeaf ? node : this.find(index, node.children);\n  }\n\n  insert(node, parent) {\n    const nodes = this.container(parent);\n    nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);\n  }\n\n  visibleSibling(node, offset) {\n    if (!node) {\n      return null;\n    }\n\n    const parent = this.findParent(node.index);\n    const container = this.container(parent);\n    let nextItemIndex = container.indexOf(node) + offset;\n    let nextItem = container[nextItemIndex];\n\n    while (isPresent(nextItem)) {\n      if (nextItem.visible) {\n        return nextItem;\n      }\n\n      nextItemIndex += offset;\n      nextItem = container[nextItemIndex];\n    }\n\n    return this.visibleSibling(parent, offset);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(localization) {\n      this.localization = localization;\n      this.expands = new Subject();\n      this.moves = new Subject();\n      this.checks = new Subject();\n      this.selects = new Subject();\n      this.loadMore = new Subject();\n      this.navigable = true;\n      this.actions = {\n        [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem), true),\n        [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem), true),\n        [Keys.ArrowLeft]: () => !this.isLoadMoreButton && this.expand({\n          expand: this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent\n        }),\n        [Keys.ArrowRight]: () => !this.isLoadMoreButton && this.expand({\n          expand: !this.localization.rtl,\n          intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild\n        }),\n        [Keys.Home]: () => this.activate(this.model.firstVisibleNode(), true),\n        [Keys.End]: () => this.activate(this.model.lastVisibleNode(), true),\n        [Keys.Enter]: () => this.handleEnter(),\n        [Keys.Space]: () => this.handleSpace()\n      };\n      this.isFocused = false;\n      this.shouldScroll = false;\n      this._model = new NavigationModel();\n      this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);\n      this.moveToParent = this.moveToParent.bind(this);\n    }\n\n    get model() {\n      return this._model;\n    }\n\n    set model(model) {\n      this._model = model;\n    }\n\n    get activeIndex() {\n      return nodeIndex(this.activeItem) || null;\n    }\n\n    get isActiveExpanded() {\n      return this.activeItem && this.activeItem.children.length > 0;\n    }\n\n    get isLoadMoreButton() {\n      return this.activeItem && this.activeItem.loadMoreButton;\n    }\n\n    get focusableItem() {\n      return this.activeItem || this.model.firstFocusableNode();\n    }\n\n    activate(item, shouldScroll = false) {\n      if (!this.navigable || !item || this.isActive(nodeIndex(item))) {\n        return;\n      }\n\n      this.isFocused = true;\n      this.activeItem = item || this.activeItem;\n      this.shouldScroll = shouldScroll;\n      this.notifyMove();\n    }\n\n    activateParent(index) {\n      this.activate(this.model.findParent(index));\n    }\n\n    activateIndex(index) {\n      if (!index) {\n        return;\n      }\n\n      this.activate(this.model.findNode(index));\n    }\n\n    activateClosest(index) {\n      if (!index || nodeIndex(this.focusableItem) !== index) {\n        return;\n      }\n\n      this.activeItem = this.model.closestNode(index);\n      this.notifyMove();\n    }\n\n    activateFocusable() {\n      if (this.activeItem) {\n        return;\n      }\n\n      this.activeItem = this.model.firstVisibleNode();\n      this.notifyMove();\n    }\n\n    deactivate() {\n      if (!this.navigable || !this.isFocused) {\n        return;\n      }\n\n      this.isFocused = false;\n      this.notifyMove();\n    }\n\n    checkIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.checks.next(index);\n      }\n    }\n\n    selectIndex(index) {\n      if (!this.isDisabled(index)) {\n        this.selects.next(index);\n      }\n    }\n\n    notifyLoadMore(index) {\n      if (!isPresent(index)) {\n        return;\n      }\n\n      this.loadMore.next(index);\n    }\n\n    isActive(index) {\n      if (!index) {\n        return false;\n      }\n\n      return this.isFocused && this.activeIndex === index;\n    }\n\n    isFocusable(index) {\n      return nodeIndex(this.focusableItem) === index;\n    }\n\n    isDisabled(index) {\n      return this.model.findNode(index).disabled;\n    }\n\n    registerItem(id, index, disabled, loadMoreButton = false, visible = true) {\n      const itemAtIndex = this.model.findNode(index);\n\n      if (isPresent(itemAtIndex)) {\n        this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);\n\n        if (this.isActive(index)) {\n          this.deactivate();\n        }\n      }\n\n      this.model.registerItem(id, index, disabled, loadMoreButton, visible);\n    }\n\n    unregisterItem(id, index) {\n      if (this.isActive(index)) {\n        this.activateParent(index);\n      }\n\n      this.model.unregisterItem(id, index);\n    }\n\n    move(e) {\n      if (!this.navigable) {\n        return;\n      }\n\n      const moveAction = this.actions[e.keyCode];\n\n      if (!moveAction) {\n        return;\n      }\n\n      moveAction();\n      e.preventDefault();\n    }\n\n    expand({\n      expand,\n      intercept\n    }) {\n      const index = nodeIndex(this.activeItem);\n\n      if (!index || intercept(index)) {\n        return;\n      }\n\n      this.notifyExpand(expand);\n    }\n\n    moveToParent() {\n      if (this.isActiveExpanded) {\n        return false;\n      }\n\n      this.activate(this.model.findParent(nodeIndex(this.activeItem)));\n      return true;\n    }\n\n    moveToFirstVisibleChild() {\n      if (!this.isActiveExpanded) {\n        return false;\n      }\n\n      this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));\n      return true;\n    }\n\n    notifyExpand(expand) {\n      this.expands.next(this.navigationState(expand));\n    }\n\n    notifyMove() {\n      this.moves.next(this.navigationState());\n    }\n\n    navigationState(expand = false) {\n      return {\n        expand,\n        index: this.activeIndex,\n        isFocused: this.isFocused,\n        shouldScroll: this.shouldScroll\n      };\n    }\n\n    handleEnter() {\n      if (!this.navigable) {\n        return;\n      }\n\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        this.selectIndex(this.activeIndex);\n      }\n    }\n\n    handleSpace() {\n      if (!this.navigable) {\n        return;\n      }\n\n      if (this.isLoadMoreButton) {\n        this.notifyLoadMore(this.activeIndex);\n      } else {\n        this.checkIndex(this.activeIndex);\n      }\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(i1.LocalizationService));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet NodeChildrenService = /*#__PURE__*/(() => {\n  class NodeChildrenService {\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    childrenLoaded(item, children) {\n      this.changes.next({\n        item,\n        children\n      });\n    }\n\n  }\n\n  NodeChildrenService.ɵfac = function NodeChildrenService_Factory(t) {\n    return new (t || NodeChildrenService)();\n  };\n\n  NodeChildrenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NodeChildrenService,\n    factory: NodeChildrenService.ɵfac\n  });\n  return NodeChildrenService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).\n * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`\n * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.\n *\n *\n * The node data item and its hierarchical index are available as context variables:\n *\n * - `let-dataItem` (`any`) - available as implicit context variable\n * - `let-index=\"index\"` (`string`)\n *\n *\n * @example\n * ```ts\n *\n *  import { Component } from '@angular/core';\n *  @Component({\n *      selector: 'my-app',\n *      template: `\n *      <kendo-treeview\n *          [nodes]=\"data\"\n *          kendoTreeViewExpandable\n *\n *          kendoTreeViewHierarchyBinding\n *          childrenField=\"items\">\n *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index=\"index\">\n *          <span [style.fontWeight]=\"dataItem.items ? 'bolder': 'normal' \">{{ index }}: {{ dataItem.text }}</span>\n *        </ng-template>\n *      </kendo-treeview>\n *    `\n *  })\n *  export class AppComponent {\n *      public data: any[] = [\n *          {\n *              text: \"Inbox\",\n *              items: [{ text: \"Read Mail\" }]\n *          },\n *          {\n *              text: \"Drafts\"\n *          },\n *          {\n *              text: \"Search Folders\",\n *              items: [\n *                  { text: \"Categorized Mail\" },\n *                  { text: \"Large Mail\" },\n *                  { text: \"Unread Mail\"}\n *              ]\n *          },\n *          { text: \"Settings\" }\n *      ];\n *  }\n *\n * ```\n */\n\n\nlet NodeTemplateDirective = /*#__PURE__*/(() => {\n  class NodeTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  NodeTemplateDirective.ɵfac = function NodeTemplateDirective_Factory(t) {\n    return new (t || NodeTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  NodeTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NodeTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewNodeTemplate\", \"\"]]\n  });\n  return NodeTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template for the TreeView load more buttons.\n * To define a button template, nest an `<ng-template>`\n * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).\n *\n * The hierarchical index of the load more button node is available as a context variable:\n *\n * - `let-index=\"index\"` (`string`)\n */\n\n\nlet LoadMoreButtonTemplateDirective = /*#__PURE__*/(() => {\n  class LoadMoreButtonTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  LoadMoreButtonTemplateDirective.ɵfac = function LoadMoreButtonTemplateDirective_Factory(t) {\n    return new (t || LoadMoreButtonTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  LoadMoreButtonTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LoadMoreButtonTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewLoadMoreButtonTemplate\", \"\"]]\n  });\n  return LoadMoreButtonTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * An injection token used by the data binding directives to interface with\n * the TreeView or the DropDownTree components.\n */\n\n\nlet DataBoundComponent = /*#__PURE__*/(() => {\n  class DataBoundComponent {}\n\n  DataBoundComponent.ɵfac = function DataBoundComponent_Factory(t) {\n    return new (t || DataBoundComponent)();\n  };\n\n  DataBoundComponent.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DataBoundComponent,\n    factory: DataBoundComponent.ɵfac\n  });\n  return DataBoundComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * An injection token used by the expand-directive to interface with\n * the TreeView or the DropDownTree components.\n */\n\n\nlet ExpandableComponent = /*#__PURE__*/(() => {\n  class ExpandableComponent {}\n\n  ExpandableComponent.ɵfac = function ExpandableComponent_Factory(t) {\n    return new (t || ExpandableComponent)();\n  };\n\n  ExpandableComponent.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExpandableComponent,\n    factory: ExpandableComponent.ɵfac\n  });\n  return ExpandableComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet SelectionService = /*#__PURE__*/(() => {\n  class SelectionService {\n    constructor() {\n      this.changes = new Subject();\n    }\n\n    isFirstSelected(index) {\n      return this.firstIndex === index;\n    }\n\n    setFirstSelected(index, selected) {\n      if (this.firstIndex === index && selected === false) {\n        this.firstIndex = null;\n      } else if (!this.firstIndex && selected) {\n        this.firstIndex = index;\n      }\n    }\n\n    select(index, dataItem) {\n      this.changes.next({\n        dataItem,\n        index\n      });\n    }\n\n  }\n\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)();\n  };\n\n  SelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: SelectionService.ɵfac\n  });\n  return SelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INDEX_REGEX = /\\d+$/;\n/**\n * @hidden\n */\n\nlet TreeViewLookupService = /*#__PURE__*/(() => {\n  class TreeViewLookupService {\n    constructor() {\n      this.map = new Map();\n    }\n\n    reset() {\n      this.map.clear();\n    }\n\n    registerItem(item, parent) {\n      const currentLookup = {\n        children: [],\n        item,\n        parent: this.item(nodeIndex(parent))\n      };\n      this.map.set(item.index, currentLookup);\n    }\n\n    registerChildren(index, children) {\n      const item = this.item(index);\n\n      if (!item) {\n        return;\n      }\n\n      item.children = children;\n    }\n\n    unregisterItem(index, dataItem) {\n      const current = this.item(index);\n\n      if (current && current.item.dataItem === dataItem) {\n        this.map.delete(index);\n\n        if (current.parent && current.parent.children) {\n          current.parent.children = current.parent.children.filter(item => item.dataItem !== dataItem);\n        }\n      }\n    }\n\n    replaceItem(index, item, parent) {\n      if (!item) {\n        return;\n      }\n\n      this.unregisterItem(index, item.dataItem);\n      this.registerItem(item, parent);\n      this.addToParent(item, parent);\n    }\n\n    itemLookup(index) {\n      const item = this.item(index);\n\n      if (!item) {\n        return null;\n      }\n\n      return {\n        children: this.mapChildren(item.children),\n        item: item.item,\n        parent: item.parent\n      };\n    }\n\n    hasItem(index) {\n      return this.map.has(index);\n    }\n\n    item(index) {\n      return this.map.get(index) || null;\n    }\n\n    addToParent(item, parent) {\n      if (parent) {\n        const parentItem = this.item(parent.index);\n        const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);\n        parentItem.children = parentItem.children || [];\n        parentItem.children.splice(index, 0, item);\n      }\n    }\n\n    mapChildren(children = []) {\n      return children.map(c => {\n        const {\n          item,\n          parent,\n          children\n        } = this.item(c.index);\n        return {\n          children: this.mapChildren(children),\n          item,\n          parent\n        };\n      });\n    }\n\n  }\n\n  TreeViewLookupService.ɵfac = function TreeViewLookupService_Factory(t) {\n    return new (t || TreeViewLookupService)();\n  };\n\n  TreeViewLookupService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TreeViewLookupService,\n    factory: TreeViewLookupService.ɵfac\n  });\n  return TreeViewLookupService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * Represents the CheckBox component of the Kendo UI TreeView for Angular.\n *\n */\n\n\nlet CheckBoxComponent = /*#__PURE__*/(() => {\n  class CheckBoxComponent {\n    constructor(element, renderer, changeDetector) {\n      this.element = element;\n      this.renderer = renderer;\n      this.changeDetector = changeDetector;\n      /**\n       * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.\n       */\n\n      this.id = `_${guid()}`;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Specifies the size of the component.\n       */\n\n      this.size = 'medium';\n      /**\n       * Fires when the user changes the check state of the component.\n       */\n\n      this.checkStateChange = new EventEmitter();\n      this.checkState = 'none';\n    } //XXX: implement ComponentValueAccessor\n    //XXX: focus/blur methods\n\n\n    get classWrapper() {\n      return true;\n    }\n\n    get indeterminate() {\n      return this.checkState === 'indeterminate';\n    }\n\n    get checked() {\n      return this.checkState === 'checked';\n    }\n\n    get checkBoxClasses() {\n      return `k-checkbox ${this.size ? getSizeClass('checkbox', this.size) : ''} k-rounded-md`;\n    }\n\n    ngOnInit() {\n      this.renderer.removeAttribute(this.element.nativeElement, \"tabindex\");\n    }\n\n    ngDoCheck() {\n      this.checkState = this.isChecked(this.node, this.index);\n    }\n\n    handleChange(e) {\n      const state = e.target.checked ? 'checked' : 'none'; // update the View State so that Angular updates the input if the isChecked value is the same\n\n      this.checkState = state;\n      this.changeDetector.detectChanges();\n      this.checkStateChange.emit(state);\n    }\n\n  }\n\n  CheckBoxComponent.ɵfac = function CheckBoxComponent_Factory(t) {\n    return new (t || CheckBoxComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  CheckBoxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CheckBoxComponent,\n    selectors: [[\"kendo-checkbox\"]],\n    hostVars: 2,\n    hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-checkbox-wrapper\", ctx.classWrapper);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      isChecked: \"isChecked\",\n      node: \"node\",\n      index: \"index\",\n      labelText: \"labelText\",\n      tabindex: \"tabindex\",\n      size: \"size\"\n    },\n    outputs: {\n      checkStateChange: \"checkStateChange\"\n    },\n    decls: 3,\n    vars: 8,\n    consts: [[\"type\", \"checkbox\", 3, \"id\", \"checked\", \"indeterminate\", \"tabindex\", \"change\"], [\"tabindex\", \"-1\", 1, \"k-checkbox-label\", 3, \"for\"]],\n    template: function CheckBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"input\", 0);\n        i0.ɵɵlistener(\"change\", function CheckBoxComponent_Template_input_change_0_listener($event) {\n          return ctx.handleChange($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(1, \"label\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.checkBoxClasses);\n        i0.ɵɵproperty(\"id\", ctx.id)(\"checked\", ctx.checked)(\"indeterminate\", ctx.indeterminate)(\"tabindex\", ctx.tabindex);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"for\", ctx.id);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.labelText);\n      }\n    },\n    encapsulation: 2\n  });\n  return CheckBoxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst buildItem = (index, dataItem) => ({\n  dataItem,\n  index\n});\n\nlet id = 0;\nconst TREE_ITEM_ROLE = 'treeitem';\nconst BUTTON_ROLE = 'button';\n/**\n * @hidden\n *\n * A directive which manages the expanded state of the TreeView.\n */\n\nlet TreeViewItemDirective = /*#__PURE__*/(() => {\n  class TreeViewItemDirective {\n    constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {\n      this.element = element;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.lookupService = lookupService;\n      this.renderer = renderer;\n      this.ib = ib;\n      this.role = TREE_ITEM_ROLE;\n      this.loadOnDemand = true;\n      this.isDisabled = false;\n      this.isVisible = true;\n      this.ariaChecked = 'false';\n      this.id = id++;\n      this.isInitialized = false;\n      this.subscriptions = [];\n      this.subscribe();\n    }\n\n    set isChecked(checked) {\n      if (checked === 'checked') {\n        this.ariaChecked = 'true';\n      } else if (checked === 'indeterminate') {\n        this.ariaChecked = 'mixed';\n      } else {\n        this.ariaChecked = 'false';\n      }\n    }\n\n    get isExpanded() {\n      return this._isExpanded || false;\n    }\n\n    set isExpanded(isExpanded) {\n      this._isExpanded = isExpanded;\n    }\n\n    get isSelected() {\n      return this._isSelected || false;\n    }\n\n    set isSelected(isSelected) {\n      this._isSelected = isSelected;\n    }\n\n    get isButton() {\n      return this.role === BUTTON_ROLE;\n    }\n\n    get treeItem() {\n      return buildItem(this.index, this.dataItem);\n    }\n\n    get parentTreeItem() {\n      return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;\n    }\n\n    ngOnInit() {\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.registerItem(this.treeItem, this.parentTreeItem);\n      }\n\n      this.registerNavigationItem();\n      this.isInitialized = true;\n      this.setAttribute('role', this.role);\n      this.setAriaAttributes();\n      this.setDisabledClass();\n      this.updateTabIndex();\n    }\n\n    ngOnChanges(changes) {\n      const {\n        index,\n        isDisabled\n      } = changes;\n\n      if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {\n        this.setAriaAttributes();\n      }\n\n      if (isDisabled) {\n        this.setDisabledClass();\n      }\n\n      if (this.loadOnDemand && !this.isButton) {\n        this.moveLookupItem(changes);\n      }\n\n      this.moveNavigationItem(index);\n\n      if (anyChanged(['isDisabled', 'isVisible'], changes)) {\n        this.updateNodeAvailability();\n      }\n    }\n\n    ngOnDestroy() {\n      this.navigationService.unregisterItem(this.id, this.index);\n\n      if (this.loadOnDemand && !this.isButton) {\n        this.lookupService.unregisterItem(this.index, this.dataItem);\n      }\n\n      this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);\n    }\n\n    subscribe() {\n      this.subscriptions = [this.navigationService.moves.subscribe(navState => {\n        this.updateTabIndex();\n        this.focusItem(navState.shouldScroll);\n      }), this.navigationService.expands.pipe(filter(({\n        index\n      }) => index === this.index && !this.isDisabled)).subscribe(({\n        expand\n      }) => this.expand(expand))];\n    }\n\n    registerNavigationItem() {\n      this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);\n      this.activateItem();\n    }\n\n    activateItem() {\n      if (this.isDisabled) {\n        return;\n      }\n\n      const navigationService = this.navigationService;\n      const selectionService = this.selectionService;\n      const index = this.index;\n      selectionService.setFirstSelected(index, this.isSelected);\n\n      if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {\n        navigationService.activateIndex(index);\n      }\n    }\n\n    expand(shouldExpand) {\n      this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);\n    }\n\n    isFocusable() {\n      return !this.isDisabled && this.navigationService.isFocusable(this.index);\n    }\n\n    focusItem(scrollIntoView = false) {\n      if (this.isInitialized && this.navigationService.isActive(this.index)) {\n        this.element.nativeElement.focus({\n          preventScroll: !scrollIntoView\n        });\n      }\n    }\n\n    moveLookupItem(changes = {}) {\n      const {\n        dataItem,\n        index,\n        parentDataItem,\n        parentIndex\n      } = changes;\n\n      if (index && index.firstChange || //skip first change\n      !dataItem && !index && !parentDataItem && !parentIndex) {\n        return;\n      }\n\n      const oldIndex = (index || {}).previousValue || this.index;\n      this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);\n    }\n\n    moveNavigationItem(indexChange = {}) {\n      const {\n        currentValue,\n        firstChange,\n        previousValue\n      } = indexChange;\n\n      if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {\n        this.navigationService.unregisterItem(this.id, previousValue);\n        this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);\n      }\n    }\n\n    updateNodeAvailability() {\n      const service = this.navigationService;\n\n      if (this.isDisabled || !this.isVisible) {\n        service.activateClosest(this.index); // activate before unregister the item\n      } else {\n        service.activateFocusable();\n      }\n\n      service.unregisterItem(this.id, this.index);\n      service.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);\n    }\n\n    setAriaAttributes() {\n      this.setAttribute('aria-level', this.ib.level(this.index).toString()); // don't render attributes when the component configuration doesn't allow the specified state\n\n      this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);\n      this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);\n      this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);\n    }\n\n    setDisabledClass() {\n      this.setClass('k-disabled', this.isDisabled);\n    }\n\n    setClass(className, toggle) {\n      const action = toggle ? 'addClass' : 'removeClass';\n      this.renderer[action](this.element.nativeElement, className);\n    }\n\n    updateTabIndex() {\n      this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');\n    }\n\n    setAttribute(attr, value) {\n      if (!isPresent(value)) {\n        this.renderer.removeAttribute(this.element.nativeElement, attr);\n        return;\n      }\n\n      this.renderer.setAttribute(this.element.nativeElement, attr, value);\n    }\n\n  }\n\n  TreeViewItemDirective.ɵfac = function TreeViewItemDirective_Factory(t) {\n    return new (t || TreeViewItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(IndexBuilderService));\n  };\n\n  TreeViewItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TreeViewItemDirective,\n    selectors: [[\"\", \"kendoTreeViewItem\", \"\"]],\n    inputs: {\n      dataItem: \"dataItem\",\n      index: \"index\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      role: \"role\",\n      loadOnDemand: \"loadOnDemand\",\n      checkable: \"checkable\",\n      selectable: \"selectable\",\n      expandable: \"expandable\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      isVisible: \"isVisible\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TreeViewItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LoadingIndicatorDirective = /*#__PURE__*/(() => {\n  class LoadingIndicatorDirective {\n    constructor(expandService, loadingService, cd) {\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.cd = cd;\n      this._loading = false;\n    }\n\n    get loading() {\n      return this._loading;\n    }\n\n    set loading(value) {\n      this._loading = value;\n      this.cd.markForCheck();\n    }\n\n    ngOnInit() {\n      const loadingNotifications = this.loadingService.changes.pipe(filter(index => index === this.index));\n      this.subscription = this.expandService.changes.pipe(filter(({\n        index\n      }) => index === this.index), tap(({\n        expand\n      }) => {\n        if (!expand && this.loading) {\n          this.loading = false;\n        }\n      }), filter(({\n        expand\n      }) => expand), switchMap(x => of(x).pipe(delay(100), takeUntil(loadingNotifications)))).subscribe(() => this.loading = true);\n      this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n\n  }\n\n  LoadingIndicatorDirective.ɵfac = function LoadingIndicatorDirective_Factory(t) {\n    return new (t || LoadingIndicatorDirective)(i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(LoadingNotificationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  LoadingIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LoadingIndicatorDirective,\n    selectors: [[\"\", \"kendoTreeViewLoading\", \"\"]],\n    hostVars: 2,\n    hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"k-i-loading\", ctx.loading);\n      }\n    },\n    inputs: {\n      index: [\"kendoTreeViewLoading\", \"index\"]\n    }\n  });\n  return LoadingIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * A directive which manages the expanded state of the TreeView.\n */\n\n\nlet TreeViewItemContentDirective = /*#__PURE__*/(() => {\n  class TreeViewItemContentDirective {\n    constructor(element, navigationService, selectionService, renderer) {\n      this.element = element;\n      this.navigationService = navigationService;\n      this.selectionService = selectionService;\n      this.renderer = renderer;\n      this.initialSelection = false;\n      this.isSelected = isSelected;\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.navigationService.moves.subscribe(this.updateFocusClass.bind(this)));\n      this.subscriptions.add(this.navigationService.selects.pipe(filter(index => index === this.index)).subscribe(index => this.selectionService.select(index, this.dataItem)));\n      this.subscriptions.add(this.selectionService.changes.subscribe(() => {\n        this.updateSelectionClass(this.isSelected(this.dataItem, this.index));\n      }));\n    }\n\n    ngOnChanges(changes) {\n      if (changes.initialSelection) {\n        this.updateSelectionClass(this.initialSelection);\n      }\n\n      if (changes.index) {\n        this.updateFocusClass();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    updateFocusClass() {\n      this.render(this.navigationService.isActive(this.index), 'k-focus');\n    }\n\n    updateSelectionClass(selected) {\n      this.render(selected, 'k-selected');\n    }\n\n    render(addClass, className) {\n      const action = addClass ? 'addClass' : 'removeClass';\n      this.renderer[action](this.element.nativeElement, className);\n    }\n\n  }\n\n  TreeViewItemContentDirective.ɵfac = function TreeViewItemContentDirective_Factory(t) {\n    return new (t || TreeViewItemContentDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  TreeViewItemContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TreeViewItemContentDirective,\n    selectors: [[\"\", \"kendoTreeViewItemContent\", \"\"]],\n    inputs: {\n      dataItem: \"dataItem\",\n      index: \"index\",\n      initialSelection: \"initialSelection\",\n      isSelected: \"isSelected\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TreeViewItemContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TOP_ITEM = 'k-treeview-top';\nconst MID_ITEM = 'k-treeview-mid';\nconst BOT_ITEM = 'k-treeview-bot';\n/**\n * @hidden\n */\n\nlet TreeViewGroupComponent = /*#__PURE__*/(() => {\n  class TreeViewGroupComponent {\n    constructor(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef) {\n      this.expandService = expandService;\n      this.loadingService = loadingService;\n      this.indexBuilder = indexBuilder;\n      this.treeViewLookupService = treeViewLookupService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.dataChangeNotification = dataChangeNotification;\n      this.changeDetectorRef = changeDetectorRef;\n      this.kGroupClass = true;\n      this.role = 'group';\n      this.loadOnDemand = true;\n      this.textField = \"\";\n      this.size = 'medium';\n      this.initialNodesLoaded = false;\n      this.loadingMoreNodes = false;\n      this._data = [];\n      this.singleRecordSubscriptions = new Subscription();\n\n      this.isChecked = () => 'none';\n\n      this.isDisabled = () => false;\n\n      this.isExpanded = () => false;\n\n      this.isVisible = () => true;\n\n      this.isSelected = () => false;\n\n      this.children = () => of([]);\n\n      this.hasChildren = () => false;\n    }\n\n    get moreNodesAvailable() {\n      if (!isPresent(this.loadMoreService) || this.data.length === 0) {\n        return false;\n      }\n\n      return this.pageSize < this.totalNodesCount;\n    }\n\n    get pageSize() {\n      if (!isPresent(this.loadMoreService)) {\n        return null;\n      }\n\n      return this.loadMoreService.getGroupSize(this.parentDataItem);\n    }\n\n    set pageSize(pageSize) {\n      this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);\n    }\n\n    get data() {\n      if (isPresent(this.pageSize)) {\n        const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;\n        return this._data.slice(0, normalizedSizeValue);\n      }\n\n      return this._data;\n    }\n\n    set data(data) {\n      this._data = data;\n      this.registerLoadedNodes(this.data);\n    }\n\n    get loadMoreButtonIndex() {\n      if (!this.loadMoreService) {\n        return null;\n      }\n\n      return this.nodeIndex(this.data.length);\n    }\n    /**\n     * Represents the total number of nodes for the current level.\n     */\n\n\n    get totalNodesCount() {\n      if (!this.loadMoreService) {\n        return this.data.length;\n      }\n\n      return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);\n    }\n\n    get hasTemplate() {\n      return isPresent(this.nodeTemplateRef);\n    }\n\n    expandNode(index, dataItem, expand) {\n      if (expand) {\n        this.expandService.expand(index, dataItem);\n      } else {\n        this.expandService.collapse(index, dataItem);\n      }\n    }\n\n    checkNode(index) {\n      this.navigationService.checkIndex(index);\n      this.navigationService.activateIndex(index);\n    }\n\n    nodeIndex(index) {\n      return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);\n    }\n\n    nodeText(dataItem) {\n      const textField = isArray(this.textField) ? this.textField[0] : this.textField;\n      return getter(textField)(dataItem);\n    }\n\n    ngOnDestroy() {\n      if (isPresent(this.nodesSubscription)) {\n        this.nodesSubscription.unsubscribe();\n      }\n\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n\n      this.singleRecordSubscriptions.unsubscribe();\n    }\n\n    ngOnInit() {\n      this.subscribeToNodesChange();\n      this.singleRecordSubscriptions.add(this.dataChangeNotification.changes.subscribe(this.subscribeToNodesChange.bind(this)));\n      this.singleRecordSubscriptions.add(this.navigationService.loadMore.pipe(filter(index => index === this.loadMoreButtonIndex)).subscribe(this.loadMoreNodes.bind(this)));\n    }\n\n    ngOnChanges(changes) {\n      if (changes.parentIndex && this.loadOnDemand) {\n        this.setNodeChildren(this.mapToTreeItem(this.data));\n      }\n    }\n\n    fetchChildren(node, index) {\n      return this.children(node).pipe(catchError(() => {\n        this.loadingService.notifyLoaded(index);\n        return EMPTY;\n      }), tap(() => this.loadingService.notifyLoaded(index)));\n    }\n\n    get nextFields() {\n      if (isArray(this.textField)) {\n        return this.textField.length > 1 ? this.textField.slice(1) : this.textField;\n      }\n\n      return [this.textField];\n    }\n\n    loadMoreNodes() {\n      if (isPresent(this.loadMoreService.loadMoreNodes)) {\n        this.fetchMoreNodes();\n      } else {\n        this.loadMoreLocalNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    setItemClasses(dataLength, index) {\n      if (dataLength === 1) {\n        return this.parentIndex ? BOT_ITEM : `${TOP_ITEM} ${BOT_ITEM}`;\n      }\n\n      if (index === 0) {\n        return TOP_ITEM;\n      }\n\n      if (index > 0 && index < dataLength - 1) {\n        return MID_ITEM;\n      }\n\n      return index === this.totalNodesCount - 1 ? BOT_ITEM : MID_ITEM;\n    }\n\n    loadMoreLocalNodes() {\n      const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n      this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);\n      this.registerLoadedNodes(this.data); // forces the new items to be registered before the focus is changed\n\n      this.changeDetectorRef.detectChanges();\n      this.reselectItemAt(initialLoadMoreButtonIndex);\n    }\n\n    fetchMoreNodes() {\n      if (this.loadingMoreNodes) {\n        return;\n      }\n\n      this.loadingMoreNodes = true;\n\n      if (isPresent(this.loadMoreNodesSubscription)) {\n        this.loadMoreNodesSubscription.unsubscribe();\n      }\n\n      this.loadMoreNodesSubscription = this.loadMoreService.loadMoreNodes({\n        dataItem: this.parentDataItem,\n        skip: this.data.length,\n        take: this.loadMoreService.getInitialPageSize(this.parentDataItem)\n      }).pipe(finalize(() => this.loadingMoreNodes = false)).subscribe(items => {\n        if (!(Array.isArray(items) && items.length > 0)) {\n          return;\n        }\n\n        const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;\n        this.pageSize += items.length;\n        this.data = this.data.concat(items);\n\n        if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {\n          // forces the new items to be registered before the focus is changed\n          this.changeDetectorRef.detectChanges();\n          this.reselectItemAt(initialLoadMoreButtonIndex);\n        }\n      });\n    }\n\n    setNodeChildren(children) {\n      this.treeViewLookupService.registerChildren(this.parentIndex, children);\n    }\n\n    mapToTreeItem(data) {\n      if (!this.parentIndex) {\n        return [];\n      }\n\n      return data.map((dataItem, idx) => ({\n        dataItem,\n        index: this.nodeIndex(idx)\n      }));\n    }\n\n    emitChildrenLoaded(children) {\n      if (!this.parentIndex) {\n        return;\n      } // ignores the registered load-more button\n\n\n      const contentChildren = children.filter(item => item.dataItem);\n      this.nodeChildrenService.childrenLoaded({\n        dataItem: this.parentDataItem,\n        index: this.parentIndex\n      }, contentChildren);\n    }\n\n    subscribeToNodesChange() {\n      if (this.nodesSubscription) {\n        this.nodesSubscription.unsubscribe();\n      }\n\n      this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe(data => {\n        this.data = data;\n        this.initialNodesLoaded = true;\n      });\n    }\n\n    reselectItemAt(index) {\n      if (!isPresent(index)) {\n        return;\n      } // make sure the old index is cleared first\n\n\n      this.navigationService.deactivate();\n      this.navigationService.activateIndex(index);\n    }\n\n    registerLoadedNodes(nodes = []) {\n      const mappedChildren = this.mapToTreeItem(nodes);\n\n      if (this.loadOnDemand) {\n        this.setNodeChildren(mappedChildren);\n      }\n\n      this.emitChildrenLoaded(mappedChildren);\n    }\n\n  }\n\n  TreeViewGroupComponent.ɵfac = function TreeViewGroupComponent_Factory(t) {\n    return new (t || TreeViewGroupComponent)(i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(LoadingNotificationService), i0.ɵɵdirectiveInject(IndexBuilderService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(NodeChildrenService), i0.ɵɵdirectiveInject(DataChangeNotificationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  TreeViewGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TreeViewGroupComponent,\n    selectors: [[\"\", \"kendoTreeViewGroup\", \"\"]],\n    hostVars: 3,\n    hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"k-treeview-group\", ctx.kGroupClass);\n      }\n    },\n    inputs: {\n      checkboxes: \"checkboxes\",\n      expandIcons: \"expandIcons\",\n      disabled: \"disabled\",\n      selectable: \"selectable\",\n      touchActions: \"touchActions\",\n      loadOnDemand: \"loadOnDemand\",\n      trackBy: \"trackBy\",\n      nodes: \"nodes\",\n      textField: \"textField\",\n      parentDataItem: \"parentDataItem\",\n      parentIndex: \"parentIndex\",\n      nodeTemplateRef: \"nodeTemplateRef\",\n      loadMoreButtonTemplateRef: \"loadMoreButtonTemplateRef\",\n      loadMoreService: \"loadMoreService\",\n      size: \"size\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      isExpanded: \"isExpanded\",\n      isVisible: \"isVisible\",\n      isSelected: \"isSelected\",\n      children: \"children\",\n      hasChildren: \"hasChildren\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    attrs: _c0,\n    decls: 2,\n    vars: 3,\n    consts: [[\"class\", \"k-treeview-item\", \"kendoTreeViewItem\", \"\", 3, \"k-display-none\", \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"k-treeview-item\", \"kendoTreeViewItem\", \"\", \"role\", \"button\", 3, \"k-treeview-load-more-checkboxes-container\", \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\", 4, \"ngIf\"], [\"kendoTreeViewItem\", \"\", 1, \"k-treeview-item\", 3, \"dataItem\", \"index\", \"parentDataItem\", \"parentIndex\", \"loadOnDemand\", \"checkable\", \"isChecked\", \"isDisabled\", \"isVisible\", \"expandable\", \"isExpanded\", \"selectable\", \"isSelected\"], [3, \"ngClass\"], [\"class\", \"k-treeview-toggle\", 3, \"kendoTreeViewLoading\", \"click\", 4, \"ngIf\"], [3, \"size\", \"node\", \"index\", \"isChecked\", \"tabindex\", \"checkStateChange\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-treeview-leaf\", 3, \"dataItem\", \"index\", \"initialSelection\", \"isSelected\"], [1, \"k-treeview-leaf-text\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"disabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\", 4, \"ngIf\"], [1, \"k-treeview-toggle\", 3, \"kendoTreeViewLoading\", \"click\"], [1, \"k-icon\"], [3, \"size\", \"node\", \"index\", \"isChecked\", \"tabindex\", \"checkStateChange\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 3, \"nodes\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"disabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"parentIndex\", \"parentDataItem\", \"textField\", \"loadMoreService\", \"trackBy\"], [\"kendoTreeViewItem\", \"\", \"role\", \"button\", 1, \"k-treeview-item\", 3, \"selectable\", \"checkable\", \"expandable\", \"index\", \"parentDataItem\", \"parentIndex\"], [1, \"k-treeview-bot\"], [\"class\", \"k-icon k-i-loading k-i-expand\", 4, \"ngIf\"], [\"kendoTreeViewItemContent\", \"\", 1, \"k-treeview-leaf\", \"k-treeview-load-more-button\", 3, \"index\"], [4, \"ngIf\"], [1, \"k-icon\", \"k-i-loading\", \"k-i-expand\"]],\n    template: function TreeViewGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 10, 30, \"li\", 0);\n        i0.ɵɵtemplate(1, TreeViewGroupComponent_li_1_Template, 7, 14, \"li\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.data)(\"ngForTrackBy\", ctx.trackBy);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.initialNodesLoaded && ctx.moreNodesAvailable);\n      }\n    },\n    directives: [CheckBoxComponent, TreeViewGroupComponent, i9.NgForOf, TreeViewItemDirective, i9.NgClass, i9.NgIf, LoadingIndicatorDirective, TreeViewItemContentDirective, i9.NgSwitch, i9.NgSwitchCase, i9.NgTemplateOutlet, i9.NgSwitchDefault],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('toggle', [transition('void => *', [style({\n        height: 0\n      }), animate('0.1s ease-in', style({\n        height: \"*\"\n      }))]), transition('* => void', [style({\n        height: \"*\"\n      }), animate('0.1s ease-in', style({\n        height: 0\n      }))])])]\n    }\n  });\n  return TreeViewGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LOAD_MORE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\nconst providers = [ExpandStateService, IndexBuilderService, TreeViewLookupService, LoadingNotificationService, NodeChildrenService, NavigationService, SelectionService, DataChangeNotificationService, LocalizationService, {\n  provide: L10N_PREFIX,\n  useValue: 'kendo.treeview'\n}, {\n  provide: DataBoundComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}, {\n  provide: ExpandableComponent,\n  useExisting: forwardRef(() => TreeViewComponent)\n}];\n/**\n * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).\n *\n * @example\n * {% meta height:450 %}\n * {% embed_file get-started/app.component.ts preview %}\n * {% embed_file get-started/app.module.ts %}\n * {% embed_file shared/main.ts %}\n * {% endmeta %}\n */\n\nlet TreeViewComponent = /*#__PURE__*/(() => {\n  class TreeViewComponent {\n    constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {\n      this.element = element;\n      this.changeDetectorRef = changeDetectorRef;\n      this.expandService = expandService;\n      this.navigationService = navigationService;\n      this.nodeChildrenService = nodeChildrenService;\n      this.selectionService = selectionService;\n      this.treeViewLookupService = treeViewLookupService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.dataChangeNotification = dataChangeNotification;\n      this.localization = localization;\n      this.classNames = true;\n      this.role = 'tree';\n      /**\n       * The hint which is displayed when the component is empty.\n       */\n\n      this.filterInputPlaceholder = \"\";\n      /** @hidden */\n\n      this.fetchNodes = () => this.data;\n      /**\n       * Fires when the children of the expanded node are loaded.\n       */\n\n\n      this.childrenLoaded = new EventEmitter();\n      /**\n       * Fires when the user blurs the component.\n       */\n\n      this.onBlur = new EventEmitter();\n      /**\n       * Fires when the user focuses the component.\n       */\n\n      this.onFocus = new EventEmitter();\n      /**\n       * Fires when the user expands a TreeView node.\n       */\n\n      this.expand = new EventEmitter();\n      /**\n       * Fires when the user collapses a TreeView node.\n       */\n\n      this.collapse = new EventEmitter();\n      /**\n       * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.\n       * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.\n       */\n\n      this.nodeDragStart = new EventEmitter();\n      /**\n       * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n\n      this.nodeDrag = new EventEmitter();\n      /**\n       * Emits when the built-in filtering mechanism in the data-binding directives updates the node's visibility.\n       * Used for the built-in auto-expand functionalities of the component and available for custom implementations.\n       */\n\n      this.filterStateChange = new EventEmitter();\n      /**\n       * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),\n       * the `addItem` and `removeItem` events will not be triggered.\n       *\n       * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was\n       * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.\n       * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.\n       */\n\n      this.nodeDrop = new EventEmitter();\n      /**\n       * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       */\n\n      this.nodeDragEnd = new EventEmitter();\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView where the item is dropped.\n       */\n\n      this.addItem = new EventEmitter();\n      /**\n       * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).\n       * Called on the TreeView from where the item is dragged.\n       */\n\n      this.removeItem = new EventEmitter();\n      /**\n       * Fires when the user selects a TreeView node checkbox\n       * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n       */\n\n      this.checkedChange = new EventEmitter();\n      /**\n       * Fires when the user selects a TreeView node\n       * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Fires when the value of the built-in filter input element changes.\n       */\n\n      this.filterChange = new EventEmitter();\n      /**\n       * Fires when the user clicks a TreeView node.\n       */\n\n      this.nodeClick = new EventEmitter();\n      /**\n       * Fires when the user double clicks a TreeView node.\n       */\n\n      this.nodeDblClick = new EventEmitter();\n      /**\n       * A function that defines how to track node changes.\n       * By default, the TreeView tracks the nodes by data item object reference.\n       *\n       * @example\n       * ```ts\n       *  @Component({\n       *      selector: 'my-app',\n       *      template: `\n       *          <kendo-treeview\n       *              [nodes]=\"data\"\n       *              textField=\"text\"\n       *              [trackBy]=\"trackBy\"\n       *          >\n       *          </kendo-treeview>\n       *      `\n       *  })\n       *  export class AppComponent {\n       *      public data: any[] = [\n       *          { text: \"Furniture\" },\n       *          { text: \"Decor\" }\n       *      ];\n       *\n       *      public trackBy(index: number, item: any): any {\n       *          return item.text;\n       *      }\n       *  }\n       * ```\n       */\n\n      this.trackBy = trackBy;\n      /**\n       * A function which determines if a specific node is disabled.\n       */\n\n      this.isDisabled = isDisabled;\n      /**\n       * A callback which determines whether a TreeView node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.\n       * Useful for custom filtering implementations.\n       */\n\n      this.isVisible = isVisible;\n      /**\n       * Determines whether the TreeView keyboard navigable is enabled.\n       */\n\n      this.navigable = true;\n      /**\n       * A function which provides the child nodes for a given parent node\n       * ([see example]({% slug databinding_treeview %})).\n       */\n\n      this.children = () => of([]);\n      /**\n       * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.\n       * @default true\n       */\n\n\n      this.loadOnDemand = true;\n      /**\n       * Renders the built-in input element for filtering the TreeView.\n       * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the TreeView manually]({% slug filtering_treeview %}#toc-manual-filtering).\n       * A built-in filtering implementation is available to use with the [`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %}) and [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %}) directives.\n       */\n\n      this.filterable = false;\n      /**\n       * Sets an initial value of the built-in input element used for filtering.\n       */\n\n      this.filter = '';\n      this.checkboxes = false;\n      this.expandIcons = false;\n      this.selectable = false;\n      this.touchActions = true;\n      this.isActive = false;\n      this.data = new BehaviorSubject([]);\n      this._animate = true;\n      this._size = 'medium';\n      this.subscriptions = new Subscription();\n      this.domSubscriptions = [];\n      validatePackage(packageMetadata);\n    }\n    /** @hidden */\n\n\n    get direction() {\n      return this.localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * Determines whether the content animation is enabled.\n     */\n\n\n    set animate(value) {\n      this._animate = value;\n    }\n\n    get animate() {\n      return !this._animate;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each node.\n     * Takes precedence over nested templates in the TreeView tag.\n     */\n\n\n    set nodeTemplateRef(template) {\n      this._nodeTemplateRef = template;\n    }\n\n    get nodeTemplateRef() {\n      return this._nodeTemplateRef || this.nodeTemplateQuery;\n    }\n    /**\n     * @hidden\n     *\n     * Defines the template for each load-more button.\n     * Takes precedence over nested templates in the TreeView tag.\n     */\n\n\n    set loadMoreButtonTemplateRef(template) {\n      this._loadMoreButtonTemplateRef = template;\n    }\n\n    get loadMoreButtonTemplateRef() {\n      return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;\n    }\n    /**\n     * The nodes which will be displayed by the TreeView\n     * ([see example]({% slug databinding_treeview %})).\n     */\n\n\n    set nodes(value) {\n      this.data.next(value || []);\n      this.dataChangeNotification.notify();\n    }\n\n    get nodes() {\n      return this.data.value;\n    }\n    /**\n     * A function which determines if a specific node has child nodes\n     * ([see example]({% slug databinding_treeview %})).\n     */\n\n\n    get hasChildren() {\n      return this._hasChildren || hasChildren;\n    }\n\n    set hasChildren(callback) {\n      this._hasChildren = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is checked\n     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).\n     */\n\n\n    get isChecked() {\n      return this._isChecked || isChecked;\n    }\n\n    set isChecked(callback) {\n      this._isChecked = callback;\n      this.checkboxes = Boolean(this._isChecked);\n    }\n    /**\n     * A function which determines if a specific node is expanded.\n     */\n\n\n    get isExpanded() {\n      return this._isExpanded || isExpanded;\n    }\n\n    set isExpanded(callback) {\n      this._isExpanded = callback;\n      this.expandIcons = Boolean(this._isExpanded && this._hasChildren);\n    }\n    /**\n     * A function which determines if a specific node is selected\n     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).\n     */\n\n\n    get isSelected() {\n      return this._isSelected || isSelected;\n    }\n\n    set isSelected(callback) {\n      this._isSelected = callback;\n      this.selectable = Boolean(this._isSelected);\n    }\n    /**\n     * Sets the size of the component.\n     *\n     * The possible values are:\n     * * `small`\n     * * `medium` (default)\n     * * `large`\n     * * `none`\n     */\n\n\n    set size(size) {\n      const newSize = size ? size : 'medium';\n\n      if (this.size !== 'none') {\n        this.renderer.removeClass(this.element.nativeElement, getSizeClass('treeview', this.size));\n      }\n\n      this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', newSize));\n      this._size = size;\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    ngOnChanges(changes) {\n      this.navigationService.navigable = Boolean(this.navigable); // TODO: should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n      if (anyChanged(['nodes', 'children', 'hasChildren', 'loadOnDemand'], changes, false) && !this.loadOnDemand) {\n        this.preloadChildNodes();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.domSubscriptions.forEach(subscription => subscription());\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.nodeChildrenService.changes.subscribe(x => this.childrenLoaded.emit(x)));\n      this.subscriptions.add(this.expandService.changes.subscribe(({\n        index,\n        dataItem,\n        expand\n      }) => expand ? this.expand.emit({\n        index,\n        dataItem\n      }) : this.collapse.emit({\n        index,\n        dataItem\n      })));\n      this.subscriptions.add(this.navigationService.checks.subscribe(x => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));\n      this.subscriptions.add(this.selectionService.changes.subscribe(x => {\n        if (hasObservers(this.selectionChange)) {\n          this.ngZone.run(() => {\n            this.selectionChange.emit(x);\n          });\n        }\n      }));\n\n      if (this.element) {\n        this.ngZone.runOutsideAngular(() => {\n          this.attachDomHandlers();\n        });\n      }\n\n      if (this.size) {\n        this.renderer.addClass(this.element.nativeElement, getSizeClass('treeview', this.size));\n      }\n    }\n    /**\n     * Blurs the focused TreeView item.\n     */\n\n\n    blur() {\n      if (!isDocumentAvailable()) {\n        return;\n      }\n\n      const target = focusableNode(this.element);\n\n      if (document.activeElement === target) {\n        target.blur();\n      }\n    }\n    /**\n     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     *  @Component({\n     *      selector: 'my-app',\n     *      template: `\n     *      <button (click)=\"treeview.focus('1')\">Focuses the second node</button>\n     *      <kendo-treeview\n     *          #treeview\n     *          [nodes]=\"data\"\n     *          textField=\"text\"\n     *      >\n     *      </kendo-treeview>\n     *  `\n     *  })\n     *  export class AppComponent {\n     *      public data: any[] = [\n     *          { text: \"Furniture\" },\n     *          { text: \"Decor\" }\n     *      ];\n     *  }\n     * ```\n     */\n\n\n    focus(index) {\n      const focusIndex = index || nodeIndex(this.navigationService.focusableItem);\n      this.navigationService.activateIndex(focusIndex);\n      const target = focusableNode(this.element);\n\n      if (target) {\n        target.focus();\n      }\n    }\n    /**\n     * Based on the specified index, returns the TreeItemLookup node.\n     *\n     * @param index - The index of the node.\n     * @returns {TreeItemLookup} - The item that was searched (looked up).\n     */\n\n\n    itemLookup(index) {\n      return this.treeViewLookupService.itemLookup(index);\n    }\n    /**\n     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,\n     * causing all rendered child nodes to be fetched again.\n     */\n\n\n    rebindChildren() {\n      this.dataChangeNotification.notify();\n    }\n    /**\n     * Triggers the `expand` event for the provided node and displays it's loading indicator.\n     */\n\n\n    expandNode(item, index) {\n      this.expandService.expand(index, item);\n    }\n    /**\n     * Triggers the `collapse` event for the provided node.\n     */\n\n\n    collapseNode(item, index) {\n      this.expandService.collapse(index, item);\n    }\n    /**\n     * Gets the current page size of the checked data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @returns {number} - The page size of the checked data item children collection.\n     */\n\n\n    getNodePageSize(dataItem) {\n      this.verifyLoadMoreService();\n      return this.loadMoreService.getGroupSize(dataItem);\n    }\n    /**\n     * Sets the page size of the targeted data item children collection\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).\n     *\n     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.\n     *\n     * @param dataItem {any} - The parent data item of the targeted collection.\n     * @param pageSize {number} - The new page size.\n     */\n\n\n    setNodePageSize(dataItem, pageSize) {\n      this.verifyLoadMoreService();\n      this.loadMoreService.setGroupSize(dataItem, pageSize);\n    }\n    /**\n     * @hidden\n     *\n     * Clears the current TreeViewLookupService node map and re-registers all nodes anew.\n     * Child nodes are acquired through the provided `children` callback.\n     */\n\n\n    preloadChildNodes() {\n      this.treeViewLookupService.reset();\n      this.registerLookupItems(this.nodes);\n    }\n\n    attachDomHandlers() {\n      const element = this.element.nativeElement;\n      this.clickHandler = this.clickHandler.bind(this);\n      this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));\n    }\n\n    focusHandler(e) {\n      let focusItem;\n\n      if (match(e.target, '.k-treeview-item')) {\n        focusItem = e.target;\n      } else if (!isFocusable(e.target)) {\n        // with compliments to IE\n        focusItem = closestNode(e.target);\n      }\n\n      if (focusItem) {\n        this.navigationService.activateIndex(nodeId(e.target));\n\n        if (!this.isActive && hasObservers(this.onFocus)) {\n          this.ngZone.run(() => {\n            this.onFocus.emit();\n          });\n        }\n\n        this.isActive = true;\n      }\n    }\n\n    blurHandler(e) {\n      if (this.isActive && match(e.target, '.k-treeview-item') && (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {\n        this.navigationService.deactivate();\n        this.isActive = false;\n\n        if (hasObservers(this.onBlur)) {\n          this.ngZone.run(() => {\n            this.onBlur.emit();\n          });\n        }\n      }\n    }\n\n    clickHandler(e) {\n      const target = e.target;\n\n      if (e.type === 'contextmenu' && !hasObservers(this.nodeClick) || e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target) || e.type === 'dblclick' && !hasObservers(this.nodeDblClick) || isFocusable(target) || !isContent(target) && !isLoadMoreButton(target) || !hasParent(target, this.element.nativeElement)) {\n        return;\n      }\n\n      const index = nodeId(closestNode(target)); // the disabled check is probably not needed due to the k-disabled styles\n\n      if (!index || this.navigationService.isDisabled(index)) {\n        return;\n      }\n\n      this.ngZone.run(() => {\n        // record this value before emitting selectionChange (`this.navigationService.selectIndex`), as the treeview state may be changed on its emission\n        const lookup = this.treeViewLookupService.itemLookup(index);\n\n        if (e.type === 'click') {\n          const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;\n\n          if (loadMoreButton) {\n            this.navigationService.notifyLoadMore(index);\n            return;\n          } else {\n            this.navigationService.selectIndex(index);\n          }\n        }\n\n        const emitter = e.type === 'dblclick' ? this.nodeDblClick : this.nodeClick;\n        emitter.emit({\n          item: lookup.item,\n          originalEvent: e,\n          type: e.type\n        });\n      });\n    }\n\n    keydownHandler(e) {\n      if (this.isActive && this.navigable) {\n        this.ngZone.run(() => {\n          this.navigationService.move(e);\n        });\n      }\n    }\n\n    verifyLoadMoreService() {\n      if (isDevMode() && !isPresent(this.loadMoreService)) {\n        throw new Error(`To use the TreeView paging functionality, you need to assign the \\`kendoTreeViewLoadMore\\` directive. See ${LOAD_MORE_DOC_LINK$1}.`);\n      }\n    }\n\n    registerLookupItems(data, parentItem = null) {\n      if (!isPresent(data) || data.length === 0) {\n        return;\n      }\n\n      const parentIndex = nodeIndex(parentItem);\n      const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));\n\n      if (isPresent(parentItem)) {\n        this.treeViewLookupService.registerChildren(parentIndex, treeItems);\n      }\n\n      treeItems.forEach(item => {\n        this.treeViewLookupService.registerItem(item, parentItem);\n\n        if (this.hasChildren(item.dataItem)) {\n          this.children(item.dataItem).subscribe(children => this.registerLookupItems(children, item));\n        }\n      });\n    }\n\n  }\n\n  TreeViewComponent.ɵfac = function TreeViewComponent_Factory(t) {\n    return new (t || TreeViewComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ExpandStateService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(NodeChildrenService), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(TreeViewLookupService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DataChangeNotificationService), i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  TreeViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TreeViewComponent,\n    selectors: [[\"kendo-treeview\"]],\n    contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplateQuery = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadMoreButtonTemplateQuery = _t.first);\n      }\n    },\n    viewQuery: function TreeViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c3, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function TreeViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"dir\", ctx.direction);\n        i0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.animate);\n        i0.ɵɵclassProp(\"k-treeview\", ctx.classNames);\n      }\n    },\n    inputs: {\n      filterInputPlaceholder: \"filterInputPlaceholder\",\n      animate: \"animate\",\n      nodeTemplateRef: [\"nodeTemplate\", \"nodeTemplateRef\"],\n      loadMoreButtonTemplateRef: [\"loadMoreButtonTemplate\", \"loadMoreButtonTemplateRef\"],\n      trackBy: \"trackBy\",\n      nodes: \"nodes\",\n      textField: \"textField\",\n      hasChildren: \"hasChildren\",\n      isChecked: \"isChecked\",\n      isDisabled: \"isDisabled\",\n      isExpanded: \"isExpanded\",\n      isSelected: \"isSelected\",\n      isVisible: \"isVisible\",\n      navigable: \"navigable\",\n      children: \"children\",\n      loadOnDemand: \"loadOnDemand\",\n      filterable: \"filterable\",\n      filter: \"filter\",\n      size: \"size\"\n    },\n    outputs: {\n      childrenLoaded: \"childrenLoaded\",\n      onBlur: \"blur\",\n      onFocus: \"focus\",\n      expand: \"expand\",\n      collapse: \"collapse\",\n      nodeDragStart: \"nodeDragStart\",\n      nodeDrag: \"nodeDrag\",\n      filterStateChange: \"filterStateChange\",\n      nodeDrop: \"nodeDrop\",\n      nodeDragEnd: \"nodeDragEnd\",\n      addItem: \"addItem\",\n      removeItem: \"removeItem\",\n      checkedChange: \"checkedChange\",\n      selectionChange: \"selectionChange\",\n      filterChange: \"filterChange\",\n      nodeClick: \"nodeClick\",\n      nodeDblClick: \"nodeDblClick\"\n    },\n    exportAs: [\"kendoTreeView\"],\n    features: [i0.ɵɵProvidersFeature(providers), i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 20,\n    consts: [[\"class\", \"k-treeview-filter\", 4, \"ngIf\"], [\"kendoTreeViewGroup\", \"\", \"role\", \"group\", 1, \"k-treeview-lines\", 3, \"size\", \"loadOnDemand\", \"checkboxes\", \"expandIcons\", \"selectable\", \"touchActions\", \"children\", \"hasChildren\", \"isChecked\", \"isDisabled\", \"isExpanded\", \"isSelected\", \"isVisible\", \"nodeTemplateRef\", \"loadMoreButtonTemplateRef\", \"textField\", \"nodes\", \"loadMoreService\", \"trackBy\"], [\"assetsContainer\", \"\"], [1, \"k-treeview-filter\"], [3, \"size\", \"value\", \"clearButton\", \"placeholder\", \"valueChange\"], [\"kendoTextBoxPrefixTemplate\", \"\"], [1, \"k-input-icon\", \"k-icon\", \"k-i-search\"]],\n    template: function TreeViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TreeViewComponent_span_0_Template, 3, 4, \"span\", 0);\n        i0.ɵɵelement(1, \"ul\", 1);\n        i0.ɵɵelementContainer(2, null, 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.filterable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"size\", ctx.size)(\"loadOnDemand\", ctx.loadOnDemand)(\"checkboxes\", ctx.checkboxes)(\"expandIcons\", ctx.expandIcons)(\"selectable\", ctx.selectable)(\"touchActions\", ctx.touchActions)(\"children\", ctx.children)(\"hasChildren\", ctx.hasChildren)(\"isChecked\", ctx.isChecked)(\"isDisabled\", ctx.isDisabled)(\"isExpanded\", ctx.isExpanded)(\"isSelected\", ctx.isSelected)(\"isVisible\", ctx.isVisible)(\"nodeTemplateRef\", ctx.nodeTemplateRef == null ? null : ctx.nodeTemplateRef.templateRef)(\"loadMoreButtonTemplateRef\", ctx.loadMoreButtonTemplateRef == null ? null : ctx.loadMoreButtonTemplateRef.templateRef)(\"textField\", ctx.textField)(\"nodes\", ctx.fetchNodes)(\"loadMoreService\", ctx.loadMoreService)(\"trackBy\", ctx.trackBy);\n      }\n    },\n    directives: [i8.TextBoxComponent, TreeViewGroupComponent, i9.NgIf, i8.TextBoxPrefixTemplateDirective],\n    encapsulation: 2\n  });\n  return TreeViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst indexChecked = (keys, index) => keys.filter(k => k === index).length > 0;\n\nconst matchKey = index => k => {\n  if (index === k) {\n    return true;\n  }\n\n  if (!k.split) {\n    return false;\n  }\n\n  return k.split('_').reduce(({\n    key,\n    result\n  }, part) => {\n    key += part;\n\n    if (index === key || result) {\n      return {\n        result: true\n      };\n    }\n\n    key += \"_\";\n    return {\n      key,\n      result: false\n    };\n  }, {\n    key: \"\",\n    result: false\n  }).result;\n};\n/**\n * A directive which manages the in-memory checked state of the TreeView node\n * ([see example]({% slug checkboxes_treeview %})).\n */\n\n\nlet CheckDirective = /*#__PURE__*/(() => {\n  class CheckDirective {\n    constructor(treeView, zone) {\n      this.treeView = treeView;\n      this.zone = zone;\n      /**\n       * Fires when the `checkedKeys` collection was updated.\n       */\n\n      this.checkedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this.checkActions = {\n        'multiple': e => this.checkMultiple(e),\n        'single': e => this.checkSingle(e)\n      };\n      /**\n       * Reflectes the internal `checkedKeys` state.\n       */\n\n      this.state = new Set();\n      this.subscriptions.add(this.treeView.checkedChange.subscribe(e => this.check(e)));\n      let expandedItems = [];\n      this.subscriptions.add(this.treeView.childrenLoaded.pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap(item => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1)))).subscribe(() => this.addCheckedItemsChildren(expandedItems)));\n      this.treeView.isChecked = this.isItemChecked.bind(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isChecked(value) {\n      this.treeView.isChecked = value;\n    }\n\n    get options() {\n      const defaultOptions = {\n        checkChildren: true,\n        checkParents: true,\n        enabled: true,\n        mode: \"multiple\"\n      };\n\n      if (!isPresent(this.checkable) || typeof this.checkable === 'string') {\n        return defaultOptions;\n      }\n\n      const checkSettings = isBoolean(this.checkable) ? {\n        enabled: this.checkable\n      } : this.checkable;\n      return Object.assign(defaultOptions, checkSettings);\n    }\n\n    ngOnChanges(changes) {\n      if (changes.checkable) {\n        this.treeView.checkboxes = this.options.enabled;\n        this.toggleCheckOnClick();\n      }\n\n      if (isChanged('checkedKeys', changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {\n        this.state = new Set(changes.checkedKeys.currentValue);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n      this.unsubscribeClick();\n    }\n\n    isItemChecked(dataItem, index) {\n      if (!this.checkKey) {\n        return this.isIndexChecked(index);\n      }\n\n      const hasKey = this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n      return hasKey ? 'checked' : 'none';\n    }\n\n    isIndexChecked(index) {\n      const checkedKeys = Array.from(this.state).filter(matchKey(index));\n\n      if (indexChecked(checkedKeys, index)) {\n        return 'checked';\n      }\n\n      const {\n        mode,\n        checkParents\n      } = this.options;\n\n      if (mode === 'multiple' && checkParents && checkedKeys.length) {\n        return 'indeterminate';\n      }\n\n      return 'none';\n    }\n\n    itemKey(item) {\n      if (!isPresent(this.checkKey)) {\n        return item.index;\n      }\n\n      if (typeof this.checkKey === \"string\" && isPresent(item.dataItem)) {\n        return item.dataItem[this.checkKey];\n      }\n\n      if (typeof this.checkKey === \"function\") {\n        return this.checkKey(item);\n      }\n    }\n\n    check(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.checkActions[mode] || noop;\n\n      if (!enabled) {\n        return;\n      }\n\n      performSelection(e);\n    }\n\n    checkSingle(node) {\n      const key = this.itemKey(node.item);\n      const hasKey = this.state.has(key);\n      this.state.clear();\n\n      if (!hasKey) {\n        this.state.add(key);\n      }\n\n      this.notify();\n    }\n\n    checkMultiple(node) {\n      this.checkNode(node);\n\n      if (this.options.checkParents) {\n        this.checkParents(node.parent);\n      }\n\n      this.notify();\n    }\n\n    toggleCheckOnClick() {\n      this.unsubscribeClick();\n\n      if (this.options.checkOnClick) {\n        this.clickSubscription = this.treeView.nodeClick.subscribe(args => {\n          if (args.type === 'click') {\n            const lookup = this.treeView.itemLookup(args.item.index);\n            this.check(lookup);\n          }\n        });\n      }\n    }\n\n    unsubscribeClick() {\n      if (this.clickSubscription) {\n        this.clickSubscription.unsubscribe();\n        this.clickSubscription = null;\n      }\n    }\n\n    checkNode(node) {\n      if (!isPresent(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index)) {\n        return;\n      }\n\n      const currentKey = this.itemKey(node.item);\n\n      if (!isPresent(currentKey)) {\n        return;\n      }\n\n      const pendingCheck = [currentKey];\n\n      if (this.options.checkChildren) {\n        const descendants = fetchLoadedDescendants(node, ({\n          item\n        }) => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index)).map(({\n          item\n        }) => this.itemKey(item));\n        pendingCheck.push(...descendants);\n      }\n\n      const shouldCheck = !this.state.has(currentKey);\n      pendingCheck.forEach(key => {\n        if (shouldCheck) {\n          this.state.add(key);\n        } else {\n          this.state.delete(key);\n        }\n      });\n    }\n\n    checkParents(parent) {\n      if (!isPresent(parent)) {\n        return;\n      }\n\n      let currentParent = parent;\n\n      while (currentParent) {\n        const parentKey = this.itemKey(currentParent.item);\n        const allChildrenSelected = currentParent.children.every(item => this.state.has(this.itemKey(item)));\n\n        if (allChildrenSelected) {\n          this.state.add(parentKey);\n        } else {\n          this.state.delete(parentKey);\n        }\n\n        currentParent = currentParent.parent;\n      }\n    }\n\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.checkedKeysChange.emit(this.lastChange);\n    }\n\n    addCheckedItemsChildren(lookups) {\n      if (!isPresent(lookups) || lookups.length === 0) {\n        return;\n      }\n\n      const initiallyCheckedItemsCount = this.state.size;\n      lookups.forEach(lookup => {\n        const itemKey = this.itemKey(lookup.item);\n\n        if (!this.state.has(itemKey)) {\n          return;\n        }\n\n        lookup.children.forEach(item => {\n          // ensure both the parent item and each child node is enabled\n          if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) && !this.treeView.isDisabled(item.dataItem, item.index)) {\n            this.state.add(this.itemKey(item));\n          }\n        });\n      });\n      const hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;\n\n      if (hasNewlyCheckedItems) {\n        this.zone.run(() => this.notify());\n      }\n    }\n\n  }\n\n  CheckDirective.ɵfac = function CheckDirective_Factory(t) {\n    return new (t || CheckDirective)(i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  CheckDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CheckDirective,\n    selectors: [[\"\", \"kendoTreeViewCheckable\", \"\"]],\n    inputs: {\n      isChecked: \"isChecked\",\n      checkKey: [\"checkBy\", \"checkKey\"],\n      checkedKeys: \"checkedKeys\",\n      checkable: [\"kendoTreeViewCheckable\", \"checkable\"]\n    },\n    outputs: {\n      checkedKeysChange: \"checkedKeysChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return CheckDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which manages the disabled in-memory state of the TreeView node\n * ([see example]({% slug disabledstate_treeview %})).\n */\n\n\nlet DisableDirective = /*#__PURE__*/(() => {\n  class DisableDirective {\n    constructor(treeView, cdr) {\n      this.treeView = treeView;\n      this.cdr = cdr;\n      /**\n       * Defines the collection that will store the disabled keys.\n       */\n\n      this.disabledKeys = [];\n\n      this.treeView.isDisabled = (dataItem, index) => this.disabledKeys.indexOf(this.itemKey({\n        dataItem,\n        index\n      })) > -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isDisabled(value) {\n      this.treeView.isDisabled = value;\n    }\n\n    ngOnChanges(changes = {}) {\n      const {\n        disabledKeys\n      } = changes;\n\n      if (disabledKeys && !disabledKeys.firstChange) {\n        this.cdr.markForCheck();\n      }\n    }\n\n    itemKey(e) {\n      if (!this.disableKey) {\n        return e.index;\n      }\n\n      if (typeof this.disableKey === \"string\") {\n        return e.dataItem[this.disableKey];\n      }\n\n      if (typeof this.disableKey === \"function\") {\n        return this.disableKey(e);\n      }\n    }\n\n  }\n\n  DisableDirective.ɵfac = function DisableDirective_Factory(t) {\n    return new (t || DisableDirective)(i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  DisableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DisableDirective,\n    selectors: [[\"\", \"kendoTreeViewDisable\", \"\"]],\n    inputs: {\n      isDisabled: \"isDisabled\",\n      disableKey: [\"kendoTreeViewDisable\", \"disableKey\"],\n      disabledKeys: \"disabledKeys\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DisableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_FILTER_EXPAND_SETTINGS = {\n  maxAutoExpandResults: -1,\n  expandMatches: false,\n  expandedOnClear: \"none\"\n};\n/**\n * A directive which manages the expanded state of the TreeView.\n * ([see example]({% slug expandedstate_treeview %})).\n */\n\nlet ExpandDirective = /*#__PURE__*/(() => {\n  class ExpandDirective {\n    constructor(component) {\n      this.component = component;\n      /**\n       * Whether or not to auto-expand the nodes leading from the root node to each filter result.\n       * To fine-tune this behavior, pass a [`FilterExpandSettings`]({% slug api_treeview_filterexpandsettings %}) object to this input.\n       * @default false\n       */\n\n      this.expandOnFilter = false;\n      /**\n       * Fires when the `expandedKeys` collection was updated.\n       */\n\n      this.expandedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      /**\n       * Reflectes the internal `expandedKeys` state.\n       */\n\n      this.state = new Set();\n      this.originalExpandedKeys = new Set();\n      this.isFiltered = false;\n      /**\n       * Fills array with the correct expand keys according to wrapper metadata.\n       */\n\n      this.updateExpandedNodes = (collection, node, autoExpandMatches) => {\n        if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.updateExpandedNodes(collection, child, autoExpandMatches);\n          });\n        }\n      };\n      /**\n       * Fills array with the expand key of every node.\n       */\n\n\n      this.getEveryExpandKey = (collection, node) => {\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          collection.push(this.itemKey({\n            dataItem: node.dataItem,\n            index: node.index\n          }));\n        }\n\n        if (isArrayWithAtLeastOneItem(node.children)) {\n          node.children.forEach(child => {\n            this.getEveryExpandKey(collection, child);\n          });\n        }\n      };\n\n      this.subscriptions.add(merge(this.component.expand.pipe(map(e => Object.assign({\n        expand: true\n      }, e))), this.component.collapse.pipe(map(e => Object.assign({\n        expand: false\n      }, e)))).subscribe(this.toggleExpand.bind(this)));\n\n      if (this.component.filterStateChange) {\n        this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));\n      }\n\n      this.component.isExpanded = (dataItem, index) => this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isExpanded(value) {\n      this.component.isExpanded = value;\n    }\n\n    get filterExpandSettings() {\n      const settings = isBoolean(this.expandOnFilter) ? {\n        enabled: this.expandOnFilter\n      } : Object.assign(Object.assign({}, this.expandOnFilter), {\n        enabled: true\n      });\n      return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('expandedKeys', changes, false) && changes.expandedKeys.currentValue !== this.lastChange) {\n        this.state = new Set(changes.expandedKeys.currentValue);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    itemKey(e) {\n      if (this.expandKey) {\n        if (typeof this.expandKey === \"string\") {\n          return e.dataItem[this.expandKey];\n        }\n\n        if (typeof this.expandKey === \"function\") {\n          return this.expandKey(e);\n        }\n      }\n\n      return e.index;\n    }\n\n    toggleExpand({\n      index,\n      dataItem,\n      expand\n    }) {\n      const key = this.itemKey({\n        index,\n        dataItem\n      });\n      const isExpanded = this.state.has(key);\n      let notify = false;\n\n      if (isExpanded && !expand) {\n        this.state.delete(key);\n        notify = true;\n      } else if (!isExpanded && expand) {\n        this.state.add(key);\n        notify = true;\n      }\n\n      if (notify) {\n        this.notify();\n      }\n    }\n\n    handleAutoExpand({\n      nodes,\n      matchCount,\n      term\n    }) {\n      if (!this.filterExpandSettings.enabled) {\n        return;\n      }\n\n      const {\n        maxAutoExpandResults,\n        expandMatches: autoExpandMatches,\n        expandedOnClear\n      } = this.filterExpandSettings;\n\n      if (!this.isFiltered) {\n        this.originalExpandedKeys = new Set(this.state);\n      }\n\n      const exitingFilteredState = this.isFiltered && !term;\n      const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;\n      const exitAutoExpandedState = exitingFilteredState || maxExceeded;\n\n      if (exitAutoExpandedState) {\n        switch (expandedOnClear) {\n          case \"initial\":\n            {\n              if (!sameValues(this.state, this.originalExpandedKeys)) {\n                this.state = this.originalExpandedKeys;\n                this.notify();\n              }\n\n              break;\n            }\n\n          case \"all\":\n            {\n              this.state = new Set(nodes.reduce((acc, rootNode) => {\n                this.getEveryExpandKey(acc, rootNode);\n                return acc;\n              }, []));\n              this.notify();\n              break;\n            }\n\n          case \"unchanged\":\n            {\n              break;\n            }\n\n          case \"none\":\n          default:\n            {\n              if (this.state.size !== 0) {\n                this.state.clear();\n                this.notify();\n              }\n\n              break;\n            }\n        }\n\n        this.isFiltered = false;\n        return;\n      }\n\n      const indicesToExpand = new Set(nodes.reduce((acc, rootNode) => {\n        this.updateExpandedNodes(acc, rootNode, autoExpandMatches);\n        return acc;\n      }, []));\n\n      if (!sameValues(this.state, indicesToExpand)) {\n        this.state = indicesToExpand;\n        this.notify();\n      }\n\n      this.isFiltered = true;\n    }\n\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.expandedKeysChange.emit(this.lastChange);\n    }\n\n  }\n\n  ExpandDirective.ɵfac = function ExpandDirective_Factory(t) {\n    return new (t || ExpandDirective)(i0.ɵɵdirectiveInject(ExpandableComponent));\n  };\n\n  ExpandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ExpandDirective,\n    selectors: [[\"\", \"kendoTreeViewExpandable\", \"\"]],\n    inputs: {\n      isExpanded: \"isExpanded\",\n      expandKey: [\"expandBy\", \"expandKey\"],\n      expandOnFilter: \"expandOnFilter\",\n      expandedKeys: \"expandedKeys\"\n    },\n    outputs: {\n      expandedKeysChange: \"expandedKeysChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return ExpandDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which manages the in-memory selection state of the TreeView node\n * ([see example]({% slug selection_treeview %})).\n */\n\n\nlet SelectDirective = /*#__PURE__*/(() => {\n  class SelectDirective {\n    constructor(treeView) {\n      this.treeView = treeView;\n      /**\n       * Fires when the `selectedKeys` collection was updated.\n       */\n\n      this.selectedKeysChange = new EventEmitter();\n      this.subscriptions = new Subscription();\n      this.selectActions = {\n        'multiple': e => this.selectMultiple(e),\n        'single': e => this.selectSingle(e)\n      };\n      /**\n       * Reflectes the internal `selectedKeys` state.\n       */\n\n      this.state = new Set();\n      this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));\n\n      this.treeView.isSelected = (dataItem, index) => this.state.has(this.itemKey({\n        dataItem,\n        index\n      }));\n    }\n    /**\n     * @hidden\n     */\n\n\n    set isSelected(value) {\n      this.treeView.isSelected = value;\n    }\n\n    get getAriaMultiselectable() {\n      return this.options.mode === 'multiple';\n    }\n\n    get options() {\n      const defaultOptions = {\n        enabled: true,\n        mode: 'single'\n      };\n\n      if (!isPresent(this.selection) || typeof this.selection === 'string') {\n        return defaultOptions;\n      }\n\n      const selectionSettings = isBoolean(this.selection) ? {\n        enabled: this.selection\n      } : this.selection;\n      return Object.assign(defaultOptions, selectionSettings);\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('selectedKeys', changes, false) && changes.selectedKeys.currentValue !== this.lastChange) {\n        this.state = new Set(changes.selectedKeys.currentValue);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    itemKey(e) {\n      if (!this.selectKey) {\n        return e.index;\n      }\n\n      if (typeof this.selectKey === 'string') {\n        return e.dataItem[this.selectKey];\n      }\n\n      if (typeof this.selectKey === 'function') {\n        return this.selectKey(e);\n      }\n    }\n\n    select(e) {\n      const {\n        enabled,\n        mode\n      } = this.options;\n      const performSelection = this.selectActions[mode] || noop;\n\n      if (!enabled) {\n        return;\n      }\n\n      performSelection(e);\n    }\n\n    selectSingle(node) {\n      const key = this.itemKey(node);\n\n      if (!this.state.has(key)) {\n        this.state.clear();\n        this.state.add(key);\n        this.notify();\n      }\n    }\n\n    selectMultiple(node) {\n      const key = this.itemKey(node);\n      const isSelected = this.state.has(key);\n\n      if (!isPresent(key)) {\n        return;\n      }\n\n      if (isSelected) {\n        this.state.delete(key);\n      } else {\n        this.state.add(key);\n      }\n\n      this.notify();\n    }\n\n    notify() {\n      this.lastChange = Array.from(this.state);\n      this.selectedKeysChange.emit(this.lastChange);\n    }\n\n  }\n\n  SelectDirective.ɵfac = function SelectDirective_Factory(t) {\n    return new (t || SelectDirective)(i0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  SelectDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectDirective,\n    selectors: [[\"\", \"kendoTreeViewSelectable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function SelectDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-multiselectable\", ctx.getAriaMultiselectable);\n      }\n    },\n    inputs: {\n      isSelected: \"isSelected\",\n      selectKey: [\"selectBy\", \"selectKey\"],\n      selection: [\"kendoTreeViewSelectable\", \"selection\"],\n      selectedKeys: \"selectedKeys\"\n    },\n    outputs: {\n      selectedKeysChange: \"selectedKeysChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return SelectDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Describes the attempted drop action during dragging.\n * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.\n * By default, this value defines the rendered icon in the drag clue.\n */\n\n\nvar DropAction = /*#__PURE__*/(() => {\n  (function (DropAction) {\n    DropAction[DropAction[\"Add\"] = 0] = \"Add\";\n    DropAction[DropAction[\"InsertTop\"] = 1] = \"InsertTop\";\n    DropAction[DropAction[\"InsertBottom\"] = 2] = \"InsertBottom\";\n    DropAction[DropAction[\"InsertMiddle\"] = 3] = \"InsertMiddle\";\n    DropAction[DropAction[\"Invalid\"] = 4] = \"Invalid\";\n  })(DropAction || (DropAction = {}));\n\n  return DropAction;\n})();\n\n/**\n * Describes where the dragged item is dropped relative to the drop target item.\n */\nvar DropPosition = /*#__PURE__*/(() => {\n  (function (DropPosition) {\n    DropPosition[DropPosition[\"Over\"] = 0] = \"Over\";\n    DropPosition[DropPosition[\"Before\"] = 1] = \"Before\";\n    DropPosition[DropPosition[\"After\"] = 2] = \"After\";\n  })(DropPosition || (DropPosition = {}));\n\n  return DropPosition;\n})();\n\n/**\n * @hidden\n */\nvar ScrollDirection = /*#__PURE__*/(() => {\n  (function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Up\"] = -1] = \"Up\";\n    ScrollDirection[ScrollDirection[\"Down\"] = 1] = \"Down\";\n  })(ScrollDirection || (ScrollDirection = {}));\n\n  return ScrollDirection;\n})();\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.\n */\n\n\nclass TreeItemDropEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer, originalEvent) {\n    super();\n    /**\n     * @hidden\n     */\n\n    this.isValid = true;\n    Object.assign(this, initializer);\n    this.originalEvent = originalEvent;\n  }\n  /**\n   * Specifies if the drop action should be marked as valid.\n   * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n   * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue\n   * will be animated back to the source item to indicate the action is marked as invalid.\n   */\n\n\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.\n */\n\n\nclass TreeItemDragStartEvent extends PreventableEvent {\n  /**\n   * @hidden\n   */\n  constructor(initializer) {\n    super();\n    Object.assign(this, initializer);\n  }\n\n}\n/**\n * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.\n */\n\n\nclass TreeItemDragEvent {\n  /** @hidden */\n  constructor() {}\n\n}\n/**\n * Checks if the browser supports relative stacking context.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n */\n\n\nconst hasRelativeStackingContext = memoize(() => {\n  if (!(isDocumentAvailable() && isPresent(document.body))) {\n    return false;\n  }\n\n  const top = 10;\n  const parent = document.createElement(\"div\");\n  parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n  parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n  document.body.appendChild(parent);\n  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n  document.body.removeChild(parent);\n  return isDifferent;\n});\n/**\n * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.\n */\n\nfunction memoize(fn) {\n  let result;\n  let called = false;\n  return (...args) => {\n    if (called) {\n      return result;\n    }\n\n    result = fn(...args);\n    called = true;\n    return result;\n  };\n}\n/**\n * @hidden\n *\n * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.\n * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;\n */\n\n\nconst getContainerOffset = element => {\n  if (!(element && hasRelativeStackingContext())) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  let offsetParent = element.parentElement;\n\n  while (offsetParent) {\n    if (window.getComputedStyle(offsetParent).transform !== 'none') {\n      break;\n    }\n\n    offsetParent = offsetParent.parentElement;\n  }\n\n  if (offsetParent) {\n    const rect = offsetParent.getBoundingClientRect();\n    return {\n      left: rect.left - offsetParent.scrollLeft,\n      top: rect.top - offsetParent.scrollTop\n    };\n  }\n\n  return {\n    left: 0,\n    top: 0\n  };\n};\n/**\n * @hidden\n */\n\n\nconst getDropAction = (dropPosition, dropTarget) => {\n  if (!(isPresent(dropPosition) && isPresent(dropTarget))) {\n    return DropAction.Invalid;\n  }\n\n  switch (dropPosition) {\n    case DropPosition.Over:\n      return DropAction.Add;\n\n    case DropPosition.Before:\n      return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;\n\n    case DropPosition.After:\n      return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;\n\n    default:\n      return DropAction.Invalid;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {\n  if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {\n    return;\n  } // the .k-treeview-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right\n\n\n  const item = closestWithMatch(target, '.k-treeview-top, .k-treeview-mid, .k-treeview-bot');\n\n  if (!isPresent(item)) {\n    return;\n  } // the content element (.k-treeview-leaf:not(.k-treeview-load-more-button)) holds just the treeview item text\n\n\n  const content = getContentElement(item);\n  const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));\n\n  if (!isPresent(content) || content === draggedItem || targetChildOfDraggedItem) {\n    return;\n  }\n\n  const itemViewPortCoords = content.getBoundingClientRect();\n  /*\n      if the user is hovering a treeview item, split the item height into four parts:\n          - dropping into the top quarter should insert the dragged item before the drop target\n          - dropping into the bottom quarter should insert the dragged item after the drop target\n          - dropping into the second or third quarter should add the item as child node of the drop target\n       if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:\n          - dropping should insert before or after\n  */\n\n  const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2); // clear any possible container offset created by parent elements with `transform` css property set\n\n  const pointerPosition = clientY - containerOffset.top;\n  const itemTop = itemViewPortCoords.top - containerOffset.top;\n\n  if (pointerPosition < itemTop + itemDivisionHeight) {\n    return DropPosition.Before;\n  }\n\n  if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {\n    return DropPosition.After;\n  }\n\n  return DropPosition.Over;\n};\n/**\n * @hidden\n */\n\n\nconst treeItemFromEventTarget = (treeView, dropTarget) => {\n  if (!(isPresent(treeView) && isPresent(dropTarget))) {\n    return null;\n  }\n\n  const node = closestNode(dropTarget);\n  const index = nodeId(node);\n  const lookup = treeView.itemLookup(index);\n\n  if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {\n    return null;\n  }\n\n  return lookup;\n};\n/**\n * @hidden\n *\n * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.\n */\n\n\nconst collapseEmptyParent = (parent, parentNodes, treeview) => {\n  if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {\n    treeview.collapseNode(parent.item.dataItem, parent.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Expands the node if it's dropped into and it's not yet expanded.\n */\n\n\nconst expandDropTarget = (dropTarget, treeView) => {\n  if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {\n    treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);\n  }\n};\n/**\n * @hidden\n *\n * Extracts the event target from the viewport coords. Required for touch devices\n * where the `event.target` of a `pointermove` event is always the initially dragged item.\n */\n\n\nconst getDropTarget = event => {\n  if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {\n    return event.target;\n  }\n\n  return document.elementFromPoint(event.clientX, event.clientY);\n};\n/**\n * @hidden\n *\n * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.\n */\n\n\nconst updateMovedItemIndex = (newIndex, originalIndex) => {\n  const movedItemNewIndexParts = newIndex.split('_');\n  const originalItemIndexParts = originalIndex.split('_'); // if the original item was moved from a deeper level, there's no need for index correction\n  // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved\n\n  if (movedItemNewIndexParts.length < originalItemIndexParts.length) {\n    return newIndex;\n  } // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies\n  // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved\n  // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved\n\n\n  const originalItemParentPathLength = originalItemIndexParts.length - 1;\n  const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');\n  const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_'); // check if the the index of the level where the original item is taken from is greater than the one of the moved item\n  // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved\n  // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved\n\n  const originalItemIndexLevel = originalItemIndexParts.length - 1;\n  const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);\n  const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);\n\n  if (originalItemParentPath === movedItemParentPath && movedItemLevelIndex > originalItemLevelIndex) {\n    // if the removed item causes the dropped item to be moved a position up - decrement the index at that level\n    movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);\n    return movedItemNewIndexParts.join('_');\n  }\n\n  return newIndex;\n};\n/**\n * @hidden\n */\n\n\nconst SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');\n/**\n * @hidden\n *\n * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.\n */\n\nconst getScrollableContainer = node => {\n  while (isPresent(node) && node.nodeName !== 'HTML') {\n    const hasOverflow = node.scrollHeight > node.clientHeight;\n    const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);\n\n    if (hasOverflow && hasScrollbar) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n *\n * Checks if the top of the scrollable element is reached.\n * Floors the scrollTop value.\n */\n\n\nconst isTopReached = element => Math.floor(element.scrollTop) <= 0;\n/**\n * @hidden\n *\n * Checks if the bottom of the scrollable element is reached.\n * Ceils the scrollTop value.\n */\n\n\nconst isBottomReached = element => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;\n/**\n * @hidden\n *\n * Scrolls the element in the given direction by the provided step.\n *\n * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),\n * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.\n *\n * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.\n */\n\n\nconst scrollElementBy = (element, step, direction) => {\n  if (!(isPresent(element) && isDocumentAvailable())) {\n    return;\n  }\n\n  const initialScrollTop = element.scrollTop;\n  let currentStep = step;\n  let iterations = 0;\n\n  while (initialScrollTop === element.scrollTop && !(direction === ScrollDirection.Up && isTopReached(element)) && !(direction === ScrollDirection.Down && isBottomReached(element)) && iterations < 20 // as the bulgarian saying goes - to ties our underpants\n  ) {\n    element.scrollTop += currentStep * direction;\n    currentStep += 1;\n    iterations += 1;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst copyPageSize = (treeview, source, target) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const sourceGroupSize = treeview.getNodePageSize(source);\n  treeview.setNodePageSize(target, sourceGroupSize);\n};\n/**\n * @hidden\n */\n\n\nconst incrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize + 1);\n};\n/**\n * @hidden\n */\n\n\nconst decrementPageSize = (treeview, dataItem) => {\n  if (!isPresent(treeview.loadMoreService)) {\n    return;\n  }\n\n  const currentPageSize = treeview.getNodePageSize(dataItem);\n  treeview.setNodePageSize(dataItem, currentPageSize - 1);\n};\n/**\n * @hidden\n */\n\n\nclass HierarchyEditingService {\n  constructor(hierarchyBinding) {\n    this.hierarchyBinding = hierarchyBinding;\n  }\n\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationChildren = this.childrenFor(getDataItem(destinationItem)); // add the moved node just before the load more button if load more is enabled\n\n      const targetIndex = isPresent(destinationTree.loadMoreService) ? Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : // the page size might be greater than the actual children array length\n      destinationChildren.length;\n      destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);\n      setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);\n    } else {\n      const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);\n    } // increment the parent page size => an item is moved into it\n\n\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent); // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem); // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    } // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n\n\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);\n    const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));\n    sourceParentNodes.splice(sourceItemIndex, 1); // emit collapse for the parent node if its last child node was spliced\n\n    collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree); // decrement source item parent page size => an item has been removed from it\n\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent)); // reload the treeview nodes\n\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    } // if the source and destination trees are different we want to focus only the moved item in the destination tree\n\n\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges(); // after the source item is removed from its original position, the candidate index might have to be corrected\n\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n\n  getParentNodes(node, treeView) {\n    return isPresent(node.parent) ? this.childrenFor(getDataItem(node.parent)) : treeView.nodes;\n  }\n\n  childrenFor(dataItem) {\n    return getter(this.hierarchyBinding.childrenField)(dataItem) || [];\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst DEFAULT_FILTER_SETTINGS = {\n  operator: 'contains',\n  ignoreCase: true,\n  mode: \"lenient\"\n};\n/**\n * @hidden\n */\n\nlet FilteringBase = /*#__PURE__*/(() => {\n  class FilteringBase {\n    constructor(component) {\n      this.component = component;\n      this.visibleNodes = new Set();\n      this._filterSettings = DEFAULT_FILTER_SETTINGS;\n    }\n    /**\n     * The settings which are applied when performing a filter on the component's data.\n     */\n\n\n    set filterSettings(settings) {\n      this._filterSettings = Object.assign(Object.assign({}, DEFAULT_FILTER_SETTINGS), settings);\n    }\n\n    get filterSettings() {\n      return this._filterSettings;\n    }\n    /**\n     * Applies a filter and changes the visibility of the component's nodes accordingly.\n     */\n\n\n    set filter(term) {\n      this.handleFilterChange(term);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleFilterChange(term) {\n      if (!this.filterData) {\n        return;\n      }\n\n      this.resetNodesVisibility(this.filterData);\n\n      if (term) {\n        filterTree(this.filterData, term, this.filterSettings, this.component.textField);\n      }\n\n      this.updateVisibleNodes(this.filterData);\n\n      if (isPresent(this.component.filterStateChange)) {\n        this.component.filterStateChange.emit({\n          nodes: this.filterData,\n          matchCount: this.visibleNodes.size,\n          term,\n          filterSettings: this.filterSettings\n        });\n      }\n    }\n\n    updateVisibleNodes(items) {\n      items.forEach(wrapper => {\n        if (wrapper.visible) {\n          this.visibleNodes.add(wrapper.dataItem);\n        }\n\n        if (wrapper.children) {\n          this.updateVisibleNodes(wrapper.children);\n        }\n      });\n    }\n\n    resetNodesVisibility(items) {\n      this.visibleNodes.clear();\n      items.forEach(wrapper => {\n        wrapper.visible = true;\n\n        if (wrapper.children) {\n          this.resetNodesVisibility(wrapper.children);\n        }\n      });\n    }\n\n  }\n\n  FilteringBase.ɵfac = function FilteringBase_Factory(t) {\n    return new (t || FilteringBase)(i0.ɵɵdirectiveInject(DataBoundComponent));\n  };\n\n  FilteringBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FilteringBase,\n    inputs: {\n      filterSettings: \"filterSettings\",\n      filter: \"filter\"\n    }\n  });\n  return FilteringBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DragClueComponent = /*#__PURE__*/(() => {\n  class DragClueComponent {\n    constructor(cdr) {\n      this.cdr = cdr;\n      this.hostClasses = true;\n      this.posistionStyle = 'fixed';\n    }\n\n    get statusIconClass() {\n      switch (this.action) {\n        case DropAction.Add:\n          return 'k-i-plus';\n\n        case DropAction.InsertTop:\n          return 'k-i-insert-up';\n\n        case DropAction.InsertBottom:\n          return 'k-i-insert-down';\n\n        case DropAction.InsertMiddle:\n          return 'k-i-insert-middle';\n\n        case DropAction.Invalid:\n        default:\n          return 'k-i-cancel';\n      }\n    } // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n\n\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n\n  }\n\n  DragClueComponent.ɵfac = function DragClueComponent_Factory(t) {\n    return new (t || DragClueComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  DragClueComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DragClueComponent,\n    selectors: [[\"kendo-treeview-drag-clue\"]],\n    hostVars: 6,\n    hostBindings: function DragClueComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"position\", ctx.posistionStyle);\n        i0.ɵɵclassProp(\"k-header\", ctx.hostClasses)(\"k-drag-clue\", ctx.hostClasses);\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function DragClueComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 4, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, DragClueComponent_1_Template, 1, 7, null, 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    directives: [i9.NgIf, i9.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DragClueComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DragAndDropAssetService = /*#__PURE__*/(() => {\n  class DragAndDropAssetService {\n    get componentRef() {\n      if (!isPresent(this._componentRef)) {\n        throw new Error('The `initalize` method must be called before calling other service methods.');\n      }\n\n      return this._componentRef;\n    }\n\n    set componentRef(componentRef) {\n      this._componentRef = componentRef;\n    }\n\n    get element() {\n      return this.componentRef.location.nativeElement;\n    }\n\n    ngOnDestroy() {\n      if (!isPresent(this._componentRef)) {\n        return;\n      }\n\n      this.element.parentElement.removeChild(this.element);\n      this.componentRef.destroy();\n      this.componentRef = null;\n    }\n\n    show() {\n      this.element.style.display = '';\n    }\n\n    hide() {\n      this.element.style.display = 'none';\n    }\n\n    move(left, top, offset = 0) {\n      this.element.style.left = `${left + offset}px`;\n      this.element.style.top = `${top + offset}px`;\n    }\n\n  }\n\n  DragAndDropAssetService.ɵfac = function DragAndDropAssetService_Factory(t) {\n    return new (t || DragAndDropAssetService)();\n  };\n\n  DragAndDropAssetService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DragAndDropAssetService,\n    factory: DragAndDropAssetService.ɵfac\n  });\n  return DragAndDropAssetService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst CLUE_OFFSET = 10;\n/**\n * @hidden\n */\n\nconst RETURN_ANIMATION_DURATION = 200;\n/**\n * @hidden\n */\n\nlet DragClueService = /*#__PURE__*/(() => {\n  class DragClueService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n\n      const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);\n      this.componentRef = container.createComponent(clueComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n\n    ngOnDestroy() {\n      this.cancelReturnAnimation();\n      this.cancelScroll();\n      super.ngOnDestroy();\n    }\n\n    move(left, top) {\n      super.move(left, top, CLUE_OFFSET);\n    }\n\n    animateDragClueToElementPosition(target) {\n      if (!(isPresent(target) && isPresent(this.element.animate))) {\n        this.hide();\n        return;\n      }\n\n      const targetElementViewPortCoords = target.getBoundingClientRect();\n      const clueElementViewPortCoords = this.element.getBoundingClientRect();\n      this.returnAnimation = this.element.animate([{\n        transform: 'translate(0, 0)'\n      }, {\n        transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)`\n      }], RETURN_ANIMATION_DURATION);\n\n      this.returnAnimation.onfinish = () => this.hide();\n    }\n\n    cancelReturnAnimation() {\n      if (!isPresent(this.returnAnimation)) {\n        return;\n      }\n\n      this.returnAnimation.cancel();\n      this.returnAnimation = null;\n    }\n\n    updateDragClueData(action, sourceItem, destinationItem) {\n      const dragClue = this.componentRef.instance;\n\n      if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {\n        return;\n      }\n\n      dragClue.action = action;\n      dragClue.sourceItem = sourceItem;\n      dragClue.destinationItem = destinationItem;\n      dragClue.detectChanges();\n    }\n\n    updateText(text) {\n      if (text === this.componentRef.instance.text) {\n        return;\n      }\n\n      this.componentRef.instance.text = text;\n      this.componentRef.instance.detectChanges();\n    }\n    /**\n     * Triggers the first scrollable parent to scroll upwards or downwards.\n     * Uses setInterval, so should be called outside the angular zone.\n     */\n\n\n    scrollIntoView({\n      step,\n      interval\n    }) {\n      this.cancelScroll();\n      const scrollableContainer = getScrollableContainer(this.element);\n\n      if (!isPresent(scrollableContainer)) {\n        return;\n      }\n\n      const containerRect = scrollableContainer.getBoundingClientRect();\n      const clueRect = this.element.getBoundingClientRect(); // if the beginning of the scrollable container is above the current viewport, fall-back to 0\n\n      const firstVisibleClientTopPart = Math.max(containerRect.top, 0); // start scrolling up when the first visible item is dragged over\n\n      const topLimit = firstVisibleClientTopPart + clueRect.height; // if the end of the scrollable container is beneath the current viewport, fall-back to its client height\n      // add the distance from the start of the viewport to the beginning of the container to ensure scrolling bottom begins when the actual end of the container is reached\n\n      const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);\n\n      if (clueRect.top < topLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval);\n      } else if (clueRect.bottom > bottomLimit) {\n        this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval);\n      }\n    }\n    /**\n     * Cancels out the on-going scroll animation, if present.\n     */\n\n\n    cancelScroll() {\n      if (isPresent(this.scrollInterval)) {\n        clearInterval(this.scrollInterval);\n        this.scrollInterval = null;\n      }\n    }\n\n  }\n\n  DragClueService.ɵfac = function DragClueService_Factory(t) {\n    return new (t || DragClueService)(i0.ɵɵinject(i0.ComponentFactoryResolver));\n  };\n\n  DragClueService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DragClueService,\n    factory: DragClueService.ɵfac\n  });\n  return DragClueService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DropHintComponent = /*#__PURE__*/(() => {\n  class DropHintComponent {\n    constructor(changeDetectorRef) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.hostClass = true;\n      this.position = 'fixed';\n      this.pointerEvents = 'none';\n    } // exposed as a public method that can be called from outside as the component uses `OnPush` strategy\n\n\n    detectChanges() {\n      this.changeDetectorRef.detectChanges();\n    }\n\n  }\n\n  DropHintComponent.ɵfac = function DropHintComponent_Factory(t) {\n    return new (t || DropHintComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  DropHintComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DropHintComponent,\n    selectors: [[\"kendo-treeview-drop-hint\"]],\n    hostVars: 6,\n    hostBindings: function DropHintComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"position\", ctx.position)(\"pointer-events\", ctx.pointerEvents);\n        i0.ɵɵclassProp(\"k-drop-hint-container\", ctx.hostClass);\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"k-drop-hint k-drop-hint-h\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"k-drop-hint\", \"k-drop-hint-h\"], [1, \"k-drop-hint-start\"], [1, \"k-drop-hint-line\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function DropHintComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DropHintComponent_div_0_Template, 3, 0, \"div\", 0);\n        i0.ɵɵtemplate(1, DropHintComponent_1_Template, 1, 6, null, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.template);\n      }\n    },\n    directives: [i9.NgIf, i9.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return DropHintComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DropHintService = /*#__PURE__*/(() => {\n  class DropHintService extends DragAndDropAssetService {\n    constructor(componentFactoryResolver) {\n      super();\n      this.componentFactoryResolver = componentFactoryResolver;\n    }\n\n    initialize(container, template) {\n      if (isPresent(this._componentRef)) {\n        this.ngOnDestroy();\n      }\n\n      const hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);\n      this.componentRef = container.createComponent(hintComponentFactory);\n      this.hide();\n      this.componentRef.instance.template = template;\n      this.componentRef.changeDetectorRef.detectChanges();\n    }\n\n    updateDropHintData(action, sourceItem, destinationItem) {\n      const dropHint = this.componentRef.instance;\n\n      if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {\n        return;\n      }\n\n      dropHint.action = action;\n      dropHint.sourceItem = sourceItem;\n      dropHint.destinationItem = destinationItem;\n      dropHint.detectChanges();\n    }\n\n  }\n\n  DropHintService.ɵfac = function DropHintService_Factory(t) {\n    return new (t || DropHintService)(i0.ɵɵinject(i0.ComponentFactoryResolver));\n  };\n\n  DropHintService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DropHintService,\n    factory: DropHintService.ɵfac\n  });\n  return DropHintService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,\n * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n *\n *\n * The text, attempted drop action, source item and destination item are available as context variables in the template:\n *\n *\n * - `let-text=\"text\"` (`string`)\n * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n */\n\n\nlet DragClueTemplateDirective = /*#__PURE__*/(() => {\n  class DragClueTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DragClueTemplateDirective.ɵfac = function DragClueTemplateDirective_Factory(t) {\n    return new (t || DragClueTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DragClueTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DragClueTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewDragClueTemplate\", \"\"]]\n  });\n  return DragClueTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,\n * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag\n * ([see example]({% slug draganddrop_treeview %}#toc-templates)).\n *\n * The attempted drop action, source item and destination item are available as context variables in the template:\n *\n * - `let-action=\"action\"` ([`DropAction`]({% slug api_treeview_dropaction %}))\n * - `let-sourceItem=\"sourceItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n * - `let-destinationItem=\"destinationItem\"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))\n */\n\n\nlet DropHintTemplateDirective = /*#__PURE__*/(() => {\n  class DropHintTemplateDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  DropHintTemplateDirective.ɵfac = function DropHintTemplateDirective_Factory(t) {\n    return new (t || DropHintTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8));\n  };\n\n  DropHintTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DropHintTemplateDirective,\n    selectors: [[\"\", \"kendoTreeViewDropHintTemplate\", \"\"]]\n  });\n  return DropHintTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULT_SCROLL_SETTINGS = {\n  enabled: true,\n  step: 1,\n  interval: 1\n};\n/**\n * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances\n * ([see example]({% slug draganddrop_treeview %})).\n *\n * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),\n * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),\n * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),\n * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),\n * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and\n * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n * events when the corresponding actions occur on the respective TreeView instance.\n */\n\nlet DragAndDropDirective = /*#__PURE__*/(() => {\n  class DragAndDropDirective {\n    constructor(element, zone, treeview, dragClueService, dropHintService) {\n      this.element = element;\n      this.zone = zone;\n      this.treeview = treeview;\n      this.dragClueService = dragClueService;\n      this.dropHintService = dropHintService;\n      /**\n       * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.\n       * If enabled, the `removeItem` event will not be fired on the source TreeView\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       *\n       * @default false\n       */\n\n      this.allowCopy = false;\n      /**\n       * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped\n       * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).\n       */\n\n      this.dropZoneTreeViews = [];\n      /**\n       * Specifies the distance in pixels from the initial item pointerdown event, before the dragging is initiated.\n       * The `nodeDragStart` and all consequent TreeView drag events will not be fired until the actual dragging begins.\n       *\n       * @default 5\n       */\n\n      this.startDragAfter = 5;\n      /**\n       * Controlls the auto-scrolling behavior during drag-and-drop ([see example]({% slug draganddrop_treeview %}#toc-auto-scrolling)).\n       * Enbaled by default. To turn the auto-scrolling off, set this prop to `false`.\n       *\n       * By default, the scrolling will be performed by 1 pixel at every 1 millisecond, when the dragged item reaches the top or the bottom of the scrollable container.\n       * The `step` and `interval` can be overridden by providing a `DragAndDropScrollSettings` object to this prop.\n       *\n       * @default true\n       */\n\n      this.autoScroll = true;\n      /**\n       * @hidden\n       */\n\n      this.userSelectStyle = 'none';\n      /**\n       * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.\n       * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.\n       * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n       */\n\n      this.containerOffset = {\n        top: 0,\n        left: 0\n      };\n      this.treeview.touchActions = false;\n    }\n\n    get scrollSettings() {\n      const userProvidedSettings = typeof this.autoScroll === 'boolean' ? {\n        enabled: this.autoScroll\n      } : this.autoScroll;\n      return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);\n    }\n\n    ngAfterContentInit() {\n      this.initalizeDraggable();\n      this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);\n      this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);\n    }\n\n    ngOnDestroy() {\n      this.draggable.destroy();\n    }\n    /**\n     * @hidden\n     */\n\n\n    handlePress({\n      originalEvent\n    }) {\n      if (!isContent(originalEvent.target)) {\n        return;\n      } // store the drag target on press, show it only when it's actually dragged\n\n\n      this.draggedItem = closestWithMatch(originalEvent.target, '.k-treeview-leaf'); // record the current pointer down coords - copared to the `startDragAfter` value to calculate whether to initiate dragging\n\n      this.pendingDragStartEvent = originalEvent;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleDrag({\n      originalEvent,\n      clientX,\n      clientY\n    }) {\n      if (this.shouldInitiateDragStart({\n        clientX,\n        clientY\n      })) {\n        this.initiateDragStart();\n      }\n\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        return;\n      }\n\n      const dropTarget = getDropTarget(originalEvent);\n\n      if (hasObservers(this.treeview.nodeDrag)) {\n        this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));\n      }\n\n      const targetTreeView = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);\n      const dropHintAnchor = closestWithMatch(dropTarget, '.k-treeview-top, .k-treeview-mid, .k-treeview-bot');\n      const dropAction = getDropAction(dropPosition, dropTarget);\n      const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);\n      this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);\n      this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);\n\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.scrollIntoView(this.scrollSettings);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleRelease({\n      originalEvent,\n      clientY\n    }) {\n      if (this.scrollSettings.enabled) {\n        this.dragClueService.cancelScroll();\n      }\n\n      if (!isPresent(this.draggedItem) || isPresent(this.pendingDragStartEvent)) {\n        this.pendingDragStartEvent = null;\n        this.draggedItem = null;\n        return;\n      }\n\n      const dropTarget = getDropTarget(originalEvent);\n      const sourceTree = this.treeview;\n      const destinationTree = this.getTargetTreeView(dropTarget);\n      const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);\n      const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);\n      const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);\n\n      if (isPresent(destinationItem) && isPresent(dropPosition)) {\n        this.zone.run(() => this.notifyDrop({\n          sourceItem,\n          destinationItem,\n          dropPosition,\n          sourceTree,\n          destinationTree\n        }, originalEvent));\n      } else {\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n\n      if (hasObservers(this.treeview.nodeDragEnd)) {\n        this.zone.run(() => this.notifyDragEnd({\n          sourceItem,\n          destinationItem,\n          originalEvent\n        }));\n      }\n\n      this.dropHintService.hide();\n      this.draggedItem = null;\n    }\n\n    updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {\n      if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {\n        this.dropHintService.hide();\n        return;\n      }\n\n      const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();\n      const insertBefore = dropPosition === DropPosition.Before;\n      const top = insertBefore ? anchorViewPortCoords.top : anchorViewPortCoords.top + anchorViewPortCoords.height;\n      this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem); // clear any possible container offset created by parent elements with `transform` css property set\n\n      this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);\n      this.dropHintService.show();\n    }\n\n    updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {\n      // clear any possible container offset created by parent elements with `transform` css property set\n      this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);\n      this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);\n      this.dragClueService.show();\n    }\n\n    initalizeDraggable() {\n      this.draggable = new Draggable({\n        press: this.handlePress.bind(this),\n        drag: this.handleDrag.bind(this),\n        release: this.handleRelease.bind(this)\n      });\n      this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n    }\n\n    notifyDragStart(originalEvent, dropTarget) {\n      const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);\n      const event = new TreeItemDragStartEvent({\n        sourceItem,\n        originalEvent\n      });\n      this.treeview.nodeDragStart.emit(event);\n      return event;\n    }\n\n    notifyDrag(originalEvent, dropTarget) {\n      const dragEvent = {\n        sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),\n        destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),\n        originalEvent\n      };\n      this.treeview.nodeDrag.emit(dragEvent);\n    }\n\n    notifyDrop(args, originalEvent) {\n      const event = new TreeItemDropEvent(args, originalEvent);\n      args.destinationTree.nodeDrop.emit(event); // disable the animations on drop and restore them afterwards (if they were initially turned on)\n\n      this.disableAnimationsForNextTick(args.destinationTree);\n\n      if (args.sourceTree !== args.destinationTree) {\n        this.disableAnimationsForNextTick(args.sourceTree);\n      }\n\n      if (!event.isDefaultPrevented() && event.isValid) {\n        this.dragClueService.hide(); // order matters in a flat data binding scenario (first add, then remove)\n\n        args.destinationTree.addItem.emit(args);\n\n        if (!(originalEvent.ctrlKey && this.allowCopy)) {\n          args.sourceTree.removeItem.emit(args);\n        }\n      } else if (event.isDefaultPrevented()) {\n        // directly hide the clue if the default is prevented\n        this.dragClueService.hide();\n      } else if (!event.isValid) {\n        // animate the clue back to the source item position if marked as invalid\n        this.dragClueService.animateDragClueToElementPosition(this.draggedItem);\n      }\n    }\n\n    notifyDragEnd(dragEndEvent) {\n      this.treeview.nodeDragEnd.emit(dragEndEvent);\n    }\n\n    getTargetTreeView(dropTarget) {\n      const treeViewTagName = this.treeview.element.nativeElement.tagName;\n      const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);\n      return [this.treeview, ...this.dropZoneTreeViews].find(treeView => isPresent(treeView) && treeView.element.nativeElement === targetTreeView);\n    }\n\n    disableAnimationsForNextTick(treeView) {\n      // the treeView.animate getter returns `true` when the animations are turned off\n      // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)\n      if (treeView.animate) {\n        return;\n      }\n\n      treeView.animate = false;\n      this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));\n    }\n\n    shouldInitiateDragStart(currentPointerCoords) {\n      if (!isPresent(this.pendingDragStartEvent)) {\n        return false;\n      }\n\n      const distanceFromPointerDown = Math.sqrt(Math.pow(this.pendingDragStartEvent.clientX - currentPointerCoords.clientX, 2) + Math.pow(this.pendingDragStartEvent.clientY - currentPointerCoords.clientY, 2));\n      return distanceFromPointerDown >= this.startDragAfter;\n    }\n\n    initiateDragStart() {\n      if (hasObservers(this.treeview.nodeDragStart)) {\n        const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));\n\n        if (dragStartEvent.isDefaultPrevented()) {\n          this.pendingDragStartEvent = null;\n          this.draggedItem = null;\n          return;\n        }\n      }\n\n      this.dragClueService.cancelReturnAnimation();\n      this.dragClueService.updateText(this.draggedItem.innerText);\n      this.containerOffset = getContainerOffset(this.draggedItem);\n      this.pendingDragStartEvent = null;\n    }\n\n  }\n\n  DragAndDropDirective.ɵfac = function DragAndDropDirective_Factory(t) {\n    return new (t || DragAndDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TreeViewComponent), i0.ɵɵdirectiveInject(DragClueService), i0.ɵɵdirectiveInject(DropHintService));\n  };\n\n  DragAndDropDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DragAndDropDirective,\n    selectors: [[\"\", \"kendoTreeViewDragAndDrop\", \"\"]],\n    contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"user-select\", ctx.userSelectStyle)(\"-ms-user-select\", ctx.userSelectStyle)(\"-moz-user-select\", ctx.userSelectStyle)(\"-webkit-user-select\", ctx.userSelectStyle);\n      }\n    },\n    inputs: {\n      allowCopy: \"allowCopy\",\n      dropZoneTreeViews: \"dropZoneTreeViews\",\n      startDragAfter: \"startDragAfter\",\n      autoScroll: \"autoScroll\"\n    },\n    features: [i0.ɵɵProvidersFeature([DragClueService, DropHintService])]\n  });\n  return DragAndDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst indexBuilder$1 = new IndexBuilderService();\n\nconst mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of child nodes.\n */\n\n\nlet HierarchyBindingDirective = /*#__PURE__*/(() => {\n  class HierarchyBindingDirective extends FilteringBase {\n    constructor(component, dragAndDropDirective) {\n      super(component);\n      this.component = component;\n      this.dragAndDropDirective = dragAndDropDirective;\n      /**\n       * @hidden\n       */\n\n      this.loadOnDemand = true;\n      this.originalData = [];\n      const shouldFilter = !isPresent(this.dragAndDropDirective);\n      this.component.isVisible = shouldFilter ? node => this.visibleNodes.has(node) : isVisible;\n    }\n    /**\n     * The field name which holds the data items of the child component.\n     */\n\n\n    set childrenField(value) {\n      if (!value) {\n        throw new Error(\"'childrenField' cannot be empty\");\n      }\n\n      this._childrenField = value;\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n\n\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * The field name which holds the data items of the child component.\n     */\n\n\n    get childrenField() {\n      return this._childrenField;\n    }\n\n    ngOnInit() {\n      if (isPresent(this.childrenField)) {\n        this.component.children = item => of(getter(this.childrenField)(item));\n\n        this.component.hasChildren = item => {\n          const children = getter(this.childrenField)(item);\n          return Boolean(children && children.length);\n        };\n\n        this.component.editService = new HierarchyEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('childrenField', changes, false)) {\n        this.nodes = this.originalData;\n        this.updateNodes(this.originalData);\n      }\n\n      if (isChanged('nodes', changes, false)) {\n        this.updateNodes(changes.nodes.currentValue);\n      } // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    updateNodes(values) {\n      this.originalData = values || [];\n      this.filterData = mapToWrappers(values, this.childrenField) || [];\n      this.updateVisibleNodes(this.filterData);\n    }\n\n  }\n\n  HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) {\n    return new (t || HierarchyBindingDirective)(i0.ɵɵdirectiveInject(DataBoundComponent), i0.ɵɵdirectiveInject(DragAndDropDirective, 9));\n  };\n\n  HierarchyBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: HierarchyBindingDirective,\n    selectors: [[\"\", \"kendoTreeViewHierarchyBinding\", \"\"]],\n    inputs: {\n      childrenField: \"childrenField\",\n      nodes: \"nodes\",\n      isVisible: \"isVisible\",\n      loadOnDemand: \"loadOnDemand\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return HierarchyBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * Performs the right-to-left function composition. Functions must have a unary.\n */\n\n\nconst compose = (...args) => data => args.reduceRight((acc, curr) => curr(acc), data);\n/**\n * @hidden\n */\n\n\nclass FlatEditingService {\n  constructor(flatBinding) {\n    this.flatBinding = flatBinding;\n  }\n\n  add({\n    sourceItem,\n    destinationItem,\n    dropPosition,\n    sourceTree,\n    destinationTree\n  }) {\n    // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position\n    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));\n\n    if (dropPosition === DropPosition.Over) {\n      // expand the item that was dropped into\n      expandDropTarget(destinationItem, destinationTree);\n      const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);\n      const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem)); // insert after the last visible child\n\n      const targetIndex = lastChildNodeIndex + 1;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem); // rebind the treeview data before searching for the focus target index\n\n      this.rebindData();\n      const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);\n    } else {\n      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;\n      const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;\n      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);\n      const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));\n      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId); // rebind the treeview data before searching for the focus target index\n\n      this.rebindData();\n      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;\n      const parentContainer = destinationItem.parent ? this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) : destinationTree.nodes;\n      const focusTarget = parentContainer.indexOf(clonedSourceDataItem);\n      this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);\n    }\n\n    if (sourceTree !== destinationTree) {\n      this.addChildNodes(clonedSourceDataItem, sourceTree);\n    } // increment the parent page size => an item is moved into it\n\n\n    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);\n    incrementPageSize(destinationTree, updatedParent); // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference\n\n    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem); // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different\n\n    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {\n      destinationTree.preloadChildNodes();\n    } // if the source and destination trees are the same, focusing the moved item here will not have the desired effect\n    // as the `remove` handler has not yet kicked-in to remove the item from its old position\n\n\n    if (sourceTree !== destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges();\n      destinationTree.focus(this.movedItemNewIndex);\n    }\n  }\n\n  remove({\n    sourceItem,\n    sourceTree,\n    destinationTree\n  }) {\n    const sourceDataItem = getDataItem(sourceItem);\n    const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);\n    this.flatBinding.originalData.splice(sourceItemIndex, 1);\n\n    if (sourceTree !== destinationTree) {\n      this.removeChildNodes(sourceDataItem, sourceTree);\n    }\n\n    this.rebindData(); // emit collapse for the parent node if its last child node was spliced\n\n    const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];\n    collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree); // decrement source item parent page size => an item has been removed from it\n\n    decrementPageSize(sourceTree, getDataItem(sourceItem.parent)); // reload the treeview nodes\n\n    if (!sourceTree.loadOnDemand) {\n      sourceTree.preloadChildNodes();\n    } // if the source and destination trees are different we want to focus only the moved item in the destination tree\n\n\n    if (sourceTree === destinationTree) {\n      // ensure the focus target is rendered and registered\n      destinationTree.changeDetectorRef.detectChanges(); // after the source item is removed from its original position, the candidate index might have to be corrected\n\n      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);\n      destinationTree.focus(index);\n    }\n  }\n\n  addChildNodes(dataItem, source) {\n    const itemChildren = this.fetchAllDescendantNodes(dataItem, source);\n    this.flatBinding.originalData.push(...itemChildren);\n  }\n\n  removeChildNodes(dataItem, source) {\n    const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);\n    sourceChildren.forEach(item => {\n      const index = this.flatBinding.originalData.indexOf(item);\n      this.flatBinding.originalData.splice(index, 1);\n    });\n  }\n\n  fetchAllDescendantNodes(node, treeview) {\n    let nodes = this.fetchChildNodes(node, treeview);\n    nodes.forEach(node => nodes = nodes.concat(this.fetchAllDescendantNodes(node, treeview) || []));\n    return nodes;\n  }\n\n  fetchChildNodes(node, treeview) {\n    if (!node) {\n      return [];\n    }\n\n    let nodes = [];\n    treeview.children(node).pipe(take(1)).subscribe(children => nodes = nodes.concat(children || []));\n    return nodes;\n  }\n\n  getLastVisibleChildNodeIndex(treeview, data, node) {\n    if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {\n      return data.length;\n    }\n\n    const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);\n    const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);\n    const lastNode = visibleChildren[visibleChildren.length - 1];\n    const lastNodeIndex = data.indexOf(lastNode);\n    return lastNodeIndex;\n  }\n\n  rebindData() {\n    this.flatBinding.nodes = this.flatBinding.originalData;\n    this.flatBinding.updateNodes(this.flatBinding.originalData);\n  }\n\n}\n\nconst findChildren = (prop, nodes, value) => nodes.filter(x => prop(x) === value);\n\nconst indexBuilder = new IndexBuilderService();\n\nconst mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = '') => {\n  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {\n    return [];\n  }\n\n  return currentLevelNodes.map((node, idx) => {\n    const index = indexBuilder.nodeIndex(idx.toString(), parentIndex);\n    const wrapper = {\n      dataItem: node,\n      index,\n      parent,\n      visible: true\n    };\n    wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);\n    return wrapper;\n  });\n};\n/**\n * A directive which encapsulates the retrieval of the child nodes.\n */\n\n\nlet FlatDataBindingDirective = /*#__PURE__*/(() => {\n  class FlatDataBindingDirective extends FilteringBase {\n    constructor(component) {\n      super(component);\n      this.component = component;\n      /**\n       * @hidden\n       */\n\n      this.loadOnDemand = true;\n      /**\n       * @hidden\n       */\n\n      this.originalData = [];\n\n      this.component.isVisible = node => this.visibleNodes.has(node);\n    }\n    /**\n     * @hidden\n     * A callback which determines whether a TreeView node should be rendered as hidden.\n     */\n\n\n    set isVisible(fn) {\n      this.component.isVisible = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      if (isPresent(this.parentIdField) && isPresent(this.idField)) {\n        const fetchChildren = node => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));\n\n        this.component.hasChildren = node => fetchChildren(node).length > 0;\n\n        this.component.children = node => of(fetchChildren(node));\n\n        this.component.editService = new FlatEditingService(this);\n        this.component.filterChange.subscribe(this.handleFilterChange.bind(this));\n\n        if (this.component.filter) {\n          this.handleFilterChange(this.component.filter);\n        }\n\n        if (!this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n          this.component.preloadChildNodes();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (isChanged('parentIdField', changes, false)) {\n        this.nodes = this.originalData;\n        this.updateNodes(this.originalData);\n      }\n\n      if (isChanged('nodes', changes, false)) {\n        this.updateNodes(changes.nodes.currentValue);\n      } // should react to changes.loadOnDemand as well - should preload the data or clear the already cached items\n\n\n      if (anyChanged(['nodes', 'loadOnDemand'], changes) && !this.loadOnDemand && isPresent(this.component.preloadChildNodes)) {\n        this.component.preloadChildNodes();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    updateNodes(values) {\n      this.originalData = values || [];\n\n      if (!isNullOrEmptyString(this.parentIdField)) {\n        const prop = getter(this.parentIdField);\n        this.component.nodes = this.originalData.filter(compose(isBlank, prop));\n        this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);\n        this.updateVisibleNodes(this.filterData);\n      } else {\n        this.component.nodes = this.originalData.slice(0);\n      }\n    }\n\n  }\n\n  FlatDataBindingDirective.ɵfac = function FlatDataBindingDirective_Factory(t) {\n    return new (t || FlatDataBindingDirective)(i0.ɵɵdirectiveInject(DataBoundComponent));\n  };\n\n  FlatDataBindingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FlatDataBindingDirective,\n    selectors: [[\"\", \"kendoTreeViewFlatDataBinding\", \"\"]],\n    inputs: {\n      nodes: \"nodes\",\n      parentIdField: \"parentIdField\",\n      idField: \"idField\",\n      loadOnDemand: \"loadOnDemand\",\n      isVisible: \"isVisible\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return FlatDataBindingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES$1 = [CheckBoxComponent];\n/**\n * @hidden\n *\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.\n */\n\nlet CheckBoxModule = /*#__PURE__*/(() => {\n  class CheckBoxModule {}\n\n  CheckBoxModule.ɵfac = function CheckBoxModule_Factory(t) {\n    return new (t || CheckBoxModule)();\n  };\n\n  CheckBoxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CheckBoxModule\n  });\n  CheckBoxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return CheckBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive which enables the update of the initially provided data array during drag-and-drop.\n *\n * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})\n * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide\n * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the\n * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)\n * handlers when the corresponding events are triggered by the TreeView component.\n */\n\n\nlet DragAndDropEditingDirective = /*#__PURE__*/(() => {\n  class DragAndDropEditingDirective {\n    constructor(treeview) {\n      this.treeview = treeview;\n      this.subscriptions = new Subscription();\n      this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));\n      this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));\n    }\n    /**\n     * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)\n     * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.\n     */\n\n\n    set editService(service) {\n      this.treeview.editService = service;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n\n    handleAdd(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n\n      this.treeview.editService.add(args);\n    }\n\n    handleRemove(args) {\n      if (!isPresent(this.treeview.editService)) {\n        throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');\n      }\n\n      this.treeview.editService.remove(args);\n    }\n\n  }\n\n  DragAndDropEditingDirective.ɵfac = function DragAndDropEditingDirective_Factory(t) {\n    return new (t || DragAndDropEditingDirective)(i0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  DragAndDropEditingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DragAndDropEditingDirective,\n    selectors: [[\"\", \"kendoTreeViewDragAndDropEditing\", \"\"]],\n    inputs: {\n      editService: \"editService\"\n    }\n  });\n  return DragAndDropEditingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LOAD_MORE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';\n/**\n * A directive that enables the display of only a limited amount of nodes per level\n * ([see example]({% slug loadmorebutton_treeview %})).\n */\n\nlet LoadMoreDirective = /*#__PURE__*/(() => {\n  class LoadMoreDirective {\n    constructor(treeview) {\n      this.treeview = treeview;\n      /**\n       * Keeps track of the current page size of each node over expand/collapse cycles.\n       */\n\n      this.pageSizes = new Map();\n      /**\n       * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.\n       */\n\n      this.rootLevelId = guid();\n      this.treeview.loadMoreService = {\n        getInitialPageSize: this.getInitalPageSize.bind(this),\n        getGroupSize: this.getGroupSize.bind(this),\n        setGroupSize: this.setGroupSize.bind(this),\n        getTotalNodesCount: this.getTotalNodesCount.bind(this)\n      };\n    }\n    /**\n     * Specifies the callback that will be called when the load more button is clicked.\n     * Providing a function is only required when additional nodes are fetched on demand\n     * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).\n     */\n\n\n    set loadMoreNodes(loadMoreNodes) {\n      if (typeof loadMoreNodes === 'string') {\n        return;\n      }\n\n      this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;\n    }\n\n    ngOnChanges() {\n      this.verifySettings();\n    }\n\n    verifySettings() {\n      if (!isDevMode()) {\n        return;\n      }\n\n      if (!isPresent(this.pageSize)) {\n        throw new Error(`To use the TreeView \\`kendoTreeViewLoadMore\\` directive, you need to assign a \\`pageSize\\` value. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n\n      const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;\n\n      if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {\n        throw new Error(`The passed value to the \\`kendoTreeViewLoadMore\\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n\n      if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {\n        throw new Error(`When a function to fetch additional nodes is provided to the \\`kendoTreeViewLoadMore\\` directive, the \\`totalField\\` and \\`totalRootNodes\\` values must also be provided. See ${LOAD_MORE_DOC_LINK}.`);\n      }\n    }\n\n    getGroupSize(dataItem) {\n      const itemKey = dataItem || this.rootLevelId;\n      return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;\n    }\n\n    setGroupSize(dataItem, pageSize) {\n      const itemKey = dataItem || this.rootLevelId;\n      const normalizedSizeValue = pageSize > 0 ? pageSize : 0;\n      this.pageSizes.set(itemKey, normalizedSizeValue);\n    }\n\n    getTotalNodesCount(dataItem, loadedNodesCount) {\n      if (isPresent(dataItem) && isPresent(this.totalField)) {\n        return dataItem[this.totalField];\n      } else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {\n        return this.totalRootNodes;\n      } else {\n        return loadedNodesCount;\n      }\n    }\n\n    getInitalPageSize() {\n      return this.pageSize;\n    }\n\n  }\n\n  LoadMoreDirective.ɵfac = function LoadMoreDirective_Factory(t) {\n    return new (t || LoadMoreDirective)(i0.ɵɵdirectiveInject(TreeViewComponent));\n  };\n\n  LoadMoreDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LoadMoreDirective,\n    selectors: [[\"\", \"kendoTreeViewLoadMore\", \"\"]],\n    inputs: {\n      loadMoreNodes: [\"kendoTreeViewLoadMore\", \"loadMoreNodes\"],\n      pageSize: \"pageSize\",\n      totalRootNodes: \"totalRootNodes\",\n      totalField: \"totalField\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LoadMoreDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [TreeViewComponent, TreeViewGroupComponent, TreeViewItemDirective, TreeViewItemContentDirective, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, LoadingIndicatorDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DragClueComponent, DropHintTemplateDirective, DropHintComponent, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n/**\n * @hidden\n */\n\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {}\n\n  SharedModule.ɵfac = function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  };\n\n  SharedModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SharedModule\n  });\n  SharedModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, CheckBoxModule, InputsModule]]\n  });\n  return SharedModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EXPORTS = [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.\n */\n\nlet TreeViewModule = /*#__PURE__*/(() => {\n  class TreeViewModule {}\n\n  TreeViewModule.ɵfac = function TreeViewModule_Factory(t) {\n    return new (t || TreeViewModule)();\n  };\n\n  TreeViewModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TreeViewModule\n  });\n  TreeViewModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[SharedModule]]\n  });\n  return TreeViewModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CheckDirective, DataBoundComponent, DisableDirective, DragAndDropDirective, DragAndDropEditingDirective, DragClueService, DragClueTemplateDirective, DropAction, DropHintService, DropHintTemplateDirective, DropPosition, ExpandDirective, ExpandableComponent, FlatDataBindingDirective, HierarchyBindingDirective, LoadMoreButtonTemplateDirective, LoadMoreDirective, NodeTemplateDirective, SelectDirective, TreeItemDragEvent, TreeItemDragStartEvent, TreeItemDropEvent, TreeViewComponent, TreeViewModule };","map":null,"metadata":{},"sourceType":"module"}