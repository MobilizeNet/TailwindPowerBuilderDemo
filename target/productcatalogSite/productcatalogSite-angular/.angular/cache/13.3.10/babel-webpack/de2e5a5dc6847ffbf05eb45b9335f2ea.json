{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, NgModule, Injectable, Component } from '@angular/core';\nimport Draggable from '@telerik/kendo-draggable';\nimport { CommonModule } from '@angular/common';\nimport { auditTime } from 'rxjs/operators';\nimport { merge, fromEvent, from } from 'rxjs';\n/**\n * @hidden\n */\n\nconst isDocumentAvailable = () => typeof document !== 'undefined';\n/**\n * @hidden\n */\n\n\nconst isChanged = (propertyName, changes, skipFirstChange = true) => typeof changes[propertyName] !== 'undefined' && (!changes[propertyName].isFirstChange() || !skipFirstChange) && changes[propertyName].previousValue !== changes[propertyName].currentValue;\n/**\n * @hidden\n */\n\n\nconst anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));\n/**\n * @hidden\n */\n\n\nconst hasObservers = emitter => emitter && emitter.observers.length > 0;\n/**\n * @hidden\n */\n\n\nconst guid = () => {\n  let id = \"\";\n\n  for (let i = 0; i < 32; i++) {\n    const random = Math.random() * 16 | 0; // eslint-disable-line no-bitwise\n\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      id += \"-\";\n    } // eslint-disable-next-line no-bitwise\n\n\n    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n  }\n\n  return id;\n};\n\nlet DraggableDirective = /*#__PURE__*/(() => {\n  class DraggableDirective {\n    constructor(element, ngZone) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.enableDrag = true;\n      this.kendoPress = new EventEmitter();\n      this.kendoDrag = new EventEmitter();\n      this.kendoRelease = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.toggleDraggable();\n    }\n\n    ngOnChanges(changes) {\n      if (isChanged('enableDrag', changes)) {\n        this.toggleDraggable();\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyDraggable();\n    }\n\n    toggleDraggable() {\n      if (isDocumentAvailable()) {\n        this.destroyDraggable();\n\n        if (this.enableDrag) {\n          this.draggable = new Draggable({\n            drag: e => this.kendoDrag.next(e),\n            press: e => this.kendoPress.next(e),\n            release: e => this.kendoRelease.next(e)\n          });\n          this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n        }\n      }\n    }\n\n    destroyDraggable() {\n      if (this.draggable) {\n        this.draggable.destroy();\n        this.draggable = null;\n      }\n    }\n\n  }\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  DraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"kendoDraggable\", \"\"]],\n    inputs: {\n      enableDrag: \"enableDrag\"\n    },\n    outputs: {\n      kendoPress: \"kendoPress\",\n      kendoDrag: \"kendoDrag\",\n      kendoRelease: \"kendoRelease\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DraggableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet DraggableModule = /*#__PURE__*/(() => {\n  class DraggableModule {}\n\n  DraggableModule.ɵfac = function DraggableModule_Factory(t) {\n    return new (t || DraggableModule)();\n  };\n\n  DraggableModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DraggableModule\n  });\n  DraggableModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return DraggableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst closestInScope = (node, predicate, scope) => {\n  while (node && node !== scope && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  if (node !== scope) {\n    return node;\n  }\n};\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n\nconst contains = (parent, node, matchSelf = false) => {\n  const outside = !closest(node, child => child === parent);\n\n  if (outside) {\n    return false;\n  }\n\n  const el = closest(node, child => child === node);\n  return el && (matchSelf || el !== parent);\n};\n\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n\n  node = node.firstChild;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n\n      if (element) {\n        return element;\n      }\n    }\n\n    node = node.nextSibling;\n  }\n};\n\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\n\nconst isFocusable = element => {\n  if (!element.tagName) {\n    return false;\n  }\n\n  const tagName = element.tagName.toLowerCase();\n  const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n  const focusable = !element.disabled && focusableRegex.test(tagName);\n  return focusable || hasTabIndex;\n};\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0; // Elements can have zero size due to styling, but they will still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n  if (!isFocusable(element)) {\n    return false;\n  }\n\n  const tabIndex = element.getAttribute('tabIndex');\n  const visible = !checkVisibility || isVisible(element);\n  return visible && tabIndex !== '-1';\n};\n\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility), false);\n};\n\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusableWithTabKey(node, checkVisibility));\n};\n\nconst toClassList = classNames => String(classNames).trim().split(' ');\n\nconst hasClasses = (element, classNames) => {\n  const namesList = toClassList(classNames);\n  return Boolean(toClassList(element.className).find(className => namesList.indexOf(className) >= 0));\n};\n\nconst matchesClasses = classNames => element => hasClasses(element, classNames);\n\nconst NODE_NAME_PREDICATES = {};\n\nconst matchesNodeName = nodeName => {\n  if (!NODE_NAME_PREDICATES[nodeName]) {\n    NODE_NAME_PREDICATES[nodeName] = element => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n  }\n\n  return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * Normalizes a scroll position value in RTL mode.\n */\n\n\nfunction rtlScrollPosition(position, element, initial) {\n  let result = position;\n\n  if (initial < 0) {\n    result = -position;\n  } else if (initial > 0) {\n    result = element.scrollWidth - element.offsetWidth - position;\n  }\n\n  return result;\n}\n/**\n * @hidden\n */\n\n\nlet EventsOutsideAngularDirective = /*#__PURE__*/(() => {\n  class EventsOutsideAngularDirective {\n    constructor(element, ngZone, renderer) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.events = {};\n    }\n\n    ngOnInit() {\n      if (!this.element || !this.element.nativeElement) {\n        return;\n      }\n\n      const events = this.events;\n      this.subscriptions = [];\n      this.ngZone.runOutsideAngular(() => {\n        for (let name in events) {\n          if (events.hasOwnProperty(name)) {\n            this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));\n          }\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscriptions) {\n        for (let idx = 0; idx < this.subscriptions.length; idx++) {\n          this.subscriptions[idx]();\n        }\n\n        this.subscriptions = null;\n      }\n    }\n\n  }\n\n  EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) {\n    return new (t || EventsOutsideAngularDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  EventsOutsideAngularDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: EventsOutsideAngularDirective,\n    selectors: [[\"\", \"kendoEventsOutsideAngular\", \"\"]],\n    inputs: {\n      events: [\"kendoEventsOutsideAngular\", \"events\"],\n      scope: \"scope\"\n    }\n  });\n  return EventsOutsideAngularDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet EventsModule = /*#__PURE__*/(() => {\n  class EventsModule {}\n\n  EventsModule.ɵfac = function EventsModule_Factory(t) {\n    return new (t || EventsModule)();\n  };\n\n  EventsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: EventsModule\n  });\n  EventsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return EventsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass ResizeService {\n  constructor(resizeBatchService) {\n    this.resizeBatchService = resizeBatchService;\n    this.resize = new EventEmitter();\n    this.acceptedSize = false;\n    this.state = 0\n    /* Initial */\n    ;\n  }\n\n  acceptSize(size = this.measure()) {\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n    this.acceptedSize = true;\n  }\n\n  checkChanges() {\n    if (!isDocumentAvailable()) {\n      return;\n    }\n\n    if (this.state === 0\n    /* Initial */\n    ) {\n      this.state = 1\n      /* Initializing */\n      ; // batch initial measure\n\n      this.resizeBatchService.schedule(this, this.init);\n    }\n  }\n\n  destroy() {\n    this.resizeBatchService.cancel(this);\n  }\n\n  checkSize() {\n    if (!this.parentElement) {\n      return;\n    }\n\n    const {\n      width,\n      height\n    } = this.measure();\n    const sameSize = width === this.lastWidth && height === this.lastHeight;\n\n    if (sameSize) {\n      return;\n    }\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n    this.acceptedSize = false;\n    this.resize.emit();\n    return true;\n  }\n\n  initSize() {\n    const size = this.measure();\n    this.lastWidth = size.width;\n    this.lastHeight = size.height;\n  }\n\n  measure() {\n    let width = 0;\n    let height = 0;\n\n    if (this.parentElement) {\n      height = this.parentElement.offsetHeight;\n      width = this.parentElement.offsetWidth;\n    }\n\n    return {\n      height,\n      width\n    };\n  }\n\n} // eslint-disable import/no-deprecated\n\n\nconst div = style => {\n  const el = document.createElement('div');\n  el.style.cssText = style;\n  return el;\n};\n\nconst computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);\n\nconst WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' + 'overflow: hidden; visibility: hidden;';\nconst EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';\nconst SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';\n\nclass ResizeCompatService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  checkChanges() {\n    if (this.state === 2\n    /* Initialized */\n    ) {\n      if (!this.resizeBatchService.isScheduled(this)) {\n        this.resizeBatchService.schedule(this, this.checkSize);\n      }\n\n      return;\n    }\n\n    super.checkChanges();\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    if (this.expand) {\n      const element = this.element.nativeElement;\n      element.removeChild(this.expand);\n      element.removeChild(this.shrink);\n      this.expand.removeChild(this.expandChild);\n      this.expand = this.expandChild = this.shrink = this.element = null;\n    }\n  }\n\n  checkSize() {\n    if (super.checkSize()) {\n      this.reset();\n      return true;\n    }\n  }\n\n  init() {\n    const parentElement = this.parentElement = this.element.nativeElement.parentElement;\n\n    if (computedProp(parentElement, 'position') === 'static') {\n      parentElement.style.position = 'relative';\n    }\n\n    this.state = 2\n    /* Initialized */\n    ;\n    this.render();\n    this.reset();\n    this.initSize();\n    this.subscribe();\n  }\n\n  render() {\n    const element = this.element.nativeElement;\n    element.style.cssText = WRAP_STYLE;\n    element.setAttribute('dir', 'ltr');\n    this.expand = div(WRAP_STYLE);\n    this.expandChild = div(EXPAND_CHILD_STYLE);\n    this.expand.appendChild(this.expandChild);\n    element.appendChild(this.expand);\n    this.shrink = div(WRAP_STYLE);\n    const shrinkChild = div(SHRINK_CHILD_STYLE);\n    this.shrink.appendChild(shrinkChild);\n    element.appendChild(this.shrink);\n  }\n\n  reset() {\n    const expandChild = this.expandChild;\n    expandChild.style.width = 100000 + 'px';\n    expandChild.style.height = 100000 + 'px';\n    const expand = this.expand;\n    expand.scrollLeft = 100000;\n    expand.scrollTop = 100000;\n    const shrink = this.shrink;\n    shrink.scrollLeft = 100000;\n    shrink.scrollTop = 100000;\n  }\n\n  subscribe() {\n    this.ngZone.runOutsideAngular(() => {\n      this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll')).subscribe(() => {\n        this.checkSize();\n      });\n    });\n  }\n\n}\n\nconst HAS_OBSERVER = typeof ResizeObserver !== 'undefined';\n/**\n * @hidden\n */\n\nclass ResizeObserverService extends ResizeService {\n  constructor(resizeBatchService, element, ngZone) {\n    super(resizeBatchService);\n    this.element = element;\n    this.ngZone = ngZone;\n  }\n\n  static supported() {\n    return HAS_OBSERVER;\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    this.parentElement = null;\n  }\n\n  init() {\n    this.parentElement = this.element.nativeElement.parentElement;\n    this.initSize();\n    this.state = 2\n    /* Initialized */\n    ;\n    this.ngZone.runOutsideAngular(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        this.checkSize();\n      });\n      this.resizeObserver.observe(this.parentElement);\n    });\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet ResizeBatchService = /*#__PURE__*/(() => {\n  class ResizeBatchService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.scheduled = [];\n      this.resolvedPromise = Promise.resolve(null);\n      this.flush = this.flush.bind(this);\n    }\n\n    schedule(instance, method) {\n      this.scheduled.push({\n        instance,\n        method\n      });\n\n      if (!this.subscription) {\n        this.ngZone.runOutsideAngular(() => {\n          this.subscription = from(this.resolvedPromise).subscribe(this.flush);\n        });\n      }\n    }\n\n    isScheduled(instance) {\n      return Boolean(this.scheduled.find(item => item.instance === instance));\n    }\n\n    cancel(instance) {\n      const scheduled = this.scheduled;\n      const count = scheduled.length;\n\n      for (let idx = 0; idx < count; idx++) {\n        if (scheduled[idx].instance === instance) {\n          scheduled.splice(idx, 1);\n\n          if (!scheduled.length) {\n            this.unsubscribe();\n          }\n\n          return;\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n\n    unsubscribe() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        this.subscription = null;\n      }\n    }\n\n    flush() {\n      this.scheduled.forEach(item => {\n        item.method.call(item.instance);\n      });\n      this.scheduled = [];\n      this.unsubscribe();\n    }\n\n  }\n\n  ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) {\n    return new (t || ResizeBatchService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  ResizeBatchService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResizeBatchService,\n    factory: ResizeBatchService.ɵfac\n  });\n  return ResizeBatchService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Emit up to 10 resize events per second by default.\n * Chosen as a compromise between responsiveness and performance.\n */\n\n\nconst DEFAULT_RATE_LIMIT = 10;\n/**\n * Resize Sensor Component\n *\n * Triggers a \"resize\" event whenever the parent DOM element size changes.\n */\n\nlet ResizeSensorComponent = /*#__PURE__*/(() => {\n  class ResizeSensorComponent {\n    constructor(resizeBatchService, element, ngZone) {\n      /**\n       * The maximum number of resize events to emit per second.\n       *\n       * Defaults to 10.\n       */\n      this.rateLimit = DEFAULT_RATE_LIMIT;\n      /**\n       * Fires when the parent DOM element has been resized.\n       */\n\n      this.resize = new EventEmitter();\n      const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;\n      this.resizeService = new serviceType(resizeBatchService, element, ngZone);\n      const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);\n      this.subscription = this.resizeService.resize.pipe(auditTime(throttleTime)).subscribe(() => {\n        if (!this.resizeService.acceptedSize) {\n          this.resize.emit();\n        }\n      });\n    }\n\n    ngAfterViewChecked() {\n      this.resizeService.checkChanges();\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n      this.resizeService.destroy();\n    }\n\n    acceptSize(size) {\n      this.resizeService.acceptSize(size);\n    }\n\n  }\n\n  ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) {\n    return new (t || ResizeSensorComponent)(i0.ɵɵdirectiveInject(ResizeBatchService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  ResizeSensorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ResizeSensorComponent,\n    selectors: [[\"kendo-resize-sensor\"]],\n    inputs: {\n      rateLimit: \"rateLimit\"\n    },\n    outputs: {\n      resize: \"resize\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ResizeSensorComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ResizeSensorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COMPONENT_DIRECTIVES = [ResizeSensorComponent];\n/**\n * Resize Sensor module\n */\n\nlet ResizeSensorModule = /*#__PURE__*/(() => {\n  class ResizeSensorModule {}\n\n  ResizeSensorModule.ɵfac = function ResizeSensorModule_Factory(t) {\n    return new (t || ResizeSensorModule)();\n  };\n\n  ResizeSensorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ResizeSensorModule\n  });\n  ResizeSensorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ResizeBatchService]\n  });\n  return ResizeSensorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass KendoInput {}\n/**\n * Enum with key codes.\n */\n\n\nvar Keys = /*#__PURE__*/(() => {\n  (function (Keys) {\n    Keys[Keys[\"Alt\"] = 18] = \"Alt\";\n    Keys[Keys[\"ArrowDown\"] = 40] = \"ArrowDown\";\n    Keys[Keys[\"ArrowLeft\"] = 37] = \"ArrowLeft\";\n    Keys[Keys[\"ArrowRight\"] = 39] = \"ArrowRight\";\n    Keys[Keys[\"ArrowUp\"] = 38] = \"ArrowUp\";\n    Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\n    Keys[Keys[\"Control\"] = 17] = \"Control\";\n    Keys[Keys[\"Delete\"] = 46] = \"Delete\";\n    Keys[Keys[\"Digit0\"] = 48] = \"Digit0\";\n    Keys[Keys[\"Digit1\"] = 49] = \"Digit1\";\n    Keys[Keys[\"Digit2\"] = 50] = \"Digit2\";\n    Keys[Keys[\"Digit3\"] = 51] = \"Digit3\";\n    Keys[Keys[\"Digit4\"] = 52] = \"Digit4\";\n    Keys[Keys[\"Digit5\"] = 53] = \"Digit5\";\n    Keys[Keys[\"Digit6\"] = 54] = \"Digit6\";\n    Keys[Keys[\"Digit7\"] = 55] = \"Digit7\";\n    Keys[Keys[\"Digit8\"] = 56] = \"Digit8\";\n    Keys[Keys[\"Digit9\"] = 57] = \"Digit9\";\n    Keys[Keys[\"End\"] = 35] = \"End\";\n    Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n    Keys[Keys[\"Escape\"] = 27] = \"Escape\";\n    Keys[Keys[\"F1\"] = 112] = \"F1\";\n    Keys[Keys[\"F2\"] = 113] = \"F2\";\n    Keys[Keys[\"F10\"] = 121] = \"F10\";\n    Keys[Keys[\"Home\"] = 36] = \"Home\";\n    Keys[Keys[\"Insert\"] = 45] = \"Insert\";\n    Keys[Keys[\"KeyA\"] = 65] = \"KeyA\";\n    Keys[Keys[\"KeyB\"] = 66] = \"KeyB\";\n    Keys[Keys[\"KeyC\"] = 67] = \"KeyC\";\n    Keys[Keys[\"KeyD\"] = 68] = \"KeyD\";\n    Keys[Keys[\"KeyE\"] = 69] = \"KeyE\";\n    Keys[Keys[\"KeyF\"] = 70] = \"KeyF\";\n    Keys[Keys[\"KeyG\"] = 71] = \"KeyG\";\n    Keys[Keys[\"KeyH\"] = 72] = \"KeyH\";\n    Keys[Keys[\"KeyI\"] = 73] = \"KeyI\";\n    Keys[Keys[\"KeyJ\"] = 74] = \"KeyJ\";\n    Keys[Keys[\"KeyK\"] = 75] = \"KeyK\";\n    Keys[Keys[\"KeyL\"] = 76] = \"KeyL\";\n    Keys[Keys[\"KeyM\"] = 77] = \"KeyM\";\n    Keys[Keys[\"KeyN\"] = 78] = \"KeyN\";\n    Keys[Keys[\"KeyO\"] = 79] = \"KeyO\";\n    Keys[Keys[\"KeyP\"] = 80] = \"KeyP\";\n    Keys[Keys[\"KeyQ\"] = 81] = \"KeyQ\";\n    Keys[Keys[\"KeyR\"] = 82] = \"KeyR\";\n    Keys[Keys[\"KeyS\"] = 83] = \"KeyS\";\n    Keys[Keys[\"KeyT\"] = 84] = \"KeyT\";\n    Keys[Keys[\"KeyU\"] = 85] = \"KeyU\";\n    Keys[Keys[\"KeyV\"] = 86] = \"KeyV\";\n    Keys[Keys[\"KeyW\"] = 87] = \"KeyW\";\n    Keys[Keys[\"KeyX\"] = 88] = \"KeyX\";\n    Keys[Keys[\"KeyY\"] = 89] = \"KeyY\";\n    Keys[Keys[\"KeyZ\"] = 90] = \"KeyZ\";\n    Keys[Keys[\"NumpadDecimal\"] = 110] = \"NumpadDecimal\";\n    Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n    Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n    Keys[Keys[\"Shift\"] = 16] = \"Shift\";\n    Keys[Keys[\"Space\"] = 32] = \"Space\";\n    Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n  })(Keys || (Keys = {}));\n\n  return Keys;\n})();\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses\n   * the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * Returns `true` if the event was prevented\n   * by any of its subscribers.\n   *\n   * @returns `true` if the default action was prevented.\n   * Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n\nconst canCreateElement = () => isDocumentAvailable() && document.createElement;\n\nconst propName = '--kendo-scrollbar-width';\n\nfunction scrollbarWidth() {\n  let scrollbarWidth = 0;\n\n  if (canCreateElement()) {\n    const div = document.createElement('div');\n    div.style.cssText = 'overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block';\n    div.innerHTML = '&nbsp;';\n    document.body.appendChild(div);\n    scrollbarWidth = div.offsetWidth - div.scrollWidth;\n    document.body.removeChild(div);\n  }\n\n  return scrollbarWidth;\n}\n/**\n * @hidden\n */\n\n\nlet ScrollbarWidthService = /*#__PURE__*/(() => {\n  class ScrollbarWidthService {\n    constructor() {\n      this.changes = new EventEmitter();\n\n      if (typeof window !== 'undefined' && isDocumentAvailable()) {\n        document.body.style.setProperty(propName, `${scrollbarWidth()}px`);\n      }\n    }\n\n  }\n\n  ScrollbarWidthService.ɵfac = function ScrollbarWidthService_Factory(t) {\n    return new (t || ScrollbarWidthService)();\n  };\n\n  ScrollbarWidthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollbarWidthService,\n    factory: ScrollbarWidthService.ɵfac,\n    providedIn: 'root'\n  });\n  return ScrollbarWidthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DraggableDirective, DraggableModule, EventsModule, EventsOutsideAngularDirective, KendoInput, Keys, PreventableEvent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorComponent, ResizeSensorModule, ScrollbarWidthService, anyChanged, closest, closestInScope, contains, findElement, findFocusable, findFocusableChild, guid, hasClasses, hasObservers, isChanged, isDocumentAvailable, isFocusable, isFocusableWithTabKey, isVisible, matchesClasses, matchesNodeName, rtlScrollPosition };","map":null,"metadata":{},"sourceType":"module"}