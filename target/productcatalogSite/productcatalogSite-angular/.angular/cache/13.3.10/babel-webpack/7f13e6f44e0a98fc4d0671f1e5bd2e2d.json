{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport GRADIENTS from './gradients';\nimport Box from './box';\nimport boxDiff from './utils/box-diff';\nimport { DEFAULT_WIDTH, DEFAULT_HEIGHT, WHITE, BLACK } from '../common/constants';\nimport { getSpacing, objectKey, setDefaultOptions } from '../common';\n\nclass RootElement extends ChartElement {\n  constructor(options) {\n    super(options);\n    const rootOptions = this.options;\n    rootOptions.width = parseInt(rootOptions.width, 10);\n    rootOptions.height = parseInt(rootOptions.height, 10);\n    this.gradients = {};\n  }\n\n  reflow() {\n    const {\n      options,\n      children\n    } = this;\n    let currentBox = new Box(0, 0, options.width, options.height);\n    this.box = currentBox.unpad(options.margin);\n\n    for (let i = 0; i < children.length; i++) {\n      children[i].reflow(currentBox);\n      currentBox = boxDiff(currentBox, children[i].box) || new Box();\n    }\n  }\n\n  createVisual() {\n    this.visual = new draw.Group();\n    this.createBackground();\n  }\n\n  createBackground() {\n    const options = this.options;\n    const border = options.border || {};\n    const box = this.box.clone().pad(options.margin).unpad(border.width);\n    const background = draw.Path.fromRect(box.toRect(), {\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      },\n      fill: {\n        color: options.background,\n        opacity: options.opacity\n      },\n      zIndex: -10\n    });\n    this.visual.append(background);\n  }\n\n  getRoot() {\n    return this;\n  }\n\n  createGradient(options) {\n    const gradients = this.gradients;\n    const hashCode = objectKey(options);\n    const gradient = GRADIENTS[options.gradient];\n    let drawingGradient;\n\n    if (gradients[hashCode]) {\n      drawingGradient = gradients[hashCode];\n    } else {\n      const gradientOptions = Object.assign({}, gradient, options);\n\n      if (gradient.type === \"linear\") {\n        drawingGradient = new draw.LinearGradient(gradientOptions);\n      } else {\n        if (options.innerRadius) {\n          gradientOptions.stops = innerRadialStops(gradientOptions);\n        }\n\n        drawingGradient = new draw.RadialGradient(gradientOptions);\n        drawingGradient.supportVML = gradient.supportVML !== false;\n      }\n\n      gradients[hashCode] = drawingGradient;\n    }\n\n    return drawingGradient;\n  }\n\n  cleanGradients() {\n    const gradients = this.gradients;\n\n    for (let hashCode in gradients) {\n      gradients[hashCode]._observers = []; //add clear observers method in drawing ObserversMixin\n    }\n  }\n\n  size() {\n    const options = this.options;\n    return new Box(0, 0, options.width, options.height);\n  }\n\n}\n\nsetDefaultOptions(RootElement, {\n  width: DEFAULT_WIDTH,\n  height: DEFAULT_HEIGHT,\n  background: WHITE,\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  margin: getSpacing(5),\n  zIndex: -2\n});\n\nfunction innerRadialStops(options) {\n  const stops = options.stops;\n  const usedSpace = options.innerRadius / options.radius * 100;\n  const length = stops.length;\n  const currentStops = [];\n\n  for (let i = 0; i < length; i++) {\n    let currentStop = Object.assign({}, stops[i]);\n    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n    currentStops.push(currentStop);\n  }\n\n  return currentStops;\n}\n\nexport default RootElement;","map":null,"metadata":{},"sourceType":"module"}