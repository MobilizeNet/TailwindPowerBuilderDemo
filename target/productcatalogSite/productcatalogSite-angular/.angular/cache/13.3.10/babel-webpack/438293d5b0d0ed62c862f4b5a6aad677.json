{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1001);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  997:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./formatblock\");\n    /***/\n  },\n\n  /***/\n  1001:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(997)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            extend = $.extend,\n            editorNS = kendo.ui.editor,\n            dom = editorNS.Dom,\n            Command = editorNS.Command,\n            Tool = editorNS.Tool,\n            BlockFormatter = editorNS.BlockFormatter,\n            normalize = dom.normalize,\n            RangeUtils = editorNS.RangeUtils,\n            registerTool = editorNS.EditorUtils.registerTool;\n        var ParagraphCommand = Command.extend({\n          init: function (options) {\n            this.options = options;\n            Command.fn.init.call(this, options);\n          },\n          _insertMarker: function (doc, range) {\n            var marker = dom.create(doc, 'a'),\n                container;\n            marker.className = \"k-marker\";\n            range.insertNode(marker);\n\n            if (!marker.parentNode) {\n              // inserting paragraph in Firefox full body range\n              container = range.commonAncestorContainer;\n              container.innerHTML = \"\";\n              container.appendChild(marker);\n            }\n\n            normalize(marker.parentNode);\n            return marker;\n          },\n          _moveFocus: function (range, candidate) {\n            if (dom.isEmpty(candidate)) {\n              range.setStartBefore(candidate);\n            } else {\n              range.selectNodeContents(candidate);\n              var focusNode = RangeUtils.textNodes(range)[0];\n\n              if (!focusNode) {\n                while (candidate.childNodes.length && !dom.is(candidate.firstChild, \"br\")) {\n                  candidate = candidate.firstChild;\n                }\n\n                focusNode = candidate;\n              }\n\n              if (dom.isEmpty(focusNode)) {\n                range.setStartBefore(focusNode);\n              } else {\n                if (dom.emptyNode(focusNode)) {\n                  focusNode.innerHTML = \"\\ufeff\";\n                }\n\n                var startNode = focusNode.firstChild || focusNode;\n\n                if (dom.isDataNode(startNode)) {\n                  range.setStart(startNode, 0);\n                } else {\n                  range.setStartBefore(startNode);\n                }\n              }\n            }\n          },\n          shouldTrim: function (range) {\n            var blocks = 'p,h1,h2,h3,h4,h5,h6'.split(','),\n                startInBlock = dom.parentOfType(range.startContainer, blocks),\n                endInBlock = dom.parentOfType(range.endContainer, blocks);\n            return startInBlock && !endInBlock || !startInBlock && endInBlock;\n          },\n          _blankAfter: function (node) {\n            while (node && (dom.isMarker(node) || dom.stripBom(node.nodeValue) === \"\")) {\n              node = node.nextSibling;\n            }\n\n            return !node;\n          },\n          exec: function () {\n            var range = this.getRange(),\n                doc = RangeUtils.documentFromRange(range),\n                parent,\n                previous,\n                next,\n                emptyParagraphContent = editorNS.emptyElementContent,\n                paragraph,\n                marker,\n                li,\n                heading,\n                tableNode,\n                rng,\n                shouldTrim;\n            this.expandImmutablesIn(range);\n            shouldTrim = this.shouldTrim(range);\n            range.deleteContents();\n            marker = this._insertMarker(doc, range);\n            dom.stripBomNode(marker.previousSibling);\n            dom.stripBomNode(marker.nextSibling);\n            li = dom.closestEditableOfType(marker, ['li']);\n            heading = dom.closestEditableOfType(marker, 'h1,h2,h3,h4,h5,h6'.split(','));\n            tableNode = dom.is(marker.parentNode, 'table') && marker.parentNode;\n\n            if (li) {\n              // hitting 'enter' in empty li\n              if (dom.emptyNode(li)) {\n                paragraph = dom.create(doc, 'p');\n\n                if (dom.next(li)) {\n                  rng = range.cloneRange();\n                  rng.selectNode(li);\n                  RangeUtils.split(rng, li.parentNode);\n                }\n\n                var br = $(\"br\", li);\n\n                if (br.length == 1) {\n                  br.remove();\n                }\n\n                var parentNode = li.parentNode;\n                var parentChildrenLength = li.parentNode.children.length;\n                var firstChild = parentChildrenLength > 1 && li.childNodes.length == 1 && li.children[0];\n                dom.insertAfter(paragraph, parentNode);\n                dom.remove(parentChildrenLength == 1 ? li.parentNode : li);\n\n                if (firstChild && firstChild !== marker) {\n                  paragraph.appendChild(firstChild);\n                  paragraph.appendChild(marker);\n                } else {\n                  paragraph.innerHTML = emptyParagraphContent;\n                }\n\n                next = paragraph;\n              }\n            } else if (heading && this._blankAfter(marker)) {\n              paragraph = this._insertParagraphAfter(heading);\n              dom.remove(marker);\n              next = paragraph;\n            } else if (tableNode) {\n              paragraph = this._insertParagraphAfter(tableNode);\n              dom.remove(marker);\n              next = paragraph;\n            }\n\n            if (!next) {\n              if (!(li || heading)) {\n                new BlockFormatter([{\n                  tags: ['p']\n                }]).apply([marker]);\n              }\n\n              range.selectNode(marker);\n              parent = dom.parentOfType(marker, [li ? 'li' : heading ? dom.name(heading) : 'p']);\n              RangeUtils.split(range, parent, shouldTrim);\n              previous = parent.previousSibling;\n\n              if (dom.is(previous, 'li') && previous.firstChild && !dom.is(previous.firstChild, 'br')) {\n                previous = previous.firstChild;\n              }\n\n              next = parent.nextSibling;\n              this.clean(previous, {\n                links: true\n              });\n              this.clean(next, {\n                links: true\n              });\n\n              if (dom.is(next, 'li') && next.firstChild && !dom.is(next.firstChild, 'br')) {\n                next = next.firstChild;\n              }\n\n              dom.remove(parent); // normalize updates the caret display in Gecko\n\n              normalize(previous);\n            }\n\n            normalize(next);\n\n            this._moveFocus(range, next);\n\n            range.collapse(true);\n            dom.scrollTo(next, true);\n            RangeUtils.selectRange(range);\n          },\n          _insertParagraphAfter: function (node) {\n            var range = this.getRange();\n            var doc = RangeUtils.documentFromRange(range);\n            var emptyElementContent = editorNS.emptyElementContent;\n            var paragraph = dom.create(doc, 'p');\n            dom.insertAfter(paragraph, node);\n            paragraph.innerHTML = emptyElementContent;\n            return paragraph;\n          },\n          clean: function (node, options) {\n            var root = node;\n\n            if (node.firstChild && dom.is(node.firstChild, 'br')) {\n              dom.remove(node.firstChild);\n            }\n\n            if (dom.isDataNode(node) && !node.nodeValue) {\n              node = node.parentNode;\n            }\n\n            if (node) {\n              var siblings = false;\n\n              while (node.firstChild && node.firstChild.nodeType == 1) {\n                siblings = siblings || dom.significantNodes(node.childNodes).length > 1;\n                node = node.firstChild;\n              }\n\n              if (!dom.isEmpty(node) && node.className != \"k-br\" && /^\\s*$/.test(node.innerHTML) && !siblings) {\n                $(root).find(\".k-br\").remove();\n                node.innerHTML = editorNS.emptyElementContent;\n              }\n\n              if (options && options.links) {\n                while (node != root) {\n                  if (dom.is(node, \"a\") && dom.emptyNode(node)) {\n                    dom.unwrap(node);\n                    break;\n                  }\n\n                  node = node.parentNode;\n                }\n              }\n            }\n          }\n        });\n        var NewLineCommand = Command.extend({\n          init: function (options) {\n            this.options = options;\n            Command.fn.init.call(this, options);\n          },\n          exec: function () {\n            var range = this.getRange();\n            this.expandImmutablesIn(range);\n            var br = dom.create(RangeUtils.documentFromRange(range), 'br');\n            var node = range.startContainer;\n            var filler;\n            var browser = kendo.support.browser;\n            var oldIE = browser.msie && browser.version < 11;\n            var tableNode = dom.is(node, 'table') && node;\n            var kbrParent;\n            range.deleteContents();\n\n            if (tableNode) {\n              dom.insertAfter(br, tableNode);\n            } else {\n              kbrParent = $(node).closest('.k-br');\n              range.insertNode(br);\n\n              if (kbrParent.length) {\n                // pressing enter in an k-br node\n                dom.unwrap(kbrParent[0]);\n              }\n            }\n\n            normalize(br.parentNode);\n\n            if (!oldIE && (!br.nextSibling || dom.isWhitespace(br.nextSibling))) {\n              // Gecko and WebKit cannot put the caret after only one br.\n              if (!!br.nextSibling && dom.isWhitespace(br.nextSibling)) {\n                $(br.nextSibling).remove();\n              }\n\n              filler = br.cloneNode(true);\n              filler.className = 'k-br';\n              dom.insertAfter(filler, br);\n            }\n\n            range.setStartAfter(br);\n            range.collapse(true);\n            dom.scrollTo(br.nextSibling || br, true);\n            RangeUtils.selectRange(range);\n          }\n        });\n        extend(editorNS, {\n          ParagraphCommand: ParagraphCommand,\n          NewLineCommand: NewLineCommand\n        });\n        registerTool(\"insertLineBreak\", new Tool({\n          key: 13,\n          shift: true,\n          command: NewLineCommand\n        }));\n        registerTool(\"insertParagraph\", new Tool({\n          key: 13,\n          command: ParagraphCommand\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}