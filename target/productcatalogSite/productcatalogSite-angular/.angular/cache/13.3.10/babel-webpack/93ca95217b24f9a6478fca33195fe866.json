{"ast":null,"code":"import { setDefaultOptions, deepExtend, isNumber } from '../../common';\nimport { ANGULAR_SPEED, RADIAL_RANGE_POINTER } from '../constants';\nimport Pointer from '../pointer';\nimport RangePointerAnimation from './range-pointer-animation';\n\nclass RangePointer extends Pointer {\n  repaint() {\n    const {\n      scale,\n      options\n    } = this;\n    const oldAngle = scale.slotAngle(options._oldValue);\n    const newAngle = scale.slotAngle(options.value);\n\n    if (this.animation) {\n      this.animation.abort();\n    }\n\n    if (options.animation.transitions === false) {\n      this.angle(newAngle);\n      this.stroke(this.currentColor());\n    } else {\n      this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n        oldAngle: oldAngle,\n        newAngle: newAngle\n      }));\n      this.animation.play();\n    }\n  }\n\n  angle(value) {\n    const geometry = this.elements.geometry();\n\n    if (this.scale.options.reverse) {\n      geometry.setStartAngle(value);\n    } else {\n      geometry.setEndAngle(value);\n    }\n\n    this.scale.placeholderRangeAngle(value);\n  }\n\n  stroke(value) {\n    this.elements.stroke(value);\n  }\n\n  render() {\n    if (this.elements) {\n      return;\n    }\n\n    const {\n      scale,\n      options\n    } = this;\n\n    if (options.animation !== false) {\n      deepExtend(options.animation, {\n        startAngle: 0,\n        center: scale.arc.center,\n        reverse: scale.options.reverse\n      });\n    }\n\n    this.elements = scale.addRange(scale.options.min, this.options.value, {\n      color: this.currentColor(),\n      opacity: options.opacity,\n      lineCap: scale.options.rangeLineCap\n    });\n  }\n\n  currentColor() {\n    const {\n      min,\n      max\n    } = this.scale.options;\n    const {\n      colors,\n      color,\n      value\n    } = this.options;\n    const currentValue = isNumber(value) ? value : min;\n\n    if (colors) {\n      for (let idx = 0; idx < colors.length; idx++) {\n        const {\n          color: rangeColor,\n          from = min,\n          to = max\n        } = colors[idx];\n\n        if (from <= currentValue && currentValue <= to) {\n          return rangeColor;\n        }\n      }\n    }\n\n    return color;\n  }\n\n  reflow() {\n    this.render();\n    this.bbox = this.elements.bbox();\n  }\n\n}\n\nsetDefaultOptions(RangePointer, {\n  animation: {\n    type: RADIAL_RANGE_POINTER,\n    duration: ANGULAR_SPEED\n  }\n});\nexport default RangePointer;","map":null,"metadata":{},"sourceType":"module"}