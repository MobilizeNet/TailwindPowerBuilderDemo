{"ast":null,"code":"import ScatterChart from '../scatter-charts/scatter-chart';\nimport Bubble from './bubble';\nimport { INITIAL_ANIMATION_DURATION, BUBBLE } from '../constants';\nimport { MIN_VALUE, CIRCLE } from '../../common/constants';\nimport { deepExtend, isFunction, setDefaultOptions, valueOrDefault } from '../../common';\n\nclass BubbleChart extends ScatterChart {\n  _initFields() {\n    this._maxSize = MIN_VALUE;\n\n    super._initFields();\n  }\n\n  addValue(value, fields) {\n    if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {\n      this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n      super.addValue(value, fields);\n    } else {\n      this.points.push(null);\n      this.seriesPoints[fields.seriesIx].push(null);\n    }\n  }\n\n  reflow(box) {\n    this.updateBubblesSize(box);\n    super.reflow(box);\n  }\n\n  pointType() {\n    return Bubble;\n  }\n\n  createPoint(value, fields) {\n    const series = fields.series;\n    const pointsCount = series.data.length;\n    const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n    const animationOptions = {\n      delay: delay,\n      duration: INITIAL_ANIMATION_DURATION - delay,\n      type: BUBBLE\n    };\n    let color = fields.color || series.color;\n\n    if (value.size < 0 && series.negativeValues.visible) {\n      color = valueOrDefault(series.negativeValues.color, color);\n    }\n\n    let pointOptions = deepExtend({\n      labels: {\n        animation: {\n          delay: delay,\n          duration: INITIAL_ANIMATION_DURATION - delay\n        }\n      }\n    }, this.pointOptions(series, fields.seriesIx), {\n      markers: {\n        type: CIRCLE,\n        border: series.border,\n        opacity: series.opacity,\n        animation: animationOptions\n      }\n    });\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    pointOptions.markers.background = color;\n    const point = new Bubble(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  }\n\n  updateBubblesSize(box) {\n    const {\n      options: {\n        series\n      }\n    } = this;\n    const boxSize = Math.min(box.width(), box.height());\n\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const seriesPoints = this.seriesPoints[seriesIx];\n      const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n      const maxSize = currentSeries.maxSize || boxSize * 0.2;\n      const minR = minSize / 2;\n      const maxR = maxSize / 2;\n      const minArea = Math.PI * minR * minR;\n      const maxArea = Math.PI * maxR * maxR;\n      const areaRange = maxArea - minArea;\n      const areaRatio = areaRange / this._maxSize;\n\n      for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n        const point = seriesPoints[pointIx];\n\n        if (point) {\n          const area = Math.abs(point.value.size) * areaRatio;\n          const radius = Math.sqrt((minArea + area) / Math.PI);\n          const baseZIndex = valueOrDefault(point.options.zIndex, 0);\n          const zIndex = baseZIndex + (1 - radius / maxR);\n          deepExtend(point.options, {\n            zIndex: zIndex,\n            markers: {\n              size: radius * 2,\n              zIndex: zIndex\n            },\n            labels: {\n              zIndex: zIndex + 1\n            }\n          });\n        }\n      }\n    }\n  }\n\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n  }\n\n  createAnimation() {}\n\n  createVisual() {}\n\n}\n\nsetDefaultOptions(BubbleChart, {\n  tooltip: {\n    format: \"{3}\"\n  },\n  labels: {\n    format: \"{3}\"\n  }\n});\nexport default BubbleChart;","map":null,"metadata":{},"sourceType":"module"}