{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(914);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  907:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./svg\");\n    /***/\n  },\n\n  /***/\n  914:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(893), __webpack_require__(907)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($, undefined) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            dataviz = kendo.dataviz,\n            diagram = dataviz.diagram,\n            Class = kendo.Class,\n            Group = diagram.Group,\n            Rect = diagram.Rect,\n            Rectangle = diagram.Rectangle,\n            Utils = diagram.Utils,\n            isUndefined = Utils.isUndefined,\n            Point = diagram.Point,\n            Circle = diagram.Circle,\n            Ticker = diagram.Ticker,\n            deepExtend = kendo.deepExtend,\n            Movable = kendo.ui.Movable,\n            util = kendo.drawing.util,\n            defined = util.defined,\n            inArray = $.inArray; // Constants ==============================================================\n\n        var Cursors = {\n          arrow: \"default\",\n          grip: \"pointer\",\n          cross: \"pointer\",\n          add: \"pointer\",\n          move: \"move\",\n          select: \"pointer\",\n          south: \"s-resize\",\n          east: \"e-resize\",\n          west: \"w-resize\",\n          north: \"n-resize\",\n          rowresize: \"row-resize\",\n          colresize: \"col-resize\"\n        },\n            HIT_TEST_DISTANCE = 10,\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            DEFAULT_SNAP_SIZE = 10,\n            DEFAULT_SNAP_ANGLE = 10,\n            DRAG_START = \"dragStart\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            ITEMROTATE = \"itemRotate\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            MIN_SNAP_SIZE = 5,\n            MIN_SNAP_ANGLE = 5,\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            SCROLL_MIN = -20000,\n            SCROLL_MAX = 20000,\n            FRICTION = 0.90,\n            FRICTION_MOBILE = 0.93,\n            VELOCITY_MULTIPLIER = 5,\n            TRANSPARENT = \"transparent\",\n            PAN = \"pan\",\n            ROTATED = \"rotated\",\n            SOURCE = \"source\",\n            TARGET = \"target\",\n            HANDLE_NAMES = {\n          \"-1\": SOURCE,\n          \"1\": TARGET\n        };\n        diagram.Cursors = Cursors;\n        var PositionAdapter = kendo.Class.extend({\n          init: function (layoutState) {\n            this.layoutState = layoutState;\n            this.diagram = layoutState.diagram;\n          },\n          initState: function () {\n            this.froms = [];\n            this.tos = [];\n            this.subjects = [];\n\n            function pusher(id, bounds) {\n              var shape = this.diagram.getShapeById(id);\n\n              if (shape) {\n                this.subjects.push(shape);\n                this.froms.push(shape.bounds().topLeft());\n                this.tos.push(bounds.topLeft());\n              }\n            }\n\n            this.layoutState.nodeMap.forEach(pusher, this);\n          },\n          update: function (tick) {\n            if (this.subjects.length <= 0) {\n              return;\n            }\n\n            for (var i = 0; i < this.subjects.length; i++) {\n              //todo: define a Lerp function instead\n              this.subjects[i].position(new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick));\n            }\n          }\n        });\n        var LayoutUndoUnit = Class.extend({\n          init: function (initialState, finalState, animate) {\n            if (isUndefined(animate)) {\n              this.animate = false;\n            } else {\n              this.animate = animate;\n            }\n\n            this._initialState = initialState;\n            this._finalState = finalState;\n            this.title = \"Diagram layout\";\n          },\n          undo: function () {\n            this.setState(this._initialState);\n          },\n          redo: function () {\n            this.setState(this._finalState);\n          },\n          setState: function (state) {\n            var diagram = state.diagram;\n\n            if (this.animate) {\n              state.linkMap.forEach(function (id, points) {\n                var conn = diagram.getShapeById(id);\n                conn.visible(false);\n\n                if (conn) {\n                  conn.points(points);\n                }\n              });\n              var ticker = new Ticker();\n              ticker.addAdapter(new PositionAdapter(state));\n              ticker.onComplete(function () {\n                state.linkMap.forEach(function (id) {\n                  var conn = diagram.getShapeById(id);\n                  conn.visible(true);\n                });\n              });\n              ticker.play();\n            } else {\n              state.nodeMap.forEach(function (id, bounds) {\n                var shape = diagram.getShapeById(id);\n\n                if (shape) {\n                  shape.position(bounds.topLeft());\n                }\n              });\n              state.linkMap.forEach(function (id, points) {\n                var conn = diagram.getShapeById(id);\n\n                if (conn) {\n                  conn.points(points);\n                }\n              });\n            }\n          }\n        });\n        var CompositeUnit = Class.extend({\n          init: function (unit) {\n            this.units = [];\n            this.title = \"Composite unit\";\n\n            if (unit !== undefined) {\n              this.units.push(unit);\n            }\n          },\n          add: function (undoUnit) {\n            this.units.push(undoUnit);\n          },\n          undo: function () {\n            for (var i = 0; i < this.units.length; i++) {\n              this.units[i].undo();\n            }\n          },\n          redo: function () {\n            for (var i = 0; i < this.units.length; i++) {\n              this.units[i].redo();\n            }\n          }\n        });\n        var ConnectionEditUnit = Class.extend({\n          init: function (item, redoSource, redoTarget) {\n            this.item = item;\n            this._redoSource = redoSource;\n            this._redoTarget = redoTarget;\n\n            if (defined(redoSource)) {\n              this._undoSource = item.source();\n            }\n\n            if (defined(redoTarget)) {\n              this._undoTarget = item.target();\n            }\n\n            this.title = \"Connection Editing\";\n          },\n          undo: function () {\n            if (this._undoSource !== undefined) {\n              this.item._updateConnector(this._undoSource, \"source\");\n            }\n\n            if (this._undoTarget !== undefined) {\n              this.item._updateConnector(this._undoTarget, \"target\");\n            }\n\n            this.item.updateModel();\n          },\n          redo: function () {\n            if (this._redoSource !== undefined) {\n              this.item._updateConnector(this._redoSource, \"source\");\n            }\n\n            if (this._redoTarget !== undefined) {\n              this.item._updateConnector(this._redoTarget, \"target\");\n            }\n\n            this.item.updateModel();\n          }\n        });\n        var ConnectionEditUndoUnit = Class.extend({\n          init: function (item, undoSource, undoTarget) {\n            this.item = item;\n            this._undoSource = undoSource;\n            this._undoTarget = undoTarget;\n            this._redoSource = item.source();\n            this._redoTarget = item.target();\n            this.title = \"Connection Editing\";\n          },\n          undo: function () {\n            this.item._updateConnector(this._undoSource, \"source\");\n\n            this.item._updateConnector(this._undoTarget, \"target\");\n\n            this.item.updateModel();\n          },\n          redo: function () {\n            this.item._updateConnector(this._redoSource, \"source\");\n\n            this.item._updateConnector(this._redoTarget, \"target\");\n\n            this.item.updateModel();\n          }\n        });\n        var DeleteConnectionUnit = Class.extend({\n          init: function (connection) {\n            this.connection = connection;\n            this.diagram = connection.diagram;\n            this.targetConnector = connection.targetConnector;\n            this.title = \"Delete connection\";\n          },\n          undo: function () {\n            this.diagram._addConnection(this.connection, false);\n          },\n          redo: function () {\n            this.diagram.remove(this.connection, false);\n          }\n        });\n        var DeleteShapeUnit = Class.extend({\n          init: function (shape) {\n            this.shape = shape;\n            this.diagram = shape.diagram;\n            this.title = \"Deletion\";\n          },\n          undo: function () {\n            this.diagram._addShape(this.shape, false);\n\n            this.shape.select(false);\n          },\n          redo: function () {\n            this.shape.select(false);\n            this.diagram.remove(this.shape, false);\n          }\n        });\n        /**\n         * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n         * @type {*}\n         */\n\n        var TransformUnit = Class.extend({\n          init: function (shapes, undoStates, adorner) {\n            this.shapes = shapes;\n            this.undoStates = undoStates;\n            this.title = \"Transformation\";\n            this.redoStates = [];\n            this.adorner = adorner;\n\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              this.redoStates.push(shape.bounds());\n            }\n          },\n          undo: function () {\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              shape.bounds(this.undoStates[i]);\n\n              if (shape.hasOwnProperty(\"layout\")) {\n                shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n              }\n\n              shape.updateModel();\n            }\n\n            if (this.adorner) {\n              this.adorner.refreshBounds();\n              this.adorner.refresh();\n            }\n          },\n          redo: function () {\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              shape.bounds(this.redoStates[i]); // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n\n              if (shape.hasOwnProperty(\"layout\")) {\n                shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n              }\n\n              shape.updateModel();\n            }\n\n            if (this.adorner) {\n              this.adorner.refreshBounds();\n              this.adorner.refresh();\n            }\n          }\n        });\n        var AddConnectionUnit = Class.extend({\n          init: function (connection, diagram) {\n            this.connection = connection;\n            this.diagram = diagram;\n            this.title = \"New connection\";\n          },\n          undo: function () {\n            this.diagram.remove(this.connection, false);\n          },\n          redo: function () {\n            this.diagram._addConnection(this.connection, false);\n          }\n        });\n        var AddShapeUnit = Class.extend({\n          init: function (shape, diagram) {\n            this.shape = shape;\n            this.diagram = diagram;\n            this.title = \"New shape\";\n          },\n          undo: function () {\n            this.diagram.deselect();\n            this.diagram.remove(this.shape, false);\n          },\n          redo: function () {\n            this.diagram._addShape(this.shape, false);\n          }\n        });\n        var PanUndoUnit = Class.extend({\n          init: function (initialPosition, finalPosition, diagram) {\n            this.initial = initialPosition;\n            this.finalPos = finalPosition;\n            this.diagram = diagram;\n            this.title = \"Pan Unit\";\n          },\n          undo: function () {\n            this.diagram.pan(this.initial);\n          },\n          redo: function () {\n            this.diagram.pan(this.finalPos);\n          }\n        });\n        var RotateUnit = Class.extend({\n          init: function (adorner, shapes, undoRotates) {\n            this.shapes = shapes;\n            this.undoRotates = undoRotates;\n            this.title = \"Rotation\";\n            this.redoRotates = [];\n            this.redoAngle = adorner._angle;\n            this.adorner = adorner;\n            this.center = adorner._innerBounds.center();\n\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              this.redoRotates.push(shape.rotate().angle);\n            }\n          },\n          undo: function () {\n            var i, shape;\n\n            for (i = 0; i < this.shapes.length; i++) {\n              shape = this.shapes[i];\n              shape.rotate(this.undoRotates[i], this.center, false);\n\n              if (shape.hasOwnProperty(\"layout\")) {\n                shape.layout(shape);\n              }\n\n              shape.updateModel();\n            }\n\n            if (this.adorner) {\n              this.adorner._initialize();\n\n              this.adorner.refresh();\n            }\n          },\n          redo: function () {\n            var i, shape;\n\n            for (i = 0; i < this.shapes.length; i++) {\n              shape = this.shapes[i];\n              shape.rotate(this.redoRotates[i], this.center, false);\n\n              if (shape.hasOwnProperty(\"layout\")) {\n                shape.layout(shape);\n              }\n\n              shape.updateModel();\n            }\n\n            if (this.adorner) {\n              this.adorner._initialize();\n\n              this.adorner.refresh();\n            }\n          }\n        });\n        var ToFrontUnit = Class.extend({\n          init: function (diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = \"Rotate Unit\";\n          },\n          undo: function () {\n            this.diagram._toIndex(this.items, this.indices);\n          },\n          redo: function () {\n            this.diagram.toFront(this.items, false);\n          }\n        });\n        var ToBackUnit = Class.extend({\n          init: function (diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = \"Rotate Unit\";\n          },\n          undo: function () {\n            this.diagram._toIndex(this.items, this.indices);\n          },\n          redo: function () {\n            this.diagram.toBack(this.items, false);\n          }\n        });\n        /**\n         * Undo-redo service.\n         */\n\n        var UndoRedoService = kendo.Observable.extend({\n          init: function (options) {\n            kendo.Observable.fn.init.call(this, options);\n            this.bind(this.events, options);\n            this.stack = [];\n            this.index = 0;\n            this.capacity = 100;\n          },\n          events: [\"undone\", \"redone\"],\n\n          /**\n           * Starts the collection of units. Add those with\n           * the addCompositeItem method and call commit. Or cancel to forget about it.\n           */\n          begin: function () {\n            this.composite = new CompositeUnit();\n          },\n\n          /**\n           * Cancels the collection process of unit started with 'begin'.\n           */\n          cancel: function () {\n            this.composite = undefined;\n          },\n\n          /**\n           * Commits a batch of units.\n           */\n          commit: function (execute) {\n            if (this.composite.units.length > 0) {\n              this._restart(this.composite, execute);\n            }\n\n            this.composite = undefined;\n          },\n\n          /**\n           * Adds a unit as part of the begin-commit batch.\n           * @param undoUnit\n           */\n          addCompositeItem: function (undoUnit) {\n            if (this.composite) {\n              this.composite.add(undoUnit);\n            } else {\n              this.add(undoUnit);\n            }\n          },\n\n          /**\n           * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n           * @param undoUnit The unit to be added.\n           * @param execute If false, the unit will be added but not executed.\n           */\n          add: function (undoUnit, execute) {\n            this._restart(undoUnit, execute);\n          },\n\n          /**\n           * Returns the number of undoable unit in the stack.\n           * @returns {Number}\n           */\n          pop: function () {\n            if (this.index > 0) {\n              this.stack.pop();\n              this.index--;\n            }\n          },\n          count: function () {\n            return this.stack.length;\n          },\n\n          /**\n           * Rollback of the unit on top of the stack.\n           */\n          undo: function () {\n            if (this.index > 0) {\n              this.index--;\n              this.stack[this.index].undo();\n              this.trigger(\"undone\");\n            }\n          },\n\n          /**\n           * Redo of the last undone action.\n           */\n          redo: function () {\n            if (this.stack.length > 0 && this.index < this.stack.length) {\n              this.stack[this.index].redo();\n              this.index++;\n              this.trigger(\"redone\");\n            }\n          },\n          _restart: function (composite, execute) {\n            // throw away anything beyond this point if this is a new branch\n            this.stack.splice(this.index, this.stack.length - this.index);\n            this.stack.push(composite);\n\n            if (execute !== false) {\n              this.redo();\n            } else {\n              this.index++;\n            } // check the capacity\n\n\n            if (this.stack.length > this.capacity) {\n              this.stack.splice(0, this.stack.length - this.capacity);\n              this.index = this.capacity; //points to the end of the stack\n            }\n          },\n\n          /**\n           * Clears the stack.\n           */\n          clear: function () {\n            this.stack = [];\n            this.index = 0;\n          }\n        }); // Tools =========================================\n\n        var EmptyTool = Class.extend({\n          init: function (toolService) {\n            this.toolService = toolService;\n          },\n          start: function () {},\n          move: function () {},\n          end: function () {},\n          tryActivate: function () {\n            return false;\n          },\n          getCursor: function () {\n            return Cursors.arrow;\n          }\n        });\n        var ScrollerTool = EmptyTool.extend({\n          init: function (toolService) {\n            var tool = this;\n            var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n            EmptyTool.fn.init.call(tool, toolService);\n            var diagram = tool.toolService.diagram,\n                canvas = diagram.canvas;\n            var scroller = diagram.scroller = tool.scroller = $(diagram.scrollable).kendoMobileScroller({\n              friction: friction,\n              velocityMultiplier: VELOCITY_MULTIPLIER,\n              mousewheelScrolling: false,\n              zoom: false,\n              scroll: tool._move.bind(tool)\n            }).data(\"kendoMobileScroller\");\n\n            if (canvas.translate) {\n              tool.movableCanvas = new Movable(canvas.element);\n            }\n\n            var virtualScroll = function (dimension, min, max) {\n              dimension.makeVirtual();\n              dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n            };\n\n            virtualScroll(scroller.dimensions.x);\n            virtualScroll(scroller.dimensions.y);\n            scroller.disable();\n          },\n          tryActivate: function (p, meta) {\n            var toolService = this.toolService;\n            var options = toolService.diagram.options.pannable;\n            var enabled = meta.ctrlKey;\n\n            if (defined(options.key)) {\n              if (!options.key || options.key == \"none\") {\n                enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n              } else {\n                enabled = meta[options.key + \"Key\"];\n              }\n            }\n\n            return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n          },\n          start: function () {\n            this.scroller.enable();\n          },\n          move: function () {},\n          //the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n          _move: function (args) {\n            var tool = this,\n                diagram = tool.toolService.diagram,\n                canvas = diagram.canvas,\n                scrollPos = new Point(args.scrollLeft, args.scrollTop);\n\n            if (canvas.translate) {\n              diagram._storePan(scrollPos.times(-1));\n\n              tool.movableCanvas.moveTo(scrollPos);\n              canvas.translate(scrollPos.x, scrollPos.y);\n            } else {\n              scrollPos = scrollPos.plus(diagram._pan.times(-1));\n            }\n\n            diagram.trigger(PAN, {\n              pan: scrollPos\n            });\n          },\n          end: function () {\n            this.scroller.disable();\n          },\n          getCursor: function () {\n            return Cursors.move;\n          }\n        });\n        /**\n         * The tool handling the transformations via the adorner.\n         * @type {*}\n         */\n\n        var PointerTool = Class.extend({\n          init: function (toolService) {\n            this.toolService = toolService;\n          },\n          tryActivate: function () {\n            return true; // the pointer tool is last and handles all others requests.\n          },\n          start: function (p, meta) {\n            var toolService = this.toolService,\n                diagram = toolService.diagram,\n                hoveredItem = toolService.hoveredItem;\n\n            if (hoveredItem) {\n              toolService.selectSingle(hoveredItem, meta);\n\n              if (hoveredItem.adorner) {\n                //connection\n                this.adorner = hoveredItem.adorner;\n                this.handle = this.adorner._hitTest(p);\n              }\n            }\n\n            if (!this.handle) {\n              this.handle = diagram._resizingAdorner._hitTest(p);\n\n              if (this.handle) {\n                this.adorner = diagram._resizingAdorner;\n              }\n            }\n\n            if (this.adorner) {\n              if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, {\n                shapes: this.adorner.shapes,\n                connections: []\n              })) {\n                this.adorner.start(p);\n              } else {\n                toolService.startPoint = p;\n                toolService.end(p);\n              }\n            }\n          },\n          move: function (p) {\n            if (this.adorner) {\n              this.adorner.move(this.handle, p);\n\n              if (this.adorner.isDragHandle(this.handle)) {\n                this.toolService.diagram.trigger(DRAG, {\n                  shapes: this.adorner.shapes,\n                  connections: []\n                });\n              }\n            }\n          },\n          end: function () {\n            var diagram = this.toolService.diagram,\n                adorner = this.adorner,\n                unit;\n\n            if (adorner) {\n              if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, {\n                shapes: adorner.shapes,\n                connections: []\n              })) {\n                unit = adorner.stop();\n\n                if (unit) {\n                  diagram.undoRedoService.add(unit, false);\n                }\n              } else {\n                adorner.cancel();\n              }\n            }\n\n            this.adorner = undefined;\n            this.handle = undefined;\n          },\n          getCursor: function (p) {\n            return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n          }\n        });\n        var SelectionTool = Class.extend({\n          init: function (toolService) {\n            this.toolService = toolService;\n          },\n          tryActivate: function (p, meta) {\n            var toolService = this.toolService;\n            var selectable = toolService.diagram.options.selectable;\n            var enabled = selectable && selectable.multiple !== false;\n\n            if (enabled) {\n              if (selectable.key && selectable.key != \"none\") {\n                enabled = meta[selectable.key + \"Key\"];\n              } else {\n                enabled = noMeta(meta);\n              }\n            }\n\n            return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n          },\n          start: function (p) {\n            var diagram = this.toolService.diagram;\n            diagram.deselect();\n            diagram.selector.start(p);\n          },\n          move: function (p) {\n            var diagram = this.toolService.diagram;\n            diagram.selector.move(p);\n          },\n          end: function (p, meta) {\n            var diagram = this.toolService.diagram,\n                hoveredItem = this.toolService.hoveredItem;\n            var rect = diagram.selector.bounds();\n\n            if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n              diagram.deselect();\n            }\n\n            if (!rect.isEmpty()) {\n              diagram.selectArea(rect);\n            }\n\n            diagram.selector.end();\n          },\n          getCursor: function () {\n            return Cursors.arrow;\n          }\n        });\n        var ConnectionTool = Class.extend({\n          init: function (toolService) {\n            this.toolService = toolService;\n            this.type = \"ConnectionTool\";\n          },\n          tryActivate: function () {\n            return this.toolService._hoveredConnector;\n          },\n          start: function (p, meta) {\n            var toolService = this.toolService,\n                diagram = toolService.diagram,\n                connector = toolService._hoveredConnector,\n                connection = diagram._createConnection({}, connector._c, p);\n\n            if (canDrag(connection) && !diagram.trigger(DRAG_START, {\n              shapes: [],\n              connections: [connection],\n              connectionHandle: TARGET\n            }) && diagram._addConnection(connection)) {\n              toolService._connectionManipulation(connection, connector._c.shape, true);\n\n              toolService._removeHover();\n\n              toolService.selectSingle(toolService.activeConnection, meta);\n\n              if (meta.type == \"touchmove\") {\n                diagram._cachedTouchTarget = connector.visual;\n              }\n            } else {\n              connection.source(null);\n              toolService.end(p);\n            }\n          },\n          move: function (p) {\n            var toolService = this.toolService;\n            var connection = toolService.activeConnection;\n            connection.target(p);\n            toolService.diagram.trigger(DRAG, {\n              shapes: [],\n              connections: [connection],\n              connectionHandle: TARGET\n            });\n            return true;\n          },\n          end: function (p) {\n            var toolService = this.toolService,\n                d = toolService.diagram,\n                connection = toolService.activeConnection,\n                hoveredItem = toolService.hoveredItem,\n                connector = toolService._hoveredConnector,\n                target,\n                cachedTouchTarget = d._cachedTouchTarget;\n\n            if (!connection) {\n              return;\n            }\n\n            if (connector && connector._c != connection.sourceConnector) {\n              target = connector._c;\n            } else if (hoveredItem && hoveredItem instanceof diagram.Shape) {\n              target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(p);\n            } else {\n              target = p;\n            }\n\n            connection.target(target);\n\n            if (!d.trigger(DRAG_END, {\n              shapes: [],\n              connections: [connection],\n              connectionHandle: TARGET\n            })) {\n              connection.updateModel();\n\n              d._syncConnectionChanges();\n            } else {\n              d.remove(connection, false);\n              d.undoRedoService.pop();\n            }\n\n            toolService._connectionManipulation();\n\n            if (cachedTouchTarget) {\n              d._connectorsAdorner.visual.remove(cachedTouchTarget);\n\n              d._cachedTouchTarget = null;\n            }\n          },\n          getCursor: function () {\n            return Cursors.arrow;\n          }\n        });\n        var ConnectionEditTool = Class.extend({\n          init: function (toolService) {\n            this.toolService = toolService;\n            this.type = \"ConnectionTool\";\n          },\n          tryActivate: function (p, meta) {\n            var toolService = this.toolService,\n                diagram = toolService.diagram,\n                selectable = diagram.options.selectable,\n                item = toolService.hoveredItem,\n                isActive = selectable !== false && item && item.path && !(item.isSelected && meta.ctrlKey);\n\n            if (isActive) {\n              this._c = item;\n            }\n\n            return isActive;\n          },\n          start: function (p, meta) {\n            var toolService = this.toolService;\n            var connection = this._c;\n            toolService.selectSingle(connection, meta);\n            var adorner = connection.adorner;\n            var handle, name;\n\n            if (adorner) {\n              handle = adorner._hitTest(p);\n              name = HANDLE_NAMES[handle];\n            }\n\n            if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, {\n              shapes: [],\n              connections: [connection],\n              connectionHandle: name\n            })) {\n              this.handle = handle;\n              this.handleName = name;\n              adorner.start(p);\n            } else {\n              toolService.startPoint = p;\n              toolService.end(p);\n            }\n          },\n          move: function (p) {\n            var adorner = this._c.adorner;\n\n            if (canDrag(this._c) && adorner) {\n              adorner.move(this.handle, p);\n              this.toolService.diagram.trigger(DRAG, {\n                shapes: [],\n                connections: [this._c],\n                connectionHandle: this.handleName\n              });\n              return true;\n            }\n          },\n          end: function (p) {\n            var connection = this._c;\n            var adorner = connection.adorner;\n            var toolService = this.toolService;\n            var diagram = toolService.diagram;\n\n            if (adorner) {\n              if (canDrag(connection)) {\n                var unit = adorner.stop(p);\n\n                if (!diagram.trigger(DRAG_END, {\n                  shapes: [],\n                  connections: [connection],\n                  connectionHandle: this.handleName\n                })) {\n                  diagram.undoRedoService.add(unit, false);\n                  connection.updateModel();\n\n                  diagram._syncConnectionChanges();\n                } else {\n                  unit.undo();\n                }\n              }\n            }\n          },\n          getCursor: function () {\n            return Cursors.move;\n          }\n        });\n\n        function testKey(key, str) {\n          return str.charCodeAt(0) == key || str.toUpperCase().charCodeAt(0) == key;\n        }\n        /**\n         * The service managing the tools.\n         * @type {*}\n         */\n\n\n        var ToolService = Class.extend({\n          init: function (diagram) {\n            this.diagram = diagram;\n            this.tools = [new ScrollerTool(this), new ConnectionEditTool(this), new ConnectionTool(this), new SelectionTool(this), new PointerTool(this)]; // the order matters.\n\n            this.activeTool = undefined;\n          },\n          start: function (p, meta) {\n            meta = deepExtend({}, meta);\n\n            if (this.activeTool) {\n              this.activeTool.end(p, meta);\n            }\n\n            this._updateHoveredItem(p);\n\n            this._activateTool(p, meta);\n\n            this.activeTool.start(p, meta);\n\n            this._updateCursor(p);\n\n            this.diagram.focus();\n            this.diagram.canvas.surface.suspendTracking();\n            this.startPoint = p;\n            return true;\n          },\n          move: function (p, meta) {\n            meta = deepExtend({}, meta);\n            var updateHovered = true;\n\n            if (this.activeTool) {\n              updateHovered = this.activeTool.move(p, meta);\n            }\n\n            if (updateHovered) {\n              this._updateHoveredItem(p);\n            }\n\n            this._updateCursor(p);\n\n            return true;\n          },\n          end: function (p, meta) {\n            meta = deepExtend({}, meta);\n\n            if (this.activeTool) {\n              this.activeTool.end(p, meta);\n            }\n\n            this.diagram.canvas.surface.resumeTracking();\n            this.activeTool = undefined;\n\n            this._updateCursor(p);\n\n            return true;\n          },\n          keyDown: function (key, meta) {\n            var diagram = this.diagram;\n            meta = deepExtend({\n              ctrlKey: false,\n              metaKey: false,\n              altKey: false\n            }, meta);\n\n            if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) {\n              // ctrl or option\n              if (testKey(key, \"a\")) {\n                // A: select all\n                diagram.selectAll();\n\n                diagram._destroyToolBar();\n\n                return true;\n              } else if (testKey(key, \"z\")) {\n                // Z: undo\n                diagram.undo();\n\n                diagram._destroyToolBar();\n\n                return true;\n              } else if (testKey(key, \"y\")) {\n                // y: redo\n                diagram.redo();\n\n                diagram._destroyToolBar();\n\n                return true;\n              } else if (testKey(key, \"c\")) {\n                diagram.copy();\n\n                diagram._destroyToolBar();\n              } else if (testKey(key, \"x\")) {\n                diagram.cut();\n\n                diagram._destroyToolBar();\n              } else if (testKey(key, \"v\")) {\n                diagram.paste();\n\n                diagram._destroyToolBar();\n              } else if (testKey(key, \"l\")) {\n                diagram.layout();\n\n                diagram._destroyToolBar();\n              } else if (testKey(key, \"d\")) {\n                diagram._destroyToolBar();\n\n                diagram.copy();\n                diagram.paste();\n              }\n            } else if (key === 46 || key === 8) {\n              // del: deletion\n              var toRemove = this.diagram._triggerRemove(diagram.select());\n\n              if (toRemove.length) {\n                this.diagram.remove(toRemove, true);\n\n                this.diagram._syncChanges();\n\n                this.diagram._destroyToolBar();\n              }\n\n              return true;\n            } else if (key === 27) {\n              // ESC: stop any action\n              this._discardNewConnection();\n\n              diagram.deselect();\n\n              diagram._destroyToolBar();\n\n              return true;\n            }\n          },\n          wheel: function (p, meta) {\n            var diagram = this.diagram,\n                delta = meta.delta,\n                z = diagram.zoom(),\n                options = diagram.options,\n                zoomRate = options.zoomRate,\n                zoomOptions = {\n              point: p,\n              meta: meta,\n              zoom: z\n            };\n\n            if (diagram.trigger(ZOOM_START, zoomOptions)) {\n              return;\n            }\n\n            if (delta < 0) {\n              z += zoomRate;\n            } else {\n              z -= zoomRate;\n            }\n\n            z = kendo.dataviz.round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n            zoomOptions.zoom = z;\n            diagram.zoom(z, zoomOptions);\n            diagram.trigger(ZOOM_END, zoomOptions);\n            return true;\n          },\n          setTool: function (tool, index) {\n            tool.toolService = this;\n            this.tools[index] = tool;\n          },\n          selectSingle: function (item, meta) {\n            var diagram = this.diagram;\n            var selectable = diagram.options.selectable;\n\n            if (selectable && !item.isSelected && item.options.selectable !== false) {\n              var addToSelection = meta.ctrlKey && selectable.multiple !== false;\n              diagram.select(item, {\n                addToSelection: addToSelection\n              });\n            }\n          },\n          _discardNewConnection: function () {\n            if (this.newConnection) {\n              this.diagram.remove(this.newConnection);\n              this.newConnection = undefined;\n            }\n          },\n          _activateTool: function (p, meta) {\n            for (var i = 0; i < this.tools.length; i++) {\n              var tool = this.tools[i];\n\n              if (tool.tryActivate(p, meta)) {\n                this.activeTool = tool;\n                break; // activating the first available tool in the loop.\n              }\n            }\n          },\n          _updateCursor: function (p) {\n            var element = this.diagram.element;\n            var cursor = this.activeTool ? this.activeTool.getCursor(p) : this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow;\n            element.css({\n              cursor: cursor\n            });\n          },\n          _connectionManipulation: function (connection, disabledShape, isNew) {\n            this.activeConnection = connection;\n            this.disabledShape = disabledShape;\n\n            if (isNew) {\n              this.newConnection = this.activeConnection;\n            } else {\n              this.newConnection = undefined;\n            }\n          },\n          _updateHoveredItem: function (p) {\n            var hit = this._hitTest(p);\n\n            var diagram = this.diagram;\n\n            if (hit != this.hoveredItem && (!this.disabledShape || hit != this.disabledShape)) {\n              if (this.hoveredItem) {\n                diagram.trigger(MOUSE_LEAVE, {\n                  item: this.hoveredItem\n                });\n\n                this.hoveredItem._hover(false);\n              }\n\n              if (hit && hit.options.enable) {\n                diagram.trigger(MOUSE_ENTER, {\n                  item: hit\n                });\n                this.hoveredItem = hit; // Shape, connection or connector\n\n                this.hoveredItem._hover(true);\n              } else {\n                this.hoveredItem = undefined;\n              }\n            }\n          },\n          _removeHover: function () {\n            if (this.hoveredItem) {\n              this.hoveredItem._hover(false);\n\n              this.hoveredItem = undefined;\n            }\n          },\n          _hitTest: function (point) {\n            var hit,\n                d = this.diagram,\n                item,\n                i; // connectors\n\n            if (this._hoveredConnector) {\n              this._hoveredConnector._hover(false);\n\n              this._hoveredConnector = undefined;\n            }\n\n            if (d._connectorsAdorner._visible) {\n              hit = d._connectorsAdorner._hitTest(point);\n\n              if (hit) {\n                return hit;\n              }\n            }\n\n            hit = this.diagram._resizingAdorner._hitTest(point);\n\n            if (hit) {\n              this.hoveredAdorner = d._resizingAdorner;\n\n              if (hit.x !== 0 || hit.y !== 0) {\n                // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                return;\n              }\n\n              hit = undefined;\n            } else {\n              this.hoveredAdorner = undefined;\n            }\n\n            if (!this.activeTool || this.activeTool.type !== \"ConnectionTool\") {\n              var selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n              // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n\n              for (i = 0; i < d._selectedItems.length; i++) {\n                item = d._selectedItems[i];\n\n                if (item instanceof diagram.Connection) {\n                  selectedConnections.push(item);\n                }\n              }\n\n              hit = this._hitTestItems(selectedConnections, point);\n            }\n\n            return hit || this._hitTestElements(point);\n          },\n          _hitTestElements: function (point) {\n            var diagram = this.diagram;\n\n            var shapeHit = this._hitTestItems(diagram.shapes, point);\n\n            var connectionHit = this._hitTestItems(diagram.connections, point);\n\n            var hit;\n\n            if ((!this.activeTool || this.activeTool.type != \"ConnectionTool\") && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n              var mainLayer = diagram.mainLayer;\n              var shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n              var connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n              hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n            }\n\n            return hit || shapeHit || connectionHit;\n          },\n          _hitTestItems: function (array, point) {\n            var i, item, hit;\n\n            for (i = array.length - 1; i >= 0; i--) {\n              item = array[i];\n              hit = item._hitTest(point);\n\n              if (hit) {\n                return hit;\n              }\n            }\n          }\n        }); // Routing =========================================\n\n        /**\n         * Base class for connection routers.\n         */\n\n        var ConnectionRouterBase = kendo.Class.extend({\n          init: function () {}\n          /*route: function (connection) {\n           },\n           hitTest: function (p) {\n            },\n           getBounds: function () {\n            }*/\n\n        });\n        /**\n         * Base class for polyline and cascading routing.\n         */\n\n        var LinearConnectionRouter = ConnectionRouterBase.extend({\n          init: function (connection) {\n            var that = this;\n            ConnectionRouterBase.fn.init.call(that);\n            this.connection = connection;\n          },\n\n          /**\n           * Hit testing for polyline paths.\n           */\n          hitTest: function (p) {\n            var rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n\n            if (!rec.contains(p)) {\n              return false;\n            }\n\n            return diagram.Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n          },\n\n          /**\n           * Bounds of a polyline.\n           * @returns {kendo.dataviz.diagram.Rect}\n           */\n          getBounds: function () {\n            var points = this.connection.allPoints(),\n                s = points[0],\n                e = points[points.length - 1],\n                right = Math.max(s.x, e.x),\n                left = Math.min(s.x, e.x),\n                top = Math.min(s.y, e.y),\n                bottom = Math.max(s.y, e.y);\n\n            for (var i = 1; i < points.length - 1; ++i) {\n              right = Math.max(right, points[i].x);\n              left = Math.min(left, points[i].x);\n              top = Math.min(top, points[i].y);\n              bottom = Math.max(bottom, points[i].y);\n            }\n\n            return new Rect(left, top, right - left, bottom - top);\n          }\n        });\n        /**\n         * A simple poly-linear routing which does not alter the intermediate points.\n         * Does hold the underlying hit, bounds....logic.\n         * @type {*|Object|void|extend|Zepto.extend|b.extend}\n         */\n\n        var PolylineRouter = LinearConnectionRouter.extend({\n          init: function (connection) {\n            var that = this;\n            LinearConnectionRouter.fn.init.call(that);\n            this.connection = connection;\n          },\n          route: function () {// just keep the points as is\n          }\n        });\n        var CascadingRouter = LinearConnectionRouter.extend({\n          SAME_SIDE_DISTANCE_RATIO: 5,\n          init: function (connection) {\n            var that = this;\n            LinearConnectionRouter.fn.init.call(that);\n            this.connection = connection;\n          },\n          routePoints: function (start, end, sourceConnector, targetConnector) {\n            var result;\n\n            if (sourceConnector && targetConnector) {\n              result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n            } else {\n              result = this._floatingPoints(start, end, sourceConnector);\n            }\n\n            return result;\n          },\n          route: function () {\n            var sourceConnector = this.connection._resolvedSourceConnector;\n            var targetConnector = this.connection._resolvedTargetConnector;\n            var start = this.connection.sourcePoint();\n            var end = this.connection.targetPoint();\n            var points = this.routePoints(start, end, sourceConnector, targetConnector);\n            this.connection.points(points);\n          },\n          _connectorSides: [{\n            name: \"Top\",\n            axis: \"y\",\n            boundsPoint: \"topLeft\",\n            secondarySign: 1\n          }, {\n            name: \"Left\",\n            axis: \"x\",\n            boundsPoint: \"topLeft\",\n            secondarySign: 1\n          }, {\n            name: \"Bottom\",\n            axis: \"y\",\n            boundsPoint: \"bottomRight\",\n            secondarySign: -1\n          }, {\n            name: \"Right\",\n            axis: \"x\",\n            boundsPoint: \"bottomRight\",\n            secondarySign: -1\n          }],\n          _connectorSide: function (connector, targetPoint) {\n            var position = connector.position();\n            var shapeBounds = connector.shape.bounds(ROTATED);\n            var bounds = {\n              topLeft: shapeBounds.topLeft(),\n              bottomRight: shapeBounds.bottomRight()\n            };\n            var sides = this._connectorSides;\n            var min = util.MAX_NUM;\n            var sideDistance;\n            var minSide;\n            var axis;\n            var side;\n\n            for (var idx = 0; idx < sides.length; idx++) {\n              side = sides[idx];\n              axis = side.axis;\n              sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n\n              if (sideDistance < min) {\n                min = sideDistance;\n                minSide = side;\n              } else if (sideDistance === min && (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                minSide = side;\n              }\n            }\n\n            return minSide.name;\n          },\n          _sameSideDistance: function (connector) {\n            var bounds = connector.shape.bounds(ROTATED);\n            return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n          },\n          _connectorPoints: function (start, end, sourceConnector, targetConnector) {\n            var sourceConnectorSide = this._connectorSide(sourceConnector, end);\n\n            var targetConnectorSide = this._connectorSide(targetConnector, start);\n\n            var deltaX = end.x - start.x;\n            var deltaY = end.y - start.y;\n\n            var sameSideDistance = this._sameSideDistance(sourceConnector);\n\n            var result = [];\n            var pointX, pointY;\n\n            if (sourceConnectorSide === TOP || sourceConnectorSide == BOTTOM) {\n              if (targetConnectorSide == TOP || targetConnectorSide == BOTTOM) {\n                if (sourceConnectorSide == targetConnectorSide) {\n                  if (sourceConnectorSide == TOP) {\n                    pointY = Math.min(start.y, end.y) - sameSideDistance;\n                  } else {\n                    pointY = Math.max(start.y, end.y) + sameSideDistance;\n                  }\n\n                  result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                } else {\n                  result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                }\n              } else {\n                result = [new Point(start.x, end.y)];\n              }\n            } else {\n              if (targetConnectorSide == LEFT || targetConnectorSide == RIGHT) {\n                if (sourceConnectorSide == targetConnectorSide) {\n                  if (sourceConnectorSide == LEFT) {\n                    pointX = Math.min(start.x, end.x) - sameSideDistance;\n                  } else {\n                    pointX = Math.max(start.x, end.x) + sameSideDistance;\n                  }\n\n                  result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                } else {\n                  result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                }\n              } else {\n                result = [new Point(end.x, start.y)];\n              }\n            }\n\n            return result;\n          },\n          _floatingPoints: function (start, end, sourceConnector) {\n            var sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n\n            var cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n\n            var points = [start, start, end, end];\n            var deltaX = end.x - start.x;\n            var deltaY = end.y - start.y;\n            var length = points.length;\n            var shiftX;\n            var shiftY; // note that this is more generic than needed for only two intermediate points.\n\n            for (var idx = 1; idx < length - 1; ++idx) {\n              if (cascadeStartHorizontal) {\n                if (idx % 2 !== 0) {\n                  shiftX = deltaX / (length / 2);\n                  shiftY = 0;\n                } else {\n                  shiftX = 0;\n                  shiftY = deltaY / ((length - 1) / 2);\n                }\n              } else {\n                if (idx % 2 !== 0) {\n                  shiftX = 0;\n                  shiftY = deltaY / (length / 2);\n                } else {\n                  shiftX = deltaX / ((length - 1) / 2);\n                  shiftY = 0;\n                }\n              }\n\n              points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n            } // need to fix the wrong 1.5 factor of the last intermediate point\n\n\n            idx--;\n\n            if (cascadeStartHorizontal && idx % 2 !== 0 || !cascadeStartHorizontal && idx % 2 === 0) {\n              points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n            } else {\n              points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n            }\n\n            return [points[1], points[2]];\n          },\n          _startHorizontal: function (start, end, sourceSide) {\n            var horizontal;\n\n            if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n              horizontal = true;\n            } else {\n              horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n            }\n\n            return horizontal;\n          }\n        }); // Adorners =========================================\n\n        var AdornerBase = Class.extend({\n          init: function (diagram, options) {\n            var that = this;\n            that.diagram = diagram;\n            that.options = deepExtend({}, that.options, options);\n            that.visual = new Group();\n\n            that.diagram._adorners.push(that);\n          },\n          refresh: function () {}\n        });\n        var ConnectionEditAdorner = AdornerBase.extend({\n          init: function (connection, options) {\n            var that = this,\n                diagram;\n            that.connection = connection;\n            diagram = that.connection.diagram;\n            that._ts = diagram.toolService;\n            AdornerBase.fn.init.call(that, diagram, options);\n            var sp = that.connection.sourcePoint();\n            var tp = that.connection.targetPoint();\n            that.spVisual = new Circle(deepExtend(that.options.handles, {\n              center: sp\n            }));\n            that.epVisual = new Circle(deepExtend(that.options.handles, {\n              center: tp\n            }));\n            that.visual.append(that.spVisual);\n            that.visual.append(that.epVisual);\n          },\n          options: {\n            handles: {}\n          },\n          _getCursor: function () {\n            return Cursors.move;\n          },\n          start: function (p) {\n            this.handle = this._hitTest(p);\n            this.startPoint = p;\n            this._initialSource = this.connection.source();\n            this._initialTarget = this.connection.target();\n\n            switch (this.handle) {\n              case -1:\n                if (this.connection.targetConnector) {\n                  this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                }\n\n                break;\n\n              case 1:\n                if (this.connection.sourceConnector) {\n                  this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                }\n\n                break;\n            }\n          },\n          move: function (handle, p) {\n            switch (handle) {\n              case -1:\n                this.connection.source(p);\n                break;\n\n              case 1:\n                this.connection.target(p);\n                break;\n\n              default:\n                var delta = p.minus(this.startPoint);\n                this.startPoint = p;\n\n                if (!this.connection.sourceConnector) {\n                  this.connection.source(this.connection.sourcePoint().plus(delta));\n                }\n\n                if (!this.connection.targetConnector) {\n                  this.connection.target(this.connection.targetPoint().plus(delta));\n                }\n\n                break;\n            }\n\n            this.refresh();\n            return true;\n          },\n          stop: function (p) {\n            var ts = this.diagram.toolService,\n                item = ts.hoveredItem,\n                target;\n\n            if (ts._hoveredConnector) {\n              target = ts._hoveredConnector._c;\n            } else if (item && item instanceof diagram.Shape) {\n              target = item.getConnector(AUTO) || item.getConnector(p);\n            } else {\n              target = p;\n            }\n\n            if (this.handle === -1) {\n              this.connection.source(target);\n            } else if (this.handle === 1) {\n              this.connection.target(target);\n            }\n\n            this.handle = undefined;\n\n            this._ts._connectionManipulation();\n\n            return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n          },\n          _hitTest: function (point) {\n            var sourcePoint = this.connection.sourcePoint();\n            var targetPoint = this.connection.targetPoint();\n            var radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n            var radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n            var sourcePointDistance = sourcePoint.distanceTo(point);\n            var targetPointDistance = targetPoint.distanceTo(point);\n            var sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n            var targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n            var handle = 0;\n\n            if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n              handle = -1;\n            } else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n              handle = 1;\n            }\n\n            return handle;\n          },\n          refresh: function () {\n            this.spVisual.redraw({\n              center: this.diagram.modelToLayer(this.connection.sourcePoint())\n            });\n            this.epVisual.redraw({\n              center: this.diagram.modelToLayer(this.connection.targetPoint())\n            });\n          }\n        });\n        var ConnectorsAdorner = AdornerBase.extend({\n          init: function (diagram, options) {\n            var that = this;\n            AdornerBase.fn.init.call(that, diagram, options);\n\n            that._refreshHandler = function (e) {\n              if (e.item == that.shape) {\n                that.refresh();\n              }\n            };\n          },\n          show: function (shape) {\n            var that = this,\n                len,\n                i,\n                ctr;\n            that._visible = true;\n            that.shape = shape;\n            that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler);\n            len = shape.connectors.length;\n            that.connectors = [];\n\n            that._clearVisual();\n\n            for (i = 0; i < len; i++) {\n              ctr = new ConnectorVisual(shape.connectors[i]);\n              that.connectors.push(ctr);\n              that.visual.append(ctr.visual);\n            }\n\n            that.visual.visible(true);\n            that.refresh();\n          },\n          _clearVisual: function () {\n            var that = this;\n\n            if (that.diagram._cachedTouchTarget) {\n              that._keepCachedTouchTarget();\n            } else {\n              that.visual.clear();\n            }\n          },\n          _keepCachedTouchTarget: function () {\n            var that = this,\n                visualChildren = that.visual.children;\n            var childrenCount = visualChildren.length;\n            var index = inArray(that.diagram._cachedTouchTarget, visualChildren);\n\n            for (var i = childrenCount - 1; i >= 0; i--) {\n              if (i == index) {\n                continue;\n              }\n\n              that.visual.remove(visualChildren[i]);\n            }\n          },\n          destroy: function () {\n            var that = this;\n            that.diagram.unbind(ITEMBOUNDSCHANGE, that._refreshHandler);\n            that.shape = undefined;\n            that._visible = undefined;\n            that.visual.visible(false);\n          },\n          _hitTest: function (p) {\n            var ctr, i;\n\n            for (i = 0; i < this.connectors.length; i++) {\n              ctr = this.connectors[i];\n\n              if (ctr._hitTest(p)) {\n                ctr._hover(true);\n\n                this.diagram.toolService._hoveredConnector = ctr;\n                break;\n              }\n            }\n          },\n          refresh: function () {\n            if (this.shape) {\n              var bounds = this.shape.bounds();\n              bounds = this.diagram.modelToLayer(bounds);\n              this.visual.position(bounds.topLeft());\n              $.each(this.connectors, function () {\n                this.refresh();\n              });\n            }\n          }\n        });\n\n        function hitToOppositeSide(hit, bounds) {\n          var result;\n\n          if (hit.x == -1 && hit.y == -1) {\n            result = bounds.bottomRight();\n          } else if (hit.x == 1 && hit.y == 1) {\n            result = bounds.topLeft();\n          } else if (hit.x == -1 && hit.y == 1) {\n            result = bounds.topRight();\n          } else if (hit.x == 1 && hit.y == -1) {\n            result = bounds.bottomLeft();\n          } else if (hit.x === 0 && hit.y == -1) {\n            result = bounds.bottom();\n          } else if (hit.x === 0 && hit.y == 1) {\n            result = bounds.top();\n          } else if (hit.x == 1 && hit.y === 0) {\n            result = bounds.left();\n          } else if (hit.x == -1 && hit.y === 0) {\n            result = bounds.right();\n          }\n\n          return result;\n        }\n\n        var ResizingAdorner = AdornerBase.extend({\n          init: function (diagram, options) {\n            var that = this;\n            AdornerBase.fn.init.call(that, diagram, options);\n            that._manipulating = false;\n            that.map = [];\n            that.shapes = [];\n\n            that._initSelection();\n\n            that._createHandles();\n\n            that.redraw();\n            that.diagram.bind(\"select\", function (e) {\n              that._initialize(e.selected);\n            });\n\n            that._refreshHandler = function () {\n              if (!that._internalChange) {\n                that.refreshBounds();\n                that.refresh();\n              }\n            };\n\n            that._rotatedHandler = function () {\n              if (that.shapes.length == 1) {\n                that._angle = that.shapes[0].rotate().angle;\n              }\n\n              that._refreshHandler();\n            };\n\n            that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler).bind(ITEMROTATE, that._rotatedHandler);\n            that.refreshBounds();\n            that.refresh();\n          },\n          options: {\n            handles: {\n              fill: {\n                color: \"#fff\"\n              },\n              stroke: {\n                color: \"#282828\"\n              },\n              height: 7,\n              width: 7,\n              hover: {\n                fill: {\n                  color: \"#282828\"\n                },\n                stroke: {\n                  color: \"#282828\"\n                }\n              }\n            },\n            selectable: {\n              stroke: {\n                color: \"#778899\",\n                width: 1,\n                dashType: \"dash\"\n              },\n              fill: {\n                color: TRANSPARENT\n              }\n            },\n            offset: 10\n          },\n          _initSelection: function () {\n            var that = this;\n            var diagram = that.diagram;\n            var selectable = diagram.options.selectable;\n            var options = deepExtend({}, that.options.selectable, selectable);\n            that.rect = new Rectangle(options);\n            that.visual.append(that.rect);\n          },\n          _resizable: function () {\n            return this.options.editable && this.options.editable.resize !== false;\n          },\n          _handleOptions: function () {\n            return (this.options.editable.resize || {}).handles || this.options.handles;\n          },\n          _createHandles: function () {\n            var handles, item, y, x;\n\n            if (this._resizable()) {\n              handles = this._handleOptions();\n\n              for (x = -1; x <= 1; x++) {\n                for (y = -1; y <= 1; y++) {\n                  if (x !== 0 || y !== 0) {\n                    // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                    item = new Rectangle(handles);\n                    item.drawingElement._hover = this._hover.bind(this);\n                    this.map.push({\n                      x: x,\n                      y: y,\n                      visual: item\n                    });\n                    this.visual.append(item);\n                  }\n                }\n              }\n            }\n          },\n          bounds: function (value) {\n            if (value) {\n              this._innerBounds = value.clone();\n              this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n            } else {\n              return this._bounds;\n            }\n          },\n          _hitTest: function (p) {\n            var tp = this.diagram.modelToLayer(p),\n                i,\n                hit,\n                handleBounds,\n                handlesCount = this.map.length,\n                handle;\n\n            if (this._angle) {\n              tp = tp.clone().rotate(this._bounds.center(), this._angle);\n            }\n\n            if (this._resizable()) {\n              for (i = 0; i < handlesCount; i++) {\n                handle = this.map[i];\n                hit = new Point(handle.x, handle.y);\n                handleBounds = this._getHandleBounds(hit); //local coordinates\n\n                handleBounds.offset(this._bounds.x, this._bounds.y);\n\n                if (handleBounds.contains(tp)) {\n                  return hit;\n                }\n              }\n            }\n\n            if (this._bounds.contains(tp)) {\n              return new Point(0, 0);\n            }\n          },\n          _getHandleBounds: function (p) {\n            if (this._resizable()) {\n              var handles = this._handleOptions(),\n                  w = handles.width,\n                  h = handles.height,\n                  r = new Rect(0, 0, w, h);\n\n              if (p.x < 0) {\n                r.x = -w / 2;\n              } else if (p.x === 0) {\n                r.x = Math.floor(this._bounds.width / 2) - w / 2;\n              } else if (p.x > 0) {\n                r.x = this._bounds.width + 1.0 - w / 2;\n              }\n\n              if (p.y < 0) {\n                r.y = -h / 2;\n              } else if (p.y === 0) {\n                r.y = Math.floor(this._bounds.height / 2) - h / 2;\n              } else if (p.y > 0) {\n                r.y = this._bounds.height + 1.0 - h / 2;\n              }\n\n              return r;\n            }\n          },\n          _getCursor: function (point) {\n            var hit = this._hitTest(point);\n\n            if (hit && hit.x >= -1 && hit.x <= 1 && hit.y >= -1 && hit.y <= 1 && this._resizable()) {\n              var angle = this._angle;\n\n              if (angle) {\n                angle = 360 - angle;\n                hit.rotate(new Point(0, 0), angle);\n                hit = new Point(Math.round(hit.x), Math.round(hit.y));\n              }\n\n              if (hit.x == -1 && hit.y == -1) {\n                return \"nw-resize\";\n              }\n\n              if (hit.x == 1 && hit.y == 1) {\n                return \"se-resize\";\n              }\n\n              if (hit.x == -1 && hit.y == 1) {\n                return \"sw-resize\";\n              }\n\n              if (hit.x == 1 && hit.y == -1) {\n                return \"ne-resize\";\n              }\n\n              if (hit.x === 0 && hit.y == -1) {\n                return \"n-resize\";\n              }\n\n              if (hit.x === 0 && hit.y == 1) {\n                return \"s-resize\";\n              }\n\n              if (hit.x == 1 && hit.y === 0) {\n                return \"e-resize\";\n              }\n\n              if (hit.x == -1 && hit.y === 0) {\n                return \"w-resize\";\n              }\n            }\n\n            return this._manipulating ? Cursors.move : Cursors.select;\n          },\n          _initialize: function () {\n            var that = this,\n                i,\n                item,\n                items = that.diagram.select();\n            that.shapes = [];\n\n            for (i = 0; i < items.length; i++) {\n              item = items[i];\n\n              if (item instanceof diagram.Shape) {\n                that.shapes.push(item);\n                item._rotationOffset = new Point();\n              }\n            }\n\n            that._angle = that.shapes.length == 1 ? that.shapes[0].rotate().angle : 0;\n            that._startAngle = that._angle;\n\n            that._rotates();\n\n            that._positions();\n\n            that.refreshBounds();\n            that.refresh();\n            that.redraw();\n          },\n          _rotates: function () {\n            var that = this,\n                i,\n                shape;\n            that.initialRotates = [];\n\n            for (i = 0; i < that.shapes.length; i++) {\n              shape = that.shapes[i];\n              that.initialRotates.push(shape.rotate().angle);\n            }\n          },\n          _positions: function () {\n            var that = this,\n                i,\n                shape;\n            that.initialStates = [];\n\n            for (i = 0; i < that.shapes.length; i++) {\n              shape = that.shapes[i];\n              that.initialStates.push(shape.bounds());\n            }\n          },\n          _hover: function (value, element) {\n            if (this._resizable()) {\n              var handleOptions = this._handleOptions(),\n                  hover = handleOptions.hover,\n                  stroke = handleOptions.stroke,\n                  fill = handleOptions.fill;\n\n              if (value && Utils.isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n              }\n\n              if (value && Utils.isDefined(hover.fill)) {\n                fill = hover.fill;\n              }\n\n              element.stroke(stroke.color, stroke.width, stroke.opacity);\n              element.fill(fill.color, fill.opacity);\n            }\n          },\n          start: function (p) {\n            this._sp = p;\n            this._cp = p;\n            this._lp = p;\n            this._manipulating = true;\n            this._internalChange = true;\n            this.shapeStates = [];\n\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              this.shapeStates.push(shape.bounds());\n            }\n          },\n          redraw: function () {\n            var i,\n                handle,\n                visibleHandles = this._resizable();\n\n            for (i = 0; i < this.map.length; i++) {\n              handle = this.map[i];\n              handle.visual.visible(visibleHandles);\n            }\n          },\n          angle: function (value) {\n            if (defined(value)) {\n              this._angle = value;\n            }\n\n            return this._angle;\n          },\n          rotate: function () {\n            var center = this._innerBounds.center();\n\n            var currentAngle = this.angle();\n            this._internalChange = true;\n\n            for (var i = 0; i < this.shapes.length; i++) {\n              var shape = this.shapes[i];\n              currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n              shape.rotate(currentAngle, center);\n            }\n\n            this.refresh();\n          },\n          move: function (handle, p) {\n            var delta,\n                dragging,\n                dtl = new Point(),\n                dbr = new Point(),\n                bounds,\n                center,\n                shape,\n                i,\n                angle,\n                newBounds,\n                changed = 0,\n                staticPoint,\n                scaleX,\n                scaleY;\n\n            if (handle.y === -2 && handle.x === -1) {\n              center = this._innerBounds.center();\n              this._angle = this._truncateAngle(Utils.findAngle(center, p));\n\n              for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                shape.rotate(angle, center);\n\n                if (shape.hasOwnProperty(\"layout\")) {\n                  shape.layout(shape);\n                }\n\n                this._rotating = true;\n              }\n\n              this.refresh();\n            } else {\n              if (this.shouldSnap()) {\n                var thr = this._truncateDistance(p.minus(this._lp)); // threshold\n\n\n                if (thr.x === 0 && thr.y === 0) {\n                  this._cp = p;\n                  return;\n                }\n\n                delta = thr;\n                this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n              } else {\n                delta = p.minus(this._cp);\n              }\n\n              if (this.isDragHandle(handle)) {\n                dbr = dtl = delta; // dragging\n\n                dragging = true;\n              } else {\n                if (this._angle) {\n                  // adjust the delta so that resizers resize in the correct direction after rotation.\n                  delta.rotate(new Point(0, 0), this._angle);\n                }\n\n                if (handle.x == -1) {\n                  dtl.x = delta.x;\n                } else if (handle.x == 1) {\n                  dbr.x = delta.x;\n                }\n\n                if (handle.y == -1) {\n                  dtl.y = delta.y;\n                } else if (handle.y == 1) {\n                  dbr.y = delta.y;\n                }\n              }\n\n              if (!dragging) {\n                staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n              }\n\n              for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                bounds = shape.bounds();\n\n                if (dragging) {\n                  if (!canDrag(shape)) {\n                    continue;\n                  }\n\n                  newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                } else {\n                  newBounds = bounds.clone();\n                  newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                  var newCenter = newBounds.center(); // fixes the new rotation center.\n\n                  newCenter.rotate(bounds.center(), -this._angle);\n                  newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                }\n\n                if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) {\n                  // if we up-size very small shape\n                  var oldBounds = bounds;\n                  shape.bounds(newBounds);\n\n                  if (shape.hasOwnProperty(\"layout\")) {\n                    shape.layout(shape, oldBounds, newBounds);\n                  }\n\n                  if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                    shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                  }\n\n                  changed += 1;\n                }\n              }\n\n              if (changed) {\n                if (changed == i) {\n                  newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                  this.bounds(newBounds);\n                } else {\n                  this.refreshBounds();\n                }\n\n                this.refresh();\n              }\n\n              this._positions();\n            }\n\n            this._cp = p;\n          },\n          isDragHandle: function (handle) {\n            return handle.x === 0 && handle.y === 0;\n          },\n          cancel: function () {\n            var shapes = this.shapes;\n            var states = this.shapeStates;\n\n            for (var idx = 0; idx < shapes.length; idx++) {\n              shapes[idx].bounds(states[idx]);\n            }\n\n            this.refreshBounds();\n            this.refresh();\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n          },\n          _truncatePositionToGuides: function (bounds) {\n            if (this.diagram.ruler) {\n              return this.diagram.ruler.truncatePositionToGuides(bounds);\n            }\n\n            return bounds;\n          },\n          _truncateSizeToGuides: function (bounds) {\n            if (this.diagram.ruler) {\n              return this.diagram.ruler.truncateSizeToGuides(bounds);\n            }\n\n            return bounds;\n          },\n          _truncateAngle: function (a) {\n            var snap = this.snapOptions();\n            var snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n            return snap ? Math.floor(a % 360 / snapAngle) * snapAngle : a % 360;\n          },\n          _truncateDistance: function (d) {\n            if (d instanceof diagram.Point) {\n              return new diagram.Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n            } else {\n              var snap = this.snapOptions() || {};\n              var snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n              return snap ? Math.floor(d / snapSize) * snapSize : d;\n            }\n          },\n          snapOptions: function () {\n            var editable = this.diagram.options.editable;\n            var snap = ((editable || {}).drag || {}).snap || {};\n            return snap;\n          },\n          shouldSnap: function () {\n            var editable = this.diagram.options.editable;\n            var drag = (editable || {}).drag;\n            var snap = (drag || {}).snap;\n            return editable !== false && drag !== false && snap !== false;\n          },\n          _displaceBounds: function (bounds, dtl, dbr, dragging) {\n            var tl = bounds.topLeft().plus(dtl),\n                br = bounds.bottomRight().plus(dbr),\n                newBounds = Rect.fromPoints(tl, br),\n                newCenter;\n\n            if (!dragging) {\n              newCenter = newBounds.center();\n              newCenter.rotate(bounds.center(), -this._angle);\n              newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n            }\n\n            return newBounds;\n          },\n          stop: function () {\n            var unit, i, shape;\n\n            if (this._cp != this._sp) {\n              if (this._rotating) {\n                unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                this._rotating = false;\n              } else if (this._diffStates()) {\n                if (this.diagram.ruler) {\n                  for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    var bounds = shape.bounds();\n                    bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                    shape.bounds(bounds);\n                    this.refreshBounds();\n                    this.refresh();\n                  }\n                }\n\n                for (i = 0; i < this.shapes.length; i++) {\n                  shape = this.shapes[i];\n                  shape.updateModel();\n                }\n\n                unit = new TransformUnit(this.shapes, this.shapeStates, this);\n\n                this.diagram._syncShapeChanges();\n              }\n            }\n\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n            return unit;\n          },\n          _diffStates: function () {\n            var shapes = this.shapes;\n            var states = this.shapeStates;\n\n            for (var idx = 0; idx < shapes.length; idx++) {\n              if (!shapes[idx].bounds().equals(states[idx])) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          refreshBounds: function () {\n            var bounds = this.shapes.length == 1 ? this.shapes[0].bounds().clone() : this.diagram.boundingBox(this.shapes, true);\n            this.bounds(bounds);\n          },\n          refresh: function () {\n            var that = this,\n                b,\n                bounds;\n\n            if (this.shapes.length > 0) {\n              bounds = this.bounds();\n              this.visual.visible(true);\n              this.visual.position(bounds.topLeft());\n              $.each(this.map, function () {\n                b = that._getHandleBounds(new Point(this.x, this.y));\n                this.visual.position(b.topLeft());\n              });\n              this.visual.position(bounds.topLeft());\n              var center = new Point(bounds.width / 2, bounds.height / 2);\n              this.visual.rotate(this._angle, center);\n              this.rect.redraw({\n                width: bounds.width,\n                height: bounds.height\n              });\n\n              if (this.rotationThumb) {\n                var thumb = this.options.editable.rotate.thumb;\n                this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                this.rotationThumb.redraw({\n                  x: bounds.width / 2 - thumb.width / 2\n                });\n              }\n            } else {\n              this.visual.visible(false);\n            }\n          }\n        });\n        var Selector = Class.extend({\n          init: function (diagram) {\n            var selectable = diagram.options.selectable;\n            this.options = deepExtend({}, this.options, selectable);\n            this.visual = new Rectangle(this.options);\n            this.diagram = diagram;\n          },\n          options: {\n            stroke: {\n              color: \"#778899\",\n              width: 1,\n              dashType: \"dash\"\n            },\n            fill: {\n              color: TRANSPARENT\n            }\n          },\n          start: function (p) {\n            this._sp = this._ep = p;\n            this.refresh();\n\n            this.diagram._adorn(this, true);\n          },\n          end: function () {\n            this._sp = this._ep = undefined;\n\n            this.diagram._adorn(this, false);\n          },\n          bounds: function (value) {\n            if (value) {\n              this._bounds = value;\n            }\n\n            return this._bounds;\n          },\n          move: function (p) {\n            this._ep = p;\n            this.refresh();\n          },\n          refresh: function () {\n            if (this._sp) {\n              var visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n              this.bounds(Rect.fromPoints(this._sp, this._ep));\n              this.visual.position(visualBounds.topLeft());\n              this.visual.redraw({\n                height: visualBounds.height + 1,\n                width: visualBounds.width + 1\n              });\n            }\n          }\n        });\n        var ConnectorVisual = Class.extend({\n          init: function (connector) {\n            this.options = deepExtend({}, connector.options);\n            this._c = connector;\n            this.visual = new Circle(this.options);\n            this.refresh();\n          },\n          _hover: function (value) {\n            var options = this.options,\n                hover = options.hover,\n                stroke = options.stroke,\n                fill = options.fill;\n\n            if (value && Utils.isDefined(hover.stroke)) {\n              stroke = deepExtend({}, stroke, hover.stroke);\n            }\n\n            if (value && Utils.isDefined(hover.fill)) {\n              fill = hover.fill;\n            }\n\n            this.visual.redraw({\n              stroke: stroke,\n              fill: fill\n            });\n          },\n          refresh: function () {\n            var p = this._c.shape.diagram.modelToView(this._c.position()),\n                relative = p.minus(this._c.shape.bounds(\"transformed\").topLeft()),\n                value = new Rect(p.x, p.y, 0, 0);\n\n            value.inflate(this.options.width / 2, this.options.height / 2);\n            this._visualBounds = value;\n            this.visual.redraw({\n              center: new Point(relative.x, relative.y)\n            });\n          },\n          _hitTest: function (p) {\n            var tp = this._c.shape.diagram.modelToView(p);\n\n            return this._visualBounds.contains(tp);\n          }\n        });\n\n        function canDrag(element) {\n          var editable = element.options.editable;\n          return editable && editable.drag !== false;\n        }\n\n        function hitTestShapeConnectors(shape, point) {\n          var connector, position, rect;\n\n          for (var idx = 0; idx < shape.connectors.length; idx++) {\n            connector = shape.connectors[idx];\n            position = connector.position();\n            rect = new Rect(position.x, position.y);\n            rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n\n            if (rect.contains(point)) {\n              return connector;\n            }\n          }\n        }\n\n        function noMeta(meta) {\n          return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n        }\n\n        deepExtend(diagram, {\n          CompositeUnit: CompositeUnit,\n          TransformUnit: TransformUnit,\n          PanUndoUnit: PanUndoUnit,\n          AddShapeUnit: AddShapeUnit,\n          AddConnectionUnit: AddConnectionUnit,\n          DeleteShapeUnit: DeleteShapeUnit,\n          DeleteConnectionUnit: DeleteConnectionUnit,\n          ConnectionEditAdorner: ConnectionEditAdorner,\n          ConnectionTool: ConnectionTool,\n          ConnectorVisual: ConnectorVisual,\n          UndoRedoService: UndoRedoService,\n          ResizingAdorner: ResizingAdorner,\n          Selector: Selector,\n          ToolService: ToolService,\n          ConnectorsAdorner: ConnectorsAdorner,\n          LayoutUndoUnit: LayoutUndoUnit,\n          ConnectionEditUnit: ConnectionEditUnit,\n          ToFrontUnit: ToFrontUnit,\n          ToBackUnit: ToBackUnit,\n          ConnectionRouterBase: ConnectionRouterBase,\n          PolylineRouter: PolylineRouter,\n          CascadingRouter: CascadingRouter,\n          SelectionTool: SelectionTool,\n          ScrollerTool: ScrollerTool,\n          PointerTool: PointerTool,\n          ConnectionEditTool: ConnectionEditTool,\n          RotateUnit: RotateUnit\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}