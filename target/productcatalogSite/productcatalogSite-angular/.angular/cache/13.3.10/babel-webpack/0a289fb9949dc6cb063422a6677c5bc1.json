{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(955);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  955:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /***********************************************************************\n    * WARNING: this file is auto-generated.  If you change it directly,\n    * your modifications will eventually be lost.  The source code is in\n    * `kendo-drawing` repository, you should make your changes there and\n    * run `src-modules/sync.sh` in this repository.\n    */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(956), __webpack_require__(957), __webpack_require__(958)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        /* jshint eqnull:true */\n\n        /* jshint -W058 */\n\n        /* jshint -W069 */\n\n        /* jshint latedef: nofunc */\n\n        /* jshint shadow: true */\n\n        /* jshint unused: false */\n        window.kendo = window.kendo || {};\n        var kendoDrawing = kendo.drawing;\n        var kendoDrawingUtil = kendoDrawing.util;\n        var extendStatic = kendoDrawingUtil.extendStatic;\n        var Class = kendo.Class;\n        var kendoUtil = kendo.util;\n        var support = kendo.support;\n        var supportBrowser = support.browser;\n        var createPromise = kendoDrawingUtil.createPromise;\n        var promiseAll = kendoDrawingUtil.promiseAll;\n\n        var HasObservers = function (Class$$1) {\n          function HasObservers() {\n            Class$$1.apply(this, arguments);\n          }\n\n          extendStatic(HasObservers, Class$$1);\n          HasObservers.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          HasObservers.prototype.constructor = HasObservers;\n          HasObservers.fn = HasObservers.prototype;\n          HasObservers.fn.init = HasObservers.fn.constructor;\n\n          HasObservers.prototype.observers = function observers() {\n            this._observers = this._observers || [];\n            return this._observers;\n          };\n\n          HasObservers.prototype.addObserver = function addObserver(element) {\n            if (!this._observers) {\n              this._observers = [element];\n            } else {\n              this._observers.push(element);\n            }\n\n            return this;\n          };\n\n          HasObservers.prototype.removeObserver = function removeObserver(element) {\n            var observers = this.observers();\n            var index = observers.indexOf(element);\n\n            if (index !== -1) {\n              observers.splice(index, 1);\n            }\n\n            return this;\n          };\n\n          HasObservers.prototype.trigger = function trigger(methodName, event) {\n            var observers = this._observers;\n\n            if (observers && !this._suspended) {\n              for (var idx = 0; idx < observers.length; idx++) {\n                var observer = observers[idx];\n\n                if (observer[methodName]) {\n                  observer[methodName](event);\n                }\n              }\n            }\n\n            return this;\n          };\n\n          HasObservers.prototype.optionsChange = function optionsChange(e) {\n            if (e === void 0) {\n              e = {};\n            }\n\n            e.element = this;\n            this.trigger(\"optionsChange\", e);\n          };\n\n          HasObservers.prototype.geometryChange = function geometryChange() {\n            this.trigger(\"geometryChange\", {\n              element: this\n            });\n          };\n\n          HasObservers.prototype.suspend = function suspend() {\n            this._suspended = (this._suspended || 0) + 1;\n            return this;\n          };\n\n          HasObservers.prototype.resume = function resume() {\n            this._suspended = Math.max((this._suspended || 0) - 1, 0);\n            return this;\n          };\n\n          HasObservers.prototype._observerField = function _observerField(field, value) {\n            if (this[field]) {\n              this[field].removeObserver(this);\n            }\n\n            this[field] = value;\n            value.addObserver(this);\n          };\n\n          return HasObservers;\n        }(Class);\n\n        function append$1$1(first, second) {\n          first.push.apply(first, second);\n          return first;\n        }\n        /* eslint-disable key-spacing,no-multi-spaces,no-param-reassign */\n\n\n        var literals = {\n          1: \"i\",\n          10: \"x\",\n          100: \"c\",\n          2: \"ii\",\n          20: \"xx\",\n          200: \"cc\",\n          3: \"iii\",\n          30: \"xxx\",\n          300: \"ccc\",\n          4: \"iv\",\n          40: \"xl\",\n          400: \"cd\",\n          5: \"v\",\n          50: \"l\",\n          500: \"d\",\n          6: \"vi\",\n          60: \"lx\",\n          600: \"dc\",\n          7: \"vii\",\n          70: \"lxx\",\n          700: \"dcc\",\n          8: \"viii\",\n          80: \"lxxx\",\n          800: \"dccc\",\n          9: \"ix\",\n          90: \"xc\",\n          900: \"cm\",\n          1000: \"m\"\n        };\n\n        function arabicToRoman(n) {\n          var values = [1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\n          var roman = \"\";\n\n          while (n > 0) {\n            if (n < values[0]) {\n              values.shift();\n            } else {\n              roman += literals[values[0]];\n              n -= values[0];\n            }\n          }\n\n          return roman;\n        }\n\n        var UNDEFINED = \"undefined\";\n\n        function defined(value) {\n          return typeof value !== UNDEFINED;\n        }\n\n        var defId = 1;\n\n        function definitionId() {\n          return \"kdef\" + defId++;\n        }\n\n        var DEG_TO_RAD = Math.PI / 180;\n        var MAX_NUM = Number.MAX_VALUE;\n        var MIN_NUM = -Number.MAX_VALUE;\n\n        function deg(radians) {\n          return radians / DEG_TO_RAD;\n        }\n\n        var fromCharCode = String.fromCharCode; // Encodes a string as UTF-8\n\n        function encodeUTF8(input) {\n          var output = \"\";\n\n          for (var i = 0; i < input.length; i++) {\n            var code = input.charCodeAt(i);\n\n            if (0xD800 <= code && code <= 0xDBFF) {\n              var hi = code;\n              var low = input.charCodeAt(++i);\n\n              if (!isNaN(low)) {\n                // Combine high and low surrogate\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\n                code = (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;\n              }\n            }\n\n            if (code < 0x80) {\n              // One byte\n              output += fromCharCode(code);\n            } else if (code < 0x800) {\n              // Two bytes\n              output += fromCharCode(0xC0 | code >>> 6);\n              output += fromCharCode(0x80 | code & 0x3f);\n            } else if (code < 0x10000) {\n              // Three bytes\n              output += fromCharCode(0xE0 | code >>> 12);\n              output += fromCharCode(0x80 | code >>> 6 & 0x3f);\n              output += fromCharCode(0x80 | code & 0x3f);\n            } else if (code < 0x10FFFF) {\n              // Four bytes\n              output += fromCharCode(0xF0 | code >>> 18);\n              output += fromCharCode(0x80 | code >>> 12 & 0x3f);\n              output += fromCharCode(0x80 | code >>> 6 & 0x3f);\n              output += fromCharCode(0x80 | code & 0x3f);\n            }\n          }\n\n          return output;\n        } // Encodes a string as UTF-16 big-endian\n\n\n        var KEY_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        function encodeBase64(input) {\n          var output = \"\";\n          var i = 0;\n          var utfInput = encodeUTF8(input);\n\n          while (i < utfInput.length) {\n            var chr1 = utfInput.charCodeAt(i++);\n            var chr2 = utfInput.charCodeAt(i++);\n            var chr3 = utfInput.charCodeAt(i++);\n            var enc1 = chr1 >> 2;\n            var enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n            var enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n            var enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n              enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n              enc4 = 64;\n            }\n\n            output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);\n          }\n\n          return output;\n        }\n\n        function eventCoordinates(e) {\n          if (defined((e.x || {}).location)) {\n            return {\n              x: e.x.location,\n              y: e.y.location\n            };\n          }\n\n          return {\n            x: e.pageX || e.clientX || 0,\n            y: e.pageY || e.clientY || 0\n          };\n        }\n\n        function eventElement(e) {\n          if (e === void 0) {\n            e = {};\n          }\n\n          return e.touch ? e.touch.initialTouch : e.target;\n        }\n\n        function isTransparent(color) {\n          return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n        }\n\n        function last(array) {\n          if (array) {\n            return array[array.length - 1];\n          }\n        }\n\n        function limitValue(value, min, max) {\n          return Math.max(Math.min(value, max), min);\n        }\n        /* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\n        /* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\n        /* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n\n        /* eslint-disable no-param-reassign, no-var, block-scoped-var */\n        // mergeSort is stable.\n\n\n        function mergeSort(a, cmp) {\n          if (a.length < 2) {\n            return a.slice();\n          }\n\n          function merge(a, b) {\n            var r = [],\n                ai = 0,\n                bi = 0,\n                i = 0;\n\n            while (ai < a.length && bi < b.length) {\n              if (cmp(a[ai], b[bi]) <= 0) {\n                r[i++] = a[ai++];\n              } else {\n                r[i++] = b[bi++];\n              }\n            }\n\n            if (ai < a.length) {\n              r.push.apply(r, a.slice(ai));\n            }\n\n            if (bi < b.length) {\n              r.push.apply(r, b.slice(bi));\n            }\n\n            return r;\n          }\n\n          return function sort(a) {\n            if (a.length <= 1) {\n              return a;\n            }\n\n            var m = Math.floor(a.length / 2);\n            var left = a.slice(0, m);\n            var right = a.slice(m);\n            left = sort(left);\n            right = sort(right);\n            return merge(left, right);\n          }(a);\n        }\n\n        var now = Date.now || function () {\n          return new Date().getTime();\n        };\n\n        function rad(degrees) {\n          return degrees * DEG_TO_RAD;\n        }\n\n        function pow(p) {\n          if (p) {\n            return Math.pow(10, p);\n          }\n\n          return 1;\n        }\n\n        function round(value, precision) {\n          var power = pow(precision);\n          return Math.round(value * power) / power;\n        }\n\n        function valueOrDefault(value, defaultValue) {\n          return defined(value) ? value : defaultValue;\n        }\n\n        function bindEvents(element, events) {\n          for (var eventName in events) {\n            var eventNames = eventName.trim().split(\" \");\n\n            for (var idx = 0; idx < eventNames.length; idx++) {\n              element.addEventListener(eventNames[idx], events[eventName], false);\n            }\n          }\n        }\n\n        function elementOffset(element) {\n          var box = element.getBoundingClientRect();\n          var documentElement = document.documentElement;\n          return {\n            top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),\n            left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)\n          };\n        }\n\n        function elementStyles(element, styles) {\n          var result = {};\n          var style = window.getComputedStyle(element) || {};\n          var stylesArray = Array.isArray(styles) ? styles : [styles];\n\n          for (var idx = 0; idx < stylesArray.length; idx++) {\n            var field = stylesArray[idx];\n            result[field] = style[field];\n          }\n\n          return result;\n        }\n\n        function getPixels(value) {\n          if (isNaN(value)) {\n            return value;\n          }\n\n          return value + \"px\";\n        }\n\n        function elementSize(element, size) {\n          if (size) {\n            var width = size.width;\n            var height = size.height;\n\n            if (defined(width)) {\n              element.style.width = getPixels(width);\n            }\n\n            if (defined(height)) {\n              element.style.height = getPixels(height);\n            }\n          } else {\n            var size$1 = elementStyles(element, ['width', 'height']);\n            return {\n              width: parseInt(size$1.width, 10),\n              height: parseInt(size$1.height, 10)\n            };\n          }\n        }\n\n        function unbindEvents(element, events) {\n          if (events === void 0) {\n            events = {};\n          }\n\n          for (var name in events) {\n            var eventNames = name.trim().split(\" \");\n\n            for (var idx = 0; idx < eventNames.length; idx++) {\n              element.removeEventListener(eventNames[idx], events[name], false);\n            }\n          }\n        }\n\n        function elementPadding(element) {\n          var ref = elementStyles(element, [\"paddingLeft\", \"paddingTop\"]);\n          var paddingLeft = ref.paddingLeft;\n          var paddingTop = ref.paddingTop;\n          return {\n            top: parseFloat(paddingTop),\n            left: parseFloat(paddingLeft)\n          };\n        }\n\n        var Matrix = function (Class$$1) {\n          function Matrix(a, b, c, d, e, f) {\n            if (a === void 0) {\n              a = 0;\n            }\n\n            if (b === void 0) {\n              b = 0;\n            }\n\n            if (c === void 0) {\n              c = 0;\n            }\n\n            if (d === void 0) {\n              d = 0;\n            }\n\n            if (e === void 0) {\n              e = 0;\n            }\n\n            if (f === void 0) {\n              f = 0;\n            }\n\n            Class$$1.call(this);\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.d = d;\n            this.e = e;\n            this.f = f;\n          }\n\n          extendStatic(Matrix, Class$$1);\n          Matrix.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          Matrix.prototype.constructor = Matrix;\n          Matrix.fn = Matrix.prototype;\n          Matrix.fn.init = Matrix.fn.constructor;\n\n          Matrix.prototype.multiplyCopy = function multiplyCopy(matrix) {\n            return new Matrix(this.a * matrix.a + this.c * matrix.b, this.b * matrix.a + this.d * matrix.b, this.a * matrix.c + this.c * matrix.d, this.b * matrix.c + this.d * matrix.d, this.a * matrix.e + this.c * matrix.f + this.e, this.b * matrix.e + this.d * matrix.f + this.f);\n          };\n\n          Matrix.prototype.invert = function invert() {\n            var ref = this;\n            var a = ref.a;\n            var b = ref.b;\n            var d = ref.c;\n            var e = ref.d;\n            var g = ref.e;\n            var h = ref.f;\n            var det = a * e - b * d;\n\n            if (det === 0) {\n              return null;\n            }\n\n            return new Matrix(e / det, -b / det, -d / det, a / det, (d * h - e * g) / det, (b * g - a * h) / det);\n          };\n\n          Matrix.prototype.clone = function clone() {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n          };\n\n          Matrix.prototype.equals = function equals(other) {\n            if (!other) {\n              return false;\n            }\n\n            return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;\n          };\n\n          Matrix.prototype.round = function round$1(precision) {\n            this.a = round(this.a, precision);\n            this.b = round(this.b, precision);\n            this.c = round(this.c, precision);\n            this.d = round(this.d, precision);\n            this.e = round(this.e, precision);\n            this.f = round(this.f, precision);\n            return this;\n          };\n\n          Matrix.prototype.toArray = function toArray(precision) {\n            var result = [this.a, this.b, this.c, this.d, this.e, this.f];\n\n            if (defined(precision)) {\n              for (var i = 0; i < result.length; i++) {\n                result[i] = round(result[i], precision);\n              }\n            }\n\n            return result;\n          };\n\n          Matrix.prototype.toString = function toString(precision, separator) {\n            if (separator === void 0) {\n              separator = \",\";\n            }\n\n            return this.toArray(precision).join(separator);\n          };\n\n          Matrix.translate = function translate(x, y) {\n            return new Matrix(1, 0, 0, 1, x, y);\n          };\n\n          Matrix.unit = function unit() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n          };\n\n          Matrix.rotate = function rotate(angle, x, y) {\n            var matrix = new Matrix();\n            matrix.a = Math.cos(rad(angle));\n            matrix.b = Math.sin(rad(angle));\n            matrix.c = -matrix.b;\n            matrix.d = matrix.a;\n            matrix.e = x - x * matrix.a + y * matrix.b || 0;\n            matrix.f = y - y * matrix.a - x * matrix.b || 0;\n            return matrix;\n          };\n\n          Matrix.scale = function scale(scaleX, scaleY) {\n            return new Matrix(scaleX, 0, 0, scaleY, 0, 0);\n          };\n\n          return Matrix;\n        }(Class);\n\n        Matrix.IDENTITY = Matrix.unit();\n        var matrixRegexp = /matrix\\((.*)\\)/;\n\n        function parseMatrix(matrixString) {\n          var match = matrixString.match(matrixRegexp);\n\n          if (match === null || match.length !== 2) {\n            return Matrix.unit();\n          }\n\n          var members = match[1].split(',').map(function (x) {\n            return parseFloat(x);\n          });\n          return new (Function.prototype.bind.apply(Matrix, [null].concat(members)))();\n        }\n\n        function transformMatrix(element) {\n          var transform = getComputedStyle(element).transform;\n\n          if (transform === 'none') {\n            return Matrix.unit();\n          }\n\n          return parseMatrix(transform);\n        }\n\n        function elementScale(element) {\n          if (!element) {\n            return Matrix.unit();\n          }\n\n          var matrix = transformMatrix(element);\n          var parent = element.parentElement;\n\n          while (parent) {\n            var parentMatrix = transformMatrix(parent);\n            matrix = matrix.multiplyCopy(parentMatrix);\n            parent = parent.parentElement;\n          }\n\n          matrix.b = matrix.c = matrix.e = matrix.f = 0;\n          return matrix;\n        }\n\n        var util = {\n          append: append$1$1,\n          arabicToRoman: arabicToRoman,\n          createPromise: createPromise,\n          defined: defined,\n          definitionId: definitionId,\n          deg: deg,\n          encodeBase64: encodeBase64,\n          eventCoordinates: eventCoordinates,\n          eventElement: eventElement,\n          isTransparent: isTransparent,\n          last: last,\n          limitValue: limitValue,\n          mergeSort: mergeSort,\n          now: now,\n          promiseAll: promiseAll,\n          rad: rad,\n          round: round,\n          valueOrDefault: valueOrDefault,\n          bindEvents: bindEvents,\n          elementOffset: elementOffset,\n          elementSize: elementSize,\n          elementStyles: elementStyles,\n          unbindEvents: unbindEvents,\n          elementPadding: elementPadding,\n          elementScale: elementScale,\n          DEG_TO_RAD: DEG_TO_RAD,\n          MAX_NUM: MAX_NUM,\n          MIN_NUM: MIN_NUM\n        };\n        var toString$1 = {}.toString;\n\n        var OptionsStore = function (HasObservers$$1) {\n          function OptionsStore(options, prefix) {\n            var this$1 = this;\n\n            if (prefix === void 0) {\n              prefix = \"\";\n            }\n\n            HasObservers$$1.call(this);\n            this.prefix = prefix;\n\n            for (var field in options) {\n              var member = options[field];\n              member = this$1._wrap(member, field);\n              this$1[field] = member;\n            }\n          }\n\n          extendStatic(OptionsStore, HasObservers$$1);\n          OptionsStore.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          OptionsStore.prototype.constructor = OptionsStore;\n          OptionsStore.fn = OptionsStore.prototype;\n          OptionsStore.fn.init = OptionsStore.fn.constructor;\n\n          OptionsStore.prototype.get = function get(field) {\n            var parts = field.split(\".\");\n            var result = this;\n\n            while (parts.length && result) {\n              var part = parts.shift();\n              result = result[part];\n            }\n\n            return result;\n          };\n\n          OptionsStore.prototype.set = function set(field, value) {\n            var current = this.get(field);\n\n            if (current !== value) {\n              this._set(field, this._wrap(value, field));\n\n              this.optionsChange({\n                field: this.prefix + field,\n                value: value\n              });\n            }\n          };\n\n          OptionsStore.prototype._set = function _set(field, value) {\n            var this$1 = this;\n            var composite = field.indexOf(\".\") >= 0;\n            var parentObj = this;\n            var fieldName = field;\n\n            if (composite) {\n              var parts = fieldName.split(\".\");\n              var prefix = this.prefix;\n\n              while (parts.length > 1) {\n                fieldName = parts.shift();\n                prefix += fieldName + \".\";\n                var obj = parentObj[fieldName];\n\n                if (!obj) {\n                  obj = new OptionsStore({}, prefix);\n                  obj.addObserver(this$1);\n                  parentObj[fieldName] = obj;\n                }\n\n                parentObj = obj;\n              }\n\n              fieldName = parts[0];\n            }\n\n            parentObj._clear(fieldName);\n\n            parentObj[fieldName] = value;\n          };\n\n          OptionsStore.prototype._clear = function _clear(field) {\n            var current = this[field];\n\n            if (current && current.removeObserver) {\n              current.removeObserver(this);\n            }\n          };\n\n          OptionsStore.prototype._wrap = function _wrap(object, field) {\n            var type = toString$1.call(object);\n            var wrapped = object;\n\n            if (wrapped !== null && defined(wrapped) && type === \"[object Object]\") {\n              if (!(object instanceof OptionsStore) && !(object instanceof Class)) {\n                wrapped = new OptionsStore(wrapped, this.prefix + field + \".\");\n              }\n\n              wrapped.addObserver(this);\n            }\n\n            return wrapped;\n          };\n\n          return OptionsStore;\n        }(HasObservers);\n\n        function setAccessor(field) {\n          return function (value) {\n            if (this[field] !== value) {\n              this[field] = value;\n              this.geometryChange();\n            }\n\n            return this;\n          };\n        }\n\n        function getAccessor(field) {\n          return function () {\n            return this[field];\n          };\n        }\n\n        function defineAccessors(fn, fields) {\n          for (var i = 0; i < fields.length; i++) {\n            var name = fields[i];\n            var capitalized = name.charAt(0).toUpperCase() + name.substring(1, name.length);\n            fn[\"set\" + capitalized] = setAccessor(name);\n            fn[\"get\" + capitalized] = getAccessor(name);\n          }\n        }\n\n        var withAccessors = function (TBase, names) {\n          var result = function (TBase) {\n            function result() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(result, TBase);\n            result.prototype = Object.create(TBase && TBase.prototype);\n            result.prototype.constructor = result;\n            result.fn = result.prototype;\n            result.fn.init = result.fn.constructor;\n            return result;\n          }(TBase);\n\n          defineAccessors(result.prototype, names);\n          return result;\n        };\n\n        function toMatrix(transformation) {\n          if (transformation && typeof transformation.matrix === \"function\") {\n            return transformation.matrix();\n          }\n\n          return transformation;\n        }\n\n        var Point = function (superclass) {\n          function Point(x, y) {\n            superclass.call(this);\n            this.x = x || 0;\n            this.y = y || 0;\n          }\n\n          extendStatic(Point, superclass);\n          Point.prototype = Object.create(superclass && superclass.prototype);\n          Point.prototype.constructor = Point;\n          Point.fn = Point.prototype;\n          Point.fn.init = Point.fn.constructor;\n          var staticAccessors = {\n            ZERO: {}\n          };\n\n          Point.prototype.equals = function equals(other) {\n            return other && other.x === this.x && other.y === this.y;\n          };\n\n          Point.prototype.clone = function clone() {\n            return new Point(this.x, this.y);\n          };\n\n          Point.prototype.rotate = function rotate(angle, origin) {\n            var originPoint = Point.create(origin) || Point.ZERO;\n            return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\n          };\n\n          Point.prototype.translate = function translate(x, y) {\n            this.x += x;\n            this.y += y;\n            this.geometryChange();\n            return this;\n          };\n\n          Point.prototype.translateWith = function translateWith(point) {\n            return this.translate(point.x, point.y);\n          };\n\n          Point.prototype.move = function move(x, y) {\n            this.x = this.y = 0;\n            return this.translate(x, y);\n          };\n\n          Point.prototype.scale = function scale(scaleX, scaleY) {\n            if (scaleY === void 0) {\n              scaleY = scaleX;\n            }\n\n            this.x *= scaleX;\n            this.y *= scaleY;\n            this.geometryChange();\n            return this;\n          };\n\n          Point.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {\n            return this.clone().scale(scaleX, scaleY);\n          };\n\n          Point.prototype.transform = function transform(transformation) {\n            var matrix = toMatrix(transformation);\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n            this.x = matrix.a * x + matrix.c * y + matrix.e;\n            this.y = matrix.b * x + matrix.d * y + matrix.f;\n            this.geometryChange();\n            return this;\n          };\n\n          Point.prototype.transformCopy = function transformCopy(transformation) {\n            var point = this.clone();\n\n            if (transformation) {\n              point.transform(transformation);\n            }\n\n            return point;\n          };\n\n          Point.prototype.distanceTo = function distanceTo(point) {\n            var dx = this.x - point.x;\n            var dy = this.y - point.y;\n            return Math.sqrt(dx * dx + dy * dy);\n          };\n\n          Point.prototype.round = function round$1(digits) {\n            this.x = round(this.x, digits);\n            this.y = round(this.y, digits);\n            this.geometryChange();\n            return this;\n          };\n\n          Point.prototype.toArray = function toArray(digits) {\n            var doRound = defined(digits);\n            var x = doRound ? round(this.x, digits) : this.x;\n            var y = doRound ? round(this.y, digits) : this.y;\n            return [x, y];\n          };\n\n          Point.prototype.toString = function toString(digits, separator) {\n            if (separator === void 0) {\n              separator = \" \";\n            }\n\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n\n            if (defined(digits)) {\n              x = round(x, digits);\n              y = round(y, digits);\n            }\n\n            return x + separator + y;\n          };\n\n          Point.create = function create(arg0, arg1) {\n            if (defined(arg0)) {\n              if (arg0 instanceof Point) {\n                return arg0;\n              } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Point(arg0[0], arg0[1]);\n              }\n\n              return new Point(arg0, arg1);\n            }\n          };\n\n          Point.min = function min() {\n            var arguments$1 = arguments;\n            var minX = MAX_NUM;\n            var minY = MAX_NUM;\n\n            for (var i = 0; i < arguments.length; i++) {\n              var point = arguments$1[i];\n              minX = Math.min(point.x, minX);\n              minY = Math.min(point.y, minY);\n            }\n\n            return new Point(minX, minY);\n          };\n\n          Point.max = function max() {\n            var arguments$1 = arguments;\n            var maxX = MIN_NUM;\n            var maxY = MIN_NUM;\n\n            for (var i = 0; i < arguments.length; i++) {\n              var point = arguments$1[i];\n              maxX = Math.max(point.x, maxX);\n              maxY = Math.max(point.y, maxY);\n            }\n\n            return new Point(maxX, maxY);\n          };\n\n          Point.minPoint = function minPoint() {\n            return new Point(MIN_NUM, MIN_NUM);\n          };\n\n          Point.maxPoint = function maxPoint() {\n            return new Point(MAX_NUM, MAX_NUM);\n          };\n\n          staticAccessors.ZERO.get = function () {\n            return new Point(0, 0);\n          };\n\n          Object.defineProperties(Point, staticAccessors);\n          return Point;\n        }(withAccessors(HasObservers, [\"x\", \"y\"]));\n\n        var Size = function (superclass) {\n          function Size(width, height) {\n            superclass.call(this);\n            this.width = width || 0;\n            this.height = height || 0;\n          }\n\n          extendStatic(Size, superclass);\n          Size.prototype = Object.create(superclass && superclass.prototype);\n          Size.prototype.constructor = Size;\n          Size.fn = Size.prototype;\n          Size.fn.init = Size.fn.constructor;\n          var staticAccessors = {\n            ZERO: {}\n          };\n\n          Size.prototype.equals = function equals(other) {\n            return other && other.width === this.width && other.height === this.height;\n          };\n\n          Size.prototype.clone = function clone() {\n            return new Size(this.width, this.height);\n          };\n\n          Size.prototype.toArray = function toArray(digits) {\n            var doRound = defined(digits);\n            var width = doRound ? round(this.width, digits) : this.width;\n            var height = doRound ? round(this.height, digits) : this.height;\n            return [width, height];\n          };\n\n          Size.create = function create(arg0, arg1) {\n            if (defined(arg0)) {\n              if (arg0 instanceof Size) {\n                return arg0;\n              } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Size(arg0[0], arg0[1]);\n              }\n\n              return new Size(arg0, arg1);\n            }\n          };\n\n          staticAccessors.ZERO.get = function () {\n            return new Size(0, 0);\n          };\n\n          Object.defineProperties(Size, staticAccessors);\n          return Size;\n        }(withAccessors(HasObservers, [\"width\", \"height\"]));\n\n        var Rect = function (HasObservers$$1) {\n          function Rect(origin, size, cornerRadius) {\n            if (origin === void 0) {\n              origin = new Point();\n            }\n\n            if (size === void 0) {\n              size = new Size();\n            }\n\n            if (cornerRadius === void 0) {\n              cornerRadius = 0;\n            }\n\n            HasObservers$$1.call(this);\n            this.setOrigin(origin);\n            this.setSize(size);\n            this.setCornerRadius(cornerRadius);\n          }\n\n          extendStatic(Rect, HasObservers$$1);\n          Rect.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          Rect.prototype.constructor = Rect;\n          Rect.fn = Rect.prototype;\n          Rect.fn.init = Rect.fn.constructor;\n\n          Rect.prototype.clone = function clone() {\n            return new Rect(this.origin.clone(), this.size.clone());\n          };\n\n          Rect.prototype.equals = function equals(other) {\n            return other && other.origin.equals(this.origin) && other.size.equals(this.size);\n          };\n\n          Rect.prototype.setOrigin = function setOrigin(value) {\n            this._observerField(\"origin\", Point.create(value));\n\n            this.geometryChange();\n            return this;\n          };\n\n          Rect.prototype.getOrigin = function getOrigin() {\n            return this.origin;\n          };\n\n          Rect.prototype.setCornerRadius = function setCornerRadius(radius) {\n            this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];\n            this.geometryChange();\n            return this;\n          };\n\n          Rect.prototype.getCornerRadius = function getCornerRadius() {\n            return this.cornerRadius;\n          };\n\n          Rect.prototype.setSize = function setSize(value) {\n            this._observerField(\"size\", Size.create(value));\n\n            this.geometryChange();\n            return this;\n          };\n\n          Rect.prototype.getSize = function getSize() {\n            return this.size;\n          };\n\n          Rect.prototype.width = function width() {\n            return this.size.width;\n          };\n\n          Rect.prototype.height = function height() {\n            return this.size.height;\n          };\n\n          Rect.prototype.topLeft = function topLeft() {\n            return this.origin.clone();\n          };\n\n          Rect.prototype.bottomRight = function bottomRight() {\n            return this.origin.clone().translate(this.width(), this.height());\n          };\n\n          Rect.prototype.topRight = function topRight() {\n            return this.origin.clone().translate(this.width(), 0);\n          };\n\n          Rect.prototype.bottomLeft = function bottomLeft() {\n            return this.origin.clone().translate(0, this.height());\n          };\n\n          Rect.prototype.center = function center() {\n            return this.origin.clone().translate(this.width() / 2, this.height() / 2);\n          };\n\n          Rect.prototype.bbox = function bbox(matrix) {\n            var tl = this.topLeft().transformCopy(matrix);\n            var tr = this.topRight().transformCopy(matrix);\n            var br = this.bottomRight().transformCopy(matrix);\n            var bl = this.bottomLeft().transformCopy(matrix);\n            return Rect.fromPoints(tl, tr, br, bl);\n          };\n\n          Rect.prototype.transformCopy = function transformCopy(m) {\n            return Rect.fromPoints(this.topLeft().transform(m), this.bottomRight().transform(m));\n          };\n\n          Rect.prototype.expand = function expand(x, y) {\n            if (y === void 0) {\n              y = x;\n            }\n\n            this.size.width += 2 * x;\n            this.size.height += 2 * y;\n            this.origin.translate(-x, -y);\n            return this;\n          };\n\n          Rect.prototype.expandCopy = function expandCopy(x, y) {\n            return this.clone().expand(x, y);\n          };\n\n          Rect.prototype.containsPoint = function containsPoint(point) {\n            var origin = this.origin;\n            var bottomRight = this.bottomRight();\n            return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);\n          };\n\n          Rect.prototype._isOnPath = function _isOnPath(point, width) {\n            var rectOuter = this.expandCopy(width, width);\n            var rectInner = this.expandCopy(-width, -width);\n            return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);\n          };\n\n          Rect.fromPoints = function fromPoints() {\n            var topLeft = Point.min.apply(null, arguments);\n            var bottomRight = Point.max.apply(null, arguments);\n            var size = new Size(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n            return new Rect(topLeft, size);\n          };\n\n          Rect.union = function union(a, b) {\n            return Rect.fromPoints(Point.min(a.topLeft(), b.topLeft()), Point.max(a.bottomRight(), b.bottomRight()));\n          };\n\n          Rect.intersect = function intersect(a, b) {\n            var rect1 = {\n              left: a.topLeft().x,\n              top: a.topLeft().y,\n              right: a.bottomRight().x,\n              bottom: a.bottomRight().y\n            };\n            var rect2 = {\n              left: b.topLeft().x,\n              top: b.topLeft().y,\n              right: b.bottomRight().x,\n              bottom: b.bottomRight().y\n            };\n\n            if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {\n              return Rect.fromPoints(new Point(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)), new Point(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)));\n            }\n          };\n\n          return Rect;\n        }(HasObservers);\n\n        var Transformation = function (HasObservers$$1) {\n          function Transformation(matrix) {\n            if (matrix === void 0) {\n              matrix = Matrix.unit();\n            }\n\n            HasObservers$$1.call(this);\n            this._matrix = matrix;\n          }\n\n          extendStatic(Transformation, HasObservers$$1);\n          Transformation.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          Transformation.prototype.constructor = Transformation;\n          Transformation.fn = Transformation.prototype;\n          Transformation.fn.init = Transformation.fn.constructor;\n\n          Transformation.prototype.clone = function clone() {\n            return new Transformation(this._matrix.clone());\n          };\n\n          Transformation.prototype.equals = function equals(other) {\n            return other && other._matrix.equals(this._matrix);\n          };\n\n          Transformation.prototype.translate = function translate(x, y) {\n            this._matrix = this._matrix.multiplyCopy(Matrix.translate(x, y));\n\n            this._optionsChange();\n\n            return this;\n          };\n\n          Transformation.prototype.scale = function scale(scaleX, scaleY, origin) {\n            if (scaleY === void 0) {\n              scaleY = scaleX;\n            }\n\n            if (origin === void 0) {\n              origin = null;\n            }\n\n            var originPoint = origin;\n\n            if (originPoint) {\n              originPoint = Point.create(originPoint);\n              this._matrix = this._matrix.multiplyCopy(Matrix.translate(originPoint.x, originPoint.y));\n            }\n\n            this._matrix = this._matrix.multiplyCopy(Matrix.scale(scaleX, scaleY));\n\n            if (originPoint) {\n              this._matrix = this._matrix.multiplyCopy(Matrix.translate(-originPoint.x, -originPoint.y));\n            }\n\n            this._optionsChange();\n\n            return this;\n          };\n\n          Transformation.prototype.rotate = function rotate(angle, origin) {\n            var originPoint = Point.create(origin) || Point.ZERO;\n            this._matrix = this._matrix.multiplyCopy(Matrix.rotate(angle, originPoint.x, originPoint.y));\n\n            this._optionsChange();\n\n            return this;\n          };\n\n          Transformation.prototype.multiply = function multiply(transformation) {\n            var matrix = toMatrix(transformation);\n            this._matrix = this._matrix.multiplyCopy(matrix);\n\n            this._optionsChange();\n\n            return this;\n          };\n\n          Transformation.prototype.matrix = function matrix(value) {\n            if (value) {\n              this._matrix = value;\n\n              this._optionsChange();\n\n              return this;\n            }\n\n            return this._matrix;\n          };\n\n          Transformation.prototype._optionsChange = function _optionsChange() {\n            this.optionsChange({\n              field: \"transform\",\n              value: this\n            });\n          };\n\n          return Transformation;\n        }(HasObservers);\n\n        function transform$1(matrix) {\n          if (matrix === null) {\n            return null;\n          }\n\n          if (matrix instanceof Transformation) {\n            return matrix;\n          }\n\n          return new Transformation(matrix);\n        }\n\n        var Element$1 = function (HasObservers$$1) {\n          function Element(options) {\n            HasObservers$$1.call(this);\n\n            this._initOptions(options);\n          }\n\n          extendStatic(Element, HasObservers$$1);\n          Element.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          Element.prototype.constructor = Element;\n          Element.fn = Element.prototype;\n          Element.fn.init = Element.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Rect\";\n          };\n\n          Element.prototype._initOptions = function _initOptions(options) {\n            if (options === void 0) {\n              options = {};\n            }\n\n            var clip = options.clip;\n            var transform = options.transform;\n\n            if (transform) {\n              options.transform = transform$1(transform);\n            }\n\n            if (clip && !clip.id) {\n              clip.id = definitionId();\n            }\n\n            this.options = new OptionsStore(options);\n            this.options.addObserver(this);\n          };\n\n          Element.prototype.transform = function transform(value) {\n            if (defined(value)) {\n              this.options.set(\"transform\", transform$1(value));\n            } else {\n              return this.options.get(\"transform\");\n            }\n          };\n\n          Element.prototype.parentTransform = function parentTransform() {\n            var element = this;\n            var parentMatrix;\n\n            while (element.parent) {\n              element = element.parent;\n              var transformation = element.transform();\n\n              if (transformation) {\n                parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\n              }\n            }\n\n            if (parentMatrix) {\n              return transform$1(parentMatrix);\n            }\n          };\n\n          Element.prototype.currentTransform = function currentTransform(parentTransform) {\n            if (parentTransform === void 0) {\n              parentTransform = this.parentTransform();\n            }\n\n            var elementTransform = this.transform();\n            var elementMatrix = toMatrix(elementTransform);\n            var parentMatrix = toMatrix(parentTransform);\n            var combinedMatrix;\n\n            if (elementMatrix && parentMatrix) {\n              combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n            } else {\n              combinedMatrix = elementMatrix || parentMatrix;\n            }\n\n            if (combinedMatrix) {\n              return transform$1(combinedMatrix);\n            }\n          };\n\n          Element.prototype.visible = function visible(value) {\n            if (defined(value)) {\n              this.options.set(\"visible\", value);\n              return this;\n            }\n\n            return this.options.get(\"visible\") !== false;\n          };\n\n          Element.prototype.clip = function clip(value) {\n            var options = this.options;\n\n            if (defined(value)) {\n              if (value && !value.id) {\n                value.id = definitionId();\n              }\n\n              options.set(\"clip\", value);\n              return this;\n            }\n\n            return options.get(\"clip\");\n          };\n\n          Element.prototype.opacity = function opacity(value) {\n            if (defined(value)) {\n              this.options.set(\"opacity\", value);\n              return this;\n            }\n\n            return valueOrDefault(this.options.get(\"opacity\"), 1);\n          };\n\n          Element.prototype.clippedBBox = function clippedBBox(transformation) {\n            var bbox = this._clippedBBox(transformation);\n\n            if (bbox) {\n              var clip = this.clip();\n              return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\n            }\n          };\n\n          Element.prototype.containsPoint = function containsPoint(point, parentTransform) {\n            if (this.visible()) {\n              var transform = this.currentTransform(parentTransform);\n              var transformedPoint = point;\n\n              if (transform) {\n                transformedPoint = point.transformCopy(transform.matrix().invert());\n              }\n\n              return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);\n            }\n\n            return false;\n          };\n\n          Element.prototype._hasFill = function _hasFill() {\n            var fill = this.options.fill;\n            return fill && !isTransparent(fill.color);\n          };\n\n          Element.prototype._hasStroke = function _hasStroke() {\n            var stroke = this.options.stroke;\n            return stroke && stroke.width > 0 && !isTransparent(stroke.color);\n          };\n\n          Element.prototype._clippedBBox = function _clippedBBox(transformation) {\n            return this.bbox(transformation);\n          };\n\n          Object.defineProperties(Element.prototype, prototypeAccessors);\n          return Element;\n        }(HasObservers);\n\n        function ellipseExtremeAngles(center, rx, ry, matrix) {\n          var extremeX = 0;\n          var extremeY = 0;\n\n          if (matrix) {\n            extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);\n\n            if (matrix.b !== 0) {\n              extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);\n            }\n          }\n\n          return {\n            x: extremeX,\n            y: extremeY\n          };\n        }\n\n        var PI_DIV_2 = Math.PI / 2;\n\n        var Circle$2 = function (superclass) {\n          function Circle(center, radius) {\n            if (center === void 0) {\n              center = new Point();\n            }\n\n            if (radius === void 0) {\n              radius = 0;\n            }\n\n            superclass.call(this);\n            this.setCenter(center);\n            this.setRadius(radius);\n          }\n\n          extendStatic(Circle, superclass);\n          Circle.prototype = Object.create(superclass && superclass.prototype);\n          Circle.prototype.constructor = Circle;\n          Circle.fn = Circle.prototype;\n          Circle.fn.init = Circle.fn.constructor;\n\n          Circle.prototype.setCenter = function setCenter(value) {\n            this._observerField(\"center\", Point.create(value));\n\n            this.geometryChange();\n            return this;\n          };\n\n          Circle.prototype.getCenter = function getCenter() {\n            return this.center;\n          };\n\n          Circle.prototype.equals = function equals(other) {\n            return other && other.center.equals(this.center) && other.radius === this.radius;\n          };\n\n          Circle.prototype.clone = function clone() {\n            return new Circle(this.center.clone(), this.radius);\n          };\n\n          Circle.prototype.pointAt = function pointAt(angle) {\n            return this._pointAt(rad(angle));\n          };\n\n          Circle.prototype.bbox = function bbox(matrix) {\n            var this$1 = this;\n            var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n            var minPoint = Point.maxPoint();\n            var maxPoint = Point.minPoint();\n\n            for (var i = 0; i < 4; i++) {\n              var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n\n              var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n\n              var currentPoint = new Point(currentPointX.x, currentPointY.y);\n              minPoint = Point.min(minPoint, currentPoint);\n              maxPoint = Point.max(maxPoint, currentPoint);\n            }\n\n            return Rect.fromPoints(minPoint, maxPoint);\n          };\n\n          Circle.prototype._pointAt = function _pointAt(angle) {\n            var ref = this;\n            var center = ref.center;\n            var radius = ref.radius;\n            return new Point(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n          };\n\n          Circle.prototype.containsPoint = function containsPoint(point) {\n            var ref = this;\n            var center = ref.center;\n            var radius = ref.radius;\n            var inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n            return inCircle;\n          };\n\n          Circle.prototype._isOnPath = function _isOnPath(point, width) {\n            var ref = this;\n            var center = ref.center;\n            var radius = ref.radius;\n            var pointDistance = center.distanceTo(point);\n            return radius - width <= pointDistance && pointDistance <= radius + width;\n          };\n\n          return Circle;\n        }(withAccessors(HasObservers, [\"radius\"]));\n\n        var GRADIENT = \"Gradient\";\n\n        var paintable = function (TBase) {\n          return function (TBase) {\n            function anonymous() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(anonymous, TBase);\n            anonymous.prototype = Object.create(TBase && TBase.prototype);\n            anonymous.prototype.constructor = anonymous;\n            anonymous.fn = anonymous.prototype;\n            anonymous.fn.init = anonymous.fn.constructor;\n\n            anonymous.prototype.fill = function fill(color, opacity) {\n              var options = this.options;\n\n              if (defined(color)) {\n                if (color && color.nodeType !== GRADIENT) {\n                  var newFill = {\n                    color: color\n                  };\n\n                  if (defined(opacity)) {\n                    newFill.opacity = opacity;\n                  }\n\n                  options.set(\"fill\", newFill);\n                } else {\n                  options.set(\"fill\", color);\n                }\n\n                return this;\n              }\n\n              return options.get(\"fill\");\n            };\n\n            anonymous.prototype.stroke = function stroke(color, width, opacity) {\n              if (defined(color)) {\n                this.options.set(\"stroke.color\", color);\n\n                if (defined(width)) {\n                  this.options.set(\"stroke.width\", width);\n                }\n\n                if (defined(opacity)) {\n                  this.options.set(\"stroke.opacity\", opacity);\n                }\n\n                return this;\n              }\n\n              return this.options.get(\"stroke\");\n            };\n\n            return anonymous;\n          }(TBase);\n        };\n\n        var IDENTITY_MATRIX_HASH = Matrix.IDENTITY.toString();\n\n        var measurable = function (TBase) {\n          return function (TBase) {\n            function anonymous() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(anonymous, TBase);\n            anonymous.prototype = Object.create(TBase && TBase.prototype);\n            anonymous.prototype.constructor = anonymous;\n            anonymous.fn = anonymous.prototype;\n            anonymous.fn.init = anonymous.fn.constructor;\n\n            anonymous.prototype.bbox = function bbox(transformation) {\n              var combinedMatrix = toMatrix(this.currentTransform(transformation));\n              var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;\n              var bbox;\n\n              if (this._bboxCache && this._matrixHash === matrixHash) {\n                bbox = this._bboxCache.clone();\n              } else {\n                bbox = this._bbox(combinedMatrix);\n                this._bboxCache = bbox ? bbox.clone() : null;\n                this._matrixHash = matrixHash;\n              }\n\n              var strokeWidth = this.options.get(\"stroke.width\");\n\n              if (strokeWidth && bbox) {\n                bbox.expand(strokeWidth / 2);\n              }\n\n              return bbox;\n            };\n\n            anonymous.prototype.geometryChange = function geometryChange() {\n              delete this._bboxCache;\n              this.trigger(\"geometryChange\", {\n                element: this\n              });\n            };\n\n            return anonymous;\n          }(TBase);\n        };\n\n        function geometryAccessor(name) {\n          var fieldName = \"_\" + name;\n          return function (value) {\n            if (defined(value)) {\n              this._observerField(fieldName, value);\n\n              this.geometryChange();\n              return this;\n            }\n\n            return this[fieldName];\n          };\n        }\n\n        function defineGeometryAccessors(fn, names) {\n          for (var i = 0; i < names.length; i++) {\n            fn[names[i]] = geometryAccessor(names[i]);\n          }\n        }\n\n        var withGeometry = function (TBase, names) {\n          if (names === void 0) {\n            names = [\"geometry\"];\n          }\n\n          var result = function (TBase) {\n            function result() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(result, TBase);\n            result.prototype = Object.create(TBase && TBase.prototype);\n            result.prototype.constructor = result;\n            result.fn = result.prototype;\n            result.fn.init = result.fn.constructor;\n            return result;\n          }(TBase);\n\n          defineGeometryAccessors(result.prototype, names);\n          return result;\n        };\n\n        var DEFAULT_STROKE = \"#000\";\n\n        var Circle = function (superclass) {\n          function Circle(geometry, options) {\n            if (geometry === void 0) {\n              geometry = new Circle$2();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.geometry(geometry);\n\n            if (!defined(this.options.stroke)) {\n              this.stroke(DEFAULT_STROKE);\n            }\n          }\n\n          extendStatic(Circle, superclass);\n          Circle.prototype = Object.create(superclass && superclass.prototype);\n          Circle.prototype.constructor = Circle;\n          Circle.fn = Circle.prototype;\n          Circle.fn.init = Circle.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Circle\";\n          };\n\n          Circle.prototype.rawBBox = function rawBBox() {\n            return this._geometry.bbox();\n          };\n\n          Circle.prototype._bbox = function _bbox(matrix) {\n            return this._geometry.bbox(matrix);\n          };\n\n          Circle.prototype._containsPoint = function _containsPoint(point) {\n            return this.geometry().containsPoint(point);\n          };\n\n          Circle.prototype._isOnPath = function _isOnPath(point) {\n            return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n          };\n\n          Object.defineProperties(Circle.prototype, prototypeAccessors);\n          return Circle;\n        }(paintable(measurable(withGeometry(Element$1))));\n\n        var PRECISION = 10;\n\n        function close$1(a, b, tolerance) {\n          if (tolerance === void 0) {\n            tolerance = PRECISION;\n          }\n\n          return round(Math.abs(a - b), tolerance) === 0;\n        }\n\n        function closeOrLess(a, b, tolerance) {\n          return a < b || close$1(a, b, tolerance);\n        }\n\n        function lineIntersection(p0, p1, p2, p3) {\n          var s1x = p1.x - p0.x;\n          var s2x = p3.x - p2.x;\n          var s1y = p1.y - p0.y;\n          var s2y = p3.y - p2.y;\n          var nx = p0.x - p2.x;\n          var ny = p0.y - p2.y;\n          var d = s1x * s2y - s2x * s1y;\n          var s = (s1x * ny - s1y * nx) / d;\n          var t = (s2x * ny - s2y * nx) / d;\n\n          if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n            return new Point(p0.x + t * s1x, p0.y + t * s1y);\n          }\n        }\n\n        var MAX_INTERVAL = 45;\n        var pow$1 = Math.pow;\n        var accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\n\n        var Arc$2 = function (superclass) {\n          function Arc(center, options) {\n            if (center === void 0) {\n              center = new Point();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this);\n            this.setCenter(center);\n            this.radiusX = options.radiusX;\n            this.radiusY = options.radiusY || options.radiusX;\n            this.startAngle = options.startAngle;\n            this.endAngle = options.endAngle;\n            this.anticlockwise = options.anticlockwise || false;\n            this.xRotation = options.xRotation;\n          }\n\n          extendStatic(Arc, superclass);\n          Arc.prototype = Object.create(superclass && superclass.prototype);\n          Arc.prototype.constructor = Arc;\n          Arc.fn = Arc.prototype;\n          Arc.fn.init = Arc.fn.constructor;\n\n          Arc.prototype.clone = function clone() {\n            return new Arc(this.center, {\n              radiusX: this.radiusX,\n              radiusY: this.radiusY,\n              startAngle: this.startAngle,\n              endAngle: this.endAngle,\n              anticlockwise: this.anticlockwise\n            });\n          };\n\n          Arc.prototype.setCenter = function setCenter(value) {\n            this._observerField(\"center\", Point.create(value));\n\n            this.geometryChange();\n            return this;\n          };\n\n          Arc.prototype.getCenter = function getCenter() {\n            return this.center;\n          };\n\n          Arc.prototype.pointAt = function pointAt(angle) {\n            var center = this.center;\n            var radian = rad(angle);\n            return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n          };\n\n          Arc.prototype.curvePoints = function curvePoints() {\n            var this$1 = this;\n            var startAngle = this.startAngle;\n            var dir = this.anticlockwise ? -1 : 1;\n            var curvePoints = [this.pointAt(startAngle)];\n\n            var interval = this._arcInterval();\n\n            var intervalAngle = interval.endAngle - interval.startAngle;\n            var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n            var subIntervalAngle = intervalAngle / subIntervalsCount;\n            var currentAngle = startAngle;\n            var transformation;\n\n            if (this.xRotation) {\n              transformation = transform$1().rotate(this.xRotation, this.center);\n            }\n\n            for (var i = 1; i <= subIntervalsCount; i++) {\n              var nextAngle = currentAngle + dir * subIntervalAngle;\n\n              var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n              curvePoints.push(points.cp1, points.cp2, points.p2);\n              currentAngle = nextAngle;\n            }\n\n            return curvePoints;\n          };\n\n          Arc.prototype.bbox = function bbox(matrix) {\n            var this$1 = this;\n\n            var interval = this._arcInterval();\n\n            var startAngle = interval.startAngle;\n            var endAngle = interval.endAngle;\n            var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n            var extremeX = deg(extremeAngles.x);\n            var extremeY = deg(extremeAngles.y);\n            var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n            var currentAngleX = bboxStartAngle(extremeX, startAngle);\n            var currentAngleY = bboxStartAngle(extremeY, startAngle);\n            var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n            var minPoint = Point.min(currentPoint, endPoint);\n            var maxPoint = Point.max(currentPoint, endPoint);\n\n            while (currentAngleX < endAngle || currentAngleY < endAngle) {\n              var currentPointX = void 0;\n\n              if (currentAngleX < endAngle) {\n                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n              }\n\n              var currentPointY = void 0;\n\n              if (currentAngleY < endAngle) {\n                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n              }\n\n              currentPoint = new Point(currentPointX.x, currentPointY.y);\n              minPoint = Point.min(minPoint, currentPoint);\n              maxPoint = Point.max(maxPoint, currentPoint);\n            }\n\n            return Rect.fromPoints(minPoint, maxPoint);\n          };\n\n          Arc.prototype._arcInterval = function _arcInterval() {\n            var ref = this;\n            var startAngle = ref.startAngle;\n            var endAngle = ref.endAngle;\n            var anticlockwise = ref.anticlockwise;\n\n            if (anticlockwise) {\n              var oldStart = startAngle;\n              startAngle = endAngle;\n              endAngle = oldStart;\n            }\n\n            if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n              endAngle += 360;\n            }\n\n            return {\n              startAngle: startAngle,\n              endAngle: endAngle\n            };\n          };\n\n          Arc.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {\n            var p1 = this.pointAt(startAngle);\n            var p2 = this.pointAt(endAngle);\n\n            var p1Derivative = this._derivativeAt(startAngle);\n\n            var p2Derivative = this._derivativeAt(endAngle);\n\n            var t = (rad(endAngle) - rad(startAngle)) / 3;\n            var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n            var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n            if (transformation) {\n              p1.transform(transformation);\n              p2.transform(transformation);\n              cp1.transform(transformation);\n              cp2.transform(transformation);\n            }\n\n            return {\n              p1: p1,\n              cp1: cp1,\n              cp2: cp2,\n              p2: p2\n            };\n          };\n\n          Arc.prototype._derivativeAt = function _derivativeAt(angle) {\n            var radian = rad(angle);\n            return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n          };\n\n          Arc.prototype.containsPoint = function containsPoint(point) {\n            var interval = this._arcInterval();\n\n            var intervalAngle = interval.endAngle - interval.startAngle;\n            var ref = this;\n            var center = ref.center;\n            var radiusX = ref.radiusX;\n            var radiusY = ref.radiusY;\n            var distance = center.distanceTo(point);\n            var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n            var pointRadius = radiusX * radiusY / Math.sqrt(pow$1(radiusX, 2) * pow$1(Math.sin(angleRad), 2) + pow$1(radiusY, 2) * pow$1(Math.cos(angleRad), 2));\n            var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n            var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n            var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n            var containsPoint;\n\n            if (intervalAngle < 180) {\n              containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n            } else {\n              var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n              if (angle !== 360) {\n                angle = (360 + angle) % 360;\n              }\n\n              var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n              containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n            }\n\n            return containsPoint;\n          };\n\n          Arc.prototype._isOnPath = function _isOnPath(point, width) {\n            var interval = this._arcInterval();\n\n            var center = this.center;\n            var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n            if (angle !== 360) {\n              angle = (360 + angle) % 360;\n            }\n\n            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n          };\n\n          Arc.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n            // eslint-disable-line max-params\n            var arcParameters = normalizeArcParameters({\n              x1: start.x,\n              y1: start.y,\n              x2: end.x,\n              y2: end.y,\n              rx: rx,\n              ry: ry,\n              largeArc: largeArc,\n              swipe: swipe,\n              rotation: rotation\n            });\n            return new Arc(arcParameters.center, {\n              startAngle: arcParameters.startAngle,\n              endAngle: arcParameters.endAngle,\n              radiusX: arcParameters.radiusX,\n              radiusY: arcParameters.radiusY,\n              xRotation: arcParameters.xRotation,\n              anticlockwise: swipe === 0\n            });\n          };\n\n          return Arc;\n        }(withAccessors(HasObservers, accessors));\n\n        function calculateAngle(cx, cy, rx, ry, x, y) {\n          var cos = round((x - cx) / rx, 3);\n          var sin = round((y - cy) / ry, 3);\n          return round(deg(Math.atan2(sin, cos)));\n        }\n\n        function normalizeArcParameters(parameters) {\n          var x1 = parameters.x1;\n          var y1 = parameters.y1;\n          var x2 = parameters.x2;\n          var y2 = parameters.y2;\n          var rx = parameters.rx;\n          var ry = parameters.ry;\n          var largeArc = parameters.largeArc;\n          var swipe = parameters.swipe;\n          var rotation = parameters.rotation;\n\n          if (rotation === void 0) {\n            rotation = 0;\n          }\n\n          var radians = rad(rotation);\n          var cosine = Math.cos(radians);\n          var sine = Math.sin(radians);\n          var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n          var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n          var sign = largeArc !== swipe ? 1 : -1;\n          var xt2 = Math.pow(xT, 2);\n          var yt2 = Math.pow(yT, 2);\n          var rx2 = Math.pow(rx, 2);\n          var ry2 = Math.pow(ry, 2);\n          var delta = xt2 / rx2 + yt2 / ry2;\n\n          if (delta > 1) {\n            delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n            rx = delta * rx;\n            rx2 = Math.pow(rx, 2);\n            ry = delta * ry;\n            ry2 = Math.pow(ry, 2);\n          }\n\n          var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n          if (isNaN(constT)) {\n            constT = 0;\n          }\n\n          var cxT = constT * (rx * yT) / ry;\n          var cyT = -constT * (ry * xT) / rx;\n          var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n          var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n          var uX = (xT - cxT) / rx;\n          var uY = (yT - cyT) / ry;\n          var vX = -(xT + cxT) / rx;\n          var vY = -(yT + cyT) / ry;\n          var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n          var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n          var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n          if (!swipe && angle > 0) {\n            angle -= 360;\n          }\n\n          if (swipe && angle < 0) {\n            angle += 360;\n          }\n\n          var endAngle = startAngle + angle;\n          var signEndAngle = endAngle >= 0 ? 1 : -1;\n          endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n          return {\n            center: new Point(cx, cy),\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: rx,\n            radiusY: ry,\n            xRotation: rotation\n          };\n        }\n\n        function bboxStartAngle(angle, start) {\n          var startAngle = angle;\n\n          while (startAngle < start) {\n            startAngle += 90;\n          }\n\n          return startAngle;\n        }\n\n        var push = [].push;\n        var pop = [].pop;\n        var splice = [].splice;\n        var shift = [].shift;\n        var slice = [].slice;\n        var unshift = [].unshift;\n\n        var ElementsArray = function (HasObservers$$1) {\n          function ElementsArray(array) {\n            if (array === void 0) {\n              array = [];\n            }\n\n            HasObservers$$1.call(this);\n            this.length = 0;\n\n            this._splice(0, array.length, array);\n          }\n\n          extendStatic(ElementsArray, HasObservers$$1);\n          ElementsArray.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          ElementsArray.prototype.constructor = ElementsArray;\n          ElementsArray.fn = ElementsArray.prototype;\n          ElementsArray.fn.init = ElementsArray.fn.constructor;\n\n          ElementsArray.prototype.elements = function elements(value) {\n            if (value) {\n              this._splice(0, this.length, value);\n\n              this._change();\n\n              return this;\n            }\n\n            return this.slice(0);\n          };\n\n          ElementsArray.prototype.push = function push$1() {\n            var elements = arguments;\n            var result = push.apply(this, elements);\n\n            this._add(elements);\n\n            return result;\n          };\n\n          ElementsArray.prototype.slice = function slice$1() {\n            return slice.call(this);\n          };\n\n          ElementsArray.prototype.pop = function pop$1() {\n            var length = this.length;\n            var result = pop.apply(this);\n\n            if (length) {\n              this._remove([result]);\n            }\n\n            return result;\n          };\n\n          ElementsArray.prototype.splice = function splice$1(index, howMany) {\n            var elements = slice.call(arguments, 2);\n\n            var result = this._splice(index, howMany, elements);\n\n            this._change();\n\n            return result;\n          };\n\n          ElementsArray.prototype.shift = function shift$1() {\n            var length = this.length;\n            var result = shift.apply(this);\n\n            if (length) {\n              this._remove([result]);\n            }\n\n            return result;\n          };\n\n          ElementsArray.prototype.unshift = function unshift$1() {\n            var elements = arguments;\n            var result = unshift.apply(this, elements);\n\n            this._add(elements);\n\n            return result;\n          };\n\n          ElementsArray.prototype.indexOf = function indexOf(element) {\n            var this$1 = this;\n            var length = this.length;\n\n            for (var idx = 0; idx < length; idx++) {\n              if (this$1[idx] === element) {\n                return idx;\n              }\n            }\n\n            return -1;\n          };\n\n          ElementsArray.prototype._splice = function _splice(index, howMany, elements) {\n            var result = splice.apply(this, [index, howMany].concat(elements));\n\n            this._clearObserver(result);\n\n            this._setObserver(elements);\n\n            return result;\n          };\n\n          ElementsArray.prototype._add = function _add(elements) {\n            this._setObserver(elements);\n\n            this._change();\n          };\n\n          ElementsArray.prototype._remove = function _remove(elements) {\n            this._clearObserver(elements);\n\n            this._change();\n          };\n\n          ElementsArray.prototype._setObserver = function _setObserver(elements) {\n            var this$1 = this;\n\n            for (var idx = 0; idx < elements.length; idx++) {\n              elements[idx].addObserver(this$1);\n            }\n          };\n\n          ElementsArray.prototype._clearObserver = function _clearObserver(elements) {\n            var this$1 = this;\n\n            for (var idx = 0; idx < elements.length; idx++) {\n              elements[idx].removeObserver(this$1);\n            }\n          };\n\n          ElementsArray.prototype._change = function _change() {};\n\n          return ElementsArray;\n        }(HasObservers);\n\n        var GeometryElementsArray = function (ElementsArray$$1) {\n          function GeometryElementsArray() {\n            ElementsArray$$1.apply(this, arguments);\n          }\n\n          extendStatic(GeometryElementsArray, ElementsArray$$1);\n          GeometryElementsArray.prototype = Object.create(ElementsArray$$1 && ElementsArray$$1.prototype);\n          GeometryElementsArray.prototype.constructor = GeometryElementsArray;\n          GeometryElementsArray.fn = GeometryElementsArray.prototype;\n          GeometryElementsArray.fn.init = GeometryElementsArray.fn.constructor;\n\n          GeometryElementsArray.prototype._change = function _change() {\n            this.geometryChange();\n          };\n\n          return GeometryElementsArray;\n        }(ElementsArray);\n\n        function isOutOfEndPoint(endPoint, controlPoint, point) {\n          var angle = deg(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));\n          var rotatedPoint = point.transformCopy(transform$1().rotate(-angle, endPoint));\n          return rotatedPoint.x < endPoint.x;\n        }\n\n        function calculateCurveAt(t, field, points) {\n          var t1 = 1 - t;\n          return Math.pow(t1, 3) * points[0][field] + 3 * Math.pow(t1, 2) * t * points[1][field] + 3 * Math.pow(t, 2) * t1 * points[2][field] + Math.pow(t, 3) * points[3][field];\n        }\n\n        function toCubicPolynomial(points, field) {\n          return [-points[0][field] + 3 * points[1][field] - 3 * points[2][field] + points[3][field], 3 * (points[0][field] - 2 * points[1][field] + points[2][field]), 3 * (-points[0][field] + points[1][field]), points[0][field]];\n        }\n\n        var ComplexNumber = function (Class$$1) {\n          function ComplexNumber(real, img) {\n            if (real === void 0) {\n              real = 0;\n            }\n\n            if (img === void 0) {\n              img = 0;\n            }\n\n            Class$$1.call(this);\n            this.real = real;\n            this.img = img;\n          }\n\n          extendStatic(ComplexNumber, Class$$1);\n          ComplexNumber.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          ComplexNumber.prototype.constructor = ComplexNumber;\n          ComplexNumber.fn = ComplexNumber.prototype;\n          ComplexNumber.fn.init = ComplexNumber.fn.constructor;\n\n          ComplexNumber.prototype.add = function add(cNumber) {\n            return new ComplexNumber(round(this.real + cNumber.real, PRECISION), round(this.img + cNumber.img, PRECISION));\n          };\n\n          ComplexNumber.prototype.addConstant = function addConstant(value) {\n            return new ComplexNumber(this.real + value, this.img);\n          };\n\n          ComplexNumber.prototype.negate = function negate() {\n            return new ComplexNumber(-this.real, -this.img);\n          };\n\n          ComplexNumber.prototype.multiply = function multiply(cNumber) {\n            return new ComplexNumber(this.real * cNumber.real - this.img * cNumber.img, this.real * cNumber.img + this.img * cNumber.real);\n          };\n\n          ComplexNumber.prototype.multiplyConstant = function multiplyConstant(value) {\n            return new ComplexNumber(this.real * value, this.img * value);\n          };\n\n          ComplexNumber.prototype.nthRoot = function nthRoot(n) {\n            var rad$$1 = Math.atan2(this.img, this.real);\n            var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));\n            var nthR = Math.pow(r, 1 / n);\n            return new ComplexNumber(nthR * Math.cos(rad$$1 / n), nthR * Math.sin(rad$$1 / n)); //Moivre's formula\n          };\n\n          ComplexNumber.prototype.equals = function equals(cNumber) {\n            return this.real === cNumber.real && this.img === cNumber.img;\n          };\n\n          ComplexNumber.prototype.isReal = function isReal() {\n            return this.img === 0;\n          };\n\n          return ComplexNumber;\n        }(Class);\n\n        function numberSign(x) {\n          return x < 0 ? -1 : 1;\n        }\n\n        function solveQuadraticEquation(a, b, c) {\n          var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);\n          return [(-b + squareRoot) / (2 * a), (-b - squareRoot) / (2 * a)];\n        } //Cardano's formula\n\n\n        function solveCubicEquation(a, b, c, d) {\n          if (a === 0) {\n            return solveQuadraticEquation(b, c, d);\n          }\n\n          var p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));\n          var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));\n          var Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);\n          var i = new ComplexNumber(0, 1);\n          var b3a = -b / (3 * a);\n          var x1, x2, y1, y2, y3, z1, z2;\n\n          if (Q < 0) {\n            x1 = new ComplexNumber(-q / 2, Math.sqrt(-Q)).nthRoot(3);\n            x2 = new ComplexNumber(-q / 2, -Math.sqrt(-Q)).nthRoot(3);\n          } else {\n            x1 = -q / 2 + Math.sqrt(Q);\n            x1 = new ComplexNumber(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));\n            x2 = -q / 2 - Math.sqrt(Q);\n            x2 = new ComplexNumber(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));\n          }\n\n          y1 = x1.add(x2);\n          z1 = x1.add(x2).multiplyConstant(-1 / 2);\n          z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);\n          y2 = z1.add(i.multiply(z2));\n          y3 = z1.add(i.negate().multiply(z2));\n          var result = [];\n\n          if (y1.isReal()) {\n            result.push(round(y1.real + b3a, PRECISION));\n          }\n\n          if (y2.isReal()) {\n            result.push(round(y2.real + b3a, PRECISION));\n          }\n\n          if (y3.isReal()) {\n            result.push(round(y3.real + b3a, PRECISION));\n          }\n\n          return result;\n        }\n\n        function hasRootsInRange(points, point, field, rootField, range) {\n          var polynomial = toCubicPolynomial(points, rootField);\n          var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point[rootField]);\n          var intersection;\n\n          for (var idx = 0; idx < roots.length; idx++) {\n            if (0 <= roots[idx] && roots[idx] <= 1) {\n              intersection = calculateCurveAt(roots[idx], field, points);\n\n              if (Math.abs(intersection - point[field]) <= range) {\n                return true;\n              }\n            }\n          }\n        }\n\n        function curveIntersectionsCount(points, point, bbox) {\n          var polynomial = toCubicPolynomial(points, \"x\");\n          var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point.x);\n          var rayIntersection, intersectsRay;\n          var count = 0;\n\n          for (var i = 0; i < roots.length; i++) {\n            rayIntersection = calculateCurveAt(roots[i], \"y\", points);\n            intersectsRay = close$1(rayIntersection, point.y) || rayIntersection > point.y;\n\n            if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point.x || 0 < roots[i] && roots[i] < 1)) {\n              count++;\n            }\n          }\n\n          return count;\n        }\n\n        function lineIntersectionsCount(a, b, point) {\n          var intersects;\n\n          if (a.x !== b.x) {\n            var minX = Math.min(a.x, b.x);\n            var maxX = Math.max(a.x, b.x);\n            var minY = Math.min(a.y, b.y);\n            var maxY = Math.max(a.y, b.y);\n            var inRange = minX <= point.x && point.x < maxX;\n\n            if (minY === maxY) {\n              intersects = point.y <= minY && inRange;\n            } else {\n              intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point.x - minX : maxX - point.x) / (maxX - minX) + minY - point.y >= 0;\n            }\n          }\n\n          return intersects ? 1 : 0;\n        }\n\n        function pointAccessor(name) {\n          var fieldName = \"_\" + name;\n          return function (value) {\n            if (defined(value)) {\n              this._observerField(fieldName, Point.create(value));\n\n              this.geometryChange();\n              return this;\n            }\n\n            return this[fieldName];\n          };\n        }\n\n        function definePointAccessors(fn, names) {\n          for (var i = 0; i < names.length; i++) {\n            fn[names[i]] = pointAccessor(names[i]);\n          }\n        }\n\n        var withPoints = function (TBase, names) {\n          var result = function (TBase) {\n            function result() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(result, TBase);\n            result.prototype = Object.create(TBase && TBase.prototype);\n            result.prototype.constructor = result;\n            result.fn = result.prototype;\n            result.fn.init = result.fn.constructor;\n            return result;\n          }(TBase);\n\n          definePointAccessors(result.prototype, names);\n          return result;\n        };\n\n        var points = [\"anchor\", \"controlIn\", \"controlOut\"];\n\n        var Segment = function (superclass) {\n          function Segment(anchor, controlIn, controlOut) {\n            superclass.call(this);\n            this.anchor(anchor || new Point());\n            this.controlIn(controlIn);\n            this.controlOut(controlOut);\n          }\n\n          extendStatic(Segment, superclass);\n          Segment.prototype = Object.create(superclass && superclass.prototype);\n          Segment.prototype.constructor = Segment;\n          Segment.fn = Segment.prototype;\n          Segment.fn.init = Segment.fn.constructor;\n\n          Segment.prototype.bboxTo = function bboxTo(toSegment, matrix) {\n            var segmentAnchor = this.anchor().transformCopy(matrix);\n            var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n            var rect;\n\n            if (this.controlOut() && toSegment.controlIn()) {\n              rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n            } else {\n              rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n            }\n\n            return rect;\n          };\n\n          Segment.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {\n            return Rect.fromPoints(p1, p2);\n          };\n\n          Segment.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {\n            var points = [p1, cp1, cp2, p2];\n\n            var extremesX = this._curveExtremesFor(points, \"x\");\n\n            var extremesY = this._curveExtremesFor(points, \"y\");\n\n            var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n            var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n            return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n          };\n\n          Segment.prototype._curveExtremesFor = function _curveExtremesFor(points, field) {\n            var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n            return {\n              min: calculateCurveAt(extremes.min, field, points),\n              max: calculateCurveAt(extremes.max, field, points)\n            };\n          };\n\n          Segment.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {\n            var a = x1 - 3 * x2 + 3 * x3 - x4;\n            var b = -2 * (x1 - 2 * x2 + x3);\n            var c = x1 - x2;\n            var sqrt = Math.sqrt(b * b - 4 * a * c);\n            var t1 = 0;\n            var t2 = 1;\n\n            if (a === 0) {\n              if (b !== 0) {\n                t1 = t2 = -c / b;\n              }\n            } else if (!isNaN(sqrt)) {\n              t1 = (-b + sqrt) / (2 * a);\n              t2 = (-b - sqrt) / (2 * a);\n            }\n\n            var min = Math.max(Math.min(t1, t2), 0);\n\n            if (min < 0 || min > 1) {\n              min = 0;\n            }\n\n            var max = Math.min(Math.max(t1, t2), 1);\n\n            if (max > 1 || max < 0) {\n              max = 1;\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          };\n\n          Segment.prototype._intersectionsTo = function _intersectionsTo(segment, point) {\n            var intersectionsCount;\n\n            if (this.controlOut() && segment.controlIn()) {\n              intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n            } else {\n              intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n            }\n\n            return intersectionsCount;\n          };\n\n          Segment.prototype._isOnCurveTo = function _isOnCurveTo(segment, point, width, endSegment) {\n            var bbox = this.bboxTo(segment).expand(width, width);\n\n            if (bbox.containsPoint(point)) {\n              var p1 = this.anchor();\n              var p2 = this.controlOut();\n              var p3 = segment.controlIn();\n              var p4 = segment.anchor();\n\n              if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n              } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n              } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n              var points = [p1, p2, p3, p4];\n\n              if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n              }\n\n              var rotation = transform$1().rotate(45, point);\n              var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n              return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n            }\n          };\n\n          Segment.prototype._isOnLineTo = function _isOnLineTo(segment, point, width) {\n            var p1 = this.anchor();\n            var p2 = segment.anchor();\n            var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n            var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n            return rect.containsPoint(point.transformCopy(transform$1().rotate(-angle, p1)));\n          };\n\n          Segment.prototype._isOnPathTo = function _isOnPathTo(segment, point, width, endSegment) {\n            var isOnPath;\n\n            if (this.controlOut() && segment.controlIn()) {\n              isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n            } else {\n              isOnPath = this._isOnLineTo(segment, point, width);\n            }\n\n            return isOnPath;\n          };\n\n          return Segment;\n        }(withPoints(HasObservers, points));\n\n        function arrayLimits(arr) {\n          var length = arr.length;\n          var min = MAX_NUM;\n          var max = MIN_NUM;\n\n          for (var i = 0; i < length; i++) {\n            max = Math.max(max, arr[i]);\n            min = Math.min(min, arr[i]);\n          }\n\n          return {\n            min: min,\n            max: max\n          };\n        }\n\n        var ShapeMap = {\n          l: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n\n            for (var i = 0; i < parameters.length; i += 2) {\n              var point = new Point(parameters[i], parameters[i + 1]);\n\n              if (options.isRelative) {\n                point.translateWith(position);\n              }\n\n              path.lineTo(point.x, point.y);\n              position.x = point.x;\n              position.y = point.y;\n            }\n          },\n          c: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n\n            for (var i = 0; i < parameters.length; i += 6) {\n              var controlOut = new Point(parameters[i], parameters[i + 1]);\n              var controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n              var point = new Point(parameters[i + 4], parameters[i + 5]);\n\n              if (options.isRelative) {\n                controlIn.translateWith(position);\n                controlOut.translateWith(position);\n                point.translateWith(position);\n              }\n\n              path.curveTo(controlOut, controlIn, point);\n              position.x = point.x;\n              position.y = point.y;\n            }\n          },\n          v: function (path, options) {\n            var value = options.isRelative ? 0 : options.position.x;\n            toLineParamaters(options.parameters, true, value);\n            this.l(path, options);\n          },\n          h: function (path, options) {\n            var value = options.isRelative ? 0 : options.position.y;\n            toLineParamaters(options.parameters, false, value);\n            this.l(path, options);\n          },\n          a: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n\n            for (var i = 0; i < parameters.length; i += 7) {\n              var radiusX = parameters[i];\n              var radiusY = parameters[i + 1];\n              var rotation = parameters[i + 2];\n              var largeArc = parameters[i + 3];\n              var swipe = parameters[i + 4];\n              var endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n              if (options.isRelative) {\n                endPoint.translateWith(position);\n              }\n\n              if (position.x !== endPoint.x || position.y !== endPoint.y) {\n                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n                position.x = endPoint.x;\n                position.y = endPoint.y;\n              }\n            }\n          },\n          s: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n            var previousCommand = options.previousCommand;\n            var lastControlIn;\n\n            if (previousCommand === \"s\" || previousCommand === \"c\") {\n              lastControlIn = last(last(path.paths).segments).controlIn();\n            }\n\n            for (var i = 0; i < parameters.length; i += 4) {\n              var controlIn = new Point(parameters[i], parameters[i + 1]);\n              var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n              var controlOut = void 0;\n\n              if (options.isRelative) {\n                controlIn.translateWith(position);\n                endPoint.translateWith(position);\n              }\n\n              if (lastControlIn) {\n                controlOut = reflectionPoint(lastControlIn, position);\n              } else {\n                controlOut = position.clone();\n              }\n\n              lastControlIn = controlIn;\n              path.curveTo(controlOut, controlIn, endPoint);\n              position.x = endPoint.x;\n              position.y = endPoint.y;\n            }\n          },\n          q: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n\n            for (var i = 0; i < parameters.length; i += 4) {\n              var controlPoint = new Point(parameters[i], parameters[i + 1]);\n              var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n              if (options.isRelative) {\n                controlPoint.translateWith(position);\n                endPoint.translateWith(position);\n              }\n\n              var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n              path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n              position.x = endPoint.x;\n              position.y = endPoint.y;\n            }\n          },\n          t: function (path, options) {\n            var parameters = options.parameters;\n            var position = options.position;\n            var previousCommand = options.previousCommand;\n            var controlPoint;\n\n            if (previousCommand === \"q\" || previousCommand === \"t\") {\n              var lastSegment = last(last(path.paths).segments);\n              controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);\n            }\n\n            for (var i = 0; i < parameters.length; i += 2) {\n              var endPoint = new Point(parameters[i], parameters[i + 1]);\n\n              if (options.isRelative) {\n                endPoint.translateWith(position);\n              }\n\n              if (controlPoint) {\n                controlPoint = reflectionPoint(controlPoint, position);\n              } else {\n                controlPoint = position.clone();\n              }\n\n              var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n              path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n              position.x = endPoint.x;\n              position.y = endPoint.y;\n            }\n          }\n        };\n\n        function toLineParamaters(parameters, isVertical, value) {\n          var insertPosition = isVertical ? 0 : 1;\n\n          for (var i = 0; i < parameters.length; i += 2) {\n            parameters.splice(i + insertPosition, 0, value);\n          }\n        }\n\n        function reflectionPoint(point, center) {\n          if (point && center) {\n            return center.scaleCopy(2).translate(-point.x, -point.y);\n          }\n        }\n\n        var third = 1 / 3;\n\n        function quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n          var scaledPoint = controlPoint.clone().scale(2 / 3);\n          return {\n            controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n            controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n          };\n        }\n\n        var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\n        var SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\n        var MOVE = \"m\";\n        var CLOSE = \"z\";\n\n        function parseParameters(str) {\n          var parameters = [];\n          str.replace(SPLIT_REGEX, function (match, number) {\n            parameters.push(parseFloat(number));\n          });\n          return parameters;\n        }\n\n        function parsePath(pathInstance, str) {\n          var position = new Point();\n          var previousCommand;\n          str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\n            var command = element.toLowerCase();\n            var isRelative = command === element;\n            var parameters = parseParameters(params.trim());\n\n            if (command === MOVE) {\n              if (isRelative) {\n                position.x += parameters[0];\n                position.y += parameters[1];\n              } else {\n                position.x = parameters[0];\n                position.y = parameters[1];\n              }\n\n              pathInstance.moveTo(position.x, position.y);\n\n              if (parameters.length > 2) {\n                command = \"l\";\n                parameters.splice(0, 2);\n              }\n            }\n\n            if (ShapeMap[command]) {\n              ShapeMap[command](pathInstance, {\n                parameters: parameters,\n                position: position,\n                isRelative: isRelative,\n                previousCommand: previousCommand\n              });\n\n              if (closePath && closePath.toLowerCase() === CLOSE) {\n                pathInstance.close();\n              }\n            } else if (command !== MOVE) {\n              throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n            }\n\n            previousCommand = command;\n          });\n          return pathInstance;\n        }\n\n        function elementsBoundingBox(elements, applyTransform, transformation) {\n          var boundingBox;\n\n          for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n\n            if (element.visible()) {\n              var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();\n\n              if (elementBoundingBox) {\n                if (boundingBox) {\n                  boundingBox = Rect.union(boundingBox, elementBoundingBox);\n                } else {\n                  boundingBox = elementBoundingBox;\n                }\n              }\n            }\n          }\n\n          return boundingBox;\n        }\n\n        function elementsClippedBoundingBox(elements, transformation) {\n          var boundingBox;\n\n          for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n\n            if (element.visible()) {\n              var elementBoundingBox = element.clippedBBox(transformation);\n\n              if (elementBoundingBox) {\n                if (boundingBox) {\n                  boundingBox = Rect.union(boundingBox, elementBoundingBox);\n                } else {\n                  boundingBox = elementBoundingBox;\n                }\n              }\n            }\n          }\n\n          return boundingBox;\n        }\n\n        var Path = function (superclass) {\n          function Path(options) {\n            superclass.call(this, options);\n            this.segments = new GeometryElementsArray();\n            this.segments.addObserver(this);\n\n            if (!defined(this.options.stroke)) {\n              this.stroke(\"#000\");\n\n              if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set(\"stroke.lineJoin\", \"miter\");\n              }\n            }\n          }\n\n          extendStatic(Path, superclass);\n          Path.prototype = Object.create(superclass && superclass.prototype);\n          Path.prototype.constructor = Path;\n          Path.fn = Path.prototype;\n          Path.fn.init = Path.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          Path.parse = function parse(str, options) {\n            return MultiPath.parse(str, options);\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Path\";\n          };\n\n          Path.prototype.moveTo = function moveTo(x, y) {\n            this.suspend();\n            this.segments.elements([]);\n            this.resume();\n            this.lineTo(x, y);\n            return this;\n          };\n\n          Path.prototype.lineTo = function lineTo(x, y) {\n            var point = defined(y) ? new Point(x, y) : x;\n            var segment = new Segment(point);\n            this.segments.push(segment);\n            return this;\n          };\n\n          Path.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n            if (this.segments.length > 0) {\n              var lastSegment = last(this.segments);\n              var segment = new Segment(point, controlIn);\n              this.suspend();\n              lastSegment.controlOut(controlOut);\n              this.resume();\n              this.segments.push(segment);\n            }\n\n            return this;\n          };\n\n          Path.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n            if (this.segments.length > 0) {\n              var lastSegment = last(this.segments);\n              var anchor = lastSegment.anchor();\n              var start = rad(startAngle);\n              var center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n              var arc = new Arc$2(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n              });\n\n              this._addArcSegments(arc);\n            }\n\n            return this;\n          };\n\n          Path.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n            if (this.segments.length > 0) {\n              var lastSegment = last(this.segments);\n              var anchor = lastSegment.anchor();\n              var arc = Arc$2.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n\n              this._addArcSegments(arc);\n            }\n\n            return this;\n          };\n\n          Path.prototype._addArcSegments = function _addArcSegments(arc) {\n            var this$1 = this;\n            this.suspend();\n            var curvePoints = arc.curvePoints();\n\n            for (var i = 1; i < curvePoints.length; i += 3) {\n              this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n            }\n\n            this.resume();\n            this.geometryChange();\n          };\n\n          Path.prototype.close = function close() {\n            this.options.closed = true;\n            this.geometryChange();\n            return this;\n          };\n\n          Path.prototype.rawBBox = function rawBBox() {\n            return this._bbox();\n          };\n\n          Path.prototype._containsPoint = function _containsPoint(point) {\n            var segments = this.segments;\n            var length = segments.length;\n            var intersectionsCount = 0;\n            var previous, current;\n\n            for (var idx = 1; idx < length; idx++) {\n              previous = segments[idx - 1];\n              current = segments[idx];\n              intersectionsCount += previous._intersectionsTo(current, point);\n            }\n\n            if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n              intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n            }\n\n            return intersectionsCount % 2 !== 0;\n          };\n\n          Path.prototype._isOnPath = function _isOnPath(point, width) {\n            var segments = this.segments;\n            var length = segments.length;\n            var pathWidth = width || this.options.stroke.width;\n\n            if (length > 1) {\n              if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n                return true;\n              }\n\n              for (var idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                  return true;\n                }\n              }\n\n              if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n\n          Path.prototype._bbox = function _bbox(matrix) {\n            var segments = this.segments;\n            var length = segments.length;\n            var boundingBox;\n\n            if (length === 1) {\n              var anchor = segments[0].anchor().transformCopy(matrix);\n              boundingBox = new Rect(anchor, Size.ZERO);\n            } else if (length > 0) {\n              for (var i = 1; i < length; i++) {\n                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n\n                if (boundingBox) {\n                  boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                  boundingBox = segmentBox;\n                }\n              }\n            }\n\n            return boundingBox;\n          };\n\n          Path.fromRect = function fromRect(rect, options) {\n            var path = new Path(options);\n            var ref = rect.cornerRadius;\n            var rx = ref[0];\n            var ry = ref[1];\n\n            if (rx === 0 && ry === 0) {\n              path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n            } else {\n              var origin = rect.origin;\n              var x = origin.x;\n              var y = origin.y;\n              var width = rect.width();\n              var height = rect.height();\n              rx = limitValue(rx, 0, width / 2);\n              ry = limitValue(ry, 0, height / 2);\n              path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);\n            }\n\n            return path;\n          };\n\n          Path.fromPoints = function fromPoints(points, options) {\n            if (points) {\n              var path = new Path(options);\n\n              for (var i = 0; i < points.length; i++) {\n                var point = Point.create(points[i]);\n\n                if (point) {\n                  if (i === 0) {\n                    path.moveTo(point);\n                  } else {\n                    path.lineTo(point);\n                  }\n                }\n              }\n\n              return path;\n            }\n          };\n\n          Path.fromArc = function fromArc(arc, options) {\n            var path = new Path(options);\n            var startAngle = arc.startAngle;\n            var start = arc.pointAt(startAngle);\n            path.moveTo(start.x, start.y);\n            path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n            return path;\n          };\n\n          Object.defineProperties(Path.prototype, prototypeAccessors);\n          return Path;\n        }(paintable(measurable(Element$1)));\n\n        var MultiPath = function (superclass) {\n          function MultiPath(options) {\n            superclass.call(this, options);\n            this.paths = new GeometryElementsArray();\n            this.paths.addObserver(this);\n\n            if (!defined(this.options.stroke)) {\n              this.stroke(\"#000\");\n            }\n          }\n\n          extendStatic(MultiPath, superclass);\n          MultiPath.prototype = Object.create(superclass && superclass.prototype);\n          MultiPath.prototype.constructor = MultiPath;\n          MultiPath.fn = MultiPath.prototype;\n          MultiPath.fn.init = MultiPath.fn.constructor;\n          var prototypeAccessors$1 = {\n            nodeType: {}\n          };\n\n          MultiPath.parse = function parse(str, options) {\n            var instance = new MultiPath(options);\n            return parsePath(instance, str);\n          };\n\n          prototypeAccessors$1.nodeType.get = function () {\n            return \"MultiPath\";\n          };\n\n          MultiPath.prototype.moveTo = function moveTo(x, y) {\n            var path = new Path();\n            path.moveTo(x, y);\n            this.paths.push(path);\n            return this;\n          };\n\n          MultiPath.prototype.lineTo = function lineTo(x, y) {\n            if (this.paths.length > 0) {\n              last(this.paths).lineTo(x, y);\n            }\n\n            return this;\n          };\n\n          MultiPath.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n            if (this.paths.length > 0) {\n              last(this.paths).curveTo(controlOut, controlIn, point);\n            }\n\n            return this;\n          };\n\n          MultiPath.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n            if (this.paths.length > 0) {\n              last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n            }\n\n            return this;\n          };\n\n          MultiPath.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n            if (this.paths.length > 0) {\n              last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n            }\n\n            return this;\n          };\n\n          MultiPath.prototype.close = function close() {\n            if (this.paths.length > 0) {\n              last(this.paths).close();\n            }\n\n            return this;\n          };\n\n          MultiPath.prototype._bbox = function _bbox(matrix) {\n            return elementsBoundingBox(this.paths, true, matrix);\n          };\n\n          MultiPath.prototype.rawBBox = function rawBBox() {\n            return elementsBoundingBox(this.paths, false);\n          };\n\n          MultiPath.prototype._containsPoint = function _containsPoint(point) {\n            var paths = this.paths;\n\n            for (var idx = 0; idx < paths.length; idx++) {\n              if (paths[idx]._containsPoint(point)) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n\n          MultiPath.prototype._isOnPath = function _isOnPath(point) {\n            var paths = this.paths;\n            var width = this.options.stroke.width;\n\n            for (var idx = 0; idx < paths.length; idx++) {\n              if (paths[idx]._isOnPath(point, width)) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n\n          MultiPath.prototype._clippedBBox = function _clippedBBox(transformation) {\n            return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n          };\n\n          Object.defineProperties(MultiPath.prototype, prototypeAccessors$1);\n          return MultiPath;\n        }(paintable(measurable(Element$1)));\n\n        var DEFAULT_STROKE$1 = \"#000\";\n\n        var Arc = function (superclass) {\n          function Arc(geometry, options) {\n            if (geometry === void 0) {\n              geometry = new Arc$2();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.geometry(geometry);\n\n            if (!defined(this.options.stroke)) {\n              this.stroke(DEFAULT_STROKE$1);\n            }\n          }\n\n          extendStatic(Arc, superclass);\n          Arc.prototype = Object.create(superclass && superclass.prototype);\n          Arc.prototype.constructor = Arc;\n          Arc.fn = Arc.prototype;\n          Arc.fn.init = Arc.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Arc\";\n          };\n\n          Arc.prototype._bbox = function _bbox(matrix) {\n            return this._geometry.bbox(matrix);\n          };\n\n          Arc.prototype.rawBBox = function rawBBox() {\n            return this.geometry().bbox();\n          };\n\n          Arc.prototype.toPath = function toPath() {\n            var path = new Path();\n            var curvePoints = this.geometry().curvePoints();\n\n            if (curvePoints.length > 0) {\n              path.moveTo(curvePoints[0].x, curvePoints[0].y);\n\n              for (var i = 1; i < curvePoints.length; i += 3) {\n                path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n              }\n            }\n\n            return path;\n          };\n\n          Arc.prototype._containsPoint = function _containsPoint(point) {\n            return this.geometry().containsPoint(point);\n          };\n\n          Arc.prototype._isOnPath = function _isOnPath(point) {\n            return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n          };\n\n          Object.defineProperties(Arc.prototype, prototypeAccessors);\n          return Arc;\n        }(paintable(measurable(withGeometry(Element$1))));\n\n        var DEFAULT_FONT = \"12px sans-serif\";\n        var DEFAULT_FILL = \"#000\";\n\n        var Text = function (superclass) {\n          function Text(content, position, options) {\n            if (position === void 0) {\n              position = new Point();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.content(content);\n            this.position(position);\n\n            if (!this.options.font) {\n              this.options.font = DEFAULT_FONT;\n            }\n\n            if (!defined(this.options.fill)) {\n              this.fill(DEFAULT_FILL);\n            }\n          }\n\n          extendStatic(Text, superclass);\n          Text.prototype = Object.create(superclass && superclass.prototype);\n          Text.prototype.constructor = Text;\n          Text.fn = Text.prototype;\n          Text.fn.init = Text.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Text\";\n          };\n\n          Text.prototype.content = function content(value) {\n            if (defined(value)) {\n              this.options.set(\"content\", value);\n              return this;\n            }\n\n            return this.options.get(\"content\");\n          };\n\n          Text.prototype.measure = function measure() {\n            var metrics = kendoUtil.measureText(this.content(), {\n              font: this.options.get(\"font\")\n            });\n            return metrics;\n          };\n\n          Text.prototype.rect = function rect() {\n            var size = this.measure();\n            var pos = this.position().clone();\n            return new Rect(pos, [size.width, size.height]);\n          };\n\n          Text.prototype.bbox = function bbox(transformation) {\n            var combinedMatrix = toMatrix(this.currentTransform(transformation));\n            return this.rect().bbox(combinedMatrix);\n          };\n\n          Text.prototype.rawBBox = function rawBBox() {\n            return this.rect().bbox();\n          };\n\n          Text.prototype._containsPoint = function _containsPoint(point) {\n            return this.rect().containsPoint(point);\n          };\n\n          Object.defineProperties(Text.prototype, prototypeAccessors);\n          return Text;\n        }(paintable(withPoints(Element$1, [\"position\"])));\n\n        var Image$1 = function (superclass) {\n          function Image(src, rect, options) {\n            if (rect === void 0) {\n              rect = new Rect();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.src(src);\n            this.rect(rect);\n          }\n\n          extendStatic(Image, superclass);\n          Image.prototype = Object.create(superclass && superclass.prototype);\n          Image.prototype.constructor = Image;\n          Image.fn = Image.prototype;\n          Image.fn.init = Image.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Image\";\n          };\n\n          Image.prototype.src = function src(value) {\n            if (defined(value)) {\n              this.options.set(\"src\", value);\n              return this;\n            }\n\n            return this.options.get(\"src\");\n          };\n\n          Image.prototype.bbox = function bbox(transformation) {\n            var combinedMatrix = toMatrix(this.currentTransform(transformation));\n            return this._rect.bbox(combinedMatrix);\n          };\n\n          Image.prototype.rawBBox = function rawBBox() {\n            return this._rect.bbox();\n          };\n\n          Image.prototype._containsPoint = function _containsPoint(point) {\n            return this._rect.containsPoint(point);\n          };\n\n          Image.prototype._hasFill = function _hasFill() {\n            return this.src();\n          };\n\n          Object.defineProperties(Image.prototype, prototypeAccessors);\n          return Image;\n        }(withGeometry(Element$1, [\"rect\"]));\n\n        var traversable = function (TBase, childrenField) {\n          return function (TBase) {\n            function anonymous() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(anonymous, TBase);\n            anonymous.prototype = Object.create(TBase && TBase.prototype);\n            anonymous.prototype.constructor = anonymous;\n            anonymous.fn = anonymous.prototype;\n            anonymous.fn.init = anonymous.fn.constructor;\n\n            anonymous.prototype.traverse = function traverse(callback) {\n              var children = this[childrenField];\n\n              for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n\n                if (child.traverse) {\n                  child.traverse(callback);\n                } else {\n                  callback(child);\n                }\n              }\n\n              return this;\n            };\n\n            return anonymous;\n          }(TBase);\n        };\n\n        var Group = function (superclass) {\n          function Group(options) {\n            superclass.call(this, options);\n            this.children = [];\n          }\n\n          extendStatic(Group, superclass);\n          Group.prototype = Object.create(superclass && superclass.prototype);\n          Group.prototype.constructor = Group;\n          Group.fn = Group.prototype;\n          Group.fn.init = Group.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Group\";\n          };\n\n          Group.prototype.childrenChange = function childrenChange(action, items, index) {\n            this.trigger(\"childrenChange\", {\n              action: action,\n              items: items,\n              index: index\n            });\n          };\n\n          Group.prototype.append = function append$1() {\n            append$1$1(this.children, arguments);\n\n            this._reparent(arguments, this);\n\n            this.childrenChange(\"add\", arguments);\n            return this;\n          };\n\n          Group.prototype.insert = function insert(index, element) {\n            this.children.splice(index, 0, element);\n            element.parent = this;\n            this.childrenChange(\"add\", [element], index);\n            return this;\n          };\n\n          Group.prototype.insertAt = function insertAt(element, index) {\n            return this.insert(index, element);\n          };\n\n          Group.prototype.remove = function remove(element) {\n            var index = this.children.indexOf(element);\n\n            if (index >= 0) {\n              this.children.splice(index, 1);\n              element.parent = null;\n              this.childrenChange(\"remove\", [element], index);\n            }\n\n            return this;\n          };\n\n          Group.prototype.removeAt = function removeAt(index) {\n            if (0 <= index && index < this.children.length) {\n              var element = this.children[index];\n              this.children.splice(index, 1);\n              element.parent = null;\n              this.childrenChange(\"remove\", [element], index);\n            }\n\n            return this;\n          };\n\n          Group.prototype.clear = function clear() {\n            var items = this.children;\n            this.children = [];\n\n            this._reparent(items, null);\n\n            this.childrenChange(\"remove\", items, 0);\n            return this;\n          };\n\n          Group.prototype.bbox = function bbox(transformation) {\n            return elementsBoundingBox(this.children, true, this.currentTransform(transformation));\n          };\n\n          Group.prototype.rawBBox = function rawBBox() {\n            return elementsBoundingBox(this.children, false);\n          };\n\n          Group.prototype._clippedBBox = function _clippedBBox(transformation) {\n            return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));\n          };\n\n          Group.prototype.currentTransform = function currentTransform(transformation) {\n            return Element$1.prototype.currentTransform.call(this, transformation) || null;\n          };\n\n          Group.prototype.containsPoint = function containsPoint(point, parentTransform) {\n            if (this.visible()) {\n              var children = this.children;\n              var transform = this.currentTransform(parentTransform);\n\n              for (var idx = 0; idx < children.length; idx++) {\n                if (children[idx].containsPoint(point, transform)) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          };\n\n          Group.prototype._reparent = function _reparent(elements, newParent) {\n            var this$1 = this;\n\n            for (var i = 0; i < elements.length; i++) {\n              var child = elements[i];\n              var parent = child.parent;\n\n              if (parent && parent !== this$1 && parent.remove) {\n                parent.remove(child);\n              }\n\n              child.parent = newParent;\n            }\n          };\n\n          Object.defineProperties(Group.prototype, prototypeAccessors);\n          return Group;\n        }(traversable(Element$1, \"children\"));\n\n        function translateToPoint(point, bbox, element) {\n          var transofrm = element.transform() || transform$1();\n          var matrix = transofrm.matrix();\n          matrix.e += point.x - bbox.origin.x;\n          matrix.f += point.y - bbox.origin.y;\n          transofrm.matrix(matrix);\n          element.transform(transofrm);\n        }\n\n        function alignStart(size, rect, align, axis, sizeField) {\n          var start;\n\n          if (align === \"start\") {\n            start = rect.origin[axis];\n          } else if (align === \"end\") {\n            start = rect.origin[axis] + rect.size[sizeField] - size;\n          } else {\n            start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n          }\n\n          return start;\n        }\n\n        function alignStartReverse(size, rect, align, axis, sizeField) {\n          var start;\n\n          if (align === \"start\") {\n            start = rect.origin[axis] + rect.size[sizeField] - size;\n          } else if (align === \"end\") {\n            start = rect.origin[axis];\n          } else {\n            start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n          }\n\n          return start;\n        }\n\n        var DEFAULT_OPTIONS = {\n          alignContent: \"start\",\n          justifyContent: \"start\",\n          alignItems: \"start\",\n          spacing: 0,\n          orientation: \"horizontal\",\n          lineSpacing: 0,\n          wrap: true,\n          revers: false\n        };\n\n        var forEach = function (elements, callback) {\n          elements.forEach(callback);\n        };\n\n        var forEachReverse = function (elements, callback) {\n          var length = elements.length;\n\n          for (var idx = length - 1; idx >= 0; idx--) {\n            callback(elements[idx], idx);\n          }\n        };\n\n        var Layout = function (Group$$1) {\n          function Layout(rect, options) {\n            Group$$1.call(this, $.extend({}, DEFAULT_OPTIONS, options));\n            this._rect = rect;\n            this._fieldMap = {};\n          }\n\n          extendStatic(Layout, Group$$1);\n          Layout.prototype = Object.create(Group$$1 && Group$$1.prototype);\n          Layout.prototype.constructor = Layout;\n          Layout.fn = Layout.prototype;\n          Layout.fn.init = Layout.fn.constructor;\n\n          Layout.prototype.rect = function rect(value) {\n            if (value) {\n              this._rect = value;\n              return this;\n            }\n\n            return this._rect;\n          };\n\n          Layout.prototype._initMap = function _initMap() {\n            var options = this.options;\n            var fieldMap = this._fieldMap;\n\n            if (options.orientation === \"horizontal\") {\n              fieldMap.sizeField = \"width\";\n              fieldMap.groupsSizeField = \"height\";\n              fieldMap.groupAxis = \"x\";\n              fieldMap.groupsAxis = \"y\";\n            } else {\n              fieldMap.sizeField = \"height\";\n              fieldMap.groupsSizeField = \"width\";\n              fieldMap.groupAxis = \"y\";\n              fieldMap.groupsAxis = \"x\";\n            }\n\n            if (options.reverse) {\n              this.forEach = forEachReverse;\n              this.justifyAlign = alignStartReverse;\n            } else {\n              this.forEach = forEach;\n              this.justifyAlign = alignStart;\n            }\n          };\n\n          Layout.prototype.reflow = function reflow() {\n            var this$1 = this;\n\n            if (!this._rect || this.children.length === 0) {\n              return;\n            }\n\n            this._initMap();\n\n            if (this.options.transform) {\n              this.transform(null);\n            }\n\n            var options = this.options;\n            var rect = this._rect;\n\n            var ref = this._initGroups();\n\n            var groups = ref.groups;\n            var groupsSize = ref.groupsSize;\n            var ref$1 = this._fieldMap;\n            var sizeField = ref$1.sizeField;\n            var groupsSizeField = ref$1.groupsSizeField;\n            var groupAxis = ref$1.groupAxis;\n            var groupsAxis = ref$1.groupsAxis;\n            var groupOrigin = new Point();\n            var elementOrigin = new Point();\n            var size = new Size();\n            var groupStart = alignStart(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n            var elementStart, group, groupBox;\n\n            var arrangeElements = function (bbox, idx) {\n              var element = group.elements[idx];\n              elementOrigin[groupAxis] = elementStart;\n              elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);\n              translateToPoint(elementOrigin, bbox, element);\n              elementStart += bbox.size[sizeField] + options.spacing;\n            };\n\n            for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {\n              group = groups[groupIdx];\n              groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options.justifyContent, groupAxis, sizeField);\n              groupOrigin[groupsAxis] = groupStart;\n              size[sizeField] = group.size;\n              size[groupsSizeField] = group.lineSize;\n              groupBox = new Rect(groupOrigin, size);\n              this$1.forEach(group.bboxes, arrangeElements);\n              groupStart += group.lineSize + options.lineSpacing;\n            }\n\n            if (!options.wrap && group.size > rect.size[sizeField]) {\n              var scale = rect.size[sizeField] / groupBox.size[sizeField];\n              var scaledStart = groupBox.topLeft().scale(scale, scale);\n              var scaledSize = groupBox.size[groupsSizeField] * scale;\n              var newStart = alignStart(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n              var transform = transform$1();\n\n              if (groupAxis === \"x\") {\n                transform.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);\n              } else {\n                transform.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);\n              }\n\n              transform.scale(scale, scale);\n              this.transform(transform);\n            }\n          };\n\n          Layout.prototype._initGroups = function _initGroups() {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var lineSpacing = options.lineSpacing;\n            var wrap = options.wrap;\n            var spacing = options.spacing;\n            var sizeField = this._fieldMap.sizeField;\n\n            var group = this._newGroup();\n\n            var groups = [];\n\n            var addGroup = function () {\n              groups.push(group);\n              groupsSize += group.lineSize + lineSpacing;\n            };\n\n            var groupsSize = -lineSpacing;\n\n            for (var idx = 0; idx < children.length; idx++) {\n              var element = children[idx];\n              var bbox = children[idx].clippedBBox();\n\n              if (element.visible() && bbox) {\n                if (wrap && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {\n                  if (group.bboxes.length === 0) {\n                    this$1._addToGroup(group, bbox, element);\n\n                    addGroup();\n                    group = this$1._newGroup();\n                  } else {\n                    addGroup();\n                    group = this$1._newGroup();\n\n                    this$1._addToGroup(group, bbox, element);\n                  }\n                } else {\n                  this$1._addToGroup(group, bbox, element);\n                }\n              }\n            }\n\n            if (group.bboxes.length) {\n              addGroup();\n            }\n\n            return {\n              groups: groups,\n              groupsSize: groupsSize\n            };\n          };\n\n          Layout.prototype._addToGroup = function _addToGroup(group, bbox, element) {\n            group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;\n            group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);\n            group.bboxes.push(bbox);\n            group.elements.push(element);\n          };\n\n          Layout.prototype._newGroup = function _newGroup() {\n            return {\n              lineSize: 0,\n              size: -this.options.spacing,\n              bboxes: [],\n              elements: []\n            };\n          };\n\n          return Layout;\n        }(Group);\n\n        var Rect$2 = function (superclass) {\n          function Rect$$1(geometry, options) {\n            if (geometry === void 0) {\n              geometry = new Rect();\n            }\n\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.geometry(geometry);\n\n            if (!defined(this.options.stroke)) {\n              this.stroke(\"#000\");\n            }\n          }\n\n          extendStatic(Rect$$1, superclass);\n          Rect$$1.prototype = Object.create(superclass && superclass.prototype);\n          Rect$$1.prototype.constructor = Rect$$1;\n          Rect$$1.fn = Rect$$1.prototype;\n          Rect$$1.fn.init = Rect$$1.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Rect\";\n          };\n\n          Rect$$1.prototype._bbox = function _bbox(matrix) {\n            return this._geometry.bbox(matrix);\n          };\n\n          Rect$$1.prototype.rawBBox = function rawBBox() {\n            return this._geometry.bbox();\n          };\n\n          Rect$$1.prototype._containsPoint = function _containsPoint(point) {\n            return this._geometry.containsPoint(point);\n          };\n\n          Rect$$1.prototype._isOnPath = function _isOnPath(point) {\n            return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n          };\n\n          Object.defineProperties(Rect$$1.prototype, prototypeAccessors);\n          return Rect$$1;\n        }(paintable(measurable(withGeometry(Element$1))));\n\n        function alignElements(elements, rect, alignment, axis, sizeField) {\n          for (var idx = 0; idx < elements.length; idx++) {\n            var bbox = elements[idx].clippedBBox();\n\n            if (bbox) {\n              var point = bbox.origin.clone();\n              point[axis] = alignStart(bbox.size[sizeField], rect, alignment || \"start\", axis, sizeField);\n              translateToPoint(point, bbox, elements[idx]);\n            }\n          }\n        }\n\n        function align(elements, rect, alignment) {\n          alignElements(elements, rect, alignment, \"x\", \"width\");\n        }\n\n        function vAlign(elements, rect, alignment) {\n          alignElements(elements, rect, alignment, \"y\", \"height\");\n        }\n\n        function stackElements(elements, stackAxis, otherAxis, sizeField) {\n          if (elements.length > 1) {\n            var origin = new Point();\n            var previousBBox = elements[0].bbox;\n\n            for (var idx = 1; idx < elements.length; idx++) {\n              var element = elements[idx].element;\n              var bbox = elements[idx].bbox;\n              origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];\n              origin[otherAxis] = bbox.origin[otherAxis];\n              translateToPoint(origin, bbox, element);\n              bbox.origin[stackAxis] = origin[stackAxis];\n              previousBBox = bbox;\n            }\n          }\n        }\n\n        function createStackElements(elements) {\n          var stackElements = [];\n\n          for (var idx = 0; idx < elements.length; idx++) {\n            var element = elements[idx];\n            var bbox = element.clippedBBox();\n\n            if (bbox) {\n              stackElements.push({\n                element: element,\n                bbox: bbox\n              });\n            }\n          }\n\n          return stackElements;\n        }\n\n        function stack(elements) {\n          stackElements(createStackElements(elements), \"x\", \"y\", \"width\");\n        }\n\n        function vStack(elements) {\n          stackElements(createStackElements(elements), \"y\", \"x\", \"height\");\n        }\n\n        function getStacks(elements, rect, sizeField) {\n          var maxSize = rect.size[sizeField];\n          var stacks = [];\n          var stack = [];\n          var stackSize = 0;\n          var element, bbox;\n\n          var addElementToStack = function () {\n            stack.push({\n              element: element,\n              bbox: bbox\n            });\n          };\n\n          for (var idx = 0; idx < elements.length; idx++) {\n            element = elements[idx];\n            bbox = element.clippedBBox();\n\n            if (bbox) {\n              var size = bbox.size[sizeField];\n\n              if (stackSize + size > maxSize) {\n                if (stack.length) {\n                  stacks.push(stack);\n                  stack = [];\n                  addElementToStack();\n                  stackSize = size;\n                } else {\n                  addElementToStack();\n                  stacks.push(stack);\n                  stack = [];\n                  stackSize = 0;\n                }\n              } else {\n                addElementToStack();\n                stackSize += size;\n              }\n            }\n          }\n\n          if (stack.length) {\n            stacks.push(stack);\n          }\n\n          return stacks;\n        }\n\n        function wrapElements(elements, rect, axis, otherAxis, sizeField) {\n          var stacks = getStacks(elements, rect, sizeField);\n          var origin = rect.origin.clone();\n          var result = [];\n\n          for (var idx = 0; idx < stacks.length; idx++) {\n            var stack = stacks[idx];\n            var startElement = stack[0];\n            origin[otherAxis] = startElement.bbox.origin[otherAxis];\n            translateToPoint(origin, startElement.bbox, startElement.element);\n            startElement.bbox.origin[axis] = origin[axis];\n            stackElements(stack, axis, otherAxis, sizeField);\n            result.push([]);\n\n            for (var elementIdx = 0; elementIdx < stack.length; elementIdx++) {\n              result[idx].push(stack[elementIdx].element);\n            }\n          }\n\n          return result;\n        }\n\n        function wrap(elements, rect) {\n          return wrapElements(elements, rect, \"x\", \"y\", \"width\");\n        }\n\n        function vWrap(elements, rect) {\n          return wrapElements(elements, rect, \"y\", \"x\", \"height\");\n        }\n\n        function fit(element, rect) {\n          var bbox = element.clippedBBox();\n\n          if (bbox) {\n            var elementSize = bbox.size;\n            var rectSize = rect.size;\n\n            if (rectSize.width < elementSize.width || rectSize.height < elementSize.height) {\n              var scale = Math.min(rectSize.width / elementSize.width, rectSize.height / elementSize.height);\n              var transform = element.transform() || transform$1();\n              transform.scale(scale, scale);\n              element.transform(transform);\n            }\n          }\n        }\n\n        var StopsArray = function (ElementsArray$$1) {\n          function StopsArray() {\n            ElementsArray$$1.apply(this, arguments);\n          }\n\n          extendStatic(StopsArray, ElementsArray$$1);\n          StopsArray.prototype = Object.create(ElementsArray$$1 && ElementsArray$$1.prototype);\n          StopsArray.prototype.constructor = StopsArray;\n          StopsArray.fn = StopsArray.prototype;\n          StopsArray.fn.init = StopsArray.fn.constructor;\n\n          StopsArray.prototype._change = function _change() {\n            this.optionsChange({\n              field: \"stops\"\n            });\n          };\n\n          return StopsArray;\n        }(ElementsArray);\n\n        function optionsAccessor(name) {\n          return function (value) {\n            if (defined(value)) {\n              this.options.set(name, value);\n              return this;\n            }\n\n            return this.options.get(name);\n          };\n        }\n\n        function defineOptionsAccessors(fn, names) {\n          for (var i = 0; i < names.length; i++) {\n            fn[names[i]] = optionsAccessor(names[i]);\n          }\n        }\n\n        var withOptions = function (TBase, names) {\n          var result = function (TBase) {\n            function result() {\n              TBase.apply(this, arguments);\n            }\n\n            extendStatic(result, TBase);\n            result.prototype = Object.create(TBase && TBase.prototype);\n            result.prototype.constructor = result;\n            result.fn = result.prototype;\n            result.fn.init = result.fn.constructor;\n            return result;\n          }(TBase);\n\n          defineOptionsAccessors(result.prototype, names);\n          return result;\n        };\n\n        var options = [\"offset\", \"color\", \"opacity\"];\n\n        var GradientStop = function (superclass) {\n          function GradientStop(offset, color, opacity) {\n            superclass.call(this);\n            this.options = new OptionsStore({\n              offset: offset,\n              color: color,\n              opacity: defined(opacity) ? opacity : 1\n            });\n            this.options.addObserver(this);\n          }\n\n          extendStatic(GradientStop, superclass);\n          GradientStop.prototype = Object.create(superclass && superclass.prototype);\n          GradientStop.prototype.constructor = GradientStop;\n          GradientStop.fn = GradientStop.prototype;\n          GradientStop.fn.init = GradientStop.fn.constructor;\n\n          GradientStop.create = function create(arg) {\n            if (defined(arg)) {\n              var stop;\n\n              if (arg instanceof GradientStop) {\n                stop = arg;\n              } else if (arg.length > 1) {\n                stop = new GradientStop(arg[0], arg[1], arg[2]);\n              } else {\n                stop = new GradientStop(arg.offset, arg.color, arg.opacity);\n              }\n\n              return stop;\n            }\n          };\n\n          return GradientStop;\n        }(withOptions(HasObservers, options));\n\n        var Gradient = function (HasObservers$$1) {\n          function Gradient(options) {\n            if (options === void 0) {\n              options = {};\n            }\n\n            HasObservers$$1.call(this);\n            this.stops = new StopsArray(this._createStops(options.stops));\n            this.stops.addObserver(this);\n            this._userSpace = options.userSpace;\n            this.id = definitionId();\n          }\n\n          extendStatic(Gradient, HasObservers$$1);\n          Gradient.prototype = Object.create(HasObservers$$1 && HasObservers$$1.prototype);\n          Gradient.prototype.constructor = Gradient;\n          Gradient.fn = Gradient.prototype;\n          Gradient.fn.init = Gradient.fn.constructor;\n          var prototypeAccessors = {\n            nodeType: {}\n          };\n\n          prototypeAccessors.nodeType.get = function () {\n            return \"Gradient\";\n          };\n\n          Gradient.prototype.userSpace = function userSpace(value) {\n            if (defined(value)) {\n              this._userSpace = value;\n              this.optionsChange();\n              return this;\n            }\n\n            return this._userSpace;\n          };\n\n          Gradient.prototype._createStops = function _createStops(stops) {\n            if (stops === void 0) {\n              stops = [];\n            }\n\n            var result = [];\n\n            for (var idx = 0; idx < stops.length; idx++) {\n              result.push(GradientStop.create(stops[idx]));\n            }\n\n            return result;\n          };\n\n          Gradient.prototype.addStop = function addStop(offset, color, opacity) {\n            this.stops.push(new GradientStop(offset, color, opacity));\n          };\n\n          Gradient.prototype.removeStop = function removeStop(stop) {\n            var index = this.stops.indexOf(stop);\n\n            if (index >= 0) {\n              this.stops.splice(index, 1);\n            }\n          };\n\n          Gradient.prototype.optionsChange = function optionsChange(e) {\n            this.trigger(\"optionsChange\", {\n              field: \"gradient\" + (e ? \".\" + e.field : \"\"),\n              value: this\n            });\n          };\n\n          Gradient.prototype.geometryChange = function geometryChange() {\n            this.optionsChange();\n          };\n\n          Object.defineProperties(Gradient.prototype, prototypeAccessors);\n          return Gradient;\n        }(HasObservers);\n\n        var points$1 = [\"start\", \"end\"];\n\n        var LinearGradient = function (superclass) {\n          function LinearGradient(options) {\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.start(options.start || new Point());\n            this.end(options.end || new Point(1, 0));\n          }\n\n          extendStatic(LinearGradient, superclass);\n          LinearGradient.prototype = Object.create(superclass && superclass.prototype);\n          LinearGradient.prototype.constructor = LinearGradient;\n          LinearGradient.fn = LinearGradient.prototype;\n          LinearGradient.fn.init = LinearGradient.fn.constructor;\n          return LinearGradient;\n        }(withPoints(Gradient, points$1));\n\n        var RadialGradient = function (superclass) {\n          function RadialGradient(options) {\n            if (options === void 0) {\n              options = {};\n            }\n\n            superclass.call(this, options);\n            this.center(options.center || new Point());\n            this._radius = defined(options.radius) ? options.radius : 1;\n            this._fallbackFill = options.fallbackFill;\n          }\n\n          extendStatic(RadialGradient, superclass);\n          RadialGradient.prototype = Object.create(superclass && superclass.prototype);\n          RadialGradient.prototype.constructor = RadialGradient;\n          RadialGradient.fn = RadialGradient.prototype;\n          RadialGradient.fn.init = RadialGradient.fn.constructor;\n\n          RadialGradient.prototype.radius = function radius(value) {\n            if (defined(value)) {\n              this._radius = value;\n              this.geometryChange();\n              return this;\n            }\n\n            return this._radius;\n          };\n\n          RadialGradient.prototype.fallbackFill = function fallbackFill(value) {\n            if (defined(value)) {\n              this._fallbackFill = value;\n              this.optionsChange();\n              return this;\n            }\n\n            return this._fallbackFill;\n          };\n\n          return RadialGradient;\n        }(withPoints(Gradient, [\"center\"]));\n\n        function swing(position) {\n          return 0.5 - Math.cos(position * Math.PI) / 2;\n        }\n\n        function linear(position) {\n          return position;\n        }\n\n        function easeOutElastic(position, time, start, diff) {\n          var s = 1.70158,\n              p = 0,\n              a = diff;\n\n          if (position === 0) {\n            return start;\n          }\n\n          if (position === 1) {\n            return start + diff;\n          }\n\n          if (!p) {\n            p = 0.5;\n          }\n\n          if (a < Math.abs(diff)) {\n            a = diff;\n            s = p / 4;\n          } else {\n            s = p / (2 * Math.PI) * Math.asin(diff / a);\n          }\n\n          return a * Math.pow(2, -10 * position) * Math.sin((Number(position) - s) * (1.1 * Math.PI) / p) + diff + start;\n        }\n\n        var easingFunctions = {\n          swing: swing,\n          linear: linear,\n          easeOutElastic: easeOutElastic\n        };\n        var instance;\n\n        var AnimationFactory = function (Class$$1) {\n          function AnimationFactory() {\n            Class$$1.call(this);\n            this._items = [];\n          }\n\n          extendStatic(AnimationFactory, Class$$1);\n          AnimationFactory.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          AnimationFactory.prototype.constructor = AnimationFactory;\n          AnimationFactory.fn = AnimationFactory.prototype;\n          AnimationFactory.fn.init = AnimationFactory.fn.constructor;\n          var staticAccessors = {\n            current: {}\n          };\n\n          staticAccessors.current.get = function () {\n            if (!instance) {\n              instance = new AnimationFactory();\n            }\n\n            return instance;\n          };\n\n          AnimationFactory.prototype.register = function register(name, type) {\n            this._items.push({\n              name: name,\n              type: type\n            });\n          };\n\n          AnimationFactory.prototype.create = function create(element, options) {\n            var items = this._items;\n            var match;\n\n            if (options && options.type) {\n              var type = options.type.toLowerCase();\n\n              for (var i = 0; i < items.length; i++) {\n                if (items[i].name.toLowerCase() === type) {\n                  match = items[i];\n                  break;\n                }\n              }\n            }\n\n            if (match) {\n              return new match.type(element, options);\n            }\n          };\n\n          Object.defineProperties(AnimationFactory, staticAccessors);\n          return AnimationFactory;\n        }(Class);\n\n        var Animation = function (Class$$1) {\n          function Animation(element, options) {\n            Class$$1.call(this);\n            this.options = $.extend({}, this.options, options);\n            this.element = element;\n          }\n\n          extendStatic(Animation, Class$$1);\n          Animation.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          Animation.prototype.constructor = Animation;\n          Animation.fn = Animation.prototype;\n          Animation.fn.init = Animation.fn.constructor;\n          var prototypeAccessors = {\n            options: {}\n          };\n\n          Animation.create = function create(type, element, options) {\n            return AnimationFactory.current.create(type, element, options);\n          };\n\n          prototypeAccessors.options.get = function () {\n            return this._options || {\n              duration: 500,\n              easing: \"swing\"\n            };\n          };\n\n          prototypeAccessors.options.set = function (value) {\n            this._options = value;\n          };\n\n          Animation.prototype.setup = function setup() {};\n\n          Animation.prototype.step = function step() {};\n\n          Animation.prototype.play = function play() {\n            var this$1 = this;\n            var options = this.options;\n            var duration = options.duration;\n            var delay = options.delay;\n\n            if (delay === void 0) {\n              delay = 0;\n            }\n\n            var easing = easingFunctions[options.easing];\n            var start = now() + delay;\n            var finish = start + duration;\n\n            if (duration === 0) {\n              this.step(1);\n              this.abort();\n            } else {\n              setTimeout(function () {\n                var loop = function () {\n                  if (this$1._stopped) {\n                    return;\n                  }\n\n                  var wallTime = now();\n                  var time = limitValue(wallTime - start, 0, duration);\n                  var position = time / duration;\n                  var easingPosition = easing(position, time, 0, 1, duration);\n                  this$1.step(easingPosition);\n\n                  if (wallTime < finish) {\n                    kendo.animationFrame(loop);\n                  } else {\n                    this$1.abort();\n                  }\n                };\n\n                loop();\n              }, delay);\n            }\n          };\n\n          Animation.prototype.abort = function abort() {\n            this._stopped = true;\n          };\n\n          Animation.prototype.destroy = function destroy() {\n            this.abort();\n          };\n\n          Object.defineProperties(Animation.prototype, prototypeAccessors);\n          return Animation;\n        }(Class);\n\n        var instance$1;\n\n        var PathParser = function (Class$$1) {\n          function PathParser() {\n            Class$$1.apply(this, arguments);\n          }\n\n          extendStatic(PathParser, Class$$1);\n          PathParser.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          PathParser.prototype.constructor = PathParser;\n          PathParser.fn = PathParser.prototype;\n          PathParser.fn.init = PathParser.fn.constructor;\n          var staticAccessors = {\n            current: {}\n          };\n\n          staticAccessors.current.get = function () {\n            if (!instance$1) {\n              instance$1 = new PathParser();\n            }\n\n            return instance$1;\n          };\n\n          PathParser.prototype.parse = function parse(str, options) {\n            var multiPath = new MultiPath(options);\n            return parsePath(multiPath, str);\n          };\n\n          Object.defineProperties(PathParser, staticAccessors);\n          return PathParser;\n        }(Class);\n\n        var BaseNode = function (Class$$1) {\n          function BaseNode(srcElement) {\n            Class$$1.call(this);\n            this.childNodes = [];\n            this.parent = null;\n\n            if (srcElement) {\n              this.srcElement = srcElement;\n              this.observe();\n            }\n          }\n\n          extendStatic(BaseNode, Class$$1);\n          BaseNode.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          BaseNode.prototype.constructor = BaseNode;\n          BaseNode.fn = BaseNode.prototype;\n          BaseNode.fn.init = BaseNode.fn.constructor;\n\n          BaseNode.prototype.destroy = function destroy() {\n            var this$1 = this;\n\n            if (this.srcElement) {\n              this.srcElement.removeObserver(this);\n            }\n\n            var children = this.childNodes;\n\n            for (var i = 0; i < children.length; i++) {\n              this$1.childNodes[i].destroy();\n            }\n\n            this.parent = null;\n          };\n\n          BaseNode.prototype.load = function load() {};\n\n          BaseNode.prototype.observe = function observe() {\n            if (this.srcElement) {\n              this.srcElement.addObserver(this);\n            }\n          };\n\n          BaseNode.prototype.append = function append(node) {\n            this.childNodes.push(node);\n            node.parent = this;\n          };\n\n          BaseNode.prototype.insertAt = function insertAt(node, pos) {\n            this.childNodes.splice(pos, 0, node);\n            node.parent = this;\n          };\n\n          BaseNode.prototype.remove = function remove(index, count) {\n            var this$1 = this;\n            var end = index + count;\n\n            for (var i = index; i < end; i++) {\n              this$1.childNodes[i].removeSelf();\n            }\n\n            this.childNodes.splice(index, count);\n          };\n\n          BaseNode.prototype.removeSelf = function removeSelf() {\n            this.clear();\n            this.destroy();\n          };\n\n          BaseNode.prototype.clear = function clear() {\n            this.remove(0, this.childNodes.length);\n          };\n\n          BaseNode.prototype.invalidate = function invalidate() {\n            if (this.parent) {\n              this.parent.invalidate();\n            }\n          };\n\n          BaseNode.prototype.geometryChange = function geometryChange() {\n            this.invalidate();\n          };\n\n          BaseNode.prototype.optionsChange = function optionsChange() {\n            this.invalidate();\n          };\n\n          BaseNode.prototype.childrenChange = function childrenChange(e) {\n            if (e.action === \"add\") {\n              this.load(e.items, e.index);\n            } else if (e.action === \"remove\") {\n              this.remove(e.index, e.items.length);\n            }\n\n            this.invalidate();\n          };\n\n          return BaseNode;\n        }(Class);\n\n        var events = [\"click\", \"mouseenter\", \"mouseleave\", \"mousemove\", \"resize\"];\n\n        var Surface$2 = function (Observable$$1) {\n          function Surface(element, options) {\n            Observable$$1.call(this);\n            this.options = $.extend({}, options);\n            this.element = element;\n            this.element._kendoExportVisual = this.exportVisual.bind(this);\n            this._click = this._handler(\"click\");\n            this._mouseenter = this._handler(\"mouseenter\");\n            this._mouseleave = this._handler(\"mouseleave\");\n            this._mousemove = this._handler(\"mousemove\");\n            this._visual = new Group();\n            elementSize(element, this.options);\n            this.bind(events, this.options);\n\n            this._enableTracking();\n          }\n\n          extendStatic(Surface, Observable$$1);\n          Surface.prototype = Object.create(Observable$$1 && Observable$$1.prototype);\n          Surface.prototype.constructor = Surface;\n          Surface.fn = Surface.prototype;\n          Surface.fn.init = Surface.fn.constructor;\n\n          Surface.prototype.draw = function draw(element) {\n            this._visual.children.push(element);\n          };\n\n          Surface.prototype.clear = function clear() {\n            this._visual.children = [];\n          };\n\n          Surface.prototype.destroy = function destroy() {\n            this._visual = null;\n            this.element._kendoExportVisual = null;\n            this.unbind();\n          };\n\n          Surface.prototype.eventTarget = function eventTarget(e) {\n            var this$1 = this;\n            var domNode = eventElement(e);\n            var node;\n\n            while (!node && domNode) {\n              node = domNode._kendoNode;\n\n              if (domNode === this$1.element) {\n                break;\n              }\n\n              domNode = domNode.parentElement;\n            }\n\n            if (node) {\n              return node.srcElement;\n            }\n          };\n\n          Surface.prototype.exportVisual = function exportVisual() {\n            return this._visual;\n          };\n\n          Surface.prototype.getSize = function getSize() {\n            return elementSize(this.element);\n          };\n\n          Surface.prototype.currentSize = function currentSize(size) {\n            if (size) {\n              this._size = size;\n            } else {\n              return this._size;\n            }\n          };\n\n          Surface.prototype.setSize = function setSize(size) {\n            elementSize(this.element, size);\n            this.currentSize(size);\n\n            this._resize();\n          };\n\n          Surface.prototype.resize = function resize(force) {\n            var size = this.getSize();\n            var currentSize = this.currentSize();\n\n            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n              this.currentSize(size);\n\n              this._resize(size, force);\n\n              this.trigger(\"resize\", size);\n            }\n          };\n\n          Surface.prototype.size = function size(value) {\n            if (!value) {\n              return this.getSize();\n            }\n\n            this.setSize(value);\n          };\n\n          Surface.prototype.suspendTracking = function suspendTracking() {\n            this._suspendedTracking = true;\n          };\n\n          Surface.prototype.resumeTracking = function resumeTracking() {\n            this._suspendedTracking = false;\n          };\n\n          Surface.prototype._enableTracking = function _enableTracking() {};\n\n          Surface.prototype._resize = function _resize() {};\n\n          Surface.prototype._handler = function _handler(eventName) {\n            var this$1 = this;\n            return function (e) {\n              var node = this$1.eventTarget(e);\n\n              if (node && !this$1._suspendedTracking) {\n                this$1.trigger(eventName, {\n                  element: node,\n                  originalEvent: e,\n                  type: eventName\n                });\n              }\n            };\n          };\n\n          Surface.prototype._elementOffset = function _elementOffset() {\n            var element = this.element;\n            var padding = elementPadding(element);\n            var ref = elementOffset(element);\n            var left = ref.left;\n            var top = ref.top;\n            return {\n              left: left + padding.left,\n              top: top + padding.top\n            };\n          };\n\n          Surface.prototype._surfacePoint = function _surfacePoint(e) {\n            var offset = this._elementOffset();\n\n            var coord = eventCoordinates(e);\n            var x = coord.x - offset.left;\n            var y = coord.y - offset.top;\n            var inverseTransform = elementScale(this.element).invert();\n            var point = new Point(x, y).transform(inverseTransform);\n            return point;\n          };\n\n          return Surface;\n        }(kendo.Observable);\n\n        function renderAttr(name, value) {\n          return defined(value) && value !== null ? \" \" + name + \"=\\\"\" + value + \"\\\" \" : \"\";\n        }\n\n        function renderAllAttr(attrs) {\n          var output = \"\";\n\n          for (var i = 0; i < attrs.length; i++) {\n            output += renderAttr(attrs[i][0], attrs[i][1]);\n          }\n\n          return output;\n        }\n\n        function renderStyle(attrs) {\n          var output = \"\";\n\n          for (var i = 0; i < attrs.length; i++) {\n            var value = attrs[i][1];\n\n            if (defined(value)) {\n              output += attrs[i][0] + \":\" + value + \";\";\n            }\n          }\n\n          if (output !== \"\") {\n            return output;\n          }\n        }\n\n        var NODE_MAP = {};\n        var SVG_NS = \"http://www.w3.org/2000/svg\";\n        var NONE = \"none\";\n\n        var renderSVG = function (container, svg) {\n          container.innerHTML = svg;\n        };\n\n        if (typeof document !== \"undefined\") {\n          var testFragment = \"<svg xmlns='\" + SVG_NS + \"'></svg>\";\n          var testContainer = document.createElement(\"div\");\n          var hasParser = typeof DOMParser !== \"undefined\";\n          testContainer.innerHTML = testFragment;\n\n          if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {\n            renderSVG = function (container, svg) {\n              var parser = new DOMParser();\n              var chartDoc = parser.parseFromString(svg, \"text/xml\");\n              var importedDoc = document.adoptNode(chartDoc.documentElement);\n              container.innerHTML = \"\";\n              container.appendChild(importedDoc);\n            };\n          }\n        }\n\n        var renderSVG$1 = renderSVG;\n        var TRANSFORM = \"transform\";\n        var DefinitionMap = {\n          clip: \"clip-path\",\n          fill: \"fill\"\n        };\n\n        function isDefinition(type, value) {\n          return type === \"clip\" || type === \"fill\" && (!value || value.nodeType === \"Gradient\");\n        }\n\n        function baseUrl() {\n          var base = document.getElementsByTagName(\"base\")[0];\n          var href = document.location.href;\n          var url = \"\";\n\n          if (base && !(supportBrowser || {}).msie) {\n            var hashIndex = href.indexOf(\"#\");\n\n            if (hashIndex !== -1) {\n              href = href.substring(0, hashIndex);\n            }\n\n            url = href;\n          }\n\n          return url;\n        }\n\n        var Node = function (BaseNode$$1) {\n          function Node(srcElement, options) {\n            BaseNode$$1.call(this, srcElement);\n            this.definitions = {};\n            this.options = options;\n          }\n\n          extendStatic(Node, BaseNode$$1);\n          Node.prototype = Object.create(BaseNode$$1 && BaseNode$$1.prototype);\n          Node.prototype.constructor = Node;\n          Node.fn = Node.prototype;\n          Node.fn.init = Node.fn.constructor;\n\n          Node.prototype.destroy = function destroy() {\n            if (this.element) {\n              this.element._kendoNode = null;\n              this.element = null;\n            }\n\n            this.clearDefinitions();\n            BaseNode$$1.prototype.destroy.call(this);\n          };\n\n          Node.prototype.load = function load(elements, pos) {\n            var this$1 = this;\n\n            for (var i = 0; i < elements.length; i++) {\n              var srcElement = elements[i];\n              var children = srcElement.children;\n              var childNode = new NODE_MAP[srcElement.nodeType](srcElement, this$1.options);\n\n              if (defined(pos)) {\n                this$1.insertAt(childNode, pos);\n              } else {\n                this$1.append(childNode);\n              }\n\n              childNode.createDefinitions();\n\n              if (children && children.length > 0) {\n                childNode.load(children);\n              }\n\n              var element = this$1.element;\n\n              if (element) {\n                childNode.attachTo(element, pos);\n              }\n            }\n          };\n\n          Node.prototype.root = function root() {\n            var root = this;\n\n            while (root.parent) {\n              root = root.parent;\n            }\n\n            return root;\n          };\n\n          Node.prototype.attachTo = function attachTo(domElement, pos) {\n            var container = document.createElement(\"div\");\n            renderSVG$1(container, \"<svg xmlns='\" + SVG_NS + \"' version='1.1'>\" + this.render() + \"</svg>\");\n            var element = container.firstChild.firstChild;\n\n            if (element) {\n              if (defined(pos)) {\n                domElement.insertBefore(element, domElement.childNodes[pos] || null);\n              } else {\n                domElement.appendChild(element);\n              }\n\n              this.setElement(element);\n            }\n          };\n\n          Node.prototype.setElement = function setElement(element) {\n            if (this.element) {\n              this.element._kendoNode = null;\n            }\n\n            this.element = element;\n            this.element._kendoNode = this;\n            var nodes = this.childNodes;\n\n            for (var i = 0; i < nodes.length; i++) {\n              var childElement = element.childNodes[i];\n              nodes[i].setElement(childElement);\n            }\n          };\n\n          Node.prototype.clear = function clear() {\n            this.clearDefinitions();\n\n            if (this.element) {\n              this.element.innerHTML = \"\";\n            }\n\n            var children = this.childNodes;\n\n            for (var i = 0; i < children.length; i++) {\n              children[i].destroy();\n            }\n\n            this.childNodes = [];\n          };\n\n          Node.prototype.removeSelf = function removeSelf() {\n            if (this.element) {\n              var parentNode = this.element.parentNode;\n\n              if (parentNode) {\n                parentNode.removeChild(this.element);\n              }\n\n              this.element = null;\n            }\n\n            BaseNode$$1.prototype.removeSelf.call(this);\n          };\n\n          Node.prototype.template = function template() {\n            return this.renderChildren();\n          };\n\n          Node.prototype.render = function render() {\n            return this.template();\n          };\n\n          Node.prototype.renderChildren = function renderChildren() {\n            var nodes = this.childNodes;\n            var output = \"\";\n\n            for (var i = 0; i < nodes.length; i++) {\n              output += nodes[i].render();\n            }\n\n            return output;\n          };\n\n          Node.prototype.optionsChange = function optionsChange(e) {\n            var field = e.field;\n            var value = e.value;\n\n            if (field === \"visible\") {\n              this.css(\"display\", value ? \"\" : NONE);\n            } else if (DefinitionMap[field] && isDefinition(field, value)) {\n              this.updateDefinition(field, value);\n            } else if (field === \"opacity\") {\n              this.attr(\"opacity\", value);\n            } else if (field === \"cursor\") {\n              this.css(\"cursor\", value);\n            } else if (field === \"id\") {\n              if (value) {\n                this.attr(\"id\", value);\n              } else {\n                this.removeAttr(\"id\");\n              }\n            }\n\n            BaseNode$$1.prototype.optionsChange.call(this, e);\n          };\n\n          Node.prototype.attr = function attr(name, value) {\n            if (this.element) {\n              this.element.setAttribute(name, value);\n            }\n          };\n\n          Node.prototype.allAttr = function allAttr(attrs) {\n            var this$1 = this;\n\n            for (var i = 0; i < attrs.length; i++) {\n              this$1.attr(attrs[i][0], attrs[i][1]);\n            }\n          };\n\n          Node.prototype.css = function css(name, value) {\n            if (this.element) {\n              this.element.style[name] = value;\n            }\n          };\n\n          Node.prototype.allCss = function allCss(styles) {\n            var this$1 = this;\n\n            for (var i = 0; i < styles.length; i++) {\n              this$1.css(styles[i][0], styles[i][1]);\n            }\n          };\n\n          Node.prototype.removeAttr = function removeAttr(name) {\n            if (this.element) {\n              this.element.removeAttribute(name);\n            }\n          };\n\n          Node.prototype.mapTransform = function mapTransform(transform) {\n            var attrs = [];\n\n            if (transform) {\n              attrs.push([TRANSFORM, \"matrix(\" + transform.matrix().toString(6) + \")\"]);\n            }\n\n            return attrs;\n          };\n\n          Node.prototype.renderTransform = function renderTransform() {\n            return renderAllAttr(this.mapTransform(this.srcElement.transform()));\n          };\n\n          Node.prototype.transformChange = function transformChange(value) {\n            if (value) {\n              this.allAttr(this.mapTransform(value));\n            } else {\n              this.removeAttr(TRANSFORM);\n            }\n          };\n\n          Node.prototype.mapStyle = function mapStyle() {\n            var options = this.srcElement.options;\n            var style = [[\"cursor\", options.cursor]];\n\n            if (options.visible === false) {\n              style.push([\"display\", NONE]);\n            }\n\n            return style;\n          };\n\n          Node.prototype.renderStyle = function renderStyle$1() {\n            return renderAttr(\"style\", renderStyle(this.mapStyle(true)));\n          };\n\n          Node.prototype.renderOpacity = function renderOpacity() {\n            return renderAttr(\"opacity\", this.srcElement.options.opacity);\n          };\n\n          Node.prototype.renderId = function renderId() {\n            return renderAttr(\"id\", this.srcElement.options.id);\n          };\n\n          Node.prototype.createDefinitions = function createDefinitions() {\n            var srcElement = this.srcElement;\n            var definitions = this.definitions;\n\n            if (srcElement) {\n              var options = srcElement.options;\n              var hasDefinitions;\n\n              for (var field in DefinitionMap) {\n                var definition = options.get(field);\n\n                if (definition && isDefinition(field, definition)) {\n                  definitions[field] = definition;\n                  hasDefinitions = true;\n                }\n              }\n\n              if (hasDefinitions) {\n                this.definitionChange({\n                  action: \"add\",\n                  definitions: definitions\n                });\n              }\n            }\n          };\n\n          Node.prototype.definitionChange = function definitionChange(e) {\n            if (this.parent) {\n              this.parent.definitionChange(e);\n            }\n          };\n\n          Node.prototype.updateDefinition = function updateDefinition(type, value) {\n            var definitions = this.definitions;\n            var current = definitions[type];\n            var attr = DefinitionMap[type];\n            var definition = {};\n\n            if (current) {\n              definition[type] = current;\n              this.definitionChange({\n                action: \"remove\",\n                definitions: definition\n              });\n              delete definitions[type];\n            }\n\n            if (!value) {\n              if (current) {\n                this.removeAttr(attr);\n              }\n            } else {\n              definition[type] = value;\n              this.definitionChange({\n                action: \"add\",\n                definitions: definition\n              });\n              definitions[type] = value;\n              this.attr(attr, this.refUrl(value.id));\n            }\n          };\n\n          Node.prototype.clearDefinitions = function clearDefinitions() {\n            var definitions = this.definitions;\n            this.definitionChange({\n              action: \"remove\",\n              definitions: definitions\n            });\n            this.definitions = {};\n          };\n\n          Node.prototype.renderDefinitions = function renderDefinitions() {\n            return renderAllAttr(this.mapDefinitions());\n          };\n\n          Node.prototype.mapDefinitions = function mapDefinitions() {\n            var this$1 = this;\n            var definitions = this.definitions;\n            var attrs = [];\n\n            for (var field in definitions) {\n              attrs.push([DefinitionMap[field], this$1.refUrl(definitions[field].id)]);\n            }\n\n            return attrs;\n          };\n\n          Node.prototype.refUrl = function refUrl(id) {\n            var skipBaseHref = (this.options || {}).skipBaseHref;\n            var baseHref = this.baseUrl().replace(/'/g, \"\\\\'\");\n            var base = skipBaseHref ? '' : baseHref;\n            return \"url(\" + base + \"#\" + id + \")\";\n          };\n\n          Node.prototype.baseUrl = function baseUrl$1() {\n            return baseUrl();\n          };\n\n          return Node;\n        }(BaseNode);\n\n        var GradientStopNode = function (Node$$1) {\n          function GradientStopNode() {\n            Node$$1.apply(this, arguments);\n          }\n\n          extendStatic(GradientStopNode, Node$$1);\n          GradientStopNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          GradientStopNode.prototype.constructor = GradientStopNode;\n          GradientStopNode.fn = GradientStopNode.prototype;\n          GradientStopNode.fn.init = GradientStopNode.fn.constructor;\n\n          GradientStopNode.prototype.template = function template() {\n            return \"<stop \" + this.renderOffset() + \" \" + this.renderStyle() + \" />\";\n          };\n\n          GradientStopNode.prototype.renderOffset = function renderOffset() {\n            return renderAttr(\"offset\", this.srcElement.offset());\n          };\n\n          GradientStopNode.prototype.mapStyle = function mapStyle() {\n            var srcElement = this.srcElement;\n            return [[\"stop-color\", srcElement.color()], [\"stop-opacity\", srcElement.opacity()]];\n          };\n\n          GradientStopNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"offset\") {\n              this.attr(e.field, e.value);\n            } else if (e.field === \"color\" || e.field === \"opacity\") {\n              this.css(\"stop-\" + e.field, e.value);\n            }\n          };\n\n          return GradientStopNode;\n        }(Node);\n\n        var GradientNode = function (Node$$1) {\n          function GradientNode(srcElement) {\n            Node$$1.call(this, srcElement);\n            this.id = srcElement.id;\n            this.loadStops();\n          }\n\n          extendStatic(GradientNode, Node$$1);\n          GradientNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          GradientNode.prototype.constructor = GradientNode;\n          GradientNode.fn = GradientNode.prototype;\n          GradientNode.fn.init = GradientNode.fn.constructor;\n\n          GradientNode.prototype.loadStops = function loadStops() {\n            var this$1 = this;\n            var stops = this.srcElement.stops;\n            var element = this.element;\n\n            for (var idx = 0; idx < stops.length; idx++) {\n              var stopNode = new GradientStopNode(stops[idx]);\n              this$1.append(stopNode);\n\n              if (element) {\n                stopNode.attachTo(element);\n              }\n            }\n          };\n\n          GradientNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"gradient.stops\") {\n              BaseNode.prototype.clear.call(this);\n              this.loadStops();\n            } else if (e.field === \"gradient\") {\n              this.allAttr(this.mapCoordinates());\n            }\n          };\n\n          GradientNode.prototype.renderCoordinates = function renderCoordinates() {\n            return renderAllAttr(this.mapCoordinates());\n          };\n\n          GradientNode.prototype.mapSpace = function mapSpace() {\n            return [\"gradientUnits\", this.srcElement.userSpace() ? \"userSpaceOnUse\" : \"objectBoundingBox\"];\n          };\n\n          return GradientNode;\n        }(Node);\n\n        var LinearGradientNode = function (GradientNode$$1) {\n          function LinearGradientNode() {\n            GradientNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(LinearGradientNode, GradientNode$$1);\n          LinearGradientNode.prototype = Object.create(GradientNode$$1 && GradientNode$$1.prototype);\n          LinearGradientNode.prototype.constructor = LinearGradientNode;\n          LinearGradientNode.fn = LinearGradientNode.prototype;\n          LinearGradientNode.fn.init = LinearGradientNode.fn.constructor;\n\n          LinearGradientNode.prototype.template = function template() {\n            return \"<linearGradient id='\" + this.id + \"' \" + this.renderCoordinates() + \">\" + this.renderChildren() + \"</linearGradient>\";\n          };\n\n          LinearGradientNode.prototype.mapCoordinates = function mapCoordinates() {\n            var srcElement = this.srcElement;\n            var start = srcElement.start();\n            var end = srcElement.end();\n            var attrs = [[\"x1\", start.x], [\"y1\", start.y], [\"x2\", end.x], [\"y2\", end.y], this.mapSpace()];\n            return attrs;\n          };\n\n          return LinearGradientNode;\n        }(GradientNode);\n\n        var RadialGradientNode = function (GradientNode$$1) {\n          function RadialGradientNode() {\n            GradientNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(RadialGradientNode, GradientNode$$1);\n          RadialGradientNode.prototype = Object.create(GradientNode$$1 && GradientNode$$1.prototype);\n          RadialGradientNode.prototype.constructor = RadialGradientNode;\n          RadialGradientNode.fn = RadialGradientNode.prototype;\n          RadialGradientNode.fn.init = RadialGradientNode.fn.constructor;\n\n          RadialGradientNode.prototype.template = function template() {\n            return \"<radialGradient id='\" + this.id + \"' \" + this.renderCoordinates() + \">\" + this.renderChildren() + \"</radialGradient>\";\n          };\n\n          RadialGradientNode.prototype.mapCoordinates = function mapCoordinates() {\n            var srcElement = this.srcElement;\n            var center = srcElement.center();\n            var radius = srcElement.radius();\n            var attrs = [[\"cx\", center.x], [\"cy\", center.y], [\"r\", radius], this.mapSpace()];\n            return attrs;\n          };\n\n          return RadialGradientNode;\n        }(GradientNode);\n\n        var ClipNode = function (Node$$1) {\n          function ClipNode(srcElement) {\n            Node$$1.call(this);\n            this.srcElement = srcElement;\n            this.id = srcElement.id;\n            this.load([srcElement]);\n          }\n\n          extendStatic(ClipNode, Node$$1);\n          ClipNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          ClipNode.prototype.constructor = ClipNode;\n          ClipNode.fn = ClipNode.prototype;\n          ClipNode.fn.init = ClipNode.fn.constructor;\n\n          ClipNode.prototype.template = function template() {\n            return \"<clipPath id='\" + this.id + \"'>\" + this.renderChildren() + \"</clipPath>\";\n          };\n\n          return ClipNode;\n        }(Node);\n\n        var DefinitionNode = function (Node$$1) {\n          function DefinitionNode() {\n            Node$$1.call(this);\n            this.definitionMap = {};\n          }\n\n          extendStatic(DefinitionNode, Node$$1);\n          DefinitionNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          DefinitionNode.prototype.constructor = DefinitionNode;\n          DefinitionNode.fn = DefinitionNode.prototype;\n          DefinitionNode.fn.init = DefinitionNode.fn.constructor;\n\n          DefinitionNode.prototype.attachTo = function attachTo(domElement) {\n            this.element = domElement;\n          };\n\n          DefinitionNode.prototype.template = function template() {\n            return \"<defs>\" + this.renderChildren() + \"</defs>\";\n          };\n\n          DefinitionNode.prototype.definitionChange = function definitionChange(e) {\n            var definitions = e.definitions;\n            var action = e.action;\n\n            if (action === \"add\") {\n              this.addDefinitions(definitions);\n            } else if (action === \"remove\") {\n              this.removeDefinitions(definitions);\n            }\n          };\n\n          DefinitionNode.prototype.createDefinition = function createDefinition(type, item) {\n            var nodeType;\n\n            if (type === \"clip\") {\n              nodeType = ClipNode;\n            } else if (type === \"fill\") {\n              if (item instanceof LinearGradient) {\n                nodeType = LinearGradientNode;\n              } else if (item instanceof RadialGradient) {\n                nodeType = RadialGradientNode;\n              }\n            }\n\n            return new nodeType(item);\n          };\n\n          DefinitionNode.prototype.addDefinitions = function addDefinitions(definitions) {\n            var this$1 = this;\n\n            for (var field in definitions) {\n              this$1.addDefinition(field, definitions[field]);\n            }\n          };\n\n          DefinitionNode.prototype.addDefinition = function addDefinition(type, srcElement) {\n            var ref = this;\n            var element = ref.element;\n            var definitionMap = ref.definitionMap;\n            var id = srcElement.id;\n            var mapItem = definitionMap[id];\n\n            if (!mapItem) {\n              var node = this.createDefinition(type, srcElement);\n              definitionMap[id] = {\n                element: node,\n                count: 1\n              };\n              this.append(node);\n\n              if (element) {\n                node.attachTo(this.element);\n              }\n            } else {\n              mapItem.count++;\n            }\n          };\n\n          DefinitionNode.prototype.removeDefinitions = function removeDefinitions(definitions) {\n            var this$1 = this;\n\n            for (var field in definitions) {\n              this$1.removeDefinition(definitions[field]);\n            }\n          };\n\n          DefinitionNode.prototype.removeDefinition = function removeDefinition(srcElement) {\n            var definitionMap = this.definitionMap;\n            var id = srcElement.id;\n            var mapItem = definitionMap[id];\n\n            if (mapItem) {\n              mapItem.count--;\n\n              if (mapItem.count === 0) {\n                this.remove(this.childNodes.indexOf(mapItem.element), 1);\n                delete definitionMap[id];\n              }\n            }\n          };\n\n          return DefinitionNode;\n        }(Node);\n\n        var RootNode = function (Node$$1) {\n          function RootNode(options) {\n            Node$$1.call(this);\n            this.options = options;\n            this.defs = new DefinitionNode();\n          }\n\n          extendStatic(RootNode, Node$$1);\n          RootNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          RootNode.prototype.constructor = RootNode;\n          RootNode.fn = RootNode.prototype;\n          RootNode.fn.init = RootNode.fn.constructor;\n\n          RootNode.prototype.attachTo = function attachTo(domElement) {\n            this.element = domElement;\n            this.defs.attachTo(domElement.firstElementChild);\n          };\n\n          RootNode.prototype.clear = function clear() {\n            BaseNode.prototype.clear.call(this);\n          };\n\n          RootNode.prototype.template = function template() {\n            return this.defs.render() + this.renderChildren();\n          };\n\n          RootNode.prototype.definitionChange = function definitionChange(e) {\n            this.defs.definitionChange(e);\n          };\n\n          return RootNode;\n        }(Node);\n\n        var DASH_ARRAYS = {\n          dot: [1.5, 3.5],\n          dash: [4, 3.5],\n          longdash: [8, 3.5],\n          dashdot: [3.5, 3.5, 1.5, 3.5],\n          longdashdot: [8, 3.5, 1.5, 3.5],\n          longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]\n        };\n        var SOLID = \"solid\";\n        var BUTT = \"butt\";\n        var ATTRIBUTE_MAP = {\n          \"fill.opacity\": \"fill-opacity\",\n          \"stroke.color\": \"stroke\",\n          \"stroke.width\": \"stroke-width\",\n          \"stroke.opacity\": \"stroke-opacity\"\n        };\n        var SPACE = \" \";\n\n        var PathNode = function (Node$$1) {\n          function PathNode() {\n            Node$$1.apply(this, arguments);\n          }\n\n          extendStatic(PathNode, Node$$1);\n          PathNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          PathNode.prototype.constructor = PathNode;\n          PathNode.fn = PathNode.prototype;\n          PathNode.fn.init = PathNode.fn.constructor;\n\n          PathNode.prototype.geometryChange = function geometryChange() {\n            this.attr(\"d\", this.renderData());\n            this.invalidate();\n          };\n\n          PathNode.prototype.optionsChange = function optionsChange(e) {\n            switch (e.field) {\n              case \"fill\":\n                if (e.value) {\n                  this.allAttr(this.mapFill(e.value));\n                } else {\n                  this.removeAttr(\"fill\");\n                }\n\n                break;\n\n              case \"fill.color\":\n                this.allAttr(this.mapFill({\n                  color: e.value\n                }));\n                break;\n\n              case \"stroke\":\n                if (e.value) {\n                  this.allAttr(this.mapStroke(e.value));\n                } else {\n                  this.removeAttr(\"stroke\");\n                }\n\n                break;\n\n              case \"transform\":\n                this.transformChange(e.value);\n                break;\n\n              default:\n                var name = ATTRIBUTE_MAP[e.field];\n\n                if (name) {\n                  this.attr(name, e.value);\n                }\n\n                break;\n            }\n\n            Node$$1.prototype.optionsChange.call(this, e);\n          };\n\n          PathNode.prototype.content = function content() {\n            if (this.element) {\n              this.element.textContent = this.srcElement.content();\n            }\n          };\n\n          PathNode.prototype.renderData = function renderData() {\n            return this.printPath(this.srcElement);\n          };\n\n          PathNode.prototype.printPath = function printPath(path) {\n            var this$1 = this;\n            var segments = path.segments;\n            var length = segments.length;\n\n            if (length > 0) {\n              var parts = [];\n              var output, currentType;\n\n              for (var i = 1; i < length; i++) {\n                var segmentType = this$1.segmentType(segments[i - 1], segments[i]);\n\n                if (segmentType !== currentType) {\n                  currentType = segmentType;\n                  parts.push(segmentType);\n                }\n\n                if (segmentType === \"L\") {\n                  parts.push(this$1.printPoints(segments[i].anchor()));\n                } else {\n                  parts.push(this$1.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n                }\n              }\n\n              output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n\n              if (path.options.closed) {\n                output += \"Z\";\n              }\n\n              return output;\n            }\n          };\n\n          PathNode.prototype.printPoints = function printPoints() {\n            var points = arguments;\n            var length = points.length;\n            var result = [];\n\n            for (var i = 0; i < length; i++) {\n              result.push(points[i].toString(3));\n            }\n\n            return result.join(\" \");\n          };\n\n          PathNode.prototype.segmentType = function segmentType(segmentStart, segmentEnd) {\n            return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n          };\n\n          PathNode.prototype.mapStroke = function mapStroke(stroke) {\n            var attrs = [];\n\n            if (stroke && !isTransparent(stroke.color)) {\n              attrs.push([\"stroke\", stroke.color]);\n              attrs.push([\"stroke-width\", stroke.width]);\n              attrs.push([\"stroke-linecap\", this.renderLinecap(stroke)]);\n              attrs.push([\"stroke-linejoin\", stroke.lineJoin]);\n\n              if (defined(stroke.opacity)) {\n                attrs.push([\"stroke-opacity\", stroke.opacity]);\n              }\n\n              if (defined(stroke.dashType)) {\n                attrs.push([\"stroke-dasharray\", this.renderDashType(stroke)]);\n              }\n            } else {\n              attrs.push([\"stroke\", NONE]);\n            }\n\n            return attrs;\n          };\n\n          PathNode.prototype.renderStroke = function renderStroke() {\n            return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));\n          };\n\n          PathNode.prototype.renderDashType = function renderDashType(stroke) {\n            var dashType = stroke.dashType;\n            var width = stroke.width;\n\n            if (width === void 0) {\n              width = 1;\n            }\n\n            if (dashType && dashType !== SOLID) {\n              var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n              var result = [];\n\n              for (var i = 0; i < dashArray.length; i++) {\n                result.push(dashArray[i] * width);\n              }\n\n              return result.join(\" \");\n            }\n          };\n\n          PathNode.prototype.renderLinecap = function renderLinecap(stroke) {\n            var dashType = stroke.dashType;\n            var lineCap = stroke.lineCap;\n            return dashType && dashType !== \"solid\" ? BUTT : lineCap;\n          };\n\n          PathNode.prototype.mapFill = function mapFill(fill) {\n            var attrs = [];\n\n            if (!(fill && fill.nodeType === \"Gradient\")) {\n              if (fill && !isTransparent(fill.color)) {\n                attrs.push([\"fill\", fill.color]);\n\n                if (defined(fill.opacity)) {\n                  attrs.push([\"fill-opacity\", fill.opacity]);\n                }\n              } else {\n                attrs.push([\"fill\", NONE]);\n              }\n            }\n\n            return attrs;\n          };\n\n          PathNode.prototype.renderFill = function renderFill() {\n            return renderAllAttr(this.mapFill(this.srcElement.options.fill));\n          };\n\n          PathNode.prototype.template = function template() {\n            return \"<path \" + this.renderId() + \" \" + this.renderStyle() + \" \" + this.renderOpacity() + \" \" + renderAttr('d', this.renderData()) + \"\" + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + \"></path>\";\n          };\n\n          return PathNode;\n        }(Node);\n\n        var ArcNode = function (PathNode$$1) {\n          function ArcNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(ArcNode, PathNode$$1);\n          ArcNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          ArcNode.prototype.constructor = ArcNode;\n          ArcNode.fn = ArcNode.prototype;\n          ArcNode.fn.init = ArcNode.fn.constructor;\n\n          ArcNode.prototype.renderData = function renderData() {\n            return this.printPath(this.srcElement.toPath());\n          };\n\n          return ArcNode;\n        }(PathNode);\n\n        var CircleNode = function (PathNode$$1) {\n          function CircleNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(CircleNode, PathNode$$1);\n          CircleNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          CircleNode.prototype.constructor = CircleNode;\n          CircleNode.fn = CircleNode.prototype;\n          CircleNode.fn.init = CircleNode.fn.constructor;\n\n          CircleNode.prototype.geometryChange = function geometryChange() {\n            var center = this.center();\n            this.attr(\"cx\", center.x);\n            this.attr(\"cy\", center.y);\n            this.attr(\"r\", this.radius());\n            this.invalidate();\n          };\n\n          CircleNode.prototype.center = function center() {\n            return this.srcElement.geometry().center;\n          };\n\n          CircleNode.prototype.radius = function radius() {\n            return this.srcElement.geometry().radius;\n          };\n\n          CircleNode.prototype.template = function template() {\n            return \"<circle \" + this.renderId() + \" \" + this.renderStyle() + \" \" + this.renderOpacity() + \"cx='\" + this.center().x + \"' cy='\" + this.center().y + \"' r='\" + this.radius() + \"'\" + this.renderStroke() + \" \" + this.renderFill() + \" \" + this.renderDefinitions() + this.renderTransform() + \" ></circle>\";\n          };\n\n          return CircleNode;\n        }(PathNode);\n\n        var GroupNode = function (Node$$1) {\n          function GroupNode() {\n            Node$$1.apply(this, arguments);\n          }\n\n          extendStatic(GroupNode, Node$$1);\n          GroupNode.prototype = Object.create(Node$$1 && Node$$1.prototype);\n          GroupNode.prototype.constructor = GroupNode;\n          GroupNode.fn = GroupNode.prototype;\n          GroupNode.fn.init = GroupNode.fn.constructor;\n\n          GroupNode.prototype.template = function template() {\n            return \"<g\" + (this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions()) + \">\" + this.renderChildren() + \"</g>\";\n          };\n\n          GroupNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"transform\") {\n              this.transformChange(e.value);\n            }\n\n            Node$$1.prototype.optionsChange.call(this, e);\n          };\n\n          return GroupNode;\n        }(Node);\n\n        var ImageNode = function (PathNode$$1) {\n          function ImageNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(ImageNode, PathNode$$1);\n          ImageNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          ImageNode.prototype.constructor = ImageNode;\n          ImageNode.fn = ImageNode.prototype;\n          ImageNode.fn.init = ImageNode.fn.constructor;\n\n          ImageNode.prototype.geometryChange = function geometryChange() {\n            this.allAttr(this.mapPosition());\n            this.invalidate();\n          };\n\n          ImageNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"src\") {\n              this.allAttr(this.mapSource());\n            }\n\n            PathNode$$1.prototype.optionsChange.call(this, e);\n          };\n\n          ImageNode.prototype.mapPosition = function mapPosition() {\n            var rect = this.srcElement.rect();\n            var tl = rect.topLeft();\n            return [[\"x\", tl.x], [\"y\", tl.y], [\"width\", rect.width() + \"px\"], [\"height\", rect.height() + \"px\"]];\n          };\n\n          ImageNode.prototype.renderPosition = function renderPosition() {\n            return renderAllAttr(this.mapPosition());\n          };\n\n          ImageNode.prototype.mapSource = function mapSource(encode) {\n            var src = this.srcElement.src();\n\n            if (encode) {\n              src = kendo.htmlEncode(src);\n            }\n\n            return [[\"xlink:href\", src]];\n          };\n\n          ImageNode.prototype.renderSource = function renderSource() {\n            return renderAllAttr(this.mapSource(true));\n          };\n\n          ImageNode.prototype.template = function template() {\n            return \"<image preserveAspectRatio='none' \" + this.renderId() + \" \" + this.renderStyle() + \" \" + this.renderTransform() + \" \" + this.renderOpacity() + this.renderPosition() + \" \" + this.renderSource() + \" \" + this.renderDefinitions() + \">\" + \"</image>\";\n          };\n\n          return ImageNode;\n        }(PathNode);\n\n        var MultiPathNode = function (PathNode$$1) {\n          function MultiPathNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(MultiPathNode, PathNode$$1);\n          MultiPathNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          MultiPathNode.prototype.constructor = MultiPathNode;\n          MultiPathNode.fn = MultiPathNode.prototype;\n          MultiPathNode.fn.init = MultiPathNode.fn.constructor;\n\n          MultiPathNode.prototype.renderData = function renderData() {\n            var this$1 = this;\n            var paths = this.srcElement.paths;\n\n            if (paths.length > 0) {\n              var result = [];\n\n              for (var i = 0; i < paths.length; i++) {\n                result.push(this$1.printPath(paths[i]));\n              }\n\n              return result.join(\" \");\n            }\n          };\n\n          return MultiPathNode;\n        }(PathNode);\n\n        var RectNode = function (PathNode$$1) {\n          function RectNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(RectNode, PathNode$$1);\n          RectNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          RectNode.prototype.constructor = RectNode;\n          RectNode.fn = RectNode.prototype;\n          RectNode.fn.init = RectNode.fn.constructor;\n\n          RectNode.prototype.geometryChange = function geometryChange() {\n            var geometry = this.srcElement.geometry();\n            this.attr(\"x\", geometry.origin.x);\n            this.attr(\"y\", geometry.origin.y);\n            this.attr(\"width\", geometry.size.width);\n            this.attr(\"height\", geometry.size.height);\n            this.attr(\"rx\", geometry.cornerRadius[0]);\n            this.attr(\"ry\", geometry.cornerRadius[1]);\n            this.invalidate();\n          };\n\n          RectNode.prototype.size = function size() {\n            return this.srcElement.geometry().size;\n          };\n\n          RectNode.prototype.origin = function origin() {\n            return this.srcElement.geometry().origin;\n          };\n\n          RectNode.prototype.rx = function rx() {\n            return this.srcElement.geometry().cornerRadius[0];\n          };\n\n          RectNode.prototype.ry = function ry() {\n            return this.srcElement.geometry().cornerRadius[1];\n          };\n\n          RectNode.prototype.template = function template() {\n            return \"<rect \" + this.renderId() + \" \" + this.renderStyle() + \" \" + this.renderOpacity() + \" x='\" + this.origin().x + \"' y='\" + this.origin().y + \"' \" + \"rx='\" + this.rx() + \"' ry='\" + this.ry() + \"' \" + \"width='\" + this.size().width + \"' height='\" + this.size().height + \"' \" + this.renderStroke() + \" \" + this.renderFill() + \" \" + this.renderDefinitions() + \" \" + this.renderTransform() + \" />\";\n          };\n\n          return RectNode;\n        }(PathNode);\n\n        var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\\d+);/g;\n\n        function decodeEntities(text) {\n          if (!text || typeof text !== \"string\" || !ENTITY_REGEX.test(text)) {\n            return text;\n          }\n\n          var element = decodeEntities._element;\n          ENTITY_REGEX.lastIndex = 0;\n          return text.replace(ENTITY_REGEX, function (match) {\n            element.innerHTML = match;\n            return element.textContent || element.innerText;\n          });\n        }\n\n        if (typeof document !== \"undefined\") {\n          decodeEntities._element = document.createElement(\"span\");\n        }\n\n        var TextNode = function (PathNode$$1) {\n          function TextNode() {\n            PathNode$$1.apply(this, arguments);\n          }\n\n          extendStatic(TextNode, PathNode$$1);\n          TextNode.prototype = Object.create(PathNode$$1 && PathNode$$1.prototype);\n          TextNode.prototype.constructor = TextNode;\n          TextNode.fn = TextNode.prototype;\n          TextNode.fn.init = TextNode.fn.constructor;\n\n          TextNode.prototype.geometryChange = function geometryChange() {\n            var pos = this.pos();\n            this.attr(\"x\", pos.x);\n            this.attr(\"y\", pos.y);\n            this.invalidate();\n          };\n\n          TextNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"font\") {\n              this.attr(\"style\", renderStyle(this.mapStyle()));\n              this.geometryChange();\n            } else if (e.field === \"content\") {\n              PathNode$$1.prototype.content.call(this, this.srcElement.content());\n            }\n\n            PathNode$$1.prototype.optionsChange.call(this, e);\n          };\n\n          TextNode.prototype.mapStyle = function mapStyle(encode) {\n            var style = PathNode$$1.prototype.mapStyle.call(this, encode);\n            var font = this.srcElement.options.font;\n\n            if (encode) {\n              font = kendo.htmlEncode(font);\n            }\n\n            style.push([\"font\", font], [\"white-space\", \"pre\"]);\n            return style;\n          };\n\n          TextNode.prototype.pos = function pos() {\n            var pos = this.srcElement.position();\n            var size = this.srcElement.measure();\n            return pos.clone().setY(pos.y + size.baseline);\n          };\n\n          TextNode.prototype.renderContent = function renderContent() {\n            var content = this.srcElement.content();\n            content = decodeEntities(content);\n            content = kendo.htmlEncode(content);\n            return kendoUtil.normalizeText(content);\n          };\n\n          TextNode.prototype.renderTextAnchor = function renderTextAnchor() {\n            var anchor;\n\n            if ((this.options || {}).rtl && !(supportBrowser.msie || supportBrowser.edge)) {\n              anchor = 'end';\n            }\n\n            return renderAttr(\"text-anchor\", anchor);\n          };\n\n          TextNode.prototype.template = function template() {\n            return \"<text \" + this.renderId() + \" \" + this.renderTextAnchor() + \" \" + this.renderStyle() + \" \" + this.renderOpacity() + \"x='\" + this.pos().x + \"' y='\" + this.pos().y + \"' \" + this.renderStroke() + \" \" + this.renderTransform() + \" \" + this.renderDefinitions() + this.renderFill() + \">\" + this.renderContent() + \"</text>\";\n          };\n\n          return TextNode;\n        }(PathNode);\n\n        NODE_MAP.Arc = ArcNode;\n        NODE_MAP.Circle = CircleNode;\n        NODE_MAP.Group = GroupNode;\n        NODE_MAP.Image = ImageNode;\n        NODE_MAP.MultiPath = MultiPathNode;\n        NODE_MAP.Path = PathNode;\n        NODE_MAP.Rect = RectNode;\n        NODE_MAP.Text = TextNode;\n        var RTL = 'rtl';\n\n        function alignToScreen(element) {\n          var ctm;\n\n          try {\n            ctm = element.getScreenCTM ? element.getScreenCTM() : null;\n          } catch (e) {} // eslint-disable-line no-empty\n\n\n          if (ctm) {\n            var left = -ctm.e % 1;\n            var top = -ctm.f % 1;\n            var style = element.style;\n\n            if (left !== 0 || top !== 0) {\n              style.left = left + \"px\";\n              style.top = top + \"px\";\n            }\n          }\n        }\n\n        var Surface$3 = function (BaseSurface) {\n          function Surface(element, options) {\n            BaseSurface.call(this, element, options);\n            this._root = new RootNode($.extend({\n              rtl: elementStyles(element, 'direction').direction === RTL\n            }, this.options));\n            renderSVG$1(this.element, this._template());\n            this._rootElement = this.element.firstElementChild;\n            alignToScreen(this._rootElement);\n\n            this._root.attachTo(this._rootElement);\n\n            bindEvents(this.element, {\n              click: this._click,\n              mouseover: this._mouseenter,\n              mouseout: this._mouseleave,\n              mousemove: this._mousemove\n            });\n            this.resize();\n          }\n\n          extendStatic(Surface, BaseSurface);\n          Surface.prototype = Object.create(BaseSurface && BaseSurface.prototype);\n          Surface.prototype.constructor = Surface;\n          Surface.fn = Surface.prototype;\n          Surface.fn.init = Surface.fn.constructor;\n          var prototypeAccessors = {\n            type: {}\n          };\n\n          prototypeAccessors.type.get = function () {\n            return \"svg\";\n          };\n\n          Surface.prototype.destroy = function destroy() {\n            if (this._root) {\n              this._root.destroy();\n\n              this._root = null;\n              this._rootElement = null;\n              unbindEvents(this.element, {\n                click: this._click,\n                mouseover: this._mouseenter,\n                mouseout: this._mouseleave,\n                mousemove: this._mousemove\n              });\n            }\n\n            BaseSurface.prototype.destroy.call(this);\n          };\n\n          Surface.prototype.translate = function translate(offset) {\n            var viewBox = Math.round(offset.x) + \" \" + Math.round(offset.y) + \" \" + this._size.width + \" \" + this._size.height;\n\n            this._offset = offset;\n\n            this._rootElement.setAttribute(\"viewBox\", viewBox);\n          };\n\n          Surface.prototype.draw = function draw(element) {\n            BaseSurface.prototype.draw.call(this, element);\n\n            this._root.load([element]);\n          };\n\n          Surface.prototype.clear = function clear() {\n            BaseSurface.prototype.clear.call(this);\n\n            this._root.clear();\n          };\n\n          Surface.prototype.svg = function svg() {\n            return \"<?xml version='1.0' ?>\" + this._template();\n          };\n\n          Surface.prototype.exportVisual = function exportVisual() {\n            var ref = this;\n            var visual = ref._visual;\n            var offset = ref._offset;\n\n            if (offset) {\n              var wrap = new Group();\n              wrap.children.push(visual);\n              wrap.transform(transform$1().translate(-offset.x, -offset.y));\n              visual = wrap;\n            }\n\n            return visual;\n          };\n\n          Surface.prototype._resize = function _resize() {\n            if (this._offset) {\n              this.translate(this._offset);\n            }\n          };\n\n          Surface.prototype._template = function _template() {\n            return \"<svg style='width: 100%; height: 100%; overflow: hidden;' xmlns='\" + SVG_NS + \"' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>\" + this._root.render() + \"</svg>\";\n          };\n\n          Object.defineProperties(Surface.prototype, prototypeAccessors);\n          return Surface;\n        }(Surface$2);\n\n        var NODE_MAP$2 = {};\n\n        function renderPath(ctx, path) {\n          var segments = path.segments;\n\n          if (segments.length === 0) {\n            return;\n          }\n\n          var segment = segments[0];\n          var anchor = segment.anchor();\n          ctx.moveTo(anchor.x, anchor.y);\n\n          for (var i = 1; i < segments.length; i++) {\n            segment = segments[i];\n            anchor = segment.anchor();\n            var prevSeg = segments[i - 1];\n            var prevOut = prevSeg.controlOut();\n            var controlIn = segment.controlIn();\n\n            if (prevOut && controlIn) {\n              ctx.bezierCurveTo(prevOut.x, prevOut.y, controlIn.x, controlIn.y, anchor.x, anchor.y);\n            } else {\n              ctx.lineTo(anchor.x, anchor.y);\n            }\n          }\n\n          if (path.options.closed) {\n            ctx.closePath();\n          }\n        }\n\n        var Node$2 = function (BaseNode$$1) {\n          function Node(srcElement) {\n            BaseNode$$1.call(this, srcElement);\n\n            if (srcElement) {\n              this.initClip();\n            }\n          }\n\n          extendStatic(Node, BaseNode$$1);\n          Node.prototype = Object.create(BaseNode$$1 && BaseNode$$1.prototype);\n          Node.prototype.constructor = Node;\n          Node.fn = Node.prototype;\n          Node.fn.init = Node.fn.constructor;\n\n          Node.prototype.initClip = function initClip() {\n            var clip = this.srcElement.clip();\n\n            if (clip) {\n              this.clip = clip;\n              clip.addObserver(this);\n            }\n          };\n\n          Node.prototype.clear = function clear() {\n            if (this.srcElement) {\n              this.srcElement.removeObserver(this);\n            }\n\n            this.clearClip();\n            BaseNode$$1.prototype.clear.call(this);\n          };\n\n          Node.prototype.clearClip = function clearClip() {\n            if (this.clip) {\n              this.clip.removeObserver(this);\n              delete this.clip;\n            }\n          };\n\n          Node.prototype.setClip = function setClip(ctx) {\n            if (this.clip) {\n              ctx.beginPath();\n              renderPath(ctx, this.clip);\n              ctx.clip();\n            }\n          };\n\n          Node.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"clip\") {\n              this.clearClip();\n              this.initClip();\n            }\n\n            BaseNode$$1.prototype.optionsChange.call(this, e);\n          };\n\n          Node.prototype.setTransform = function setTransform(ctx) {\n            if (this.srcElement) {\n              var transform = this.srcElement.transform();\n\n              if (transform) {\n                ctx.transform.apply(ctx, transform.matrix().toArray(6));\n              }\n            }\n          };\n\n          Node.prototype.loadElements = function loadElements(elements, pos, cors) {\n            var this$1 = this;\n\n            for (var i = 0; i < elements.length; i++) {\n              var srcElement = elements[i];\n              var children = srcElement.children;\n              var childNode = new NODE_MAP$2[srcElement.nodeType](srcElement, cors);\n\n              if (children && children.length > 0) {\n                childNode.load(children, pos, cors);\n              }\n\n              if (defined(pos)) {\n                this$1.insertAt(childNode, pos);\n              } else {\n                this$1.append(childNode);\n              }\n            }\n          };\n\n          Node.prototype.load = function load(elements, pos, cors) {\n            this.loadElements(elements, pos, cors);\n            this.invalidate();\n          };\n\n          Node.prototype.setOpacity = function setOpacity(ctx) {\n            if (this.srcElement) {\n              var opacity = this.srcElement.opacity();\n\n              if (defined(opacity)) {\n                this.globalAlpha(ctx, opacity);\n              }\n            }\n          };\n\n          Node.prototype.globalAlpha = function globalAlpha(ctx, value) {\n            var opactity = value;\n\n            if (opactity && ctx.globalAlpha) {\n              opactity *= ctx.globalAlpha;\n            }\n\n            ctx.globalAlpha = opactity;\n          };\n\n          Node.prototype.visible = function visible() {\n            var src = this.srcElement;\n            return !src || src && src.options.visible !== false;\n          };\n\n          return Node;\n        }(BaseNode);\n\n        var GroupNode$2 = function (superclass) {\n          function GroupNode() {\n            superclass.apply(this, arguments);\n          }\n\n          extendStatic(GroupNode, superclass);\n          GroupNode.prototype = Object.create(superclass && superclass.prototype);\n          GroupNode.prototype.constructor = GroupNode;\n          GroupNode.fn = GroupNode.prototype;\n          GroupNode.fn.init = GroupNode.fn.constructor;\n\n          GroupNode.prototype.renderTo = function renderTo(ctx) {\n            if (!this.visible()) {\n              return;\n            }\n\n            ctx.save();\n            this.setTransform(ctx);\n            this.setClip(ctx);\n            this.setOpacity(ctx);\n            var childNodes = this.childNodes;\n\n            for (var i = 0; i < childNodes.length; i++) {\n              var child = childNodes[i];\n\n              if (child.visible()) {\n                child.renderTo(ctx);\n              }\n            }\n\n            ctx.restore();\n          };\n\n          return GroupNode;\n        }(traversable(Node$2, \"childNodes\"));\n\n        var FRAME_DELAY = 1000 / 60;\n\n        var RootNode$2 = function (superclass) {\n          function RootNode(canvas, size) {\n            superclass.call(this);\n            this.canvas = canvas;\n            this.size = size;\n            this.ctx = canvas.getContext(\"2d\");\n\n            var invalidateHandler = this._invalidate.bind(this);\n\n            this.invalidate = kendo.throttle(function () {\n              kendo.animationFrame(invalidateHandler);\n            }, FRAME_DELAY);\n          }\n\n          extendStatic(RootNode, superclass);\n          RootNode.prototype = Object.create(superclass && superclass.prototype);\n          RootNode.prototype.constructor = RootNode;\n          RootNode.fn = RootNode.prototype;\n          RootNode.fn.init = RootNode.fn.constructor;\n\n          RootNode.prototype.destroy = function destroy() {\n            superclass.prototype.destroy.call(this);\n            this.canvas = null;\n            this.ctx = null;\n          };\n\n          RootNode.prototype.load = function load(elements, pos, cors) {\n            this.loadElements(elements, pos, cors);\n\n            this._invalidate();\n          };\n\n          RootNode.prototype._rescale = function _rescale(scale) {\n            var ref = this;\n            var canvas = ref.canvas;\n            var size = ref.size;\n            canvas.width = size.width * scale;\n            canvas.height = size.height * scale;\n            this.ctx.scale(scale, scale);\n          };\n\n          RootNode.prototype._devicePixelRatio = function _devicePixelRatio() {\n            if (typeof window.devicePixelRatio === 'number') {\n              return window.devicePixelRatio;\n            }\n\n            return 1;\n          };\n\n          RootNode.prototype._invalidate = function _invalidate(options) {\n            if (!this.ctx) {\n              return;\n            }\n\n            var fixedScale = options && options.fixedScale;\n            var scale = fixedScale ? 1 : this._devicePixelRatio();\n\n            this._rescale(scale);\n\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.renderTo(this.ctx);\n          };\n\n          return RootNode;\n        }(traversable(GroupNode$2, \"childNodes\"));\n\n        var QuadRoot = function (Class$$1) {\n          function QuadRoot() {\n            Class$$1.call(this);\n            this.shapes = [];\n          }\n\n          extendStatic(QuadRoot, Class$$1);\n          QuadRoot.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          QuadRoot.prototype.constructor = QuadRoot;\n          QuadRoot.fn = QuadRoot.prototype;\n          QuadRoot.fn.init = QuadRoot.fn.constructor;\n\n          QuadRoot.prototype._add = function _add(shape, bbox) {\n            this.shapes.push({\n              bbox: bbox,\n              shape: shape\n            });\n            shape._quadNode = this;\n          };\n\n          QuadRoot.prototype.pointShapes = function pointShapes(point) {\n            var shapes = this.shapes;\n            var length = shapes.length;\n            var result = [];\n\n            for (var idx = 0; idx < length; idx++) {\n              if (shapes[idx].bbox.containsPoint(point)) {\n                result.push(shapes[idx].shape);\n              }\n            }\n\n            return result;\n          };\n\n          QuadRoot.prototype.insert = function insert(shape, bbox) {\n            this._add(shape, bbox);\n          };\n\n          QuadRoot.prototype.remove = function remove(shape) {\n            var shapes = this.shapes;\n            var length = shapes.length;\n\n            for (var idx = 0; idx < length; idx++) {\n              if (shapes[idx].shape === shape) {\n                shapes.splice(idx, 1);\n                break;\n              }\n            }\n          };\n\n          return QuadRoot;\n        }(Class);\n\n        var geometry = {\n          Circle: Circle$2,\n          Arc: Arc$2,\n          Rect: Rect,\n          Point: Point,\n          Segment: Segment,\n          Matrix: Matrix,\n          Size: Size,\n          toMatrix: toMatrix,\n          Transformation: Transformation,\n          transform: transform$1\n        };\n\n        var QuadNode = function (QuadRoot$$1) {\n          function QuadNode(rect) {\n            QuadRoot$$1.call(this);\n            this.children = [];\n            this.rect = rect;\n          }\n\n          extendStatic(QuadNode, QuadRoot$$1);\n          QuadNode.prototype = Object.create(QuadRoot$$1 && QuadRoot$$1.prototype);\n          QuadNode.prototype.constructor = QuadNode;\n          QuadNode.fn = QuadNode.prototype;\n          QuadNode.fn.init = QuadNode.fn.constructor;\n\n          QuadNode.prototype.inBounds = function inBounds(rect) {\n            var nodeRect = this.rect;\n            var nodeBottomRight = nodeRect.bottomRight();\n            var bottomRight = rect.bottomRight();\n            var inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;\n            return inBounds;\n          };\n\n          QuadNode.prototype.pointShapes = function pointShapes(point) {\n            var children = this.children;\n            var length = children.length;\n            var result = QuadRoot$$1.prototype.pointShapes.call(this, point);\n\n            for (var idx = 0; idx < length; idx++) {\n              append$1$1(result, children[idx].pointShapes(point));\n            }\n\n            return result;\n          };\n\n          QuadNode.prototype.insert = function insert(shape, bbox) {\n            var children = this.children;\n            var inserted = false;\n\n            if (this.inBounds(bbox)) {\n              if (this.shapes.length < 4) {\n                this._add(shape, bbox);\n              } else {\n                if (!children.length) {\n                  this._initChildren();\n                }\n\n                for (var idx = 0; idx < children.length; idx++) {\n                  if (children[idx].insert(shape, bbox)) {\n                    inserted = true;\n                    break;\n                  }\n                }\n\n                if (!inserted) {\n                  this._add(shape, bbox);\n                }\n              }\n\n              inserted = true;\n            }\n\n            return inserted;\n          };\n\n          QuadNode.prototype._initChildren = function _initChildren() {\n            var ref = this;\n            var rect = ref.rect;\n            var children = ref.children;\n            var center = rect.center();\n            var halfWidth = rect.width() / 2;\n            var halfHeight = rect.height() / 2;\n            children.push(new QuadNode(new Rect([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])), new QuadNode(new Rect([center.x, rect.origin.y], [halfWidth, halfHeight])), new QuadNode(new Rect([rect.origin.x, center.y], [halfWidth, halfHeight])), new QuadNode(new Rect([center.x, center.y], [halfWidth, halfHeight])));\n          };\n\n          return QuadNode;\n        }(QuadRoot);\n\n        var ROOT_SIZE = 3000;\n        var LEVEL_STEP = 10000;\n        var MAX_LEVEL = 75;\n\n        var ShapesQuadTree = function (Class$$1) {\n          function ShapesQuadTree() {\n            Class$$1.call(this);\n            this.initRoots();\n          }\n\n          extendStatic(ShapesQuadTree, Class$$1);\n          ShapesQuadTree.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          ShapesQuadTree.prototype.constructor = ShapesQuadTree;\n          ShapesQuadTree.fn = ShapesQuadTree.prototype;\n          ShapesQuadTree.fn.init = ShapesQuadTree.fn.constructor;\n\n          ShapesQuadTree.prototype.initRoots = function initRoots() {\n            this.rootMap = {};\n            this.root = new QuadRoot();\n            this.rootElements = [];\n          };\n\n          ShapesQuadTree.prototype.clear = function clear() {\n            var this$1 = this;\n            var rootElements = this.rootElements;\n\n            for (var idx = 0; idx < rootElements.length; idx++) {\n              this$1.remove(rootElements[idx]);\n            }\n\n            this.initRoots();\n          };\n\n          ShapesQuadTree.prototype.pointShape = function pointShape(point) {\n            var sectorRoot = (this.rootMap[Math.floor(point.x / ROOT_SIZE)] || {})[Math.floor(point.y / ROOT_SIZE)];\n            var result = this.root.pointShapes(point);\n\n            if (sectorRoot) {\n              result = result.concat(sectorRoot.pointShapes(point));\n            }\n\n            this.assignZindex(result);\n            result.sort(zIndexComparer);\n\n            for (var idx = 0; idx < result.length; idx++) {\n              if (result[idx].containsPoint(point)) {\n                return result[idx];\n              }\n            }\n          };\n\n          ShapesQuadTree.prototype.assignZindex = function assignZindex(elements) {\n            var this$1 = this;\n\n            for (var idx = 0; idx < elements.length; idx++) {\n              var element = elements[idx];\n              var zIndex = 0;\n              var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n              var parents = [];\n\n              while (element) {\n                parents.push(element);\n                element = element.parent;\n              }\n\n              while (parents.length) {\n                element = parents.pop();\n                zIndex += ((element.parent ? element.parent.children : this$1.rootElements).indexOf(element) + 1) * levelWeight;\n                levelWeight /= LEVEL_STEP;\n              }\n\n              elements[idx]._zIndex = zIndex;\n            }\n          };\n\n          ShapesQuadTree.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"transform\" || e.field === \"stroke.width\") {\n              this.bboxChange(e.element);\n            }\n          };\n\n          ShapesQuadTree.prototype.geometryChange = function geometryChange(e) {\n            this.bboxChange(e.element);\n          };\n\n          ShapesQuadTree.prototype.bboxChange = function bboxChange(element) {\n            var this$1 = this;\n\n            if (element.nodeType === \"Group\") {\n              for (var idx = 0; idx < element.children.length; idx++) {\n                this$1.bboxChange(element.children[idx]);\n              }\n            } else {\n              if (element._quadNode) {\n                element._quadNode.remove(element);\n              }\n\n              this._insertShape(element);\n            }\n          };\n\n          ShapesQuadTree.prototype.add = function add(elements) {\n            var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];\n            append$1$1(this.rootElements, elementsArray);\n\n            this._insert(elementsArray);\n          };\n\n          ShapesQuadTree.prototype.childrenChange = function childrenChange(e) {\n            var this$1 = this;\n\n            if (e.action === \"remove\") {\n              for (var idx = 0; idx < e.items.length; idx++) {\n                this$1.remove(e.items[idx]);\n              }\n            } else {\n              this._insert(Array.prototype.slice.call(e.items, 0));\n            }\n          };\n\n          ShapesQuadTree.prototype._insert = function _insert(elements) {\n            var this$1 = this;\n            var element;\n\n            while (elements.length > 0) {\n              element = elements.pop();\n              element.addObserver(this$1);\n\n              if (element.nodeType === \"Group\") {\n                append$1$1(elements, element.children);\n              } else {\n                this$1._insertShape(element);\n              }\n            }\n          };\n\n          ShapesQuadTree.prototype._insertShape = function _insertShape(shape) {\n            var bbox = shape.bbox();\n\n            if (bbox) {\n              var sectors = this.getSectors(bbox);\n              var x = sectors[0][0];\n              var y = sectors[1][0];\n\n              if (this.inRoot(sectors)) {\n                this.root.insert(shape, bbox);\n              } else {\n                var rootMap = this.rootMap;\n\n                if (!rootMap[x]) {\n                  rootMap[x] = {};\n                }\n\n                if (!rootMap[x][y]) {\n                  rootMap[x][y] = new QuadNode(new Rect([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));\n                }\n\n                rootMap[x][y].insert(shape, bbox);\n              }\n            }\n          };\n\n          ShapesQuadTree.prototype.remove = function remove(element) {\n            var this$1 = this;\n            element.removeObserver(this);\n\n            if (element.nodeType === \"Group\") {\n              var children = element.children;\n\n              for (var idx = 0; idx < children.length; idx++) {\n                this$1.remove(children[idx]);\n              }\n            } else if (element._quadNode) {\n              element._quadNode.remove(element);\n\n              delete element._quadNode;\n            }\n          };\n\n          ShapesQuadTree.prototype.inRoot = function inRoot(sectors) {\n            return sectors[0].length > 1 || sectors[1].length > 1;\n          };\n\n          ShapesQuadTree.prototype.getSectors = function getSectors(rect) {\n            var bottomRight = rect.bottomRight();\n            var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n            var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n            var sectors = [[], []];\n\n            for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n              sectors[0].push(x);\n            }\n\n            for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n              sectors[1].push(y);\n            }\n\n            return sectors;\n          };\n\n          return ShapesQuadTree;\n        }(Class);\n\n        function zIndexComparer(x1, x2) {\n          if (x1._zIndex < x2._zIndex) {\n            return 1;\n          }\n\n          if (x1._zIndex > x2._zIndex) {\n            return -1;\n          }\n\n          return 0;\n        }\n\n        var SurfaceCursor = function SurfaceCursor(surface) {\n          surface.bind(\"mouseenter\", this._mouseenter.bind(this));\n          surface.bind(\"mouseleave\", this._mouseleave.bind(this));\n          this.element = surface.element;\n        };\n\n        SurfaceCursor.prototype.clear = function clear() {\n          this._resetCursor();\n        };\n\n        SurfaceCursor.prototype.destroy = function destroy() {\n          this._resetCursor();\n\n          delete this.element;\n        };\n\n        SurfaceCursor.prototype._mouseenter = function _mouseenter(e) {\n          var cursor = this._shapeCursor(e);\n\n          if (!cursor) {\n            this._resetCursor();\n          } else {\n            if (!this._current) {\n              this._defaultCursor = this._getCursor();\n            }\n\n            this._setCursor(cursor);\n          }\n        };\n\n        SurfaceCursor.prototype._mouseleave = function _mouseleave() {\n          this._resetCursor();\n        };\n\n        SurfaceCursor.prototype._shapeCursor = function _shapeCursor(e) {\n          var shape = e.element;\n\n          while (shape && !defined(shape.options.cursor)) {\n            shape = shape.parent;\n          }\n\n          if (shape) {\n            return shape.options.cursor;\n          }\n        };\n\n        SurfaceCursor.prototype._getCursor = function _getCursor() {\n          if (this.element) {\n            return this.element.style.cursor;\n          }\n        };\n\n        SurfaceCursor.prototype._setCursor = function _setCursor(cursor) {\n          if (this.element) {\n            this.element.style.cursor = cursor;\n            this._current = cursor;\n          }\n        };\n\n        SurfaceCursor.prototype._resetCursor = function _resetCursor() {\n          if (this._current) {\n            this._setCursor(this._defaultCursor || \"\");\n\n            delete this._current;\n          }\n        };\n\n        function addGradientStops(gradient, stops) {\n          for (var idx = 0; idx < stops.length; idx++) {\n            var stop = stops[idx];\n            var color = kendo.parseColor(stop.color());\n            color.a *= stop.opacity();\n            gradient.addColorStop(stop.offset(), color.toCssRgba());\n          }\n        }\n\n        var PathNode$2 = function (Node) {\n          function PathNode() {\n            Node.apply(this, arguments);\n          }\n\n          extendStatic(PathNode, Node);\n          PathNode.prototype = Object.create(Node && Node.prototype);\n          PathNode.prototype.constructor = PathNode;\n          PathNode.fn = PathNode.prototype;\n          PathNode.fn.init = PathNode.fn.constructor;\n\n          PathNode.prototype.renderTo = function renderTo(ctx) {\n            ctx.save();\n            this.setTransform(ctx);\n            this.setClip(ctx);\n            this.setOpacity(ctx);\n            ctx.beginPath();\n            this.renderPoints(ctx, this.srcElement);\n            this.setLineDash(ctx);\n            this.setLineCap(ctx);\n            this.setLineJoin(ctx);\n            this.setFill(ctx);\n            this.setStroke(ctx);\n            ctx.restore();\n          };\n\n          PathNode.prototype.setFill = function setFill(ctx) {\n            var fill = this.srcElement.options.fill;\n            var hasFill = false;\n\n            if (fill) {\n              if (fill.nodeType === \"Gradient\") {\n                this.setGradientFill(ctx, fill);\n                hasFill = true;\n              } else if (!isTransparent(fill.color)) {\n                ctx.fillStyle = fill.color;\n                ctx.save();\n                this.globalAlpha(ctx, fill.opacity);\n                ctx.fill();\n                ctx.restore();\n                hasFill = true;\n              }\n            }\n\n            return hasFill;\n          };\n\n          PathNode.prototype.setGradientFill = function setGradientFill(ctx, fill) {\n            var bbox = this.srcElement.rawBBox();\n            var gradient;\n\n            if (fill instanceof LinearGradient) {\n              var start = fill.start();\n              var end = fill.end();\n              gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            } else if (fill instanceof RadialGradient) {\n              var center = fill.center();\n              gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n            }\n\n            addGradientStops(gradient, fill.stops);\n            ctx.save();\n\n            if (!fill.userSpace()) {\n              ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n            }\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.restore();\n          };\n\n          PathNode.prototype.setStroke = function setStroke(ctx) {\n            var stroke = this.srcElement.options.stroke;\n\n            if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\n              ctx.strokeStyle = stroke.color;\n              ctx.lineWidth = valueOrDefault(stroke.width, 1);\n              ctx.save();\n              this.globalAlpha(ctx, stroke.opacity);\n              ctx.stroke();\n              ctx.restore();\n              return true;\n            }\n          };\n\n          PathNode.prototype.dashType = function dashType() {\n            var stroke = this.srcElement.options.stroke;\n\n            if (stroke && stroke.dashType) {\n              return stroke.dashType.toLowerCase();\n            }\n          };\n\n          PathNode.prototype.setLineDash = function setLineDash(ctx) {\n            var dashType = this.dashType();\n\n            if (dashType && dashType !== SOLID) {\n              var dashArray = DASH_ARRAYS[dashType];\n\n              if (ctx.setLineDash) {\n                ctx.setLineDash(dashArray);\n              } else {\n                ctx.mozDash = dashArray;\n                ctx.webkitLineDash = dashArray;\n              }\n            }\n          };\n\n          PathNode.prototype.setLineCap = function setLineCap(ctx) {\n            var dashType = this.dashType();\n            var stroke = this.srcElement.options.stroke;\n\n            if (dashType && dashType !== SOLID) {\n              ctx.lineCap = BUTT;\n            } else if (stroke && stroke.lineCap) {\n              ctx.lineCap = stroke.lineCap;\n            }\n          };\n\n          PathNode.prototype.setLineJoin = function setLineJoin(ctx) {\n            var stroke = this.srcElement.options.stroke;\n\n            if (stroke && stroke.lineJoin) {\n              ctx.lineJoin = stroke.lineJoin;\n            }\n          };\n\n          PathNode.prototype.renderPoints = function renderPoints(ctx, path) {\n            renderPath(ctx, path);\n          };\n\n          return PathNode;\n        }(Node$2);\n\n        var ArcNode$2 = function (PathNode) {\n          function ArcNode() {\n            PathNode.apply(this, arguments);\n          }\n\n          extendStatic(ArcNode, PathNode);\n          ArcNode.prototype = Object.create(PathNode && PathNode.prototype);\n          ArcNode.prototype.constructor = ArcNode;\n          ArcNode.fn = ArcNode.prototype;\n          ArcNode.fn.init = ArcNode.fn.constructor;\n\n          ArcNode.prototype.renderPoints = function renderPoints(ctx) {\n            var path = this.srcElement.toPath();\n            renderPath(ctx, path);\n          };\n\n          return ArcNode;\n        }(PathNode$2);\n\n        var CircleNode$2 = function (PathNode) {\n          function CircleNode() {\n            PathNode.apply(this, arguments);\n          }\n\n          extendStatic(CircleNode, PathNode);\n          CircleNode.prototype = Object.create(PathNode && PathNode.prototype);\n          CircleNode.prototype.constructor = CircleNode;\n          CircleNode.fn = CircleNode.prototype;\n          CircleNode.fn.init = CircleNode.fn.constructor;\n\n          CircleNode.prototype.renderPoints = function renderPoints(ctx) {\n            var ref = this.srcElement.geometry();\n            var center = ref.center;\n            var radius = ref.radius;\n            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\n          };\n\n          return CircleNode;\n        }(PathNode$2);\n\n        var ImageNode$2 = function (PathNode) {\n          function ImageNode(srcElement, cors) {\n            PathNode.call(this, srcElement);\n            this.onLoad = this.onLoad.bind(this);\n            this.onError = this.onError.bind(this);\n            this.loading = createPromise();\n            var img = this.img = new Image();\n\n            if (cors && !/^data:/i.test(srcElement.src())) {\n              img.crossOrigin = cors;\n            }\n\n            img.src = srcElement.src();\n\n            if (img.complete) {\n              this.onLoad();\n            } else {\n              img.onload = this.onLoad;\n              img.onerror = this.onError;\n            }\n          }\n\n          extendStatic(ImageNode, PathNode);\n          ImageNode.prototype = Object.create(PathNode && PathNode.prototype);\n          ImageNode.prototype.constructor = ImageNode;\n          ImageNode.fn = ImageNode.prototype;\n          ImageNode.fn.init = ImageNode.fn.constructor;\n\n          ImageNode.prototype.renderTo = function renderTo(ctx) {\n            if (this.loading.state() === \"resolved\") {\n              ctx.save();\n              this.setTransform(ctx);\n              this.setClip(ctx);\n              this.drawImage(ctx);\n              ctx.restore();\n            }\n          };\n\n          ImageNode.prototype.optionsChange = function optionsChange(e) {\n            if (e.field === \"src\") {\n              this.loading = createPromise();\n              this.img.src = this.srcElement.src();\n            } else {\n              PathNode.prototype.optionsChange.call(this, e);\n            }\n          };\n\n          ImageNode.prototype.onLoad = function onLoad() {\n            this.loading.resolve();\n            this.invalidate();\n          };\n\n          ImageNode.prototype.onError = function onError() {\n            this.loading.reject(new Error(\"Unable to load image '\" + this.img.src + \"'. Check for connectivity and verify CORS headers.\"));\n          };\n\n          ImageNode.prototype.drawImage = function drawImage(ctx) {\n            var rect = this.srcElement.rect();\n            var topLeft = rect.topLeft();\n            ctx.drawImage(this.img, topLeft.x, topLeft.y, rect.width(), rect.height());\n          };\n\n          return ImageNode;\n        }(PathNode$2);\n\n        var MultiPathNode$2 = function (PathNode) {\n          function MultiPathNode() {\n            PathNode.apply(this, arguments);\n          }\n\n          extendStatic(MultiPathNode, PathNode);\n          MultiPathNode.prototype = Object.create(PathNode && PathNode.prototype);\n          MultiPathNode.prototype.constructor = MultiPathNode;\n          MultiPathNode.fn = MultiPathNode.prototype;\n          MultiPathNode.fn.init = MultiPathNode.fn.constructor;\n\n          MultiPathNode.prototype.renderPoints = function renderPoints(ctx) {\n            var paths = this.srcElement.paths;\n\n            for (var i = 0; i < paths.length; i++) {\n              renderPath(ctx, paths[i]);\n            }\n          };\n\n          return MultiPathNode;\n        }(PathNode$2);\n\n        var RectNode$2 = function (PathNode) {\n          function RectNode() {\n            PathNode.apply(this, arguments);\n          }\n\n          extendStatic(RectNode, PathNode);\n          RectNode.prototype = Object.create(PathNode && PathNode.prototype);\n          RectNode.prototype.constructor = RectNode;\n          RectNode.fn = RectNode.prototype;\n          RectNode.fn.init = RectNode.fn.constructor;\n\n          RectNode.prototype.renderPoints = function renderPoints(ctx) {\n            var geometry = this.srcElement.geometry();\n            var ref = geometry.cornerRadius;\n            var rx = ref[0];\n            var ry = ref[1];\n\n            if (rx === 0 && ry === 0) {\n              var origin = geometry.origin;\n              var size = geometry.size;\n              ctx.rect(origin.x, origin.y, size.width, size.height);\n            } else {\n              PathNode.prototype.renderPoints.call(this, ctx, Path.fromRect(geometry));\n            }\n          };\n\n          return RectNode;\n        }(PathNode$2);\n\n        var TextNode$2 = function (PathNode) {\n          function TextNode() {\n            PathNode.apply(this, arguments);\n          }\n\n          extendStatic(TextNode, PathNode);\n          TextNode.prototype = Object.create(PathNode && PathNode.prototype);\n          TextNode.prototype.constructor = TextNode;\n          TextNode.fn = TextNode.prototype;\n          TextNode.fn.init = TextNode.fn.constructor;\n\n          TextNode.prototype.renderTo = function renderTo(ctx) {\n            var text = this.srcElement;\n            var pos = text.position();\n            var size = text.measure();\n            ctx.save();\n            this.setTransform(ctx);\n            this.setClip(ctx);\n            this.setOpacity(ctx);\n            ctx.beginPath();\n            ctx.font = text.options.font;\n            ctx.textAlign = 'left';\n\n            if (this.setFill(ctx)) {\n              ctx.fillText(text.content(), pos.x, pos.y + size.baseline);\n            }\n\n            if (this.setStroke(ctx)) {\n              this.setLineDash(ctx);\n              ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);\n            }\n\n            ctx.restore();\n          };\n\n          return TextNode;\n        }(PathNode$2);\n\n        NODE_MAP$2.Arc = ArcNode$2;\n        NODE_MAP$2.Circle = CircleNode$2;\n        NODE_MAP$2.Group = GroupNode$2;\n        NODE_MAP$2.Image = ImageNode$2;\n        NODE_MAP$2.MultiPath = MultiPathNode$2;\n        NODE_MAP$2.Path = PathNode$2;\n        NODE_MAP$2.Rect = RectNode$2;\n        NODE_MAP$2.Text = TextNode$2;\n\n        var Surface$4 = function (BaseSurface) {\n          function Surface(element, options) {\n            BaseSurface.call(this, element, options);\n            this.element.innerHTML = this._template(this);\n            var canvas = this.element.firstElementChild;\n            var size = elementSize(element);\n            canvas.width = size.width;\n            canvas.height = size.height;\n            this._rootElement = canvas;\n            this._root = new RootNode$2(canvas, size);\n            this._mouseTrackHandler = this._trackMouse.bind(this);\n            bindEvents(this.element, {\n              click: this._mouseTrackHandler,\n              mousemove: this._mouseTrackHandler\n            });\n          }\n\n          extendStatic(Surface, BaseSurface);\n          Surface.prototype = Object.create(BaseSurface && BaseSurface.prototype);\n          Surface.prototype.constructor = Surface;\n          Surface.fn = Surface.prototype;\n          Surface.fn.init = Surface.fn.constructor;\n          var prototypeAccessors = {\n            type: {}\n          };\n\n          prototypeAccessors.type.get = function () {\n            return \"canvas\";\n          };\n\n          Surface.prototype.destroy = function destroy() {\n            BaseSurface.prototype.destroy.call(this);\n\n            if (this._root) {\n              this._root.destroy();\n\n              this._root = null;\n            }\n\n            if (this._searchTree) {\n              this._searchTree.clear();\n\n              delete this._searchTree;\n            }\n\n            if (this._cursor) {\n              this._cursor.destroy();\n\n              delete this._cursor;\n            }\n\n            unbindEvents(this.element, {\n              click: this._mouseTrackHandler,\n              mousemove: this._mouseTrackHandler\n            });\n          };\n\n          Surface.prototype.draw = function draw(element) {\n            BaseSurface.prototype.draw.call(this, element);\n\n            this._root.load([element], undefined, this.options.cors);\n\n            if (this._searchTree) {\n              this._searchTree.add([element]);\n            }\n          };\n\n          Surface.prototype.clear = function clear() {\n            BaseSurface.prototype.clear.call(this);\n\n            this._root.clear();\n\n            if (this._searchTree) {\n              this._searchTree.clear();\n            }\n\n            if (this._cursor) {\n              this._cursor.clear();\n            }\n          };\n\n          Surface.prototype.eventTarget = function eventTarget(e) {\n            if (this._searchTree) {\n              var point = this._surfacePoint(e);\n\n              var shape = this._searchTree.pointShape(point);\n\n              return shape;\n            }\n          };\n\n          Surface.prototype.image = function image() {\n            var ref = this;\n            var root = ref._root;\n            var rootElement = ref._rootElement;\n            var loadingStates = [];\n            root.traverse(function (childNode) {\n              if (childNode.loading) {\n                loadingStates.push(childNode.loading);\n              }\n            });\n            var promise = createPromise();\n\n            var resolveDataURL = function () {\n              root._invalidate({\n                fixedScale: true\n              });\n\n              try {\n                var data = rootElement.toDataURL();\n                promise.resolve(data);\n              } catch (e) {\n                promise.reject(e);\n              }\n            };\n\n            promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);\n            return promise;\n          };\n\n          Surface.prototype.suspendTracking = function suspendTracking() {\n            BaseSurface.prototype.suspendTracking.call(this);\n\n            if (this._searchTree) {\n              this._searchTree.clear();\n\n              delete this._searchTree;\n            }\n          };\n\n          Surface.prototype.resumeTracking = function resumeTracking() {\n            BaseSurface.prototype.resumeTracking.call(this);\n\n            if (!this._searchTree) {\n              this._searchTree = new ShapesQuadTree();\n              var childNodes = this._root.childNodes;\n              var rootElements = [];\n\n              for (var idx = 0; idx < childNodes.length; idx++) {\n                rootElements.push(childNodes[idx].srcElement);\n              }\n\n              this._searchTree.add(rootElements);\n            }\n          };\n\n          Surface.prototype._resize = function _resize() {\n            this._rootElement.width = this._size.width;\n            this._rootElement.height = this._size.height;\n            this._root.size = this._size;\n\n            this._root.invalidate();\n          };\n\n          Surface.prototype._template = function _template() {\n            return \"<canvas style='width: 100%; height: 100%;'></canvas>\";\n          };\n\n          Surface.prototype._enableTracking = function _enableTracking() {\n            this._searchTree = new ShapesQuadTree();\n            this._cursor = new SurfaceCursor(this);\n\n            BaseSurface.prototype._enableTracking.call(this);\n          };\n\n          Surface.prototype._trackMouse = function _trackMouse(e) {\n            if (this._suspendedTracking) {\n              return;\n            }\n\n            var shape = this.eventTarget(e);\n\n            if (e.type !== \"click\") {\n              var currentShape = this._currentShape;\n\n              if (currentShape && currentShape !== shape) {\n                this.trigger(\"mouseleave\", {\n                  element: currentShape,\n                  originalEvent: e,\n                  type: \"mouseleave\"\n                });\n              }\n\n              if (shape && currentShape !== shape) {\n                this.trigger(\"mouseenter\", {\n                  element: shape,\n                  originalEvent: e,\n                  type: \"mouseenter\"\n                });\n              }\n\n              this.trigger(\"mousemove\", {\n                element: shape,\n                originalEvent: e,\n                type: \"mousemove\"\n              });\n              this._currentShape = shape;\n            } else if (shape) {\n              this.trigger(\"click\", {\n                element: shape,\n                originalEvent: e,\n                type: \"click\"\n              });\n            }\n          };\n\n          Object.defineProperties(Surface.prototype, prototypeAccessors);\n          return Surface;\n        }(Surface$2);\n\n        var instance$2;\n        var support$1;\n\n        var hasDocument = function () {\n          return typeof document !== \"undefined\";\n        };\n\n        var supportsCanvas = function () {\n          return hasDocument() && document.createElement(\"canvas\").getContext;\n        };\n\n        var supportsSVG = function () {\n          return hasDocument() && document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\");\n        };\n\n        var SurfaceFactory = function (Class$$1) {\n          function SurfaceFactory() {\n            Class$$1.call(this);\n            this._items = [{\n              name: \"svg\",\n              type: Surface$3\n            }, {\n              name: \"canvas\",\n              type: Surface$4\n            }];\n          }\n\n          extendStatic(SurfaceFactory, Class$$1);\n          SurfaceFactory.prototype = Object.create(Class$$1 && Class$$1.prototype);\n          SurfaceFactory.prototype.constructor = SurfaceFactory;\n          SurfaceFactory.fn = SurfaceFactory.prototype;\n          SurfaceFactory.fn.init = SurfaceFactory.fn.constructor;\n          var staticAccessors = {\n            support: {},\n            current: {}\n          };\n\n          staticAccessors.support.get = function () {\n            if (!support$1) {\n              support$1 = {\n                canvas: supportsCanvas(),\n                svg: supportsSVG()\n              };\n            }\n\n            return support$1;\n          };\n\n          staticAccessors.current.get = function () {\n            if (!instance$2) {\n              instance$2 = new SurfaceFactory();\n            }\n\n            return instance$2;\n          };\n\n          SurfaceFactory.prototype.create = function create(element, options) {\n            var items = this._items;\n            var match = items[0];\n\n            if (options && options.type) {\n              var preferred = options.type.toLowerCase();\n\n              for (var i = 0; i < items.length; i++) {\n                if (items[i].name === preferred) {\n                  match = items[i];\n                  break;\n                }\n              }\n            }\n\n            if (match) {\n              return new match.type(element, options);\n            }\n\n            kendo.logToConsole(\"Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\\n\" + \"- The browser does not support SVG and Canvas. User agent: \" + navigator.userAgent);\n          };\n\n          Object.defineProperties(SurfaceFactory, staticAccessors);\n          return SurfaceFactory;\n        }(Class);\n\n        var Surface = function (BaseSurface) {\n          function Surface() {\n            BaseSurface.apply(this, arguments);\n          }\n\n          extendStatic(Surface, BaseSurface);\n          Surface.prototype = Object.create(BaseSurface && BaseSurface.prototype);\n          Surface.prototype.constructor = Surface;\n          Surface.fn = Surface.prototype;\n          Surface.fn.init = Surface.fn.constructor;\n          var staticAccessors = {\n            support: {}\n          };\n\n          staticAccessors.support.get = function () {\n            return SurfaceFactory.support;\n          };\n\n          Surface.create = function create(element, options) {\n            return SurfaceFactory.current.create(element, options);\n          };\n\n          Object.defineProperties(Surface, staticAccessors);\n          return Surface;\n        }(Surface$2);\n\n        function exportGroup(group) {\n          var root = new RootNode({\n            skipBaseHref: true\n          });\n          var bbox = group.clippedBBox();\n          var rootGroup = group;\n\n          if (bbox) {\n            var origin = bbox.getOrigin();\n            var exportRoot = new Group();\n            exportRoot.transform(transform$1().translate(-origin.x, -origin.y));\n            exportRoot.children.push(group);\n            rootGroup = exportRoot;\n          }\n\n          root.load([rootGroup]);\n          var svg = \"<?xml version='1.0' ?><svg xmlns='\" + SVG_NS + \"' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>\" + root.render() + \"</svg>\";\n          root.destroy();\n          return svg;\n        }\n\n        var svg$1 = {\n          Surface: Surface$3,\n          RootNode: RootNode,\n          Node: Node,\n          GroupNode: GroupNode,\n          ArcNode: ArcNode,\n          CircleNode: CircleNode,\n          RectNode: RectNode,\n          ImageNode: ImageNode,\n          TextNode: TextNode,\n          PathNode: PathNode,\n          MultiPathNode: MultiPathNode,\n          DefinitionNode: DefinitionNode,\n          ClipNode: ClipNode,\n          GradientStopNode: GradientStopNode,\n          LinearGradientNode: LinearGradientNode,\n          RadialGradientNode: RadialGradientNode,\n          exportGroup: exportGroup\n        };\n        var canvas = {\n          Surface: Surface$4,\n          RootNode: RootNode$2,\n          Node: Node$2,\n          GroupNode: GroupNode$2,\n          ArcNode: ArcNode$2,\n          CircleNode: CircleNode$2,\n          RectNode: RectNode$2,\n          ImageNode: ImageNode$2,\n          TextNode: TextNode$2,\n          PathNode: PathNode$2,\n          MultiPathNode: MultiPathNode$2\n        };\n\n        function exportImage(group, options) {\n          var defaults = {\n            width: \"800px\",\n            height: \"600px\",\n            cors: \"Anonymous\"\n          };\n          var exportRoot = group;\n          var bbox = group.clippedBBox();\n\n          if (bbox) {\n            var origin = bbox.getOrigin();\n            exportRoot = new Group();\n            exportRoot.transform(transform$1().translate(-origin.x, -origin.y));\n            exportRoot.children.push(group);\n            var size = bbox.getSize();\n            defaults.width = size.width + \"px\";\n            defaults.height = size.height + \"px\";\n          }\n\n          var surfaceOptions = $.extend(defaults, options);\n          var container = document.createElement(\"div\");\n          var style = container.style;\n          style.display = \"none\";\n          style.width = surfaceOptions.width;\n          style.height = surfaceOptions.height;\n          document.body.appendChild(container);\n          var surface = new Surface$4(container, surfaceOptions);\n          surface.suspendTracking();\n          surface.draw(exportRoot);\n          var promise = surface.image();\n\n          var destroy = function () {\n            surface.destroy();\n            document.body.removeChild(container);\n          };\n\n          promise.then(destroy, destroy);\n          return promise;\n        }\n\n        function exportSVG(group, options) {\n          var svg = exportGroup(group);\n\n          if (!options || !options.raw) {\n            svg = \"data:image/svg+xml;base64,\" + encodeBase64(svg);\n          }\n\n          return createPromise().resolve(svg);\n        }\n        /* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\n        /* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\n        /* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n\n        /* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\n\n        var browser = supportBrowser || {};\n        /*\n        \t  XXX: to test:\n        \t  - cloneNodes function:\n            - drawing document containing canvas with page breaking\n            - drawing document with named radio <input>-s (should not clear selection)\n            - IE9/IE10 don't support el.dataset; do they copy user data?\n        \t  - repeating table headers/footers on page breaking\n        \t  - forceBreak, keepTogether\n        \t  - avoidLinks\n        \t */\n\n        /* -----[ local vars ]----- */\n\n        function slice$1$1(thing) {\n          return Array.prototype.slice.call(thing);\n        }\n\n        var KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\n        var IMAGE_CACHE = {};\n        var nodeInfo = {};\n        nodeInfo._root = nodeInfo;\n        /* -----[ Custom Text node to speed up rendering in kendo.pdf ]----- */\n\n        var inBrowser = typeof window !== 'undefined';\n        var microsoft = inBrowser ? browser.msie || browser.edge : false;\n\n        var TextRect = function (Text$$1) {\n          function TextRect(str, rect, options) {\n            Text$$1.call(this, str, rect.getOrigin(), options);\n            this._pdfRect = rect;\n          }\n\n          extendStatic(TextRect, Text$$1);\n          TextRect.prototype = Object.create(Text$$1 && Text$$1.prototype);\n          TextRect.prototype.constructor = TextRect;\n          TextRect.fn = TextRect.prototype;\n          TextRect.fn.init = TextRect.fn.constructor;\n\n          TextRect.prototype.rect = function rect() {\n            // this is the crux of it: we can avoid a call to\n            // measure(), which is what the base class does, since we\n            // already know the rect.  measure() is s-l-o-w.\n            return this._pdfRect;\n          };\n\n          TextRect.prototype.rawBBox = function rawBBox() {\n            // also let's avoid creating a new rectangle.\n            return this._pdfRect;\n          };\n\n          return TextRect;\n        }(Text);\n\n        function addClass(el, cls) {\n          if (el.classList) {\n            el.classList.add(cls);\n          } else {\n            el.className += \" \" + cls;\n          }\n        }\n\n        function removeClass(el, cls) {\n          if (el.classList) {\n            el.classList.remove(cls);\n          } else {\n            el.className = el.className.split(/\\s+/).reduce(function (a, word) {\n              if (word != cls) {\n                a.push(word);\n              }\n\n              return a;\n            }, []).join(\" \");\n          }\n        }\n\n        function setCSS(el, styles) {\n          Object.keys(styles).forEach(function (key) {\n            el.style[key] = styles[key];\n          });\n        }\n\n        var matches = typeof Element !== \"undefined\" && Element.prototype && function (p) {\n          if (p.matches) {\n            return function (el, selector) {\n              return el.matches(selector);\n            };\n          }\n\n          if (p.webkitMatchesSelector) {\n            return function (el, selector) {\n              return el.webkitMatchesSelector(selector);\n            };\n          }\n\n          if (p.mozMatchesSelector) {\n            return function (el, selector) {\n              return el.mozMatchesSelector(selector);\n            };\n          }\n\n          if (p.msMatchesSelector) {\n            return function (el, selector) {\n              return el.msMatchesSelector(selector);\n            };\n          }\n\n          return function (s) {\n            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n          };\n        }(Element.prototype);\n\n        function closest(el, selector) {\n          if (el.closest) {\n            return el.closest(selector);\n          } // IE: stringifying rather than simply comparing with `document`,\n          // which is not iframe-proof and fails in editor export \n          // https://github.com/telerik/kendo/issues/6721\n\n\n          while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n            if (el.nodeType == 1\n            /* Element */\n            && matches(el, selector)) {\n              return el;\n            }\n\n            el = el.parentNode;\n          }\n        } // clone nodes ourselves, so that we redraw <canvas> (DOM or\n        // jQuery clone will not)\n\n\n        var cloneNodes = function ($) {\n          if ($) {\n            // if we have Kendo and jQuery, use this version as it will\n            // maintain proper links between cloned element and Kendo\n            // widgets (i.e. it clones jQuery data(), which isn't the same\n            // as element's data attributes).\n            // https://github.com/telerik/kendo-ui-core/issues/2750\n            return function cloneNodes(el) {\n              var clone = el.cloneNode(false);\n\n              if (el.nodeType == 1\n              /* Element */\n              ) {\n                var $el = $(el),\n                    $clone = $(clone),\n                    i;\n                var data = $el.data();\n\n                for (i in data) {\n                  $clone.data(i, data[i]);\n                }\n\n                if (/^canvas$/i.test(el.tagName)) {\n                  clone.getContext(\"2d\").drawImage(el, 0, 0);\n                } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n                  // drop the name attributes so that we don't affect the selection of the\n                  // original nodes (i.e. checked status of radio buttons) when we insert our copy\n                  // into the DOM.  https://github.com/telerik/kendo/issues/5409\n                  clone.removeAttribute(\"id\");\n                  clone.removeAttribute(\"name\");\n\n                  if (!/^textarea$/i.test(el.tagName)) {\n                    clone.value = el.value;\n                  }\n\n                  clone.checked = el.checked;\n                  clone.selected = el.selected;\n                }\n\n                for (i = el.firstChild; i; i = i.nextSibling) {\n                  clone.appendChild(cloneNodes(i));\n                }\n              }\n\n              return clone;\n            };\n          } else {\n            // the no-jQuery version\n            return function cloneNodes(el) {\n              var clone = function dive(node) {\n                var clone = node.cloneNode(false);\n\n                if (node._kendoExportVisual) {\n                  clone._kendoExportVisual = node._kendoExportVisual;\n                }\n\n                for (var i = node.firstChild; i; i = i.nextSibling) {\n                  clone.appendChild(dive(i));\n                }\n\n                return clone;\n              }(el); // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n\n\n              var canvases = el.querySelectorAll(\"canvas\");\n\n              if (canvases.length) {\n                slice$1$1(clone.querySelectorAll(\"canvas\")).forEach(function (canvas$$1, i) {\n                  canvas$$1.getContext(\"2d\").drawImage(canvases[i], 0, 0);\n                });\n              } // remove \"name\" attributes from <input> elements -\n              // https://github.com/telerik/kendo/issues/5409\n\n\n              var orig = el.querySelectorAll(\"input, select, textarea, option\");\n              slice$1$1(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\n                el.removeAttribute(\"id\");\n                el.removeAttribute(\"name\");\n\n                if (!/^textarea$/i.test(el.tagName)) {\n                  el.value = orig[i].value;\n                }\n\n                el.checked = orig[i].checked;\n                el.selected = orig[i].selected;\n              });\n              return clone;\n            };\n          }\n        }(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\n\n        function getXY(thing) {\n          if (typeof thing == \"number\") {\n            return {\n              x: thing,\n              y: thing\n            };\n          }\n\n          if (Array.isArray(thing)) {\n            return {\n              x: thing[0],\n              y: thing[1]\n            };\n          }\n\n          return {\n            x: thing.x,\n            y: thing.y\n          };\n        }\n\n        function drawDOM(element, options) {\n          if (!options) {\n            options = {};\n          }\n\n          var promise = createPromise();\n\n          if (!element) {\n            return promise.reject(\"No element to export\");\n          }\n\n          if (typeof window.getComputedStyle != \"function\") {\n            throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\n          }\n\n          kendo.pdf.defineFont(getFontFaces(element.ownerDocument));\n          var scale = getXY(options.scale || 1);\n\n          function doOne(element) {\n            var group = new Group(); // translate to start of page\n\n            var pos = element.getBoundingClientRect();\n            setTransform$1(group, [scale.x, 0, 0, scale.y, -pos.left * scale.x, -pos.top * scale.y]);\n            nodeInfo._clipbox = false;\n            nodeInfo._matrix = Matrix.unit();\n            nodeInfo._stackingContext = {\n              element: element,\n              group: group\n            };\n\n            if (options.avoidLinks === true) {\n              nodeInfo._avoidLinks = \"a\";\n            } else {\n              nodeInfo._avoidLinks = options.avoidLinks;\n            }\n\n            addClass(element, \"k-pdf-export\");\n            renderElement(element, group);\n            removeClass(element, \"k-pdf-export\");\n            return group;\n          }\n\n          cacheImages([element], function () {\n            var forceBreak = options && options.forcePageBreak;\n            var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\n            var paperOptions = kendo.pdf.getPaperOptions(function (key, def) {\n              if (key == \"paperSize\") {\n                // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\n                // still be interested in margins.\n                return hasPaperSize ? options[key] : \"A4\";\n              }\n\n              return key in options ? options[key] : def;\n            });\n            var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n            var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n            var margin = options.margin && paperOptions.margin;\n            var hasMargin = Boolean(margin);\n\n            if (forceBreak || pageHeight) {\n              if (!margin) {\n                margin = {\n                  left: 0,\n                  top: 0,\n                  right: 0,\n                  bottom: 0\n                };\n              } // we want paper size and margin to be unaffected by\n              // scaling in the output, so we have to reverse-scale\n              // before our calculations begin.\n\n\n              if (pageWidth) {\n                pageWidth /= scale.x;\n              }\n\n              if (pageHeight) {\n                pageHeight /= scale.y;\n              }\n\n              margin.left /= scale.x;\n              margin.right /= scale.x;\n              margin.top /= scale.y;\n              margin.bottom /= scale.y;\n              var group = new Group({\n                pdf: {\n                  multiPage: true,\n                  paperSize: hasPaperSize ? paperOptions.paperSize : \"auto\",\n                  _ignoreMargin: hasMargin // HACK!  see exportPDF in pdf/drawing.js\n\n                }\n              });\n              handlePageBreaks(function (x) {\n                if (options.progress) {\n                  var canceled = false,\n                      pageNum = 0;\n\n                  (function next() {\n                    if (pageNum < x.pages.length) {\n                      var page = doOne(x.pages[pageNum]);\n                      group.append(page);\n                      options.progress({\n                        page: page,\n                        pageNum: ++pageNum,\n                        totalPages: x.pages.length,\n                        cancel: function () {\n                          canceled = true;\n                        }\n                      });\n\n                      if (!canceled) {\n                        setTimeout(next);\n                      } else {\n                        // XXX: should we also fail() the deferred object?\n                        x.container.parentNode.removeChild(x.container);\n                      }\n                    } else {\n                      x.container.parentNode.removeChild(x.container);\n                      promise.resolve(group);\n                    }\n                  })();\n                } else {\n                  x.pages.forEach(function (page) {\n                    group.append(doOne(page));\n                  });\n                  x.container.parentNode.removeChild(x.container);\n                  promise.resolve(group);\n                }\n              }, element, forceBreak, pageWidth ? pageWidth - margin.left - margin.right : null, pageHeight ? pageHeight - margin.top - margin.bottom : null, margin, options);\n            } else {\n              promise.resolve(doOne(element));\n            }\n          });\n\n          function makeTemplate(template) {\n            if (template != null) {\n              if (typeof template == \"string\") {\n                template = kendo.template(template.replace(/^\\s+|\\s+$/g, \"\"));\n              }\n\n              if (typeof template == \"function\") {\n                return function (data) {\n                  var el = template(data);\n\n                  if (el && typeof el == \"string\") {\n                    var div = document.createElement(\"div\");\n                    div.innerHTML = el;\n                    el = div.firstElementChild;\n                  }\n\n                  return el;\n                };\n              } // assumed DOM element\n\n\n              return function () {\n                return template.cloneNode(true);\n              };\n            }\n          }\n\n          function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n            var template = makeTemplate(options.template);\n            var doc = element.ownerDocument;\n            var pages = [];\n            var copy = options._destructive ? element : cloneNodes(element);\n            var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\n            var adjust = 0; // make sure <tfoot> elements are at the end (Grid widget\n            // places TFOOT before TBODY, tricking our algorithm to\n            // insert a page break right after the header).\n            // https://github.com/telerik/kendo/issues/4699\n\n            slice$1$1(copy.querySelectorAll(\"tfoot\")).forEach(function (tfoot) {\n              tfoot.parentNode.appendChild(tfoot);\n            }); // remember the index of each LI from an ordered list.\n            // we'll use it to reconstruct the proper numbering.\n\n            slice$1$1(copy.querySelectorAll(\"ol\")).forEach(function (ol) {\n              slice$1$1(ol.children).forEach(function (li, index) {\n                li.setAttribute(\"kendo-split-index\", index);\n              });\n            });\n            setCSS(container, {\n              display: \"block\",\n              position: \"absolute\",\n              boxSizing: \"content-box\",\n              left: \"-10000px\",\n              top: \"-10000px\"\n            });\n\n            if (pageWidth) {\n              // subtle: if we don't set the width *and* margins here, the layout in this\n              // container will be different from the one in our final page elements, and we'll\n              // split at the wrong places.\n              setCSS(container, {\n                width: pageWidth + \"px\",\n                paddingLeft: margin.left + \"px\",\n                paddingRight: margin.right + \"px\"\n              }); // when the first element has a margin-top (i.e. a <h1>) the page will be\n              // inadvertently enlarged by that number (the browser will report the container's\n              // bounding box top to start at the element's top, rather than including its\n              // margin).  Adding overflow: hidden seems to fix it.\n              //\n              // to understand the difference, try the following snippets in your browser:\n              //\n              // 1. <div style=\"background: yellow\">\n              //      <h1 style=\"margin: 3em\">Foo</h1>\n              //    </div>\n              //\n              // 2. <div style=\"background: yellow; overflow: hidden\">\n              //      <h1 style=\"margin: 3em\">Foo</h1>\n              //    </div>\n              //\n              // this detail is not important when automatic page breaking is not requested, hence\n              // doing it only if pageWidth is defined.\n\n              setCSS(copy, {\n                overflow: \"hidden\"\n              });\n            }\n\n            element.parentNode.insertBefore(container, element);\n            container.appendChild(copy); // With cache disabled, images will still have height zero until their `complete` attribute\n            // is true.  `whenImagesAreActuallyLoaded` will wait for it.\n\n            if (options.beforePageBreak) {\n              whenImagesAreActuallyLoaded([container], function () {\n                options.beforePageBreak(container, doPageBreak);\n              });\n            } else {\n              whenImagesAreActuallyLoaded([container], doPageBreak);\n            }\n\n            function doPageBreak() {\n              if (forceBreak != \"-\" || pageHeight) {\n                splitElement(copy);\n              }\n\n              {\n                var page = makePage();\n                copy.parentNode.insertBefore(page, copy);\n                page.appendChild(copy);\n              }\n\n              if (template) {\n                pages.forEach(function (page, i) {\n                  var el = template({\n                    element: page,\n                    pageNum: i + 1,\n                    totalPages: pages.length\n                  });\n\n                  if (el) {\n                    page.appendChild(el);\n                  }\n                });\n              }\n\n              cacheImages(pages, callback.bind(null, {\n                pages: pages,\n                container: container\n              }));\n            }\n\n            function keepTogether(el) {\n              if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n                return true;\n              }\n\n              var tag = el.tagName;\n\n              if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n                return false;\n              }\n\n              return el.getAttribute(\"data-kendo-chart\") || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName);\n            }\n\n            function splitElement(element) {\n              if (element.tagName == \"TABLE\") {\n                setCSS(element, {\n                  tableLayout: \"fixed\"\n                });\n              }\n\n              if (keepTogether(element)) {\n                return;\n              }\n\n              var style = getComputedStyle$1(element);\n              var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n              var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\n              var saveAdjust = adjust;\n              adjust += bottomPadding + bottomBorder;\n              var isFirst = true;\n\n              for (var el = element.firstChild; el; el = el.nextSibling) {\n                if (el.nodeType == 1\n                /* Element */\n                ) {\n                  isFirst = false;\n\n                  if (matches(el, forceBreak)) {\n                    breakAtElement(el);\n                    continue;\n                  }\n\n                  if (!pageHeight) {\n                    // we're in \"manual breaks mode\"\n                    splitElement(el);\n                    continue;\n                  }\n\n                  if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle$1(el), \"position\"))) {\n                    continue;\n                  }\n\n                  var fall = fallsOnMargin(el);\n\n                  if (fall == 1) {\n                    // element starts on next page, break before anyway.\n                    breakAtElement(el);\n                  } else if (fall) {\n                    // elements ends up on next page, or possibly doesn't fit on a page at\n                    // all.  break before it anyway if it's an <img> or <tr>, otherwise\n                    // attempt to split.\n                    if (keepTogether(el)) {\n                      breakAtElement(el);\n                    } else {\n                      splitElement(el);\n                    }\n                  } else {\n                    splitElement(el);\n                  }\n                } else if (el.nodeType == 3\n                /* Text */\n                && pageHeight) {\n                  splitText(el, isFirst);\n                  isFirst = false;\n                }\n              }\n\n              adjust = saveAdjust;\n            }\n\n            function firstInParent(el) {\n              var p = el.parentNode,\n                  first = p.firstChild;\n\n              if (el === first) {\n                return true;\n              }\n\n              if (el === p.children[0]) {\n                if (first.nodeType == 7\n                /* comment */\n                || first.nodeType == 8\n                /* processing instruction */\n                ) {\n                  return true;\n                }\n\n                if (first.nodeType == 3\n                /* text */\n                ) {\n                  // if whitespace only we can probably consider it's first\n                  return !/\\S/.test(first.data);\n                }\n              }\n\n              return false;\n            }\n\n            function breakAtElement(el) {\n              if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n                return breakAtElement(el.parentNode);\n              }\n\n              var table, colgroup, thead, grid, gridHead;\n              table = closest(el, \"table\");\n              colgroup = table && table.querySelector(\"colgroup\");\n\n              if (options.repeatHeaders) {\n                thead = table && table.querySelector(\"thead\"); // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n                // necessary because a scrollable grid will keep the header in a separate\n                // <table> element from its content.\n                //\n                // XXX: This is likely to break as soon as the widget HTML is modified.\n\n                grid = closest(el, \".k-grid.k-widget\");\n\n                if (grid && grid.querySelector(\".k-auto-scrollable\")) {\n                  gridHead = grid.querySelector(\".k-grid-header\");\n                }\n              }\n\n              var page = makePage();\n              var range = doc.createRange();\n              range.setStartBefore(copy);\n              range.setEndBefore(el);\n              page.appendChild(range.extractContents());\n              copy.parentNode.insertBefore(page, copy);\n              preventBulletOnListItem(el.parentNode);\n\n              if (table) {\n                table = closest(el, \"table\"); // that's the <table> on next page!\n\n                if (options.repeatHeaders && thead) {\n                  table.insertBefore(thead.cloneNode(true), table.firstChild);\n                }\n\n                if (colgroup) {\n                  table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n                }\n              }\n\n              if (options.repeatHeaders && gridHead) {\n                grid = closest(el, \".k-grid.k-widget\");\n                grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n              }\n            }\n\n            function makePage() {\n              var page = doc.createElement(\"KENDO-PDF-PAGE\");\n              setCSS(page, {\n                display: \"block\",\n                boxSizing: \"content-box\",\n                width: pageWidth ? pageWidth + \"px\" : \"auto\",\n                padding: margin.top + \"px \" + margin.right + \"px \" + margin.bottom + \"px \" + margin.left + \"px\",\n                // allow absolutely positioned elements to be relative to current page\n                position: \"relative\",\n                // without the following we might affect layout of subsequent pages\n                height: pageHeight ? pageHeight + \"px\" : \"auto\",\n                overflow: pageHeight || pageWidth ? \"hidden\" : \"visible\",\n                clear: \"both\"\n              }); // debug\n              // $(\"<div>\").css({\n              //     position  : \"absolute\",\n              //     left      : margin.left,\n              //     top       : margin.top,\n              //     width     : pageWidth,\n              //     height    : pageHeight,\n              //     boxSizing : \"border-box\",\n              //     background: \"rgba(255, 255, 0, 0.5)\"\n              //     //border    : \"1px solid red\"\n              // }).appendTo(page);\n\n              if (options && options.pageClassName) {\n                page.className = options.pageClassName;\n              }\n\n              pages.push(page);\n              return page;\n            }\n\n            function fallsOnMargin(thing) {\n              var box = thing.getBoundingClientRect();\n\n              if (box.width === 0 || box.height === 0) {\n                // I'd say an element with dimensions zero fits on current page.\n                return 0;\n              }\n\n              var top = copy.getBoundingClientRect().top;\n              var available = pageHeight - adjust;\n              return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;\n            }\n\n            function splitText(node, isFirst) {\n              if (!/\\S/.test(node.data)) {\n                return;\n              }\n\n              var len = node.data.length;\n              var range = doc.createRange();\n              range.selectNodeContents(node);\n              var fall = fallsOnMargin(range);\n\n              if (!fall) {\n                return; // the whole text fits on current page\n              }\n\n              var nextnode = node;\n\n              if (fall == 1) {\n                // starts on next page, break before anyway.\n                if (isFirst) {\n                  // avoid leaving an empty <p>, <li>, etc. on previous page.\n                  breakAtElement(node.parentNode);\n                } else {\n                  breakAtElement(node);\n                }\n              } else {\n                (function findEOP(min, pos, max) {\n                  range.setEnd(node, pos);\n\n                  if (min == pos || pos == max) {\n                    return pos;\n                  }\n\n                  if (fallsOnMargin(range)) {\n                    return findEOP(min, min + pos >> 1, pos);\n                  } else {\n                    return findEOP(pos, pos + max >> 1, max);\n                  }\n                })(0, len >> 1, len);\n\n                if (!/\\S/.test(range.toString()) && isFirst) {\n                  // avoid leaving an empty <p>, <li>, etc. on previous page.\n                  breakAtElement(node.parentNode);\n                } else {\n                  // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n                  // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n                  nextnode = node.splitText(range.endOffset);\n                  var page = makePage();\n                  range.setStartBefore(copy);\n                  page.appendChild(range.extractContents());\n                  copy.parentNode.insertBefore(page, copy);\n                  preventBulletOnListItem(nextnode.parentNode);\n                }\n              }\n\n              splitText(nextnode);\n            }\n\n            function preventBulletOnListItem(el) {\n              // set a hint on continued LI elements, to tell the\n              // renderer not to draw the bullet again.\n              // https://github.com/telerik/kendo-ui-core/issues/2732\n              var li = closest(el, \"li\");\n\n              if (li) {\n                li.setAttribute(\"kendo-no-bullet\", \"1\");\n                preventBulletOnListItem(li.parentNode);\n              }\n            }\n          }\n\n          return promise;\n        } // This is needed for the Spreadsheet print functionality.  Since\n        // there we only need to draw text, this cuts through the ceremony\n        // of drawDOM/renderElement and renders the text node directly.\n\n\n        function drawText(element) {\n          var group = new Group();\n          nodeInfo._clipbox = false;\n          nodeInfo._matrix = Matrix.unit();\n          nodeInfo._stackingContext = {\n            element: element,\n            group: group\n          };\n          pushNodeInfo(element, getComputedStyle$1(element), group);\n\n          if (element.firstChild.nodeType == 3\n          /* Text */\n          ) {\n            // avoid the penalty of renderElement\n            renderText(element, element.firstChild, group);\n          } else {\n            _renderElement(element, group);\n          }\n\n          popNodeInfo();\n          return group;\n        }\n\n        var parseBackgroundImage = function () {\n          var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/; //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n\n          var tok_percent = /^([-0-9.]+%)/;\n          var tok_length = /^([-0-9.]+px)/;\n          var tok_keyword = /^(left|right|top|bottom|to|center)\\W/;\n          var tok_angle = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n          var tok_whitespace = /^(\\s+)/;\n          var tok_popen = /^(\\()/;\n          var tok_pclose = /^(\\))/;\n          var tok_comma = /^(,)/;\n          var tok_url = /^(url)\\(/;\n          var tok_content = /^(.*?)\\)/;\n          var cache1 = {},\n              cache2 = {};\n\n          function parse(input) {\n            var orig = input;\n\n            if (hasOwnProperty(cache1, orig)) {\n              return cache1[orig];\n            }\n\n            function skip_ws() {\n              var m = tok_whitespace.exec(input);\n\n              if (m) {\n                input = input.substr(m[1].length);\n              }\n            }\n\n            function read(token) {\n              skip_ws();\n              var m = token.exec(input);\n\n              if (m) {\n                input = input.substr(m[1].length);\n                return m[1];\n              }\n            }\n\n            function read_stop() {\n              var color = kendo.parseColor(input, true);\n              var length, percent;\n\n              if (color) {\n                var match = /^#[0-9a-f]+/i.exec(input) || /^rgba?\\(.*?\\)/i.exec(input) || /^..*?\\b/.exec(input); // maybe named color\n\n                input = input.substr(match[0].length);\n                color = color.toRGB();\n\n                if (!(length = read(tok_length))) {\n                  percent = read(tok_percent);\n                }\n\n                return {\n                  color: color,\n                  length: length,\n                  percent: percent\n                };\n              }\n            }\n\n            function read_linear_gradient(propName) {\n              var angle;\n              var to1, to2;\n              var stops = [];\n              var reverse = false;\n\n              if (read(tok_popen)) {\n                // 1. [ <angle> || to <side-or-corner>, ]?\n                angle = read(tok_angle);\n\n                if (angle == \"0\") {\n                  angle = \"0deg\"; // Edge\n                }\n\n                if (angle) {\n                  angle = parseAngle(angle);\n                  read(tok_comma);\n                } else {\n                  to1 = read(tok_keyword);\n\n                  if (to1 == \"to\") {\n                    to1 = read(tok_keyword);\n                  } else if (to1 && /^-/.test(propName)) {\n                    reverse = true;\n                  }\n\n                  to2 = read(tok_keyword);\n                  read(tok_comma);\n                }\n\n                if (/-moz-/.test(propName) && angle == null && to1 == null) {\n                  var x = read(tok_percent),\n                      y = read(tok_percent);\n                  reverse = true;\n\n                  if (x == \"0%\") {\n                    to1 = \"left\";\n                  } else if (x == \"100%\") {\n                    to1 = \"right\";\n                  }\n\n                  if (y == \"0%\") {\n                    to2 = \"top\";\n                  } else if (y == \"100%\") {\n                    to2 = \"bottom\";\n                  }\n\n                  read(tok_comma);\n                } // 2. color stops\n\n\n                while (input && !read(tok_pclose)) {\n                  var stop = read_stop();\n\n                  if (!stop) {\n                    break;\n                  }\n\n                  stops.push(stop);\n                  read(tok_comma);\n                }\n\n                return {\n                  type: \"linear\",\n                  angle: angle,\n                  to: to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\n                  stops: stops,\n                  reverse: reverse\n                };\n              }\n            }\n\n            function read_url() {\n              if (read(tok_popen)) {\n                var url = read(tok_content);\n                url = url.replace(/^['\"]+|[\"']+$/g, \"\");\n                read(tok_pclose);\n                return {\n                  type: \"url\",\n                  url: url\n                };\n              }\n            }\n\n            var tok;\n\n            if (tok = read(tok_linear_gradient)) {\n              tok = read_linear_gradient(tok);\n            } else if (tok = read(tok_url)) {\n              tok = read_url();\n            }\n\n            return cache1[orig] = tok || {\n              type: \"none\"\n            };\n          }\n\n          return function (input) {\n            if (hasOwnProperty(cache2, input)) {\n              return cache2[input];\n            }\n\n            return cache2[input] = splitProperty(input).map(parse);\n          };\n        }();\n\n        var splitProperty = function () {\n          var cache = {};\n          return function (input, separator) {\n            if (!separator) {\n              separator = /^\\s*,\\s*/;\n            }\n\n            var cacheKey = input + separator;\n\n            if (hasOwnProperty(cache, cacheKey)) {\n              return cache[cacheKey];\n            }\n\n            var ret = [];\n            var last$$1 = 0,\n                pos = 0;\n            var in_paren = 0;\n            var in_string = false;\n            var m;\n\n            function looking_at(rx) {\n              return m = rx.exec(input.substr(pos));\n            }\n\n            function trim(str) {\n              return str.replace(/^\\s+|\\s+$/g, \"\");\n            }\n\n            while (pos < input.length) {\n              if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n                in_paren++;\n                pos++;\n              } else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n                in_paren--;\n                pos++;\n              } else if (!in_string && looking_at(/^[\\\"\\']/)) {\n                in_string = m[0];\n                pos++;\n              } else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\n                pos += 2;\n              } else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\n                pos += 2;\n              } else if (in_string == \"'\" && looking_at(/^\\'/)) {\n                in_string = false;\n                pos++;\n              } else if (in_string == '\"' && looking_at(/^\\\"/)) {\n                in_string = false;\n                pos++;\n              } else if (looking_at(separator)) {\n                if (!in_string && !in_paren && pos > last$$1) {\n                  ret.push(trim(input.substring(last$$1, pos)));\n                  last$$1 = pos + m[0].length;\n                }\n\n                pos += m[0].length;\n              } else {\n                pos++;\n              }\n            }\n\n            if (last$$1 < pos) {\n              ret.push(trim(input.substring(last$$1, pos)));\n            }\n\n            return cache[cacheKey] = ret;\n          };\n        }();\n\n        var getFontURL = function (cache) {\n          return function (el) {\n            // XXX: for IE we get here the whole cssText of the rule,\n            // because the computedStyle.src is empty.  Next time we need\n            // to fix these regexps we better write a CSS parser. :-\\\n            var url = cache[el];\n\n            if (!url) {\n              var m;\n\n              if (m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el)) {\n                url = cache[el] = m[2];\n              } else if (m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el)) {\n                url = cache[el] = m[2];\n              }\n            }\n\n            return url;\n          };\n        }(Object.create ? Object.create(null) : {});\n\n        var getFontHeight = function (cache) {\n          return function (font) {\n            var height = cache[font];\n\n            if (height == null) {\n              height = cache[font] = kendoUtil.measureText(\"Mapq\", {\n                font: font\n              }).height;\n            }\n\n            return height;\n          };\n        }(Object.create ? Object.create(null) : {});\n\n        function getFontFaces(doc) {\n          if (doc == null) {\n            doc = document;\n          }\n\n          var result = {};\n\n          for (var i = 0; i < doc.styleSheets.length; ++i) {\n            doStylesheet(doc.styleSheets[i]);\n          }\n\n          return result;\n\n          function doStylesheet(ss) {\n            if (ss) {\n              var rules = null;\n\n              try {\n                rules = ss.cssRules;\n              } catch (ex) {}\n\n              if (rules) {\n                addRules(ss, rules);\n              }\n            }\n          }\n\n          function findFonts(rule) {\n            var src = getPropertyValue(rule.style, \"src\");\n\n            if (src) {\n              return splitProperty(src).reduce(function (a, el) {\n                var font = getFontURL(el);\n\n                if (font) {\n                  a.push(font);\n                }\n\n                return a;\n              }, []);\n            } else {\n              // Internet Explorer\n              // XXX: this is gross.  should work though for valid CSS.\n              var font = getFontURL(rule.cssText);\n              return font ? [font] : [];\n            }\n          }\n\n          function addRules(styleSheet, rules) {\n            for (var i = 0; i < rules.length; ++i) {\n              var r = rules[i];\n\n              switch (r.type) {\n                case 3:\n                  // CSSImportRule\n                  doStylesheet(r.styleSheet);\n                  break;\n\n                case 5:\n                  // CSSFontFaceRule\n                  var style = r.style;\n                  var family = splitProperty(getPropertyValue(style, \"font-family\"));\n                  var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\n                  var italic = \"italic\" == getPropertyValue(style, \"font-style\");\n                  var src = findFonts(r);\n\n                  if (src.length > 0) {\n                    addRule(styleSheet, family, bold, italic, src[0]);\n                  }\n\n              }\n            }\n          }\n\n          function addRule(styleSheet, names, bold, italic, url) {\n            // We get full resolved absolute URLs in Chrome, but sadly\n            // not in Firefox.\n            if (!/^data:/i.test(url)) {\n              if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n                url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\n              }\n            }\n\n            names.forEach(function (name) {\n              name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\n\n              if (bold) {\n                name += \"|bold\";\n              }\n\n              if (italic) {\n                name += \"|italic\";\n              }\n\n              result[name] = url;\n            });\n          }\n        }\n\n        function hasOwnProperty(obj, key) {\n          return Object.prototype.hasOwnProperty.call(obj, key);\n        }\n\n        function getCounter(name) {\n          name = \"_counter_\" + name;\n          return nodeInfo[name];\n        }\n\n        function getAllCounters(name) {\n          var values = [],\n              p = nodeInfo;\n          name = \"_counter_\" + name;\n\n          while (p) {\n            if (hasOwnProperty(p, name)) {\n              values.push(p[name]);\n            }\n\n            p = Object.getPrototypeOf(p);\n          }\n\n          return values.reverse();\n        }\n\n        function incCounter(name, inc) {\n          var p = nodeInfo;\n          name = \"_counter_\" + name;\n\n          while (p && !hasOwnProperty(p, name)) {\n            p = Object.getPrototypeOf(p);\n          }\n\n          if (!p) {\n            p = nodeInfo._root;\n          }\n\n          p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n        }\n\n        function resetCounter(name, val) {\n          name = \"_counter_\" + name;\n          nodeInfo[name] = val == null ? 0 : val;\n        }\n\n        function doCounters(a, f, def) {\n          for (var i = 0; i < a.length;) {\n            var name = a[i++];\n            var val = parseFloat(a[i]);\n\n            if (isNaN(val)) {\n              f(name, def);\n            } else {\n              f(name, val);\n              ++i;\n            }\n          }\n        }\n\n        function updateCounters(style) {\n          var counterReset = getPropertyValue(style, \"counter-reset\");\n\n          if (counterReset) {\n            doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n          }\n\n          var counterIncrement = getPropertyValue(style, \"counter-increment\");\n\n          if (counterIncrement) {\n            doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n          }\n        }\n\n        function parseColor$1(str, css) {\n          var color = kendo.parseColor(str, true);\n\n          if (color) {\n            color = color.toRGB();\n\n            if (css) {\n              color = color.toCssRgba();\n            } else if (color.a === 0) {\n              color = null;\n            }\n          }\n\n          return color;\n        }\n\n        function whenImagesAreActuallyLoaded(elements, callback) {\n          var pending = 0;\n          elements.forEach(function (el) {\n            var images = el.querySelectorAll(\"img\");\n\n            for (var i = 0; i < images.length; ++i) {\n              var img = images[i];\n\n              if (!img.complete) {\n                pending++;\n                img.onload = img.onerror = next;\n              }\n            }\n          });\n\n          if (!pending) {\n            next();\n          }\n\n          function next() {\n            if (--pending <= 0) {\n              callback();\n            }\n          }\n        }\n\n        function cacheImages(elements, callback) {\n          var urls = [];\n\n          function add(url) {\n            if (!IMAGE_CACHE[url]) {\n              IMAGE_CACHE[url] = true;\n              urls.push(url);\n            }\n          }\n\n          elements.forEach(function dive(element) {\n            if (/^img$/i.test(element.tagName)) {\n              add(element.src);\n            }\n\n            parseBackgroundImage(getPropertyValue(getComputedStyle$1(element), \"background-image\")).forEach(function (bg) {\n              if (bg.type == \"url\") {\n                add(bg.url);\n              }\n            });\n\n            if (element.children) {\n              slice$1$1(element.children).forEach(dive);\n            }\n          });\n          var count = urls.length;\n\n          function next() {\n            if (--count <= 0) {\n              // Even though we cached them, they simply won't be available immediately in the newly\n              // created DOM.  Previously we'd allow a 10ms timeout, but that's arbitrary and clearly\n              // not working in all cases (https://github.com/telerik/kendo/issues/5399), so this\n              // function will wait for their .complete attribute.\n              whenImagesAreActuallyLoaded(elements, callback);\n            }\n          }\n\n          if (count === 0) {\n            next();\n          }\n\n          urls.forEach(function (url) {\n            var img = IMAGE_CACHE[url] = new window.Image();\n\n            if (!/^data:/i.test(url)) {\n              img.crossOrigin = \"Anonymous\";\n            }\n\n            img.src = url;\n\n            if (img.complete) {\n              next();\n            } else {\n              img.onload = next;\n\n              img.onerror = function () {\n                IMAGE_CACHE[url] = null;\n                next();\n              };\n            }\n          });\n        }\n\n        function alphaNumeral(n) {\n          var result = \"\";\n\n          do {\n            var r = n % 26;\n            result = String.fromCharCode(97 + r) + result;\n            n = Math.floor(n / 26);\n          } while (n > 0);\n\n          return result;\n        }\n\n        function pushNodeInfo(element, style, group) {\n          nodeInfo = Object.create(nodeInfo);\n          nodeInfo[element.tagName.toLowerCase()] = {\n            element: element,\n            style: style\n          };\n          var decoration = getPropertyValue(style, \"text-decoration\");\n\n          if (decoration && decoration != \"none\") {\n            var color = getPropertyValue(style, \"color\");\n            decoration.split(/\\s+/g).forEach(function (name) {\n              if (!nodeInfo[name]) {\n                nodeInfo[name] = color;\n              }\n            });\n          }\n\n          if (createsStackingContext(style)) {\n            nodeInfo._stackingContext = {\n              element: element,\n              group: group\n            };\n          }\n        }\n\n        function popNodeInfo() {\n          nodeInfo = Object.getPrototypeOf(nodeInfo);\n        }\n\n        function updateClipbox(path) {\n          if (nodeInfo._clipbox != null) {\n            var box = path.bbox(nodeInfo._matrix);\n\n            if (nodeInfo._clipbox) {\n              nodeInfo._clipbox = Rect.intersect(nodeInfo._clipbox, box);\n            } else {\n              nodeInfo._clipbox = box;\n            }\n          }\n        }\n\n        function emptyClipbox() {\n          var cb = nodeInfo._clipbox;\n\n          if (cb == null) {\n            return true;\n          }\n\n          if (cb) {\n            return cb.width() === 0 || cb.height() === 0;\n          }\n        }\n\n        function createsStackingContext(style) {\n          function prop(name) {\n            return getPropertyValue(style, name);\n          }\n\n          if (prop(\"transform\") != \"none\" || prop(\"position\") != \"static\" || prop(\"z-index\") != \"auto\" || prop(\"opacity\") < 1) {\n            return true;\n          }\n        }\n\n        function getComputedStyle$1(element, pseudoElt) {\n          return window.getComputedStyle(element, pseudoElt || null);\n        }\n\n        function getPropertyValue(style, prop, defa) {\n          var val = style.getPropertyValue(prop);\n\n          if (val == null || val === \"\") {\n            if (browser.webkit) {\n              val = style.getPropertyValue(\"-webkit-\" + prop);\n            } else if (browser.mozilla) {\n              val = style.getPropertyValue(\"-moz-\" + prop);\n            } else if (browser.opera) {\n              val = style.getPropertyValue(\"-o-\" + prop);\n            } else if (microsoft) {\n              val = style.getPropertyValue(\"-ms-\" + prop);\n            }\n          }\n\n          if (arguments.length > 2 && (val == null || val === \"\")) {\n            return defa;\n          } else {\n            return val;\n          }\n        }\n\n        function pleaseSetPropertyValue(style, prop, value, important) {\n          style.setProperty(prop, value, important);\n\n          if (browser.webkit) {\n            style.setProperty(\"-webkit-\" + prop, value, important);\n          } else if (browser.mozilla) {\n            style.setProperty(\"-moz-\" + prop, value, important);\n          } else if (browser.opera) {\n            style.setProperty(\"-o-\" + prop, value, important);\n          } else if (microsoft) {\n            style.setProperty(\"-ms-\" + prop, value, important);\n            prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function (s, p1, p2) {\n              return p1 + p2.toUpperCase();\n            });\n            style[prop] = value;\n          }\n        }\n\n        function getBorder(style, side) {\n          side = \"border-\" + side;\n          return {\n            width: parseFloat(getPropertyValue(style, side + \"-width\")),\n            style: getPropertyValue(style, side + \"-style\"),\n            color: parseColor$1(getPropertyValue(style, side + \"-color\"), true)\n          };\n        }\n\n        function saveStyle(element, func) {\n          var prev = element.style.cssText;\n          var result = func();\n          element.style.cssText = prev;\n          return result;\n        }\n\n        function getBorderRadius(style, side) {\n          var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\n\n          if (r.length == 1) {\n            r.push(r[0]);\n          }\n\n          return sanitizeRadius({\n            x: r[0],\n            y: r[1]\n          });\n        }\n\n        function getContentBox(element) {\n          var box = element.getBoundingClientRect();\n          box = innerBox(box, \"border-*-width\", element);\n          box = innerBox(box, \"padding-*\", element);\n          return box;\n        }\n\n        function innerBox(box, prop, element) {\n          var style, wt, wr, wb, wl;\n\n          if (typeof prop == \"string\") {\n            style = getComputedStyle$1(element);\n            wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\n            wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\n            wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\n            wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\n          } else if (typeof prop == \"number\") {\n            wt = wr = wb = wl = prop;\n          }\n\n          return {\n            top: box.top + wt,\n            right: box.right - wr,\n            bottom: box.bottom - wb,\n            left: box.left + wl,\n            width: box.right - box.left - wr - wl,\n            height: box.bottom - box.top - wb - wt\n          };\n        }\n\n        function getTransform(style) {\n          var transform$$1 = getPropertyValue(style, \"transform\");\n\n          if (transform$$1 == \"none\") {\n            return null;\n          }\n\n          var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform$$1);\n\n          if (matrix) {\n            var origin = getPropertyValue(style, \"transform-origin\");\n            matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n            origin = origin.split(/\\s+/g).map(parseFloat);\n            return {\n              matrix: matrix,\n              origin: origin\n            };\n          }\n        }\n\n        function radiansToDegrees(radians) {\n          return 180 * radians / Math.PI % 360;\n        }\n\n        function parseAngle(angle) {\n          var num = parseFloat(angle);\n\n          if (/grad$/.test(angle)) {\n            return Math.PI * num / 200;\n          } else if (/rad$/.test(angle)) {\n            return num;\n          } else if (/turn$/.test(angle)) {\n            return Math.PI * num * 2;\n          } else if (/deg$/.test(angle)) {\n            return Math.PI * num / 180;\n          }\n        }\n\n        function setTransform$1(shape, m) {\n          m = new Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n          shape.transform(m);\n          return m;\n        }\n\n        function setClipping(shape, clipPath) {\n          shape.clip(clipPath);\n        }\n\n        function addArcToPath(path, x, y, options) {\n          var points = new Arc$2([x, y], options).curvePoints(),\n              i = 1;\n\n          while (i < points.length) {\n            path.curveTo(points[i++], points[i++], points[i++]);\n          }\n        }\n\n        function sanitizeRadius(r) {\n          if (r.x <= 0 || r.y <= 0) {\n            r.x = r.y = 0;\n          }\n\n          return r;\n        }\n\n        function adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n          // adjust border radiuses such that the sum of adjacent\n          // radiuses is not bigger than the length of the side.\n          // seems the correct algorithm is variant (3) from here:\n          // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n          var tl_x = Math.max(0, rTL.x),\n              tl_y = Math.max(0, rTL.y);\n          var tr_x = Math.max(0, rTR.x),\n              tr_y = Math.max(0, rTR.y);\n          var br_x = Math.max(0, rBR.x),\n              br_y = Math.max(0, rBR.y);\n          var bl_x = Math.max(0, rBL.x),\n              bl_y = Math.max(0, rBL.y);\n          var f = Math.min(box.width / (tl_x + tr_x), box.height / (tr_y + br_y), box.width / (br_x + bl_x), box.height / (bl_y + tl_y));\n\n          if (f < 1) {\n            tl_x *= f;\n            tl_y *= f;\n            tr_x *= f;\n            tr_y *= f;\n            br_x *= f;\n            br_y *= f;\n            bl_x *= f;\n            bl_y *= f;\n          }\n\n          return {\n            tl: {\n              x: tl_x,\n              y: tl_y\n            },\n            tr: {\n              x: tr_x,\n              y: tr_y\n            },\n            br: {\n              x: br_x,\n              y: br_y\n            },\n            bl: {\n              x: bl_x,\n              y: bl_y\n            }\n          };\n        }\n\n        function elementRoundBox(element, box, type) {\n          var style = getComputedStyle$1(element);\n          var rTL = getBorderRadius(style, \"top-left\");\n          var rTR = getBorderRadius(style, \"top-right\");\n          var rBL = getBorderRadius(style, \"bottom-left\");\n          var rBR = getBorderRadius(style, \"bottom-right\");\n\n          if (type == \"padding\" || type == \"content\") {\n            var bt = getBorder(style, \"top\");\n            var br = getBorder(style, \"right\");\n            var bb = getBorder(style, \"bottom\");\n            var bl = getBorder(style, \"left\");\n            rTL.x -= bl.width;\n            rTL.y -= bt.width;\n            rTR.x -= br.width;\n            rTR.y -= bt.width;\n            rBR.x -= br.width;\n            rBR.y -= bb.width;\n            rBL.x -= bl.width;\n            rBL.y -= bb.width;\n\n            if (type == \"content\") {\n              var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\n              var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\n              var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n              var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\n              rTL.x -= pl;\n              rTL.y -= pt;\n              rTR.x -= pr;\n              rTR.y -= pt;\n              rBR.x -= pr;\n              rBR.y -= pb;\n              rBL.x -= pl;\n              rBL.y -= pb;\n            }\n          }\n\n          if (typeof type == \"number\") {\n            rTL.x -= type;\n            rTL.y -= type;\n            rTR.x -= type;\n            rTR.y -= type;\n            rBR.x -= type;\n            rBR.y -= type;\n            rBL.x -= type;\n            rBL.y -= type;\n          }\n\n          return roundBox(box, rTL, rTR, rBR, rBL);\n        } // Create a drawing.Path for a rounded rectangle.  Receives the\n        // bounding box and the border-radiuses in CSS order (top-left,\n        // top-right, bottom-right, bottom-left).  The radiuses must be\n        // objects containing x (horiz. radius) and y (vertical radius).\n\n\n        function roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n          var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n          var rTL = tmp.tl;\n          var rTR = tmp.tr;\n          var rBR = tmp.br;\n          var rBL = tmp.bl;\n          var path = new Path({\n            fill: null,\n            stroke: null\n          });\n          path.moveTo(box.left, box.top + rTL.y);\n\n          if (rTL.x) {\n            addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n              startAngle: -180,\n              endAngle: -90,\n              radiusX: rTL.x,\n              radiusY: rTL.y\n            });\n          }\n\n          path.lineTo(box.right - rTR.x, box.top);\n\n          if (rTR.x) {\n            addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n              startAngle: -90,\n              endAngle: 0,\n              radiusX: rTR.x,\n              radiusY: rTR.y\n            });\n          }\n\n          path.lineTo(box.right, box.bottom - rBR.y);\n\n          if (rBR.x) {\n            addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n              startAngle: 0,\n              endAngle: 90,\n              radiusX: rBR.x,\n              radiusY: rBR.y\n            });\n          }\n\n          path.lineTo(box.left + rBL.x, box.bottom);\n\n          if (rBL.x) {\n            addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n              startAngle: 90,\n              endAngle: 180,\n              radiusX: rBL.x,\n              radiusY: rBL.y\n            });\n          }\n\n          return path.close();\n        }\n\n        function formatCounter(val, style) {\n          var str = String(parseFloat(val));\n\n          switch (style) {\n            case \"decimal-leading-zero\":\n              if (str.length < 2) {\n                str = \"0\" + str;\n              }\n\n              return str;\n\n            case \"lower-roman\":\n              return arabicToRoman(val).toLowerCase();\n\n            case \"upper-roman\":\n              return arabicToRoman(val).toUpperCase();\n\n            case \"lower-latin\":\n            case \"lower-alpha\":\n              return alphaNumeral(val - 1);\n\n            case \"upper-latin\":\n            case \"upper-alpha\":\n              return alphaNumeral(val - 1).toUpperCase();\n\n            default:\n              return str;\n          }\n        }\n\n        function evalPseudoElementContent(element, content) {\n          function displayCounter(name, style, separator) {\n            if (!separator) {\n              return formatCounter(getCounter(name) || 0, style);\n            }\n\n            separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\n            return getAllCounters(name).map(function (val) {\n              return formatCounter(val, style);\n            }).join(separator);\n          }\n\n          var a = splitProperty(content, /^\\s+/);\n          var result = [],\n              m;\n          a.forEach(function (el) {\n            var tmp;\n\n            if (m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el)) {\n              result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function (s, p) {\n                return String.fromCharCode(parseInt(p, 16));\n              }));\n            } else if (m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el)) {\n              tmp = splitProperty(m[1]);\n              result.push(displayCounter(tmp[0], tmp[1]));\n            } else if (m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el)) {\n              tmp = splitProperty(m[1]);\n              result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n            } else if (m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el)) {\n              result.push(element.getAttribute(m[1]) || \"\");\n            } else {\n              result.push(el);\n            }\n          });\n          return result.join(\"\");\n        }\n\n        function getCssText(style) {\n          if (style.cssText) {\n            return style.cssText;\n          } // Status: NEW.  Report year: 2002.  Current year: 2014.\n          // Nice played, Mozillians.\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n\n\n          var result = [];\n\n          for (var i = 0; i < style.length; ++i) {\n            result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\n          }\n\n          return result.join(\";\\n\");\n        }\n\n        function _renderWithPseudoElements(element, group) {\n          if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n            _renderElement(element, group);\n\n            return;\n          }\n\n          var fake = [];\n\n          function pseudo(kind, place) {\n            var style = getComputedStyle$1(element, kind),\n                content = style.content;\n            updateCounters(style);\n\n            if (content && content != \"normal\" && content != \"none\" && style.width != \"0px\") {\n              var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n              psel.style.cssText = getCssText(style);\n              psel.textContent = evalPseudoElementContent(element, content);\n              element.insertBefore(psel, place);\n              fake.push(psel);\n            }\n          }\n\n          pseudo(\":before\", element.firstChild);\n          pseudo(\":after\", null);\n\n          if (fake.length > 0) {\n            var saveClass = element.className;\n            element.className += \" kendo-pdf-hide-pseudo-elements\";\n\n            _renderElement(element, group);\n\n            element.className = saveClass;\n            fake.forEach(function (el) {\n              element.removeChild(el);\n            });\n          } else {\n            _renderElement(element, group);\n          }\n        }\n\n        function _renderElement(element, group) {\n          var style = getComputedStyle$1(element);\n          var top = getBorder(style, \"top\");\n          var right = getBorder(style, \"right\");\n          var bottom = getBorder(style, \"bottom\");\n          var left = getBorder(style, \"left\");\n          var rTL0 = getBorderRadius(style, \"top-left\");\n          var rTR0 = getBorderRadius(style, \"top-right\");\n          var rBL0 = getBorderRadius(style, \"bottom-left\");\n          var rBR0 = getBorderRadius(style, \"bottom-right\");\n          var dir = getPropertyValue(style, \"direction\");\n          var backgroundColor = getPropertyValue(style, \"background-color\");\n          backgroundColor = parseColor$1(backgroundColor);\n          var backgroundImage = parseBackgroundImage(getPropertyValue(style, \"background-image\"));\n          var backgroundRepeat = splitProperty(getPropertyValue(style, \"background-repeat\"));\n          var backgroundPosition = splitProperty(getPropertyValue(style, \"background-position\"));\n          var backgroundOrigin = splitProperty(getPropertyValue(style, \"background-origin\"));\n          var backgroundSize = splitProperty(getPropertyValue(style, \"background-size\")); // IE shrinks the text with text-overflow: ellipsis,\n          // apparently because the returned bounding box for the range\n          // is limited to the visible area minus space for the dots,\n          // instead of being the full width of the text.\n          //\n          // https://github.com/telerik/kendo/issues/5232\n          // https://github.com/telerik/kendo-ui-core/issues/1868\n          //\n          // We have to test it here rather than in renderText because\n          // text-overflow: ellipsis could be set on a parent element (not\n          // necessarily the one containing the text); in this case,\n          // getComputedStyle(elementWithTheText) will return \"clip\", not\n          // \"ellipsis\" (which is probably a bug, but oh well...)\n\n          var textOverflow, saveTextOverflow;\n\n          if (microsoft) {\n            textOverflow = style.textOverflow; // computed style\n\n            if (textOverflow == \"ellipsis\") {\n              saveTextOverflow = element.style.textOverflow; // own style.\n\n              element.style.textOverflow = \"clip\";\n            }\n          }\n\n          if (browser.msie && browser.version < 10) {\n            // IE9 hacks.  getPropertyValue won't return the correct\n            // value.  Sucks that we have to do it here, I'd prefer to\n            // move it in getPropertyValue, but we don't have the\n            // element.\n            backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n          }\n\n          var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element); // CSS \"clip\" property - if present, replace the group with a\n          // new one which is clipped.  This must happen before drawing\n          // the borders and background.\n\n          (function () {\n            var clip = getPropertyValue(style, \"clip\");\n            var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n\n            if (m) {\n              var a = m[1].split(/[ ,]+/g);\n              var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n              var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n              var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n              var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n              var tmp = new Group();\n              var clipPath = new Path().moveTo(left, top).lineTo(right, top).lineTo(right, bottom).lineTo(left, bottom).close();\n              setClipping(tmp, clipPath);\n              group.append(tmp);\n              group = tmp;\n              updateClipbox(clipPath);\n            }\n          })();\n\n          var boxes, i, cells;\n          var display = getPropertyValue(style, \"display\");\n\n          if (display == \"table-row\") {\n            // because of rowspan/colspan, we shouldn't draw background of table row elements on the\n            // box given by its getBoundingClientRect, because if we do we risk overwritting a\n            // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n            boxes = [];\n\n            for (i = 0, cells = element.children; i < cells.length; ++i) {\n              boxes.push(cells[i].getBoundingClientRect());\n            }\n          } else {\n            boxes = element.getClientRects();\n\n            if (boxes.length == 1) {\n              // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n              // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n              // getClientRects() to support cases where there are more boxes (continued inline\n              // elements that might have border/background).\n              boxes = [element.getBoundingClientRect()];\n            }\n          } // This function workarounds another Chrome bug, where boxes returned for a table with\n          // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n          // such case anyway, but with this is better than without it.\n\n\n          boxes = adjustBoxes(boxes);\n\n          for (i = 0; i < boxes.length; ++i) {\n            drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n          } // Render links as separate groups.  We can't use boxes returned by element's getClientRects\n          // because if display type is \"inline\" (default for <a>), boxes will not include the height of\n          // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n\n\n          if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\n            if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n              var r = document.createRange();\n              r.selectNodeContents(element);\n              slice$1$1(r.getClientRects()).forEach(function (box) {\n                var g = new Group();\n                g._pdfLink = {\n                  url: element.href,\n                  top: box.top,\n                  right: box.right,\n                  bottom: box.bottom,\n                  left: box.left\n                };\n                group.append(g);\n              });\n            }\n          }\n\n          if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\n            drawBullet(boxes[0]);\n          } // overflow: hidden/auto - if present, replace the group with\n          // a new one clipped by the inner box.\n\n\n          (function () {\n            function clipit() {\n              var clipPath = elementRoundBox(element, innerbox, \"padding\");\n              var tmp = new Group();\n              setClipping(tmp, clipPath);\n              group.append(tmp);\n              group = tmp;\n              updateClipbox(clipPath);\n            }\n\n            if (isFormField(element)) {\n              clipit();\n            } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\n              clipit();\n            } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\n              clipit();\n            } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\n              clipit();\n            }\n          })();\n\n          if (!maybeRenderWidget(element, group)) {\n            renderContents(element, group);\n          }\n\n          if (microsoft && textOverflow == \"ellipsis\") {\n            element.style.textOverflow = saveTextOverflow;\n          }\n\n          return group; // only utility functions after this line.\n\n          function adjustBoxes(boxes) {\n            if (/^td$/i.test(element.tagName)) {\n              var table = nodeInfo.table;\n\n              if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\n                var tableBorderLeft = getBorder(table.style, \"left\").width;\n                var tableBorderTop = getBorder(table.style, \"top\").width; // check if we need to adjust\n\n                if (tableBorderLeft === 0 && tableBorderTop === 0) {\n                  return boxes; // nope\n                }\n\n                var tableBox = table.element.getBoundingClientRect();\n                var firstCell = table.element.rows[0].cells[0];\n                var firstCellBox = firstCell.getBoundingClientRect();\n\n                if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n                  return slice$1$1(boxes).map(function (box) {\n                    return {\n                      left: box.left + tableBorderLeft,\n                      top: box.top + tableBorderTop,\n                      right: box.right + tableBorderLeft,\n                      bottom: box.bottom + tableBorderTop,\n                      height: box.height,\n                      width: box.width\n                    };\n                  });\n                }\n              }\n            }\n\n            return boxes;\n          } // this function will be called to draw each border.  it\n          // draws starting at origin and the resulted path must be\n          // translated/rotated to be placed in the proper position.\n          //\n          // arguments are named as if it draws the top border:\n          //\n          //    - `len` the length of the edge\n          //    - `Wtop` the width of the edge (i.e. border-top-width)\n          //    - `Wleft` the width of the left edge (border-left-width)\n          //    - `Wright` the width of the right edge\n          //    - `rl` and `rl` -- the border radius on the left and right\n          //      (objects containing x and y, for horiz/vertical radius)\n          //    - `transform` -- transformation to apply\n          //\n\n\n          function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform$$1) {\n            if (Wtop <= 0) {\n              return;\n            }\n\n            var path,\n                edge = new Group();\n            setTransform$1(edge, transform$$1);\n            group.append(edge);\n            sanitizeRadius(rl);\n            sanitizeRadius(rr); // draw main border.  this is the area without the rounded corners\n\n            path = new Path({\n              fill: {\n                color: color\n              },\n              stroke: null\n            });\n            edge.append(path);\n            path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();\n\n            if (rl.x) {\n              drawRoundCorner(Wleft, rl, [-1, 0, 0, 1, rl.x, 0]);\n            }\n\n            if (rr.x) {\n              drawRoundCorner(Wright, rr, [1, 0, 0, 1, len - rr.x, 0]);\n            } // draws one round corner, starting at origin (needs to be\n            // translated/rotated to be placed properly).\n\n\n            function drawRoundCorner(Wright, r, transform$$1) {\n              var angle = Math.PI / 2 * Wright / (Wright + Wtop); // not sanitizing this one, because negative values\n              // are useful to fill the box correctly.\n\n              var ri = {\n                x: r.x - Wright,\n                y: r.y - Wtop\n              };\n              var path = new Path({\n                fill: {\n                  color: color\n                },\n                stroke: null\n              }).moveTo(0, 0);\n              setTransform$1(path, transform$$1);\n              addArcToPath(path, 0, r.y, {\n                startAngle: -90,\n                endAngle: -radiansToDegrees(angle),\n                radiusX: r.x,\n                radiusY: r.y\n              });\n\n              if (ri.x > 0 && ri.y > 0) {\n                path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n                addArcToPath(path, 0, r.y, {\n                  startAngle: -radiansToDegrees(angle),\n                  endAngle: -90,\n                  radiusX: ri.x,\n                  radiusY: ri.y,\n                  anticlockwise: true\n                });\n              } else if (ri.x > 0) {\n                path.lineTo(ri.x, Wtop).lineTo(0, Wtop);\n              } else {\n                path.lineTo(ri.x, Wtop).lineTo(ri.x, 0);\n              }\n\n              edge.append(path.close());\n            }\n          }\n\n          function drawBackground(box) {\n            var background = new Group();\n            setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n            group.append(background);\n\n            if (backgroundColor) {\n              var path = new Path({\n                fill: {\n                  color: backgroundColor.toCssRgba()\n                },\n                stroke: null\n              });\n              path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();\n              background.append(path);\n            }\n\n            for (var i = backgroundImage.length; --i >= 0;) {\n              drawOneBackground(background, box, backgroundImage[i], backgroundRepeat[i % backgroundRepeat.length], backgroundPosition[i % backgroundPosition.length], backgroundOrigin[i % backgroundOrigin.length], backgroundSize[i % backgroundSize.length]);\n            }\n          }\n\n          function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n            if (!background || background == \"none\") {\n              return;\n            }\n\n            if (background.type == \"url\") {\n              var img = IMAGE_CACHE[background.url];\n\n              if (img && img.width > 0 && img.height > 0) {\n                drawBackgroundImage(group, box, img.width, img.height, function (group, rect) {\n                  group.append(new Image$1(background.url, rect));\n                });\n              }\n            } else if (background.type == \"linear\") {\n              drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n            } else {\n              return;\n            }\n\n            function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n              var aspect_ratio = img_width / img_height,\n                  f; // for background-origin: border-box the box is already appropriate\n\n              var orgBox = box;\n\n              if (backgroundOrigin == \"content-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n                orgBox = innerBox(orgBox, \"padding-*\", element);\n              } else if (backgroundOrigin == \"padding-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n              }\n\n              if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n                if (backgroundSize == \"contain\") {\n                  f = Math.min(orgBox.width / img_width, orgBox.height / img_height);\n                  img_width *= f;\n                  img_height *= f;\n                } else if (backgroundSize == \"cover\") {\n                  f = Math.max(orgBox.width / img_width, orgBox.height / img_height);\n                  img_width *= f;\n                  img_height *= f;\n                } else {\n                  var size = backgroundSize.split(/\\s+/g); // compute width\n\n                  if (/%$/.test(size[0])) {\n                    img_width = orgBox.width * parseFloat(size[0]) / 100;\n                  } else {\n                    img_width = parseFloat(size[0]);\n                  } // compute height\n\n\n                  if (size.length == 1 || size[1] == \"auto\") {\n                    img_height = img_width / aspect_ratio;\n                  } else if (/%$/.test(size[1])) {\n                    img_height = orgBox.height * parseFloat(size[1]) / 100;\n                  } else {\n                    img_height = parseFloat(size[1]);\n                  }\n                }\n              }\n\n              var pos = String(backgroundPosition); // IE sometimes reports single-word positions\n              // https://github.com/telerik/kendo-ui-core/issues/2786\n              //\n              // it seems to switch to percentages when the horizontal\n              // position is not \"center\", therefore we don't handle\n              // multi-word cases here.  All other browsers return\n              // percentages or pixels instead of keywords.  At least\n              // for now...\n\n              switch (pos) {\n                case \"bottom\":\n                  pos = \"50% 100%\";\n                  break;\n\n                case \"top\":\n                  pos = \"50% 0\";\n                  break;\n\n                case \"left\":\n                  pos = \"0 50%\";\n                  break;\n\n                case \"right\":\n                  pos = \"100% 50%\";\n                  break;\n\n                case \"center\":\n                  pos = \"50% 50%\";\n                  break;\n              }\n\n              pos = pos.split(/\\s+/);\n\n              if (pos.length == 1) {\n                pos[1] = \"50%\";\n              }\n\n              if (/%$/.test(pos[0])) {\n                pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n              } else {\n                pos[0] = parseFloat(pos[0]);\n              }\n\n              if (/%$/.test(pos[1])) {\n                pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n              } else {\n                pos[1] = parseFloat(pos[1]);\n              }\n\n              var rect = new Rect([orgBox.left + pos[0], orgBox.top + pos[1]], [img_width, img_height]); // XXX: background-repeat could be implemented more\n              //      efficiently as a fill pattern (at least for PDF\n              //      output, probably SVG too).\n\n              function rewX() {\n                while (rect.origin.x > box.left) {\n                  rect.origin.x -= img_width;\n                }\n              }\n\n              function rewY() {\n                while (rect.origin.y > box.top) {\n                  rect.origin.y -= img_height;\n                }\n              }\n\n              function repeatX() {\n                while (rect.origin.x < box.right) {\n                  renderBG(group, rect.clone());\n                  rect.origin.x += img_width;\n                }\n              }\n\n              if (backgroundRepeat == \"no-repeat\") {\n                renderBG(group, rect);\n              } else if (backgroundRepeat == \"repeat-x\") {\n                rewX();\n                repeatX();\n              } else if (backgroundRepeat == \"repeat-y\") {\n                rewY();\n\n                while (rect.origin.y < box.bottom) {\n                  renderBG(group, rect.clone());\n                  rect.origin.y += img_height;\n                }\n              } else if (backgroundRepeat == \"repeat\") {\n                rewX();\n                rewY();\n                var origin = rect.origin.clone();\n\n                while (rect.origin.y < box.bottom) {\n                  rect.origin.x = origin.x;\n                  repeatX();\n                  rect.origin.y += img_height;\n                }\n              }\n            }\n          }\n\n          function drawBullet() {\n            var listStyleType = getPropertyValue(style, \"list-style-type\");\n\n            if (listStyleType == \"none\") {\n              return;\n            }\n\n            var listStylePosition = getPropertyValue(style, \"list-style-position\");\n\n            function _drawBullet(f) {\n              saveStyle(element, function () {\n                element.style.position = \"relative\";\n                var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n                bullet.style.position = \"absolute\";\n                bullet.style.boxSizing = \"border-box\";\n\n                if (listStylePosition == \"outside\") {\n                  bullet.style.width = \"6em\";\n                  bullet.style.left = \"-6.8em\";\n                  bullet.style.textAlign = \"right\";\n                } else {\n                  bullet.style.left = \"0px\";\n                }\n\n                f(bullet);\n                element.insertBefore(bullet, element.firstChild);\n                renderElement(bullet, group);\n                element.removeChild(bullet);\n              });\n            }\n\n            function elementIndex(f) {\n              var a = element.parentNode.children;\n              var k = element.getAttribute(\"kendo-split-index\");\n\n              if (k != null) {\n                return f(k | 0, a.length);\n              }\n\n              for (var i = 0; i < a.length; ++i) {\n                if (a[i] === element) {\n                  return f(i, a.length);\n                }\n              }\n            }\n\n            switch (listStyleType) {\n              case \"circle\":\n              case \"disc\":\n              case \"square\":\n                _drawBullet(function (bullet) {\n                  // XXX: the science behind these values is called \"trial and error\".\n                  bullet.style.fontSize = \"60%\";\n                  bullet.style.lineHeight = \"200%\";\n                  bullet.style.paddingRight = \"0.5em\";\n                  bullet.style.fontFamily = \"DejaVu Serif\";\n                  bullet.innerHTML = {\n                    \"disc\": \"\\u25cf\",\n                    \"circle\": \"\\u25ef\",\n                    \"square\": \"\\u25a0\"\n                  }[listStyleType];\n                });\n\n                break;\n\n              case \"decimal\":\n              case \"decimal-leading-zero\":\n                _drawBullet(function (bullet) {\n                  elementIndex(function (idx) {\n                    ++idx;\n\n                    if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\n                      idx = \"0\" + idx;\n                    }\n\n                    bullet.innerHTML = idx + \".\";\n                  });\n                });\n\n                break;\n\n              case \"lower-roman\":\n              case \"upper-roman\":\n                _drawBullet(function (bullet) {\n                  elementIndex(function (idx) {\n                    idx = arabicToRoman(idx + 1);\n\n                    if (listStyleType == \"upper-roman\") {\n                      idx = idx.toUpperCase();\n                    }\n\n                    bullet.innerHTML = idx + \".\";\n                  });\n                });\n\n                break;\n\n              case \"lower-latin\":\n              case \"lower-alpha\":\n              case \"upper-latin\":\n              case \"upper-alpha\":\n                _drawBullet(function (bullet) {\n                  elementIndex(function (idx) {\n                    idx = alphaNumeral(idx);\n\n                    if (/^upper/i.test(listStyleType)) {\n                      idx = idx.toUpperCase();\n                    }\n\n                    bullet.innerHTML = idx + \".\";\n                  });\n                });\n\n                break;\n            }\n          } // draws a single border box\n\n\n          function drawOneBox(box, isFirst, isLast) {\n            if (box.width === 0 || box.height === 0) {\n              return;\n            }\n\n            drawBackground(box);\n            var shouldDrawLeft = left.width > 0 && (isFirst && dir == \"ltr\" || isLast && dir == \"rtl\");\n            var shouldDrawRight = right.width > 0 && (isLast && dir == \"ltr\" || isFirst && dir == \"rtl\"); // The most general case is that the 4 borders have different widths and border\n            // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n            // straight line, and two round corners which represent half of the entire rounded\n            // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n            // function), then translated/rotated into the right position.\n            //\n            // However, this leads to poor results due to rounding in the simpler cases where\n            // borders are straight lines.  Therefore we handle a few such cases separately with\n            // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n            // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n            // web dev is still a ghetto.)\n            // first, just in case there is no border...\n\n            if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n              return;\n            } // START paint borders\n            // if all borders have equal colors...\n\n\n            if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n              // if same widths too, we can draw the whole border by stroking a single path.\n              if (top.width == right.width && top.width == bottom.width && top.width == left.width) {\n                if (shouldDrawLeft && shouldDrawRight) {\n                  // reduce box by half the border width, so we can draw it by stroking.\n                  box = innerBox(box, top.width / 2); // adjust the border radiuses, again by top.width/2, and make the path element.\n\n                  var path = elementRoundBox(element, box, top.width / 2);\n                  path.options.stroke = {\n                    color: top.color,\n                    width: top.width\n                  };\n                  group.append(path);\n                  return;\n                }\n              }\n            } // if border radiuses are zero and widths are at most one pixel, we can again use simple\n            // paths.\n\n\n            if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n              // alright, 1.9px will do as well.  the difference in color blending should not be\n              // noticeable.\n              if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n                // top border\n                if (top.width > 0) {\n                  group.append(new Path({\n                    stroke: {\n                      width: top.width,\n                      color: top.color\n                    }\n                  }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2));\n                } // bottom border\n\n\n                if (bottom.width > 0) {\n                  group.append(new Path({\n                    stroke: {\n                      width: bottom.width,\n                      color: bottom.color\n                    }\n                  }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2));\n                } // left border\n\n\n                if (shouldDrawLeft) {\n                  group.append(new Path({\n                    stroke: {\n                      width: left.width,\n                      color: left.color\n                    }\n                  }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom));\n                } // right border\n\n\n                if (shouldDrawRight) {\n                  group.append(new Path({\n                    stroke: {\n                      width: right.width,\n                      color: right.color\n                    }\n                  }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom));\n                }\n\n                return;\n              }\n            } // END paint borders\n\n\n            var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n            var rTL = tmp.tl;\n            var rTR = tmp.tr;\n            var rBR = tmp.br;\n            var rBL = tmp.bl; // top border\n\n            drawEdge(top.color, box.width, top.width, left.width, right.width, rTL, rTR, [1, 0, 0, 1, box.left, box.top]); // bottom border\n\n            drawEdge(bottom.color, box.width, bottom.width, right.width, left.width, rBR, rBL, [-1, 0, 0, -1, box.right, box.bottom]); // for left/right borders we need to invert the border-radiuses\n\n            function inv(p) {\n              return {\n                x: p.y,\n                y: p.x\n              };\n            } // left border\n\n\n            drawEdge(left.color, box.height, left.width, bottom.width, top.width, inv(rBL), inv(rTL), [0, -1, 1, 0, box.left, box.bottom]); // right border\n\n            drawEdge(right.color, box.height, right.width, top.width, bottom.width, inv(rTR), inv(rBR), [0, 1, -1, 0, box.right, box.top]);\n          }\n        }\n\n        function gradientRenderer(gradient) {\n          return function (group, rect) {\n            var width = rect.width(),\n                height = rect.height();\n\n            switch (gradient.type) {\n              case \"linear\":\n                // figure out the angle.\n                var angle = gradient.angle != null ? gradient.angle : Math.PI;\n\n                switch (gradient.to) {\n                  case \"top\":\n                    angle = 0;\n                    break;\n\n                  case \"left\":\n                    angle = -Math.PI / 2;\n                    break;\n\n                  case \"bottom\":\n                    angle = Math.PI;\n                    break;\n\n                  case \"right\":\n                    angle = Math.PI / 2;\n                    break;\n\n                  case \"top left\":\n                  case \"left top\":\n                    angle = -Math.atan2(height, width);\n                    break;\n\n                  case \"top right\":\n                  case \"right top\":\n                    angle = Math.atan2(height, width);\n                    break;\n\n                  case \"bottom left\":\n                  case \"left bottom\":\n                    angle = Math.PI + Math.atan2(height, width);\n                    break;\n\n                  case \"bottom right\":\n                  case \"right bottom\":\n                    angle = Math.PI - Math.atan2(height, width);\n                    break;\n                }\n\n                if (gradient.reverse) {\n                  angle -= Math.PI;\n                } // limit the angle between 0..2PI\n\n\n                angle %= 2 * Math.PI;\n\n                if (angle < 0) {\n                  angle += 2 * Math.PI;\n                } // compute gradient's start/end points.  here len is the length of the gradient line\n                // and x,y is the end point relative to the center of the rectangle in conventional\n                // (math) axis direction.\n                // this is the original (unscaled) length of the gradient line.  needed to deal with\n                // absolutely positioned color stops.  formula from the CSS spec:\n                // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n\n\n                var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle)); // The math below is pretty simple, but it took a while to figure out.  We compute x\n                // and y, the *end* of the gradient line.  However, we want to transform them into\n                // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\n                // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n                // bottom edge.\n                //\n                // A naive approach would use the original angle for these calculations.  Say we'd\n                // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n                // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n                // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n                // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n                // the following:\n                //\n                //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\n                //     identity matrix, the normal of the linear gradient is perpendicular to the\n                //     gradient vector in object bounding box space (i.e., the abstract coordinate\n                //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n                //     at the bottom/right of the object bounding box). When the object's bounding\n                //     box is not square, the gradient normal which is initially perpendicular to\n                //     the gradient vector within object bounding box space may render\n                //     non-perpendicular relative to the gradient vector in user space. If the\n                //     gradient vector is parallel to one of the axes of the bounding box, the\n                //     gradient normal will remain perpendicular. This transformation is due to\n                //     application of the non-uniform scaling transformation from bounding box space\n                //     to user space.\n                //\n                // which is an extremely long and confusing way to tell what I just said above.\n                //\n                // For this reason we need to apply the reverse scaling to the original angle, so\n                // that when it'll finally be rendered it'll actually be at the desired slope.  Now\n                // I'll let you figure out the math yourself.\n\n                var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n                var sin = Math.sin(scaledAngle),\n                    cos = Math.cos(scaledAngle);\n                var len = Math.abs(sin) + Math.abs(cos);\n                var x = len / 2 * sin;\n                var y = len / 2 * cos; // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n                // losing the intended direction of the gradient.  The following fixes it.\n\n                if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {\n                  x = -x;\n                  y = -y;\n                } // compute the color stops.\n\n\n                var implicit = [],\n                    right = 0;\n                var stops = gradient.stops.map(function (s, i) {\n                  var offset = s.percent;\n\n                  if (offset) {\n                    offset = parseFloat(offset) / 100;\n                  } else if (s.length) {\n                    offset = parseFloat(s.length) / pxlen;\n                  } else if (i === 0) {\n                    offset = 0;\n                  } else if (i == gradient.stops.length - 1) {\n                    offset = 1;\n                  }\n\n                  var stop = {\n                    color: s.color.toCssRgba(),\n                    offset: offset\n                  };\n\n                  if (offset != null) {\n                    right = offset; // fix implicit offsets\n\n                    implicit.forEach(function (s, i) {\n                      var stop = s.stop;\n                      stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n                    });\n                    implicit = [];\n                  } else {\n                    implicit.push({\n                      left: right,\n                      stop: stop\n                    });\n                  }\n\n                  return stop;\n                });\n                var start = [0.5 - x, 0.5 + y];\n                var end = [0.5 + x, 0.5 - y]; // finally, draw it.\n\n                group.append(Path.fromRect(rect).stroke(null).fill(new LinearGradient({\n                  start: start,\n                  end: end,\n                  stops: stops,\n                  userSpace: false\n                })));\n                break;\n\n              case \"radial\":\n                // XXX:\n                if (window.console && window.console.log) {\n                  window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\n                }\n\n                break;\n            }\n          };\n        }\n\n        function maybeRenderWidget(element, group) {\n          var visual;\n\n          if (element._kendoExportVisual) {\n            visual = element._kendoExportVisual();\n          } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\n            var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n\n            if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n              if (widget.exportDOMVisual) {\n                visual = widget.exportDOMVisual();\n              } else {\n                visual = widget.exportVisual();\n              }\n            }\n          }\n\n          if (!visual) {\n            return false;\n          }\n\n          var wrap$$1 = new Group();\n          wrap$$1.children.push(visual);\n          var bbox = element.getBoundingClientRect();\n          wrap$$1.transform(transform$1().translate(bbox.left, bbox.top));\n          group.append(wrap$$1);\n          return true;\n        }\n\n        function renderImage(element, url, group) {\n          var box = getContentBox(element);\n          var rect = new Rect([box.left, box.top], [box.width, box.height]);\n          var image = new Image$1(url, rect);\n          setClipping(image, elementRoundBox(element, box, \"content\"));\n          group.append(image);\n        }\n\n        function zIndexSort(a, b) {\n          var sa = getComputedStyle$1(a);\n          var sb = getComputedStyle$1(b);\n          var za = parseFloat(getPropertyValue(sa, \"z-index\"));\n          var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\n          var pa = getPropertyValue(sa, \"position\");\n          var pb = getPropertyValue(sb, \"position\");\n\n          if (isNaN(za) && isNaN(zb)) {\n            if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {\n              return 0;\n            }\n\n            if (pa == \"static\") {\n              return -1;\n            }\n\n            if (pb == \"static\") {\n              return 1;\n            }\n\n            return 0;\n          }\n\n          if (isNaN(za)) {\n            return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n          }\n\n          if (isNaN(zb)) {\n            return za === 0 ? 0 : za > 0 ? 1 : -1;\n          }\n\n          return parseFloat(za) - parseFloat(zb);\n        }\n\n        function isFormField(element) {\n          return /^(?:textarea|select|input)$/i.test(element.tagName);\n        }\n\n        function getSelectedOption(element) {\n          if (element.selectedOptions && element.selectedOptions.length > 0) {\n            return element.selectedOptions[0];\n          }\n\n          return element.options[element.selectedIndex];\n        }\n\n        function renderCheckbox(element, group) {\n          var style = getComputedStyle$1(element);\n          var color = getPropertyValue(style, \"color\");\n          var box = element.getBoundingClientRect();\n\n          if (element.type == \"checkbox\") {\n            group.append(Path.fromRect(new Rect([box.left + 1, box.top + 1], [box.width - 2, box.height - 2])).stroke(color, 1));\n\n            if (element.checked) {\n              // fill a rectangle inside?  looks kinda ugly.\n              // group.append(\n              //     Path.fromRect(\n              //         new geo.Rect([ box.left+4, box.top+4 ],\n              //                      [ box.width-8, box.height-8])\n              //     ).fill(color).stroke(null)\n              // );\n              // let's draw a checkmark instead.  artistic, eh?\n              group.append(new Path().stroke(color, 1.2).moveTo(box.left + 0.22 * box.width, box.top + 0.55 * box.height).lineTo(box.left + 0.45 * box.width, box.top + 0.75 * box.height).lineTo(box.left + 0.78 * box.width, box.top + 0.22 * box.width));\n            }\n          } else {\n            group.append(new Circle(new Circle$2([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 2, box.height - 2) / 2)).stroke(color, 1));\n\n            if (element.checked) {\n              group.append(new Circle(new Circle$2([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 8, box.height - 8) / 2)).fill(color).stroke(null));\n            }\n          }\n        }\n\n        function renderFormField(element, group) {\n          var tag = element.tagName.toLowerCase();\n\n          if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n            return renderCheckbox(element, group);\n          }\n\n          var p = element.parentNode;\n          var doc = element.ownerDocument;\n          var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n          var option;\n          el.style.cssText = getCssText(getComputedStyle$1(element));\n\n          if (tag == \"input\") {\n            el.style.whiteSpace = \"pre\";\n          }\n\n          if (tag == \"select\" || tag == \"textarea\") {\n            el.style.overflow = \"auto\";\n          }\n\n          if (tag == \"select\") {\n            if (element.multiple) {\n              for (var i = 0; i < element.options.length; ++i) {\n                option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n                option.style.cssText = getCssText(getComputedStyle$1(element.options[i]));\n                option.style.display = \"block\"; // IE9 messes up without this\n\n                option.textContent = element.options[i].textContent;\n                el.appendChild(option);\n              }\n            } else {\n              option = getSelectedOption(element);\n\n              if (option) {\n                el.textContent = option.textContent;\n              }\n            }\n          } else {\n            el.textContent = element.value;\n          }\n\n          p.insertBefore(el, element);\n          el.scrollLeft = element.scrollLeft;\n          el.scrollTop = element.scrollTop; // must temporarily hide the original element, otherwise it\n          // may affect layout of the fake element we want to render.\n\n          element.style.display = \"none\";\n          renderContents(el, group);\n          element.style.display = \"\";\n          p.removeChild(el);\n        }\n\n        function serializeSVG(element) {\n          var serializer = new window.XMLSerializer();\n          var xml = serializer.serializeToString(element);\n\n          if (browser.mozilla && !(element.getAttribute(\"width\") && element.getAttribute(\"height\"))) {\n            var doc = new window.DOMParser().parseFromString(xml, \"image/svg+xml\");\n            var svg$$1 = doc.documentElement;\n            var box = getContentBox(element);\n            svg$$1.setAttribute(\"width\", box.width);\n            svg$$1.setAttribute(\"height\", box.height);\n            xml = serializer.serializeToString(svg$$1);\n          }\n\n          return xml;\n        }\n\n        function renderContents(element, group) {\n          if (nodeInfo._stackingContext.element === element) {\n            // the group that was set in pushNodeInfo might have\n            // changed due to clipping/transforms, update it here.\n            nodeInfo._stackingContext.group = group;\n          }\n\n          switch (element.tagName.toLowerCase()) {\n            case \"img\":\n              renderImage(element, element.src, group);\n              break;\n\n            case \"svg\":\n              var xml = serializeSVG(element);\n              var dataURL = \"data:image/svg+xml;base64,\" + encodeBase64(xml);\n              renderImage(element, dataURL, group);\n              break;\n\n            case \"canvas\":\n              try {\n                renderImage(element, element.toDataURL(\"image/png\"), group);\n              } catch (ex) {// tainted; can't draw it, ignore.\n              }\n\n              break;\n\n            case \"textarea\":\n            case \"input\":\n            case \"select\":\n              renderFormField(element, group);\n              break;\n\n            default:\n              var children = [],\n                  floats = [],\n                  positioned = [];\n\n              for (var i = element.firstChild; i; i = i.nextSibling) {\n                switch (i.nodeType) {\n                  case 3:\n                    // Text\n                    if (/\\S/.test(i.data)) {\n                      renderText(element, i, group);\n                    }\n\n                    break;\n\n                  case 1:\n                    // Element\n                    var style = getComputedStyle$1(i);\n                    var floating = getPropertyValue(style, \"float\");\n                    var position = getPropertyValue(style, \"position\");\n\n                    if (position != \"static\") {\n                      positioned.push(i);\n                    } else if (floating != \"none\") {\n                      floats.push(i);\n                    } else {\n                      children.push(i);\n                    }\n\n                    break;\n                }\n              }\n\n              mergeSort(children, zIndexSort).forEach(function (el) {\n                renderElement(el, group);\n              });\n              mergeSort(floats, zIndexSort).forEach(function (el) {\n                renderElement(el, group);\n              });\n              mergeSort(positioned, zIndexSort).forEach(function (el) {\n                renderElement(el, group);\n              });\n          }\n        }\n\n        function renderText(element, node, group) {\n          if (emptyClipbox()) {\n            return;\n          }\n\n          var style = getComputedStyle$1(element);\n\n          if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\n            // assume it should not be displayed.  the slider's\n            // draggable handle displays a Drag text for some reason,\n            // having text-indent: -3333px.\n            return;\n          }\n\n          var text = node.data;\n          var start = 0;\n          var end = text.search(/\\S\\s*$/) + 1;\n\n          if (!end) {\n            return; // whitespace-only node\n          }\n\n          var fontSize = getPropertyValue(style, \"font-size\");\n          var lineHeight = getPropertyValue(style, \"line-height\"); // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\n\n          var font = [getPropertyValue(style, \"font-style\"), getPropertyValue(style, \"font-variant\"), getPropertyValue(style, \"font-weight\"), fontSize, // no need for line height here; it breaks layout in FF\n          getPropertyValue(style, \"font-family\")].join(\" \");\n          fontSize = parseFloat(fontSize);\n          lineHeight = parseFloat(lineHeight);\n\n          if (fontSize === 0) {\n            return;\n          }\n\n          var color = getPropertyValue(style, \"color\");\n          var range = element.ownerDocument.createRange();\n          var align$$1 = getPropertyValue(style, \"text-align\");\n          var isJustified = align$$1 == \"justify\";\n          var columnCount = getPropertyValue(style, \"column-count\", 1);\n          var whiteSpace = getPropertyValue(style, \"white-space\");\n          var textTransform = getPropertyValue(style, \"text-transform\"); // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n          // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\n          // seems to be a good option.\n\n          var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n\n          if (estimateLineLength === 0) {\n            estimateLineLength = 500;\n          } // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\n          // https://github.com/telerik/kendo/issues/5740\n\n\n          var prevLineBottom = null;\n          var underline = nodeInfo[\"underline\"];\n          var lineThrough = nodeInfo[\"line-through\"];\n          var overline = nodeInfo[\"overline\"];\n          var hasDecoration = underline || lineThrough || overline; // doChunk returns true when all text has been rendered\n\n          while (!doChunk()) {}\n\n          if (hasDecoration) {\n            range.selectNode(node);\n            slice$1$1(range.getClientRects()).forEach(decorate);\n          }\n\n          return; // only function declarations after this line\n\n          function actuallyGetRangeBoundingRect(range) {\n            // XXX: to be revised when this Chrome bug is fixed:\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n            if (microsoft || browser.chrome || browser.safari) {\n              // Workaround browser bugs: IE and Chrome would sometimes\n              // return 0 or 1-width rectangles before or after the main\n              // one.  https://github.com/telerik/kendo/issues/4674\n              // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n              // full character, making it hard to tell whether it's a bogus rectangle or valid\n              // selection location.  The workaround is to ignore rectangles that fall on the\n              // previous line.  https://github.com/telerik/kendo/issues/5740\n              var rectangles = range.getClientRects(),\n                  box = {\n                top: Infinity,\n                right: -Infinity,\n                bottom: -Infinity,\n                left: Infinity\n              },\n                  done = false;\n\n              for (var i = 0; i < rectangles.length; ++i) {\n                var b = rectangles[i];\n\n                if (b.width <= 1 || b.bottom === prevLineBottom) {\n                  continue; // bogus rectangle\n                }\n\n                box.left = Math.min(b.left, box.left);\n                box.top = Math.min(b.top, box.top);\n                box.right = Math.max(b.right, box.right);\n                box.bottom = Math.max(b.bottom, box.bottom);\n                done = true;\n              }\n\n              if (!done) {\n                return range.getBoundingClientRect();\n              }\n\n              box.width = box.right - box.left;\n              box.height = box.bottom - box.top;\n              return box;\n            }\n\n            return range.getBoundingClientRect();\n          } // Render a chunk of text, typically one line (but for justified text we render each word as\n          // a separate Text object, because spacing is variable).  Returns true when it finished the\n          // current node.  After each chunk it updates `start` to just after the last rendered\n          // character.\n\n\n          function doChunk() {\n            var origStart = start;\n            var box,\n                pos = text.substr(start).search(/\\S/);\n            start += pos;\n\n            if (pos < 0 || start >= end) {\n              return true;\n            } // Select a single character to determine the height of a line of text.  The box.bottom\n            // will be essential for us to figure out where the next line begins.\n\n\n            range.setStart(node, start);\n            range.setEnd(node, start + 1);\n            box = actuallyGetRangeBoundingRect(range); // for justified text we must split at each space, because space has variable width.\n\n            var found = false;\n\n            if (isJustified || columnCount > 1) {\n              pos = text.substr(start).search(/\\s/);\n\n              if (pos >= 0) {\n                // we can only split there if it's on the same line, otherwise we'll fall back\n                // to the default mechanism (see findEOL below).\n                range.setEnd(node, start + pos);\n                var r = actuallyGetRangeBoundingRect(range);\n\n                if (r.bottom == box.bottom) {\n                  box = r;\n                  found = true;\n                  start += pos;\n                }\n              }\n            }\n\n            if (!found) {\n              // This code does three things: (1) it selects one line of text in `range`, (2) it\n              // leaves the bounding rect of that line in `box` and (3) it returns the position\n              // just after the EOL.  We know where the line starts (`start`) but we don't know\n              // where it ends.  To figure this out, we select a piece of text and look at the\n              // bottom of the bounding box.  If it changes, we have more than one line selected\n              // and should retry with a smaller selection.\n              //\n              // To speed things up, we first try to select all text in the node (`start` ->\n              // `end`).  If there's more than one line there, then select only half of it.  And\n              // so on.  When we find a value for `end` that fits in one line, we try increasing\n              // it (also in halves) until we get to the next line.  The algorithm stops when the\n              // right side of the bounding box does not change.\n              //\n              // One more thing to note is that everything happens in a single Text DOM node.\n              // There's no other tags inside it, therefore the left/top coordinates of the\n              // bounding box will not change.\n              pos = function findEOL(min, eol, max) {\n                range.setEnd(node, eol);\n                var r = actuallyGetRangeBoundingRect(range);\n\n                if (r.bottom != box.bottom && min < eol) {\n                  return findEOL(min, min + eol >> 1, eol);\n                } else if (r.right != box.right) {\n                  box = r;\n\n                  if (eol < max) {\n                    return findEOL(eol, eol + max >> 1, max);\n                  } else {\n                    return eol;\n                  }\n                } else {\n                  return eol;\n                }\n              }(start, Math.min(end, start + estimateLineLength), end);\n\n              if (pos == start) {\n                // if EOL is at the start, then no more text fits on this line.  Skip the\n                // remainder of this node entirely to avoid a stack overflow.\n                return true;\n              }\n\n              start = pos;\n              pos = range.toString().search(/\\s+$/);\n\n              if (pos === 0) {\n                return false; // whitespace only; we should not get here.\n              }\n\n              if (pos > 0) {\n                // eliminate trailing whitespace\n                range.setEnd(node, range.startOffset + pos);\n                box = actuallyGetRangeBoundingRect(range);\n              }\n            } // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\n            // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n            // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n\n\n            if (microsoft) {\n              box = range.getClientRects()[0];\n            }\n\n            var str = range.toString();\n\n            if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n              // node with non-significant space -- collapse whitespace.\n              str = str.replace(/\\s+/g, \" \");\n            } else if (/\\t/.test(str)) {\n              // with significant whitespace we need to do something about literal TAB characters.\n              // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\n              // and the whole text will stretch to fill the original width.  The core PDF lib\n              // does not have sufficient context to deal with it.\n              // calculate the starting column here, since we initially discarded any whitespace.\n              var cc = 0;\n\n              for (pos = origStart; pos < range.startOffset; ++pos) {\n                var code = text.charCodeAt(pos);\n\n                if (code == 9) {\n                  // when we meet a TAB we must round up to the next tab stop.\n                  // in all browsers TABs seem to be 8 characters.\n                  cc += 8 - cc % 8;\n                } else if (code == 10 || code == 13) {\n                  // just in case we meet a newline we must restart.\n                  cc = 0;\n                } else {\n                  // ordinary character --> advance one column\n                  cc++;\n                }\n              } // based on starting column, replace any TAB characters in the string we actually\n              // have to display with spaces so that they align to columns multiple of 8.\n\n\n              while ((pos = str.search(\"\\t\")) >= 0) {\n                var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\n                str = str.substr(0, pos) + indent + str.substr(pos + 1);\n              }\n            }\n\n            if (!found) {\n              prevLineBottom = box.bottom;\n            }\n\n            drawText(str, box);\n          }\n\n          function drawText(str, box) {\n            // In IE the box height will be approximately lineHeight, while in\n            // other browsers it'll (correctly) be the height of the bounding\n            // box for the current text/font.  Which is to say, IE sucks again.\n            // The only good solution I can think of is to measure the text\n            // ourselves and center the bounding box.\n            if (microsoft && !isNaN(lineHeight)) {\n              var height = getFontHeight(font);\n              var top = (box.top + box.bottom - height) / 2;\n              box = {\n                top: top,\n                right: box.right,\n                bottom: top + height,\n                left: box.left,\n                height: height,\n                width: box.right - box.left\n              };\n            } // var path = new Path({ stroke: { color: \"red\" }});\n            // path.moveTo(box.left, box.top)\n            //     .lineTo(box.right, box.top)\n            //     .lineTo(box.right, box.bottom)\n            //     .lineTo(box.left, box.bottom)\n            //     .close();\n            // group.append(path);\n\n\n            switch (textTransform) {\n              case \"uppercase\":\n                str = str.toUpperCase();\n                break;\n\n              case \"lowercase\":\n                str = str.toLowerCase();\n                break;\n\n              case \"capitalize\":\n                str = str.replace(/(?:^|\\s)\\S/g, function (l) {\n                  return l.toUpperCase();\n                });\n                break;\n            }\n\n            var text = new TextRect(str, new Rect([box.left, box.top], [box.width, box.height]), {\n              font: font,\n              fill: {\n                color: color\n              }\n            });\n            group.append(text);\n          }\n\n          function decorate(box) {\n            line(underline, box.bottom);\n            line(lineThrough, box.bottom - box.height / 2.7);\n            line(overline, box.top);\n\n            function line(color, ypos) {\n              if (color) {\n                var width = fontSize / 12;\n                var path = new Path({\n                  stroke: {\n                    width: width,\n                    color: color\n                  }\n                });\n                ypos -= width;\n                path.moveTo(box.left, ypos).lineTo(box.right, ypos);\n                group.append(path);\n              }\n            }\n          }\n        }\n\n        function groupInStackingContext(element, group, zIndex) {\n          var main;\n\n          if (zIndex != \"auto\") {\n            // use the current stacking context\n            main = nodeInfo._stackingContext.group;\n            zIndex = parseFloat(zIndex);\n          } else {\n            // normal flow  use given container.  we still have to\n            // figure out where should we insert this element with the\n            // assumption that its z-index is zero, as the group might\n            // already contain elements with higher z-index.\n            main = group;\n            zIndex = 0;\n          }\n\n          var a = main.children;\n\n          for (var i = 0; i < a.length; ++i) {\n            if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n              break;\n            }\n          }\n\n          var tmp = new Group();\n          main.insert(i, tmp);\n          tmp._dom_zIndex = zIndex;\n\n          if (main !== group) {\n            // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\n            // console.log(a.slice(i+1));\n            // if (nodeInfo._matrix) {\n            //     tmp.transform(nodeInfo._matrix);\n            // }\n            if (nodeInfo._clipbox) {\n              var m = nodeInfo._matrix.invert();\n\n              var r = nodeInfo._clipbox.transformCopy(m);\n\n              setClipping(tmp, Path.fromRect(r)); // console.log(r);\n              // tmp.append(Path.fromRect(r));\n              // tmp.append(new Text(element.className || element.id, r.topLeft()));\n            }\n          }\n\n          return tmp;\n        }\n\n        function renderElement(element, container) {\n          var style = getComputedStyle$1(element);\n          updateCounters(style);\n\n          if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {\n            return;\n          }\n\n          if (nodeInfo._clipbox == null) {\n            return;\n          }\n\n          var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\n          var visibility = getPropertyValue(style, \"visibility\");\n          var display = getPropertyValue(style, \"display\");\n\n          if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\n            return;\n          }\n\n          var tr = getTransform(style);\n          var group;\n          var zIndex = getPropertyValue(style, \"z-index\");\n\n          if ((tr || opacity < 1) && zIndex == \"auto\") {\n            zIndex = 0;\n          }\n\n          group = groupInStackingContext(element, container, zIndex); // XXX: remove at some point\n          // group._pdfElement = element;\n          // group.options._pdfDebug = \"\";\n          // if (element.id) {\n          //     group.options._pdfDebug = \"#\" + element.id;\n          // }\n          // if (element.className) {\n          //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\n          // }\n\n          if (opacity < 1) {\n            group.opacity(opacity * group.opacity());\n          }\n\n          pushNodeInfo(element, style, group);\n\n          if (!tr) {\n            _renderWithPseudoElements(element, group);\n          } else {\n            saveStyle(element, function () {\n              // must clear transform, so getBoundingClientRect returns correct values.\n              pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\"); // must also clear transitions, so correct values are returned *immediately*\n\n              pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\"); // the presence of any transform makes it behave like it had position: relative,\n              // because why not.\n              // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n\n              if (getPropertyValue(style, \"position\") == \"static\") {\n                // but only if it's not already positioned. :-/\n                pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\n              } // must translate to origin before applying the CSS\n              // transformation, then translate back.\n\n\n              var bbox = element.getBoundingClientRect();\n              var x = bbox.left + tr.origin[0];\n              var y = bbox.top + tr.origin[1];\n              var m = [1, 0, 0, 1, -x, -y];\n              m = mmul(m, tr.matrix);\n              m = mmul(m, [1, 0, 0, 1, x, y]);\n              m = setTransform$1(group, m);\n              nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n\n              _renderWithPseudoElements(element, group);\n            });\n          }\n\n          popNodeInfo(); //drawDebugBox(element.getBoundingClientRect(), container);\n        } // function drawDebugBox(box, group, color) {\n        //     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n        //     if (color) {\n        //         path.stroke(color);\n        //     }\n        //     group.append(path);\n        // }\n        // function dumpTextNode(node) {\n        //     var txt = node.data.replace(/^\\s+/, \"\");\n        //     if (txt.length < 100) {\n        //         console.log(node.data.length + \": |\" + txt);\n        //     } else {\n        //         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\n        //     }\n        // }\n\n\n        function mmul(a, b) {\n          var a1 = a[0],\n              b1 = a[1],\n              c1 = a[2],\n              d1 = a[3],\n              e1 = a[4],\n              f1 = a[5];\n          var a2 = b[0],\n              b2 = b[1],\n              c2 = b[2],\n              d2 = b[3],\n              e2 = b[4],\n              f2 = b[5];\n          return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];\n        }\n\n        var drawing = {\n          svg: svg$1,\n          canvas: canvas,\n          util: util,\n          HasObservers: HasObservers,\n          PathParser: PathParser,\n          parsePath: parsePath,\n          BaseNode: BaseNode,\n          OptionsStore: OptionsStore,\n          Surface: Surface,\n          SurfaceFactory: SurfaceFactory,\n          exportImage: exportImage,\n          exportSVG: exportSVG,\n          QuadNode: QuadNode,\n          ShapesQuadTree: ShapesQuadTree,\n          Element: Element$1,\n          Circle: Circle,\n          Arc: Arc,\n          Path: Path,\n          MultiPath: MultiPath,\n          Text: Text,\n          Image: Image$1,\n          Group: Group,\n          Layout: Layout,\n          Rect: Rect$2,\n          align: align,\n          vAlign: vAlign,\n          stack: stack,\n          vStack: vStack,\n          wrap: wrap,\n          vWrap: vWrap,\n          fit: fit,\n          LinearGradient: LinearGradient,\n          RadialGradient: RadialGradient,\n          GradientStop: GradientStop,\n          Gradient: Gradient,\n          Animation: Animation,\n          AnimationFactory: AnimationFactory,\n          drawDOM: drawDOM,\n          drawText: drawText,\n          getFontFaces: getFontFaces\n        };\n        kendo.deepExtend(kendo, {\n          drawing: drawing,\n          geometry: geometry\n        });\n        kendo.drawing.Segment = kendo.geometry.Segment;\n        kendo.dataviz.drawing = kendo.drawing;\n        kendo.dataviz.geometry = kendo.geometry;\n        kendo.drawing.util.measureText = kendo.util.measureText;\n        kendo.drawing.util.objectKey = kendo.util.objectKey;\n        kendo.drawing.Color = kendo.Color;\n        kendo.util.encodeBase64 = kendo.drawing.util.encodeBase64;\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  956:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./util\");\n    /***/\n  },\n\n  /***/\n  957:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.color\");\n    /***/\n  },\n\n  /***/\n  958:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../util/text-metrics\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}