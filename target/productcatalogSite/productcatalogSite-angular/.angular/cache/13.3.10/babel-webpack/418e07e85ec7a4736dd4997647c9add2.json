{"ast":null,"code":"/**-----------------------------------------------------------------------------------------\n* Copyright © 2021 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, Component, Input, Output, HostListener, Directive, forwardRef, ViewContainerRef, ContentChildren, ViewChild, ViewChildren, HostBinding, ElementRef, NgModule } from '@angular/core';\nimport * as i1 from '@progress/kendo-angular-l10n';\nimport { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { take, filter, takeUntil } from 'rxjs/operators';\nimport * as i6 from '@progress/kendo-angular-common';\nimport { Keys, isDocumentAvailable, ResizeSensorModule } from '@progress/kendo-angular-common';\nimport { Subject, Subscription, merge, fromEvent } from 'rxjs';\nimport * as i2 from '@progress/kendo-angular-popup';\nimport { PopupModule } from '@progress/kendo-angular-popup';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@progress/kendo-angular-buttons';\nimport { DropDownButtonComponent, ButtonsModule } from '@progress/kendo-angular-buttons';\n/**\n * @hidden\n */\n\nfunction ToolBarRendererComponent_ng_container_0_ng_template_1_Template(rf, ctx) {}\n\nfunction ToolBarRendererComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ToolBarRendererComponent_ng_container_0_ng_template_1_Template, 0, 0, \"ng-template\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template);\n  }\n}\n\nfunction ToolBarRendererComponent_ng_container_1_ng_template_1_Template(rf, ctx) {}\n\nfunction ToolBarRendererComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ToolBarRendererComponent_ng_container_1_ng_template_1_Template, 0, 0, \"ng-template\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.template);\n  }\n}\n\nconst _c0 = [\"overflowButton\"];\nconst _c1 = [\"popupTemplate\"];\nconst _c2 = [\"resizeSensor\"];\nconst _c3 = [\"container\"];\nconst _c4 = [\"toolbarRenderer\"];\nconst _c5 = [\"overflowRenderer\"];\n\nfunction ToolBarComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"kendo-toolbar-renderer\", 6, 7);\n    i0.ɵɵlistener(\"rendererClick\", function ToolBarComponent_ng_container_1_Template_kendo_toolbar_renderer_rendererClick_1_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.onRendererClick($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tool_r6 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"location\", \"toolbar\")(\"resizable\", ctx_r0.overflow)(\"tool\", tool_r6);\n  }\n}\n\nfunction ToolBarComponent_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 8, 9);\n    i0.ɵɵlistener(\"click\", function ToolBarComponent_button_2_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.showPopup();\n    });\n    i0.ɵɵelement(2, \"span\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\");\n    i0.ɵɵproperty(\"title\", ctx_r1.moreToolsTitle);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.moreToolsTitle);\n  }\n}\n\nfunction ToolBarComponent_ng_template_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"li\", 12)(2, \"kendo-toolbar-renderer\", 6, 13);\n    i0.ɵɵlistener(\"rendererClick\", function ToolBarComponent_ng_template_3_ng_container_1_Template_kendo_toolbar_renderer_rendererClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return ctx_r18.onRendererClick($event);\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tool_r15 = ctx.$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"location\", \"overflow\")(\"resizable\", ctx_r14.overflow)(\"tool\", tool_r15);\n  }\n}\n\nfunction ToolBarComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ul\", 11);\n    i0.ɵɵtemplate(1, ToolBarComponent_ng_template_3_ng_container_1_Template, 4, 3, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.allTools);\n  }\n}\n\nfunction ToolBarComponent_kendo_resize_sensor_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"kendo-resize-sensor\", null, 14);\n  }\n}\n\nconst _c8 = [\"toolbarTemplate\"];\nconst _c9 = [\"toolbarButton\"];\n\nfunction ToolBarButtonComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 2, 3);\n    i0.ɵɵlistener(\"click\", function ToolBarButtonComponent_ng_template_0_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.click.emit($event);\n    })(\"pointerdown\", function ToolBarButtonComponent_ng_template_0_Template_button_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.pointerdown.emit($event);\n    })(\"selectedChange\", function ToolBarButtonComponent_ng_template_0_Template_button_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.selectedChange.emit($event);\n    })(\"blur\", function ToolBarButtonComponent_ng_template_0_Template_button_blur_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.onBlur();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabindex\", ctx_r1.tabIndex)(\"ngStyle\", ctx_r1.style)(\"ngClass\", ctx_r1.className)(\"disabled\", ctx_r1.disabled)(\"toggleable\", ctx_r1.toggleable)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null)(\"selected\", ctx_r1.selected)(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", ctx_r1.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.toolbarOptions.text, \" \");\n  }\n}\n\nfunction ToolBarButtonComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 4, 5);\n    i0.ɵɵlistener(\"click\", function ToolBarButtonComponent_ng_template_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.click.emit($event);\n    })(\"selectedChange\", function ToolBarButtonComponent_ng_template_2_Template_button_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.selectedChange.emit($event);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r3.style)(\"ngClass\", ctx_r3.className)(\"disabled\", ctx_r3.disabled)(\"toggleable\", ctx_r3.toggleable)(\"fillMode\", ctx_r3.fillMode)(\"themeColor\", ctx_r3.fillMode ? ctx_r3.themeColor : null)(\"selected\", ctx_r3.selected)(\"icon\", ctx_r3.overflowOptions.icon)(\"iconClass\", ctx_r3.overflowOptions.iconClass)(\"imageUrl\", ctx_r3.overflowOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", ctx_r3.title);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.overflowOptions.text, \" \");\n  }\n}\n\nconst _c10 = [\"toolbarButtonGroup\"];\nconst _c11 = [\"overflowButtonGroup\"];\n\nfunction ToolBarButtonGroupComponent_ng_template_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵlistener(\"click\", function ToolBarButtonGroupComponent_ng_template_0_span_2_Template_span_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const button_r6 = restoredCtx.$implicit;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      button_r6.click.emit($event);\n      return ctx_r7.onButtonClick($event);\n    })(\"pointerdown\", function ToolBarButtonGroupComponent_ng_template_0_span_2_Template_span_pointerdown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const button_r6 = restoredCtx.$implicit;\n      return button_r6.pointerdown.emit($event);\n    })(\"selectedChange\", function ToolBarButtonGroupComponent_ng_template_0_span_2_Template_span_selectedChange_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const button_r6 = restoredCtx.$implicit;\n      const ctx_r10 = i0.ɵɵnextContext(2);\n      return ctx_r10.selectedChangeHandler($event, button_r6);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const button_r6 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", button_r6.style)(\"ngClass\", button_r6.className)(\"disabled\", button_r6.disabled)(\"togglable\", button_r6.togglable)(\"selected\", button_r6.selected)(\"fillMode\", button_r6.fillMode)(\"themeColor\", button_r6.fillMode ? button_r6.themeColor : null)(\"icon\", button_r6.toolbarOptions.icon)(\"iconClass\", button_r6.toolbarOptions.iconClass)(\"imageUrl\", button_r6.toolbarOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", button_r6.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", button_r6.toolbarOptions.text, \" \");\n  }\n}\n\nfunction ToolBarButtonGroupComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-buttongroup\", 2, 3);\n    i0.ɵɵlistener(\"navigate\", function ToolBarButtonGroupComponent_ng_template_0_Template_kendo_buttongroup_navigate_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.onNavigate($event);\n    })(\"focus\", function ToolBarButtonGroupComponent_ng_template_0_Template_kendo_buttongroup_focus_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.onFocus();\n    });\n    i0.ɵɵtemplate(2, ToolBarButtonGroupComponent_ng_template_0_span_2_Template, 2, 12, \"span\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabIndex\", -1)(\"selection\", ctx_r1.selection)(\"disabled\", ctx_r1.disabled)(\"width\", ctx_r1.width);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.buttonComponents);\n  }\n}\n\nfunction ToolBarButtonGroupComponent_ng_template_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵlistener(\"click\", function ToolBarButtonGroupComponent_ng_template_2_span_2_Template_span_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r18);\n      const button_r16 = restoredCtx.$implicit;\n      const ctx_r17 = i0.ɵɵnextContext(2);\n      button_r16.click.emit($event);\n      return ctx_r17.onButtonClick($event);\n    })(\"selectedChange\", function ToolBarButtonGroupComponent_ng_template_2_span_2_Template_span_selectedChange_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r18);\n      const button_r16 = restoredCtx.$implicit;\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.selectedChangeHandler($event, button_r16);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const button_r16 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", button_r16.style)(\"ngClass\", button_r16.className)(\"disabled\", button_r16.disabled)(\"togglable\", button_r16.togglable)(\"selected\", button_r16.selected)(\"fillMode\", button_r16.fillMode)(\"themeColor\", button_r16.fillMode ? button_r16.themeColor : null)(\"icon\", button_r16.overflowOptions.icon)(\"iconClass\", button_r16.overflowOptions.iconClass)(\"imageUrl\", button_r16.overflowOptions.imageUrl);\n    i0.ɵɵattribute(\"title\", button_r16.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", button_r16.overflowOptions.text, \" \");\n  }\n}\n\nfunction ToolBarButtonGroupComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"kendo-buttongroup\", 6, 7);\n    i0.ɵɵtemplate(2, ToolBarButtonGroupComponent_ng_template_2_span_2_Template, 2, 12, \"span\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabIndex\", -1)(\"selection\", ctx_r3.selection)(\"disabled\", ctx_r3.disabled)(\"width\", ctx_r3.width);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.buttonComponents);\n  }\n}\n\nconst _c12 = [\"button\"];\n\nfunction ToolBarButtonListComponent_button_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 1, 2);\n    i0.ɵɵlistener(\"click\", function ToolBarButtonListComponent_button_0_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r5);\n      const item_r1 = restoredCtx.$implicit;\n      const i_r2 = restoredCtx.index;\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.onClick(item_r1, i_r2);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"disabled\", ctx_r0.disabled || item_r1.disabled)(\"icon\", item_r1.icon)(\"iconClass\", item_r1.iconClass)(\"imageUrl\", item_r1.imageUrl)(\"fillMode\", ctx_r0.fillMode)(\"themeColor\", ctx_r0.fillMode ? ctx_r0.themeColor : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.getText(item_r1), \" \");\n  }\n}\n\nconst _c13 = [\"dropdownButton\"];\nconst _c14 = [\"toolbarDropDownButton\"];\nconst _c15 = [\"overflowDropDownButtonButtonList\"];\n\nfunction ToolBarDropDownButtonComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-dropdownbutton\", 2, 3);\n    i0.ɵɵlistener(\"open\", function ToolBarDropDownButtonComponent_ng_template_0_Template_kendo_dropdownbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.open.emit($event);\n    })(\"close\", function ToolBarDropDownButtonComponent_ng_template_0_Template_kendo_dropdownbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.close.emit($event);\n    })(\"itemClick\", function ToolBarDropDownButtonComponent_ng_template_0_Template_kendo_dropdownbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.itemClick.emit($event);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl)(\"buttonClass\", ctx_r1.buttonClass)(\"disabled\", ctx_r1.disabled)(\"tabIndex\", -1)(\"data\", ctx_r1.data)(\"textField\", ctx_r1.textField)(\"popupSettings\", ctx_r1.popupSettings)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.toolbarOptions.text, \" \");\n  }\n}\n\nfunction ToolBarDropDownButtonComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 4);\n    i0.ɵɵlistener(\"click\", function ToolBarDropDownButtonComponent_ng_template_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.itemClick.emit($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"kendo-toolbar-buttonlist\", 5, 6);\n    i0.ɵɵlistener(\"itemClick\", function ToolBarDropDownButtonComponent_ng_template_2_Template_kendo_toolbar_buttonlist_itemClick_2_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.itemClick.emit($event);\n    })(\"click\", function ToolBarDropDownButtonComponent_ng_template_2_Template_kendo_toolbar_buttonlist_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.onButtonListClick($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"disabled\", true)(\"icon\", ctx_r3.overflowOptions.icon)(\"iconClass\", ctx_r3.overflowOptions.iconClass)(\"imageUrl\", ctx_r3.overflowOptions.imageUrl)(\"ngClass\", ctx_r3.buttonClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.overflowOptions.text, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", ctx_r3.data)(\"disabled\", ctx_r3.disabled)(\"textField\", ctx_r3.textField);\n  }\n}\n\nconst _c16 = [\"toolbarSplitButton\"];\nconst _c17 = [\"overflowSplitButton\"];\nconst _c18 = [\"overflowSplitButtonButtonList\"];\n\nfunction ToolBarSplitButtonComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"kendo-splitbutton\", 2, 3);\n    i0.ɵɵlistener(\"buttonClick\", function ToolBarSplitButtonComponent_ng_template_0_Template_kendo_splitbutton_buttonClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.buttonClick.emit($event);\n    })(\"open\", function ToolBarSplitButtonComponent_ng_template_0_Template_kendo_splitbutton_open_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.open.emit($event);\n    })(\"close\", function ToolBarSplitButtonComponent_ng_template_0_Template_kendo_splitbutton_close_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.close.emit($event);\n    })(\"itemClick\", function ToolBarSplitButtonComponent_ng_template_0_Template_kendo_splitbutton_itemClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.itemClick.emit($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"data\", ctx_r1.data)(\"text\", ctx_r1.toolbarOptions.text)(\"icon\", ctx_r1.toolbarOptions.icon)(\"iconClass\", ctx_r1.toolbarOptions.iconClass)(\"imageUrl\", ctx_r1.toolbarOptions.imageUrl)(\"buttonClass\", ctx_r1.buttonClass)(\"arrowButtonClass\", ctx_r1.arrowButtonClass)(\"arrowButtonIcon\", ctx_r1.arrowButtonIcon)(\"disabled\", ctx_r1.disabled)(\"tabIndex\", -1)(\"textField\", ctx_r1.textField)(\"popupSettings\", ctx_r1.popupSettings)(\"fillMode\", ctx_r1.fillMode)(\"themeColor\", ctx_r1.fillMode ? ctx_r1.themeColor : null);\n  }\n}\n\nfunction ToolBarSplitButtonComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 4, 5);\n    i0.ɵɵlistener(\"click\", function ToolBarSplitButtonComponent_ng_template_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.onMainButtonClick($event);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"kendo-toolbar-buttonlist\", 6, 7);\n    i0.ɵɵlistener(\"itemClick\", function ToolBarSplitButtonComponent_ng_template_2_Template_kendo_toolbar_buttonlist_itemClick_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.itemClick.emit($event);\n    })(\"click\", function ToolBarSplitButtonComponent_ng_template_2_Template_kendo_toolbar_buttonlist_click_3_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.onButtonListClick($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"fillMode\", ctx_r3.fillMode)(\"themeColor\", ctx_r3.fillMode ? ctx_r3.themeColor : null)(\"disabled\", ctx_r3.disabled)(\"icon\", ctx_r3.overflowOptions.icon)(\"iconClass\", ctx_r3.overflowOptions.iconClass)(\"imageUrl\", ctx_r3.overflowOptions.imageUrl)(\"ngClass\", ctx_r3.buttonClass);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.overflowOptions.text, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", ctx_r3.data)(\"disabled\", ctx_r3.disabled)(\"fillMode\", ctx_r3.fillMode)(\"themeColor\", ctx_r3.fillMode ? ctx_r3.themeColor : null)(\"textField\", ctx_r3.textField);\n  }\n}\n\nconst _c19 = [\"separator\"];\n\nfunction ToolBarSeparatorComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 1);\n  }\n}\n\nconst packageMetadata = {\n  name: '@progress/kendo-angular-toolbar',\n  productName: 'Kendo UI for Angular',\n  productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n  publishDate: 1654755194,\n  version: '',\n  licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\n/**\n * @hidden\n */\n\nlet RefreshService = /*#__PURE__*/(() => {\n  class RefreshService {\n    constructor() {\n      this.onRefresh = new EventEmitter();\n    }\n\n    refresh(tool) {\n      this.onRefresh.emit(tool);\n    }\n\n  }\n\n  RefreshService.ɵfac = function RefreshService_Factory(t) {\n    return new (t || RefreshService)();\n  };\n\n  RefreshService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RefreshService,\n    factory: RefreshService.ɵfac\n  });\n  return RefreshService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst focusableRegex = /^(?:a|input|select|textarea|button|object)$/i;\n/**\n * @hidden\n */\n\nfunction outerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseFloat(style.marginLeft) || 0 + parseFloat(style.marginRight) || 0;\n  return width;\n}\n/**\n * @hidden\n */\n\n\nfunction innerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width -= parseFloat(style.paddingLeft) || 0 + parseFloat(style.borderLeftWidth) || 0;\n  width -= parseFloat(style.paddingRight) || 0 + parseFloat(style.borderRightWidth) || 0;\n  return width;\n}\n/**\n * @hidden\n */\n\n\nfunction outerHeight(element) {\n  var width = element.offsetHeight;\n  var style = getComputedStyle(element);\n  width += parseFloat(style.marginTop) || 0 + parseFloat(style.marginBottom) || 0;\n  return width;\n}\n/**\n * @hidden\n */\n\n\nconst closest = (node, predicate) => {\n  while (node && !predicate(node)) {\n    node = node.parentNode;\n  }\n\n  return node;\n};\n/**\n * @hidden\n */\n\n\nconst isVisible = element => {\n  const rect = element.getBoundingClientRect();\n  const hasSize = rect.width > 0 && rect.height > 0;\n  const hasPosition = rect.x !== 0 && rect.y !== 0; // Elements can have zero size due to styling, but they should still count as visible.\n  // For example, the selection checkbox has no size, but is made visible through styling.\n\n  return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\n/**\n * @hidden\n */\n\n\nconst findElement = (node, predicate, matchSelf = true) => {\n  if (!node) {\n    return;\n  }\n\n  if (matchSelf && predicate(node)) {\n    return node;\n  }\n\n  node = node.firstChild;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const element = findElement(node, predicate);\n\n      if (element) {\n        return element;\n      }\n    }\n\n    node = node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst isFocusable = (element, checkVisibility = true) => {\n  if (element.tagName) {\n    const tagName = element.tagName.toLowerCase();\n    const tabIndex = element.getAttribute('tabIndex');\n    let focusable = tabIndex !== null;\n\n    if (focusableRegex.test(tagName)) {\n      focusable = !element.disabled;\n    }\n\n    return focusable && (!checkVisibility || isVisible(element));\n  }\n\n  return false;\n};\n/**\n * @hidden\n */\n\n\nconst findFocusable = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusable(node, checkVisibility));\n};\n/**\n * @hidden\n */\n\n\nconst findFocusableChild = (element, checkVisibility = true) => {\n  return findElement(element, node => isFocusable(node, checkVisibility), false);\n};\n/**\n * @hidden\n */\n\n\nconst findFocusableSibling = (element, checkVisibility = true, reverse) => {\n  let node = reverse ? element.prevSibling : element.nextSibling;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      const result = findElement(node, el => isFocusable(el, checkVisibility));\n\n      if (result) {\n        return result;\n      }\n    }\n\n    node = reverse ? node.prevSibling : node.nextSibling;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst isPresent = value => value !== null && value !== undefined;\n/**\n * @hidden\n */\n\n\nconst makePeeker = collection => index => isPresent(collection[index]);\n/**\n * @hidden\n */\n\n\nconst getIndexOfFocused = (prevKeyCode, nextKeyCode, collection) => ev => {\n  switch (ev.type) {\n    case 'keydown':\n      if (ev.keyCode === prevKeyCode) {\n        return collection.length - 1;\n      }\n\n      if (ev.keyCode === nextKeyCode) {\n        return 0;\n      }\n\n      break;\n\n    case 'click':\n      return collection.findIndex(be => be === ev.target || be.contains(ev.target));\n\n    case 'focus':\n      return 0;\n\n    default:\n      return 0;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst seekFocusedIndex = (prevKeyCode, nextKeyCode, seeker) => (startIndex, ev) => {\n  switch (ev.keyCode) {\n    case prevKeyCode:\n      return seeker(startIndex - 1) ? startIndex - 1 : startIndex;\n\n    case nextKeyCode:\n      return seeker(startIndex + 1) ? startIndex + 1 : startIndex;\n\n    default:\n      return startIndex;\n  }\n};\n/**\n * @hidden\n */\n\n\nconst areEqual = first => second => first === second;\n/**\n * @hidden\n */\n\n\nconst getNextKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowDown : rtl ? Keys.ArrowLeft : Keys.ArrowRight;\n/**\n * @hidden\n */\n\n\nconst getPrevKey = (rtl = false) => (overflows = true) => overflows ? Keys.ArrowUp : rtl ? Keys.ArrowRight : Keys.ArrowLeft;\n/**\n * @hidden\n */\n\n\nconst getValueForLocation = (property, displayMode, overflows) => {\n  switch (displayMode) {\n    case 'toolbar':\n      return overflows ? undefined : property;\n\n    case 'overflow':\n      return overflows ? property : undefined;\n\n    default:\n      return property;\n  }\n};\n/**\n * @hidden\n */\n\n\nlet NavigationService = /*#__PURE__*/(() => {\n  class NavigationService {\n    constructor(zone) {\n      this.zone = zone;\n      this.focused = {\n        renderedTool: null,\n        index: -1\n      };\n      this.renderedTools = [];\n      this.isPopupFocused = false;\n      this.isOverflowButtonFocused = false;\n    }\n\n    setRenderedTools(rts) {\n      this.renderedTools = [...rts];\n    }\n\n    click({\n      context,\n      event: ev\n    }) {\n      if (this.focused.renderedTool !== context && ev) {\n        this.focus(context, ev);\n      }\n    }\n\n    moveFocusToToolBar() {\n      this.isPopupFocused = false;\n      this.focusOverflowButton();\n    }\n\n    moveFocusToPopup() {\n      this.isPopupFocused = true;\n      this.blurOverflowButton();\n      this.focus();\n    }\n\n    focusNext(ev) {\n      if (!this.isOverflowButtonFocused && this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {\n        const nextRT = this.getFocusableTools().slice(this.focused.index + 1)[0];\n\n        if (nextRT) {\n          this.focus(nextRT, ev);\n        } else {\n          if (this.isOverflowButtonVisible() && !this.isPopupFocused) {\n            this.focusOverflowButton();\n          }\n        }\n      }\n    }\n\n    focusPrev(ev) {\n      if (this.isOverflowButtonFocused) {\n        const lastFocusableRT = this.getFocusableTools().reverse()[0];\n        this.focus(lastFocusableRT, ev);\n      } else if (this.focused.renderedTool && !this.focused.renderedTool.tool.handleKey(ev)) {\n        const prevRT = this.getFocusableTools().slice(0, this.focused.index).reverse()[0];\n\n        if (prevRT) {\n          this.focus(prevRT, ev);\n        }\n      }\n    }\n\n    resetNavigation() {\n      this.blurOverflowButton();\n      this.focused.renderedTool = null;\n      this.focused.index = -1;\n    }\n\n    focusFirst(ev) {\n      const firstTool = this.getFocusableTools()[0];\n      const overFlowButton = this.overflowButton;\n\n      if (firstTool) {\n        this.focused.renderedTool = firstTool;\n        this.focused.index = this.getFocusableTools().findIndex(rt => rt === firstTool);\n        this.focus(firstTool, ev);\n      } else if (overFlowButton) {\n        overFlowButton.nativeElement.focus();\n      }\n    }\n\n    getFocusableTools() {\n      return this.renderedTools.filter(rt => rt.tool.overflows === this.isPopupFocused && rt.tool.canFocus());\n    }\n\n    focus(renderedTool, ev) {\n      // running the code below in onStable fixes issue #2939\n      this.zone.onStable.pipe(take(1)).subscribe(() => {\n        if (!renderedTool) {\n          const focusableRTs = this.getFocusableTools();\n          const lastFocusedRT = focusableRTs.find(rt => rt === this.focused.renderedTool) || focusableRTs[0]; // guard against only disabled tools\n\n          if (lastFocusedRT) {\n            this.focused.renderedTool = lastFocusedRT;\n            this.focused.index = this.getFocusableTools().findIndex(rt => rt === lastFocusedRT); // if event is undefined, then this means that the tool is the first one in the overflow popup\n\n            lastFocusedRT.tool.focus(ev);\n          }\n        } else if (renderedTool.tool.canFocus && renderedTool.tool.canFocus()) {\n          this.focused.renderedTool = renderedTool;\n          this.focused.index = this.getFocusableTools().findIndex(rt => rt === renderedTool);\n          renderedTool.tool.focus(ev);\n          this.blurOverflowButton();\n        }\n      });\n    }\n\n    blurOverflowButton() {\n      if (this.overflowButton) {\n        this.isOverflowButtonFocused = false;\n        this.overflowButton.nativeElement.tabIndex = -1;\n      }\n    }\n\n    focusOverflowButton() {\n      this.isOverflowButtonFocused = true;\n      this.overflowButton.nativeElement.tabIndex = 0;\n      this.overflowButton.nativeElement.focus();\n    }\n\n    isOverflowButtonVisible() {\n      return isPresent(this.overflowButton) && window.getComputedStyle(this.overflowButton.nativeElement).getPropertyValue('visibility') === 'visible';\n    }\n\n  }\n\n  NavigationService.ɵfac = function NavigationService_Factory(t) {\n    return new (t || NavigationService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  NavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationService,\n    factory: NavigationService.ɵfac\n  });\n  return NavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the Base ToolBar Tool component for Angular.\n * Extend this class to create custom tools.\n */\n\n\nlet ToolBarToolComponent = /*#__PURE__*/(() => {\n  class ToolBarToolComponent {\n    constructor() {\n      this.tabIndex = -1; //Focus movement inside the toolbar is managed using roving tabindex.\n\n      this.overflows = true; // this should be replaced with showTool: DisplayMode = 'both';\n\n      /**\n       * @hidden\n       */\n\n      this.responsive = true;\n    }\n\n    get toolbarDisplay() {\n      return this.overflows ? 'none' : 'inline-block';\n    }\n\n    get overflowDisplay() {\n      return this.overflows ? 'block' : 'none';\n    }\n    /**\n     * Determines if the tool can be focused.\n     * If the returned value is `false`, the tool will not be part of the keyboard navigation.\n     * @returns `true` if the tool should take part in keyboard navigation.\n     */\n\n\n    canFocus() {\n      return false;\n    }\n    /**\n     * Called when the tool is focused.\n     * The method accepts as argument the original browser event, which can be a `KeyboardEvent`, `MouseEvent` or `FocusEvent`.\n     * @param {Event} ev - This is the event that caused the tool to be focused.\n     */\n    // @ts-ignore\n\n\n    focus(ev) {\n      /* noop */\n    }\n    /**\n     * Called when the tool is focused and one of the arrow keys is pressed.\n     * The returned boolean value determines whether the `ToolBarComponent` will move the focus to the next/previous `ToolBarToolComponent`\n     * ([see example]({% slug customcontroltypes_toolbar %}#toc-adding-keyboard-navigation)).\n     * @param {KeyboardEvent} ev - The last pressed arrow key\n     * @returns\n     */\n    // @ts-ignore\n\n\n    handleKey(ev) {\n      return false;\n    }\n\n  }\n\n  ToolBarToolComponent.ɵfac = function ToolBarToolComponent_Factory(t) {\n    return new (t || ToolBarToolComponent)();\n  };\n\n  ToolBarToolComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarToolComponent,\n    selectors: [[\"toolbar-tool\"]],\n    inputs: {\n      responsive: \"responsive\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function ToolBarToolComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ToolBarToolComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass PreventableEvent {\n  constructor() {\n    this.prevented = false;\n  }\n  /**\n   * Prevents the default action for a specified event.\n   * In this way, the source component suppresses the built-in behavior that follows the event.\n   */\n\n\n  preventDefault() {\n    this.prevented = true;\n  }\n  /**\n   * If the event is prevented by any of its subscribers, returns `true`.\n   *\n   * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n   */\n\n\n  isDefaultPrevented() {\n    return this.prevented;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst defaultPopupWidth = '150px';\n/**\n * @hidden\n */\n\nlet RendererService = /*#__PURE__*/(() => {\n  class RendererService {\n    getElement() {\n      return this.element.nativeElement;\n    }\n\n    querySelector(selector) {\n      return this.element.nativeElement.querySelector(selector);\n    }\n\n    querySelectorAll(selector) {\n      return this.element.nativeElement.querySelectorAll(selector);\n    }\n\n    findFocusable() {\n      return findFocusable(this.element.nativeElement, false);\n    }\n\n    findFocusableChild(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n\n      return findFocusableChild(element, false);\n    }\n\n    findNextFocusableSibling(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n\n      return findFocusableSibling(element, false);\n    }\n\n    findPrevFocusableSibling(element) {\n      if (!element) {\n        element = this.findFocusable();\n      }\n\n      return findFocusableSibling(element, false, true);\n    }\n\n    setAttribute(element, attr, value) {\n      this.renderer.setAttribute(element, attr, value);\n    }\n\n  }\n\n  RendererService.ɵfac = function RendererService_Factory(t) {\n    return new (t || RendererService)();\n  };\n\n  RendererService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RendererService,\n    factory: RendererService.ɵfac\n  });\n  return RendererService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ToolBarRendererComponent = /*#__PURE__*/(() => {\n  class ToolBarRendererComponent {\n    constructor(element, renderer, rendererService, refreshService) {\n      this.element = element;\n      this.renderer = renderer;\n      this.rendererService = rendererService;\n      this.refreshService = refreshService;\n      this.rendererClick = new EventEmitter();\n      this.rendererService.element = element;\n      this.rendererService.renderer = this;\n      this.refreshSubscription = this.refreshService.onRefresh.subscribe(tool => {\n        if (this.tool === tool) {\n          this.refresh();\n        }\n      });\n    }\n\n    onClick(ev) {\n      this.rendererClick.emit({\n        context: this,\n        event: ev\n      });\n    }\n\n    ngOnInit() {\n      if (this.resizable) {\n        if (this.location === 'toolbar') {\n          this.template = this.tool.toolbarTemplate;\n          this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          this.renderer.setStyle(this.element.nativeElement, 'display', 'none');\n        } else {\n          this.template = this.tool.popupTemplate;\n          this.renderer.setStyle(this.element.nativeElement, 'display', 'none');\n        }\n      } else {\n        this.tool.overflows = false;\n        this.template = this.tool.toolbarTemplate;\n        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'display');\n        this.renderer.setStyle(this.element.nativeElement, 'display', 'inline-block');\n      }\n    }\n\n    ngOnDestroy() {\n      this.refreshSubscription.unsubscribe();\n    }\n\n    ngAfterViewInit() {\n      if (this.resizable) {\n        this.refresh();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get width() {\n      return this.tool.overflows ? 0 : outerWidth(this.element.nativeElement);\n    }\n    /**\n     * @hidden\n     */\n\n\n    isDisplayed() {\n      return this.element.nativeElement.style.display !== 'none';\n    }\n    /**\n     * @hidden\n     */\n\n\n    refresh() {\n      if (this.resizable) {\n        if (this.location === 'toolbar') {\n          this.renderer.setStyle(this.element.nativeElement, 'visibility', this.tool.visibility);\n          this.renderer.setStyle(this.element.nativeElement, 'display', this.tool.toolbarDisplay);\n        } else {\n          this.renderer.setStyle(this.element.nativeElement, 'display', this.tool.overflowDisplay);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    setAttribute(element, attr, value) {\n      this.renderer.setAttribute(element, attr, value);\n    }\n\n  }\n\n  ToolBarRendererComponent.ɵfac = function ToolBarRendererComponent_Factory(t) {\n    return new (t || ToolBarRendererComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(RendererService), i0.ɵɵdirectiveInject(RefreshService));\n  };\n\n  ToolBarRendererComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarRendererComponent,\n    selectors: [[\"kendo-toolbar-renderer\"]],\n    hostBindings: function ToolBarRendererComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ToolBarRendererComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      tool: \"tool\",\n      location: \"location\",\n      resizable: \"resizable\"\n    },\n    outputs: {\n      rendererClick: \"rendererClick\"\n    },\n    exportAs: [\"kendoToolBarRenderer\"],\n    features: [i0.ɵɵProvidersFeature([RendererService])],\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\"]],\n    template: function ToolBarRendererComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarRendererComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, ToolBarRendererComponent_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.location === \"toolbar\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.location === \"overflow\" && ctx.tool.responsive);\n      }\n    },\n    directives: [i3.NgIf, i3.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return ToolBarRendererComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ToolbarMessages = /*#__PURE__*/(() => {\n  class ToolbarMessages extends ComponentMessages {}\n\n  ToolbarMessages.ɵfac = /* @__PURE__ */function () {\n    let ɵToolbarMessages_BaseFactory;\n    return function ToolbarMessages_Factory(t) {\n      return (ɵToolbarMessages_BaseFactory || (ɵToolbarMessages_BaseFactory = i0.ɵɵgetInheritedFactory(ToolbarMessages)))(t || ToolbarMessages);\n    };\n  }();\n\n  ToolbarMessages.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ToolbarMessages,\n    selectors: [[\"kendo-toolbar-messages-base\"]],\n    inputs: {\n      moreToolsTitle: \"moreToolsTitle\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return ToolbarMessages;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet LocalizedToolbarMessagesDirective = /*#__PURE__*/(() => {\n  class LocalizedToolbarMessagesDirective extends ToolbarMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n  }\n\n  LocalizedToolbarMessagesDirective.ɵfac = function LocalizedToolbarMessagesDirective_Factory(t) {\n    return new (t || LocalizedToolbarMessagesDirective)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  LocalizedToolbarMessagesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LocalizedToolbarMessagesDirective,\n    selectors: [[\"\", \"kendoToolbarLocalizedMessages\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolbarMessages,\n      useExisting: forwardRef(() => LocalizedToolbarMessagesDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return LocalizedToolbarMessagesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst getInitialPopupSettings = isRtl => ({\n  animate: true,\n  anchorAlign: {\n    horizontal: isRtl ? 'left' : 'right',\n    vertical: 'bottom'\n  },\n  popupAlign: {\n    horizontal: isRtl ? 'left' : 'right',\n    vertical: 'top'\n  }\n});\n/**\n * Represents the [Kendo UI ToolBar component for Angular]({% slug overview_toolbar %}).\n */\n\n\nlet ToolBarComponent = /*#__PURE__*/(() => {\n  class ToolBarComponent {\n    constructor(localization, popupService, refreshService, navigationService, element, zone, renderer, _cdr) {\n      this.localization = localization;\n      this.popupService = popupService;\n      this.refreshService = refreshService;\n      this.navigationService = navigationService;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this._cdr = _cdr;\n      /**\n       * Hides the overflowing tools in a popup.\n       */\n\n      this.overflow = false;\n      /**\n       * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the ToolBar.\n       */\n\n      this.tabindex = 0;\n      /**\n       * Fires when the overflow popup of the ToolBar is opened.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires when the overflow popup of the ToolBar is closed.\n       */\n\n      this.close = new EventEmitter();\n      this.hostClasses = true;\n      this.cancelRenderedToolsSubscription$ = new Subject();\n      this.subscriptions = new Subscription();\n      this.popupSubs = new Subscription();\n      validatePackage(packageMetadata);\n      this.direction = localization.rtl ? 'rtl' : 'ltr';\n    }\n    /**\n     * @hidden\n     */\n\n\n    set resizable(value) {\n      this.overflow = value;\n    }\n\n    get resizable() {\n      return this.overflow;\n    }\n    /**\n     * Configures the popup of the ToolBar drop-down list.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({}, getInitialPopupSettings(this.localization.rtl), settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings || getInitialPopupSettings(this.localization.rtl);\n    }\n    /**\n     * @hidden\n     */\n\n\n    set tabIndex(tabIndex) {\n      this.tabindex = tabIndex;\n    }\n\n    get tabIndex() {\n      return this.tabindex;\n    }\n\n    get appendTo() {\n      const {\n        appendTo\n      } = this.popupSettings;\n\n      if (!appendTo || appendTo === 'root') {\n        return undefined;\n      }\n\n      return appendTo === 'component' ? this.container : appendTo;\n    }\n\n    set popupOpen(open) {\n      if (this.popupOpen === open) {\n        return;\n      }\n\n      const eventArgs = new PreventableEvent();\n\n      if (open) {\n        this.open.emit(eventArgs);\n      } else {\n        this.close.emit(eventArgs);\n      }\n\n      if (eventArgs.isDefaultPrevented()) {\n        return;\n      }\n\n      this.toggle(open);\n    }\n\n    get popupOpen() {\n      return this._open;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFocus(ev) {\n      this.navigationService.resetNavigation();\n      this.navigationService.focusFirst(ev); // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n\n      this.element.nativeElement.setAttribute('tabindex', '-1');\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFocusOut(event) {\n      // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n      if (closest(event.relatedTarget, el => el === this.element.nativeElement)) {\n        this.element.nativeElement.setAttribute('tabindex', '-1');\n        return;\n      }\n\n      this.element.nativeElement.setAttribute('tabindex', this.tabindex.toString());\n    }\n\n    get getRole() {\n      return 'toolbar';\n    }\n\n    get getDir() {\n      return this.direction;\n    }\n\n    get resizableClass() {\n      return this.overflow;\n    }\n\n    ngAfterViewInit() {\n      const element = this.element.nativeElement;\n\n      if (!element.getAttribute('tabindex')) {\n        this.element.nativeElement.setAttribute('tabindex', '0');\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.toolbarKeydownListener = this.renderer.listen(this.element.nativeElement, 'keydown', ev => {\n          switch (ev.keyCode) {\n            case Keys.ArrowLeft:\n              this.zone.run(() => {\n                ev.preventDefault();\n\n                if (this.direction === 'ltr') {\n                  this.navigationService.focusPrev(ev);\n                } else {\n                  this.navigationService.focusNext(ev);\n                } // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n\n\n                this.element.nativeElement.setAttribute('tabindex', '-1');\n              });\n              break;\n\n            case Keys.ArrowRight:\n              this.zone.run(() => {\n                ev.preventDefault();\n\n                if (this.direction === 'ltr') {\n                  this.navigationService.focusNext(ev);\n                } else {\n                  this.navigationService.focusPrev(ev);\n                } // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n\n\n                this.element.nativeElement.setAttribute('tabindex', '-1');\n              });\n              break;\n\n            case Keys.Tab:\n              this.zone.run(() => this.navigationService.resetNavigation());\n              break;\n\n            case Keys.Escape:\n              this.zone.run(() => this.toggle(false));\n              break;\n\n            default:\n              break;\n          }\n        });\n      });\n\n      if (this.overflow) {\n        this.subscriptions.add(merge(this.resizeSensor.resize, this.renderedTools.changes).subscribe(() => {\n          this.onResize();\n        })); // because of https://github.com/telerik/kendo-angular-buttons/pull/276\n        // calling onResize twice is the trade-off for removing the manual ChangeDetection\n        // triggering altogether - it ensures correct layout and calculations\n        // when some tools need overflow on initial rendering\n\n        this.zone.runOutsideAngular(() => setTimeout(() => {\n          this.onResize();\n          this.onResize();\n        }));\n        this.navigationService.overflowButton = this.overflowButton;\n      }\n\n      this.navigationService.setRenderedTools(this.renderedTools.toArray());\n      this.subscriptions.add(this.renderedTools.changes.subscribe(rts => this.navigationService.setRenderedTools(rts.toArray())));\n    }\n\n    ngOnInit() {\n      this.subscriptions.add(this.localization.changes.subscribe(({\n        rtl\n      }) => this.direction = rtl ? 'rtl' : 'ltr'));\n\n      if (isDocumentAvailable()) {\n        this.zone.runOutsideAngular(() => this.subscriptions.add(fromEvent(document, 'click').pipe(filter(() => !!this.popupRef), filter(ev => !this.popupRef.popup.instance.container.nativeElement.contains(ev.target)), filter(ev => !this.overflowButton.nativeElement.contains(ev.target))).subscribe(() => {\n          this.zone.run(() => {\n            this.popupOpen = false;\n          });\n        })));\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.tabindex) {\n        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously\n        this.element.nativeElement.setAttribute('tabindex', changes.tabindex.currentValue.toString());\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyPopup();\n\n      if (this.toolbarKeydownListener) {\n        this.toolbarKeydownListener();\n      }\n\n      this.cancelRenderedToolsSubscription$.next();\n      this.subscriptions.unsubscribe();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get moreToolsTitle() {\n      return this.localization.get('moreToolsTitle');\n    }\n    /**\n     * @hidden\n     */\n\n\n    get cdr() {\n      return this._cdr;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onRendererClick(data) {\n      this.navigationService.click(data);\n      this.element.nativeElement.setAttribute('tabindex', '-1');\n    }\n    /**\n     * @hidden\n     */\n\n\n    showPopup() {\n      this.popupOpen = !this.popupOpen;\n      this.navigationService.click({\n        context: undefined,\n        event: undefined\n      });\n    }\n    /**\n     * Toggles the visibility of the overflow popup.\n     */\n\n\n    toggle(popupOpen) {\n      this._open = popupOpen !== undefined ? popupOpen : !this.popupOpen;\n\n      if (this.popupRef) {\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n\n      if (this.popupOpen) {\n        this.popupRef = this.popupService.open({\n          anchor: this.overflowButton,\n          anchorAlign: this.popupSettings.anchorAlign,\n          popupAlign: this.popupSettings.popupAlign,\n          content: this.popupTemplate,\n          appendTo: this.appendTo,\n          animate: this.popupSettings.animate,\n          popupClass: this.popupSettings.popupClass,\n          positionMode: 'absolute'\n        });\n        this.setPopupContentDimensions();\n        this.popupSubs.add(this.popupRef.popupOpen.subscribe(this.onPopupOpen.bind(this)));\n        this.popupSubs.add(this.popupRef.popupClose.subscribe(this.onPopupClose.bind(this)));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onResize() {\n      if (isDocumentAvailable()) {\n        const containerWidth = innerWidth(this.element.nativeElement) - this.overflowAnchorWidth;\n        this.shrink(containerWidth, this.childrenWidth);\n        this.stretch(containerWidth, this.childrenWidth);\n        this.displayAnchor();\n        this.resizeSensor.acceptSize();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPopupOpen() {\n      this.zone.runOutsideAngular(() => {\n        this.overflowKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', ev => {\n          switch (ev.keyCode) {\n            case Keys.ArrowUp:\n              this.zone.run(() => {\n                ev.preventDefault();\n                this.navigationService.focusPrev(ev);\n              });\n              break;\n\n            case Keys.ArrowDown:\n              this.zone.run(() => {\n                ev.preventDefault();\n                this.navigationService.focusNext(ev);\n              });\n              break;\n\n            case Keys.Escape:\n              this.zone.run(() => this.toggle(false));\n              break;\n\n            case Keys.Tab:\n              this.zone.run(() => {\n                this.toggle(false);\n                this.navigationService.resetNavigation();\n              });\n              break;\n\n            default:\n              break;\n          }\n        });\n      });\n      this.cancelRenderedToolsSubscription$.next();\n      this.navigationService.moveFocusToPopup();\n      this.navigationService.setRenderedTools(this.overflowRenderedTools.toArray());\n      this.overflowRenderedTools.changes.pipe(takeUntil(this.cancelRenderedToolsSubscription$)).subscribe(rts => this.navigationService.setRenderedTools(rts.toArray()));\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPopupClose() {\n      this.cancelRenderedToolsSubscription$.next();\n      this.navigationService.setRenderedTools(this.renderedTools.toArray());\n      this.renderedTools.changes.pipe(takeUntil(this.cancelRenderedToolsSubscription$)).subscribe(rts => this.navigationService.setRenderedTools(rts.toArray()));\n      this.navigationService.moveFocusToToolBar();\n\n      if (this.overflowKeydownListener) {\n        this.overflowKeydownListener();\n      }\n    }\n\n    displayAnchor() {\n      const visibility = this.allTools.filter(t => t.overflows && t.responsive).length > 0 ? 'visible' : 'hidden';\n      this.renderer.setStyle(this.overflowButton.nativeElement, 'visibility', visibility);\n    }\n\n    get popupWidth() {\n      if (!this.popupSettings || !this.popupSettings.width) {\n        return defaultPopupWidth;\n      }\n\n      return isNaN(this.popupSettings.width) ? this.popupSettings.width : `${this.popupSettings.width}px`;\n    }\n\n    get popupHeight() {\n      if (!this.popupSettings || !this.popupSettings.height) {\n        return;\n      }\n\n      return isNaN(this.popupSettings.height) ? this.popupSettings.height : `${this.popupSettings.height}px`;\n    }\n\n    get overflowAnchorWidth() {\n      if (!this.overflow) {\n        return 0;\n      }\n\n      if (!this.cachedOverflowAnchorWidth) {\n        this.cachedOverflowAnchorWidth = outerWidth(this.overflowButton.nativeElement);\n      }\n\n      return this.cachedOverflowAnchorWidth;\n    }\n\n    get gap() {\n      if (isPresent(this.cachedGap)) {\n        return this.cachedGap;\n      }\n\n      const computedGap = getComputedStyle(this.element.nativeElement).gap;\n      this.cachedGap = isPresent(computedGap) ? parseInt(computedGap, 10) : 0;\n      return this.cachedGap;\n    }\n\n    get childrenWidth() {\n      const width = this.renderedTools.reduce((totalWidth, tool) => tool.width + totalWidth + (tool.isDisplayed() ? this.gap : 0), 0);\n      return Math.ceil(width);\n    }\n\n    get visibleTools() {\n      return this.allTools.filter(tool => {\n        return tool.overflows === false;\n      });\n    }\n\n    get overflowTools() {\n      return this.allTools.filter(tool => {\n        return tool.overflows === true;\n      });\n    }\n\n    shrink(containerWidth, childrenWidth) {\n      let width;\n\n      if (containerWidth < childrenWidth) {\n        for (var i = this.visibleTools.length - 1; i >= 0; i--) {\n          if (containerWidth > childrenWidth) {\n            break;\n          } else {\n            width = this.hideLastVisibleTool();\n            childrenWidth -= width;\n          }\n        }\n      }\n    }\n\n    stretch(containerWidth, childrenWidth) {\n      let width;\n\n      if (containerWidth > childrenWidth) {\n        for (var i = this.overflowTools.length - 1; i >= 0; i--) {\n          width = this.showFirstHiddenTool(containerWidth, childrenWidth);\n\n          if (width) {\n            childrenWidth += width;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n\n    hideLastVisibleTool() {\n      const tool = this.visibleTools[this.visibleTools.length - 1];\n      const renderedElement = this.renderedTools.find(r => {\n        return r.tool === tool;\n      });\n      const width = renderedElement.width;\n      tool.overflows = true;\n      this.refreshService.refresh(tool);\n      return width;\n    }\n\n    showFirstHiddenTool(containerWidth, childrenWidth) {\n      const tool = this.overflowTools[0];\n      const renderedElement = this.renderedTools.find(r => r.tool === tool);\n      tool.overflows = false;\n      tool.visibility = 'hidden';\n      this.refreshService.refresh(tool);\n\n      if (containerWidth > childrenWidth + renderedElement.width) {\n        tool.visibility = 'visible';\n        this.refreshService.refresh(tool);\n      } else {\n        tool.overflows = true;\n        this.refreshService.refresh(tool);\n      }\n\n      return renderedElement.width; // returns 0 if `overflows` is true\n    }\n\n    setPopupContentDimensions() {\n      const popupContentContainer = this.popupRef.popup.instance.contentContainer.nativeElement;\n      popupContentContainer.style.width = this.popupWidth;\n      popupContentContainer.style.height = this.popupHeight;\n      popupContentContainer.style.overflow = 'auto';\n    }\n\n    destroyPopup() {\n      if (this.popupRef) {\n        this.popupSubs.unsubscribe();\n        this.popupRef.close();\n        this.popupRef = null;\n      }\n    }\n\n  }\n\n  ToolBarComponent.ɵfac = function ToolBarComponent_Factory(t) {\n    return new (t || ToolBarComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService), i0.ɵɵdirectiveInject(i2.PopupService), i0.ɵɵdirectiveInject(RefreshService), i0.ɵɵdirectiveInject(NavigationService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  ToolBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarComponent,\n    selectors: [[\"kendo-toolbar\"]],\n    contentQueries: function ToolBarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ToolBarToolComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.allTools = _t);\n      }\n    },\n    viewQuery: function ToolBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 5);\n        i0.ɵɵviewQuery(_c3, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c4, 5);\n        i0.ɵɵviewQuery(_c5, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.renderedTools = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowRenderedTools = _t);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function ToolBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function ToolBarComponent_focus_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        })(\"focusout\", function ToolBarComponent_focusout_HostBindingHandler($event) {\n          return ctx.onFocusOut($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.getRole)(\"dir\", ctx.getDir);\n        i0.ɵɵclassProp(\"k-widget\", ctx.hostClasses)(\"k-toolbar\", ctx.hostClasses)(\"k-toolbar-resizable\", ctx.resizableClass);\n      }\n    },\n    inputs: {\n      overflow: \"overflow\",\n      resizable: \"resizable\",\n      popupSettings: \"popupSettings\",\n      tabindex: \"tabindex\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBar\"],\n    features: [i0.ɵɵProvidersFeature([RefreshService, NavigationService, LocalizationService, {\n      provide: L10N_PREFIX,\n      useValue: 'kendo.toolbar'\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 3,\n    consts: function () {\n      let i18n_6;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\n         * @desc The title of the **more tools** button in a responsive ToolBar\n         * @meaning kendo.toolbar.moreToolsTitle\n         */\n        const MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2015_KENDO_ANGULAR_TOOLBAR_JS_7 = goog.getMsg(\"More tools\");\n        i18n_6 = MSG_C__USERS_JBARRIT_DESKTOP_PBDEMOS_MIGRATION_TW_MIGRATEDSOLUTION_PRODUCTCATALOGSITE_PRODUCTCATALOGSITE_ANGULAR_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLBAR_FESM2015_KENDO_ANGULAR_TOOLBAR_JS_7;\n      } else {\n        i18n_6 = $localize`:kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar:More tools`;\n      }\n\n      return [[\"kendoToolbarLocalizedMessages\", \"\", \"moreToolsTitle\", i18n_6], [4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"tabindex\", \"-1\", \"class\", \"k-overflow-anchor k-button\", 3, \"title\", \"visibility\", \"click\", 4, \"ngIf\"], [\"popupTemplate\", \"\"], [\"container\", \"\"], [4, \"ngIf\"], [3, \"location\", \"resizable\", \"tool\", \"rendererClick\"], [\"toolbarRenderer\", \"\"], [\"type\", \"button\", \"tabindex\", \"-1\", 1, \"k-overflow-anchor\", \"k-button\", 3, \"title\", \"click\"], [\"overflowButton\", \"\"], [1, \"k-icon\", \"k-i-more-vertical\"], [1, \"k-overflow-container\", \"k-list-container\", \"k-reset\"], [1, \"k-item\"], [\"overflowRenderer\", \"\"], [\"resizeSensor\", \"\"]];\n    },\n    template: function ToolBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainer(0, 0);\n        i0.ɵɵtemplate(1, ToolBarComponent_ng_container_1_Template, 3, 3, \"ng-container\", 1);\n        i0.ɵɵtemplate(2, ToolBarComponent_button_2_Template, 3, 4, \"button\", 2);\n        i0.ɵɵtemplate(3, ToolBarComponent_ng_template_3_Template, 2, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainer(5, null, 4);\n        i0.ɵɵtemplate(7, ToolBarComponent_kendo_resize_sensor_7_Template, 2, 0, \"kendo-resize-sensor\", 5);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.allTools);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.overflow);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.overflow);\n      }\n    },\n    directives: [ToolBarRendererComponent, i6.ResizeSensorComponent, LocalizedToolbarMessagesDirective, i3.NgForOf, i3.NgIf],\n    encapsulation: 2\n  });\n  return ToolBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ToolBar Button tool for Angular]({% slug controltypes_toolbar %}#toc-buttons).\n */\n\n\nlet ToolBarButtonComponent = /*#__PURE__*/(() => {\n  class ToolBarButtonComponent extends ToolBarToolComponent {\n    constructor() {\n      super();\n      /**\n       * Specifies where button icon should be displayed\n       */\n\n      this.showIcon = 'both';\n      /**\n       * Provides visual styling that indicates if the Button is active\n       * ([see example]({% slug controltypes_toolbar %}#toc-toggle-buttons)).\n       * By default, `toggleable` is set to `false`.\n       */\n\n      this.toggleable = false;\n      /**\n       * Sets the selected state of the Button.\n       */\n\n      this.selected = false;\n      /**\n       * The fillMode property specifies the background and border styles of the Button.\n       *\n       * The available values are:\n       * * `solid` (default)\n       * * `flat`\n       * * `outline`\n       * * `link`\n       * * `null`\n       */\n\n      this.fillMode = 'solid';\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n\n      this.themeColor = 'base';\n      /**\n       * Fires each time the Button is clicked.\n       */\n\n      this.click = new EventEmitter();\n      /**\n       * Fires when the Button [pointerdown](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/pointerdown_event) event is triggered.\n       */\n\n      this.pointerdown = new EventEmitter();\n      /**\n       * Fires each time the selected state of a Toggle Button is changed.\n       * The event argument is the new selected state (Boolean).\n       */\n\n      this.selectedChange = new EventEmitter();\n      this.toolbarOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this.overflowOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this._showText = 'both';\n    } // showText and showIcon showIcon should be declared first\n\n    /**\n     * Specifies where button text should be displayed\n     */\n\n\n    set showText(value) {\n      this._showText = value;\n      this.setTextDisplayMode();\n    }\n\n    get showText() {\n      return this._showText;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get togglable() {\n      return this.toggleable;\n    }\n\n    set togglable(value) {\n      this.toggleable = value;\n    }\n    /**\n     * Defines the name for an existing icon in a Kendo UI theme\n     * ([see example]({% slug controltypes_toolbar %}#toc-buttons)).\n     * The icon is rendered inside the Button by a `span.k-icon` element.\n     */\n\n\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;\n     * which are applied to a `span` element inside the Button. Allows the usage of custom icons.\n     */\n\n\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines a URL which is used for an `img` element inside the Button.\n     * The URL can be relative or absolute. If relative, it is evaluated with relation to the web page URL.\n     */\n\n\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n\n    ngOnInit() {\n      this.setTextDisplayMode();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onBlur() {\n      this.getButton().tabIndex = -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus(ev) {\n      // guard against focusing twice on mousedown.\n      if (!ev || ev.type === 'focus' || ev.type === 'keydown') {\n        this.getButton().focus();\n      }\n\n      this.getButton().tabIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKey() {\n      this.getButton().tabIndex = -1;\n      return false;\n    }\n\n    getButton() {\n      return (this.overflows ? this.overflowButtonElement : this.toolbarButtonElement).nativeElement;\n    }\n\n    setTextDisplayMode() {\n      this.toolbarOptions.text = this.showText === 'overflow' ? undefined : this.text;\n      this.overflowOptions.text = this.showText === 'toolbar' ? undefined : this.text;\n    }\n\n  }\n\n  ToolBarButtonComponent.ɵfac = function ToolBarButtonComponent_Factory(t) {\n    return new (t || ToolBarButtonComponent)();\n  };\n\n  ToolBarButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarButtonComponent,\n    selectors: [[\"kendo-toolbar-button\"]],\n    viewQuery: function ToolBarButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c9, 5, ElementRef);\n        i0.ɵɵviewQuery(_c0, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarButtonElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowButtonElement = _t.first);\n      }\n    },\n    inputs: {\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      style: \"style\",\n      className: \"className\",\n      title: \"title\",\n      disabled: \"disabled\",\n      toggleable: \"toggleable\",\n      look: \"look\",\n      togglable: \"togglable\",\n      selected: \"selected\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\"\n    },\n    outputs: {\n      click: \"click\",\n      pointerdown: \"pointerdown\",\n      selectedChange: \"selectedChange\"\n    },\n    exportAs: [\"kendoToolBarButton\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => ToolBarButtonComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [\"type\", \"button\", \"kendoButton\", \"\", 3, \"tabindex\", \"ngStyle\", \"ngClass\", \"disabled\", \"toggleable\", \"fillMode\", \"themeColor\", \"selected\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\", \"blur\"], [\"toolbarButton\", \"\"], [\"tabindex\", \"-1\", \"type\", \"button\", \"kendoButton\", \"\", 1, \"k-overflow-button\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"toggleable\", \"fillMode\", \"themeColor\", \"selected\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"selectedChange\"], [\"overflowButton\", \"\"]],\n    template: function ToolBarButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarButtonComponent_ng_template_0_Template, 3, 13, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, ToolBarButtonComponent_ng_template_2_Template, 3, 12, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [i1$1.ButtonDirective, i3.NgStyle, i3.NgClass],\n    encapsulation: 2\n  });\n  return ToolBarButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the Kendo UI Toolbar ButtonGroup for Angular.\n */\n\n\nlet ToolBarButtonGroupComponent = /*#__PURE__*/(() => {\n  class ToolBarButtonGroupComponent extends ToolBarToolComponent {\n    constructor(localization) {\n      super();\n      this.localization = localization;\n      /**\n       * By default, the selection mode of the ButtonGroup is set to `multiple`.\n       */\n\n      this.selection = 'multiple';\n      this.focusedIndex = -1;\n      this.getNextKey = getNextKey(this.localization.rtl);\n      this.getPrevKey = getPrevKey(this.localization.rtl);\n    }\n    /**\n     * @hidden\n     */\n\n\n    set look(look) {\n      if (look) {\n        this.buttonComponents.forEach(b => b.fillMode = look === 'default' ? 'solid' : look);\n      }\n    }\n\n    get buttonElements() {\n      return this.getButtonGroup().buttons.filter(b => !b.isDisabled).map(b => b.element);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFocus() {\n      // triggered on tabin\n      this.focusedIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onNavigate(ev) {\n      ev.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectedChangeHandler(state, button) {\n      button.selected = state;\n      button.selectedChange.emit(state);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onButtonClick(ev) {\n      this.focusedIndex = this.buttonElements.findIndex(be => be === ev.target || be.contains(ev.target));\n      this.focusButton(this.focusedIndex, ev);\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return !(this.disabled || this.buttonElements.length === 0);\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus(ev = {}) {\n      const nextKey = this.getNextKey(this.overflows);\n      const prevKey = this.getPrevKey(this.overflows);\n      this.focusedIndex = getIndexOfFocused(prevKey, nextKey, this.buttonElements)(ev);\n      this.focusButton(this.focusedIndex, ev);\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKey(ev) {\n      const nextKey = this.getNextKey(this.overflows);\n      const prevKey = this.getPrevKey(this.overflows);\n      const peekAtIndex = makePeeker(this.buttonElements);\n      const isUnmodified = areEqual(this.focusedIndex);\n      this.focusedIndex = seekFocusedIndex(prevKey, nextKey, peekAtIndex)(this.focusedIndex, ev);\n      this.focusButton(this.focusedIndex, ev);\n      return !isUnmodified(this.focusedIndex);\n    }\n\n    getButtonGroup() {\n      return this.overflows ? this.overflowButtonGroup : this.toolbarButtonGroup;\n    }\n\n    focusButton(index, ev) {\n      // Guard against focusing twice on mousedown.\n      if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n        this.buttonElements[index].focus();\n      }\n    }\n\n  }\n\n  ToolBarButtonGroupComponent.ɵfac = function ToolBarButtonGroupComponent_Factory(t) {\n    return new (t || ToolBarButtonGroupComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ToolBarButtonGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarButtonGroupComponent,\n    selectors: [[\"kendo-toolbar-buttongroup\"]],\n    contentQueries: function ToolBarButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ToolBarButtonComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttonComponents = _t);\n      }\n    },\n    viewQuery: function ToolBarButtonGroupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c10, 5);\n        i0.ɵɵviewQuery(_c11, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowButtonGroup = _t.first);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      selection: \"selection\",\n      width: \"width\",\n      look: \"look\"\n    },\n    exportAs: [\"kendoToolBarButtonGroup\"],\n    features: [i0.ɵɵProvidersFeature([LocalizationService, {\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => ToolBarButtonGroupComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [3, \"tabIndex\", \"selection\", \"disabled\", \"width\", \"navigate\", \"focus\"], [\"toolbarButtonGroup\", \"\"], [\"kendoButton\", \"\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\", 4, \"ngFor\", \"ngForOf\"], [\"kendoButton\", \"\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"pointerdown\", \"selectedChange\"], [1, \"k-overflow-button\", 3, \"tabIndex\", \"selection\", \"disabled\", \"width\"], [\"overflowButtonGroup\", \"\"], [\"kendoButton\", \"\", \"class\", \"k-overflow-button\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"selectedChange\", 4, \"ngFor\", \"ngForOf\"], [\"kendoButton\", \"\", 1, \"k-overflow-button\", 3, \"ngStyle\", \"ngClass\", \"disabled\", \"togglable\", \"selected\", \"fillMode\", \"themeColor\", \"icon\", \"iconClass\", \"imageUrl\", \"click\", \"selectedChange\"]],\n    template: function ToolBarButtonGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarButtonGroupComponent_ng_template_0_Template, 3, 5, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, ToolBarButtonGroupComponent_ng_template_2_Template, 3, 5, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [i1$1.ButtonGroupComponent, i3.NgForOf, i1$1.ButtonDirective, i3.NgStyle, i3.NgClass],\n    encapsulation: 2\n  });\n  return ToolBarButtonGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet ToolBarButtonListComponent = /*#__PURE__*/(() => {\n  class ToolBarButtonListComponent {\n    constructor() {\n      this.disabled = false;\n      this.fillMode = 'solid';\n      this.themeColor = 'base';\n      this.itemClick = new EventEmitter();\n    }\n\n    getText(dataItem) {\n      if (dataItem) {\n        return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n      }\n\n      return undefined;\n    }\n\n    onClick(item, index) {\n      const dataItem = this.data[index];\n\n      if (item.click) {\n        item.click(dataItem);\n      }\n\n      this.itemClick.emit(dataItem);\n    }\n\n  }\n\n  ToolBarButtonListComponent.ɵfac = function ToolBarButtonListComponent_Factory(t) {\n    return new (t || ToolBarButtonListComponent)();\n  };\n\n  ToolBarButtonListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarButtonListComponent,\n    selectors: [[\"kendo-toolbar-buttonlist\"]],\n    viewQuery: function ToolBarButtonListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c12, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttons = _t);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      textField: \"textField\",\n      disabled: \"disabled\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\"\n    },\n    outputs: {\n      itemClick: \"itemClick\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[\"type\", \"button\", \"tabindex\", \"-1\", \"kendoButton\", \"\", \"style\", \"padding-left: 16px\", \"class\", \"k-overflow-button\", 3, \"disabled\", \"icon\", \"iconClass\", \"imageUrl\", \"fillMode\", \"themeColor\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"tabindex\", \"-1\", \"kendoButton\", \"\", 1, \"k-overflow-button\", 2, \"padding-left\", \"16px\", 3, \"disabled\", \"icon\", \"iconClass\", \"imageUrl\", \"fillMode\", \"themeColor\", \"click\"], [\"button\", \"\"]],\n    template: function ToolBarButtonListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarButtonListComponent_button_0_Template, 3, 7, \"button\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    directives: [i3.NgForOf, i1$1.ButtonDirective],\n    encapsulation: 2\n  });\n  return ToolBarButtonListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ToolBar DropDownButton for Angular]({% slug controltypes_toolbar %}#toc-dropdownbuttons).\n */\n\n\nlet ToolBarDropDownButtonComponent = /*#__PURE__*/(() => {\n  class ToolBarDropDownButtonComponent extends ToolBarToolComponent {\n    constructor() {\n      super(); // showText and showIcon showIcon should be declared first\n\n      /**\n       * Defines the location of the button text that will be displayed.\n       */\n\n      this.showText = 'both';\n      /**\n       * Defines the location of the button icon that will be displayed.\n       */\n\n      this.showIcon = 'both';\n      /**\n       * The fillMode property specifies the background and border styles of the Button.\n       *\n       * The available values are:\n       * * `solid` (default)\n       * * `flat`\n       * * `outline`\n       * * `link`\n       * * `null`\n       */\n\n      this.fillMode = 'solid';\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly\n       * ([see example]({% slug api_buttons_dropdownbuttoncomponent %}#toc-themeColor)).\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n\n      this.themeColor = 'base';\n      /**\n       * Fires each time the user clicks a DropDownButton item.\n       * The event data contains the data item that is bound to the clicked list item.\n       */\n\n      this.itemClick = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      this.toolbarOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this.overflowOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this._popupSettings = {\n        animate: true,\n        popupClass: ''\n      };\n      this.focusedIndex = -1;\n      this.getNextKey = getNextKey();\n      this.getPrevKey = getPrevKey();\n    }\n    /**\n     * Sets the text of the DropDownButton\n     * ([see example]({% slug controltypes_toolbar %}#toc-dropdownbuttons).\n     */\n\n\n    set text(text) {\n      this.toolbarOptions.text = getValueForLocation(text, this.showText, false);\n      this.overflowOptions.text = getValueForLocation(text, this.showText, true);\n    }\n    /**\n     * Defines an icon that will be rendered next to the button text.\n     */\n\n\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an icon with a custom CSS class that will be rendered next to the button text.\n     */\n\n\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines the location of an image that will be displayed next to the button text.\n     */\n\n\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n    /**\n     * Configures the popup of the DropDownButton.\n     *\n     * The available options are:\n     * - `animate:Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass:String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(settings) {\n      this._popupSettings = Object.assign({\n        animate: true,\n        popupClass: ''\n      }, settings);\n    }\n\n    get popupSettings() {\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    set primary(primary) {\n      this.themeColor = primary ? 'primary' : 'base';\n    }\n    /**\n     * Sets the data of the DropDownButton\n     * ([see example]({% slug controltypes_toolbar %}#toc-dropdownbuttons)).\n     *\n     * > The data has to be provided in an array-like list.\n     */\n\n\n    set data(data) {\n      this._data = data || [];\n    }\n\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n\n      return this._data;\n    }\n\n    get overflowButtons() {\n      return [...this.overflowDropDownButtonButtonList.buttons.toArray().filter(b => !b.nativeElement.disabled)];\n    }\n    /**\n     * @hidden\n     */\n\n\n    onButtonListClick(ev) {\n      this.focusedIndex = this.overflowDropDownButtonButtonList.buttons.toArray().findIndex(b => b.nativeElement.contains(ev.target));\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus(ev = {}) {\n      if (!this.overflows) {\n        if (ev.type === 'focus' || ev.type === 'keydown') {\n          this.toolbarDropDownButton.focus();\n        }\n      } else if (this.overflowButtons.length > 0) {\n        this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);\n        this.focusButton(this.focusedIndex, ev);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKey(ev) {\n      if (!this.overflows && (ev.keyCode === this.getPrevKey(this.overflows) || ev.keyCode === this.getNextKey(this.overflows))) {\n        return false;\n      }\n\n      if (this.overflows) {\n        const peekAtIndex = makePeeker(this.overflowButtons);\n        const isUnmodified = areEqual(this.focusedIndex);\n        this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);\n        this.focusButton(this.focusedIndex, ev);\n        return !isUnmodified(this.focusedIndex);\n      }\n    }\n\n    focusButton(index, ev) {\n      if (!ev.type || ev.type === 'focus' || ev.type === 'keydown') {\n        this.overflowButtons[index].nativeElement.focus();\n      }\n    }\n\n  }\n\n  ToolBarDropDownButtonComponent.ɵfac = function ToolBarDropDownButtonComponent_Factory(t) {\n    return new (t || ToolBarDropDownButtonComponent)();\n  };\n\n  ToolBarDropDownButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarDropDownButtonComponent,\n    selectors: [[\"kendo-toolbar-dropdownbutton\"]],\n    viewQuery: function ToolBarDropDownButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c13, 7, ElementRef);\n        i0.ɵɵviewQuery(DropDownButtonComponent, 5);\n        i0.ɵɵviewQuery(_c14, 5);\n        i0.ɵɵviewQuery(_c15, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropDownButtonComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarDropDownButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowDropDownButtonButtonList = _t.first);\n      }\n    },\n    inputs: {\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      popupSettings: \"popupSettings\",\n      look: \"look\",\n      primary: \"primary\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      buttonClass: \"buttonClass\",\n      textField: \"textField\",\n      disabled: \"disabled\",\n      data: \"data\"\n    },\n    outputs: {\n      itemClick: \"itemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBarDropDownButton\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => ToolBarDropDownButtonComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [3, \"icon\", \"iconClass\", \"imageUrl\", \"buttonClass\", \"disabled\", \"tabIndex\", \"data\", \"textField\", \"popupSettings\", \"fillMode\", \"themeColor\", \"open\", \"close\", \"itemClick\"], [\"toolbarDropDownButton\", \"\"], [\"type\", \"button\", \"tabindex\", \"-1\", \"kendoButton\", \"\", 1, \"k-overflow-button\", 3, \"disabled\", \"icon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"click\"], [3, \"data\", \"disabled\", \"textField\", \"itemClick\", \"click\"], [\"overflowDropDownButtonButtonList\", \"\"]],\n    template: function ToolBarDropDownButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarDropDownButtonComponent_ng_template_0_Template, 3, 12, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, ToolBarDropDownButtonComponent_ng_template_2_Template, 4, 9, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [i1$1.DropDownButtonComponent, ToolBarButtonListComponent, i1$1.ButtonDirective, i3.NgClass],\n    encapsulation: 2\n  });\n  return ToolBarDropDownButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ToolBar SplitButton for Angular]({% slug controltypes_toolbar %}#toc-splitbuttons).\n */\n\n\nlet ToolBarSplitButtonComponent = /*#__PURE__*/(() => {\n  class ToolBarSplitButtonComponent extends ToolBarToolComponent {\n    constructor() {\n      super(); // showText and showIcon showIcon should be declared first\n\n      /**\n       * Specifies where button text should be displayed\n       */\n\n      this.showText = 'both';\n      /**\n       * Specifies where button icon should be displayed\n       */\n\n      this.showIcon = 'both';\n      /**\n       * The fillMode property specifies the background and border styles of the Button.\n       *\n       * The available values are:\n       * * `solid` (default)\n       * * `flat`\n       * * `outline`\n       * * `link`\n       * * `null`\n       */\n\n      this.fillMode = 'solid';\n      /**\n       * The Button allows you to specify predefined theme colors.\n       * The theme color will be applied as a background and border color while also amending the text color accordingly.\n       *\n       * The possible values are:\n       * * `base` &mdash;Applies coloring based on the `base` theme color. (default)\n       * * `primary` &mdash;Applies coloring based on the `primary` theme color.\n       * * `secondary`&mdash;Applies coloring based on the `secondary` theme color.\n       * * `tertiary`&mdash; Applies coloring based on the `tertiary` theme color.\n       * * `info`&mdash;Applies coloring based on the `info` theme color.\n       * * `success`&mdash; Applies coloring based on the `success` theme color.\n       * * `warning`&mdash; Applies coloring based on the `warning` theme color.\n       * * `error`&mdash; Applies coloring based on the `error` theme color.\n       * * `dark`&mdash; Applies coloring based on the `dark` theme color.\n       * * `light`&mdash; Applies coloring based on the `light` theme color.\n       * * `inverse`&mdash; Applies coloring based on the `inverse` theme color.\n       * * `null` &mdash;Removes the default CSS class (no class would be rendered).\n       */\n\n      this.themeColor = 'base';\n      /**\n       * Specifies the name of the [font icon]({% slug icons %}#toc-list-of-font-icons) that will\n       * be rendered for the button which opens the popup.\n       */\n\n      this.arrowButtonIcon = 'arrow-s';\n      /**\n       * Configures the text field of the button-list popup.\n       */\n\n      this.textField = 'text';\n      /**\n       * Fires each time the user clicks the main button.\n       */\n\n      this.buttonClick = new EventEmitter();\n      /**\n       * Fires each time the user clicks the drop-down list.\n       * The event data contains the data item that is bound to the clicked list item.\n       */\n\n      this.itemClick = new EventEmitter();\n      /**\n       * Fires each time the popup is about to open.\n       * This event is preventable. If you cancel the event, the popup will remain closed.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Fires each time the popup is about to close.\n       * This event is preventable. If you cancel the event, the popup will remain open.\n       */\n\n      this.close = new EventEmitter();\n      this.toolbarOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this.overflowOptions = {\n        text: '',\n        icon: '',\n        iconClass: '',\n        imageUrl: ''\n      };\n      this._popupSettings = {\n        animate: true,\n        popupClass: ''\n      };\n      this.focusedIndex = -1;\n      this.getNextKey = getNextKey();\n      this.getPrevKey = getPrevKey();\n    }\n    /**\n     * Sets the text of the SplitButton ([see example]({% slug controltypes_toolbar %}#toc-splitbuttons).\n     */\n\n\n    set text(text) {\n      this.toolbarOptions.text = getValueForLocation(text, this.showText, false);\n      this.overflowOptions.text = getValueForLocation(text, this.showText, true);\n    }\n    /**\n     * Defines the icon that will be rendered next to the button text\n     * ([see example]({% slug controltypes_toolbar %}#toc-splitbuttons)).\n     */\n\n\n    set icon(icon) {\n      this.toolbarOptions.icon = getValueForLocation(icon, this.showIcon, false);\n      this.overflowOptions.icon = getValueForLocation(icon, this.showIcon, true);\n    }\n    /**\n     * Defines an icon with a custom CSS class that will be rendered next to the button text.\n     */\n\n\n    set iconClass(iconClass) {\n      this.toolbarOptions.iconClass = getValueForLocation(iconClass, this.showIcon, false);\n      this.overflowOptions.iconClass = getValueForLocation(iconClass, this.showIcon, true);\n    }\n    /**\n     * Defines the location of an image that will be displayed next to the button text.\n     */\n\n\n    set imageUrl(imageUrl) {\n      this.toolbarOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, false);\n      this.overflowOptions.imageUrl = getValueForLocation(imageUrl, this.showIcon, true);\n    }\n    /**\n     * Configures the popup of the SplitButton.\n     *\n     * The available options are:\n     * - `animate:Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass:String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     */\n\n\n    set popupSettings(value) {\n      this._popupSettings = value;\n    }\n\n    get popupSettings() {\n      if (!this._popupSettings) {\n        this._popupSettings = {\n          animate: true,\n          popupClass: ''\n        };\n      }\n\n      return this._popupSettings;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set look(look) {\n      if (look) {\n        this.fillMode = look === 'default' ? 'solid' : look;\n      }\n    }\n    /**\n     * Sets the data of the SplitButton ([see example]({% slug controltypes_toolbar %}#toc-splitbuttons)).\n     *\n     * > The data has to be provided in an array-like list.\n     */\n\n\n    set data(data) {\n      this._data = data || [];\n    }\n\n    get data() {\n      if (!this._data) {\n        this.data = [];\n      }\n\n      return this._data;\n    }\n\n    get overflowButtons() {\n      return [this.overflowSplitButton, ...this.overflowSplitButtonButtonList.buttons.toArray().filter(b => !b.nativeElement.disabled)];\n    }\n    /**\n     * @hidden\n     */\n\n\n    onButtonListClick(ev) {\n      this.focusedIndex = this.overflowButtons.findIndex(b => b.nativeElement.contains(ev.target));\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMainButtonClick(ev) {\n      this.buttonClick.emit(ev);\n      this.focusedIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return !this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    focus(ev = {}) {\n      if (!this.overflows) {\n        if (ev.type === 'focus' || ev.type === 'keydown') {\n          this.toolbarSplitButton.focus();\n        }\n      } else if (this.overflowButtons.length > 0) {\n        this.focusedIndex = getIndexOfFocused(this.getPrevKey(), this.getNextKey(), this.overflowButtons.map(ob => ob.nativeElement))(ev);\n        this.focusButton(this.focusedIndex, ev);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    handleKey(ev) {\n      if (!this.overflows && (ev.keyCode === this.getPrevKey(this.overflows) || ev.keyCode === this.getNextKey(this.overflows))) {\n        return false;\n      }\n\n      if (this.overflows) {\n        const peekAtIndex = makePeeker(this.overflowButtons);\n        const isUnmodified = areEqual(this.focusedIndex);\n        this.focusedIndex = seekFocusedIndex(this.getPrevKey(), this.getNextKey(), peekAtIndex)(this.focusedIndex, ev);\n        this.focusButton(this.focusedIndex, ev);\n        return !isUnmodified(this.focusedIndex);\n      }\n    }\n\n    focusButton(index, ev) {\n      if (!ev.type || ev.type === 'focus' || ev.type === 'keydown' || ev.type === 'click') {\n        this.overflowButtons[index].nativeElement.focus();\n      }\n    }\n\n  }\n\n  ToolBarSplitButtonComponent.ɵfac = function ToolBarSplitButtonComponent_Factory(t) {\n    return new (t || ToolBarSplitButtonComponent)();\n  };\n\n  ToolBarSplitButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarSplitButtonComponent,\n    selectors: [[\"kendo-toolbar-splitbutton\"]],\n    viewQuery: function ToolBarSplitButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c16, 5);\n        i0.ɵɵviewQuery(_c17, 5, ElementRef);\n        i0.ɵɵviewQuery(_c18, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarSplitButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowSplitButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowSplitButtonButtonList = _t.first);\n      }\n    },\n    inputs: {\n      showText: \"showText\",\n      showIcon: \"showIcon\",\n      text: \"text\",\n      icon: \"icon\",\n      iconClass: \"iconClass\",\n      imageUrl: \"imageUrl\",\n      disabled: \"disabled\",\n      popupSettings: \"popupSettings\",\n      fillMode: \"fillMode\",\n      themeColor: \"themeColor\",\n      look: \"look\",\n      buttonClass: \"buttonClass\",\n      arrowButtonClass: \"arrowButtonClass\",\n      arrowButtonIcon: \"arrowButtonIcon\",\n      textField: \"textField\",\n      data: \"data\"\n    },\n    outputs: {\n      buttonClick: \"buttonClick\",\n      itemClick: \"itemClick\",\n      open: \"open\",\n      close: \"close\"\n    },\n    exportAs: [\"kendoToolBarSplitButton\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => ToolBarSplitButtonComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [\"popupTemplate\", \"\"], [3, \"data\", \"text\", \"icon\", \"iconClass\", \"imageUrl\", \"buttonClass\", \"arrowButtonClass\", \"arrowButtonIcon\", \"disabled\", \"tabIndex\", \"textField\", \"popupSettings\", \"fillMode\", \"themeColor\", \"buttonClick\", \"open\", \"close\", \"itemClick\"], [\"toolbarSplitButton\", \"\"], [\"type\", \"button\", \"tabindex\", \"-1\", \"kendoButton\", \"\", 1, \"k-overflow-button\", 3, \"fillMode\", \"themeColor\", \"disabled\", \"icon\", \"iconClass\", \"imageUrl\", \"ngClass\", \"click\"], [\"overflowSplitButton\", \"\"], [3, \"data\", \"disabled\", \"fillMode\", \"themeColor\", \"textField\", \"itemClick\", \"click\"], [\"overflowSplitButtonButtonList\", \"\"]],\n    template: function ToolBarSplitButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarSplitButtonComponent_ng_template_0_Template, 2, 14, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, ToolBarSplitButtonComponent_ng_template_2_Template, 5, 13, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    directives: [i1$1.SplitButtonComponent, ToolBarButtonListComponent, i1$1.ButtonDirective, i3.NgClass],\n    encapsulation: 2\n  });\n  return ToolBarSplitButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents the [Kendo UI ToolBar Separator for Angular]({% slug controltypes_toolbar %}#toc-separators).\n */\n\n\nlet ToolBarSeparatorComponent = /*#__PURE__*/(() => {\n  class ToolBarSeparatorComponent extends ToolBarToolComponent {\n    constructor() {\n      super();\n    }\n    /**\n     * @hidden\n     */\n\n\n    canFocus() {\n      return false;\n    } // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n\n    /**\n     * @hidden\n     */\n\n\n    focus() {\n      /* noop */\n    } // If this is not here, the docs display info from its parent(ToolBarToolComponent).\n\n    /**\n     * @hidden\n     */\n\n\n    handleKey() {\n      return false;\n    }\n\n    ngAfterViewInit() {\n      if (!this.popupTemplate) {\n        this.popupTemplate = this.toolbarTemplate;\n      }\n    }\n\n  }\n\n  ToolBarSeparatorComponent.ɵfac = function ToolBarSeparatorComponent_Factory(t) {\n    return new (t || ToolBarSeparatorComponent)();\n  };\n\n  ToolBarSeparatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolBarSeparatorComponent,\n    selectors: [[\"kendo-toolbar-separator\"]],\n    viewQuery: function ToolBarSeparatorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c8, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c19, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.separator = _t.first);\n      }\n    },\n    exportAs: [\"kendoToolBarSeparator\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolBarToolComponent,\n      useExisting: forwardRef(() => ToolBarSeparatorComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"toolbarTemplate\", \"\"], [1, \"k-separator\"]],\n    template: function ToolBarSeparatorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ToolBarSeparatorComponent_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  });\n  return ToolBarSeparatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Custom component messages override default component messages.\n */\n\n\nlet ToolbarCustomMessagesComponent = /*#__PURE__*/(() => {\n  class ToolbarCustomMessagesComponent extends ToolbarMessages {\n    constructor(service) {\n      super();\n      this.service = service;\n    }\n\n    get override() {\n      return true;\n    }\n\n  }\n\n  ToolbarCustomMessagesComponent.ɵfac = function ToolbarCustomMessagesComponent_Factory(t) {\n    return new (t || ToolbarCustomMessagesComponent)(i0.ɵɵdirectiveInject(i1.LocalizationService));\n  };\n\n  ToolbarCustomMessagesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ToolbarCustomMessagesComponent,\n    selectors: [[\"kendo-toolbar-messages\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: ToolbarMessages,\n      useExisting: forwardRef(() => ToolbarCustomMessagesComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function ToolbarCustomMessagesComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return ToolbarCustomMessagesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst TOOLBAR_TOOLS = [ToolBarToolComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSplitButtonComponent, ToolBarSeparatorComponent];\nconst TOOLBAR_COMMON = [ToolBarRendererComponent, ToolBarButtonListComponent, ToolbarCustomMessagesComponent, LocalizedToolbarMessagesDirective];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the ToolBar component.\n *\n * The package exports:\n * - `ToolBarComponent`&mdash;The ToolBarComponent class.\n * - `ToolBarToolComponent`&mdash;The base Tool component class.\n * - `ToolBarButtonComponent`&mdash;The Button Tool component class.\n * - `ToolBarButtonGroupComponent`&mdash;The ButtonGroup Tool component class.\n * - `ToolBarDropDownButtonComponent`&mdash;The DropDownButton Tool component class.\n * - `ToolBarSplitButtonComponent`&mdash;The SplitButton Tool component class.\n * - `ToolBarSeparatorComponent`&mdash;The Separator Tool component class.\n */\n\nlet ToolBarModule = /*#__PURE__*/(() => {\n  class ToolBarModule {}\n\n  ToolBarModule.ɵfac = function ToolBarModule_Factory(t) {\n    return new (t || ToolBarModule)();\n  };\n\n  ToolBarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ToolBarModule\n  });\n  ToolBarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ButtonsModule, PopupModule, ResizeSensorModule]]\n  });\n  return ToolBarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LocalizedToolbarMessagesDirective, RefreshService, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarComponent, ToolBarDropDownButtonComponent, ToolBarModule, ToolBarSeparatorComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, ToolbarCustomMessagesComponent };","map":null,"metadata":{},"sourceType":"module"}