{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1427);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1417:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.scheduler.view\");\n    /***/\n  },\n\n  /***/\n  1427:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1417)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"scheduler.timelineview\",\n        name: \"Scheduler Timeline View\",\n        category: \"web\",\n        description: \"The Scheduler Timeline View\",\n        depends: [\"scheduler.view\"],\n        hidden: true\n      };\n\n      (function ($, undefined) {\n        var kendo = window.kendo,\n            ui = kendo.ui,\n            setTime = kendo.date.setTime,\n            SchedulerView = ui.SchedulerView,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            getDate = kendo.date.getDate,\n            getMilliseconds = kendo.date.getMilliseconds,\n            MS_PER_DAY = kendo.date.MS_PER_DAY,\n            MS_PER_MINUTE = kendo.date.MS_PER_MINUTE,\n            CURRENT_TIME_MARKER_CLASS = \"k-current-time\",\n            CURRENT_TIME_MARKER_ARROW_CLASS = \"k-current-time-arrow\",\n            SCHEDULER_HEADER_WRAP_CLASS = \"k-scheduler-header-wrap\",\n            INVERSE_COLOR_CLASS = \"k-event-inverse\",\n            BORDER_SIZE_COEFF = 0.8666,\n            NS = \".kendoTimelineView\";\n        var EVENT_TEMPLATE = kendo.template('<div>' + '<div class=\"k-event-template k-event-time\">#:kendo.format(\"{0:t} - {1:t}\", start, end)#</div>' + '<div class=\"k-event-template\">${title}</div></div>'),\n            DATA_HEADER_TEMPLATE = kendo.template(\"<span class='k-link k-nav-day'>#=kendo.format('{0:m}', date)#</span>\"),\n            EVENT_WRAPPER_STRING = '<div role=\"button\" ' + 'aria-label=\"#: ariaLabel #\" ' + 'data-#=ns#uid=\"#=uid#\"' + '#if (resources[0]) { #' + 'style=\"background-color:#=resources[0].color#; border-color: #=resources[0].color#\"' + 'class=\"k-event\" ' + '#} else {#' + 'class=\"k-event\"' + '#}#' + '>' + '<span class=\"k-event-actions\">' + '# if(data.tail) {#' + '<span class=\"k-icon k-i-arrow-60-left\"></span>' + '#}#' + '# if(data.isException()) {#' + '<span class=\"k-icon k-i-non-recurrence\"></span>' + '# } else if(data.isRecurring()) {#' + '<span class=\"k-icon k-i-reload\"></span>' + '# } #' + '</span>' + '{0}' + '<span class=\"k-event-actions\">' + '#if (showDelete) {#' + '<a href=\"\\\\#\" class=\"k-link k-event-delete\" title=\"${data.messages.destroy}\" aria-label=\"${data.messages.destroy}\"><span class=\"k-icon k-i-close\"></span></a>' + '#}#' + '# if(data.head) {#' + '<span class=\"k-icon k-i-arrow-60-right\"></span>' + '#}#' + '</span>' + '#if(resizable && !data.tail){#' + '<span class=\"k-resize-handle k-resize-w\"></span>' + '#}#' + '#if(resizable && !data.head){#' + '<span class=\"k-resize-handle k-resize-e\"></span>' + '#}#' + '</div>';\n\n        function toInvariantTime(date) {\n          var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n          setTime(staticDate, getMilliseconds(date));\n          return staticDate;\n        }\n\n        function getWorkDays(options) {\n          if (options.workDays && options.workDays.length) {\n            return options.workDays;\n          }\n\n          var workDays = [];\n          var dayIndex = options.workWeekStart % 7;\n          var workWeekEnd = Math.abs(options.workWeekEnd % 7);\n          workDays.push(dayIndex);\n\n          while (workWeekEnd != dayIndex) {\n            if (dayIndex > 6) {\n              dayIndex -= 7;\n            } else {\n              dayIndex++;\n            }\n\n            workDays.push(dayIndex);\n          }\n\n          return workDays;\n        }\n\n        function setColspan(columnLevel) {\n          var count = 0;\n\n          if (columnLevel.columns) {\n            for (var i = 0; i < columnLevel.columns.length; i++) {\n              count += setColspan(columnLevel.columns[i]);\n            }\n\n            columnLevel.colspan = count;\n            return count;\n          } else {\n            columnLevel.colspan = 1;\n            return 1;\n          }\n        }\n\n        function collidingEvents(elements, left, right) {\n          var idx, startPosition, overlaps, endPosition;\n\n          for (idx = elements.length - 1; idx >= 0; idx--) {\n            startPosition = elements[idx].rectLeft;\n            endPosition = elements[idx].rectRight;\n            overlaps = startPosition <= left && endPosition >= left;\n\n            if (overlaps || startPosition >= left && endPosition <= right || left <= startPosition && right >= startPosition) {\n              if (startPosition < left) {\n                left = startPosition;\n              }\n\n              if (endPosition > right) {\n                right = endPosition;\n              }\n            }\n          }\n\n          return eventsForSlot(elements, left, right);\n        }\n\n        function eventsForSlot(elements, left, right) {\n          var events = [];\n\n          for (var idx = 0; idx < elements.length; idx++) {\n            var event = {\n              rectLeft: elements[idx].rectLeft,\n              rectRight: elements[idx].rectRight\n            };\n\n            if (event.rectLeft < left && event.rectRight > left || event.rectLeft >= left && event.rectRight <= right) {\n              events.push(elements[idx]);\n            }\n          }\n\n          return events;\n        }\n\n        var TimelineGroupedView = kendo.Class.extend({\n          init: function (view) {\n            this._view = view;\n          },\n          _getTimeSlotByPosition: function (x, y, groupIndex) {\n            var group = this._view.groups[groupIndex];\n            return group.timeSlotByPosition(x, y);\n          },\n          _hideHeaders: function () {\n            var view = this._view;\n            view.timesHeader.find(\"table tr\").last().hide();\n            /*Chrome fix, use CSS selector*/\n\n            view.datesHeader.find(\"table tr\").last().hide();\n          },\n          _setColspan: function (timeColumn) {\n            setColspan(timeColumn);\n          },\n          _createRowsLayout: function (resources, rows, groupHeaderTemplate) {\n            var view = this._view;\n            return view._createRowsLayout(resources, rows, groupHeaderTemplate);\n          },\n          _createVerticalColumnsLayout: function (resources, rows, groupHeaderTemplate, columns) {\n            return columns;\n          },\n          _createColumnsLayout: function (resources, columns, groupHeaderTemplate) {\n            var view = this._view;\n            return view._createColumnsLayout(resources, columns, groupHeaderTemplate);\n          },\n          _getRowCount: function () {\n            var view = this._view;\n            return view._groupCount();\n          },\n          _getGroupsCount: function () {\n            return 1;\n          },\n          _addContent: function (dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped) {\n            var view = this._view;\n            var html = '';\n            var options = view.options;\n\n            var appendRow = function (date) {\n              var content = \"\";\n              var classes = \"\";\n              var tmplDate;\n\n              var resources = function (groupIndex) {\n                return function () {\n                  return view._resourceBySlot({\n                    groupIndex: groupIndex\n                  });\n                };\n              };\n\n              if (kendo.date.isToday(dates[idx])) {\n                classes += \"k-today\";\n              }\n\n              if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(options.workDayStart) || kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(options.workDayEnd) || !view._isWorkDay(dates[idx])) {\n                classes += \" k-nonwork-hour\";\n              }\n\n              content += '<td' + (classes !== \"\" ? ' class=\"' + classes + '\"' : \"\") + \">\";\n              tmplDate = kendo.date.getDate(dates[idx]);\n              kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n              content += slotTemplate({\n                date: tmplDate,\n                resources: resources(isVerticalGrouped ? rowIdx : groupIdx)\n              });\n              content += \"</td>\";\n              return content;\n            };\n\n            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n              html += '<tr>';\n\n              for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                for (var idx = 0, length = columnCount; idx < length; idx++) {\n                  html += view._forTimeRange(start, end, appendRow);\n                }\n              }\n\n              html += \"</tr>\";\n            }\n\n            return html;\n          },\n          _addTimeSlotsCollections: function (groupCount, datesCount, tableRows, interval, isVerticallyGrouped) {\n            var view = this._view;\n            var rowCount = tableRows.length;\n\n            if (isVerticallyGrouped) {\n              rowCount = Math.floor(rowCount / groupCount);\n            }\n\n            for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {\n              var rowMultiplier = 0;\n              var group = view.groups[groupIndex];\n              var time;\n\n              if (isVerticallyGrouped) {\n                rowMultiplier = groupIndex;\n              }\n\n              var rowIndex = rowMultiplier * rowCount;\n              var cellMultiplier = 0;\n\n              if (!isVerticallyGrouped) {\n                cellMultiplier = groupIndex;\n              }\n\n              var cells = tableRows[rowIndex].children;\n              var cellsPerGroup = cells.length / (!isVerticallyGrouped ? groupCount : 1);\n              var cellsPerDay = cellsPerGroup / datesCount;\n\n              for (var dateIndex = 0; dateIndex < datesCount; dateIndex++) {\n                var cellOffset = dateIndex * cellsPerDay + cellsPerGroup * cellMultiplier;\n                time = getMilliseconds(new Date(+view.startTime()));\n\n                for (var cellIndex = 0; cellIndex < cellsPerDay; cellIndex++) {\n                  view._addTimeSlotToCollection(group, cells, cellIndex, cellOffset, dateIndex, time, interval);\n\n                  time += interval;\n                }\n              }\n            }\n          },\n          _getVerticalGroupCount: function (groupsCount) {\n            return groupsCount;\n          },\n          _getVerticalRowCount: function (eventGroups, groupIndex, maxRowCount) {\n            var view = this._view;\n            return view._isVerticallyGrouped() ? eventGroups[groupIndex].maxRowCount : maxRowCount;\n          },\n          _renderEvent: function (eventGroup, event, adjustedEvent, group, range, container) {\n            var view = this._view;\n            var element;\n            element = view._createEventElement(adjustedEvent.occurrence, event, range.head || adjustedEvent.head, range.tail || adjustedEvent.tail);\n            element.appendTo(container).css({\n              top: 0,\n              height: view.options.eventHeight\n            });\n            var eventObject = {\n              start: adjustedEvent.occurrence._startTime || adjustedEvent.occurrence.start,\n              end: adjustedEvent.occurrence._endTime || adjustedEvent.occurrence.end,\n              element: element,\n              uid: event.uid,\n              slotRange: range,\n              rowIndex: 0,\n              offsetTop: 0\n            };\n            eventGroup.events[event.uid] = eventObject;\n\n            view._inverseEventColor(element);\n\n            view.addContinuousEvent(group, range, element, event.isAllDay);\n\n            view._arrangeRows(eventObject, range, eventGroup);\n          },\n          _verticalCountForLevel: function (level) {\n            var view = this._view;\n            return view._rowCountForLevel(level);\n          },\n          _horizontalCountForLevel: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level);\n          },\n          _updateCurrentVerticalTimeMarker: function (ranges, currentTime) {\n            var view = this._view;\n            var elementHtml = \"<div class='\" + CURRENT_TIME_MARKER_CLASS + \"'></div>\";\n            var headerWrap = view.datesHeader.find(\".\" + SCHEDULER_HEADER_WRAP_CLASS);\n            var left = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).left);\n            var timesTableMarker = $(elementHtml).prependTo(headerWrap).addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-down\");\n            timesTableMarker.css({\n              left: view._adjustLeftPosition(left - outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2),\n              top: headerWrap.find(\"tr\").last().prev().position().top\n            });\n            $(elementHtml).prependTo(view.content).css({\n              left: view._adjustLeftPosition(left),\n              width: \"1px\",\n              height: view.content[0].scrollHeight - 1,\n              top: 0\n            });\n          },\n          _changeGroup: function () {\n            return undefined;\n          },\n          _prevGroupSlot: function (slot, group, isDay) {\n            var view = this._view;\n\n            if (view._isVerticallyGrouped()) {\n              return slot;\n            } else {\n              var collection = group._collection(0, isDay);\n\n              return collection.last();\n            }\n          },\n          _nextGroupSlot: function (slot, group, isDay) {\n            var view = this._view;\n\n            if (view._isVerticallyGrouped()) {\n              return slot;\n            } else {\n              var collection = group._collection(0, isDay);\n\n              return collection.first();\n            }\n          },\n          _verticalSlots: function (selection, reverse) {\n            var view = this._view;\n            return view._changeGroup(selection, reverse);\n          },\n          _verticalMethod: function (reverse) {\n            return reverse ? \"leftSlot\" : \"rightSlot\";\n          },\n          _normalizeVerticalSelection: function () {\n            return undefined;\n          },\n          _horizontalSlots: function (selection, group, method, startSlot, endSlot, multiple, reverse) {\n            var view = this._view;\n            var result = {};\n            result.startSlot = group[method](startSlot);\n            result.endSlot = group[method](endSlot);\n\n            if (!multiple && view._isHorizontallyGrouped() && (!result.startSlot || !result.endSlot)) {\n              result.startSlot = result.endSlot = view._changeGroup(selection, reverse);\n            }\n\n            return result;\n          },\n          _changeVerticalViewPeriod: function () {\n            return false;\n          },\n          _changeHorizontalViewPeriod: function (slots, shift, selection, reverse) {\n            var view = this._view;\n\n            if ((!slots.startSlot || !slots.endSlot) && !shift && view._changeViewPeriod(selection, reverse, false)) {\n              return true;\n            }\n\n            return false;\n          },\n          _updateDirection: function (selection, ranges, shift, reverse) {\n            var view = this._view;\n\n            view._updateDirection(selection, ranges, shift, reverse, true);\n          },\n          _createMoveHint: function (range, adjustedEvent) {\n            var view = this._view;\n            var startSlot = range.start;\n\n            var hint = view._createEventElement(adjustedEvent.occurrence, adjustedEvent.occurrence, false, false);\n\n            hint.addClass(\"k-event-drag-hint\");\n            var rect = range.innerRect(adjustedEvent.occurrence.start, adjustedEvent.occurrence.end, view.options.snap);\n            var width = rect.right - rect.left;\n\n            if (width < 0) {\n              width = 0;\n            }\n\n            var left = view._adjustLeftPosition(rect.left);\n\n            var css = {\n              left: left,\n              top: startSlot.offsetTop,\n              height: startSlot.offsetHeight,\n              width: width\n            };\n            hint.css(css);\n\n            if (adjustedEvent.occurrence.inverseColor) {\n              hint.addClass(INVERSE_COLOR_CLASS);\n            }\n\n            view._appendMoveHint(hint);\n          },\n          _adjustLeftPosition: function (left) {\n            var view = this._view;\n\n            if (view._isRtl) {\n              left -= view.content[0].scrollWidth - view.content[0].clientWidth;\n            }\n\n            return left;\n          }\n        });\n        var TimelineGroupedByDateView = kendo.Class.extend({\n          init: function (view) {\n            this._view = view;\n          },\n          _getTimeSlotByPosition: function (x, y, groupIndex) {\n            var group = this._view.groups[groupIndex];\n            return group.timeSlotByPosition(x, y, true);\n          },\n          _hideHeaders: function () {\n            var view = this._view;\n\n            if (!view._isVerticallyGrouped()) {\n              view.timesHeader.find(\"table tr\").eq(2).hide();\n              view.datesHeader.find(\"table tr\").eq(2).hide();\n            } else {\n              view.times.find(\".k-last\").hide();\n            }\n          },\n          _setColspan: function () {},\n          _createRowsLayout: function (resources, rows, groupHeaderTemplate, columns) {\n            var view = this._view;\n            return view._createDateLayout(columns, null, true);\n          },\n          _createVerticalColumnsLayout: function (resources, rows, groupHeaderTemplate) {\n            var view = this._view;\n            return view._createColumnsLayout(resources, null, groupHeaderTemplate);\n          },\n          _createColumnsLayout: function (resources, columns, groupHeaderTemplate, subColumns) {\n            var view = this._view;\n            return view._createColumnsLayout(resources, columns, groupHeaderTemplate, subColumns, true);\n          },\n          _getRowCount: function (level) {\n            var view = this._view;\n            return view._rowCountForLevel(level);\n          },\n          _getGroupsCount: function () {\n            var view = this._view;\n            return view._groupCount();\n          },\n          _addContent: function (dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped) {\n            var view = this._view;\n            var html = '';\n            var options = view.options;\n\n            var appendRow = function (date, isMajorTickColumn, isMiddleColumn, isLastSlotColumn, minorTickColumns, groupIdx) {\n              var content = \"\";\n              var classes = \"\";\n              var tmplDate;\n              var workDateIndex = view._isVerticallyGrouped() ? dateIndex : idx;\n\n              var resources = function (groupIndex) {\n                return function () {\n                  return view._resourceBySlot({\n                    groupIndex: groupIndex\n                  });\n                };\n              };\n\n              if (kendo.date.isToday(dates[idx])) {\n                classes += \"k-today\";\n              }\n\n              if (kendo.date.getMilliseconds(date) < kendo.date.getMilliseconds(options.workDayStart) || kendo.date.getMilliseconds(date) >= kendo.date.getMilliseconds(options.workDayEnd) || !view._isWorkDay(dates[workDateIndex])) {\n                classes += \" k-nonwork-hour\";\n              }\n\n              content += '<td' + (classes !== \"\" ? ' class=\"' + classes + '\"' : \"\") + \">\";\n              tmplDate = kendo.date.getDate(dates[idx]);\n              kendo.date.setTime(tmplDate, kendo.date.getMilliseconds(date));\n              content += slotTemplate({\n                date: tmplDate,\n                resources: resources(groupIdx)\n              });\n              content += \"</td>\";\n              return content;\n            };\n\n            var tempStart = new Date(start),\n                minorTickCount = view.options.minorTickCount,\n                msMajorInterval = view.options.majorTick * MS_PER_MINUTE,\n                msInterval = msMajorInterval / minorTickCount || 1,\n                dateIndex;\n\n            for (var rowIdx = 0; rowIdx < rowCount; rowIdx++) {\n              html += '<tr>';\n\n              if (rowIdx % (rowCount / view._dates.length) === 0) {\n                dateIndex = rowIdx / (rowCount / view._dates.length);\n                tempStart = new Date(view._dates[dateIndex]);\n                kendo.date.setTime(tempStart, kendo.date.getMilliseconds(start));\n              }\n\n              for (var idx = 0, length = columnCount; idx < length; idx++) {\n                html += view._forTimeRange(tempStart, end, appendRow, isVerticalGrouped, groupsCount);\n\n                if (isVerticalGrouped) {\n                  setTime(tempStart, msInterval, false);\n                  break;\n                }\n              }\n\n              html += \"</tr>\";\n            }\n\n            return html;\n          },\n          _addTimeSlotsCollections: function (groupCount, datesCount, tableRows, interval, isVerticallyGrouped) {\n            var view = this._view;\n            var rowCount = tableRows.length;\n\n            if (isVerticallyGrouped) {\n              rowCount = rowCount / datesCount;\n            }\n\n            for (var dateIndex = 0; dateIndex < datesCount; dateIndex++) {\n              var rowMultiplier = 0;\n              var time;\n\n              if (isVerticallyGrouped) {\n                rowMultiplier = dateIndex;\n              }\n\n              var rowIndex = rowMultiplier * rowCount;\n              var cellMultiplier = 0;\n              var cells = tableRows[rowIndex].children;\n              var cellsPerGroup = isVerticallyGrouped ? rowCount : cells.length / (datesCount * groupCount);\n              var cellsPerDay = cells.length / datesCount;\n              var cellOffset;\n              time = getMilliseconds(new Date(+view.startTime()));\n\n              for (var cellIndex = 0; cellIndex < cellsPerGroup; cellIndex++) {\n                if (!isVerticallyGrouped) {\n                  cellOffset = dateIndex * cellsPerDay + groupCount * cellIndex;\n                  cellMultiplier++;\n                } else {\n                  cellOffset = 0;\n                  cells = tableRows[cellIndex + cellsPerGroup * dateIndex].children;\n                }\n\n                for (var groupIndex = 0; groupIndex < groupCount; groupIndex++) {\n                  var group = view.groups[groupIndex];\n\n                  view._addTimeSlotToCollection(group, cells, groupIndex, cellOffset, dateIndex, time, interval);\n                }\n\n                time += interval;\n              }\n            }\n          },\n          _getVerticalGroupCount: function () {\n            var view = this._view;\n            return view.content.find(\"tr\").length;\n          },\n          _getVerticalRowCount: function (eventGroups, groupIndex, maxRowCount) {\n            return maxRowCount;\n          },\n          _renderEvent: function (eventGroup, event, adjustedEvent, group, range, container, startIndex, endIndex) {\n            var view = this._view;\n            var element;\n            var eventObjects = [];\n\n            for (var i = range.start.index; i <= range.end.index; i++) {\n              element = view._createEventElement(adjustedEvent.occurrence, event, i !== endIndex, i !== startIndex);\n              element.appendTo(container).css({\n                top: 0,\n                height: view.options.eventHeight\n              });\n              var currentSlot = group._timeSlotCollections[0]._slots[i];\n              var dateRange = group.timeSlotRanges(currentSlot.start, currentSlot.end, false)[0];\n              var eventObject = {\n                start: i === startIndex ? adjustedEvent.occurrence._startTime || adjustedEvent.occurrence.start : currentSlot.start,\n                end: i === endIndex ? adjustedEvent.occurrence._endTime || adjustedEvent.occurrence.end : currentSlot.end,\n                element: element,\n                uid: event.uid,\n                slotRange: dateRange,\n                rowIndex: 0,\n                offsetTop: 0\n              };\n              eventGroup.events[event.uid] = eventObject;\n              eventObjects.push(eventObject);\n              view.addContinuousEvent(group, dateRange, element, event.isAllDay);\n\n              view._arrangeRows(eventObject, dateRange, eventGroup);\n            }\n\n            eventGroup.events[event.uid] = eventObjects;\n          },\n          _verticalCountForLevel: function (level) {\n            var view = this._view;\n            return view._columnCountForLevel(level);\n          },\n          _horizontalCountForLevel: function (level, columnLevel) {\n            var view = this._view;\n            return view._columnCountForLevel(columnLevel) / view._columnCountForLevel(2);\n          },\n          _updateCurrentVerticalTimeMarker: function (ranges, currentTime) {\n            var view = this._view;\n            var firstTimesCell = view.times.find(\"tr\").first().find(\"th\").first();\n            var lastTimesCell = view.times.find(\"tr\").first().find(\"th\").last();\n            var elementHtml = \"<div class='\" + CURRENT_TIME_MARKER_CLASS + \"'></div>\";\n            var timesTableMarker = $(elementHtml).prependTo(view.times);\n            var markerTopPosition = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).top);\n            var timesTableMarkerCss = {};\n\n            if (this._isRtl) {\n              timesTableMarkerCss.right = firstTimesCell.position().left + outerHeight(firstTimesCell) - outerHeight(lastTimesCell);\n              timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-left\");\n            } else {\n              timesTableMarkerCss.left = lastTimesCell.position().left;\n              timesTableMarker.addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-right\");\n            }\n\n            timesTableMarkerCss.top = markerTopPosition - outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2;\n            timesTableMarker.css(timesTableMarkerCss);\n            $(elementHtml).prependTo(view.content).css({\n              top: markerTopPosition,\n              height: \"1px\",\n              right: \"1px\",\n              width: view.content[0].scrollWidth,\n              left: 0\n            });\n          },\n          _changeGroup: function (selection, previous, slot) {\n            var view = this._view;\n\n            if (!slot) {\n              selection.groupIndex = previous ? view.groups.length - 1 : 0;\n            }\n          },\n          _prevGroupSlot: function (slot) {\n            return slot;\n          },\n          _nextGroupSlot: function (slot) {\n            return slot;\n          },\n          _changeDate: function (selection, reverse, slot) {\n            var view = this._view;\n            var group = view.groups[selection.groupIndex];\n            var collections, index;\n\n            if (reverse) {\n              collections = group._getCollections(false);\n              index = slot.index - 1;\n\n              if (index >= 0) {\n                return collections[0]._slots[index];\n              }\n            } else {\n              collections = group._getCollections(false);\n              index = slot.index + 1;\n\n              if (collections[0] && collections[0]._slots[index]) {\n                return collections[0]._slots[index];\n              }\n            }\n          },\n          _verticalSlots: function (selection, reverse, slot) {\n            return this._changeDate(selection, reverse, slot);\n          },\n          _verticalMethod: function (reverse, multiple) {\n            if (multiple) {\n              return reverse ? \"upSlot\" : \"downSlot\";\n            } else {\n              return reverse ? \"leftSlot\" : \"rightSlot\";\n            }\n          },\n          _normalizeVerticalSelection: function (selection, ranges, reverse, multiple) {\n            var view = this._view;\n\n            if (!multiple) {\n              return view._normalizeVerticalSelection(selection, ranges, reverse);\n            }\n\n            return undefined;\n          },\n          _horizontalSlots: function (selection, group, method, startSlot, endSlot, multiple, reverse) {\n            var view = this._view;\n\n            var tempSlot = view._changeGroup(selection, reverse);\n\n            var result = {};\n\n            if (!tempSlot) {\n              if (!view._isVerticallyGrouped()) {\n                result.startSlot = group[method](startSlot);\n                result.endSlot = group[method](endSlot);\n              }\n            } else {\n              result.startSlot = result.endSlot = tempSlot;\n            }\n\n            return result;\n          },\n          _changeVerticalViewPeriod: function (slots, shift, selection, reverse) {\n            var view = this._view;\n\n            if ((!slots.startSlot || !slots.endSlot) && !shift && view._changeViewPeriod(selection, reverse, view._isVerticallyGrouped())) {\n              return true;\n            }\n\n            return false;\n          },\n          _changeHorizontalViewPeriod: function (slots, shift, selection, reverse) {\n            var view = this._view;\n\n            if (view._isVerticallyGrouped()) {\n              return false;\n            }\n\n            if ((!slots.startSlot || !slots.endSlot) && !shift && view._changeViewPeriod(selection, reverse, false)) {\n              return true;\n            }\n\n            return false;\n          },\n          _updateDirection: function (selection, ranges, shift, reverse) {\n            var view = this._view;\n\n            view._updateDirection(selection, ranges, shift, reverse, !view._isVerticallyGrouped());\n          },\n          _createMoveHint: function (range, adjustedEvent) {\n            var view = this._view;\n            var startSlot = range.start;\n            var startEnd = range.end;\n\n            for (var slotIdx = startSlot.index; slotIdx <= startEnd.index; slotIdx++) {\n              var slot = range.collection._slots[slotIdx];\n\n              var hint = view._createEventElement(adjustedEvent.occurrence, adjustedEvent.occurrence, false, false);\n\n              hint.addClass(\"k-event-drag-hint\");\n              var css = {\n                left: slot.offsetLeft + 2,\n                top: slot.offsetTop,\n                height: view.options.eventHeight,\n                width: slot.offsetWidth\n              };\n              hint.css(css);\n\n              if (adjustedEvent.occurrence.inverseColor) {\n                hint.addClass(INVERSE_COLOR_CLASS);\n              }\n\n              view._appendMoveHint(hint);\n            }\n          },\n          _adjustLeftPosition: function (left) {\n            var view = this._view;\n\n            if (view._isRtl && !view._isVerticallyGrouped()) {\n              left -= view.content[0].scrollWidth - view.content[0].offsetWidth;\n            }\n\n            return left;\n          }\n        });\n        kendo.ui.scheduler.TimelineGroupedView = TimelineGroupedView;\n        kendo.ui.scheduler.TimelineGroupedByDateView = TimelineGroupedByDateView;\n        var TimelineView = SchedulerView.extend({\n          init: function (element, options) {\n            var that = this;\n            SchedulerView.fn.init.call(that, element, options);\n            that._groupedView = that._getGroupedView();\n            that.title = that.options.title || that.options.name;\n            that._workDays = getWorkDays(that.options);\n\n            that._templates();\n\n            that._editable();\n\n            that.calculateDateRange();\n\n            that._groups();\n\n            that._currentTime(true);\n          },\n          name: \"timeline\",\n          _isVirtualized: function () {\n            return false;\n          },\n          _getGroupedView: function () {\n            if (this._isGroupedByDate()) {\n              return new kendo.ui.scheduler.TimelineGroupedByDateView(this);\n            } else {\n              return new kendo.ui.scheduler.TimelineGroupedView(this);\n            }\n          },\n          _getNextEventIndexBySlot: function (slot, sortedEvents, groupIndex) {\n            if (this._isVerticallyGrouped()) {\n              return kendo.ui.SchedulerView.fn._getNextEventIndexBySlot.call(this, slot, sortedEvents, groupIndex);\n            }\n\n            var tempIndex = 0;\n\n            for (var i = 0; i < sortedEvents.length; i++) {\n              if (slot.startDate() > sortedEvents[i].start.startDate()) {\n                tempIndex++;\n                continue;\n              }\n\n              if (slot.startDate().getTime() === sortedEvents[i].start.startDate().getTime() && groupIndex > sortedEvents[i].start.groupIndex) {\n                tempIndex++;\n                continue;\n              }\n\n              break;\n            }\n\n            return tempIndex;\n          },\n          _getSelectedSlot: function (slot, sortedEvents, event, idx, pad, prev) {\n            if (this._isVerticallyGrouped()) {\n              return kendo.ui.SchedulerView.fn._getSelectedSlot.call(this, slot, sortedEvents, event, idx, pad, prev);\n            }\n\n            return slot;\n          },\n          _getSortedEvents: function (uniqueAllEvents) {\n            if (this._isVerticallyGrouped()) {\n              return kendo.ui.SchedulerView.fn._getSortedEvents.call(this, uniqueAllEvents);\n            }\n\n            return uniqueAllEvents.sort(function (first, second) {\n              var result = first.start.startDate().getTime() - second.start.startDate().getTime();\n\n              if (result === 0) {\n                if (first.start.isDaySlot && !second.start.isDaySlot) {\n                  result = -1;\n                }\n\n                if (!first.start.isDaySlot && second.start.isDaySlot) {\n                  result = 1;\n                }\n              }\n\n              if (result === 0) {\n                result = first.start.groupIndex - second.start.groupIndex;\n              }\n\n              if (result === 0) {\n                result = $(first.element).index() - $(second.element).index();\n              }\n\n              return result;\n            });\n          },\n          _currentTimeMarkerUpdater: function () {\n            this._updateCurrentTimeMarker(new Date());\n          },\n          _scrollTo: function (element, container) {\n            SchedulerView.fn._scrollTo.call(this, element, container);\n\n            var elementOffset = element.offsetLeft,\n                elementOffsetDir = element.offsetWidth,\n                containerScroll = container.scrollLeft,\n                containerOffsetDir = container.clientWidth,\n                rightDistance = elementOffset + elementOffsetDir,\n                result = 0;\n\n            if (containerScroll > elementOffset) {\n              result = elementOffset;\n            } else if (rightDistance > containerScroll + containerOffsetDir) {\n              if (elementOffsetDir <= containerOffsetDir) {\n                result = rightDistance - containerOffsetDir;\n              } else {\n                result = elementOffset;\n              }\n            } else {\n              result = containerScroll;\n            }\n\n            container.scrollLeft = result;\n          },\n          _updateCurrentTimeMarker: function (currentTime) {\n            var options = this.options;\n            this.datesHeader.find(\".\" + CURRENT_TIME_MARKER_CLASS).remove();\n            this.times.find(\".\" + CURRENT_TIME_MARKER_CLASS).remove();\n            this.content.find(\".\" + CURRENT_TIME_MARKER_CLASS).remove();\n\n            if (!this._isInDateSlot({\n              start: currentTime,\n              end: currentTime\n            })) {\n              return;\n            }\n\n            if (options.currentTimeMarker.useLocalTimezone === false) {\n              var timezone = options.dataSource.options.schema.timezone;\n\n              if (options.dataSource && timezone) {\n                var timezoneOffset = kendo.timezone.offset(currentTime, timezone);\n                currentTime = kendo.timezone.convert(currentTime, currentTime.getTimezoneOffset(), timezoneOffset);\n              }\n            }\n\n            var groupsCount = !options.group || options.group.orientation == \"vertical\" ? 1 : this.groups.length;\n\n            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n              var currentGroup = this.groups[groupIndex];\n\n              if (!currentGroup) {\n                return;\n              }\n\n              var utcCurrentTime = kendo.date.toUtcTime(currentTime);\n              var ranges = currentGroup.timeSlotRanges(utcCurrentTime, utcCurrentTime + 1);\n\n              if (ranges.length === 0) {\n                return;\n              }\n\n              var collection = ranges[0].collection;\n              var slotElement = collection.slotByStartDate(currentTime);\n\n              if (slotElement) {\n                if (this._isVerticallyGrouped()) {\n                  this._groupedView._updateCurrentVerticalTimeMarker(ranges, currentTime);\n                } else {\n                  var elementHtml = \"<div class='\" + CURRENT_TIME_MARKER_CLASS + \"'></div>\";\n                  var headerWrap = this.datesHeader.find(\".\" + SCHEDULER_HEADER_WRAP_CLASS);\n                  var left = Math.round(ranges[0].innerRect(currentTime, new Date(currentTime.getTime() + 1), false).left);\n                  var timesTableMarker = $(elementHtml).prependTo(headerWrap).addClass(CURRENT_TIME_MARKER_ARROW_CLASS + \"-down\");\n                  timesTableMarker.css({\n                    left: this._adjustLeftPosition(left - outerWidth(timesTableMarker) * BORDER_SIZE_COEFF / 2),\n                    top: headerWrap.find(\"tr\").last().prev().position().top\n                  });\n                  $(elementHtml).prependTo(this.content).css({\n                    left: this._adjustLeftPosition(left),\n                    width: \"1px\",\n                    height: this.content[0].scrollHeight - 1,\n                    top: 0\n                  });\n                }\n              }\n            }\n          },\n          _adjustLeftPosition: function (left) {\n            return this._groupedView._adjustLeftPosition(left);\n          },\n          _currentTime: function (setUpdateTimer) {\n            var that = this;\n            var markerOptions = that.options.currentTimeMarker;\n\n            if (markerOptions !== false && markerOptions.updateInterval !== undefined) {\n              that._currentTimeMarkerUpdater();\n\n              if (setUpdateTimer) {\n                that._currentTimeUpdateTimer = setInterval(this._currentTimeMarkerUpdater.bind(that), markerOptions.updateInterval);\n              }\n            }\n          },\n          _editable: function () {\n            if (this.options.editable) {\n              if (this._isMobile()) {\n                this._touchEditable();\n              } else {\n                this._mouseEditable();\n              }\n            }\n          },\n          _mouseEditable: function () {\n            var that = this;\n            that.element.on(\"click\" + NS, \".k-event a:has(.k-i-close)\", function (e) {\n              that.trigger(\"remove\", {\n                uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n              });\n              e.preventDefault();\n            });\n\n            if (that.options.editable.create !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-scheduler-content td\", function (e) {\n                var slot = that._slotByPosition(e.pageX, e.pageY);\n\n                if (slot) {\n                  var resourceInfo = that._resourceBySlot(slot);\n\n                  that.trigger(\"add\", {\n                    eventInfo: extend({\n                      start: slot.startDate(),\n                      end: slot.endDate()\n                    }, resourceInfo)\n                  });\n                }\n\n                e.preventDefault();\n              });\n            }\n\n            if (that.options.editable.update !== false) {\n              that.element.on(\"dblclick\" + NS, \".k-event\", function (e) {\n                that.trigger(\"edit\", {\n                  uid: $(this).closest(\".k-event\").attr(kendo.attr(\"uid\"))\n                });\n                e.preventDefault();\n              });\n            }\n          },\n          _touchEditable: function () {\n            var that = this;\n            var threshold = 0;\n\n            if (kendo.support.mobileOS.android) {\n              threshold = 5;\n            }\n\n            if (that.options.editable.create !== false) {\n              that._addUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                useClickAsTap: !kendo.support.browser.edge,\n                filter: \".k-scheduler-content td\",\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  var x = e.x.location !== undefined ? e.x.location : e.x;\n                  var y = e.y.location !== undefined ? e.y.location : e.y;\n\n                  var slot = that._slotByPosition(x, y);\n\n                  if (slot) {\n                    var resourceInfo = that._resourceBySlot(slot);\n\n                    that.trigger(\"add\", {\n                      eventInfo: extend({\n                        start: slot.startDate(),\n                        end: slot.endDate()\n                      }, resourceInfo)\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              });\n            }\n\n            if (that.options.editable.update !== false) {\n              that._editUserEvents = new kendo.UserEvents(that.element, {\n                threshold: threshold,\n                useClickAsTap: !kendo.support.browser.edge,\n                filter: \".k-event\",\n                tap: function (e) {\n                  if (that._scrolling) {\n                    return;\n                  }\n\n                  var eventElement = $(e.target).closest(\".k-event\");\n                  var touchElement = $(e.touch.initialTouch);\n\n                  if (touchElement.hasClass(\"k-i-close\")) {\n                    that.trigger(\"remove\", {\n                      uid: eventElement.attr(kendo.attr(\"uid\"))\n                    });\n                  } else if (!eventElement.hasClass(\"k-event-active\")) {\n                    that.trigger(\"edit\", {\n                      uid: eventElement.attr(kendo.attr(\"uid\"))\n                    });\n                  }\n\n                  e.preventDefault();\n                }\n              });\n            }\n          },\n          _slotByPosition: function (x, y) {\n            var slot;\n            var content = this.content;\n            var offset = content.offset();\n            var groupIndex;\n            x -= offset.left;\n            y -= offset.top;\n\n            if (this._isRtl) {\n              var browser = kendo.support.browser;\n\n              if (browser.mozilla || browser.webkit && browser.version >= 85) {\n                x += content[0].scrollWidth - content[0].offsetWidth;\n                x += content[0].scrollLeft;\n              } else if (browser.msie) {\n                x -= kendo.scrollLeft(content);\n                x += content[0].scrollWidth - content[0].offsetWidth;\n              } else if (browser.webkit) {\n                x += content[0].scrollLeft;\n              }\n            } else {\n              x += content[0].scrollLeft;\n            }\n\n            y += content[0].scrollTop;\n            x = Math.ceil(x);\n            y = Math.ceil(y);\n\n            for (groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n              slot = this._groupedView._getTimeSlotByPosition(x, y, groupIndex);\n\n              if (slot) {\n                return slot;\n              }\n            }\n\n            return null;\n          },\n          options: {\n            name: \"TimelineView\",\n            title: \"Timeline\",\n            selectedDateFormat: \"{0:D}\",\n            selectedShortDateFormat: \"{0:d}\",\n            selectedMobileDateFormat: \"{0:MMM dd}\",\n            date: kendo.date.today(),\n            startTime: kendo.date.today(),\n            endTime: kendo.date.today(),\n            showWorkHours: false,\n            minorTickCount: 2,\n            editable: true,\n            workDayStart: new Date(1980, 1, 1, 8, 0, 0),\n            workDayEnd: new Date(1980, 1, 1, 17, 0, 0),\n            workWeekStart: 1,\n            workWeekEnd: 5,\n            majorTick: 60,\n            eventHeight: 25,\n            eventMinWidth: 0,\n            columnWidth: 100,\n            groupHeaderTemplate: \"#=text#\",\n            majorTimeHeaderTemplate: \"#=kendo.toString(date, 't')#\",\n            slotTemplate: \"&nbsp;\",\n            eventTemplate: EVENT_TEMPLATE,\n            dateHeaderTemplate: DATA_HEADER_TEMPLATE,\n            footer: {\n              command: \"workDay\"\n            },\n            currentTimeMarker: {\n              updateInterval: 10000,\n              useLocalTimezone: true\n            },\n            messages: {\n              defaultRowText: \"All events\",\n              showFullDay: \"Show full day\",\n              showWorkDay: \"Show business hours\"\n            }\n          },\n          events: [\"remove\", \"add\", \"edit\"],\n          _templates: function () {\n            var options = this.options,\n                settings = extend({}, kendo.Template, options.templateSettings);\n            this.eventTemplate = this._eventTmpl(options.eventTemplate, EVENT_WRAPPER_STRING);\n            this.majorTimeHeaderTemplate = kendo.template(options.majorTimeHeaderTemplate, settings);\n            this.dateHeaderTemplate = kendo.template(options.dateHeaderTemplate, settings);\n            this.slotTemplate = kendo.template(options.slotTemplate, settings);\n            this.groupHeaderTemplate = kendo.template(options.groupHeaderTemplate, settings);\n          },\n          _render: function (dates) {\n            var that = this;\n            dates = dates || [];\n            that._dates = dates;\n            that._startDate = dates[0];\n            that._endDate = dates[dates.length - 1 || 0];\n\n            that._calculateSlotRanges();\n\n            that.createLayout(that._layout(dates));\n\n            that._content(dates);\n\n            that._footer();\n\n            that._setContentWidth();\n\n            that.refreshLayout();\n            that.datesHeader.on(\"click\" + NS, \".k-nav-day\", function (e) {\n              var th = $(e.currentTarget).closest(\"th\");\n\n              var slot = that._slotByPosition(th.offset().left, that.content.offset().top);\n\n              that.trigger(\"navigate\", {\n                view: \"timeline\",\n                date: slot.startDate()\n              });\n            });\n\n            that._groupedView._hideHeaders();\n          },\n          _setContentWidth: function () {\n            var content = this.content;\n            var contentWidth = content.width();\n            var contentTable = this.content.find(\"table\");\n            var columnCount = contentTable.find(\"tr\").first().children().length;\n            var minWidth = 100;\n            var calculatedWidth = columnCount * this.options.columnWidth;\n\n            if (contentWidth < calculatedWidth) {\n              minWidth = Math.ceil(calculatedWidth / contentWidth * 100);\n            }\n\n            contentTable.add(this.datesHeader.find(\"table\")).css(\"width\", minWidth + \"%\");\n          },\n          _calculateSlotRanges: function () {\n            var dates = this._dates;\n            var slotStartTime = this.startTime();\n            var slotEndTime = this.endTime();\n            slotEndTime = getMilliseconds(slotEndTime);\n            slotStartTime = getMilliseconds(slotStartTime);\n\n            if (slotEndTime === slotStartTime) {\n              slotEndTime += MS_PER_DAY - 1;\n            } else if (slotEndTime < slotStartTime) {\n              slotEndTime += MS_PER_DAY;\n            }\n\n            var slotRanges = [];\n\n            for (var i = 0; i < dates.length; i++) {\n              var rangeStart = getDate(dates[i]);\n              setTime(rangeStart, slotStartTime);\n              var rangeEnd = getDate(dates[i]);\n              setTime(rangeEnd, slotEndTime);\n              slotRanges.push({\n                start: kendo.date.toUtcTime(rangeStart),\n                end: kendo.date.toUtcTime(rangeEnd)\n              });\n            }\n\n            this._slotRanges = slotRanges;\n          },\n          _forTimeRange: function (min, max, action, verticalByDate, groupsCount) {\n            min = toInvariantTime(min); //convert the date to 1/2/1980 and sets the time\n\n            max = toInvariantTime(max);\n            var that = this,\n                msMin = getMilliseconds(min),\n                msMax = getMilliseconds(max),\n                minorTickCount = that.options.minorTickCount,\n                msMajorInterval = that.options.majorTick * MS_PER_MINUTE,\n                msInterval = msMajorInterval / minorTickCount || 1,\n                start = new Date(+min),\n                idx = 0,\n                length,\n                html = \"\";\n            length = MS_PER_DAY / msInterval;\n\n            if (msMin != msMax) {\n              if (msMin > msMax) {\n                msMax += MS_PER_DAY;\n              }\n\n              length = (msMax - msMin) / msInterval;\n            }\n\n            length = verticalByDate ? 1 : Math.round(length);\n\n            if (groupsCount) {\n              length = length * groupsCount;\n            }\n\n            for (; idx < length; idx++) {\n              var majorTickDivider = idx % (msMajorInterval / msInterval);\n              var isMajorTickColumn = majorTickDivider === 0;\n              var isMiddleColumn = majorTickDivider < minorTickCount - 1;\n              var isLastSlotColumn = majorTickDivider === minorTickCount - 1;\n              var minorTickColumns = minorTickCount;\n\n              if (length % minorTickCount !== 0) {\n                var isLastMajorSlot = length - (idx + 1) < minorTickCount;\n\n                if (isMajorTickColumn && isLastMajorSlot) {\n                  minorTickColumns = length % minorTickCount;\n                }\n              }\n\n              html += action(start, isMajorTickColumn, isMiddleColumn, isLastSlotColumn, minorTickColumns, idx % groupsCount);\n\n              if (!verticalByDate) {\n                if (groupsCount) {\n                  if (idx % groupsCount === groupsCount - 1) {\n                    setTime(start, msInterval, false);\n                  }\n                } else {\n                  setTime(start, msInterval, false);\n                }\n              }\n            }\n\n            return html;\n          },\n          _layout: function (dates) {\n            var timeColumns = [];\n            var columns = [];\n            var that = this;\n            var rows = [{\n              text: that.options.messages.defaultRowText\n            }];\n            var groupedView = that._groupedView;\n            var minorTickSlots = [];\n\n            for (var minorTickIndex = 0; minorTickIndex < that.options.minorTickCount; minorTickIndex++) {\n              minorTickSlots.push({\n                text: \"&#8203;\",\n                className: \"k-last\",\n                minorTicks: true\n              });\n            }\n\n            this._forTimeRange(that.startTime(), that.endTime(), function (date, majorTick, middleColumn, lastSlotColumn, minorSlotsCount) {\n              var template = that.majorTimeHeaderTemplate;\n\n              if (majorTick) {\n                var timeColumn = {\n                  text: template({\n                    date: date\n                  }),\n                  className: lastSlotColumn ? \"k-slot-cell\" : \"\",\n                  columns: minorTickSlots.slice(0, minorSlotsCount)\n                };\n\n                groupedView._setColspan(timeColumn);\n\n                timeColumns.push(timeColumn);\n              }\n            });\n\n            for (var idx = 0; idx < dates.length; idx++) {\n              columns.push({\n                text: that.dateHeaderTemplate({\n                  date: dates[idx]\n                }),\n                className: \"k-slot-cell\",\n                columns: timeColumns.slice(0)\n              });\n            }\n\n            var resources = this.groupedResources;\n\n            if (resources.length) {\n              if (this._groupOrientation() === \"vertical\") {\n                rows = groupedView._createRowsLayout(resources, null, this.groupHeaderTemplate, columns);\n                columns = groupedView._createVerticalColumnsLayout(resources, null, this.groupHeaderTemplate, columns);\n              } else {\n                columns = groupedView._createColumnsLayout(resources, columns, this.groupHeaderTemplate, columns);\n              }\n            }\n\n            return {\n              columns: columns,\n              rows: rows\n            };\n          },\n          _footer: function () {\n            var options = this.options;\n\n            if (options.footer !== false) {\n              var html = '<div class=\"k-scheduler-footer k-toolbar\">';\n              var command = options.footer.command;\n\n              if (this._isMobile()) {\n                html += '<span class=\"k-scheduler-today\"><a tabindex=\"-1\" href=\"#\" class=\"k-link\">';\n                html += options.messages.today + '</a></span>';\n              }\n\n              if (command && command === \"workDay\") {\n                if (this._isMobile()) {\n                  html += '<span class=\"k-scheduler-fullday\"><a tabindex=\"-1\" href=\"#\" class=\"k-link\">';\n                  html += (options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay) + '</a></span>';\n                } else {\n                  html += '<button tabindex=\"-1\" type=\"button\" class=\"k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-scheduler-fullday\">';\n                  html += '<span class=\"k-button-icon k-icon k-i-clock\"></span>';\n                  html += '<span class=\"k-button-text\">';\n                  html += options.showWorkHours ? options.messages.showFullDay : options.messages.showWorkDay;\n                  html += '</span>';\n                  html += '</button>';\n                }\n              }\n\n              html += \"</div>\";\n              this.footer = $(html).appendTo(this.element);\n              var that = this;\n              this.footer.on(\"click\" + NS, \".k-scheduler-fullday\", function (e) {\n                e.preventDefault();\n                that.toggleFullDay();\n              });\n              this.footer.on(\"click\" + NS, \".k-scheduler-today\", function (e) {\n                e.preventDefault();\n                var timezone = that.options.timezone;\n                var action = \"today\";\n                var currentDate = new Date();\n                var date;\n\n                if (timezone) {\n                  var timezoneOffset = kendo.timezone.offset(currentDate, timezone);\n                  date = kendo.timezone.convert(currentDate, currentDate.getTimezoneOffset(), timezoneOffset);\n                } else {\n                  date = currentDate;\n                }\n\n                that.trigger(\"navigate\", {\n                  view: that.name || options.name,\n                  action: action,\n                  date: date\n                });\n              });\n            }\n          },\n          toggleFullDay: function () {\n            var options = this.options;\n            this.trigger(\"navigate\", {\n              view: this.name || options.name,\n              date: options.date,\n              isWorkDay: !options.showWorkHours\n            });\n          },\n          _columnCountForLevel: function (level) {\n            var columnLevel = this.columnLevels[level];\n            return columnLevel ? columnLevel.length : 0;\n          },\n          _rowCountForLevel: function (level) {\n            var rowLevel = this.rowLevels[level];\n            return rowLevel ? rowLevel.length : 0;\n          },\n          _isWorkDay: function (date) {\n            var day = date.getDay();\n            var workDays = this._workDays;\n\n            for (var i = 0; i < workDays.length; i++) {\n              if (workDays[i] === day) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _content: function (dates) {\n            var that = this;\n            var start = that.startTime();\n            var end = this.endTime();\n            var groupsCount = 1;\n            var rowCount = 1;\n            var columnCount = dates.length;\n            var html = '';\n            var resources = this.groupedResources;\n            var slotTemplate = this.slotTemplate;\n            var isVerticalGrouped = false;\n\n            if (resources.length) {\n              isVerticalGrouped = that._groupOrientation() === \"vertical\";\n\n              if (isVerticalGrouped) {\n                rowCount = that._groupedView._getRowCount(this.rowLevels.length - 1);\n                groupsCount = that._groupedView._getGroupsCount();\n              } else {\n                groupsCount = that._groupCount();\n              }\n            }\n\n            html += '<tbody>';\n            html += that._groupedView._addContent(dates, columnCount, groupsCount, rowCount, start, end, slotTemplate, isVerticalGrouped);\n            html += '</tbody>';\n            this.content.find(\"table\").append(html);\n          },\n          _groups: function () {\n            var groupCount = this._groupCount();\n\n            var dates = this._dates;\n            var columnCount = dates.length;\n            this.groups = [];\n\n            for (var idx = 0; idx < groupCount; idx++) {\n              var view = this._addResourceView(idx);\n\n              var start = dates[0];\n              var end = dates[dates.length - 1 || 0];\n              var startTime = getMilliseconds(this.startTime());\n              var endTime = getMilliseconds(this.endTime());\n\n              if (startTime !== 0 && endTime <= startTime) {\n                start = getDate(start);\n                setTime(start, startTime);\n                end = getDate(end);\n                setTime(end, endTime);\n              }\n\n              view.addTimeSlotCollection(start, kendo.date.addDays(end, 1));\n            }\n\n            this._timeSlotGroups(groupCount, columnCount);\n          },\n          _isHorizontallyGrouped: function () {\n            return this.groupedResources.length && this._groupOrientation() === \"horizontal\";\n          },\n          _timeSlotGroups: function (groupCount, datesCount) {\n            var interval = this._timeSlotInterval();\n\n            var isVerticallyGrouped = this._isVerticallyGrouped();\n\n            var tableRows = this.content.find(\"tr\");\n\n            this._groupedView._addTimeSlotsCollections(groupCount, datesCount, tableRows, interval, isVerticallyGrouped);\n          },\n          _addTimeSlotToCollection: function (group, cells, cellIndex, cellOffset, dateIndex, time, interval) {\n            var cell = cells[cellIndex + cellOffset];\n            var collection = group.getTimeSlotCollection(0);\n            var currentDate = this._dates[dateIndex];\n            var currentTime = Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());\n            var start = currentTime + time;\n            var end = start + interval;\n            collection.addTimeSlot(cell, start, end, true);\n          },\n          startDate: function () {\n            return this._startDate;\n          },\n          endDate: function () {\n            return this._endDate;\n          },\n          visibleEndDate: function () {\n            var startTime = getMilliseconds(this.startTime());\n            var endTime = getMilliseconds(this.endTime());\n            var endDate = this.endDate();\n\n            if (startTime !== 0 && endTime <= startTime) {\n              endDate = kendo.date.addDays(endDate, 1);\n            }\n\n            return endDate;\n          },\n          startTime: function () {\n            var options = this.options;\n            return options.showWorkHours ? options.workDayStart : options.startTime;\n          },\n          endTime: function () {\n            var options = this.options;\n            return options.showWorkHours ? options.workDayEnd : options.endTime;\n          },\n          _timeSlotInterval: function () {\n            var options = this.options;\n            return options.majorTick / options.minorTickCount * MS_PER_MINUTE;\n          },\n          nextDate: function () {\n            return kendo.date.nextDay(this.endDate());\n          },\n          previousDate: function () {\n            return kendo.date.previousDay(this.startDate());\n          },\n          calculateDateRange: function () {\n            this._render([this.options.date]);\n          },\n          render: function (events) {\n            this._headerColumnCount = 0;\n\n            this._groups();\n\n            this.element.find(\".k-event\").remove();\n            events = new kendo.data.Query(events).sort([{\n              field: \"start\",\n              dir: \"asc\"\n            }, {\n              field: \"end\",\n              dir: \"desc\"\n            }]).toArray();\n            var eventsByResource = [];\n\n            this._eventsByResource(events, this.groupedResources, eventsByResource);\n\n            var eventGroups = [];\n            var maxRowCount = 0;\n\n            for (var groupIndex = 0; groupIndex < eventsByResource.length; groupIndex++) {\n              var eventGroup = {\n                groupIndex: groupIndex,\n                maxRowCount: 0,\n                events: {}\n              };\n              eventGroups.push(eventGroup);\n\n              this._renderEvents(eventsByResource[groupIndex], groupIndex, eventGroup);\n\n              if (maxRowCount < eventGroup.maxRowCount) {\n                maxRowCount = eventGroup.maxRowCount;\n              }\n            }\n\n            this._setRowsHeight(eventGroups, eventsByResource.length, maxRowCount);\n\n            this._positionEvents(eventGroups, eventsByResource.length);\n\n            this._currentTime(false);\n\n            this.trigger(\"activate\");\n          },\n          _positionEvents: function (eventGroups, groupsCount) {\n            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n              var eventsForGroup = eventGroups[groupIndex].events;\n\n              for (var eventUid in eventsForGroup) {\n                var eventObject = eventsForGroup[eventUid];\n\n                if (Array.isArray(eventObject)) {\n                  for (var eventIndex = 0; eventIndex < eventObject.length; eventIndex++) {\n                    this._positionEvent(eventObject[eventIndex]);\n                  }\n                } else {\n                  this._positionEvent(eventObject);\n                }\n              }\n            }\n          },\n          _setRowsHeight: function (eventGroups, groupsCount, maxRowCount) {\n            var eventHeight = this.options.eventHeight;\n\n            var eventBottomOffset = this._getBottomRowOffset();\n\n            var groupedView = this._groupedView;\n\n            var verticalGroupCount = groupedView._getVerticalGroupCount(groupsCount);\n\n            groupsCount = this._isVerticallyGrouped() ? verticalGroupCount : 1;\n\n            for (var groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n              var rowsCount = groupedView._getVerticalRowCount(eventGroups, groupIndex, maxRowCount);\n\n              rowsCount = rowsCount ? rowsCount : 1;\n              var rowHeight = (eventHeight + 2) * rowsCount + eventBottomOffset;\n              var timesRow = $(this.times.find(\"tr\")[groupIndex]);\n              var row = $(this.content.find(\"tr\")[groupIndex]);\n              timesRow.height(rowHeight);\n              row.height(rowHeight);\n            }\n\n            this._setContentWidth();\n\n            this.refreshLayout();\n\n            this._refreshSlots();\n          },\n          _getBottomRowOffset: function () {\n            var eventBottomOffset = this.options.eventHeight * 0.50;\n\n            var isMobile = this._isMobile();\n\n            var minOffset;\n            var maxOffset;\n\n            if (isMobile) {\n              minOffset = 30;\n              maxOffset = 60;\n            } else {\n              minOffset = 15;\n              maxOffset = 30;\n            }\n\n            if (eventBottomOffset > maxOffset) {\n              eventBottomOffset = maxOffset;\n            } else if (eventBottomOffset < minOffset) {\n              eventBottomOffset = minOffset;\n            }\n\n            return eventBottomOffset;\n          },\n          _positionEvent: function (eventObject) {\n            var eventHeight = this.options.eventHeight;\n            var eventOffset = 2;\n            var rect = eventObject.slotRange.innerRect(eventObject.start, eventObject.end, false);\n\n            var left = this._adjustLeftPosition(rect.left);\n\n            var width = rect.right - rect.left;\n\n            if (width < 0) {\n              width = 0;\n            }\n\n            if (width < this.options.eventMinWidth) {\n              var slotsCollection = eventObject.slotRange.collection;\n              var lastSlot = slotsCollection._slots[slotsCollection._slots.length - 1];\n              var offsetRight = lastSlot.offsetLeft + lastSlot.offsetWidth;\n              width = this.options.eventMinWidth;\n\n              if (offsetRight < left + width) {\n                width = offsetRight - rect.left;\n              }\n            }\n\n            eventObject.element.css({\n              top: eventObject.slotRange.start.offsetTop + eventObject.rowIndex * (eventHeight + eventOffset) + \"px\",\n              left: left,\n              width: width\n            });\n          },\n          _refreshSlots: function () {\n            for (var groupIndex = 0; groupIndex < this.groups.length; groupIndex++) {\n              this.groups[groupIndex].refresh();\n            }\n          },\n          _eventsByResource: function (events, resources, result, parentValue) {\n            var resource = resources[0];\n\n            if (resource) {\n              var view = resource.dataSource.view();\n              view = view.filter(function (item) {\n                var itemParentValue = kendo.getter(resource.dataParentValueField)(item);\n                return itemParentValue === null || itemParentValue === undefined || itemParentValue === parentValue;\n              });\n\n              for (var itemIdx = 0; itemIdx < view.length; itemIdx++) {\n                var value = this._resourceValue(resource, view[itemIdx]);\n\n                var eventsFilteredByResource = new kendo.data.Query(events).filter({\n                  field: resource.field,\n                  operator: SchedulerView.groupEqFilter(value)\n                }).toArray();\n\n                if (resources.length > 1) {\n                  this._eventsByResource(eventsFilteredByResource, resources.slice(1), result, value);\n                } else {\n                  result.push(eventsFilteredByResource);\n                }\n              }\n            } else {\n              result.push(events);\n            }\n          },\n          _isInDateSlot: function (event) {\n            var startTime = event.start;\n            var endTime = event.end;\n            var rangeStart = getDate(this._startDate);\n            var rangeEnd = kendo.date.addDays(getDate(this.visibleEndDate()), 1);\n\n            if (startTime < rangeEnd && rangeStart <= endTime) {\n              return true;\n            }\n\n            return false;\n          },\n          _isInTimeSlot: function (event) {\n            var startTime = event._startTime || kendo.date.toUtcTime(event.start);\n            var endTime = event._endTime || kendo.date.toUtcTime(event.end);\n            var slotRanges = this._slotRanges;\n\n            if (startTime === endTime) {\n              endTime = endTime + 1;\n            }\n\n            for (var slotIndex = 0; slotIndex < slotRanges.length; slotIndex++) {\n              if (startTime < slotRanges[slotIndex].end && slotRanges[slotIndex].start < endTime) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _adjustEvent: function (event) {\n            var start = event.start;\n            var end = event.end;\n\n            var eventStartTime = event._time(\"start\");\n\n            var eventEndTime = event._time(\"end\");\n\n            var startTime = getMilliseconds(this.startTime());\n            var endTime = getMilliseconds(this.endTime());\n            var adjustedStartDate = null;\n            var adjustedEndDate = null;\n            var occurrence;\n            var head = false;\n            var tail = false;\n\n            if (event.isAllDay) {\n              start = getDate(start);\n              eventStartTime = 0;\n              end = getDate(end);\n              eventEndTime = MS_PER_DAY;\n              adjustedEndDate = kendo.date.addDays(end, 1);\n            }\n\n            if (endTime === 0) {\n              endTime = MS_PER_DAY;\n            }\n\n            if (endTime <= startTime) {\n              if (eventStartTime < startTime && eventStartTime >= endTime) {\n                adjustedStartDate = getDate(start);\n                setTime(adjustedStartDate, startTime);\n                tail = true;\n              }\n\n              if (eventEndTime > endTime && eventEndTime <= startTime) {\n                adjustedEndDate = getDate(end);\n                setTime(adjustedEndDate, endTime);\n                head = true;\n              }\n            } else {\n              if (startTime > eventStartTime) {\n                adjustedStartDate = getDate(start);\n                setTime(adjustedStartDate, startTime);\n                tail = true;\n              } else if (endTime <= eventStartTime) {\n                adjustedStartDate = getDate(start);\n                adjustedStartDate = kendo.date.addDays(adjustedStartDate, 1);\n                setTime(adjustedStartDate, startTime);\n                tail = true;\n              }\n\n              if (endTime < eventEndTime) {\n                adjustedEndDate = getDate(end);\n                setTime(adjustedEndDate, endTime);\n                head = true;\n              } else if (startTime > eventEndTime) {\n                adjustedEndDate = getDate(end);\n                adjustedEndDate = kendo.date.addDays(adjustedEndDate, -1);\n                setTime(adjustedEndDate, endTime);\n                head = true;\n              }\n            }\n\n            occurrence = event.clone({\n              start: adjustedStartDate ? adjustedStartDate : start,\n              end: adjustedEndDate ? adjustedEndDate : end,\n              _startTime: adjustedStartDate ? kendo.date.toUtcTime(adjustedStartDate) : event._startTime,\n              _endTime: adjustedEndDate ? kendo.date.toUtcTime(adjustedEndDate) : event._endTime,\n              isAllDay: false\n            });\n            return {\n              occurrence: occurrence,\n              head: head,\n              tail: tail\n            };\n          },\n          _renderEvents: function (events, groupIndex, eventGroup) {\n            var event;\n            var idx;\n            var length;\n\n            for (idx = 0, length = events.length; idx < length; idx++) {\n              event = events[idx];\n\n              if (this._isInDateSlot(event)) {\n                var isMultiDayEvent = event.isAllDay || event.duration() >= MS_PER_DAY;\n                var container = this.content;\n\n                if (isMultiDayEvent || this._isInTimeSlot(event)) {\n                  var adjustedEvent = this._adjustEvent(event);\n\n                  var group = this.groups[groupIndex];\n\n                  if (!group._continuousEvents) {\n                    group._continuousEvents = [];\n                  }\n\n                  if (this._isInTimeSlot(adjustedEvent.occurrence)) {\n                    var ranges = group.slotRanges(adjustedEvent.occurrence, false);\n                    var range = ranges[0];\n                    var startIndex = range.start.index;\n                    var endIndex = range.end.index;\n\n                    this._groupedView._renderEvent(eventGroup, event, adjustedEvent, group, range, container, startIndex, endIndex);\n                  }\n                }\n              }\n            }\n          },\n          addContinuousEvent: function (group, range, element, isAllDay) {\n            var events = group._continuousEvents;\n            events.push({\n              element: element,\n              isAllDay: isAllDay,\n              uid: element.attr(kendo.attr(\"uid\")),\n              start: range.start,\n              end: range.end\n            });\n          },\n          _createEventElement: function (occurrence, event, head, tail) {\n            var template = this.eventTemplate;\n            var editable = this.options.editable;\n\n            var isMobile = this._isMobile();\n\n            var showDelete = editable && editable.destroy !== false && !isMobile;\n            var resizable = editable && editable.resize !== false;\n\n            var eventStartTime = event._time(\"start\");\n\n            var eventEndTime = event._time(\"end\");\n\n            var eventStartDate = event.start;\n            var eventEndDate = event.end;\n            var resources = this.eventResources(event);\n\n            if (event._startTime && eventStartTime !== kendo.date.getMilliseconds(event.start)) {\n              eventStartDate = new Date(eventStartTime);\n              eventStartDate = kendo.timezone.apply(eventStartDate, \"Etc/UTC\");\n            }\n\n            if (event._endTime && eventEndTime !== kendo.date.getMilliseconds(event.end)) {\n              eventEndDate = new Date(eventEndTime);\n              eventEndDate = kendo.timezone.apply(eventEndDate, \"Etc/UTC\");\n            }\n\n            var data = extend({}, {\n              ns: kendo.ns,\n              resizable: resizable,\n              showDelete: showDelete,\n              head: head,\n              tail: tail,\n              singleDay: this._dates.length == 1,\n              resources: resources,\n              inverseColor: false,\n              messages: this.options.messages,\n              ariaLabel: this._formatEventAriaLabel(event.title, eventStartDate, eventEndDate, event.isAllDay)\n            }, event, {\n              start: eventStartDate,\n              end: eventEndDate\n            });\n            var element = $(template(data));\n            this.angular(\"compile\", function () {\n              return {\n                elements: element,\n                data: [{\n                  dataItem: data\n                }]\n              };\n            });\n            return element;\n          },\n          _arrangeRows: function (eventObject, slotRange, eventGroup) {\n            var startIndex = slotRange.start.index;\n            var endIndex = slotRange.end.index;\n            var rect = eventObject.slotRange.innerRect(eventObject.start, eventObject.end, false);\n            var rectRight = rect.right + this.options.eventMinWidth;\n            var events = collidingEvents(slotRange.events(), rect.left, rectRight);\n            slotRange.addEvent({\n              slotIndex: startIndex,\n              start: startIndex,\n              end: endIndex,\n              rectLeft: rect.left,\n              rectRight: rectRight,\n              element: eventObject.element,\n              uid: eventObject.uid\n            });\n            events.push({\n              start: startIndex,\n              end: endIndex,\n              uid: eventObject.uid\n            });\n            var rows = SchedulerView.createRows(events);\n\n            if (eventGroup.maxRowCount < rows.length) {\n              eventGroup.maxRowCount = rows.length;\n            }\n\n            for (var idx = 0, length = rows.length; idx < length; idx++) {\n              var rowEvents = rows[idx].events;\n\n              for (var j = 0, eventLength = rowEvents.length; j < eventLength; j++) {\n                eventGroup.events[rowEvents[j].uid].rowIndex = idx;\n              }\n            }\n          },\n          _groupCount: function () {\n            var resources = this.groupedResources;\n            var groupedView = this._groupedView;\n\n            if (resources.length) {\n              if (this._groupOrientation() === \"vertical\") {\n                return groupedView._verticalCountForLevel(resources.length - 1);\n              } else {\n                return groupedView._horizontalCountForLevel(resources.length - 1, this.columnLevels.length - 1);\n              }\n            }\n\n            return 1;\n          },\n          _updateEventForSelection: function (event) {\n            var adjustedEvent = this._adjustEvent(event.clone());\n\n            return adjustedEvent.occurrence;\n          },\n          _eventOptionsForMove: function (event) {\n            if (event.isAllDay) {\n              return {\n                isAllDay: false\n              };\n            }\n\n            return {};\n          },\n          _updateEventForResize: function (event) {\n            if (event.isAllDay) {\n              event.set(\"isAllDay\", false);\n            }\n          },\n          _updateMoveHint: function (event, groupIndex, distance) {\n            var group = this.groups[groupIndex];\n            var clonedEvent = event.clone({\n              start: event.start,\n              end: event.end\n            });\n            var eventDuraton = clonedEvent.duration();\n            clonedEvent.start = new Date(clonedEvent.start.getTime() + distance);\n            clonedEvent.end = new Date(+clonedEvent.start + eventDuraton);\n\n            this._removeMoveHint(event.uid);\n\n            if (this._isInDateSlot(clonedEvent)) {\n              if (clonedEvent.isAllDay || clonedEvent.duration() >= MS_PER_DAY || this._isInTimeSlot(clonedEvent)) {\n                var adjustedEvent = this._adjustEvent(clonedEvent);\n\n                var ranges = group.slotRanges(adjustedEvent.occurrence, false);\n\n                for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n                  this._groupedView._createMoveHint(ranges[rangeIndex], adjustedEvent);\n                }\n              }\n            }\n          },\n          _appendMoveHint: function (hint) {\n            hint.appendTo(this.content);\n            this._moveHint = this._moveHint.add(hint);\n          },\n          _updateResizeHint: function (event, groupIndex, startTime, endTime) {\n            var group = this.groups[groupIndex];\n            var ranges = group.ranges(startTime, endTime, false, false);\n\n            this._removeResizeHint();\n\n            for (var rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {\n              var range = ranges[rangeIndex];\n              var start = range.startSlot();\n              var startRect = range.innerRect(startTime, endTime, false);\n              startRect.top = start.offsetTop;\n              var width = startRect.right - startRect.left;\n\n              if (width < 0) {\n                for (var i = 0; i < range.events().length; i++) {\n                  if (range.events()[i].uid === event.uid) {\n                    width = range.events()[i].rectRight - startRect.left;\n                    break;\n                  }\n                }\n              }\n\n              var height = range.endSlot().offsetTop + start.offsetHeight - startRect.top;\n\n              var left = this._adjustLeftPosition(startRect.left);\n\n              var hint = SchedulerView.fn._createResizeHint.call(this, left, startRect.top, width, height);\n\n              this._resizeHint = this._resizeHint.add(hint);\n            }\n\n            var format = \"t\";\n            var container = this.content;\n\n            this._resizeHint.appendTo(container);\n\n            this._resizeHint.find(\".k-label-top,.k-label-bottom\").text(\"\");\n\n            this._resizeHint.first().addClass(\"k-first\").find(\".k-label-top\").text(kendo.toString(kendo.timezone.toLocalDate(startTime), format));\n\n            this._resizeHint.last().addClass(\"k-last\").find(\".k-label-bottom\").text(kendo.toString(kendo.timezone.toLocalDate(endTime), format));\n          },\n          selectionByElement: function (cell) {\n            var offset = cell.offset();\n            return this._slotByPosition(offset.left, offset.top);\n          },\n          _updateDirection: function (selection, ranges, multiple, reverse, vertical) {\n            var startSlot = ranges[0].start;\n            var endSlot = ranges[ranges.length - 1].end;\n\n            if (multiple && !vertical) {\n              if (startSlot.index === endSlot.index && startSlot.collectionIndex === endSlot.collectionIndex) {\n                selection.backward = reverse;\n              }\n            }\n          },\n          _changeGroup: function (selection, previous) {\n            var method = previous ? \"prevGroupSlot\" : \"nextGroupSlot\";\n            var slot = this[method](selection.start, selection.groupIndex, false);\n\n            if (slot) {\n              selection.groupIndex += previous ? -1 : 1;\n            }\n\n            this._groupedView._changeGroup(selection, previous, slot);\n\n            return slot;\n          },\n          prevGroupSlot: function (date, groupIndex, isDay) {\n            var group = this.groups[groupIndex];\n            var slot = group.ranges(date, date, isDay, false)[0].start;\n\n            if (groupIndex <= 0) {\n              return;\n            }\n\n            return this._groupedView._prevGroupSlot(slot, group, isDay);\n          },\n          nextGroupSlot: function (date, groupIndex, isDay) {\n            var group = this.groups[groupIndex];\n            var slot = group.ranges(date, date, isDay, false)[0].start;\n\n            if (groupIndex >= this.groups.length - 1) {\n              return;\n            }\n\n            return this._groupedView._nextGroupSlot(slot, group, isDay);\n          },\n          _verticalSlots: function (selection, ranges, multiple, reverse) {\n            var groupedView = this._groupedView;\n\n            var method = groupedView._verticalMethod(reverse, multiple);\n\n            var startSlot = ranges[0].start;\n            var endSlot = ranges[ranges.length - 1].end;\n            var group = this.groups[selection.groupIndex];\n\n            var slot = groupedView._normalizeVerticalSelection(selection, ranges, reverse, multiple);\n\n            if (slot) {\n              startSlot = endSlot = slot;\n            }\n\n            startSlot = group[method](startSlot);\n            endSlot = group[method](endSlot);\n\n            if (!multiple && this._isVerticallyGrouped() && (!startSlot || !endSlot)) {\n              startSlot = endSlot = groupedView._verticalSlots(selection, reverse, slot);\n            }\n\n            return {\n              startSlot: startSlot,\n              endSlot: endSlot\n            };\n          },\n          _horizontalSlots: function (selection, ranges, multiple, reverse) {\n            var method = reverse ? \"upSlot\" : \"downSlot\";\n            var startSlot = ranges[0].start;\n            var endSlot = ranges[ranges.length - 1].end;\n            var group = this.groups[selection.groupIndex];\n            var result = {};\n\n            if (!multiple) {\n              result = this._groupedView._horizontalSlots(selection, group, method, startSlot, endSlot, multiple, reverse);\n            } else {\n              result.startSlot = group[method](startSlot);\n              result.endSlot = group[method](endSlot);\n\n              if (!multiple && this._isHorizontallyGrouped() && (!startSlot || !endSlot)) {\n                result.startSlot = result.endSlot = this._changeGroup(selection, reverse);\n              }\n            }\n\n            return result;\n          },\n          _changeViewPeriod: function (selection, reverse) {\n            var date = reverse ? this.previousDate() : this.nextDate();\n            var start = selection.start;\n            var end = selection.end;\n            var newStart, newEnd;\n            newStart = new Date(date);\n            newEnd = new Date(date);\n\n            if (this._isInRange(newStart, newEnd)) {\n              return false;\n            }\n\n            selection.start = newStart;\n            selection.end = newEnd;\n\n            if (this._isHorizontallyGrouped()) {\n              selection.groupIndex = reverse ? this.groups.length - 1 : 0;\n            }\n\n            var duration = end - start;\n\n            if (reverse) {\n              end = getMilliseconds(this.endTime());\n              end = end === 0 ? MS_PER_DAY : end;\n              setTime(selection.start, end - duration);\n              setTime(selection.end, end);\n            } else {\n              start = getMilliseconds(this.startTime());\n              setTime(selection.start, start);\n              setTime(selection.end, start + duration);\n            }\n\n            selection.events = [];\n            return true;\n          },\n          move: function (selection, key, shift) {\n            var handled = false;\n            var group = this.groups[selection.groupIndex];\n            var keys = kendo.keys;\n            var groupedView = this._groupedView;\n            var ranges = group.ranges(selection.start, selection.end, false, false);\n            var startSlot, endSlot, reverse, slots;\n\n            if (key === keys.DOWN || key === keys.UP) {\n              handled = true;\n              reverse = key === keys.UP;\n\n              groupedView._updateDirection(selection, ranges, shift, reverse);\n\n              slots = this._verticalSlots(selection, ranges, shift, reverse);\n\n              if (groupedView._changeVerticalViewPeriod(slots, shift, selection, reverse)) {\n                return handled;\n              }\n            } else if (key === keys.LEFT || key === keys.RIGHT) {\n              handled = true;\n              reverse = key === keys.LEFT;\n\n              this._updateDirection(selection, ranges, shift, reverse, false);\n\n              slots = this._horizontalSlots(selection, ranges, shift, reverse);\n\n              if (groupedView._changeHorizontalViewPeriod(slots, shift, selection, reverse)) {\n                return handled;\n              }\n            }\n\n            if (handled) {\n              startSlot = slots.startSlot;\n              endSlot = slots.endSlot;\n\n              if (shift) {\n                var backward = selection.backward;\n\n                if (backward && startSlot) {\n                  selection.start = startSlot.startDate();\n                } else if (!backward && endSlot) {\n                  selection.end = endSlot.endDate();\n                }\n              } else if (startSlot && endSlot) {\n                selection.start = startSlot.startDate();\n                selection.end = endSlot.endDate();\n              }\n\n              selection.events = [];\n            }\n\n            return handled;\n          },\n          destroy: function () {\n            var that = this;\n\n            if (that.element) {\n              that.element.off(NS);\n            }\n\n            if (that.footer) {\n              that.footer.remove();\n            }\n\n            if (that._currentTimeUpdateTimer) {\n              clearInterval(that._currentTimeUpdateTimer);\n            }\n\n            SchedulerView.fn.destroy.call(this);\n\n            if (this._isMobile() && that.options.editable) {\n              if (that.options.editable.create !== false) {\n                that._addUserEvents.destroy();\n              }\n\n              if (that.options.editable.update !== false) {\n                that._editUserEvents.destroy();\n              }\n            }\n          },\n          _resourceBySlot: function (slot) {\n            var resources = this.groupedResources;\n            var result = {},\n                groupOptions = this.options.group;\n\n            if (resources.length && groupOptions.orientation === \"horizontal\" && groupOptions.date) {\n              var resourceIndex = slot.groupIndex,\n                  levels = this.columnLevels,\n                  groupLevel = levels[levels.length - 1],\n                  resource = resources[resources.length - 1],\n                  groupLevelMember = groupLevel[resourceIndex],\n                  passedChildren,\n                  numberOfChildren,\n                  j,\n                  i;\n\n              this._setResourceValue(groupLevelMember, resource, result);\n\n              for (j = levels.length - 2; j >= 3; j--) {\n                groupLevel = levels[j];\n                resource = resources[j - 3];\n                passedChildren = 0;\n\n                for (i = 0; i < groupLevel.length; i++) {\n                  groupLevelMember = groupLevel[i];\n                  numberOfChildren = groupLevelMember.columns.length;\n\n                  if (numberOfChildren > resourceIndex - passedChildren) {\n                    this._setResourceValue(groupLevelMember, resource, result);\n\n                    i = groupLevel.length;\n                  } else {\n                    passedChildren += numberOfChildren;\n                  }\n                }\n              }\n\n              return result;\n            } else {\n              return SchedulerView.fn._resourceBySlot.call(this, slot);\n            }\n          }\n        });\n        extend(true, ui, {\n          TimelineView: TimelineView,\n          TimelineWeekView: TimelineView.extend({\n            options: {\n              name: \"TimelineWeekView\",\n              title: \"Timeline Week\",\n              selectedDateFormat: \"{0:D} - {1:D}\",\n              selectedShortDateFormat: \"{0:d} - {1:d}\",\n              selectedMobileDateFormat: \"{0:MMM dd} - {1:dd}\",\n              majorTick: 120\n            },\n            name: \"timelineWeek\",\n            calculateDateRange: function () {\n              var selectedDate = this.options.date,\n                  start = kendo.date.dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n                  idx,\n                  length,\n                  dates = [];\n\n              for (idx = 0, length = 7; idx < length; idx++) {\n                dates.push(start);\n                start = kendo.date.nextDay(start);\n              }\n\n              this._render(dates);\n            }\n          }),\n          TimelineWorkWeekView: TimelineView.extend({\n            options: {\n              name: \"TimelineWorkWeekView\",\n              title: \"Timeline Work Week\",\n              selectedDateFormat: \"{0:D} - {1:D}\",\n              selectedShortDateFormat: \"{0:d} - {1:d}\",\n              selectedMobileDateFormat: \"{0:MMM dd} - {1:dd}\",\n              majorTick: 120\n            },\n            name: \"timelineWorkWeek\",\n            nextDate: function () {\n              var weekStart = kendo.date.dayOfWeek(kendo.date.nextDay(this.endDate()), this.calendarInfo().firstDay, 1);\n              return kendo.date.addDays(weekStart, this._workDays[0]);\n            },\n            previousDate: function () {\n              var weekStart = kendo.date.dayOfWeek(this.startDate(), this.calendarInfo().firstDay, -1);\n              var workDays = this._workDays;\n              return kendo.date.addDays(weekStart, workDays[workDays.length - 1] - 7);\n            },\n            calculateDateRange: function () {\n              var options = this.options,\n                  selectedDate = options.date,\n                  dayOfWeek = kendo.date.dayOfWeek,\n                  weekStart = dayOfWeek(selectedDate, this.calendarInfo().firstDay, -1),\n                  start = dayOfWeek(weekStart, options.workWeekStart, 1),\n                  end = dayOfWeek(start, options.workWeekEnd, 1),\n                  dates = [],\n                  workDays = options.workDays && options.workDays.length ? options.workDays.map(function (day) {\n                return dayOfWeek(weekStart, day, 1).getTime();\n              }) : null;\n\n              if (workDays) {\n                start = weekStart;\n                end = dayOfWeek(start, this.calendarInfo().firstDay + 6, 1);\n              }\n\n              while (start <= end) {\n                if (workDays && workDays.indexOf(start.getTime()) > -1) {\n                  dates.push(start);\n                } else if (!workDays) {\n                  dates.push(start);\n                }\n\n                start = kendo.date.nextDay(start);\n              }\n\n              this._render(dates);\n            }\n          }),\n          TimelineMonthView: TimelineView.extend({\n            options: {\n              name: \"TimelineMonthView\",\n              title: \"Timeline Month\",\n              selectedDateFormat: \"{0:D} - {1:D}\",\n              selectedShortDateFormat: \"{0:d} - {1:d}\",\n              workDayStart: new Date(1980, 1, 1, 0, 0, 0),\n              workDayEnd: new Date(1980, 1, 1, 23, 59, 59),\n              footer: false,\n              majorTick: 1440,\n              minorTickCount: 1\n            },\n            name: \"timelineMonth\",\n            calculateDateRange: function () {\n              var selectedDate = this.options.date,\n                  start = kendo.date.firstDayOfMonth(selectedDate),\n                  end = kendo.date.lastDayOfMonth(selectedDate),\n                  idx,\n                  length,\n                  dates = [];\n\n              for (idx = 0, length = end.getDate(); idx < length; idx++) {\n                dates.push(start);\n                start = kendo.date.nextDay(start);\n              }\n\n              this._render(dates);\n            }\n          })\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}