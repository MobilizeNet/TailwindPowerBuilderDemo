{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1125);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  1051:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.core\");\n    /***/\n  },\n\n  /***/\n  1125:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1051), __webpack_require__(1126), __webpack_require__(1127)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      var __meta__ = {\n        // jshint ignore:line\n        id: \"data\",\n        name: \"Data source\",\n        category: \"framework\",\n        description: \"Powerful component for using local and remote data.Fully supports CRUD, Sorting, Paging, Filtering, Grouping, and Aggregates.\",\n        depends: [\"core\"],\n        features: [{\n          id: \"data-odata\",\n          name: \"OData\",\n          description: \"Support for accessing Open Data Protocol (OData) services.\",\n          depends: [\"data.odata\"]\n        }, {\n          id: \"data-signalr\",\n          name: \"SignalR\",\n          description: \"Support for binding to SignalR hubs.\",\n          depends: [\"data.signalr\"]\n        }, {\n          id: \"data-XML\",\n          name: \"XML\",\n          description: \"Support for binding to XML.\",\n          depends: [\"data.xml\"]\n        }]\n      };\n      /*jshint eqnull: true, loopfunc: true, evil: true */\n\n      (function ($, undefined) {\n        var extend = $.extend,\n            isPlainObject = $.isPlainObject,\n            isEmptyObject = $.isEmptyObject,\n            isArray = Array.isArray,\n            grep = $.grep,\n            ajax = $.ajax,\n            map,\n            each = $.each,\n            noop = $.noop,\n            kendo = window.kendo,\n            isFunction = kendo.isFunction,\n            Observable = kendo.Observable,\n            Class = kendo.Class,\n            STRING = \"string\",\n            FUNCTION = \"function\",\n            ASCENDING = \"asc\",\n            CREATE = \"create\",\n            READ = \"read\",\n            UPDATE = \"update\",\n            DESTROY = \"destroy\",\n            CHANGE = \"change\",\n            SYNC = \"sync\",\n            GET = \"get\",\n            ERROR = \"error\",\n            REQUESTSTART = \"requestStart\",\n            PROGRESS = \"progress\",\n            REQUESTEND = \"requestEnd\",\n            ITEMSLOADED = \"itemsLoaded\",\n            ITEMLOAD = \"itemLoad\",\n            crud = [CREATE, READ, UPDATE, DESTROY],\n            identity = function (o) {\n          return o;\n        },\n            getter = kendo.getter,\n            stringify = kendo.stringify,\n            math = Math,\n            push = [].push,\n            join = [].join,\n            pop = [].pop,\n            splice = [].splice,\n            shift = [].shift,\n            slice = [].slice,\n            unshift = [].unshift,\n            toString = {}.toString,\n            stableSort = kendo.support.stableSort,\n            dateRegExp = /^\\/Date\\((.*?)\\)\\/$/,\n            objectKeys = [];\n\n        var ObservableArray = Observable.extend({\n          init: function (array, type) {\n            var that = this;\n            that.type = type || ObservableObject;\n            Observable.fn.init.call(that);\n            that.length = array.length;\n            that.wrapAll(array, that);\n            that._loadPromises = [];\n            that._loadedNodes = [];\n          },\n          at: function (index) {\n            return this[index];\n          },\n          toJSON: function (serializeFunctions) {\n            var idx,\n                length = this.length,\n                value,\n                json = new Array(length);\n\n            for (idx = 0; idx < length; idx++) {\n              value = this[idx];\n\n              if (value instanceof ObservableObject) {\n                value = value.toJSON(serializeFunctions);\n              }\n\n              json[idx] = value;\n            }\n\n            return json;\n          },\n          parent: noop,\n          wrapAll: function (source, target) {\n            var that = this,\n                idx,\n                length,\n                parent = function () {\n              return that;\n            };\n\n            target = target || [];\n\n            for (idx = 0, length = source.length; idx < length; idx++) {\n              target[idx] = that.wrap(source[idx], parent);\n            }\n\n            return target;\n          },\n          wrap: function (object, parent) {\n            var that = this,\n                observable;\n\n            if (object !== null && toString.call(object) === \"[object Object]\") {\n              observable = object instanceof that.type || object instanceof Model;\n\n              if (!observable) {\n                object = object instanceof ObservableObject ? object.toJSON() : object;\n                object = new that.type(object);\n              }\n\n              object.parent = parent;\n              object.bind(CHANGE, function (e) {\n                var isGroup = object.hasOwnProperty(\"hasSubgroups\");\n                that.trigger(CHANGE, {\n                  field: e.field,\n                  node: e.node,\n                  index: e.index,\n                  items: e.items || [this],\n                  action: e.node || isGroup ? e.action || \"itemloaded\" : \"itemchange\"\n                });\n              });\n              object.bind(ITEMLOAD, function (e) {\n                that._loadPromises.push(e.promise);\n\n                that._loading = true;\n                e.promise.done(function () {\n                  that._loadedNodes.push(e.node);\n\n                  var index = that._loadPromises.indexOf(e.promise);\n\n                  that._loadPromises.splice(index, 1);\n\n                  if (!that._loadPromises.length) {\n                    that._loading = false;\n                    that.trigger(ITEMSLOADED, {\n                      collection: that,\n                      nodes: that._loadedNodes\n                    });\n                    that._loadedNodes = [];\n                  }\n                });\n              });\n            }\n\n            return object;\n          },\n          loading: function () {\n            return this._loading;\n          },\n          push: function () {\n            var index = this.length,\n                items = this.wrapAll(arguments),\n                result;\n            result = push.apply(this, items);\n\n            if (!this.omitChangeEvent) {\n              this.trigger(CHANGE, {\n                action: \"add\",\n                index: index,\n                items: items\n              });\n            }\n\n            return result;\n          },\n          slice: slice,\n          sort: [].sort,\n          join: join,\n          pop: function () {\n            var length = this.length,\n                result = pop.apply(this);\n\n            if (length) {\n              this.trigger(CHANGE, {\n                action: \"remove\",\n                index: length - 1,\n                items: [result]\n              });\n            }\n\n            return result;\n          },\n          splice: function (index, howMany, item) {\n            var items = this.wrapAll(slice.call(arguments, 2)),\n                result,\n                i,\n                len;\n            result = splice.apply(this, [index, howMany].concat(items));\n\n            if (result.length) {\n              if (!this.omitChangeEvent) {\n                this.trigger(CHANGE, {\n                  action: \"remove\",\n                  index: index,\n                  items: result\n                });\n              }\n\n              for (i = 0, len = result.length; i < len; i++) {\n                if (result[i] && result[i].children) {\n                  result[i].unbind(CHANGE);\n                }\n              }\n            }\n\n            if (item) {\n              if (!this.omitChangeEvent) {\n                this.trigger(CHANGE, {\n                  action: \"add\",\n                  index: index,\n                  items: items\n                });\n              }\n            }\n\n            return result;\n          },\n          shift: function () {\n            var length = this.length,\n                result = shift.apply(this);\n\n            if (length) {\n              this.trigger(CHANGE, {\n                action: \"remove\",\n                index: 0,\n                items: [result]\n              });\n            }\n\n            return result;\n          },\n          unshift: function () {\n            var items = this.wrapAll(arguments),\n                result;\n            result = unshift.apply(this, items);\n            this.trigger(CHANGE, {\n              action: \"add\",\n              index: 0,\n              items: items\n            });\n            return result;\n          },\n          indexOf: function (item) {\n            var that = this,\n                idx,\n                length;\n\n            for (idx = 0, length = that.length; idx < length; idx++) {\n              if (that[idx] === item) {\n                return idx;\n              }\n            }\n\n            return -1;\n          },\n          forEach: function (callback, thisArg) {\n            var idx = 0;\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              callback.call(context, this[idx], idx, this);\n            }\n          },\n          map: function (callback, thisArg) {\n            var idx = 0;\n            var result = [];\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              result[idx] = callback.call(context, this[idx], idx, this);\n            }\n\n            return result;\n          },\n          reduce: function (callback) {\n            var idx = 0,\n                result,\n                length = this.length;\n\n            if (arguments.length == 2) {\n              result = arguments[1];\n            } else if (idx < length) {\n              result = this[idx++];\n            }\n\n            for (; idx < length; idx++) {\n              result = callback(result, this[idx], idx, this);\n            }\n\n            return result;\n          },\n          reduceRight: function (callback) {\n            var idx = this.length - 1,\n                result;\n\n            if (arguments.length == 2) {\n              result = arguments[1];\n            } else if (idx > 0) {\n              result = this[idx--];\n            }\n\n            for (; idx >= 0; idx--) {\n              result = callback(result, this[idx], idx, this);\n            }\n\n            return result;\n          },\n          filter: function (callback, thisArg) {\n            var idx = 0;\n            var result = [];\n            var item;\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              item = this[idx];\n\n              if (callback.call(context, item, idx, this)) {\n                result[result.length] = item;\n              }\n            }\n\n            return result;\n          },\n          find: function (callback, thisArg) {\n            var idx = 0;\n            var item;\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              item = this[idx];\n\n              if (callback.call(context, item, idx, this)) {\n                return item;\n              }\n            }\n          },\n          every: function (callback, thisArg) {\n            var idx = 0;\n            var item;\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              item = this[idx];\n\n              if (!callback.call(context, item, idx, this)) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          some: function (callback, thisArg) {\n            var idx = 0;\n            var item;\n            var length = this.length;\n            var context = thisArg || window;\n\n            for (; idx < length; idx++) {\n              item = this[idx];\n\n              if (callback.call(context, item, idx, this)) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          // non-standard collection methods\n          remove: function (item) {\n            var idx = this.indexOf(item);\n\n            if (idx !== -1) {\n              this.splice(idx, 1);\n            }\n          },\n          empty: function () {\n            this.splice(0, this.length);\n          }\n        }); // Polyfill for Symbol.iterator\n\n        if (typeof Symbol !== \"undefined\" && Symbol.iterator && !ObservableArray.prototype[Symbol.iterator]) {\n          ObservableArray.prototype[Symbol.iterator] = [][Symbol.iterator];\n        }\n\n        var LazyObservableArray = ObservableArray.extend({\n          init: function (data, type, events) {\n            var parentFn = function () {\n              return this;\n            };\n\n            Observable.fn.init.call(this);\n            this.type = type || ObservableObject;\n\n            if (events) {\n              this._events = events;\n            }\n\n            for (var idx = 0; idx < data.length; idx++) {\n              this[idx] = data[idx];\n            }\n\n            this.length = idx;\n            this._parent = parentFn.bind(this);\n          },\n          at: function (index) {\n            var item = this[index];\n\n            if (!(item instanceof this.type)) {\n              item = this[index] = this.wrap(item, this._parent);\n            } else {\n              item.parent = this._parent;\n            }\n\n            return item;\n          }\n        });\n\n        function eventHandler(context, type, field, prefix) {\n          return function (e) {\n            var event = {},\n                key;\n\n            for (key in e) {\n              event[key] = e[key];\n            }\n\n            if (prefix) {\n              event.field = field + \".\" + e.field;\n            } else {\n              event.field = field;\n            }\n\n            if (type == CHANGE && context._notifyChange) {\n              context._notifyChange(event);\n            }\n\n            context.trigger(type, event);\n          };\n        }\n\n        function ownKeys(value, ignoreObjectKeys) {\n          var props = [];\n          var keys, filteredObjectKeys;\n          value = value || {};\n          keys = Object.getOwnPropertyNames(value);\n          filteredObjectKeys = objectKeys.filter(function (key) {\n            return keys.indexOf(key) < 0;\n          });\n\n          while (value) {\n            Object.getOwnPropertyNames(value).forEach(function (prop) {\n              if (props.indexOf(prop) === -1 && (!ignoreObjectKeys || filteredObjectKeys.indexOf(prop) < 0)) {\n                props.push(prop);\n              }\n            });\n            value = Object.getPrototypeOf(value);\n          }\n\n          return props;\n        }\n\n        objectKeys = ownKeys({}, false);\n        var ObservableObject = Observable.extend({\n          init: function (value) {\n            var that = this,\n                member,\n                keys = ownKeys(value, true),\n                parent = function () {\n              return that;\n            };\n\n            Observable.fn.init.call(this);\n            this._handlers = {};\n            keys.forEach(function (field) {\n              member = value[field];\n\n              if (typeof member === \"object\" && member && !member.getTime && field.charAt(0) != \"_\") {\n                member = that.wrap(member, field, parent);\n              }\n\n              that[field] = member;\n            });\n            that.uid = kendo.guid();\n          },\n          shouldSerialize: function (field, serializeFunctions) {\n            return this.hasOwnProperty(field) && field !== \"_handlers\" && field !== \"_events\" && (serializeFunctions && serializeFunctions[field] || typeof this[field] !== FUNCTION) && field !== \"uid\";\n          },\n          forEach: function (f) {\n            for (var i in this) {\n              if (this.shouldSerialize(i)) {\n                f(this[i], i);\n              }\n            }\n          },\n          toJSON: function (serializeFunctions) {\n            var result = {},\n                value,\n                field;\n\n            for (field in this) {\n              if (this.shouldSerialize(field, serializeFunctions)) {\n                value = this[field];\n\n                if (value instanceof ObservableObject || value instanceof ObservableArray) {\n                  value = value.toJSON(serializeFunctions);\n                }\n\n                result[field] = value;\n              }\n            }\n\n            return result;\n          },\n          get: function (field) {\n            var that = this,\n                result;\n            that.trigger(GET, {\n              field: field\n            });\n\n            if (field === \"this\") {\n              result = that;\n            } else {\n              result = kendo.getter(field, true)(that);\n            }\n\n            return result;\n          },\n          _set: function (field, value) {\n            var that = this;\n            var composite = field.indexOf(\".\") >= 0;\n\n            if (composite) {\n              var paths = field.split(\".\"),\n                  path = \"\";\n\n              while (paths.length > 1) {\n                path += paths.shift();\n                var obj = kendo.getter(path, true)(that);\n\n                if (obj instanceof ObservableObject) {\n                  obj.set(paths.join(\".\"), value);\n                  return composite;\n                }\n\n                path += \".\";\n              }\n            }\n\n            kendo.setter(field)(that, value);\n            return composite;\n          },\n          set: function (field, value) {\n            var that = this,\n                isSetPrevented = false,\n                composite = field.indexOf(\".\") >= 0,\n                current = kendo.getter(field, true)(that);\n\n            if (current !== value) {\n              if (current instanceof Observable && this._handlers[field]) {\n                if (this._handlers[field].get) {\n                  current.unbind(GET, this._handlers[field].get);\n                }\n\n                current.unbind(CHANGE, this._handlers[field].change);\n              }\n\n              isSetPrevented = that.trigger(\"set\", {\n                field: field,\n                value: value\n              });\n\n              if (!isSetPrevented) {\n                if (!composite) {\n                  value = that.wrap(value, field, function () {\n                    return that;\n                  });\n                }\n\n                if (!that._set(field, value) || field.indexOf(\"(\") >= 0 || field.indexOf(\"[\") >= 0) {\n                  that.trigger(CHANGE, {\n                    field: field\n                  });\n                }\n              }\n            }\n\n            return isSetPrevented;\n          },\n          parent: noop,\n          wrap: function (object, field, parent) {\n            var that = this;\n            var get;\n            var change;\n            var type = toString.call(object);\n\n            if (object != null && (type === \"[object Object]\" || type === \"[object Array]\")) {\n              var isObservableArray = object instanceof ObservableArray;\n              var isDataSource = object instanceof DataSource;\n\n              if (type === \"[object Object]\" && !isDataSource && !isObservableArray) {\n                if (!(object instanceof ObservableObject)) {\n                  object = new ObservableObject(object);\n                }\n\n                get = eventHandler(that, GET, field, true);\n                object.bind(GET, get);\n                change = eventHandler(that, CHANGE, field, true);\n                object.bind(CHANGE, change);\n                that._handlers[field] = {\n                  get: get,\n                  change: change\n                };\n              } else if (type === \"[object Array]\" || isObservableArray || isDataSource) {\n                if (!isObservableArray && !isDataSource) {\n                  object = new ObservableArray(object);\n                }\n\n                change = eventHandler(that, CHANGE, field, false);\n                object.bind(CHANGE, change);\n                that._handlers[field] = {\n                  change: change\n                };\n              }\n\n              object.parent = parent;\n            }\n\n            return object;\n          }\n        });\n\n        function equal(x, y) {\n          if (x === y) {\n            return true;\n          }\n\n          var xtype = kendo.type(x),\n              ytype = kendo.type(y),\n              field;\n\n          if (xtype !== ytype) {\n            return false;\n          }\n\n          if (xtype === \"date\") {\n            return x.getTime() === y.getTime();\n          }\n\n          if (xtype !== \"object\" && xtype !== \"array\") {\n            return false;\n          }\n\n          for (field in x) {\n            if (!equal(x[field], y[field])) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        var parsers = {\n          \"number\": function (value) {\n            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n              return null;\n            }\n\n            return kendo.parseFloat(value);\n          },\n          \"date\": function (value) {\n            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n              return null;\n            }\n\n            return kendo.parseDate(value);\n          },\n          \"boolean\": function (value) {\n            if (typeof value === STRING) {\n              if (value.toLowerCase() === \"null\") {\n                return null;\n              } else {\n                return value.toLowerCase() === \"true\";\n              }\n            }\n\n            return value != null ? !!value : value;\n          },\n          \"string\": function (value) {\n            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n              return null;\n            }\n\n            return value != null ? value + \"\" : value;\n          },\n          \"default\": function (value) {\n            return value;\n          }\n        };\n        var defaultValues = {\n          \"string\": \"\",\n          \"number\": 0,\n          \"date\": new Date(),\n          \"boolean\": false,\n          \"default\": \"\"\n        };\n\n        function getFieldByName(obj, name) {\n          var field, fieldName;\n\n          for (fieldName in obj) {\n            field = obj[fieldName];\n\n            if (isPlainObject(field) && field.field && field.field === name) {\n              return field;\n            } else if (field === name) {\n              return field;\n            }\n          }\n\n          return null;\n        }\n\n        var Model = ObservableObject.extend({\n          init: function (data) {\n            var that = this;\n\n            if (!data || $.isEmptyObject(data)) {\n              data = $.extend({}, that.defaults, data);\n\n              if (that._initializers) {\n                for (var idx = 0; idx < that._initializers.length; idx++) {\n                  var name = that._initializers[idx];\n                  data[name] = that.defaults[name]();\n                }\n              }\n            }\n\n            ObservableObject.fn.init.call(that, data);\n            that.dirty = false;\n            that.dirtyFields = {};\n\n            if (that.idField) {\n              that.id = that.get(that.idField);\n\n              if (that.id === undefined) {\n                that.id = that._defaultId;\n              }\n            }\n          },\n          shouldSerialize: function (field) {\n            return ObservableObject.fn.shouldSerialize.call(this, field) && field !== \"uid\" && !(this.idField !== \"id\" && field === \"id\") && field !== \"dirty\" && field !== \"dirtyFields\" && field !== \"_accessors\";\n          },\n          _parse: function (field, value) {\n            var that = this,\n                fieldName = field,\n                fields = that.fields || {},\n                parse;\n            field = fields[field];\n\n            if (!field) {\n              field = getFieldByName(fields, fieldName);\n            }\n\n            if (field) {\n              parse = field.parse;\n\n              if (!parse && field.type) {\n                parse = parsers[field.type.toLowerCase()];\n              }\n            }\n\n            return parse ? parse(value) : value;\n          },\n          _notifyChange: function (e) {\n            var action = e.action;\n\n            if (action == \"add\" || action == \"remove\") {\n              this.dirty = true;\n              this.dirtyFields[e.field] = true;\n            }\n          },\n          editable: function (field) {\n            field = (this.fields || {})[field];\n            return field ? field.editable !== false : true;\n          },\n          set: function (field, value) {\n            var that = this;\n            var dirty = that.dirty;\n\n            if (that.editable(field)) {\n              value = that._parse(field, value);\n\n              if (!equal(value, that.get(field))) {\n                that.dirty = true;\n                that.dirtyFields[field] = true;\n\n                if (ObservableObject.fn.set.call(that, field, value) && !dirty) {\n                  that.dirty = dirty;\n\n                  if (!that.dirty) {\n                    that.dirtyFields[field] = false;\n                  }\n                }\n              } else {\n                that.trigger(\"equalSet\", {\n                  field: field,\n                  value: value\n                });\n              }\n            }\n          },\n          accept: function (data) {\n            var that = this,\n                parent = function () {\n              return that;\n            },\n                field;\n\n            for (field in data) {\n              var value = data[field];\n\n              if (field.charAt(0) != \"_\") {\n                value = that.wrap(data[field], field, parent);\n              }\n\n              that._set(field, value);\n            }\n\n            if (that.idField) {\n              that.id = that.get(that.idField);\n            }\n\n            that.dirty = false;\n            that.dirtyFields = {};\n          },\n          isNew: function () {\n            return this.id === this._defaultId;\n          }\n        });\n\n        Model.define = function (base, options) {\n          if (options === undefined) {\n            options = base;\n            base = Model;\n          }\n\n          var model,\n              proto = extend({\n            defaults: {}\n          }, options),\n              name,\n              field,\n              type,\n              value,\n              idx,\n              length,\n              fields = {},\n              originalName,\n              id = proto.id,\n              functionFields = [];\n\n          if (id) {\n            proto.idField = id;\n          }\n\n          if (proto.id) {\n            delete proto.id;\n          }\n\n          if (id) {\n            proto.defaults[id] = proto._defaultId = \"\";\n          }\n\n          if (toString.call(proto.fields) === \"[object Array]\") {\n            for (idx = 0, length = proto.fields.length; idx < length; idx++) {\n              field = proto.fields[idx];\n\n              if (typeof field === STRING) {\n                fields[field] = {};\n              } else if (field.field) {\n                fields[field.field] = field;\n              }\n            }\n\n            proto.fields = fields;\n          }\n\n          for (name in proto.fields) {\n            field = proto.fields[name];\n            type = field.type || \"default\";\n            value = null;\n            originalName = name;\n            name = typeof field.field === STRING ? field.field : name;\n\n            if (!field.nullable) {\n              value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];\n\n              if (typeof value === \"function\") {\n                functionFields.push(name);\n              }\n            }\n\n            if (options.id === name) {\n              proto._defaultId = value;\n            }\n\n            proto.defaults[originalName !== name ? originalName : name] = value;\n            field.parse = field.parse || parsers[type];\n          }\n\n          if (functionFields.length > 0) {\n            proto._initializers = functionFields;\n          }\n\n          model = base.extend(proto);\n\n          model.define = function (options) {\n            return Model.define(model, options);\n          };\n\n          if (proto.fields) {\n            model.fields = proto.fields;\n            model.idField = proto.idField;\n          }\n\n          return model;\n        };\n\n        var Comparer = {\n          selector: function (field) {\n            return isFunction(field) ? field : getter(field);\n          },\n          compare: function (field) {\n            var selector = this.selector(field);\n            return function (a, b) {\n              a = selector(a);\n              b = selector(b);\n\n              if (a == null && b == null) {\n                return 0;\n              }\n\n              if (a == null) {\n                return -1;\n              }\n\n              if (b == null) {\n                return 1;\n              }\n\n              if (a.localeCompare) {\n                return a.localeCompare(b);\n              }\n\n              return a > b ? 1 : a < b ? -1 : 0;\n            };\n          },\n          create: function (sort) {\n            var compare = sort.compare || this.compare(sort.field);\n\n            if (sort.dir == \"desc\") {\n              return function (a, b) {\n                return compare(b, a, true);\n              };\n            }\n\n            return compare;\n          },\n          combine: function (comparers) {\n            return function (a, b) {\n              var result = comparers[0](a, b),\n                  idx,\n                  length;\n\n              for (idx = 1, length = comparers.length; idx < length; idx++) {\n                result = result || comparers[idx](a, b);\n              }\n\n              return result;\n            };\n          }\n        };\n        var StableComparer = extend({}, Comparer, {\n          asc: function (field) {\n            var selector = this.selector(field);\n            return function (a, b) {\n              var valueA = selector(a);\n              var valueB = selector(b);\n\n              if (valueA && valueA.getTime && valueB && valueB.getTime) {\n                valueA = valueA.getTime();\n                valueB = valueB.getTime();\n              }\n\n              if (valueA === valueB) {\n                return a.__position - b.__position;\n              }\n\n              if (valueA == null) {\n                return -1;\n              }\n\n              if (valueB == null) {\n                return 1;\n              }\n\n              if (valueA.localeCompare) {\n                return valueA.localeCompare(valueB);\n              }\n\n              return valueA > valueB ? 1 : -1;\n            };\n          },\n          desc: function (field) {\n            var selector = this.selector(field);\n            return function (a, b) {\n              var valueA = selector(a);\n              var valueB = selector(b);\n\n              if (valueA && valueA.getTime && valueB && valueB.getTime) {\n                valueA = valueA.getTime();\n                valueB = valueB.getTime();\n              }\n\n              if (valueA === valueB) {\n                return a.__position - b.__position;\n              }\n\n              if (valueA == null) {\n                return 1;\n              }\n\n              if (valueB == null) {\n                return -1;\n              }\n\n              if (valueB.localeCompare) {\n                return valueB.localeCompare(valueA);\n              }\n\n              return valueA < valueB ? 1 : -1;\n            };\n          },\n          create: function (sort) {\n            return this[sort.dir](sort.field);\n          }\n        });\n\n        map = function (array, callback) {\n          var idx,\n              length = array.length,\n              result = new Array(length);\n\n          for (idx = 0; idx < length; idx++) {\n            result[idx] = callback(array[idx], idx, array);\n          }\n\n          return result;\n        };\n\n        var operators = function () {\n          function quote(str) {\n            if (typeof str == \"string\") {\n              str = str.replace(/[\\r\\n]+/g, \"\");\n            }\n\n            return JSON.stringify(str);\n          }\n\n          function textOp(impl) {\n            return function (a, b, ignore, accentFoldingFiltering) {\n              b += \"\";\n\n              if (ignore) {\n                a = \"(\" + a + \" + '').toString()\" + (accentFoldingFiltering ? \".toLocaleLowerCase('\" + accentFoldingFiltering + \"')\" : \".toLowerCase()\");\n                b = accentFoldingFiltering ? b.toLocaleLowerCase(accentFoldingFiltering) : b.toLowerCase();\n              }\n\n              return impl(a, quote(b), ignore);\n            };\n          }\n\n          function operator(op, a, b, ignore, accentFoldingFiltering) {\n            if (b != null) {\n              if (typeof b === STRING) {\n                var date = dateRegExp.exec(b);\n\n                if (date) {\n                  b = new Date(+date[1]);\n                } else if (ignore) {\n                  b = quote(accentFoldingFiltering ? b.toLocaleLowerCase(accentFoldingFiltering) : b.toLowerCase());\n                  a = \"((\" + a + \" || '')+'')\" + (accentFoldingFiltering ? \".toLocaleLowerCase('\" + accentFoldingFiltering + \"')\" : \".toLowerCase()\");\n                } else {\n                  b = quote(b);\n                }\n              }\n\n              if (b.getTime) {\n                //b looks like a Date\n                a = \"(\" + a + \"&&\" + a + \".getTime?\" + a + \".getTime():\" + a + \")\";\n                b = b.getTime();\n              }\n            }\n\n            return a + \" \" + op + \" \" + b;\n          }\n\n          function getMatchRegexp(pattern) {\n            // take a pattern, as supported by Excel match filter, and\n            // convert it to the equivalent JS regular expression.\n            // Excel patterns support:\n            //\n            //   * - match any sequence of characters\n            //   ? - match a single character\n            //\n            // to match a literal * or ?, they must be prefixed by a tilde (~)\n            for (var rx = \"/^\", esc = false, i = 0; i < pattern.length; ++i) {\n              var ch = pattern.charAt(i);\n\n              if (esc) {\n                rx += \"\\\\\" + ch;\n              } else if (ch == \"~\") {\n                esc = true;\n                continue;\n              } else if (ch == \"*\") {\n                rx += \".*\";\n              } else if (ch == \"?\") {\n                rx += \".\";\n              } else if (\".+^$()[]{}|\\\\/\\n\\r\\u2028\\u2029\\xA0\".indexOf(ch) >= 0) {\n                rx += \"\\\\\" + ch;\n              } else {\n                rx += ch;\n              }\n\n              esc = false;\n            }\n\n            return rx + \"$/\";\n          }\n\n          return {\n            quote: function (value) {\n              if (value && value.getTime) {\n                return \"new Date(\" + value.getTime() + \")\";\n              }\n\n              return quote(value);\n            },\n            eq: function (a, b, ignore, accentFoldingFiltering) {\n              return operator(\"==\", a, b, ignore, accentFoldingFiltering);\n            },\n            neq: function (a, b, ignore, accentFoldingFiltering) {\n              return operator(\"!=\", a, b, ignore, accentFoldingFiltering);\n            },\n            gt: function (a, b, ignore) {\n              return operator(\">\", a, b, ignore);\n            },\n            gte: function (a, b, ignore) {\n              return operator(\">=\", a, b, ignore);\n            },\n            lt: function (a, b, ignore) {\n              return operator(\"<\", a, b, ignore);\n            },\n            lte: function (a, b, ignore) {\n              return operator(\"<=\", a, b, ignore);\n            },\n            startswith: textOp(function (a, b) {\n              return a + \".lastIndexOf(\" + b + \", 0) == 0\";\n            }),\n            doesnotstartwith: textOp(function (a, b) {\n              return a + \".lastIndexOf(\" + b + \", 0) == -1\";\n            }),\n            endswith: textOp(function (a, b) {\n              var n = b ? b.length - 2 : 0;\n              return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") >= 0\";\n            }),\n            doesnotendwith: textOp(function (a, b) {\n              var n = b ? b.length - 2 : 0;\n              return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") < 0\";\n            }),\n            contains: textOp(function (a, b) {\n              return a + \".indexOf(\" + b + \") >= 0\";\n            }),\n            doesnotcontain: textOp(function (a, b) {\n              return a + \".indexOf(\" + b + \") == -1\";\n            }),\n            matches: textOp(function (a, b) {\n              b = b.substring(1, b.length - 1);\n              return getMatchRegexp(b) + \".test(\" + a + \")\";\n            }),\n            doesnotmatch: textOp(function (a, b) {\n              b = b.substring(1, b.length - 1);\n              return \"!\" + getMatchRegexp(b) + \".test(\" + a + \")\";\n            }),\n            isempty: function (a) {\n              return a + \" === ''\";\n            },\n            isnotempty: function (a) {\n              return a + \" !== ''\";\n            },\n            isnull: function (a) {\n              return \"(\" + a + \" == null)\";\n            },\n            isnotnull: function (a) {\n              return \"(\" + a + \" != null)\";\n            },\n            isnullorempty: function (a) {\n              return \"(\" + a + \" === null) || (\" + a + \" === '')\";\n            },\n            isnotnullorempty: function (a) {\n              return \"(\" + a + \" !== null) && (\" + a + \" !== '')\";\n            }\n          };\n        }();\n\n        function Query(data) {\n          this.data = data || [];\n        }\n\n        Query.filterExpr = function (expression) {\n          var expressions = [],\n              logic = {\n            and: \" && \",\n            or: \" || \"\n          },\n              idx,\n              length,\n              filter,\n              expr,\n              fieldFunctions = [],\n              operatorFunctions = [],\n              field,\n              operator,\n              filters = expression.filters;\n\n          for (idx = 0, length = filters.length; idx < length; idx++) {\n            filter = filters[idx];\n            field = filter.field;\n            operator = filter.operator;\n\n            if (filter.filters) {\n              expr = Query.filterExpr(filter); //Nested function fields or operators - update their index e.g. __o[0] -> __o[1]\n\n              filter = expr.expression.replace(/__o\\[(\\d+)\\]/g, function (match, index) {\n                index = +index;\n                return \"__o[\" + (operatorFunctions.length + index) + \"]\";\n              }).replace(/__f\\[(\\d+)\\]/g, function (match, index) {\n                index = +index;\n                return \"__f[\" + (fieldFunctions.length + index) + \"]\";\n              });\n              operatorFunctions.push.apply(operatorFunctions, expr.operators);\n              fieldFunctions.push.apply(fieldFunctions, expr.fields);\n            } else {\n              if (typeof field === FUNCTION) {\n                expr = \"__f[\" + fieldFunctions.length + \"](d)\";\n                fieldFunctions.push(field);\n              } else {\n                expr = kendo.expr(field);\n              }\n\n              if (typeof operator === FUNCTION) {\n                filter = \"__o[\" + operatorFunctions.length + \"](\" + expr + \", \" + operators.quote(filter.value) + \")\";\n                operatorFunctions.push(operator);\n              } else {\n                filter = operators[(operator || \"eq\").toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined ? filter.ignoreCase : true, expression.accentFoldingFiltering);\n              }\n            }\n\n            expressions.push(filter);\n          }\n\n          return {\n            expression: \"(\" + expressions.join(logic[expression.logic]) + \")\",\n            fields: fieldFunctions,\n            operators: operatorFunctions\n          };\n        };\n\n        function normalizeSort(field, dir) {\n          if (field) {\n            var descriptor = typeof field === STRING ? {\n              field: field,\n              dir: dir\n            } : field,\n                descriptors = isArray(descriptor) ? descriptor : descriptor !== undefined ? [descriptor] : [];\n            return grep(descriptors, function (d) {\n              return !!d.dir;\n            });\n          }\n        }\n\n        function sortFields(sorts, dir) {\n          var sortObject = {};\n\n          if (sorts) {\n            var descriptor = typeof sorts === STRING ? {\n              field: sorts,\n              dir: dir\n            } : sorts,\n                descriptors = isArray(descriptor) ? descriptor : descriptor !== undefined ? [descriptor] : [];\n\n            for (var i = 0; i < descriptors.length; i++) {\n              sortObject[descriptors[i].field] = {\n                dir: descriptors[i].dir,\n                index: i + 1\n              };\n            }\n          }\n\n          return sortObject;\n        }\n\n        var operatorMap = {\n          \"==\": \"eq\",\n          equals: \"eq\",\n          isequalto: \"eq\",\n          equalto: \"eq\",\n          equal: \"eq\",\n          \"!=\": \"neq\",\n          ne: \"neq\",\n          notequals: \"neq\",\n          isnotequalto: \"neq\",\n          notequalto: \"neq\",\n          notequal: \"neq\",\n          \"<\": \"lt\",\n          islessthan: \"lt\",\n          lessthan: \"lt\",\n          less: \"lt\",\n          \"<=\": \"lte\",\n          le: \"lte\",\n          islessthanorequalto: \"lte\",\n          lessthanequal: \"lte\",\n          \">\": \"gt\",\n          isgreaterthan: \"gt\",\n          greaterthan: \"gt\",\n          greater: \"gt\",\n          \">=\": \"gte\",\n          isgreaterthanorequalto: \"gte\",\n          greaterthanequal: \"gte\",\n          ge: \"gte\",\n          notsubstringof: \"doesnotcontain\",\n          isnull: \"isnull\",\n          isempty: \"isempty\",\n          isnotempty: \"isnotempty\"\n        };\n\n        function normalizeOperator(expression) {\n          var idx,\n              length,\n              filter,\n              operator,\n              filters = expression.filters;\n\n          if (filters) {\n            for (idx = 0, length = filters.length; idx < length; idx++) {\n              filter = filters[idx];\n              operator = filter.operator;\n\n              if (operator && typeof operator === STRING) {\n                filter.operator = operatorMap[operator.toLowerCase()] || operator;\n              }\n\n              normalizeOperator(filter);\n            }\n          }\n        }\n\n        function normalizeFilter(expression) {\n          if (expression && !isEmptyObject(expression)) {\n            if (isArray(expression) || !expression.filters) {\n              expression = {\n                logic: \"and\",\n                filters: isArray(expression) ? expression : [expression]\n              };\n            }\n\n            normalizeOperator(expression);\n            return expression;\n          }\n        }\n\n        Query.normalizeFilter = normalizeFilter;\n\n        function compareDescriptor(f1, f2) {\n          if (f1.logic || f2.logic) {\n            return false;\n          }\n\n          return f1.field === f2.field && f1.value === f2.value && f1.operator === f2.operator;\n        }\n\n        function normalizeDescriptor(filter) {\n          filter = filter || {};\n\n          if (isEmptyObject(filter)) {\n            return {\n              logic: \"and\",\n              filters: []\n            };\n          }\n\n          return normalizeFilter(filter);\n        }\n\n        function fieldComparer(a, b) {\n          if (b.logic || a.field > b.field) {\n            return 1;\n          } else if (a.field < b.field) {\n            return -1;\n          } else {\n            return 0;\n          }\n        }\n\n        function compareFilters(expr1, expr2) {\n          expr1 = normalizeDescriptor(expr1);\n          expr2 = normalizeDescriptor(expr2);\n\n          if (expr1.logic !== expr2.logic) {\n            return false;\n          }\n\n          var f1, f2;\n          var filters1 = (expr1.filters || []).slice();\n          var filters2 = (expr2.filters || []).slice();\n\n          if (filters1.length !== filters2.length) {\n            return false;\n          }\n\n          filters1 = filters1.sort(fieldComparer);\n          filters2 = filters2.sort(fieldComparer);\n\n          for (var idx = 0; idx < filters1.length; idx++) {\n            f1 = filters1[idx];\n            f2 = filters2[idx];\n\n            if (f1.logic && f2.logic) {\n              if (!compareFilters(f1, f2)) {\n                return false;\n              }\n            } else if (!compareDescriptor(f1, f2)) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        Query.compareFilters = compareFilters;\n\n        function normalizeAggregate(expressions) {\n          return isArray(expressions) ? expressions : [expressions];\n        }\n\n        function normalizeGroup(field, dir, compare, skipItemSorting) {\n          var descriptor = typeof field === STRING ? {\n            field: field,\n            dir: dir,\n            compare: compare,\n            skipItemSorting: skipItemSorting\n          } : field,\n              descriptors = isArray(descriptor) ? descriptor : descriptor !== undefined ? [descriptor] : [];\n          return map(descriptors, function (d) {\n            return {\n              field: d.field,\n              dir: d.dir || \"asc\",\n              aggregates: d.aggregates,\n              compare: d.compare,\n              skipItemSorting: d.skipItemSorting\n            };\n          });\n        }\n\n        function normalizeGroupWithoutCompare(field, dir, compare) {\n          var descriptors = normalizeGroup(field, dir, compare);\n\n          for (var i = 0; i < descriptors.length; i++) {\n            delete descriptors[i].compare;\n          }\n\n          return descriptors;\n        }\n\n        function anyGroupDescriptorHasCompare(groupDescriptors) {\n          var descriptors = isArray(groupDescriptors) ? groupDescriptors : [groupDescriptors];\n\n          for (var i = 0; i < descriptors.length; i++) {\n            if (descriptors[i] && isFunction(descriptors[i].compare)) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n        Query.prototype = {\n          toArray: function () {\n            return this.data;\n          },\n          range: function (index, count) {\n            return new Query(this.data.slice(index, index + count));\n          },\n          skip: function (count) {\n            return new Query(this.data.slice(count));\n          },\n          take: function (count) {\n            return new Query(this.data.slice(0, count));\n          },\n          select: function (selector) {\n            return new Query(map(this.data, selector));\n          },\n          order: function (selector, dir, inPlace) {\n            var sort = {\n              dir: dir\n            };\n\n            if (selector) {\n              if (selector.compare) {\n                sort.compare = selector.compare;\n              } else {\n                sort.field = selector;\n              }\n            }\n\n            if (inPlace) {\n              return new Query(this.data.sort(Comparer.create(sort)));\n            }\n\n            return new Query(this.data.slice(0).sort(Comparer.create(sort)));\n          },\n          orderBy: function (selector, inPlace) {\n            return this.order(selector, \"asc\", inPlace);\n          },\n          orderByDescending: function (selector, inPlace) {\n            return this.order(selector, \"desc\", inPlace);\n          },\n          sort: function (field, dir, comparer, inPlace) {\n            var idx,\n                length,\n                descriptors = normalizeSort(field, dir),\n                comparers = [];\n            comparer = comparer || Comparer;\n\n            if (descriptors.length) {\n              for (idx = 0, length = descriptors.length; idx < length; idx++) {\n                comparers.push(comparer.create(descriptors[idx]));\n              }\n\n              return this.orderBy({\n                compare: comparer.combine(comparers)\n              }, inPlace);\n            }\n\n            return this;\n          },\n          filter: function (expressions) {\n            var idx,\n                current,\n                length,\n                compiled,\n                predicate,\n                data = this.data,\n                fields,\n                operators,\n                result = [],\n                filter;\n            expressions = normalizeFilter(expressions);\n\n            if (!expressions || expressions.filters.length === 0) {\n              return this;\n            }\n\n            compiled = Query.filterExpr(expressions);\n            fields = compiled.fields;\n            operators = compiled.operators;\n            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\n\n            if (fields.length || operators.length) {\n              filter = function (d) {\n                return predicate(d, fields, operators);\n              };\n            }\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              current = data[idx];\n\n              if (filter(current)) {\n                result.push(current);\n              }\n            }\n\n            return new Query(result);\n          },\n          group: function (descriptors, allData, options) {\n            descriptors = normalizeGroup(descriptors || []);\n            allData = allData || this.data;\n            var that = this,\n                result = new Query(that.data),\n                descriptor;\n\n            if (descriptors.length > 0) {\n              descriptor = descriptors[0];\n\n              if (options && options.groupPaging) {\n                result = new Query(allData).groupAllData(descriptor, allData).select(function (group) {\n                  var data = new Query(allData).filter([{\n                    field: group.field,\n                    operator: \"eq\",\n                    value: group.value,\n                    ignoreCase: false\n                  }]);\n                  var items = descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray(), options).toArray() : group.items;\n                  return {\n                    field: group.field,\n                    value: group.value,\n                    hasSubgroups: descriptors.length > 1,\n                    items: items,\n                    aggregates: data.aggregate(descriptor.aggregates),\n                    uid: kendo.guid(),\n                    itemCount: items.length,\n                    subgroupCount: items.length\n                  };\n                });\n              } else {\n                result = result.groupBy(descriptor).select(function (group) {\n                  var data = new Query(allData).filter([{\n                    field: group.field,\n                    operator: \"eq\",\n                    value: group.value,\n                    ignoreCase: false\n                  }]);\n                  return {\n                    field: group.field,\n                    value: group.value,\n                    items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,\n                    hasSubgroups: descriptors.length > 1,\n                    aggregates: data.aggregate(descriptor.aggregates)\n                  };\n                });\n              }\n            }\n\n            return result;\n          },\n          groupBy: function (descriptor) {\n            var that = this;\n\n            if (isEmptyObject(descriptor) || !this.data.length) {\n              return new Query([]);\n            }\n\n            var field = descriptor.field,\n                sorted = descriptor.skipItemSorting ? this.data : this._sortForGrouping(field, descriptor.dir || \"asc\"),\n                accessor = kendo.accessor(field),\n                item,\n                groupValue = accessor.get(sorted[0], field),\n                group = {\n              field: field,\n              value: groupValue,\n              items: []\n            },\n                currentValue,\n                idx,\n                len,\n                result = [group];\n\n            for (idx = 0, len = sorted.length; idx < len; idx++) {\n              item = sorted[idx];\n              currentValue = accessor.get(item, field);\n\n              if (!groupValueComparer(groupValue, currentValue)) {\n                groupValue = currentValue;\n                group = {\n                  field: field,\n                  value: groupValue,\n                  items: []\n                };\n                result.push(group);\n              }\n\n              group.items.push(item);\n            }\n\n            result = that._sortGroups(result, descriptor);\n            return new Query(result);\n          },\n          groupAllData: function (descriptor, allData) {\n            if (isEmptyObject(descriptor) || this.data && !this.data.length) {\n              return new Query([]);\n            }\n\n            var field = descriptor.field,\n                sorted = descriptor.skipItemSorting ? allData : new Query(allData).sort(field, descriptor.dir || \"asc\", StableComparer).toArray(),\n                accessor = kendo.accessor(field),\n                item,\n                groupValue = accessor.get(sorted[0], field),\n                group = {\n              field: field,\n              value: groupValue,\n              items: []\n            },\n                currentValue,\n                idx,\n                len,\n                result = [group];\n\n            for (idx = 0, len = sorted.length; idx < len; idx++) {\n              item = sorted[idx];\n              currentValue = accessor.get(item, field);\n\n              if (!groupValueComparer(groupValue, currentValue)) {\n                groupValue = currentValue;\n                group = {\n                  field: field,\n                  value: groupValue,\n                  items: []\n                };\n                result.push(group);\n              }\n\n              group.items.push(item);\n            }\n\n            result = this._sortGroups(result, descriptor);\n            return new Query(result);\n          },\n          _sortForGrouping: function (field, dir) {\n            var idx,\n                length,\n                data = this.data;\n\n            if (!stableSort) {\n              for (idx = 0, length = data.length; idx < length; idx++) {\n                data[idx].__position = idx;\n              }\n\n              data = new Query(data).sort(field, dir, StableComparer).toArray();\n\n              for (idx = 0, length = data.length; idx < length; idx++) {\n                delete data[idx].__position;\n              }\n\n              return data;\n            }\n\n            return this.sort(field, dir).toArray();\n          },\n          _sortGroups: function (groups, descriptor) {\n            var result = groups;\n\n            if (descriptor && isFunction(descriptor.compare)) {\n              result = new Query(result).order({\n                compare: descriptor.compare\n              }, descriptor.dir || ASCENDING).toArray();\n            }\n\n            return result;\n          },\n          aggregate: function (aggregates) {\n            var idx,\n                len,\n                result = {},\n                state = {};\n\n            if (aggregates && aggregates.length) {\n              for (idx = 0, len = this.data.length; idx < len; idx++) {\n                calculateAggregate(result, aggregates, this.data[idx], idx, len, state);\n              }\n            }\n\n            return result;\n          }\n        };\n\n        function groupValueComparer(a, b) {\n          if (a && a.getTime && b && b.getTime) {\n            return a.getTime() === b.getTime();\n          }\n\n          return a === b;\n        }\n\n        function calculateAggregate(accumulator, aggregates, item, index, length, state) {\n          aggregates = aggregates || [];\n          var idx,\n              aggr,\n              functionName,\n              len = aggregates.length;\n\n          for (idx = 0; idx < len; idx++) {\n            aggr = aggregates[idx];\n            functionName = aggr.aggregate;\n            var field = aggr.field;\n            accumulator[field] = accumulator[field] || {};\n            state[field] = state[field] || {};\n            state[field][functionName] = state[field][functionName] || {};\n            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);\n          }\n        }\n\n        var functions = {\n          sum: function (accumulator, item, accessor) {\n            var value = accessor.get(item);\n\n            if (!isNumber(accumulator)) {\n              accumulator = value;\n            } else if (isNumber(value)) {\n              accumulator += value;\n            }\n\n            return accumulator;\n          },\n          count: function (accumulator) {\n            return (accumulator || 0) + 1;\n          },\n          average: function (accumulator, item, accessor, index, length, state) {\n            var value = accessor.get(item);\n\n            if (state.count === undefined) {\n              state.count = 0;\n            }\n\n            if (!isNumber(accumulator)) {\n              accumulator = value;\n            } else if (isNumber(value)) {\n              accumulator += value;\n            }\n\n            if (isNumber(value)) {\n              state.count++;\n            }\n\n            if (index == length - 1 && isNumber(accumulator)) {\n              accumulator = accumulator / state.count;\n            }\n\n            return accumulator;\n          },\n          max: function (accumulator, item, accessor) {\n            var value = accessor.get(item);\n\n            if (!isNumber(accumulator) && !isDate(accumulator)) {\n              accumulator = value;\n            }\n\n            if (accumulator < value && (isNumber(value) || isDate(value))) {\n              accumulator = value;\n            }\n\n            return accumulator;\n          },\n          min: function (accumulator, item, accessor) {\n            var value = accessor.get(item);\n\n            if (!isNumber(accumulator) && !isDate(accumulator)) {\n              accumulator = value;\n            }\n\n            if (accumulator > value && (isNumber(value) || isDate(value))) {\n              accumulator = value;\n            }\n\n            return accumulator;\n          }\n        };\n\n        function isNumber(val) {\n          return typeof val === \"number\" && !isNaN(val);\n        }\n\n        function isDate(val) {\n          return val && val.getTime;\n        }\n\n        function toJSON(array) {\n          var idx,\n              length = array.length,\n              result = new Array(length);\n\n          for (idx = 0; idx < length; idx++) {\n            result[idx] = array[idx].toJSON();\n          }\n\n          return result;\n        }\n\n        Query.normalizeGroup = normalizeGroup;\n        Query.normalizeSort = normalizeSort;\n\n        Query.process = function (data, options, inPlace) {\n          options = options || {};\n          var group = options.group;\n          var customGroupSort = anyGroupDescriptorHasCompare(normalizeGroup(group || []));\n          var query = new Query(data),\n              groupDescriptorsWithoutCompare = normalizeGroupWithoutCompare(group || []),\n              normalizedSort = normalizeSort(options.sort || []),\n              sort = customGroupSort ? normalizedSort : groupDescriptorsWithoutCompare.concat(normalizedSort),\n              groupDescriptorsWithoutSort,\n              total,\n              filterCallback = options.filterCallback,\n              filter = options.filter,\n              skip = options.skip,\n              take = options.take;\n\n          if (sort && inPlace) {\n            query = query.sort(sort, undefined, undefined, inPlace);\n          }\n\n          if (filter) {\n            query = query.filter(filter);\n\n            if (filterCallback) {\n              query = filterCallback(query);\n            }\n\n            total = query.toArray().length;\n          }\n\n          if (sort) {\n            if (!inPlace) {\n              query = query.sort(sort);\n            }\n\n            if (group) {\n              data = query.toArray();\n            }\n          }\n\n          if (customGroupSort) {\n            query = query.group(group, data, options);\n\n            if (skip !== undefined && take !== undefined && !options.groupPaging) {\n              query = new Query(flatGroups(query.toArray())).range(skip, take);\n              groupDescriptorsWithoutSort = map(groupDescriptorsWithoutCompare, function (groupDescriptor) {\n                return extend({}, groupDescriptor, {\n                  skipItemSorting: true\n                });\n              });\n              query = query.group(groupDescriptorsWithoutSort, data, options);\n            }\n          } else {\n            if (skip !== undefined && take !== undefined) {\n              total = query.data.length;\n\n              if (skip + take > total && options.virtual) {\n                skip -= skip + take - total;\n              }\n\n              query = query.range(skip, take);\n            }\n\n            if (group && (!isEmptyObject(group) || group.length !== 0)) {\n              query = query.group(group, data, options);\n            }\n          }\n\n          return {\n            total: total,\n            data: query.toArray()\n          };\n        };\n\n        var LocalTransport = Class.extend({\n          init: function (options) {\n            this.data = options.data;\n          },\n          read: function (options) {\n            options.success(this.data);\n          },\n          update: function (options) {\n            options.success(options.data);\n          },\n          create: function (options) {\n            options.success(options.data);\n          },\n          destroy: function (options) {\n            options.success(options.data);\n          }\n        });\n        var RemoteTransport = Class.extend({\n          init: function (options) {\n            var that = this,\n                parameterMap;\n            options = that.options = extend({}, that.options, options);\n            each(crud, function (index, type) {\n              if (typeof options[type] === STRING) {\n                options[type] = {\n                  url: options[type]\n                };\n              }\n            });\n            that.cache = options.cache ? Cache.create(options.cache) : {\n              find: noop,\n              add: noop\n            };\n            parameterMap = options.parameterMap;\n\n            if (options.submit) {\n              that.submit = options.submit;\n            }\n\n            if (isFunction(options.push)) {\n              that.push = options.push;\n            }\n\n            if (!that.push) {\n              that.push = identity;\n            }\n\n            that.parameterMap = isFunction(parameterMap) ? parameterMap : function (options) {\n              var result = {};\n              each(options, function (option, value) {\n                if (option in parameterMap) {\n                  option = parameterMap[option];\n\n                  if (isPlainObject(option)) {\n                    value = option.value(value);\n                    option = option.key;\n                  }\n                }\n\n                result[option] = value;\n              });\n              return result;\n            };\n          },\n          options: {\n            parameterMap: identity\n          },\n          create: function (options) {\n            return ajax(this.setup(options, CREATE));\n          },\n          read: function (options) {\n            var that = this,\n                success,\n                error,\n                result,\n                cache = that.cache;\n            options = that.setup(options, READ);\n            success = options.success || noop;\n            error = options.error || noop;\n            result = cache.find(options.data);\n\n            if (result !== undefined) {\n              success(result);\n            } else {\n              options.success = function (result) {\n                cache.add(options.data, result);\n                success(result);\n              };\n\n              $.ajax(options);\n            }\n          },\n          update: function (options) {\n            return ajax(this.setup(options, UPDATE));\n          },\n          destroy: function (options) {\n            return ajax(this.setup(options, DESTROY));\n          },\n          setup: function (options, type) {\n            options = options || {};\n            var that = this,\n                parameters,\n                operation = that.options[type],\n                data = isFunction(operation.data) ? operation.data(options.data) : operation.data;\n            options = extend(true, {}, operation, options);\n            parameters = extend(true, {}, data, options.data);\n            options.data = that.parameterMap(parameters, type);\n\n            if (isFunction(options.url)) {\n              options.url = options.url(parameters);\n            }\n\n            return options;\n          }\n        });\n        var Cache = Class.extend({\n          init: function () {\n            this._store = {};\n          },\n          add: function (key, data) {\n            if (key !== undefined) {\n              this._store[stringify(key)] = data;\n            }\n          },\n          find: function (key) {\n            return this._store[stringify(key)];\n          },\n          clear: function () {\n            this._store = {};\n          },\n          remove: function (key) {\n            delete this._store[stringify(key)];\n          }\n        });\n\n        Cache.create = function (options) {\n          var store = {\n            \"inmemory\": function () {\n              return new Cache();\n            }\n          };\n\n          if (isPlainObject(options) && isFunction(options.find)) {\n            return options;\n          }\n\n          if (options === true) {\n            return new Cache();\n          }\n\n          return store[options]();\n        };\n\n        function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n          var record,\n              getter,\n              originalName,\n              idx,\n              setters = {},\n              length;\n\n          for (idx = 0, length = data.length; idx < length; idx++) {\n            record = data[idx];\n\n            for (getter in getters) {\n              originalName = fieldNames[getter];\n\n              if (originalName && originalName !== getter) {\n                if (!setters[originalName]) {\n                  setters[originalName] = kendo.setter(originalName);\n                }\n\n                setters[originalName](record, getters[getter](record));\n                delete record[getter];\n              }\n            }\n          }\n        }\n\n        function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n          var record, getter, originalName, idx, length;\n\n          for (idx = 0, length = data.length; idx < length; idx++) {\n            record = data[idx];\n\n            for (getter in getters) {\n              record[getter] = modelInstance._parse(getter, getters[getter](record));\n              originalName = fieldNames[getter];\n\n              if (originalName && originalName !== getter) {\n                delete record[originalName];\n              }\n            }\n          }\n        }\n\n        function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {\n          var record, idx, fieldName, length;\n\n          for (idx = 0, length = data.length; idx < length; idx++) {\n            record = data[idx];\n            fieldName = originalFieldNames[record.field];\n\n            if (fieldName && fieldName != record.field) {\n              record.field = fieldName;\n            }\n\n            record.value = modelInstance._parse(record.field, record.value);\n\n            if (record.items) {\n              if (record.hasSubgroups) {\n                convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n              } else {\n                convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n              }\n            }\n          }\n        }\n\n        function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {\n          return function (data) {\n            data = originalFunction(data);\n            return wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames)(data);\n          };\n        }\n\n        function wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames) {\n          return function (data) {\n            if (data && !isEmptyObject(getters)) {\n              if (toString.call(data) !== \"[object Array]\" && !(data instanceof ObservableArray)) {\n                data = [data];\n              }\n\n              converter(data, getters, new model(), originalFieldNames, fieldNames);\n            }\n\n            return data || [];\n          };\n        }\n\n        var DataReader = Class.extend({\n          init: function (schema) {\n            var that = this,\n                member,\n                get,\n                model,\n                base;\n            schema = schema || {};\n\n            for (member in schema) {\n              get = schema[member];\n              that[member] = typeof get === STRING ? getter(get) : get;\n            }\n\n            base = schema.modelBase || Model;\n\n            if (isPlainObject(that.model)) {\n              that.model = model = base.define(that.model);\n            }\n\n            var dataFunction = that.data.bind(that);\n            that._dataAccessFunction = dataFunction;\n\n            if (that.model) {\n              var groupsFunction = that.groups.bind(that),\n                  serializeFunction = that.serialize.bind(that),\n                  originalFieldNames = {},\n                  getters = {},\n                  serializeGetters = {},\n                  fieldNames = {},\n                  shouldSerialize = false,\n                  fieldName,\n                  name;\n              model = that.model;\n\n              if (model.fields) {\n                each(model.fields, function (field, value) {\n                  var fromName;\n                  fieldName = field;\n\n                  if (isPlainObject(value) && value.field) {\n                    fieldName = value.field;\n                  } else if (typeof value === STRING) {\n                    fieldName = value;\n                  }\n\n                  if (isPlainObject(value) && value.from) {\n                    fromName = value.from;\n                  }\n\n                  shouldSerialize = shouldSerialize || fromName && fromName !== field || fieldName !== field;\n                  name = fromName || fieldName;\n                  getters[field] = name.indexOf(\".\") !== -1 ? getter(name, true) : getter(name);\n                  serializeGetters[field] = getter(field);\n                  originalFieldNames[fromName || fieldName] = field;\n                  fieldNames[field] = fromName || fieldName;\n                });\n\n                if (!schema.serialize && shouldSerialize) {\n                  that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);\n                }\n              }\n\n              that._dataAccessFunction = dataFunction;\n              that._wrapDataAccessBase = wrapDataAccessBase(model, convertRecords, getters, originalFieldNames, fieldNames);\n              that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);\n              that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);\n            }\n          },\n          errors: function (data) {\n            return data ? data.errors : null;\n          },\n          parse: identity,\n          data: identity,\n          total: function (data) {\n            return data.length;\n          },\n          groups: identity,\n          aggregates: function () {\n            return {};\n          },\n          serialize: function (data) {\n            return data;\n          }\n        });\n\n        function fillLastGroup(originalGroup, newGroup) {\n          var currOriginal;\n          var currentNew;\n\n          if (newGroup.items && newGroup.items.length) {\n            for (var i = 0; i < newGroup.items.length; i++) {\n              currOriginal = originalGroup.items[originalGroup.items.length - 1];\n              currentNew = newGroup.items[i];\n\n              if (currOriginal && currentNew) {\n                if (currOriginal.hasSubgroups && currOriginal.value == currentNew.value) {\n                  fillLastGroup(currOriginal, currentNew);\n                } else if (currOriginal.field && currOriginal.value == currentNew.value) {\n                  currOriginal.items.push.apply(currOriginal.items, currentNew.items);\n                } else {\n                  originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n                }\n              } else if (currentNew) {\n                originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n              }\n            }\n          }\n        }\n\n        function mergeGroups(target, dest, skip, take) {\n          var group,\n              idx = 0,\n              items;\n\n          while (dest.length && take) {\n            group = dest[idx];\n            items = group.items;\n            var length = items.length;\n\n            if (target && target.field === group.field && target.value === group.value) {\n              if (target.hasSubgroups && target.items.length) {\n                mergeGroups(target.items[target.items.length - 1], group.items, skip, take);\n              } else {\n                items = items.slice(skip, skip + take);\n                target.items = target.items.concat(items);\n              }\n\n              dest.splice(idx--, 1);\n            } else if (group.hasSubgroups && items.length) {\n              mergeGroups(group, items, skip, take);\n\n              if (!group.items.length) {\n                dest.splice(idx--, 1);\n              }\n            } else {\n              items = items.slice(skip, skip + take);\n              group.items = items;\n\n              if (!group.items.length) {\n                dest.splice(idx--, 1);\n              }\n            }\n\n            if (items.length === 0) {\n              skip -= length;\n            } else {\n              skip = 0;\n              take -= items.length;\n            }\n\n            if (++idx >= dest.length) {\n              break;\n            }\n          }\n\n          if (idx < dest.length) {\n            dest.splice(idx, dest.length - idx);\n          }\n        }\n\n        function flatGroups(groups, indexFunction) {\n          var result = [];\n          var groupsLength = (groups || []).length;\n          var group;\n          var items;\n          var indexFn = isFunction(indexFunction) ? indexFunction : function (array, index) {\n            return array[index];\n          };\n\n          for (var groupIndex = 0; groupIndex < groupsLength; groupIndex++) {\n            group = indexFn(groups, groupIndex);\n\n            if (group.hasSubgroups) {\n              result = result.concat(flatGroups(group.items));\n            } else {\n              items = group.items;\n\n              for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {\n                result.push(indexFn(items, itemIndex));\n              }\n            }\n          }\n\n          return result;\n        }\n\n        function flattenGroups(data) {\n          var idx,\n              result = [],\n              length,\n              items,\n              itemIndex;\n\n          for (idx = 0, length = data.length; idx < length; idx++) {\n            var group = data.at(idx);\n\n            if (group.items) {\n              if (group.hasSubgroups) {\n                result = result.concat(flattenGroups(group.items));\n              } else {\n                items = group.items;\n\n                for (itemIndex = 0; itemIndex < items.length; itemIndex++) {\n                  result.push(items.at(itemIndex));\n                }\n              }\n            }\n          }\n\n          return result;\n        }\n\n        function wrapGroupItems(data, model) {\n          var idx, length, group;\n\n          if (model) {\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              group = data.at(idx);\n\n              if (group.items) {\n                if (group.hasSubgroups) {\n                  wrapGroupItems(group.items, model);\n                } else {\n                  group.items = new LazyObservableArray(group.items, model, group.items._events);\n                }\n              }\n            }\n          }\n        }\n\n        function eachGroupItems(data, func) {\n          for (var idx = 0; idx < data.length; idx++) {\n            if (data[idx].hasSubgroups) {\n              if (eachGroupItems(data[idx].items, func)) {\n                return true;\n              }\n            } else if (func(data[idx].items, data[idx])) {\n              return true;\n            }\n          }\n        }\n\n        function replaceInRanges(ranges, data, item, observable) {\n          for (var idx = 0; idx < ranges.length; idx++) {\n            if (ranges[idx].data === data) {\n              break;\n            }\n\n            if (replaceInRange(ranges[idx].data, item, observable)) {\n              break;\n            }\n          }\n        }\n\n        function replaceInRange(items, item, observable) {\n          for (var idx = 0, length = items.length; idx < length; idx++) {\n            if (items[idx] && items[idx].hasSubgroups) {\n              return replaceInRange(items[idx].items, item, observable);\n            } else if (items[idx] === item || items[idx] === observable) {\n              items[idx] = observable;\n              return true;\n            }\n          }\n        }\n\n        function replaceWithObservable(view, data, ranges, type, serverGrouping) {\n          for (var viewIndex = 0, length = view.length; viewIndex < length; viewIndex++) {\n            var item = view[viewIndex];\n\n            if (!item || item instanceof type) {\n              continue;\n            }\n\n            if (item.hasSubgroups !== undefined && !serverGrouping) {\n              replaceWithObservable(item.items, data, ranges, type, serverGrouping);\n            } else {\n              for (var idx = 0; idx < data.length; idx++) {\n                if (data[idx] === item) {\n                  view[viewIndex] = data.at(idx);\n                  replaceInRanges(ranges, data, item, view[viewIndex]);\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        function removeModel(data, model) {\n          if (!data) {\n            return;\n          }\n\n          var length = data.length;\n          var dataItem;\n          var idx;\n\n          for (idx = 0; idx < length; idx++) {\n            dataItem = data[idx];\n\n            if (dataItem.uid && dataItem.uid == model.uid) {\n              data.splice(idx, 1);\n              return dataItem;\n            }\n          }\n        }\n\n        function indexOfPristineModel(data, model) {\n          if (model) {\n            return indexOf(data, function (item) {\n              return item.uid && item.uid == model.uid || item[model.idField] === model.id && model.id !== model._defaultId;\n            });\n          }\n\n          return -1;\n        }\n\n        function indexOfModel(data, model) {\n          if (model) {\n            return indexOf(data, function (item) {\n              return item.uid == model.uid;\n            });\n          }\n\n          return -1;\n        }\n\n        function indexOf(data, comparer) {\n          var idx, length;\n\n          if (!data) {\n            return;\n          }\n\n          for (idx = 0, length = data.length; idx < length; idx++) {\n            if (comparer(data[idx])) {\n              return idx;\n            }\n          }\n\n          return -1;\n        }\n\n        function fieldNameFromModel(fields, name) {\n          if (fields && !isEmptyObject(fields)) {\n            var descriptor = fields[name];\n            var fieldName;\n\n            if (isPlainObject(descriptor)) {\n              fieldName = descriptor.from || descriptor.field || name;\n            } else {\n              fieldName = fields[name] || name;\n            }\n\n            if (isFunction(fieldName)) {\n              return name;\n            }\n\n            return fieldName;\n          }\n\n          return name;\n        }\n\n        function convertFilterDescriptorsField(descriptor, model) {\n          var idx,\n              length,\n              target = {};\n\n          for (var field in descriptor) {\n            if (field !== \"filters\") {\n              target[field] = descriptor[field];\n            }\n          }\n\n          if (descriptor.filters) {\n            target.filters = [];\n\n            for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {\n              target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);\n            }\n          } else {\n            target.field = fieldNameFromModel(model.fields, target.field);\n          }\n\n          return target;\n        }\n\n        function convertDescriptorsField(descriptors, model) {\n          var idx,\n              length,\n              result = [],\n              target,\n              descriptor;\n\n          for (idx = 0, length = descriptors.length; idx < length; idx++) {\n            target = {};\n            descriptor = descriptors[idx];\n\n            for (var field in descriptor) {\n              target[field] = descriptor[field];\n            }\n\n            target.field = fieldNameFromModel(model.fields, target.field);\n\n            if (target.aggregates && isArray(target.aggregates)) {\n              target.aggregates = convertDescriptorsField(target.aggregates, model);\n            }\n\n            result.push(target);\n          }\n\n          return result;\n        }\n\n        var DataSource = Observable.extend({\n          init: function (options) {\n            var that = this,\n                model,\n                data;\n\n            if (options) {\n              data = options.data;\n            }\n\n            options = that.options = extend({}, that.options, options);\n            that._map = {};\n            that._prefetch = {};\n            that._data = [];\n            that._pristineData = [];\n            that._ranges = [];\n            that._view = [];\n            that._pristineTotal = 0;\n            that._destroyed = [];\n            that._pageSize = options.pageSize;\n            that._page = options.page || (options.pageSize ? 1 : undefined);\n            that._sort = normalizeSort(options.sort);\n            that._sortFields = sortFields(options.sort);\n            that._filter = normalizeFilter(options.filter);\n            that._group = normalizeGroup(options.group);\n            that._aggregate = options.aggregate;\n            that._total = options.total;\n            that._groupPaging = options.groupPaging;\n\n            if (that._groupPaging) {\n              that._groupsState = {};\n            }\n\n            that._shouldDetachObservableParents = true;\n            Observable.fn.init.call(that);\n            that.transport = Transport.create(options, data, that);\n\n            if (isFunction(that.transport.push)) {\n              that.transport.push({\n                pushCreate: that._pushCreate.bind(that),\n                pushUpdate: that._pushUpdate.bind(that),\n                pushDestroy: that._pushDestroy.bind(that)\n              });\n            }\n\n            if (options.offlineStorage != null) {\n              if (typeof options.offlineStorage == \"string\") {\n                var key = options.offlineStorage;\n                that._storage = {\n                  getItem: function () {\n                    return JSON.parse(localStorage.getItem(key));\n                  },\n                  setItem: function (item) {\n                    localStorage.setItem(key, stringify(that.reader.serialize(item)));\n                  }\n                };\n              } else {\n                that._storage = options.offlineStorage;\n              }\n            }\n\n            that.reader = new kendo.data.readers[options.schema.type || \"json\"](options.schema);\n            model = that.reader.model || {};\n\n            that._detachObservableParents();\n\n            that._data = that._observe(that._data);\n            that._online = true;\n            that.bind([\"push\", ERROR, CHANGE, REQUESTSTART, SYNC, REQUESTEND, PROGRESS], options);\n          },\n          options: {\n            data: null,\n            schema: {\n              modelBase: Model\n            },\n            offlineStorage: null,\n            serverSorting: false,\n            serverPaging: false,\n            serverFiltering: false,\n            serverGrouping: false,\n            serverAggregates: false,\n            batch: false,\n            inPlaceSort: false\n          },\n          clone: function () {\n            return this;\n          },\n          online: function (value) {\n            if (value !== undefined) {\n              if (this._online != value) {\n                this._online = value;\n\n                if (value) {\n                  return this.sync();\n                }\n              }\n\n              return $.Deferred().resolve().promise();\n            } else {\n              return this._online;\n            }\n          },\n          offlineData: function (state) {\n            if (this.options.offlineStorage == null) {\n              return null;\n            }\n\n            if (state !== undefined) {\n              return this._storage.setItem(state);\n            }\n\n            return this._storage.getItem() || [];\n          },\n          _isServerGrouped: function () {\n            var group = this.group() || [];\n            return this.options.serverGrouping && group.length;\n          },\n          _isServerGroupPaged: function () {\n            return this._isServerGrouped() && this._groupPaging;\n          },\n          _isGroupPaged: function () {\n            var group = this._group || [];\n            return this._groupPaging && group.length;\n          },\n          _pushCreate: function (result) {\n            this._push(result, \"pushCreate\");\n          },\n          _pushUpdate: function (result) {\n            this._push(result, \"pushUpdate\");\n          },\n          _pushDestroy: function (result) {\n            this._push(result, \"pushDestroy\");\n          },\n          _push: function (result, operation) {\n            var data = this._readData(result);\n\n            if (!data) {\n              data = result;\n            }\n\n            this[operation](data);\n          },\n          _flatData: function (data, skip) {\n            if (data) {\n              if (this._isServerGrouped()) {\n                return flattenGroups(data);\n              }\n\n              if (!skip) {\n                for (var idx = 0; idx < data.length; idx++) {\n                  data.at(idx);\n                }\n              }\n            }\n\n            return data;\n          },\n          parent: noop,\n          get: function (id) {\n            var idx,\n                length,\n                data = this._flatData(this._data, this.options.useRanges);\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              if (data[idx].id == id) {\n                return data[idx];\n              }\n            }\n          },\n          getByUid: function (id) {\n            return this._getByUid(id, this._data);\n          },\n          _getByUid: function (id, dataItems) {\n            var idx,\n                length,\n                data = this._flatData(dataItems, this.options.useRanges);\n\n            if (!data) {\n              return;\n            }\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              if (data[idx].uid == id) {\n                return data[idx];\n              }\n            }\n          },\n          indexOf: function (model) {\n            return indexOfModel(this._data, model);\n          },\n          at: function (index) {\n            return this._data.at(index);\n          },\n          data: function (value) {\n            var that = this;\n\n            if (value !== undefined) {\n              that._detachObservableParents();\n\n              that._data = this._observe(value);\n              that._pristineData = value.slice(0);\n\n              that._storeData();\n\n              that._ranges = [];\n              that.trigger(\"reset\");\n\n              that._addRange(that._data);\n\n              that._total = that._data.length;\n              that._pristineTotal = that._total;\n\n              that._process(that._data);\n            } else {\n              if (that._data) {\n                for (var idx = 0; idx < that._data.length; idx++) {\n                  that._data.at(idx);\n                }\n              }\n\n              return that._data;\n            }\n          },\n          view: function (value) {\n            if (value === undefined) {\n              return this._view;\n            } else {\n              this._view = this._observeView(value);\n            }\n          },\n          _observeView: function (data) {\n            var that = this;\n            replaceWithObservable(data, that._data, that._ranges, that.reader.model || ObservableObject, that._isServerGrouped());\n            var view = new LazyObservableArray(data, that.reader.model);\n\n            view.parent = function () {\n              return that.parent();\n            };\n\n            return view;\n          },\n          flatView: function () {\n            var groups = this.group() || [];\n\n            if (groups.length) {\n              return flattenGroups(this._view);\n            } else {\n              return this._view;\n            }\n          },\n          add: function (model) {\n            return this.insert(this._data.length, model);\n          },\n          _createNewModel: function (model) {\n            if (this.reader.model) {\n              return new this.reader.model(model);\n            }\n\n            if (model instanceof ObservableObject) {\n              return model;\n            }\n\n            return new ObservableObject(model);\n          },\n          insert: function (index, model) {\n            if (!model) {\n              model = index;\n              index = 0;\n            }\n\n            if (!(model instanceof Model)) {\n              model = this._createNewModel(model);\n            }\n\n            if (this._isServerGrouped()) {\n              this._data.splice(index, 0, this._wrapInEmptyGroup(model));\n            } else {\n              this._data.splice(index, 0, model);\n            }\n\n            this._insertModelInRange(index, model);\n\n            return model;\n          },\n          pushInsert: function (index, items) {\n            var that = this;\n\n            var rangeSpan = that._getCurrentRangeSpan();\n\n            if (!items) {\n              items = index;\n              index = 0;\n            }\n\n            if (!isArray(items)) {\n              items = [items];\n            }\n\n            var pushed = [];\n            var autoSync = this.options.autoSync;\n            this.options.autoSync = false;\n\n            try {\n              for (var idx = 0; idx < items.length; idx++) {\n                var item = items[idx];\n                var result = this.insert(index, item);\n                pushed.push(result);\n                var pristine = result.toJSON();\n\n                if (this._isServerGrouped()) {\n                  pristine = this._wrapInEmptyGroup(pristine);\n                }\n\n                this._pristineData.push(pristine);\n\n                if (rangeSpan && rangeSpan.length) {\n                  $(rangeSpan).last()[0].pristineData.push(pristine);\n                }\n\n                index++;\n              }\n            } finally {\n              this.options.autoSync = autoSync;\n            }\n\n            if (pushed.length) {\n              this.trigger(\"push\", {\n                type: \"create\",\n                items: pushed\n              });\n            }\n          },\n          pushCreate: function (items) {\n            this.pushInsert(this._data.length, items);\n          },\n          pushUpdate: function (items) {\n            if (!isArray(items)) {\n              items = [items];\n            }\n\n            var pushed = [];\n\n            for (var idx = 0; idx < items.length; idx++) {\n              var item = items[idx];\n\n              var model = this._createNewModel(item);\n\n              var target = this.get(model.id);\n\n              if (target) {\n                pushed.push(target);\n                target.accept(item);\n                target.trigger(CHANGE);\n\n                this._updatePristineForModel(target, item);\n              } else {\n                this.pushCreate(item);\n              }\n            }\n\n            if (pushed.length) {\n              this.trigger(\"push\", {\n                type: \"update\",\n                items: pushed\n              });\n            }\n          },\n          pushDestroy: function (items) {\n            var pushed = this._removeItems(items);\n\n            if (pushed.length) {\n              this.trigger(\"push\", {\n                type: \"destroy\",\n                items: pushed\n              });\n            }\n          },\n          _removeItems: function (items, removePristine) {\n            if (!isArray(items)) {\n              items = [items];\n            }\n\n            var shouldRemovePristine = typeof removePristine !== \"undefined\" ? removePristine : true;\n            var destroyed = [];\n            var autoSync = this.options.autoSync;\n            this.options.autoSync = false;\n\n            try {\n              for (var idx = 0; idx < items.length; idx++) {\n                var item = items[idx];\n\n                var model = this._createNewModel(item);\n\n                var found = false;\n\n                this._eachItem(this._data, function (items) {\n                  for (var idx = 0; idx < items.length; idx++) {\n                    var item = items.at(idx);\n\n                    if (item.id === model.id) {\n                      destroyed.push(item);\n                      items.splice(idx, 1);\n                      found = true;\n                      break;\n                    }\n                  }\n                });\n\n                if (found && shouldRemovePristine) {\n                  this._removePristineForModel(model);\n\n                  this._destroyed.pop();\n                }\n              }\n            } finally {\n              this.options.autoSync = autoSync;\n            }\n\n            return destroyed;\n          },\n          pushMove: function (index, items) {\n            var pushed = this._moveItems(index, items);\n\n            if (pushed.length) {\n              this.trigger(\"push\", {\n                type: \"update\",\n                items: pushed\n              });\n            }\n          },\n          _moveItems: function (index, items) {\n            if (!isArray(items)) {\n              items = [items];\n            }\n\n            var moved = [];\n            var autoSync = this.options.autoSync;\n            this.options.autoSync = false;\n\n            try {\n              for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n\n                var model = this._createNewModel(item);\n\n                this._eachItem(this._data, function (dataItems) {\n                  for (var idx = 0; idx < dataItems.length; idx++) {\n                    var dataItem = dataItems.at(idx);\n\n                    if (dataItem.id === model.id) {\n                      moved.push(dataItem);\n                      dataItems.splice(index >= idx ? --index : index, 0, dataItems.splice(idx, 1)[0]);\n                      index++;\n                      break;\n                    }\n                  }\n                });\n              }\n            } finally {\n              this.options.autoSync = autoSync;\n            }\n\n            return moved;\n          },\n          remove: function (model) {\n            var result,\n                that = this,\n                hasGroups = that._isServerGrouped();\n\n            if (hasGroups && model.uid && (!model.isNew || !model.isNew())) {\n              that._destroyed.push(model);\n            }\n\n            this._eachItem(that._data, function (items) {\n              result = removeModel(items, model);\n\n              if (result && hasGroups) {\n                return true;\n              }\n            });\n\n            this._removeModelFromRanges(model);\n\n            return model;\n          },\n          destroyed: function () {\n            return this._destroyed;\n          },\n          created: function () {\n            var idx,\n                length,\n                result = [],\n                data = this._flatData(this._data, this.options.useRanges);\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              if (data[idx].isNew && data[idx].isNew()) {\n                result.push(data[idx]);\n              }\n            }\n\n            return result;\n          },\n          updated: function () {\n            var idx,\n                length,\n                result = [],\n                data = this._flatData(this._data, this.options.useRanges);\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              if (data[idx].isNew && !data[idx].isNew() && data[idx].dirty) {\n                result.push(data[idx]);\n              }\n            }\n\n            return result;\n          },\n          sync: function () {\n            var that = this,\n                created = [],\n                updated = [],\n                destroyed = that._destroyed;\n            var promise = $.Deferred().resolve().promise();\n\n            if (that.online()) {\n              if (!that.reader.model) {\n                return promise;\n              }\n\n              created = that.created();\n              updated = that.updated();\n              var promises = [];\n\n              if (that.options.batch && that.transport.submit) {\n                promises = that._sendSubmit(created, updated, destroyed);\n              } else {\n                promises.push.apply(promises, that._send(\"create\", created));\n                promises.push.apply(promises, that._send(\"update\", updated));\n                promises.push.apply(promises, that._send(\"destroy\", destroyed));\n              }\n\n              promise = $.when.apply(null, promises).then(function () {\n                var idx, length;\n\n                for (idx = 0, length = arguments.length; idx < length; idx++) {\n                  if (arguments[idx]) {\n                    that._accept(arguments[idx]);\n                  }\n                }\n\n                that._storeData(true);\n\n                that._syncEnd();\n\n                that._change({\n                  action: \"sync\"\n                });\n\n                that.trigger(SYNC);\n\n                if (that._isServerGroupPaged()) {\n                  that.read();\n                }\n              });\n            } else {\n              that._storeData(true);\n\n              that._syncEnd();\n\n              that._change({\n                action: \"sync\"\n              });\n            }\n\n            return promise;\n          },\n          _syncEnd: noop,\n          cancelChanges: function (model) {\n            var that = this;\n\n            if (model instanceof kendo.data.Model) {\n              that._cancelModel(model);\n            } else {\n              that._destroyed = [];\n\n              that._detachObservableParents();\n\n              that._data = that._observe(that._pristineData);\n\n              if (that.options.serverPaging) {\n                that._total = that._pristineTotal;\n              }\n\n              that._ranges = [];\n\n              that._addRange(that._data, 0);\n\n              that._changesCanceled();\n\n              that._change();\n\n              that._markOfflineUpdatesAsDirty();\n\n              if (that._isServerGrouped()) {\n                that.read();\n              }\n            }\n          },\n          _changesCanceled: noop,\n          _markOfflineUpdatesAsDirty: function () {\n            var that = this;\n\n            if (that.options.offlineStorage != null) {\n              that._eachItem(that._data, function (items) {\n                for (var idx = 0; idx < items.length; idx++) {\n                  var item = items.at(idx);\n\n                  if (item.__state__ == \"update\" || item.__state__ == \"create\") {\n                    item.dirty = true;\n                  }\n                }\n              });\n            }\n          },\n          hasChanges: function () {\n            var idx,\n                length,\n                data = this._flatData(this._data, this.options.useRanges);\n\n            if (this._destroyed.length) {\n              return true;\n            }\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              if (data[idx].isNew && data[idx].isNew() || data[idx].dirty) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _accept: function (result) {\n            var that = this,\n                models = result.models,\n                response = result.response,\n                idx = 0,\n                serverGroup = that._isServerGrouped(),\n                pristine = that._pristineData,\n                type = result.type,\n                length;\n\n            that.trigger(REQUESTEND, {\n              response: response,\n              type: type\n            });\n\n            if (response && !isEmptyObject(response)) {\n              response = that.reader.parse(response);\n\n              if (that._handleCustomErrors(response)) {\n                return;\n              }\n\n              response = that.reader.data(response);\n\n              if (!isArray(response)) {\n                response = [response];\n              }\n            } else {\n              response = $.map(models, function (model) {\n                return model.toJSON();\n              });\n            }\n\n            if (type === \"destroy\") {\n              that._destroyed = [];\n            }\n\n            for (idx = 0, length = models.length; idx < length; idx++) {\n              if (type !== \"destroy\") {\n                models[idx].accept(response[idx]);\n\n                if (type === \"create\") {\n                  pristine.push(serverGroup ? that._wrapInEmptyGroup(models[idx].toJSON()) : response[idx]);\n                } else if (type === \"update\") {\n                  that._updatePristineForModel(models[idx], response[idx]);\n                }\n              } else {\n                that._removePristineForModel(models[idx]);\n              }\n            }\n          },\n          _updatePristineForModel: function (model, values) {\n            this._executeOnPristineForModel(model, function (index, items) {\n              kendo.deepExtend(items[index], values);\n            });\n          },\n          _executeOnPristineForModel: function (model, callback) {\n            this._eachPristineItem(function (items) {\n              var index = indexOfPristineModel(items, model);\n\n              if (index > -1) {\n                callback(index, items);\n                return true;\n              }\n            });\n          },\n          _removePristineForModel: function (model) {\n            this._executeOnPristineForModel(model, function (index, items) {\n              items.splice(index, 1);\n            });\n          },\n          _readData: function (data) {\n            var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;\n            return read.call(this.reader, data);\n          },\n          _eachPristineItem: function (callback) {\n            var that = this;\n            var options = that.options;\n\n            var rangeSpan = that._getCurrentRangeSpan();\n\n            that._eachItem(that._pristineData, callback);\n\n            if (options.serverPaging && options.useRanges) {\n              each(rangeSpan, function (i, range) {\n                that._eachItem(range.pristineData, callback);\n              });\n            }\n          },\n          _eachItem: function (data, callback) {\n            if (data && data.length) {\n              if (this._isServerGrouped()) {\n                eachGroupItems(data, callback);\n              } else {\n                callback(data);\n              }\n            }\n          },\n          _pristineForModel: function (model) {\n            var pristine,\n                idx,\n                callback = function (items) {\n              idx = indexOfPristineModel(items, model);\n\n              if (idx > -1) {\n                pristine = items[idx];\n                return true;\n              }\n            };\n\n            this._eachPristineItem(callback);\n\n            return pristine;\n          },\n          _cancelModel: function (model) {\n            var that = this;\n\n            var pristine = this._pristineForModel(model);\n\n            this._eachItem(this._data, function (items) {\n              var idx = indexOfModel(items, model);\n\n              if (idx >= 0) {\n                if (pristine && (!model.isNew() || pristine.__state__)) {\n                  items[idx].accept(pristine);\n\n                  if (pristine.__state__ == \"update\") {\n                    items[idx].dirty = true;\n                  }\n                } else {\n                  that._modelCanceled(model);\n\n                  items.splice(idx, 1);\n\n                  that._removeModelFromRanges(model);\n                }\n              }\n            });\n          },\n          _modelCanceled: noop,\n          _submit: function (promises, data) {\n            var that = this;\n            that.trigger(REQUESTSTART, {\n              type: \"submit\"\n            });\n            that.trigger(PROGRESS);\n            that.transport.submit(extend({\n              success: function (response, type) {\n                var promise = $.grep(promises, function (x) {\n                  return x.type == type;\n                })[0];\n\n                if (promise) {\n                  promise.resolve({\n                    response: response,\n                    models: promise.models,\n                    type: type\n                  });\n                }\n              },\n              error: function (response, status, error) {\n                for (var idx = 0; idx < promises.length; idx++) {\n                  promises[idx].reject(response);\n                }\n\n                that.error(response, status, error);\n              }\n            }, data));\n          },\n          _sendSubmit: function (created, updated, destroyed) {\n            var that = this,\n                promises = [];\n\n            if (that.options.batch) {\n              if (created.length) {\n                promises.push($.Deferred(function (deferred) {\n                  deferred.type = \"create\";\n                  deferred.models = created;\n                }));\n              }\n\n              if (updated.length) {\n                promises.push($.Deferred(function (deferred) {\n                  deferred.type = \"update\";\n                  deferred.models = updated;\n                }));\n              }\n\n              if (destroyed.length) {\n                promises.push($.Deferred(function (deferred) {\n                  deferred.type = \"destroy\";\n                  deferred.models = destroyed;\n                }));\n              }\n\n              that._submit(promises, {\n                data: {\n                  created: that.reader.serialize(toJSON(created)),\n                  updated: that.reader.serialize(toJSON(updated)),\n                  destroyed: that.reader.serialize(toJSON(destroyed))\n                }\n              });\n            }\n\n            return promises;\n          },\n          _promise: function (data, models, type) {\n            var that = this;\n            return $.Deferred(function (deferred) {\n              that.trigger(REQUESTSTART, {\n                type: type\n              });\n              that.trigger(PROGRESS);\n              that.transport[type].call(that.transport, extend({\n                success: function (response) {\n                  deferred.resolve({\n                    response: response,\n                    models: models,\n                    type: type\n                  });\n                },\n                error: function (response, status, error) {\n                  deferred.reject(response);\n                  that.error(response, status, error);\n                }\n              }, data));\n            }).promise();\n          },\n          _send: function (method, data) {\n            var that = this,\n                idx,\n                length,\n                promises = [],\n                converted = that.reader.serialize(toJSON(data));\n\n            if (that.options.batch) {\n              if (data.length) {\n                promises.push(that._promise({\n                  data: {\n                    models: converted\n                  }\n                }, data, method));\n              }\n            } else {\n              for (idx = 0, length = data.length; idx < length; idx++) {\n                promises.push(that._promise({\n                  data: converted[idx]\n                }, [data[idx]], method));\n              }\n            }\n\n            return promises;\n          },\n          read: function (data) {\n            var that = this,\n                params = that._params(data);\n\n            var deferred = $.Deferred();\n\n            that._queueRequest(params, function () {\n              var isPrevented = that.trigger(REQUESTSTART, {\n                type: \"read\"\n              });\n\n              if (!isPrevented) {\n                that.trigger(PROGRESS);\n                that._ranges = [];\n                that.trigger(\"reset\");\n\n                if (that.online()) {\n                  that.transport.read({\n                    data: params,\n                    success: function (data) {\n                      that._ranges = [];\n                      that.success(data, params);\n                      deferred.resolve();\n                    },\n                    error: function () {\n                      var args = slice.call(arguments);\n                      that.error.apply(that, args);\n                      deferred.reject.apply(deferred, args);\n                    }\n                  });\n                } else if (that.options.offlineStorage != null) {\n                  that.success(that.offlineData(), params);\n                  deferred.resolve();\n                }\n              } else {\n                that._dequeueRequest();\n\n                deferred.resolve(isPrevented);\n              }\n            });\n\n            return deferred.promise();\n          },\n          _readAggregates: function (data) {\n            return this.reader.aggregates(data);\n          },\n          success: function (data) {\n            var that = this,\n                options = that.options,\n                items,\n                replaceSubset;\n            that.trigger(REQUESTEND, {\n              response: data,\n              type: \"read\"\n            });\n\n            if (that.online()) {\n              data = that.reader.parse(data);\n\n              if (that._handleCustomErrors(data)) {\n                that._dequeueRequest();\n\n                return;\n              }\n\n              that._total = that.reader.total(data);\n\n              if (that._isServerGroupPaged()) {\n                that._serverGroupsTotal = that._total;\n              }\n\n              if (that._pageSize > that._total) {\n                that._pageSize = that._total;\n\n                if (that.options.pageSize && that.options.pageSize > that._pageSize) {\n                  that._pageSize = that.options.pageSize;\n                }\n              }\n\n              if (that._aggregate && options.serverAggregates) {\n                that._aggregateResult = that._readAggregates(data);\n              }\n\n              data = that._readData(data);\n              that._destroyed = [];\n            } else {\n              data = that._readData(data);\n              items = [];\n              var itemIds = {};\n              var model = that.reader.model;\n              var idField = model ? model.idField : \"id\";\n              var idx;\n\n              for (idx = 0; idx < this._destroyed.length; idx++) {\n                var id = this._destroyed[idx][idField];\n                itemIds[id] = id;\n              }\n\n              for (idx = 0; idx < data.length; idx++) {\n                var item = data[idx];\n                var state = item.__state__;\n\n                if (state == \"destroy\") {\n                  if (!itemIds[item[idField]]) {\n                    this._destroyed.push(this._createNewModel(item));\n                  }\n                } else {\n                  items.push(item);\n                }\n              }\n\n              data = items;\n              that._total = data.length;\n            }\n\n            that._pristineTotal = that._total;\n            replaceSubset = that._skip && that._data.length && that._skip < that._data.length;\n\n            if (that.options.endless) {\n              if (replaceSubset) {\n                that._pristineData.splice(that._skip, that._pristineData.length);\n              }\n\n              items = data.slice(0);\n\n              for (var j = 0; j < items.length; j++) {\n                that._pristineData.push(items[j]);\n              }\n            } else {\n              that._pristineData = data.slice(0);\n            }\n\n            that._detachObservableParents();\n\n            if (that.options.endless) {\n              that._data.unbind(CHANGE, that._changeHandler);\n\n              if (that._isServerGrouped() && that._data[that._data.length - 1].value === data[0].value) {\n                fillLastGroup(that._data[that._data.length - 1], data[0]);\n                data.shift();\n              }\n\n              data = that._observe(data);\n\n              if (replaceSubset) {\n                that._data.splice(that._skip, that._data.length);\n              }\n\n              for (var i = 0; i < data.length; i++) {\n                that._data.push(data[i]);\n              }\n\n              that._data.bind(CHANGE, that._changeHandler);\n            } else {\n              that._data = that._observe(data);\n            }\n\n            that._markOfflineUpdatesAsDirty();\n\n            that._storeData();\n\n            that._addRange(that._data);\n\n            that._process(that._data);\n\n            that._dequeueRequest();\n          },\n          _detachObservableParents: function () {\n            if (this._data && this._shouldDetachObservableParents) {\n              for (var idx = 0; idx < this._data.length; idx++) {\n                if (this._data[idx].parent) {\n                  this._data[idx].parent = noop;\n                }\n              }\n            }\n          },\n          _storeData: function (updatePristine) {\n            var serverGrouping = this._isServerGrouped();\n\n            var model = this.reader.model;\n\n            function items(data) {\n              var state = [];\n\n              for (var idx = 0; idx < data.length; idx++) {\n                var dataItem = data.at(idx);\n                var item = dataItem.toJSON();\n\n                if (serverGrouping && dataItem.items) {\n                  item.items = items(dataItem.items);\n                } else {\n                  item.uid = dataItem.uid;\n\n                  if (model) {\n                    if (dataItem.isNew()) {\n                      item.__state__ = \"create\";\n                    } else if (dataItem.dirty) {\n                      item.__state__ = \"update\";\n                    }\n                  }\n                }\n\n                state.push(item);\n              }\n\n              return state;\n            }\n\n            if (this.options.offlineStorage != null) {\n              var state = items(this._data);\n              var destroyed = [];\n\n              for (var idx = 0; idx < this._destroyed.length; idx++) {\n                var item = this._destroyed[idx].toJSON();\n\n                item.__state__ = \"destroy\";\n                destroyed.push(item);\n              }\n\n              this.offlineData(state.concat(destroyed));\n\n              if (updatePristine) {\n                this._pristineData = this.reader.reader ? this.reader.reader._wrapDataAccessBase(state) : this.reader._wrapDataAccessBase(state);\n              }\n            }\n          },\n          _addRange: function (data, skip) {\n            var that = this,\n                start = typeof skip !== \"undefined\" ? skip : that._skip || 0,\n                end,\n                range = {\n              data: data,\n              pristineData: data.toJSON(),\n              timestamp: that._timeStamp()\n            };\n\n            if (this._isGroupPaged()) {\n              end = start + data.length;\n              range.outerStart = start;\n              range.outerEnd = end;\n            } else {\n              end = start + that._flatData(data, true).length;\n            }\n\n            range.start = start;\n            range.end = end;\n\n            that._ranges.push(range);\n\n            that._sortRanges();\n\n            if (that._isGroupPaged()) {\n              if (!that._groupsFlat) {\n                that._groupsFlat = [];\n              }\n\n              that._appendToGroupsFlat(range.data);\n\n              that._updateOuterRangesLength();\n            }\n          },\n          _appendToGroupsFlat: function (data) {\n            var length = data.length;\n\n            for (var i = 0; i < length; i++) {\n              this._groupsFlat.push(data[i]);\n            }\n          },\n          _getGroupByUid: function (uid) {\n            var length = this._groupsFlat.length;\n            var group;\n\n            for (var i = 0; i < length; i++) {\n              group = this._groupsFlat[i];\n\n              if (group.uid === uid) {\n                return group;\n              }\n            }\n          },\n          _sortRanges: function () {\n            this._ranges.sort(function (x, y) {\n              return x.start - y.start;\n            });\n          },\n          error: function (xhr, status, errorThrown) {\n            this._dequeueRequest();\n\n            this.trigger(REQUESTEND, {});\n            this.trigger(ERROR, {\n              xhr: xhr,\n              status: status,\n              errorThrown: errorThrown\n            });\n          },\n          _params: function (data) {\n            var that = this,\n                options = extend({\n              take: that.take(),\n              skip: that.skip(),\n              page: that.page(),\n              pageSize: that.pageSize(),\n              sort: that._sort,\n              filter: that._filter,\n              group: that._group,\n              aggregate: that._aggregate,\n              groupPaging: !!that._groupPaging\n            }, data);\n\n            if (!that.options.serverPaging) {\n              delete options.take;\n              delete options.skip;\n              delete options.page;\n              delete options.pageSize;\n            }\n\n            if (!that.options.serverGrouping) {\n              delete options.group;\n            } else if (that.reader.model && options.group) {\n              options.group = convertDescriptorsField(options.group, that.reader.model);\n            }\n\n            if (!that.options.serverFiltering) {\n              delete options.filter;\n            } else if (that.reader.model && options.filter) {\n              options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);\n            }\n\n            if (!that.options.serverSorting) {\n              delete options.sort;\n            } else if (that.reader.model && options.sort) {\n              options.sort = convertDescriptorsField(options.sort, that.reader.model);\n            }\n\n            if (!that.options.serverAggregates) {\n              delete options.aggregate;\n            } else if (that.reader.model && options.aggregate) {\n              options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);\n            }\n\n            if (!that.options.groupPaging) {\n              delete options.groupPaging;\n            }\n\n            return options;\n          },\n          _queueRequest: function (options, callback) {\n            var that = this;\n\n            if (!that._requestInProgress) {\n              that._requestInProgress = true;\n              that._pending = undefined;\n              callback();\n            } else {\n              that._pending = {\n                callback: callback.bind(that),\n                options: options\n              };\n            }\n          },\n          _dequeueRequest: function () {\n            var that = this;\n            that._requestInProgress = false;\n\n            if (that._pending) {\n              that._queueRequest(that._pending.options, that._pending.callback);\n            }\n          },\n          _handleCustomErrors: function (response) {\n            if (this.reader.errors) {\n              var errors = this.reader.errors(response);\n\n              if (errors) {\n                this.trigger(ERROR, {\n                  xhr: null,\n                  status: \"customerror\",\n                  errorThrown: \"custom error\",\n                  errors: errors\n                });\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _shouldWrap: function (data) {\n            var model = this.reader.model;\n\n            if (model && data.length) {\n              return !(data[0] instanceof model);\n            }\n\n            return false;\n          },\n          _observe: function (data) {\n            var that = this,\n                model = that.reader.model;\n            that._shouldDetachObservableParents = true;\n\n            if (data instanceof ObservableArray) {\n              that._shouldDetachObservableParents = false;\n\n              if (that._shouldWrap(data)) {\n                data.type = that.reader.model;\n                data.wrapAll(data, data);\n              }\n            } else {\n              var arrayType = that.pageSize() && !that.options.serverPaging ? LazyObservableArray : ObservableArray;\n              data = new arrayType(data, that.reader.model);\n\n              data.parent = function () {\n                return that.parent();\n              };\n            }\n\n            if (that._isServerGrouped()) {\n              wrapGroupItems(data, model);\n            }\n\n            if (that._changeHandler && that._data && that._data instanceof ObservableArray && !(that.options.useRanges && that.options.serverPaging)) {\n              that._data.unbind(CHANGE, that._changeHandler);\n            } else {\n              that._changeHandler = that._change.bind(that);\n            }\n\n            return data.bind(CHANGE, that._changeHandler);\n          },\n          _updateTotalForAction: function (action, items) {\n            var that = this;\n            var total = parseInt(that._total, 10);\n\n            if (!isNumber(that._total)) {\n              total = parseInt(that._pristineTotal, 10);\n            }\n\n            if (action === \"add\") {\n              total += items.length;\n            } else if (action === \"remove\") {\n              total -= items.length;\n            } else if (action !== \"itemchange\" && action !== \"sync\" && !that.options.serverPaging) {\n              total = that._pristineTotal;\n            } else if (action === \"sync\") {\n              total = that._pristineTotal = parseInt(that._total, 10);\n            }\n\n            that._total = total;\n          },\n          _change: function (e) {\n            var that = this,\n                idx,\n                length,\n                action = e ? e.action : \"\";\n\n            if (action === \"remove\") {\n              for (idx = 0, length = e.items.length; idx < length; idx++) {\n                if (!e.items[idx].isNew || !e.items[idx].isNew()) {\n                  that._destroyed.push(e.items[idx]);\n                }\n              }\n            }\n\n            if (that.options.autoSync && (action === \"add\" || action === \"remove\" || action === \"itemchange\")) {\n              var handler = function (args) {\n                if (args.action === \"sync\") {\n                  that.unbind(\"change\", handler);\n\n                  that._updateTotalForAction(action, e.items);\n                }\n              };\n\n              that.first(\"change\", handler);\n              that.sync();\n            } else {\n              that._updateTotalForAction(action, e ? e.items : []);\n\n              that._process(that._data, e);\n            }\n          },\n          _calculateAggregates: function (data, options) {\n            options = options || {};\n            var query = new Query(data),\n                aggregates = options.aggregate,\n                filter = options.filter;\n\n            if (filter) {\n              query = query.filter(filter);\n            }\n\n            return query.aggregate(aggregates);\n          },\n          _process: function (data, e) {\n            var that = this,\n                options = {},\n                result;\n\n            if (that.options.serverPaging !== true) {\n              options.skip = that._skip;\n              options.take = that._take || that._pageSize;\n\n              if (options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {\n                options.skip = (that._page - 1) * that._pageSize;\n              }\n\n              if (that.options.useRanges) {\n                options.skip = that.currentRangeStart();\n              }\n            }\n\n            if (that.options.serverSorting !== true) {\n              options.sort = that._sort;\n            }\n\n            if (that.options.serverFiltering !== true) {\n              options.filter = that._filter;\n            }\n\n            if (that.options.serverGrouping !== true) {\n              options.group = that._group;\n            }\n\n            if (that.options.serverAggregates !== true) {\n              options.aggregate = that._aggregate;\n            }\n\n            if (that.options.serverGrouping) {\n              that._clearEmptyGroups(data);\n            }\n\n            options.groupPaging = that._groupPaging;\n\n            if (that._isGroupPaged() && e && (e.action === \"page\" || e.action === \"expandGroup\" || e.action === \"collapseGroup\")) {\n              result = that._queryProcess(data, {\n                aggregate: that._aggregate\n              });\n            } else {\n              result = that._queryProcess(data, options);\n            }\n\n            if (that.options.serverAggregates !== true) {\n              // for performance reasons, calculate aggregates for part of the data only after query process\n              // this is necessary in the TreeList when paging\n              that._aggregateResult = that._calculateAggregates(result.dataToAggregate || data, options);\n            }\n\n            that._setView(result, options, e);\n\n            that._setFilterTotal(result.total, false);\n\n            e = e || {};\n            e.items = e.items || that._view;\n            that.trigger(CHANGE, e);\n          },\n          _setView: function (result, options, e) {\n            var that = this;\n\n            if (that._isGroupPaged() && !that._isServerGrouped()) {\n              if (e && (e.action === \"page\" || e.action === \"expandGroup\" || e.action === \"collapseGroup\")) {\n                that.view(result.data);\n\n                that._updateOuterRangesLength();\n              } else {\n                that._ranges = [];\n                var query = new Query(result.data);\n\n                that._addRange(that._observe(result.data));\n\n                if (options.skip + options.take > result.data.length) {\n                  options.skip = result.data.length - options.take;\n                }\n\n                that.view(query.range(options.skip, options.take).toArray());\n              }\n            } else {\n              that.view(result.data);\n            }\n          },\n          _clearEmptyGroups: function (data) {\n            for (var idx = data.length - 1; idx >= 0; idx--) {\n              var group = data[idx];\n\n              if (group.hasSubgroups) {\n                this._clearEmptyGroups(group.items);\n              }\n\n              if (group.items && !group.items.length && !group.itemCount) {\n                splice.apply(group.parent(), [idx, 1]);\n              }\n            }\n          },\n          _queryProcess: function (data, options) {\n            if (this.options.inPlaceSort) {\n              return Query.process(data, options, this.options.inPlaceSort);\n            } else {\n              return Query.process(data, options);\n            }\n          },\n          _mergeState: function (options) {\n            var that = this;\n\n            if (options !== undefined) {\n              that._pageSize = options.pageSize;\n              that._page = options.page;\n              that._sort = options.sort;\n              that._filter = options.filter;\n              that._group = options.group;\n              that._aggregate = options.aggregate;\n              that._skip = that._currentRangeStart = options.skip;\n              that._take = options.take;\n\n              if (that._skip === undefined) {\n                that._skip = that._currentRangeStart = that.skip();\n                options.skip = that.skip();\n              }\n\n              if (that._take === undefined && that._pageSize !== undefined) {\n                that._take = that._pageSize;\n                options.take = that._take;\n              }\n\n              if (that.options.virtual) {\n                options.virtual = that.options.virtual;\n              }\n\n              if (options.sort) {\n                that._sort = options.sort = normalizeSort(options.sort);\n                that._sortFields = sortFields(options.sort);\n              }\n\n              if (options.filter) {\n                that._filter = options.filter = that.options.accentFoldingFiltering && !$.isEmptyObject(options.filter) ? $.extend({}, normalizeFilter(options.filter), {\n                  accentFoldingFiltering: that.options.accentFoldingFiltering\n                }) : normalizeFilter(options.filter);\n              }\n\n              if (options.group) {\n                that._group = options.group = normalizeGroup(options.group);\n              }\n\n              if (options.aggregate) {\n                that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);\n              }\n            }\n\n            return options;\n          },\n          query: function (options) {\n            var result;\n            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\n\n            if (remote || (this._data === undefined || this._data.length === 0) && !this._destroyed.length) {\n              if (this.options.endless) {\n                var moreItemsCount = options.pageSize - this.pageSize();\n\n                if (moreItemsCount > 0) {\n                  moreItemsCount = this.pageSize();\n                  options.page = options.pageSize / moreItemsCount;\n                  options.pageSize = moreItemsCount;\n                } else {\n                  options.page = 1;\n                  this.options.endless = false;\n                }\n              }\n\n              return this.read(this._mergeState(options));\n            }\n\n            var isPrevented = this.trigger(REQUESTSTART, {\n              type: \"read\"\n            });\n\n            if (!isPrevented) {\n              this.trigger(PROGRESS);\n\n              if (options) {\n                options.groupPaging = this._groupPaging;\n              }\n\n              result = this._queryProcess(this._data, this._mergeState(options));\n\n              this._setFilterTotal(result.total, true);\n\n              this._aggregateResult = this._calculateAggregates(result.dataToAggregate || this._data, options);\n\n              this._setView(result, options);\n\n              this.trigger(REQUESTEND, {\n                type: \"read\"\n              });\n              this.trigger(CHANGE, {\n                items: result.data,\n                action: options ? options.action : \"\"\n              });\n            }\n\n            return $.Deferred().resolve(isPrevented).promise();\n          },\n          _hasExpandedSubGroups: function (group) {\n            var result = false;\n            var length = group.items ? group.items.length : 0;\n\n            if (!group.hasSubgroups) {\n              return false;\n            }\n\n            for (var i = 0; i < length; i++) {\n              if (this._groupsState[group.items[i].uid]) {\n                result = true;\n                break;\n              }\n            }\n\n            return result;\n          },\n          _findGroupedRange: function (data, result, options, parents, callback) {\n            var that = this;\n            var length = data.length;\n            var group;\n            var current;\n            var itemsLength;\n            var groupCount;\n            var itemsToSkip;\n\n            for (var i = 0; i < length; i++) {\n              group = data[i];\n\n              if (options.taken >= options.take) {\n                break;\n              }\n\n              if (!that._getGroupByUid(group.uid)) {\n                that._groupsFlat.push(group);\n              }\n\n              if (that._groupsState[group.uid]) {\n                if (that._isServerGroupPaged()) {\n                  if (that._fetchGroupItems(group, options, parents, callback)) {\n                    that._fetchingGroupItems = true;\n                    return;\n                  }\n\n                  groupCount = (group.subgroupCount || group.itemCount) + 1;\n                  itemsToSkip = options.skip - options.skipped;\n\n                  if (!that._hasExpandedSubGroups(group) && itemsToSkip > groupCount) {\n                    options.skipped += groupCount;\n                    continue;\n                  }\n                }\n\n                if (options.includeParents && options.skipped < options.skip) {\n                  options.skipped++;\n                  group.excludeHeader = true;\n                } else if (options.includeParents) {\n                  options.taken++;\n                  group.excludeHeader = false;\n                }\n\n                if (group.hasSubgroups && group.items && group.items.length) {\n                  group.currentItems = [];\n\n                  if (!parents) {\n                    parents = [];\n                  }\n\n                  parents.push(group);\n\n                  that._findGroupedRange(group.items, group.currentItems, options, parents, callback);\n\n                  parents.pop();\n\n                  if (group.currentItems.length || options.taken > 0) {\n                    result.push(group);\n                  } else {\n                    group.excludeHeader = false;\n                  }\n                } else {\n                  current = [];\n                  itemsLength = group.items.length;\n\n                  for (var j = 0; j < itemsLength; j++) {\n                    if (options.skipped < options.skip) {\n                      options.skipped++;\n                      continue;\n                    }\n\n                    if (options.taken >= options.take) {\n                      break;\n                    }\n\n                    current.push(group.items[j]);\n                    options.taken++;\n                  }\n\n                  if (current.length || options.taken > 0) {\n                    group.currentItems = current;\n                    result.push(group);\n                  } else {\n                    group.excludeHeader = false;\n                  }\n                }\n              } else {\n                if (options.skipped < options.skip) {\n                  options.skipped++;\n                  continue;\n                }\n\n                result.push(group);\n                options.taken++;\n              }\n            }\n          },\n          _expandedSubGroupItemsCount: function (group, end, includeCurrentItems) {\n            var that = this;\n            var result = 0;\n            var subGroup;\n            var endSpecified = typeof end === \"number\";\n            var length = endSpecified ? end : group.subgroupCount;\n            var temp;\n\n            if (!group.hasSubgroups) {\n              return result;\n            }\n\n            for (var i = 0; i < length; i++) {\n              subGroup = group.items[i];\n\n              if (!subGroup) {\n                break;\n              }\n\n              if (subGroup.hasSubgroups && that._groupsState[group.uid]) {\n                temp = that._expandedSubGroupItemsCount(subGroup, length, true);\n                result += temp;\n\n                if (endSpecified) {\n                  length -= temp;\n                }\n              } else if (!subGroup.hasSubgroups && that._groupsState[subGroup.uid]) {\n                temp = subGroup.items ? subGroup.items.length : 0;\n                result += temp;\n\n                if (endSpecified) {\n                  length -= temp;\n                }\n              }\n\n              if (includeCurrentItems) {\n                result += 1;\n\n                if (endSpecified) {\n                  length -= 1;\n                }\n              }\n\n              if (endSpecified && result > length) {\n                return result;\n              }\n            }\n\n            return result;\n          },\n          _fetchGroupItems: function (group, options, parents, callback) {\n            var that = this;\n            var groupItemsSkip;\n            var firstItem;\n            var lastItem;\n            var groupItemCount = group.hasSubgroups ? group.subgroupCount : group.itemCount;\n            var take = options.take;\n            var skipped = options.skipped;\n            var pageSize = that.take();\n            var expandedSubGroupItemsCount;\n\n            if (options.includeParents) {\n              if (skipped < options.skip) {\n                skipped += 1;\n              } else {\n                take -= 1;\n              }\n            }\n\n            if (!group.items || group.items && !group.items.length) {\n              that.getGroupItems(group, options, parents, callback, 0);\n              return true;\n            } else {\n              expandedSubGroupItemsCount = this._expandedSubGroupItemsCount(group, options.skip - skipped);\n              groupItemsSkip = Math.max(options.skip - (skipped + expandedSubGroupItemsCount), 0);\n\n              if (groupItemsSkip >= groupItemCount) {\n                return false;\n              }\n\n              firstItem = group.items[groupItemsSkip];\n              lastItem = group.items[Math.min(groupItemsSkip + take, groupItemCount - 1)];\n\n              if (firstItem.notFetched) {\n                that.getGroupItems(group, options, parents, callback, math.max(math.floor(groupItemsSkip / pageSize), 0) * pageSize, math.round((groupItemsSkip + pageSize) / pageSize));\n                return true;\n              }\n\n              if (lastItem.notFetched) {\n                that.getGroupItems(group, options, parents, callback, math.max(math.floor((groupItemsSkip + pageSize) / pageSize), 0) * pageSize, math.round((groupItemsSkip + pageSize) / pageSize));\n                return true;\n              }\n            }\n          },\n          getGroupItems: function (group, options, parents, callback, groupItemsSkip, page) {\n            var that = this;\n            var take;\n            var filter;\n            var data;\n            var subgroups;\n\n            if (!group.items) {\n              group.items = [];\n            }\n\n            take = that.take();\n            filter = this._composeItemsFilter(group, parents);\n            data = {\n              page: page || 1,\n              pageSize: take,\n              skip: groupItemsSkip,\n              take: take,\n              filter: filter,\n              aggregate: that._aggregate,\n              sort: that._sort\n            };\n            subgroups = that.findSubgroups(group);\n\n            if (subgroups && subgroups.length) {\n              data.group = subgroups;\n              data.groupPaging = true;\n            }\n\n            clearTimeout(that._timeout);\n            that._timeout = setTimeout(function () {\n              that._queueRequest(data, function () {\n                if (!that.trigger(REQUESTSTART, {\n                  type: \"read\"\n                })) {\n                  that.transport.read({\n                    data: data,\n                    success: that._groupItemsSuccessHandler(group, options.skip, that.take(), callback, groupItemsSkip),\n                    error: function () {\n                      var args = slice.call(arguments);\n                      that.error.apply(that, args);\n                    }\n                  });\n                } else {\n                  that._dequeueRequest();\n                }\n              });\n            }, 100);\n          },\n          _groupItemsSuccessHandler: function (group, skip, take, callback, groupItemsSkip) {\n            var that = this;\n\n            var timestamp = that._timeStamp();\n\n            callback = isFunction(callback) ? callback : noop;\n            var totalField = that.options.schema && that.options.schema.total ? that.options.schema.total : \"Total\";\n            return function (data) {\n              var temp;\n              var model = Model.define(that.options.schema.model);\n              var totalCount;\n\n              that._dequeueRequest();\n\n              that.trigger(REQUESTEND, {\n                response: data,\n                type: \"read\"\n              });\n\n              if (isFunction(totalField)) {\n                totalCount = totalField(data);\n              } else {\n                totalCount = data[totalField];\n              }\n\n              data = that.reader.parse(data);\n\n              if (group.hasSubgroups) {\n                temp = that.reader.groups(data);\n                group.subgroupCount = totalCount;\n              } else {\n                temp = that.reader.data(data);\n                temp = temp.map(function (item) {\n                  return new model(item);\n                });\n              }\n\n              group.items.omitChangeEvent = true;\n\n              for (var i = 0; i < totalCount; i++) {\n                if (i >= groupItemsSkip && i < groupItemsSkip + take) {\n                  group.items.splice(i, 1, temp[i - groupItemsSkip]);\n                } else {\n                  if (!group.items[i]) {\n                    group.items.splice(i, 0, {\n                      notFetched: true\n                    });\n                  }\n                }\n              }\n\n              group.items.omitChangeEvent = false;\n\n              that._updateRangePristineData(group);\n\n              that._fetchingGroupItems = false;\n\n              if (!group.countAdded) {\n                that._serverGroupsTotal += totalCount;\n                group.countAdded = true;\n              }\n\n              that.range(skip, take, callback, \"expandGroup\");\n\n              if (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress) {\n                that.trigger(CHANGE, {});\n              }\n            };\n          },\n          findSubgroups: function (group) {\n            var indexOfCurrentGroup = this._group.map(function (g) {\n              return g.field;\n            }).indexOf(group.field);\n\n            return this._group.slice(indexOfCurrentGroup + 1, this._group.length);\n          },\n          _composeItemsFilter: function (group, parents) {\n            var filter = this.filter() || {\n              logic: \"and\",\n              filters: []\n            };\n            filter.logic = 'and';\n            filter = extend(true, {}, filter);\n            filter.filters.push({\n              field: group.field,\n              operator: \"eq\",\n              value: group.value\n            });\n\n            if (parents) {\n              for (var i = 0; i < parents.length; i++) {\n                filter.filters.push({\n                  field: parents[i].field,\n                  operator: \"eq\",\n                  value: parents[i].value\n                });\n              }\n            }\n\n            return filter;\n          },\n          _updateRangePristineData: function (group) {\n            var that = this;\n            var ranges = that._ranges;\n            var rangesLength = ranges.length;\n            var temp;\n            var currentGroup;\n            var range;\n            var dataLength;\n            var indexes;\n            var currIdx;\n\n            for (var i = 0; i < rangesLength; i++) {\n              range = ranges[i];\n              dataLength = range.data.length;\n              indexes = [];\n              temp = null;\n\n              for (var j = 0; j < dataLength; j++) {\n                currentGroup = range.data[j];\n                indexes.push(j);\n\n                if (currentGroup.uid === group.uid || currentGroup.hasSubgroups && currentGroup.items.length && that._containsSubGroup(currentGroup, group, indexes)) {\n                  break;\n                }\n\n                indexes.pop();\n              }\n\n              if (indexes.length) {\n                temp = ranges[i].pristineData;\n\n                while (indexes.length > 1) {\n                  currIdx = indexes.splice(0, 1)[0];\n                  temp = temp[currIdx].items;\n                }\n\n                temp[indexes[0]] = that._cloneGroup(group);\n                break;\n              }\n            }\n          },\n          _containsSubGroup: function (group, subgroup, indexes) {\n            var that = this;\n            var length = group.items.length;\n            var currentSubGroup;\n\n            if (group.hasSubgroups && length) {\n              for (var i = 0; i < length; i++) {\n                currentSubGroup = group.items[i];\n                indexes.push(i);\n\n                if (currentSubGroup.uid === subgroup.uid) {\n                  return true;\n                } else if (currentSubGroup.hasSubgroups && currentSubGroup.items.length) {\n                  return that._containsSubGroup(currentSubGroup, subgroup, indexes);\n                }\n\n                indexes.pop();\n              }\n            }\n          },\n          _cloneGroup: function (group) {\n            var that = this;\n            group = typeof group.toJSON == \"function\" ? group.toJSON() : group;\n\n            if (group.items && group.items.length) {\n              group.items = group.items.map(function (item) {\n                return that._cloneGroup(item);\n              });\n            }\n\n            return group;\n          },\n          _setFilterTotal: function (filterTotal, setDefaultValue) {\n            var that = this;\n\n            if (!that.options.serverFiltering) {\n              if (filterTotal !== undefined) {\n                that._total = filterTotal;\n              } else if (setDefaultValue) {\n                that._total = that._data.length;\n              }\n            }\n          },\n          fetch: function (callback) {\n            var that = this;\n\n            var fn = function (isPrevented) {\n              if (isPrevented !== true && isFunction(callback)) {\n                callback.call(that);\n              }\n            };\n\n            return this._query().done(fn);\n          },\n          _query: function (options) {\n            var that = this;\n            return that.query(extend({}, {\n              page: that.page(),\n              pageSize: that.pageSize(),\n              sort: that.sort(),\n              filter: that.filter(),\n              group: that.group(),\n              aggregate: that.aggregate()\n            }, options));\n          },\n          next: function (options) {\n            var that = this,\n                page = that.page(),\n                total = that.total();\n            options = options || {};\n\n            if (!page || total && page + 1 > that.totalPages()) {\n              return;\n            }\n\n            that._skip = that._currentRangeStart = page * that.take();\n            page += 1;\n            options.page = page;\n\n            that._query(options);\n\n            return page;\n          },\n          prev: function (options) {\n            var that = this,\n                page = that.page();\n            options = options || {};\n\n            if (!page || page === 1) {\n              return;\n            }\n\n            that._skip = that._currentRangeStart = that._skip - that.take();\n            page -= 1;\n            options.page = page;\n\n            that._query(options);\n\n            return page;\n          },\n          page: function (val) {\n            var that = this,\n                skip;\n\n            if (val !== undefined) {\n              val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);\n              var take = that.take();\n\n              if (that._isGroupPaged()) {\n                val -= 1;\n                that.range(val * take, take, null, \"page\");\n                return;\n              }\n\n              that._query(that._pageableQueryOptions({\n                page: val\n              }));\n\n              return;\n            }\n\n            skip = that.skip();\n            return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;\n          },\n          pageSize: function (val) {\n            var that = this;\n\n            if (val !== undefined) {\n              that._query(that._pageableQueryOptions({\n                pageSize: val,\n                page: 1\n              }));\n\n              return;\n            }\n\n            return that.take();\n          },\n          sort: function (val) {\n            var that = this;\n\n            if (val !== undefined) {\n              that.trigger(\"sort\");\n\n              that._query({\n                sort: val\n              });\n\n              return;\n            }\n\n            return that._sort;\n          },\n          filter: function (val) {\n            var that = this;\n\n            if (val === undefined) {\n              return that._filter;\n            }\n\n            that.trigger(\"reset\");\n\n            that._query({\n              filter: val,\n              page: 1\n            });\n          },\n          group: function (val) {\n            var that = this;\n            var options = {\n              group: val\n            };\n\n            if (that._groupPaging) {\n              // clear ranges if ungrouping is performed\n              if (val !== undefined && (!val || !val.length)) {\n                that._ranges = [];\n              }\n\n              options.page = 1;\n            }\n\n            if (val !== undefined) {\n              that._query(options);\n\n              return;\n            }\n\n            return that._group;\n          },\n          getGroupsFlat: function (data) {\n            var idx,\n                result = [],\n                length;\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              var group = data[idx];\n\n              if (group.hasSubgroups) {\n                result = result.concat(this.getGroupsFlat(group.items));\n              }\n\n              result.push(group);\n            }\n\n            return result;\n          },\n          total: function () {\n            return parseInt(this._total || 0, 10);\n          },\n          groupsTotal: function (includeExpanded) {\n            var that = this;\n\n            if (!that._group.length) {\n              return that.total();\n            }\n\n            if (that._isServerGrouped()) {\n              if (that._serverGroupsTotal) {\n                return that._serverGroupsTotal;\n              }\n\n              that._serverGroupsTotal = that.total();\n              return that._serverGroupsTotal;\n            }\n\n            return that._calculateGroupsTotal(that._ranges.length ? that._ranges[0].data : [], includeExpanded);\n          },\n          _calculateGroupsTotal: function (groups, includeExpanded, itemsField, ignoreState) {\n            var that = this;\n            itemsField = itemsField || \"items\";\n            var total;\n            var length;\n\n            if (that._group.length && groups) {\n              total = 0;\n              length = groups.length;\n\n              for (var i = 0; i < length; i++) {\n                total += that.groupCount(groups[i], includeExpanded, itemsField, ignoreState);\n              }\n\n              that._groupsTotal = total;\n              return total;\n            }\n\n            that._groupsTotal = that._data.length;\n            return that._groupsTotal;\n          },\n          groupCount: function (group, includeExpanded, itemsField, ignoreState) {\n            var that = this;\n            var total = 0;\n\n            if (group.hasSubgroups && that._groupsState[group.uid]) {\n              if (includeExpanded && !group.excludeHeader || ignoreState) {\n                total += 1;\n              }\n\n              group[itemsField].forEach(function (subgroup) {\n                total += that.groupCount(subgroup, includeExpanded, itemsField, ignoreState);\n              });\n            } else {\n              if (that._groupsState[group.uid]) {\n                if (includeExpanded && !group.excludeHeader || ignoreState) {\n                  total++;\n                }\n\n                total += group[itemsField] ? group[itemsField].length : 0;\n              } else {\n                total++;\n              }\n            }\n\n            return total;\n          },\n          countGroupRange: function (range) {\n            var total = 0;\n            var length = range.length;\n\n            for (var i = 0; i < length; i++) {\n              total += this.groupCount(range[i], true);\n            }\n\n            return total;\n          },\n          aggregate: function (val) {\n            var that = this;\n\n            if (val !== undefined) {\n              that._query({\n                aggregate: val\n              });\n\n              return;\n            }\n\n            return that._aggregate;\n          },\n          aggregates: function () {\n            var result = this._aggregateResult;\n\n            if (isEmptyObject(result)) {\n              result = this._emptyAggregates(this.aggregate());\n            }\n\n            return result;\n          },\n          _emptyAggregates: function (aggregates) {\n            var result = {};\n\n            if (!isEmptyObject(aggregates)) {\n              var aggregate = {};\n\n              if (!isArray(aggregates)) {\n                aggregates = [aggregates];\n              }\n\n              for (var idx = 0; idx < aggregates.length; idx++) {\n                aggregate[aggregates[idx].aggregate] = 0;\n                result[aggregates[idx].field] = aggregate;\n              }\n            }\n\n            return result;\n          },\n          _pageableQueryOptions: function (options) {\n            return options;\n          },\n          _wrapInEmptyGroup: function (model) {\n            var groups = this.group(),\n                parent,\n                group,\n                idx,\n                length;\n\n            for (idx = groups.length - 1, length = 0; idx >= length; idx--) {\n              group = groups[idx];\n              parent = {\n                value: model.get ? model.get(group.field) : model[group.field],\n                field: group.field,\n                items: parent ? [parent] : [model],\n                hasSubgroups: !!parent,\n                aggregates: this._emptyAggregates(group.aggregates)\n              };\n            }\n\n            return parent;\n          },\n          totalPages: function () {\n            var that = this,\n                pageSize = that.pageSize() || that.total(),\n                total = that._isGroupPaged() ? that.groupsTotal(true) : that.total();\n            return math.ceil((total || 0) / pageSize);\n          },\n          inRange: function (skip, take) {\n            var that = this,\n                end = math.min(skip + take, that.total());\n\n            if (!that.options.serverPaging && that._data.length > 0) {\n              return true;\n            }\n\n            return that._findRange(skip, end).length > 0;\n          },\n          lastRange: function () {\n            var ranges = this._ranges;\n            return ranges[ranges.length - 1] || {\n              start: 0,\n              end: 0,\n              data: []\n            };\n          },\n          firstItemUid: function () {\n            var ranges = this._ranges;\n            return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;\n          },\n          enableRequestsInProgress: function () {\n            this._skipRequestsInProgress = false;\n          },\n          _timeStamp: function () {\n            return new Date().getTime();\n          },\n          range: function (skip, take, callback, action) {\n            this._currentRequestTimeStamp = this._timeStamp();\n            this._skipRequestsInProgress = true;\n            var total = this._isGroupPaged() ? this.groupsTotal(true) : this.total();\n\n            if (action === \"expandGroup\" || action === \"collapseGroup\") {\n              this._updateOuterRangesLength();\n            }\n\n            skip = math.min(skip || 0, total);\n            callback = isFunction(callback) ? callback : noop;\n            var that = this,\n                pageSkip = math.max(math.floor(skip / take), 0) * take,\n                size = math.min(pageSkip + take, total),\n                data;\n            data = that._findRange(skip, math.min(skip + take, total), callback);\n\n            if ((data.length || total === 0) && !that._fetchingGroupItems) {\n              that._processRangeData(data, skip, take, that._originalPageSkip || pageSkip, that._originalSize || size, {\n                action: action\n              });\n\n              that._originalPageSkip = null;\n              that._originalSize = null;\n              callback();\n              return;\n            }\n\n            if (that._isGroupPaged()) {\n              that._originalPageSkip = pageSkip;\n              that._originalSize = size;\n              pageSkip = math.max(math.floor(that._adjustPageSkip(skip, take) / take), 0) * take;\n              size = math.min(pageSkip + take, total);\n            }\n\n            if (take !== undefined && !that._fetchingGroupItems) {\n              if (that._isGroupPaged() && !that._groupRangeExists(pageSkip, take) || !that._rangeExists(pageSkip, size)) {\n                that.prefetch(pageSkip, take, function () {\n                  if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {\n                    that.prefetch(size, take, function () {\n                      that.range(skip, take, callback);\n                    });\n                  } else {\n                    that.range(skip, take, callback);\n                  }\n                });\n              } else if (pageSkip < skip) {\n                that.prefetch(size, take, function () {\n                  that.range(skip, take, callback);\n                });\n              }\n            }\n          },\n          _findRange: function (start, end, callback) {\n            var that = this,\n                ranges = that._ranges,\n                range,\n                data = [],\n                skipIdx,\n                takeIdx,\n                startIndex,\n                endIndex,\n                rangeData,\n                rangeEnd,\n                processed,\n                options = that.options,\n                remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates,\n                flatData,\n                count,\n                length,\n                groupMapOptions = {\n              take: end - start,\n              skip: start,\n              skipped: 0,\n              taken: 0,\n              includeParents: true\n            },\n                prevRangeEnd,\n                isGroupPaged = that._isGroupPaged(),\n                startField = isGroupPaged ? \"outerStart\" : \"start\",\n                endField = isGroupPaged ? \"outerEnd\" : \"end\",\n                currentDataLength;\n\n            for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {\n              range = ranges[skipIdx];\n\n              if (isGroupPaged) {\n                if (range.outerStart >= end) {\n                  return [];\n                }\n\n                if (start > range.outerEnd) {\n                  groupMapOptions.skipped += range.outerEnd - (prevRangeEnd || 0);\n                  prevRangeEnd = range.outerEnd;\n                  continue;\n                }\n\n                if (typeof prevRangeEnd !== \"undefined\" && prevRangeEnd != range.outerStart) {\n                  groupMapOptions.skipped += range.outerStart - prevRangeEnd;\n                }\n\n                if (groupMapOptions.skipped > groupMapOptions.skip) {\n                  return [];\n                }\n\n                if (typeof prevRangeEnd === \"undefined\" && start > 0 && range.start > 0) {\n                  groupMapOptions.skipped = range.outerStart;\n                }\n\n                takeIdx = skipIdx;\n\n                while (true) {\n                  this._findGroupedRange(range.data, data, groupMapOptions, null, callback);\n\n                  currentDataLength = that._calculateGroupsTotal(data, true, \"currentItems\");\n\n                  if (currentDataLength >= groupMapOptions.take) {\n                    return data;\n                  }\n\n                  if (that._fetchingGroupItems) {\n                    return [];\n                  }\n\n                  takeIdx++;\n\n                  if (ranges[takeIdx] && ranges[takeIdx].outerStart === range.outerEnd) {\n                    range = ranges[takeIdx];\n                  } else {\n                    break;\n                  }\n                }\n              } else if (start >= range[startField] && start <= range[endField]) {\n                count = 0;\n\n                for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {\n                  range = ranges[takeIdx];\n                  flatData = that._flatData(range.data, true);\n\n                  if (flatData.length && start + count >= range.start) {\n                    rangeData = range.data;\n                    rangeEnd = range.end;\n\n                    if (!remote) {\n                      if (options.inPlaceSort) {\n                        processed = that._queryProcess(range.data, {\n                          filter: that.filter()\n                        });\n                      } else {\n                        var sort = normalizeGroupWithoutCompare(that.group() || []).concat(normalizeSort(that.sort() || []));\n                        processed = that._queryProcess(range.data, {\n                          sort: sort,\n                          filter: that.filter()\n                        });\n                      }\n\n                      flatData = rangeData = processed.data;\n\n                      if (processed.total !== undefined) {\n                        rangeEnd = processed.total;\n                      }\n                    }\n\n                    startIndex = 0;\n\n                    if (start + count > range.start) {\n                      startIndex = start + count - range.start;\n                    }\n\n                    endIndex = flatData.length;\n\n                    if (rangeEnd > end) {\n                      endIndex = endIndex - (rangeEnd - end);\n                    }\n\n                    count += endIndex - startIndex;\n                    data = that._mergeGroups(data, rangeData, startIndex, endIndex);\n\n                    if (end <= range.end && count == end - start) {\n                      return data;\n                    }\n                  }\n                }\n\n                break;\n              }\n\n              prevRangeEnd = range.outerEnd;\n            }\n\n            return [];\n          },\n          _getRangesMismatch: function (pageSkip) {\n            var that = this;\n            var ranges = that._ranges;\n            var mismatch = 0;\n            var i = 0;\n\n            while (true) {\n              var range = ranges[i];\n\n              if (!range || range.outerStart > pageSkip) {\n                break;\n              }\n\n              if (range.outerEnd != range.end) {\n                mismatch = range.outerEnd - range.end;\n              }\n\n              i++;\n            }\n\n            return mismatch;\n          },\n          _mergeGroups: function (data, range, skip, take) {\n            if (this._isServerGrouped()) {\n              var temp = range.toJSON(),\n                  prevGroup;\n\n              if (data.length) {\n                prevGroup = data[data.length - 1];\n              }\n\n              mergeGroups(prevGroup, temp, skip, take);\n              return data.concat(temp);\n            }\n\n            return data.concat(range.slice(skip, take));\n          },\n          _processRangeData: function (data, skip, take, pageSkip, size, eventData) {\n            var that = this;\n            that._pending = undefined;\n            that._skip = skip > that.skip() && !that._omitPrefetch ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;\n            that._currentRangeStart = skip;\n            that._take = take;\n            var paging = that.options.serverPaging;\n            var sorting = that.options.serverSorting;\n            var filtering = that.options.serverFiltering;\n            var aggregates = that.options.serverAggregates;\n\n            try {\n              that.options.serverPaging = true;\n\n              if (!that._isServerGrouped() && !(that.group() && that.group().length)) {\n                that.options.serverSorting = true;\n              }\n\n              that.options.serverFiltering = true;\n              that.options.serverPaging = true;\n              that.options.serverAggregates = true;\n\n              if (paging) {\n                that._detachObservableParents();\n\n                that._data = data = that._observe(data);\n              }\n\n              that._process(data, eventData);\n            } finally {\n              that.options.serverPaging = paging;\n              that.options.serverSorting = sorting;\n              that.options.serverFiltering = filtering;\n              that.options.serverAggregates = aggregates;\n            }\n          },\n          skip: function () {\n            var that = this;\n\n            if (that._skip === undefined) {\n              return that._page !== undefined ? (that._page - 1) * (that.take() || 1) : undefined;\n            }\n\n            return that._skip;\n          },\n          currentRangeStart: function () {\n            return this._currentRangeStart || 0;\n          },\n          take: function () {\n            return this._take || this._pageSize;\n          },\n          _prefetchSuccessHandler: function (skip, size, callback, force) {\n            var that = this;\n\n            var timestamp = that._timeStamp();\n\n            return function (data) {\n              var found = false,\n                  range = {\n                start: skip,\n                end: size,\n                data: [],\n                timestamp: that._timeStamp()\n              },\n                  idx,\n                  length,\n                  temp;\n\n              that._dequeueRequest();\n\n              that.trigger(REQUESTEND, {\n                response: data,\n                type: \"read\"\n              });\n              data = that.reader.parse(data);\n              temp = that._readData(data);\n\n              if (temp.length) {\n                for (idx = 0, length = that._ranges.length; idx < length; idx++) {\n                  if (that._ranges[idx].start === skip) {\n                    found = true;\n                    range = that._ranges[idx];\n\n                    if (!that._isGroupPaged()) {\n                      range.pristineData = temp;\n                      range.data = that._observe(temp);\n                      range.end = range.start + that._flatData(range.data, true).length;\n\n                      that._sortRanges();\n                    }\n\n                    break;\n                  }\n                }\n\n                if (!found) {\n                  that._addRange(that._observe(temp), skip);\n                }\n              }\n\n              that._total = that.reader.total(data);\n\n              if (force || timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress) {\n                if (callback && temp.length) {\n                  callback();\n                } else {\n                  that.trigger(CHANGE, {});\n                }\n              }\n            };\n          },\n          prefetch: function (skip, take, callback) {\n            var that = this,\n                size = math.min(skip + take, that.total()),\n                options = {\n              take: take,\n              skip: skip,\n              page: skip / take + 1,\n              pageSize: take,\n              sort: that._sort,\n              filter: that._filter,\n              group: that._group,\n              aggregate: that._aggregate\n            };\n\n            if (that._isGroupPaged() && !that._isServerGrouped() && that._groupRangeExists(skip, size)) {\n              if (callback) {\n                callback();\n              }\n\n              return;\n            }\n\n            if (that._isServerGroupPaged() && !that._groupRangeExists(skip, size) || !that._rangeExists(skip, size)) {\n              clearTimeout(that._timeout);\n              that._timeout = setTimeout(function () {\n                that._queueRequest(options, function () {\n                  if (!that.trigger(REQUESTSTART, {\n                    type: \"read\"\n                  })) {\n                    if (that._omitPrefetch) {\n                      that.trigger(PROGRESS);\n                    }\n\n                    that.transport.read({\n                      data: that._params(options),\n                      success: that._prefetchSuccessHandler(skip, size, callback),\n                      error: function () {\n                        var args = slice.call(arguments);\n                        that.error.apply(that, args);\n                      }\n                    });\n                  } else {\n                    that._dequeueRequest();\n                  }\n                });\n              }, 100);\n            } else if (callback) {\n              callback();\n            }\n          },\n          _multiplePrefetch: function (skip, take, callback) {\n            var that = this,\n                size = math.min(skip + take, that.total()),\n                options = {\n              take: take,\n              skip: skip,\n              page: skip / take + 1,\n              pageSize: take,\n              sort: that._sort,\n              filter: that._filter,\n              group: that._group,\n              aggregate: that._aggregate\n            };\n\n            if (!that._rangeExists(skip, size)) {\n              if (!that.trigger(REQUESTSTART, {\n                type: \"read\"\n              })) {\n                that.transport.read({\n                  data: that._params(options),\n                  success: that._prefetchSuccessHandler(skip, size, callback, true)\n                });\n              }\n            } else if (callback) {\n              callback();\n            }\n          },\n          _adjustPageSkip: function (start, take) {\n            var that = this;\n\n            var prevRange = that._getPrevRange(start);\n\n            var result;\n            var total = that.total();\n            var mismatch;\n\n            if (prevRange) {\n              mismatch = that._getRangesMismatch(start);\n\n              if (!mismatch) {\n                return start;\n              }\n\n              start -= mismatch;\n            }\n\n            result = math.max(math.floor(start / take), 0) * take;\n\n            if (result > total) {\n              while (true) {\n                result -= take;\n\n                if (result < total) {\n                  break;\n                }\n              }\n            }\n\n            return result;\n          },\n          _getNextRange: function (end) {\n            var that = this,\n                ranges = that._ranges,\n                idx,\n                length;\n\n            for (idx = 0, length = ranges.length; idx < length; idx++) {\n              if (ranges[idx].start <= end && ranges[idx].end >= end) {\n                return ranges[idx];\n              }\n            }\n          },\n          _getPrevRange: function (start) {\n            var that = this,\n                ranges = that._ranges,\n                idx,\n                range,\n                length = ranges.length;\n\n            for (idx = length - 1; idx >= 0; idx--) {\n              if (ranges[idx].outerStart <= start) {\n                range = ranges[idx];\n                break;\n              }\n            }\n\n            return range;\n          },\n          _rangeExists: function (start, end) {\n            var that = this,\n                ranges = that._ranges,\n                idx,\n                length;\n\n            for (idx = 0, length = ranges.length; idx < length; idx++) {\n              if (ranges[idx].start <= start && ranges[idx].end >= end) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _groupRangeExists: function (start, end) {\n            var that = this,\n                ranges = that._ranges,\n                idx,\n                length,\n                availableItemsCount = 0,\n                total = that.groupsTotal(true);\n\n            if (end > total && !that._isServerGrouped()) {\n              end = total;\n            }\n\n            for (idx = 0, length = ranges.length; idx < length; idx++) {\n              var range = ranges[idx];\n\n              if (range.outerStart <= start && range.outerEnd >= start) {\n                availableItemsCount += range.outerEnd - start;\n              } else if (range.outerStart <= end && range.outerEnd >= end) {\n                availableItemsCount += end - range.outerStart;\n              }\n            }\n\n            return availableItemsCount >= end - start;\n          },\n          _getCurrentRangeSpan: function () {\n            var that = this;\n            var ranges = that._ranges;\n            var start = that.currentRangeStart();\n            var end = start + (that.take() || 0);\n            var rangeSpan = [];\n            var range;\n            var idx;\n            var length = ranges.length;\n\n            for (idx = 0; idx < length; idx++) {\n              range = ranges[idx];\n\n              if (range.start <= start && range.end >= start || range.start >= start && range.start <= end) {\n                rangeSpan.push(range);\n              }\n            }\n\n            return rangeSpan;\n          },\n          _removeModelFromRanges: function (model) {\n            var that = this;\n            var range;\n\n            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {\n              range = this._ranges[idx];\n\n              that._removeModelFromRange(range, model);\n            }\n\n            that._updateRangesLength();\n          },\n          _removeModelFromRange: function (range, model) {\n            this._eachItem(range.data, function (data) {\n              if (!data) {\n                return;\n              }\n\n              for (var idx = 0; idx < data.length; idx++) {\n                var dataItem = data[idx];\n\n                if (dataItem.uid && dataItem.uid == model.uid) {\n                  [].splice.call(data, idx, 1);\n                  break;\n                }\n              }\n            });\n          },\n          _insertModelInRange: function (index, model) {\n            var that = this;\n            var ranges = that._ranges || [];\n            var rangesLength = ranges.length;\n            var range;\n            var i;\n\n            for (i = 0; i < rangesLength; i++) {\n              range = ranges[i];\n\n              if (range.start <= index && range.end >= index) {\n                if (!that._getByUid(model.uid, range.data)) {\n                  if (that._isServerGrouped()) {\n                    range.data.splice(index, 0, that._wrapInEmptyGroup(model));\n                  } else {\n                    range.data.splice(index, 0, model);\n                  }\n                }\n\n                break;\n              }\n            }\n\n            that._updateRangesLength();\n          },\n          _updateRangesLength: function () {\n            var that = this;\n            var ranges = that._ranges || [];\n            var rangesLength = ranges.length;\n            var mismatchFound = false;\n            var mismatchLength = 0;\n            var lengthDifference = 0;\n            var rangeLength;\n            var range;\n            var i;\n\n            for (i = 0; i < rangesLength; i++) {\n              range = ranges[i];\n              rangeLength = that._isGroupPaged() ? range.data.length : that._flatData(range.data, true).length;\n              lengthDifference = rangeLength - math.abs(range.end - range.start);\n\n              if (!mismatchFound && lengthDifference !== 0) {\n                mismatchFound = true;\n                mismatchLength = lengthDifference;\n                range.end += mismatchLength;\n                continue;\n              }\n\n              if (mismatchFound) {\n                range.start += mismatchLength;\n                range.end += mismatchLength;\n              }\n            }\n          },\n          _updateOuterRangesLength: function () {\n            var that = this;\n            var ranges = that._ranges || [];\n            var rangesLength = ranges.length;\n            var mismatchLength = 0;\n            var range;\n            var i;\n            var prevRange;\n            var rangeLength;\n\n            for (i = 0; i < rangesLength; i++) {\n              range = ranges[i];\n              rangeLength = that._isGroupPaged() ? that._calculateGroupsTotal(range.data, true, \"items\", true) : that._flatData(range.data, true).length;\n\n              if (prevRange) {\n                if (prevRange.end != range.start) {\n                  mismatchLength = range.start - prevRange.end;\n                }\n\n                range.outerStart = prevRange.outerEnd + mismatchLength;\n                mismatchLength = 0;\n              } else {\n                range.outerStart = range.start;\n              }\n\n              range.outerEnd = range.outerStart + rangeLength;\n              prevRange = range;\n            }\n          }\n        });\n        var Transport = {};\n\n        Transport.create = function (options, data, dataSource) {\n          var transport,\n              transportOptions = options.transport ? $.extend({}, options.transport) : null;\n\n          if (transportOptions) {\n            transportOptions.read = typeof transportOptions.read === STRING ? {\n              url: transportOptions.read\n            } : transportOptions.read;\n\n            if (options.type === \"jsdo\") {\n              transportOptions.dataSource = dataSource;\n            }\n\n            if (options.type) {\n              kendo.data.transports = kendo.data.transports || {};\n              kendo.data.schemas = kendo.data.schemas || {};\n\n              if (!kendo.data.transports[options.type]) {\n                kendo.logToConsole(\"Unknown DataSource transport type '\" + options.type + \"'.\\nVerify that registration scripts for this type are included after Kendo UI on the page.\", \"warn\");\n              } else if (!isPlainObject(kendo.data.transports[options.type])) {\n                transport = new kendo.data.transports[options.type](extend(transportOptions, {\n                  data: data\n                }));\n              } else {\n                transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);\n              }\n\n              options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);\n            }\n\n            if (!transport) {\n              transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);\n            }\n          } else {\n            transport = new LocalTransport({\n              data: options.data || []\n            });\n          }\n\n          return transport;\n        };\n\n        DataSource.create = function (options) {\n          if (isArray(options) || options instanceof ObservableArray) {\n            options = {\n              data: options\n            };\n          }\n\n          var dataSource = options || {},\n              data = dataSource.data,\n              fields = dataSource.fields,\n              table = dataSource.table,\n              select = dataSource.select,\n              idx,\n              length,\n              model = {},\n              field;\n\n          if (!data && fields && !dataSource.transport) {\n            if (table) {\n              data = inferTable(table, fields);\n            } else if (select) {\n              data = inferSelect(select, fields);\n\n              if (dataSource.group === undefined && data[0] && data[0].optgroup !== undefined) {\n                dataSource.group = \"optgroup\";\n              }\n            }\n          }\n\n          if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {\n            for (idx = 0, length = fields.length; idx < length; idx++) {\n              field = fields[idx];\n\n              if (field.type) {\n                model[field.field] = field;\n              }\n            }\n\n            if (!isEmptyObject(model)) {\n              dataSource.schema = extend(true, dataSource.schema, {\n                model: {\n                  fields: model\n                }\n              });\n            }\n          }\n\n          dataSource.data = data;\n          select = null;\n          dataSource.select = null;\n          table = null;\n          dataSource.table = null;\n          return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);\n        };\n\n        function inferSelect(select, fields) {\n          select = $(select)[0];\n          var options = select.options;\n          var firstField = fields[0];\n          var secondField = fields[1];\n          var data = [];\n          var idx, length;\n          var optgroup;\n          var option;\n          var record;\n          var value;\n\n          for (idx = 0, length = options.length; idx < length; idx++) {\n            record = {};\n            option = options[idx];\n            optgroup = option.parentNode;\n\n            if (optgroup === select) {\n              optgroup = null;\n            }\n\n            if (option.disabled || optgroup && optgroup.disabled) {\n              continue;\n            }\n\n            if (optgroup) {\n              record.optgroup = optgroup.label;\n            }\n\n            record[firstField.field] = option.text;\n            value = option.attributes.value;\n\n            if (value && value.specified) {\n              value = option.value;\n            } else {\n              value = option.text;\n            }\n\n            record[secondField.field] = value;\n            data.push(record);\n          }\n\n          return data;\n        }\n\n        function inferTable(table, fields) {\n          var tbody = $(table)[0].tBodies[0],\n              rows = tbody ? tbody.rows : [],\n              idx,\n              length,\n              fieldIndex,\n              fieldCount = fields.length,\n              data = [],\n              cells,\n              record,\n              cell,\n              empty;\n\n          for (idx = 0, length = rows.length; idx < length; idx++) {\n            record = {};\n            empty = true;\n            cells = rows[idx].cells;\n\n            for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {\n              cell = cells[fieldIndex];\n\n              if (cell.nodeName.toLowerCase() !== \"th\") {\n                empty = false;\n                record[fields[fieldIndex].field] = cell.innerHTML;\n              }\n            }\n\n            if (!empty) {\n              data.push(record);\n            }\n          }\n\n          return data;\n        }\n\n        var Node = Model.define({\n          idField: \"id\",\n          init: function (value) {\n            var that = this,\n                hasChildren = that.hasChildren || value && value.hasChildren,\n                childrenField = \"items\",\n                childrenOptions = {};\n            kendo.data.Model.fn.init.call(that, value);\n\n            if (typeof that.children === STRING) {\n              childrenField = that.children;\n            }\n\n            childrenOptions = {\n              schema: {\n                data: childrenField,\n                model: {\n                  hasChildren: hasChildren,\n                  id: that.idField,\n                  fields: that.fields\n                }\n              }\n            };\n\n            if (typeof that.children !== STRING) {\n              extend(childrenOptions, that.children);\n            }\n\n            childrenOptions.data = value;\n\n            if (!hasChildren) {\n              hasChildren = childrenOptions.schema.data;\n            }\n\n            if (typeof hasChildren === STRING) {\n              hasChildren = kendo.getter(hasChildren);\n            }\n\n            if (isFunction(hasChildren)) {\n              var hasChildrenObject = hasChildren.call(that, that);\n\n              if (hasChildrenObject && hasChildrenObject.length === 0) {\n                that.hasChildren = false;\n              } else {\n                that.hasChildren = !!hasChildrenObject;\n              }\n            }\n\n            that._childrenOptions = childrenOptions;\n\n            if (that.hasChildren) {\n              that._initChildren();\n            }\n\n            that._loaded = !!(value && value._loaded);\n          },\n          _initChildren: function () {\n            var that = this;\n            var children, transport, parameterMap;\n\n            if (!(that.children instanceof HierarchicalDataSource)) {\n              children = that.children = new HierarchicalDataSource(that._childrenOptions);\n              transport = children.transport;\n              parameterMap = transport.parameterMap;\n\n              transport.parameterMap = function (data, type) {\n                data[that.idField || \"id\"] = that.id;\n\n                if (parameterMap) {\n                  data = parameterMap.call(that, data, type);\n                }\n\n                return data;\n              };\n\n              children.parent = function () {\n                return that;\n              };\n\n              children.bind(CHANGE, function (e) {\n                e.node = e.node || that;\n                that.trigger(CHANGE, e);\n              });\n              children.bind(ERROR, function (e) {\n                var collection = that.parent();\n\n                if (collection) {\n                  e.node = e.node || that;\n                  collection.trigger(ERROR, e);\n                }\n              });\n              children.bind(ITEMSLOADED, function (e) {\n                var collection = that.parent();\n\n                if (collection) {\n                  collection.trigger(ITEMSLOADED, e);\n                }\n              });\n\n              that._updateChildrenField();\n            }\n          },\n          append: function (model) {\n            this._initChildren();\n\n            this.loaded(true);\n            this.children.add(model);\n          },\n          hasChildren: false,\n          level: function () {\n            var parentNode = this.parentNode(),\n                level = 0;\n\n            while (parentNode && parentNode.parentNode) {\n              level++;\n              parentNode = parentNode.parentNode ? parentNode.parentNode() : null;\n            }\n\n            return level;\n          },\n          _updateChildrenField: function () {\n            var fieldName = this._childrenOptions.schema.data;\n            this[fieldName || \"items\"] = this.children.data();\n          },\n          _childrenLoaded: function () {\n            this._loaded = true;\n\n            this._updateChildrenField();\n          },\n          load: function () {\n            var options = {};\n            var method = \"_query\";\n            var children, promise;\n\n            if (this.hasChildren) {\n              this._initChildren();\n\n              children = this.children;\n              options[this.idField || \"id\"] = this.id;\n\n              if (!this._loaded) {\n                children._data = undefined;\n                method = \"read\";\n              }\n\n              children.one(CHANGE, this._childrenLoaded.bind(this));\n\n              if (this._matchFilter) {\n                options.filter = {\n                  field: '_matchFilter',\n                  operator: 'eq',\n                  value: true\n                };\n              }\n\n              promise = children[method](options);\n\n              if (!this._loaded) {\n                this.trigger(ITEMLOAD, {\n                  promise: promise,\n                  node: this\n                });\n              }\n            } else {\n              this.loaded(true);\n            }\n\n            return promise || $.Deferred().resolve().promise();\n          },\n          parentNode: function () {\n            var array = this.parent();\n            return array.parent();\n          },\n          loaded: function (value) {\n            if (value !== undefined) {\n              this._loaded = value;\n            } else {\n              return this._loaded;\n            }\n          },\n          shouldSerialize: function (field) {\n            return Model.fn.shouldSerialize.call(this, field) && field !== \"children\" && field !== \"_loaded\" && field !== \"hasChildren\" && field !== \"_childrenOptions\";\n          }\n        });\n\n        function dataMethod(name) {\n          return function () {\n            var data = this._data,\n                result = DataSource.fn[name].apply(this, slice.call(arguments));\n\n            if (this._data != data) {\n              this._attachBubbleHandlers();\n            }\n\n            return result;\n          };\n        }\n\n        var HierarchicalDataSource = DataSource.extend({\n          init: function (options) {\n            var node = Node.define({\n              children: options\n            });\n\n            if (options.filter && !options.serverFiltering) {\n              this._hierarchicalFilter = options.filter;\n              options.filter = null;\n            }\n\n            DataSource.fn.init.call(this, extend(true, {}, {\n              schema: {\n                modelBase: node,\n                model: node\n              }\n            }, options));\n\n            this._attachBubbleHandlers();\n          },\n          _attachBubbleHandlers: function () {\n            var that = this;\n\n            that._data.bind(ERROR, function (e) {\n              that.trigger(ERROR, e);\n            });\n\n            that._data.bind(ITEMSLOADED, function (e) {\n              that.trigger(ITEMSLOADED, e);\n            });\n          },\n          loading: function () {\n            if (this._data) {\n              return this._data.loading() || this._childrenLoading();\n            }\n\n            return false;\n          },\n          _childrenLoading: function () {\n            var isLoading = false;\n\n            this._data.forEach(function (node) {\n              if (node.hasChildren && node.children.loading()) {\n                isLoading = true;\n              }\n            });\n\n            return isLoading;\n          },\n          read: function (data) {\n            var result = DataSource.fn.read.call(this, data);\n\n            if (this._hierarchicalFilter) {\n              if (this._data && this._data.length > 0) {\n                this.filter(this._hierarchicalFilter);\n              } else {\n                this.options.filter = this._hierarchicalFilter;\n                this._filter = normalizeFilter(this.options.filter);\n                this._hierarchicalFilter = null;\n              }\n            }\n\n            return result;\n          },\n          remove: function (node) {\n            var parentNode = node.parentNode(),\n                dataSource = this,\n                result;\n\n            if (parentNode && parentNode._initChildren) {\n              dataSource = parentNode.children;\n            }\n\n            result = DataSource.fn.remove.call(dataSource, node);\n\n            if (parentNode && !dataSource.data().length) {\n              parentNode.hasChildren = false;\n            }\n\n            return result;\n          },\n          success: dataMethod(\"success\"),\n          data: dataMethod(\"data\"),\n          insert: function (index, model) {\n            var parentNode = this.parent();\n\n            if (parentNode && parentNode._initChildren) {\n              parentNode.hasChildren = true;\n\n              parentNode._initChildren();\n            }\n\n            return DataSource.fn.insert.call(this, index, model);\n          },\n          filter: function (val) {\n            if (val === undefined) {\n              return this._filter;\n            }\n\n            if (!this.options.serverFiltering && this._markHierarchicalQuery(val)) {\n              val = {\n                logic: \"or\",\n                filters: [val, {\n                  field: '_matchFilter',\n                  operator: 'equals',\n                  value: true\n                }]\n              };\n            }\n\n            this.trigger(\"reset\");\n\n            this._query({\n              filter: val,\n              page: 1\n            });\n          },\n          _markHierarchicalQuery: function (expressions) {\n            var compiled;\n            var predicate;\n            var fields;\n            var operators;\n            var filter;\n            var accentFoldingFiltering = this.options.accentFoldingFiltering;\n            expressions = accentFoldingFiltering ? $.extend({}, normalizeFilter(expressions), {\n              accentFoldingFiltering: accentFoldingFiltering\n            }) : normalizeFilter(expressions);\n\n            if (!expressions || expressions.filters.length === 0) {\n              this._updateHierarchicalFilter(function () {\n                return true;\n              });\n\n              return false;\n            }\n\n            compiled = Query.filterExpr(expressions);\n            fields = compiled.fields;\n            operators = compiled.operators;\n            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\n\n            if (fields.length || operators.length) {\n              filter = function (d) {\n                return predicate(d, fields, operators);\n              };\n            }\n\n            this._updateHierarchicalFilter(filter);\n\n            return true;\n          },\n          _updateHierarchicalFilter: function (filter) {\n            var current;\n            var data = this._data;\n            var result = false;\n\n            for (var idx = 0; idx < data.length; idx++) {\n              current = data[idx];\n\n              if (current.hasChildren) {\n                current._matchFilter = current.children._updateHierarchicalFilter(filter);\n\n                if (!current._matchFilter) {\n                  current._matchFilter = filter(current);\n                }\n              } else {\n                current._matchFilter = filter(current);\n              }\n\n              if (current._matchFilter) {\n                result = true;\n              }\n            }\n\n            return result;\n          },\n          _find: function (method, value) {\n            var idx, length, node, children;\n            var data = this._data;\n\n            if (!data) {\n              return;\n            }\n\n            node = DataSource.fn[method].call(this, value);\n\n            if (node) {\n              return node;\n            }\n\n            data = this._flatData(this._data);\n\n            for (idx = 0, length = data.length; idx < length; idx++) {\n              children = data[idx].children;\n\n              if (!(children instanceof HierarchicalDataSource)) {\n                continue;\n              }\n\n              node = children[method](value);\n\n              if (node) {\n                return node;\n              }\n            }\n          },\n          get: function (id) {\n            return this._find(\"get\", id);\n          },\n          getByUid: function (uid) {\n            return this._find(\"getByUid\", uid);\n          }\n        });\n\n        function inferList(list, fields) {\n          var items = $(list).children(),\n              idx,\n              length,\n              data = [],\n              record,\n              textField = fields[0].field,\n              urlField = fields[1] && fields[1].field,\n              spriteCssClassField = fields[2] && fields[2].field,\n              imageUrlField = fields[3] && fields[3].field,\n              item,\n              id,\n              textChild,\n              className,\n              children;\n\n          function elements(collection, tagName) {\n            return collection.filter(tagName).add(collection.find(tagName));\n          }\n\n          for (idx = 0, length = items.length; idx < length; idx++) {\n            record = {\n              _loaded: true\n            };\n            item = items.eq(idx);\n            textChild = item[0].firstChild;\n            children = item.children();\n            list = children.filter(\"ul\");\n            children = children.filter(\":not(ul)\");\n            id = item.attr(\"data-id\");\n\n            if (id) {\n              record.id = id;\n            }\n\n            if (textChild) {\n              record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();\n            }\n\n            if (urlField) {\n              record[urlField] = elements(children, \"a\").attr(\"href\");\n            }\n\n            if (imageUrlField) {\n              record[imageUrlField] = elements(children, \"img\").attr(\"src\");\n            }\n\n            if (spriteCssClassField) {\n              className = elements(children, \".k-sprite\").prop(\"className\");\n              record[spriteCssClassField] = className && kendo.trim(className.replace(\"k-sprite\", \"\"));\n            }\n\n            if (list.length) {\n              record.items = inferList(list.eq(0), fields);\n            }\n\n            if (item.attr(\"data-hasChildren\") == \"true\") {\n              record.hasChildren = true;\n            }\n\n            data.push(record);\n          }\n\n          return data;\n        }\n\n        HierarchicalDataSource.create = function (options) {\n          options = options && options.push ? {\n            data: options\n          } : options;\n          var dataSource = options || {},\n              data = dataSource.data,\n              fields = dataSource.fields,\n              list = dataSource.list;\n\n          if (data && data._dataSource) {\n            return data._dataSource;\n          }\n\n          if (!data && fields && !dataSource.transport) {\n            if (list) {\n              data = inferList(list, fields);\n            }\n          }\n\n          dataSource.data = data;\n          return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);\n        };\n\n        var Buffer = kendo.Observable.extend({\n          init: function (dataSource, viewSize, disablePrefetch) {\n            kendo.Observable.fn.init.call(this);\n            this._prefetching = false;\n            this.dataSource = dataSource;\n            this.prefetch = !disablePrefetch;\n            var buffer = this;\n            dataSource.bind(\"change\", function () {\n              buffer._change();\n            });\n            dataSource.bind(\"reset\", function () {\n              buffer._reset();\n            });\n\n            this._syncWithDataSource();\n\n            this.setViewSize(viewSize);\n          },\n          setViewSize: function (viewSize) {\n            this.viewSize = viewSize;\n\n            this._recalculate();\n          },\n          at: function (index) {\n            var pageSize = this.pageSize,\n                itemPresent = true;\n\n            if (index >= this.total()) {\n              this.trigger(\"endreached\", {\n                index: index\n              });\n              return null;\n            }\n\n            if (!this.useRanges) {\n              return this.dataSource.view()[index];\n            }\n\n            if (this.useRanges) {\n              // out of range request\n              if (index < this.dataOffset || index >= this.skip + pageSize) {\n                itemPresent = this.range(Math.floor(index / pageSize) * pageSize);\n              } // prefetch\n\n\n              if (index === this.prefetchThreshold) {\n                this._prefetch();\n              } // mid-range jump - prefetchThreshold and nextPageThreshold may be equal, do not change to else if\n\n\n              if (index === this.midPageThreshold) {\n                this.range(this.nextMidRange, true);\n              } // next range jump\n              else if (index === this.nextPageThreshold) {\n                this.range(this.nextFullRange);\n              } // pull-back\n              else if (index === this.pullBackThreshold) {\n                if (this.offset === this.skip) {\n                  // from full range to mid range\n                  this.range(this.previousMidRange);\n                } else {\n                  // from mid range to full range\n                  this.range(this.previousFullRange);\n                }\n              }\n\n              if (itemPresent) {\n                return this.dataSource.at(index - this.dataOffset);\n              } else {\n                this.trigger(\"endreached\", {\n                  index: index\n                });\n                return null;\n              }\n            }\n          },\n          indexOf: function (item) {\n            return this.dataSource.data().indexOf(item) + this.dataOffset;\n          },\n          total: function () {\n            return parseInt(this.dataSource.total(), 10);\n          },\n          next: function () {\n            var buffer = this,\n                pageSize = buffer.pageSize,\n                offset = buffer.skip - buffer.viewSize + pageSize,\n                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize;\n            this.offset = offset;\n            this.dataSource.prefetch(pageSkip, pageSize, function () {\n              buffer._goToRange(offset, true);\n            });\n          },\n          range: function (offset, nextRange) {\n            if (this.offset === offset) {\n              return true;\n            }\n\n            var buffer = this,\n                pageSize = this.pageSize,\n                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize,\n                dataSource = this.dataSource;\n\n            if (nextRange) {\n              pageSkip += pageSize;\n            }\n\n            if (dataSource.inRange(offset, pageSize)) {\n              this.offset = offset;\n\n              this._recalculate();\n\n              this._goToRange(offset);\n\n              return true;\n            } else if (this.prefetch) {\n              dataSource.prefetch(pageSkip, pageSize, function () {\n                buffer.offset = offset;\n\n                buffer._recalculate();\n\n                buffer._goToRange(offset, true);\n              });\n              return false;\n            }\n\n            return true;\n          },\n          syncDataSource: function () {\n            var offset = this.offset;\n            this.offset = null;\n            this.range(offset);\n          },\n          destroy: function () {\n            this.unbind();\n          },\n          _prefetch: function () {\n            var buffer = this,\n                pageSize = this.pageSize,\n                prefetchOffset = this.skip + pageSize,\n                dataSource = this.dataSource;\n\n            if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {\n              this._prefetching = true;\n              this.trigger(\"prefetching\", {\n                skip: prefetchOffset,\n                take: pageSize\n              });\n              dataSource.prefetch(prefetchOffset, pageSize, function () {\n                buffer._prefetching = false;\n                buffer.trigger(\"prefetched\", {\n                  skip: prefetchOffset,\n                  take: pageSize\n                });\n              });\n            }\n          },\n          _goToRange: function (offset, expanding) {\n            if (this.offset !== offset) {\n              return;\n            }\n\n            this.dataOffset = offset;\n            this._expanding = expanding;\n            this.dataSource.range(offset, this.pageSize);\n            this.dataSource.enableRequestsInProgress();\n          },\n          _reset: function () {\n            this._syncPending = true;\n          },\n          _change: function () {\n            var dataSource = this.dataSource;\n            this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;\n\n            if (this._syncPending) {\n              this._syncWithDataSource();\n\n              this._recalculate();\n\n              this._syncPending = false;\n              this.trigger(\"reset\", {\n                offset: this.offset\n              });\n            }\n\n            this.trigger(\"resize\");\n\n            if (this._expanding) {\n              this.trigger(\"expand\");\n            }\n\n            delete this._expanding;\n          },\n          _syncWithDataSource: function () {\n            var dataSource = this.dataSource;\n            this._firstItemUid = dataSource.firstItemUid();\n            this.dataOffset = this.offset = dataSource.skip() || 0;\n            this.pageSize = dataSource.pageSize();\n            this.useRanges = dataSource.options.serverPaging;\n          },\n          _recalculate: function () {\n            var pageSize = this.pageSize,\n                offset = this.offset,\n                viewSize = this.viewSize,\n                skip = Math.ceil(offset / pageSize) * pageSize;\n            this.skip = skip;\n            this.midPageThreshold = skip + pageSize - 1;\n            this.nextPageThreshold = skip + viewSize - 1;\n            this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);\n            this.pullBackThreshold = this.offset - 1;\n            this.nextMidRange = skip + pageSize - viewSize;\n            this.nextFullRange = skip;\n            this.previousMidRange = offset - viewSize;\n            this.previousFullRange = skip - pageSize;\n          }\n        });\n        var BatchBuffer = kendo.Observable.extend({\n          init: function (dataSource, batchSize) {\n            var batchBuffer = this;\n            kendo.Observable.fn.init.call(batchBuffer);\n            this.dataSource = dataSource;\n            this.batchSize = batchSize;\n            this._total = 0;\n            this.buffer = new Buffer(dataSource, batchSize * 3);\n            this.buffer.bind({\n              \"endreached\": function (e) {\n                batchBuffer.trigger(\"endreached\", {\n                  index: e.index\n                });\n              },\n              \"prefetching\": function (e) {\n                batchBuffer.trigger(\"prefetching\", {\n                  skip: e.skip,\n                  take: e.take\n                });\n              },\n              \"prefetched\": function (e) {\n                batchBuffer.trigger(\"prefetched\", {\n                  skip: e.skip,\n                  take: e.take\n                });\n              },\n              \"reset\": function () {\n                batchBuffer._total = 0;\n                batchBuffer.trigger(\"reset\");\n              },\n              \"resize\": function () {\n                batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);\n                batchBuffer.trigger(\"resize\", {\n                  total: batchBuffer.total(),\n                  offset: this.offset\n                });\n              }\n            });\n          },\n          syncDataSource: function () {\n            this.buffer.syncDataSource();\n          },\n          at: function (index) {\n            var buffer = this.buffer,\n                skip = index * this.batchSize,\n                take = this.batchSize,\n                view = [],\n                item;\n\n            if (buffer.offset > skip) {\n              buffer.at(buffer.offset - 1);\n            }\n\n            for (var i = 0; i < take; i++) {\n              item = buffer.at(skip + i);\n\n              if (item === null) {\n                break;\n              }\n\n              view.push(item);\n            }\n\n            return view;\n          },\n          total: function () {\n            return this._total;\n          },\n          destroy: function () {\n            this.buffer.destroy();\n            this.unbind();\n          }\n        });\n        extend(true, kendo.data, {\n          readers: {\n            json: DataReader\n          },\n          Query: Query,\n          DataSource: DataSource,\n          HierarchicalDataSource: HierarchicalDataSource,\n          Node: Node,\n          Comparer: Comparer,\n          ObservableObject: ObservableObject,\n          ObservableArray: ObservableArray,\n          LazyObservableArray: LazyObservableArray,\n          LocalTransport: LocalTransport,\n          RemoteTransport: RemoteTransport,\n          Cache: Cache,\n          DataReader: DataReader,\n          Model: Model,\n          Buffer: Buffer,\n          BatchBuffer: BatchBuffer\n        });\n      })(window.kendo.jQuery);\n\n      return window.kendo;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1126:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data.odata\");\n    /***/\n  },\n\n  /***/\n  1127:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./kendo.data.xml\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}