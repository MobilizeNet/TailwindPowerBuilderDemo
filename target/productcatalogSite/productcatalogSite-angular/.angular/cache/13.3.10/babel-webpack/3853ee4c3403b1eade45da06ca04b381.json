{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1718);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1718:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function (kendo) {\n        var RangeTreeNode = kendo.Class.extend({\n          init: function Node(level, value, left, right) {\n            this.level = level;\n            this.value = value;\n            this.left = left;\n            this.right = right;\n          }\n        });\n        var NilNode = new function NIL() {\n          // jshint ignore:line\n          this.left = this;\n          this.right = this;\n          this.level = 0;\n        }();\n\n        function skew(node) {\n          if (node.left.level === node.level) {\n            var temp = node;\n            node = node.left;\n            temp.left = node.right;\n            node.right = temp;\n          }\n\n          return node;\n        }\n\n        function split(node) {\n          if (node.right.right.level === node.level) {\n            var temp = node;\n            node = node.right;\n            temp.right = node.left;\n            node.left = temp;\n            node.level += 1;\n          }\n\n          return node;\n        }\n\n        function insert(node, value) {\n          if (node === NilNode) {\n            return new RangeTreeNode(1, value, NilNode, NilNode);\n          } else if (node.value.start > value.start) {\n            node.left = insert(node.left, value);\n          } else {\n            node.right = insert(node.right, value);\n          }\n\n          return split(skew(node));\n        }\n\n        function remove(node, value) {\n          if (node === NilNode) {\n            return node;\n          }\n\n          var diff = node.value.start - value.start;\n\n          if (diff === 0) {\n            if (node.left !== NilNode && node.right !== NilNode) {\n              var heir = node.left;\n\n              while (heir.right !== NilNode) {\n                heir = heir.right;\n              }\n\n              node.value = heir.value;\n              node.left = remove(node.left, node.value);\n            } else if (node.left === NilNode) {\n              node = node.right;\n            } else {\n              node = node.left;\n            }\n          } else if (diff > 0) {\n            node.left = remove(node.left, value);\n          } else {\n            node.right = remove(node.right, value);\n          }\n\n          if (node.left.level < node.level - 1 || node.right.level < node.level - 1) {\n            node.level -= 1;\n\n            if (node.right.level > node.level) {\n              node.right.level = node.level;\n            }\n\n            node = skew(node);\n            node.right = skew(node.right);\n            node.right.right = skew(node.right.right);\n            node = split(node);\n            node.right = split(node.right);\n          }\n\n          return node;\n        }\n\n        var Range = kendo.Class.extend({\n          init: function ValueRange(start, end, value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n          },\n          intersects: function (range) {\n            return range.start <= this.end && range.end >= this.start;\n          },\n          clone: function () {\n            return new Range(this.start, this.end, this.value);\n          }\n        });\n        var RangeTree = kendo.Class.extend({\n          init: function RangeTree() {\n            this.root = NilNode;\n          },\n          insert: function (value) {\n            this.root = insert(this.root, value);\n          },\n          remove: function (value) {\n            this.root = remove(this.root, value);\n          },\n          findrange: function (value) {\n            var node = this.root;\n\n            while (node != NilNode) {\n              if (value < node.value.start) {\n                node = node.left;\n              } else if (value > node.value.end) {\n                node = node.right;\n              } else {\n                return node.value;\n              }\n            }\n\n            return null;\n          },\n          values: function () {\n            var result = [];\n            values(this.root, result);\n            return result;\n          },\n          intersecting: function (start, end) {\n            var ranges = [];\n            intersecting(this.root, new Range(start, end), ranges);\n            return ranges;\n          },\n          map: function (callback) {\n            var tree = new RangeTree();\n            map(tree, this.root, callback);\n            return tree;\n          },\n          forEach: function (callback) {\n            forEach(this.root, callback);\n          },\n          clone: function () {\n            return this.map(function (value) {\n              return value.clone();\n            });\n          },\n          first: function () {\n            var first = this.root;\n\n            while (first.left != NilNode) {\n              first = first.left;\n            }\n\n            return first;\n          },\n          last: function () {\n            var last = this.root;\n\n            while (last.right != NilNode) {\n              last = last.right;\n            }\n\n            return last;\n          }\n        });\n\n        function values(node, result) {\n          if (node === NilNode) {\n            return;\n          }\n\n          values(node.left, result);\n          result.push(node.value);\n          values(node.right, result);\n        }\n\n        function intersecting(node, range, ranges) {\n          if (node === NilNode) {\n            return;\n          }\n\n          var value = node.value;\n\n          if (range.start < value.start) {\n            intersecting(node.left, range, ranges);\n          }\n\n          if (value.intersects(range)) {\n            ranges.push(value);\n          }\n\n          if (range.end > value.end) {\n            intersecting(node.right, range, ranges);\n          }\n        }\n\n        function map(tree, root, callback) {\n          if (root === NilNode) {\n            return;\n          }\n\n          map(tree, root.left, callback);\n          tree.insert(callback(root.value));\n          map(tree, root.right, callback);\n        }\n\n        function forEach(root, callback) {\n          if (root === NilNode) {\n            return;\n          }\n\n          forEach(root.left, callback);\n          callback(root.value);\n          forEach(root.right, callback);\n        }\n\n        var RangeList = kendo.Class.extend({\n          init: function RangeList(start, end, value) {\n            if (end === undefined) {\n              this.tree = start;\n            } else {\n              this.tree = new RangeTree();\n              this.tree.insert(new Range(start, end, value));\n            }\n          },\n          values: function () {\n            return this.tree.values();\n          },\n          map: function (callback) {\n            return new RangeList(this.tree.map(callback));\n          },\n          forEach: function (callback) {\n            this.tree.forEach(callback);\n          },\n          intersecting: function (start, end) {\n            return this.tree.intersecting(start, end);\n          },\n          first: function () {\n            return this.tree.first().value;\n          },\n          last: function () {\n            return this.tree.last().value;\n          },\n          insert: function (start, end, value) {\n            return this.tree.insert(new Range(start, end, value));\n          },\n          value: function (start, end, value) {\n            if (value === undefined) {\n              if (end === undefined) {\n                end = start;\n              }\n\n              return this.intersecting(start, end)[0].value;\n            }\n\n            var ranges = this.tree.intersecting(start - 1, end + 1);\n\n            if (ranges.length) {\n              var firstRange = ranges[0],\n                  lastRange = ranges[ranges.length - 1];\n\n              if (firstRange.end < start) {\n                if (firstRange.value === value) {\n                  start = firstRange.start;\n                } else {\n                  ranges.shift();\n                }\n              }\n\n              if (lastRange.start > end) {\n                if (lastRange.value === value) {\n                  end = lastRange.end;\n                } else {\n                  ranges.pop();\n                }\n              }\n\n              for (var i = 0, length = ranges.length; i < length; i++) {\n                var range = ranges[i];\n                var rangeValue = range.value;\n                var rangeStart = range.start;\n                var rangeEnd = range.end;\n                this.tree.remove(range);\n\n                if (rangeStart < start) {\n                  if (rangeValue !== value) {\n                    this.insert(rangeStart, start - 1, rangeValue);\n                  } else {\n                    start = rangeStart;\n                  }\n                }\n\n                if (rangeEnd > end) {\n                  if (rangeValue !== value) {\n                    this.insert(end + 1, rangeEnd, rangeValue);\n                  } else {\n                    end = rangeEnd;\n                  }\n                }\n              }\n            }\n\n            this.insert(start, end, value);\n          },\n          expandedValues: function (start, end) {\n            var ranges = this.intersecting(start, end);\n            var result = [];\n            var rangeIndex = 0;\n\n            for (var i = start; i <= end; i++) {\n              if (ranges[rangeIndex].end < i) {\n                rangeIndex++;\n              }\n\n              result.push({\n                index: i - start,\n                value: ranges[rangeIndex].value\n              });\n            }\n\n            return result;\n          },\n          sortedIndices: function (start, end, valueComparer, indices) {\n            var result = this.expandedValues(start, end);\n\n            var comparer = function (a, b) {\n              if (a.value === b.value) {\n                return a.index - b.index;\n              }\n\n              return valueComparer(a.value, b.value);\n            };\n\n            if (indices) {\n              comparer = function (a, b) {\n                var x = indices[a.index];\n                var y = indices[b.index];\n\n                if (x.value === y.value) {\n                  return valueComparer(a.value, b.value);\n                }\n\n                return a.index - b.index;\n              };\n            }\n\n            result.sort(comparer);\n            return result;\n          },\n          sort: function (start, end, indices) {\n            if (this.intersecting(start, end).length === 1) {\n              return;\n            }\n\n            var values = this.expandedValues(start, end);\n\n            for (var i = 0, len = indices.length; i < len; i++) {\n              this.value(i + start, i + start, values[indices[i].index].value);\n            }\n          },\n          copy: function (sourceStart, sourceEnd, targetStart) {\n            var values = this.intersecting(sourceStart, sourceEnd);\n            var start = targetStart;\n            var end;\n\n            for (var i = 0, len = values.length; i < len; i++) {\n              var rangeStart = values[i].start;\n\n              if (rangeStart < sourceStart) {\n                rangeStart = sourceStart;\n              }\n\n              var rangeEnd = values[i].end;\n\n              if (rangeEnd > sourceEnd) {\n                rangeEnd = sourceEnd;\n              }\n\n              end = start + (rangeEnd - rangeStart);\n              this.value(start, end, values[i].value);\n              start = ++end;\n            }\n          },\n          iterator: function (start, end) {\n            return new Iterator(start, end, this.intersecting(start, end));\n          },\n          getState: function () {\n            return this.tree.clone();\n          },\n          setState: function (state) {\n            this.tree = state.clone();\n          },\n          toJSON: function () {\n            return this.values();\n          },\n          fromJSON: function (values) {\n            values.forEach(function (v) {\n              this.value(v.start, v.end, v.value);\n            }, this);\n          }\n        });\n        var Iterator = kendo.Class.extend({\n          init: function (start, end, ranges) {\n            this.start = start;\n            this.end = end;\n            this.index = 0;\n            this.ranges = ranges;\n          },\n          unique: function () {\n            return this.ranges.map(function (range) {\n              return range.value;\n            });\n          },\n          at: function (index) {\n            while (this.ranges[this.index] && this.ranges[this.index].end < index) {\n              this.index++;\n            }\n\n            return this.ranges[this.index] && this.ranges[this.index].value;\n          },\n          forEach: function (callback) {\n            for (var i = this.start; i <= this.end; i++) {\n              callback(this.at(i), i);\n            }\n\n            this.index = 0;\n          }\n        });\n        var SparseRangeList = RangeList.extend({\n          init: function (start, end, value) {\n            this.tree = new RangeTree();\n            this.range = new Range(start, end, value);\n          },\n          intersecting: function (start, end) {\n            var ranges = this.tree.intersecting(start, end);\n            var result = [];\n            var range;\n\n            if (!ranges.length) {\n              return [this.range];\n            }\n\n            for (var i = 0, len = ranges.length; i < len; i++) {\n              range = ranges[i];\n\n              if (range.start > start) {\n                result.push(new Range(start, range.start - 1, this.range.value));\n              }\n\n              result.push(range);\n              start = range.end + 1;\n            }\n\n            if (range.end < end) {\n              result.push(new Range(range.end + 1, end, this.range.value));\n            }\n\n            return result;\n          },\n          insert: function (start, end, value) {\n            if (value !== this.range.value) {\n              this.tree.insert(new Range(start, end, value));\n            }\n          },\n          lastRangeStart: function () {\n            var node = this.tree.root;\n\n            if (node === NilNode) {\n              return this.range.start;\n            }\n\n            while (node.right !== NilNode) {\n              node = node.right;\n            }\n\n            return node.value.end + 1;\n          }\n        });\n        kendo.spreadsheet.RangeTree = RangeTree;\n        kendo.spreadsheet.RangeList = RangeList;\n        kendo.spreadsheet.SparseRangeList = SparseRangeList;\n        kendo.spreadsheet.ValueRange = Range;\n      })(kendo);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}