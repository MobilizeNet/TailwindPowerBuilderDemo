{"ast":null,"code":"import { drawing as draw, geometry } from '@progress/kendo-drawing';\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\nconst PIE_SECTOR_ANIM_DELAY = 70;\n\nclass PieChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.points = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n\n  traverseDataPoints(callback) {\n    const {\n      options,\n      plotArea: {\n        options: {\n          seriesColors = []\n        }\n      }\n    } = this;\n    const colorsCount = seriesColors.length;\n    const series = options.series;\n    const seriesCount = series.length;\n\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const data = currentSeries.data;\n      const {\n        total,\n        points,\n        count\n      } = bindSegments(currentSeries);\n      const anglePerValue = 360 / total;\n      let constantAngle;\n\n      if (!isFinite(anglePerValue)) {\n        constantAngle = 360 / count;\n      }\n\n      let currentAngle;\n\n      if (defined(currentSeries.startAngle)) {\n        currentAngle = currentSeries.startAngle;\n      } else {\n        currentAngle = options.startAngle;\n      }\n\n      if (seriesIx !== seriesCount - 1) {\n        if (currentSeries.labels.position === OUTSIDE_END) {\n          currentSeries.labels.position = CENTER;\n        }\n      }\n\n      for (let i = 0; i < points.length; i++) {\n        const pointData = points[i];\n\n        if (!pointData) {\n          continue;\n        }\n\n        const {\n          fields,\n          value,\n          visible\n        } = pointData;\n        const angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n        const explode = data.length !== 1 && Boolean(fields.explode);\n\n        if (!isFunction(currentSeries.color)) {\n          currentSeries.color = fields.color || seriesColors[i % colorsCount];\n        }\n\n        callback(value, new Ring(null, 0, 0, currentAngle, angle), {\n          owner: this,\n          category: defined(fields.category) ? fields.category : \"\",\n          index: i,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: data[i],\n          percentage: total !== 0 ? value / total : 0,\n          explode: explode,\n          visibleInLegend: fields.visibleInLegend,\n          visible: visible,\n          zIndex: seriesCount - seriesIx,\n          animationDelay: this.animationDelay(i, seriesIx, seriesCount)\n        });\n\n        if (visible !== false) {\n          currentAngle += angle;\n        }\n      }\n    }\n  }\n\n  evalSegmentOptions(options, value, fields) {\n    const series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      category: fields.category,\n      percentage: fields.percentage\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n    });\n  }\n\n  addValue(value, sector, fields) {\n    const segmentOptions = deepExtend({}, fields.series, {\n      index: fields.index\n    });\n    this.evalSegmentOptions(segmentOptions, value, fields);\n    this.createLegendItem(value, segmentOptions, fields);\n\n    if (fields.visible === false) {\n      return;\n    }\n\n    const segment = new PieSegment(value, sector, segmentOptions);\n    Object.assign(segment, fields);\n    this.append(segment);\n    this.points.push(segment);\n  }\n\n  reflow(targetBox) {\n    const {\n      options,\n      points,\n      seriesConfigs = []\n    } = this;\n    const count = points.length;\n    const box = targetBox.clone();\n    const space = 5;\n    const minWidth = Math.min(box.width(), box.height());\n    const halfMinWidth = minWidth / 2;\n    const defaultPadding = minWidth - minWidth * 0.85;\n    const newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n    const newBoxCenter = newBox.center();\n    const boxCenter = box.center();\n    const seriesCount = options.series.length;\n    const leftSideLabels = [];\n    const rightSideLabels = [];\n    let padding = valueOrDefault(options.padding, defaultPadding);\n    this.targetBox = targetBox;\n    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n    const radius = halfMinWidth - padding;\n    const center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n\n    for (let i = 0; i < count; i++) {\n      const segment = points[i];\n      const sector = segment.sector;\n      const seriesIndex = segment.seriesIx;\n      sector.radius = radius;\n      sector.center = center;\n\n      if (seriesConfigs.length) {\n        const seriesConfig = seriesConfigs[seriesIndex];\n        sector.innerRadius = seriesConfig.innerRadius;\n        sector.radius = seriesConfig.radius;\n      }\n\n      if (seriesIndex === seriesCount - 1 && segment.explode) {\n        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n      }\n\n      segment.reflow(newBox);\n      const label = segment.label;\n\n      if (label) {\n        if (label.options.position === OUTSIDE_END) {\n          if (seriesIndex === seriesCount - 1) {\n            if (label.orientation === RIGHT) {\n              rightSideLabels.push(label);\n            } else {\n              leftSideLabels.push(label);\n            }\n          }\n        }\n      }\n    }\n\n    if (leftSideLabels.length > 0) {\n      leftSideLabels.sort(this.labelComparator(true));\n      this.leftLabelsReflow(leftSideLabels);\n    }\n\n    if (rightSideLabels.length > 0) {\n      rightSideLabels.sort(this.labelComparator(false));\n      this.rightLabelsReflow(rightSideLabels);\n    }\n\n    this.box = newBox;\n  }\n\n  leftLabelsReflow(labels) {\n    const distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  }\n\n  rightLabelsReflow(labels) {\n    const distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  }\n\n  distanceBetweenLabels(labels) {\n    const segment = last(this.points);\n    const sector = segment.sector;\n    const count = labels.length - 1;\n    const lr = sector.radius + segment.options.labels.distance;\n    const distances = [];\n    let firstBox = labels[0].box;\n    let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n    distances.push(distance);\n\n    for (let i = 0; i < count; i++) {\n      const secondBox = labels[i + 1].box;\n      firstBox = labels[i].box;\n      distance = round(secondBox.y1 - firstBox.y2);\n      distances.push(distance);\n    }\n\n    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n    distances.push(distance);\n    return distances;\n  }\n\n  distributeLabels(distances, labels) {\n    const count = distances.length;\n    let left, right, remaining;\n\n    for (let i = 0; i < count; i++) {\n      remaining = -distances[i];\n      left = right = i;\n\n      while (remaining > 0 && (left >= 0 || right < count)) {\n        remaining = this._takeDistance(distances, i, --left, remaining);\n        remaining = this._takeDistance(distances, i, ++right, remaining);\n      }\n    }\n\n    this.reflowLabels(distances, labels);\n  }\n\n  _takeDistance(distances, anchor, position, amount) {\n    let result = amount;\n\n    if (distances[position] > 0) {\n      const available = Math.min(distances[position], result);\n      result -= available;\n      distances[position] -= available;\n      distances[anchor] += available;\n    }\n\n    return result;\n  }\n\n  reflowLabels(distances, labels) {\n    const segment = last(this.points);\n    const sector = segment.sector;\n    const labelOptions = segment.options.labels;\n    const labelsCount = labels.length;\n    const labelDistance = labelOptions.distance;\n    let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n    let boxX;\n    distances[0] += 2;\n\n    for (let i = 0; i < labelsCount; i++) {\n      const label = labels[i];\n      const box = label.box;\n      boxY += distances[i];\n      boxX = this.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n\n      if (label.orientation === RIGHT) {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.radius + sector.center.x + labelDistance;\n        }\n\n        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n      } else {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.center.x - sector.radius - labelDistance;\n        }\n\n        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n      }\n\n      boxY += box.height();\n    }\n  }\n\n  createVisual() {\n    const {\n      options: {\n        connectors\n      },\n      points\n    } = this;\n    const count = points.length;\n    const space = 4;\n    super.createVisual();\n    this._connectorLines = [];\n\n    for (let i = 0; i < count; i++) {\n      const segment = points[i];\n      const {\n        sector,\n        label\n      } = segment;\n      const angle = sector.middle();\n      const connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n      if (label) {\n        const connectorLine = new draw.Path({\n          stroke: {\n            color: connectorsColor,\n            width: connectors.width\n          },\n          animation: {\n            type: FADEIN,\n            delay: segment.animationDelay\n          }\n        });\n\n        if (label.options.position === OUTSIDE_END) {\n          const box = label.box;\n          const centerPoint = sector.center;\n          let start = sector.point(angle);\n          let middle = new Point(box.x1, box.center().y);\n          let sr, end, crossing;\n          start = sector.clone().expand(connectors.padding).point(angle);\n          connectorLine.moveTo(start.x, start.y); // TODO: Extract into a method to remove duplication\n\n          if (label.orientation === RIGHT) {\n            end = new Point(box.x1 - connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x - space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.min(crossing.x, middle.x);\n\n            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n              sr = sector.center.x + sector.radius + space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr < middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x + space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          } else {\n            end = new Point(box.x2 + connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x + space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.max(crossing.x, middle.x);\n\n            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n              sr = sector.center.x - sector.radius - space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr > middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x - space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          }\n\n          connectorLine.lineTo(end.x, end.y);\n\n          this._connectorLines.push(connectorLine);\n\n          this.visual.append(connectorLine);\n        }\n      }\n    }\n  }\n\n  renderVisual() {\n    super.renderVisual();\n\n    if (find(this.options.series, options => options.autoFit)) {\n      const targetBox = this.targetBox;\n      const pieCenter = this.box.center();\n      const bbox = this.visual.bbox();\n\n      if (!bbox) {\n        return;\n      }\n\n      const bboxBottom = bbox.bottomRight();\n      const scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));\n\n      if (scale < 1) {\n        this.visual.transform(geometry.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));\n      }\n    }\n  }\n\n  labelComparator(reverse) {\n    const reverseValue = reverse ? -1 : 1;\n    return function (a, b) {\n      const first = (a.parent.sector.middle() + 270) % 360;\n      const second = (b.parent.sector.middle() + 270) % 360;\n      return (first - second) * reverseValue;\n    };\n  }\n\n  hAlignLabel(originalX, sector, y1, y2, direction) {\n    const {\n      radius,\n      center: {\n        x: cx,\n        y: cy\n      }\n    } = sector;\n    const t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n    if (t > radius) {\n      return originalX;\n    }\n\n    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n  }\n\n  pointInCircle(point, center, radius) {\n    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n  }\n\n  formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  }\n\n  animationDelay(categoryIndex) {\n    return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n  }\n\n  stackRoot() {\n    return this;\n  }\n\n}\n\nfunction intersection(a1, a2, b1, b2) {\n  const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n  const ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n  let result;\n\n  if (ub !== 0) {\n    const ua = uat / ub;\n    result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n  }\n\n  return result;\n}\n\nsetDefaultOptions(PieChart, {\n  startAngle: 90,\n  connectors: {\n    width: 2,\n    color: \"#939393\",\n    padding: 8\n  },\n  inactiveItems: {\n    markers: {},\n    labels: {}\n  }\n});\ndeepExtend(PieChart.prototype, PieChartMixin);\nPieChart.prototype.isStackRoot = true;\nexport default PieChart;","map":null,"metadata":{},"sourceType":"module"}