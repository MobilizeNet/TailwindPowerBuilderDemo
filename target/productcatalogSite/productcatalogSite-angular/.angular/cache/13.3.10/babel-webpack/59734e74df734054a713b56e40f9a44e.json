{"ast":null,"code":"import Aggregates from './aggregates';\nimport { Class, defined, inArray, isArray, isFunction, isNumber, isObject } from '../../common';\n\nclass SeriesAggregator extends Class {\n  constructor(series, binder, defaultAggregates) {\n    super();\n    const canonicalFields = binder.canonicalFields(series);\n    const valueFields = binder.valueFields(series);\n    const sourceFields = binder.sourceFields(series, canonicalFields);\n    const seriesFields = this._seriesFields = [];\n    const defaults = defaultAggregates.query(series.type);\n    const rootAggregate = series.aggregate || defaults;\n    this._series = series;\n    this._binder = binder;\n\n    for (let i = 0; i < canonicalFields.length; i++) {\n      const field = canonicalFields[i];\n      let fieldAggregate;\n\n      if (isObject(rootAggregate)) {\n        fieldAggregate = rootAggregate[field];\n      } else if (i === 0 || inArray(field, valueFields)) {\n        fieldAggregate = rootAggregate;\n      } else {\n        break;\n      }\n\n      if (fieldAggregate) {\n        seriesFields.push({\n          canonicalName: field,\n          name: sourceFields[i],\n          transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\n        });\n      }\n    }\n  }\n\n  aggregatePoints(srcPoints, group) {\n    const {\n      _series: series,\n      _seriesFields: seriesFields\n    } = this;\n\n    const data = this._bindPoints(srcPoints || []);\n\n    const firstDataItem = data.dataItems[0];\n    let result = {};\n\n    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n      const fn = function () {};\n\n      fn.prototype = firstDataItem;\n      result = new fn();\n    }\n\n    for (let i = 0; i < seriesFields.length; i++) {\n      const field = seriesFields[i];\n\n      const srcValues = this._bindField(data.values, field.canonicalName);\n\n      const value = field.transform(srcValues, series, data.dataItems, group);\n\n      if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n        result = value;\n        break;\n      } else {\n        if (defined(value)) {\n          setValue(field.name, result, value);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _bindPoints(points) {\n    const {\n      _binder: binder,\n      _series: series\n    } = this;\n    const values = [];\n    const dataItems = [];\n\n    for (let i = 0; i < points.length; i++) {\n      const pointIx = points[i];\n      values.push(binder.bindPoint(series, pointIx));\n      dataItems.push(series.data[pointIx]);\n    }\n\n    return {\n      values: values,\n      dataItems: dataItems\n    };\n  }\n\n  _bindField(data, field) {\n    const values = [];\n    const count = data.length;\n\n    for (let i = 0; i < count; i++) {\n      const item = data[i];\n      const valueFields = item.valueFields;\n      let value;\n\n      if (defined(valueFields[field])) {\n        value = valueFields[field];\n      } else {\n        value = item.fields[field];\n      }\n\n      values.push(value);\n    }\n\n    return values;\n  }\n\n}\n\nfunction setValue(fieldName, target, value) {\n  let parentObj = target;\n  let field = fieldName;\n\n  if (fieldName.indexOf(\".\") > -1) {\n    const parts = fieldName.split(\".\");\n\n    while (parts.length > 1) {\n      field = parts.shift();\n\n      if (!defined(parentObj[field])) {\n        parentObj[field] = {};\n      }\n\n      parentObj = parentObj[field];\n    }\n\n    field = parts.shift();\n  }\n\n  parentObj[field] = value;\n}\n\nexport default SeriesAggregator;","map":null,"metadata":{},"sourceType":"module"}