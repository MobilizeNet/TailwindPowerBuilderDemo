{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(900);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  896:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.core\");\n    /***/\n  },\n\n  /***/\n  900:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /***********************************************************************\n    * WARNING: this file is auto-generated.  If you change it directly,\n    * your modifications will eventually be lost.  The source code is in\n    * `kendo-charts` repository, you should make your changes there and\n    * run `src-modules/sync.sh` in this repository.\n    */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(896), __webpack_require__(893)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        /* jshint curly:false */\n\n        /* jshint -W058 */\n        window.kendo.dataviz = window.kendo.dataviz || {};\n        var drawing = kendo.drawing;\n        var util = drawing.util;\n        var Path = drawing.Path;\n        var Group = drawing.Group;\n        var Class = kendo.Class;\n        var support = kendo.support;\n        var geometry = kendo.geometry;\n        var Rect = geometry.Rect;\n        var Circle = geometry.Circle;\n        var geometryTransform = geometry.transform;\n        var Segment = geometry.Segment;\n        var dataviz = kendo.dataviz;\n        var deepExtend = kendo.deepExtend;\n        var isFunction = kendo.isFunction;\n        var __common_getter_js = kendo.getter;\n        var ARC = \"arc\";\n        var AXIS_LABEL_CLICK = \"axisLabelClick\";\n        var BLACK = \"#000\";\n        var BOTTOM = \"bottom\";\n        var CENTER = \"center\";\n        var CIRCLE = \"circle\";\n        var COORD_PRECISION = 3;\n        var CROSS = \"cross\";\n        var DATE = \"date\";\n        var DEFAULT_FONT = \"12px sans-serif\";\n        var DEFAULT_HEIGHT = 400;\n        var DEFAULT_PRECISION = 10;\n        var DEFAULT_WIDTH = 600;\n        var END = \"end\";\n        var FORMAT_REGEX = /\\{\\d+:?/;\n        var HEIGHT = \"height\";\n        var HIGHLIGHT_ZINDEX = 100;\n        var INSIDE = \"inside\";\n        var LEFT = \"left\";\n        var MAX_VALUE = Number.MAX_VALUE;\n        var MIN_VALUE = -Number.MAX_VALUE;\n        var NONE = \"none\";\n        var NOTE_CLICK = \"noteClick\";\n        var NOTE_HOVER = \"noteHover\";\n        var NOTE_LEAVE = \"noteLeave\";\n        var OBJECT = \"object\";\n        var OUTSIDE = \"outside\";\n        var RIGHT = \"right\";\n        var ROUNDED_RECT = \"roundedRect\";\n        var START = \"start\";\n        var STRING = \"string\";\n        var TOP = \"top\";\n        var TRIANGLE = \"triangle\";\n        var VALUE = \"value\";\n        var WHITE = \"#fff\";\n        var WIDTH = \"width\";\n        var X = \"x\";\n        var Y = \"y\";\n        var DEFAULT_SERIES_OPACITY = 1;\n        var constants = {\n          ARC: ARC,\n          AXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\n          BLACK: BLACK,\n          BOTTOM: BOTTOM,\n          CENTER: CENTER,\n          CIRCLE: CIRCLE,\n          COORD_PRECISION: COORD_PRECISION,\n          CROSS: CROSS,\n          DATE: DATE,\n          DEFAULT_FONT: DEFAULT_FONT,\n          DEFAULT_HEIGHT: DEFAULT_HEIGHT,\n          DEFAULT_PRECISION: DEFAULT_PRECISION,\n          DEFAULT_WIDTH: DEFAULT_WIDTH,\n          END: END,\n          FORMAT_REGEX: FORMAT_REGEX,\n          HEIGHT: HEIGHT,\n          HIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX,\n          INSIDE: INSIDE,\n          LEFT: LEFT,\n          MAX_VALUE: MAX_VALUE,\n          MIN_VALUE: MIN_VALUE,\n          NONE: NONE,\n          NOTE_CLICK: NOTE_CLICK,\n          NOTE_HOVER: NOTE_HOVER,\n          NOTE_LEAVE: NOTE_LEAVE,\n          OBJECT: OBJECT,\n          OUTSIDE: OUTSIDE,\n          RIGHT: RIGHT,\n          ROUNDED_RECT: ROUNDED_RECT,\n          START: START,\n          STRING: STRING,\n          TOP: TOP,\n          TRIANGLE: TRIANGLE,\n          VALUE: VALUE,\n          WHITE: WHITE,\n          WIDTH: WIDTH,\n          X: X,\n          Y: Y,\n          DEFAULT_SERIES_OPACITY: DEFAULT_SERIES_OPACITY\n        };\n\n        function isArray(value) {\n          return Array.isArray(value);\n        }\n\n        function addClass(element, classes) {\n          var classArray = isArray(classes) ? classes : [classes];\n\n          for (var idx = 0; idx < classArray.length; idx++) {\n            var className = classArray[idx];\n\n            if (element.className.indexOf(className) === -1) {\n              element.className += \" \" + className;\n            }\n          }\n        }\n\n        var SPACE_REGEX = /\\s+/g;\n\n        function removeClass(element, className) {\n          if (element && element.className) {\n            element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\n          }\n        }\n\n        function alignPathToPixel(path) {\n          var offset = 0.5;\n\n          if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\n            if (path.options.stroke.width % 2 === 0) {\n              offset = 0;\n            }\n          }\n\n          for (var i = 0; i < path.segments.length; i++) {\n            path.segments[i].anchor().round(0).translate(offset, offset);\n          }\n\n          return path;\n        }\n\n        function clockwise(angle1, angle2) {\n          // True if angle2 is clockwise of angle1\n          // assuming angles grow in clock-wise direction\n          // (as in the pie and radar charts)\n          return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n        }\n\n        function isNumber(value) {\n          return typeof value === \"number\" && !isNaN(value);\n        }\n\n        function isString(value) {\n          return typeof value === STRING;\n        }\n\n        function convertableToNumber(value) {\n          return isNumber(value) || isString(value) && isFinite(value);\n        }\n\n        function isObject(value) {\n          return typeof value === \"object\";\n        }\n\n        function styleValue(value) {\n          if (isNumber(value)) {\n            return value + \"px\";\n          }\n\n          return value;\n        }\n\n        var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\n        function isSizeField(field) {\n          return SIZE_STYLES_REGEX.test(field);\n        }\n\n        function elementStyles(element, styles) {\n          var stylesArray = isString(styles) ? [styles] : styles;\n\n          if (isArray(stylesArray)) {\n            var result = {};\n            var style = window.getComputedStyle(element);\n\n            for (var idx = 0; idx < stylesArray.length; idx++) {\n              var field = stylesArray[idx];\n              result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n            }\n\n            return result;\n          } else if (isObject(styles)) {\n            for (var field$1 in styles) {\n              element.style[field$1] = styleValue(styles[field$1]);\n            }\n          }\n        }\n\n        function getSpacing(value, defaultSpacing) {\n          if (defaultSpacing === void 0) {\n            defaultSpacing = 0;\n          }\n\n          var spacing = {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n          };\n\n          if (typeof value === \"number\") {\n            spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n          } else {\n            spacing[TOP] = value[TOP] || defaultSpacing;\n            spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n            spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n            spacing[LEFT] = value[LEFT] || defaultSpacing;\n          }\n\n          return spacing;\n        }\n\n        var current = {\n          compile: function (template) {\n            return template;\n          }\n        };\n        var TemplateService = Class.extend({});\n\n        TemplateService.register = function (userImplementation) {\n          current = userImplementation;\n        };\n\n        TemplateService.compile = function (template) {\n          return current.compile(template);\n        };\n\n        function getTemplate(options) {\n          if (options === void 0) {\n            options = {};\n          }\n\n          var template;\n\n          if (options.template) {\n            options.template = template = TemplateService.compile(options.template);\n          } else if (isFunction(options.content)) {\n            template = options.content;\n          }\n\n          return template;\n        }\n\n        function grep(array, callback) {\n          var length = array.length;\n          var result = [];\n\n          for (var idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n              result.push(array[idx]);\n            }\n          }\n\n          return result;\n        }\n\n        function hasClasses(element, classNames) {\n          if (element.className) {\n            var names = classNames.split(\" \");\n\n            for (var idx = 0; idx < names.length; idx++) {\n              if (element.className.indexOf(names[idx]) !== -1) {\n                return true;\n              }\n            }\n          }\n        }\n\n        var HashMap = function HashMap() {\n          this._map = {};\n        };\n\n        HashMap.prototype.get = function get(name) {\n          return this._map[this._key(name)];\n        };\n\n        HashMap.prototype.set = function set(name, value) {\n          this._map[this._key(name)] = value;\n        };\n\n        HashMap.prototype._key = function _key(name) {\n          return name instanceof Date ? name.getTime() : name;\n        };\n\n        function inArray(value, array) {\n          if (array) {\n            return array.indexOf(value) !== -1;\n          }\n        }\n\n        function interpolateValue(start, end, progress) {\n          return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\n        }\n\n        var TRIGGER = 'trigger';\n        var InstanceObserver = Class.extend({\n          init: function (observer, handlers) {\n            this.observer = observer;\n            this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n          },\n          trigger: function (name, args) {\n            var ref = this;\n            var observer = ref.observer;\n            var handlerMap = ref.handlerMap;\n            var isDefaultPrevented;\n\n            if (handlerMap[name]) {\n              isDefaultPrevented = this.callObserver(handlerMap[name], args);\n            } else if (observer[TRIGGER]) {\n              isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n            }\n\n            return isDefaultPrevented;\n          },\n          callObserver: function (fnName) {\n            var args = [],\n                len = arguments.length - 1;\n\n            while (len-- > 0) args[len] = arguments[len + 1];\n\n            return this.observer[fnName].apply(this.observer, args);\n          },\n          requiresHandlers: function (names) {\n            var this$1 = this;\n\n            if (this.observer.requiresHandlers) {\n              return this.observer.requiresHandlers(names);\n            }\n\n            for (var idx = 0; idx < names.length; idx++) {\n              if (this$1.handlerMap[names[idx]]) {\n                return true;\n              }\n            }\n          }\n        });\n\n        function map(array, callback) {\n          var length = array.length;\n          var result = [];\n\n          for (var idx = 0; idx < length; idx++) {\n            var value = callback(array[idx]);\n\n            if (kendo.drawing.util.defined(value)) {\n              result.push(value);\n            }\n          }\n\n          return result;\n        }\n\n        var browser = support.browser || {};\n\n        function mousewheelDelta(e) {\n          var delta = 0;\n\n          if (e.wheelDelta) {\n            delta = -e.wheelDelta / 120;\n\n            if (browser.webkit) {\n              // Webkit browsers scale the delta by twice the device resolution.\n              // Possibly related to https://bugs.webkit.org/show_bug.cgi?id=196339\n              //\n              // Low device resolutions (e.g. zoom-out to 30%) also behave strangely.\n              delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));\n            }\n          } else if (e.detail) {\n            delta = e.detail / 3;\n          }\n\n          delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n          return delta;\n        }\n\n        var ref = kendo.drawing.util;\n        var append = ref.append;\n        var bindEvents = ref.bindEvents;\n        var defined = ref.defined;\n        var deg = ref.deg;\n        var elementOffset = ref.elementOffset;\n        var elementSize = ref.elementSize;\n        var eventCoordinates = ref.eventCoordinates;\n        var eventElement = ref.eventElement;\n        var hashKey = ref.hashKey;\n        var last = ref.last;\n        var limitValue = ref.limitValue;\n        var objectKey = ref.objectKey;\n        var rad = ref.rad;\n        var round = ref.round;\n        var unbindEvents = ref.unbindEvents;\n        var valueOrDefault = ref.valueOrDefault;\n        var FontLoader = Class.extend({});\n\n        FontLoader.fetchFonts = function (options, fonts, state) {\n          if (state === void 0) {\n            state = {\n              depth: 0\n            };\n          }\n\n          var MAX_DEPTH = 5;\n\n          if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n            return;\n          }\n\n          Object.keys(options).forEach(function (key) {\n            var value = options[key];\n\n            if (key === \"dataSource\" || key[0] === \"$\" || !value) {\n              return;\n            }\n\n            if (key === \"font\") {\n              fonts.push(value);\n            } else if (typeof value === \"object\") {\n              state.depth++;\n              FontLoader.fetchFonts(value, fonts, state);\n              state.depth--;\n            }\n          });\n        };\n\n        FontLoader.loadFonts = function (fonts, callback) {\n          var promises = [];\n\n          if (fonts.length > 0 && document.fonts) {\n            try {\n              promises = fonts.map(function (font) {\n                return document.fonts.load(font);\n              });\n            } catch (e) {\n              // Silence font-loading errors\n              kendo.logToConsole(e);\n            }\n\n            Promise.all(promises).then(callback, callback);\n          } else {\n            callback();\n          }\n        };\n\n        FontLoader.preloadFonts = function (options, callback) {\n          var fonts = [];\n          FontLoader.fetchFonts(options, fonts);\n          FontLoader.loadFonts(fonts, callback);\n        };\n\n        function setDefaultOptions(type, options) {\n          var proto = type.prototype;\n\n          if (proto.options) {\n            proto.options = deepExtend({}, proto.options, options);\n          } else {\n            proto.options = options;\n          }\n        }\n\n        function sparseArrayLimits(arr) {\n          var min = MAX_VALUE;\n          var max = MIN_VALUE;\n\n          for (var idx = 0, length = arr.length; idx < length; idx++) {\n            var value = arr[idx];\n\n            if (value !== null && isFinite(value)) {\n              min = Math.min(min, value);\n              max = Math.max(max, value);\n            }\n          }\n\n          return {\n            min: min === MAX_VALUE ? undefined : min,\n            max: max === MIN_VALUE ? undefined : max\n          };\n        }\n\n        function find(array, predicate) {\n          for (var i = 0; i < array.length; i++) {\n            var item = array[i];\n\n            if (predicate(item, i, array)) {\n              return item;\n            }\n          }\n        }\n\n        var Matrix = geometry.Matrix;\n        var matrixRegexp = /matrix\\((.*)\\)/;\n\n        function parseMatrix(matrixString) {\n          var match = matrixString.match(matrixRegexp);\n\n          if (match === null || match.length !== 2) {\n            return Matrix.unit();\n          }\n\n          var members = match[1].split(',').map(function (x) {\n            return parseFloat(x);\n          });\n          return new (Function.prototype.bind.apply(Matrix, [null].concat(members)))();\n        }\n\n        function transformMatrix(element) {\n          var transform = getComputedStyle(element).transform;\n\n          if (transform === 'none') {\n            return Matrix.unit();\n          }\n\n          return parseMatrix(transform);\n        }\n\n        function elementScale(element) {\n          if (!element) {\n            return Matrix.unit();\n          }\n\n          var matrix = transformMatrix(element);\n          var parent = element.parentElement;\n\n          while (parent) {\n            var parentMatrix = transformMatrix(parent);\n            matrix = matrix.multiplyCopy(parentMatrix);\n            parent = parent.parentElement;\n          }\n\n          matrix.b = matrix.c = matrix.e = matrix.f = 0;\n          return matrix;\n        }\n\n        function autoTextColor(color) {\n          var isDark = new kendo.Color(color).isDark();\n\n          if (isDark) {\n            return WHITE;\n          }\n\n          return BLACK;\n        }\n\n        var DELETED = {};\n        var LegacySet = Class.extend({\n          init: function (values) {\n            var this$1 = this;\n            this._index = {};\n            this._values = values ? values.slice(0) : [];\n\n            for (var i = 0; i < this._values.length; i++) {\n              this$1._index[this$1._values[i]] = i;\n            }\n          },\n          values: function () {\n            return this._values.filter(function (item) {\n              return item !== DELETED;\n            });\n          },\n          has: function (value) {\n            return this._index[value] !== undefined;\n          },\n          add: function (value) {\n            if (!this.has(value)) {\n              this._index[value] = this._values.length;\n\n              this._values.push(value);\n            }\n          },\n          delete: function (value) {\n            var index = this._index[value];\n\n            if (index !== undefined) {\n              this._values[index] = DELETED;\n              delete this._index[value];\n            }\n          },\n          clear: function () {\n            this._index = {};\n            this._values = [];\n          }\n        });\n\n        if (Object.defineProperties) {\n          Object.defineProperties(LegacySet.fn, {\n            size: {\n              get: function () {\n                return this._values.length;\n              }\n            }\n          });\n        }\n\n        var SetWrapper = Class.extend({\n          init: function (values) {\n            this._set = new Set(values);\n          },\n          values: function () {\n            return Array.from(this._set);\n          },\n          has: function (value) {\n            return this._set.has(value);\n          },\n          add: function (value) {\n            this._set.add(value);\n          },\n          delete: function (value) {\n            this._set.delete(value);\n          },\n          clear: function () {\n            this._set.clear();\n          }\n        });\n\n        if (Object.defineProperties) {\n          Object.defineProperties(SetWrapper.fn, {\n            size: {\n              get: function () {\n                return this._set.size;\n              }\n            }\n          });\n        } // TODO: Drop LegacySet when removing support for IE10\n\n\n        var supportsSet = function () {\n          var supported = false;\n\n          if (typeof Set === 'function') {\n            var set = new Set([1]);\n            supported = set.has(1);\n          }\n\n          return supported;\n        };\n\n        function createHashSet(values) {\n          if (supportsSet()) {\n            return new SetWrapper(values);\n          }\n\n          return new LegacySet(values);\n        }\n\n        function defaultErrorHandler(error) {\n          throw error;\n        }\n\n        var keys = {\n          INSERT: 45,\n          DELETE: 46,\n          BACKSPACE: 8,\n          TAB: 9,\n          ENTER: 13,\n          ESC: 27,\n          LEFT: 37,\n          UP: 38,\n          RIGHT: 39,\n          DOWN: 40,\n          END: 35,\n          HOME: 36,\n          SPACEBAR: 32,\n          PAGEUP: 33,\n          PAGEDOWN: 34,\n          F2: 113,\n          F10: 121,\n          F12: 123,\n          NUMPAD_PLUS: 107,\n          NUMPAD_MINUS: 109,\n          NUMPAD_DOT: 110\n        };\n\n        function autoMajorUnit(min, max) {\n          var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n          if (diff === 0) {\n            if (max === 0) {\n              return 0.1;\n            }\n\n            diff = Math.abs(max);\n          }\n\n          var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n          var relativeValue = round(diff / scale, DEFAULT_PRECISION);\n          var scaleMultiplier = 1;\n\n          if (relativeValue < 1.904762) {\n            scaleMultiplier = 0.2;\n          } else if (relativeValue < 4.761904) {\n            scaleMultiplier = 0.5;\n          } else if (relativeValue < 9.523809) {\n            scaleMultiplier = 1;\n          } else {\n            scaleMultiplier = 2;\n          }\n\n          return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n        }\n\n        var Point = Class.extend({\n          init: function (x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n          },\n          clone: function () {\n            return new Point(this.x, this.y);\n          },\n          equals: function (point) {\n            return point && this.x === point.x && this.y === point.y;\n          },\n          rotate: function (center, degrees) {\n            var theta = rad(degrees);\n            var cosT = Math.cos(theta);\n            var sinT = Math.sin(theta);\n            var cx = center.x;\n            var cy = center.y;\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n            this.x = round(cx + (x - cx) * cosT + (y - cy) * sinT, COORD_PRECISION);\n            this.y = round(cy + (y - cy) * cosT - (x - cx) * sinT, COORD_PRECISION);\n            return this;\n          },\n          multiply: function (a) {\n            this.x *= a;\n            this.y *= a;\n            return this;\n          },\n          distanceTo: function (point) {\n            var dx = this.x - point.x;\n            var dy = this.y - point.y;\n            return Math.sqrt(dx * dx + dy * dy);\n          }\n        });\n\n        Point.onCircle = function (center, angle, radius) {\n          var radians = rad(angle);\n          return new Point(center.x - radius * Math.cos(radians), center.y - radius * Math.sin(radians));\n        };\n\n        var Box = Class.extend({\n          init: function (x1, y1, x2, y2) {\n            this.x1 = x1 || 0;\n            this.y1 = y1 || 0;\n            this.x2 = x2 || 0;\n            this.y2 = y2 || 0;\n          },\n          equals: function (box) {\n            return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;\n          },\n          width: function () {\n            return this.x2 - this.x1;\n          },\n          height: function () {\n            return this.y2 - this.y1;\n          },\n          translate: function (dx, dy) {\n            this.x1 += dx;\n            this.x2 += dx;\n            this.y1 += dy;\n            this.y2 += dy;\n            return this;\n          },\n          move: function (x, y) {\n            var height = this.height();\n            var width = this.width();\n\n            if (defined(x)) {\n              this.x1 = x;\n              this.x2 = this.x1 + width;\n            }\n\n            if (defined(y)) {\n              this.y1 = y;\n              this.y2 = this.y1 + height;\n            }\n\n            return this;\n          },\n          wrap: function (targetBox) {\n            this.x1 = Math.min(this.x1, targetBox.x1);\n            this.y1 = Math.min(this.y1, targetBox.y1);\n            this.x2 = Math.max(this.x2, targetBox.x2);\n            this.y2 = Math.max(this.y2, targetBox.y2);\n            return this;\n          },\n          wrapPoint: function (point) {\n            var arrayPoint = isArray(point);\n            var x = arrayPoint ? point[0] : point.x;\n            var y = arrayPoint ? point[1] : point.y;\n            this.wrap(new Box(x, y, x, y));\n            return this;\n          },\n          snapTo: function (targetBox, axis) {\n            if (axis === X || !axis) {\n              this.x1 = targetBox.x1;\n              this.x2 = targetBox.x2;\n            }\n\n            if (axis === Y || !axis) {\n              this.y1 = targetBox.y1;\n              this.y2 = targetBox.y2;\n            }\n\n            return this;\n          },\n          alignTo: function (targetBox, anchor) {\n            var height = this.height();\n            var width = this.width();\n            var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n            var offset = axis === Y ? height : width;\n\n            if (anchor === CENTER) {\n              var targetCenter = targetBox.center();\n              var center = this.center();\n              this.x1 += targetCenter.x - center.x;\n              this.y1 += targetCenter.y - center.y;\n            } else if (anchor === TOP || anchor === LEFT) {\n              this[axis + 1] = targetBox[axis + 1] - offset;\n            } else {\n              this[axis + 1] = targetBox[axis + 2];\n            }\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n            return this;\n          },\n          shrink: function (dw, dh) {\n            this.x2 -= dw;\n            this.y2 -= dh;\n            return this;\n          },\n          expand: function (dw, dh) {\n            this.shrink(-dw, -dh);\n            return this;\n          },\n          pad: function (padding) {\n            var spacing = getSpacing(padding);\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n            return this;\n          },\n          unpad: function (padding) {\n            var spacing = getSpacing(padding);\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n            return this.pad(spacing);\n          },\n          clone: function () {\n            return new Box(this.x1, this.y1, this.x2, this.y2);\n          },\n          center: function () {\n            return new Point(this.x1 + this.width() / 2, this.y1 + this.height() / 2);\n          },\n          containsPoint: function (point) {\n            return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;\n          },\n          points: function () {\n            return [new Point(this.x1, this.y1), new Point(this.x2, this.y1), new Point(this.x2, this.y2), new Point(this.x1, this.y2)];\n          },\n          getHash: function () {\n            return [this.x1, this.y1, this.x2, this.y2].join(\",\");\n          },\n          overlaps: function (box) {\n            return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n          },\n          rotate: function (rotation) {\n            var width = this.width();\n            var height = this.height();\n            var ref = this.center();\n            var cx = ref.x;\n            var cy = ref.y;\n            var r1 = rotatePoint(0, 0, cx, cy, rotation);\n            var r2 = rotatePoint(width, 0, cx, cy, rotation);\n            var r3 = rotatePoint(width, height, cx, cy, rotation);\n            var r4 = rotatePoint(0, height, cx, cy, rotation);\n            width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n            height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n            return this;\n          },\n          toRect: function () {\n            return new Rect([this.x1, this.y1], [this.width(), this.height()]);\n          },\n          hasSize: function () {\n            return this.width() !== 0 && this.height() !== 0;\n          },\n          align: function (targetBox, axis, alignment) {\n            var c1 = axis + 1;\n            var c2 = axis + 2;\n            var sizeFunc = axis === X ? WIDTH : HEIGHT;\n            var size = this[sizeFunc]();\n\n            if (inArray(alignment, [LEFT, TOP])) {\n              this[c1] = targetBox[c1];\n              this[c2] = this[c1] + size;\n            } else if (inArray(alignment, [RIGHT, BOTTOM])) {\n              this[c2] = targetBox[c2];\n              this[c1] = this[c2] - size;\n            } else if (alignment === CENTER) {\n              this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n              this[c2] = this[c1] + size;\n            }\n          }\n        });\n\n        function rotatePoint(x, y, cx, cy, angle) {\n          var theta = rad(angle);\n          return new Point(cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta), cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta));\n        }\n\n        var Ring = Class.extend({\n          init: function (center, innerRadius, radius, startAngle, angle) {\n            this.center = center;\n            this.innerRadius = innerRadius;\n            this.radius = radius;\n            this.startAngle = startAngle;\n            this.angle = angle;\n          },\n          clone: function () {\n            return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n          },\n          middle: function () {\n            return this.startAngle + this.angle / 2;\n          },\n          setRadius: function (newRadius, innerRadius) {\n            if (innerRadius) {\n              this.innerRadius = newRadius;\n            } else {\n              this.radius = newRadius;\n            }\n\n            return this;\n          },\n          point: function (angle, innerRadius) {\n            var radianAngle = rad(angle);\n            var ax = Math.cos(radianAngle);\n            var ay = Math.sin(radianAngle);\n            var radius = innerRadius ? this.innerRadius : this.radius;\n            var x = round(this.center.x - ax * radius, COORD_PRECISION);\n            var y = round(this.center.y - ay * radius, COORD_PRECISION);\n            return new Point(x, y);\n          },\n          adjacentBox: function (distance, width, height) {\n            var sector = this.clone().expand(distance);\n            var midAndle = sector.middle();\n            var midPoint = sector.point(midAndle);\n            var hw = width / 2;\n            var hh = height / 2;\n            var sa = Math.sin(rad(midAndle));\n            var ca = Math.cos(rad(midAndle));\n            var x = midPoint.x - hw;\n            var y = midPoint.y - hh;\n\n            if (Math.abs(sa) < 0.9) {\n              x += hw * -ca / Math.abs(ca);\n            }\n\n            if (Math.abs(ca) < 0.9) {\n              y += hh * -sa / Math.abs(sa);\n            }\n\n            return new Box(x, y, x + width, y + height);\n          },\n          containsPoint: function (p) {\n            var center = this.center;\n            var innerRadius = this.innerRadius;\n            var radius = this.radius;\n            var startAngle = this.startAngle;\n            var endAngle = this.startAngle + this.angle;\n            var dx = p.x - center.x;\n            var dy = p.y - center.y;\n            var vector = new Point(dx, dy);\n            var startPoint = this.point(startAngle);\n            var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n            var endPoint = this.point(endAngle);\n            var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n            var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n            return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n          },\n          getBBox: function () {\n            var this$1 = this;\n            var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n            var startAngle = round(this.startAngle % 360);\n            var endAngle = round((startAngle + this.angle) % 360);\n            var innerRadius = this.innerRadius;\n            var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n            var startAngleIndex = allAngles.indexOf(startAngle);\n            var endAngleIndex = allAngles.indexOf(endAngle);\n            var angles;\n\n            if (startAngle === endAngle) {\n              angles = allAngles;\n            } else {\n              if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n              } else {\n                angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n              }\n            }\n\n            for (var i = 0; i < angles.length; i++) {\n              var point = this$1.point(angles[i]);\n              box.wrapPoint(point);\n              box.wrapPoint(point, innerRadius);\n            }\n\n            if (!innerRadius) {\n              box.wrapPoint(this.center);\n            }\n\n            return box;\n          },\n          expand: function (value) {\n            this.radius += value;\n            return this;\n          }\n        });\n\n        function numericComparer(a, b) {\n          return a - b;\n        }\n\n        var Sector = Ring.extend({\n          init: function (center, radius, startAngle, angle) {\n            Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\n          },\n          expand: function (value) {\n            return Ring.fn.expand.call(this, value);\n          },\n          clone: function () {\n            return new Sector(this.center, this.radius, this.startAngle, this.angle);\n          },\n          setRadius: function (newRadius) {\n            this.radius = newRadius;\n            return this;\n          }\n        });\n        var DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\n\n        var ShapeBuilder = Class.extend({\n          createRing: function (sector, options) {\n            var startAngle = sector.startAngle + 180;\n            var endAngle = sector.angle + startAngle; //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n\n            if (sector.angle > 0 && startAngle === endAngle) {\n              endAngle += DIRECTION_ANGLE;\n            }\n\n            var center = new geometry.Point(sector.center.x, sector.center.y);\n            var radius = Math.max(sector.radius, 0);\n            var innerRadius = Math.max(sector.innerRadius, 0);\n            var arc = new geometry.Arc(center, {\n              startAngle: startAngle,\n              endAngle: endAngle,\n              radiusX: radius,\n              radiusY: radius\n            });\n            var path = Path.fromArc(arc, options).close();\n\n            if (innerRadius) {\n              arc.radiusX = arc.radiusY = innerRadius;\n              var innerEnd = arc.pointAt(endAngle);\n              path.lineTo(innerEnd.x, innerEnd.y);\n              path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n            } else {\n              path.lineTo(center.x, center.y);\n            }\n\n            return path;\n          }\n        });\n        ShapeBuilder.current = new ShapeBuilder();\n        var ChartElement = Class.extend({\n          init: function (options) {\n            this.children = [];\n            this.options = deepExtend({}, this.options, this.initUserOptions(options));\n          },\n          initUserOptions: function (options) {\n            return options;\n          },\n          reflow: function (targetBox) {\n            var children = this.children;\n            var box;\n\n            for (var i = 0; i < children.length; i++) {\n              var currentChild = children[i];\n              currentChild.reflow(targetBox);\n              box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n            }\n\n            this.box = box || targetBox;\n          },\n          destroy: function () {\n            var children = this.children;\n\n            if (this.animation) {\n              this.animation.destroy();\n            }\n\n            for (var i = 0; i < children.length; i++) {\n              children[i].destroy();\n            }\n          },\n          getRoot: function () {\n            var parent = this.parent;\n            return parent ? parent.getRoot() : null;\n          },\n          getSender: function () {\n            var service = this.getService();\n\n            if (service) {\n              return service.sender;\n            }\n          },\n          getService: function () {\n            var element = this;\n\n            while (element) {\n              if (element.chartService) {\n                return element.chartService;\n              }\n\n              element = element.parent;\n            }\n          },\n          translateChildren: function (dx, dy) {\n            var children = this.children;\n            var childrenCount = children.length;\n\n            for (var i = 0; i < childrenCount; i++) {\n              children[i].box.translate(dx, dy);\n            }\n          },\n          append: function () {\n            var arguments$1 = arguments;\n            var this$1 = this;\n\n            for (var i = 0; i < arguments.length; i++) {\n              var item = arguments$1[i];\n              this$1.children.push(item);\n              item.parent = this$1;\n            }\n          },\n          renderVisual: function () {\n            if (this.options.visible === false) {\n              return;\n            }\n\n            this.createVisual();\n            this.addVisual();\n            this.renderChildren();\n            this.createAnimation();\n            this.renderComplete();\n          },\n          addVisual: function () {\n            if (this.visual) {\n              this.visual.chartElement = this;\n\n              if (this.parent) {\n                this.parent.appendVisual(this.visual);\n              }\n            }\n          },\n          renderChildren: function () {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n              children[i].renderVisual();\n            }\n          },\n          createVisual: function () {\n            this.visual = new Group({\n              zIndex: this.options.zIndex,\n              visible: valueOrDefault(this.options.visible, true)\n            });\n          },\n          createAnimation: function () {\n            if (this.visual && this.options.animation) {\n              this.animation = drawing.Animation.create(this.visual, this.options.animation);\n            }\n          },\n          appendVisual: function (childVisual) {\n            if (!childVisual.chartElement) {\n              childVisual.chartElement = this;\n            }\n\n            if (childVisual.options.noclip) {\n              this.clipRoot().visual.append(childVisual);\n            } else if (defined(childVisual.options.zIndex)) {\n              this.stackRoot().stackVisual(childVisual);\n            } else if (this.isStackRoot) {\n              this.stackVisual(childVisual);\n            } else if (this.visual) {\n              this.visual.append(childVisual);\n            } else {\n              // Allow chart elements without visuals to\n              // pass through child visuals\n              this.parent.appendVisual(childVisual);\n            }\n          },\n          clipRoot: function () {\n            if (this.parent) {\n              return this.parent.clipRoot();\n            }\n\n            return this;\n          },\n          stackRoot: function () {\n            if (this.parent) {\n              return this.parent.stackRoot();\n            }\n\n            return this;\n          },\n          stackVisual: function (childVisual) {\n            var zIndex = childVisual.options.zIndex || 0;\n            var visuals = this.visual.children;\n            var length = visuals.length;\n            var pos;\n\n            for (pos = 0; pos < length; pos++) {\n              var sibling = visuals[pos];\n              var here = valueOrDefault(sibling.options.zIndex, 0);\n\n              if (here > zIndex) {\n                break;\n              }\n            }\n\n            this.visual.insert(pos, childVisual);\n          },\n          traverse: function (callback) {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n              var child = children[i];\n              callback(child);\n\n              if (child.traverse) {\n                child.traverse(callback);\n              }\n            }\n          },\n          closest: function (match) {\n            var element = this;\n            var matched = false;\n\n            while (element && !matched) {\n              matched = match(element);\n\n              if (!matched) {\n                element = element.parent;\n              }\n            }\n\n            if (matched) {\n              return element;\n            }\n          },\n          renderComplete: function () {},\n          hasHighlight: function () {\n            var options = (this.options || {}).highlight;\n            return !(!this.createHighlight || options && options.visible === false);\n          },\n          toggleHighlight: function (show, opacity) {\n            var this$1 = this;\n            var options = (this.options || {}).highlight || {};\n            var customVisual = options.visual;\n            var highlight = this._highlight;\n\n            if (!highlight) {\n              var highlightOptions = {\n                fill: {\n                  color: WHITE,\n                  opacity: opacity || 0.2\n                },\n                stroke: {\n                  color: WHITE,\n                  width: 1,\n                  opacity: opacity || 0.2\n                }\n              };\n\n              if (customVisual) {\n                highlight = this._highlight = customVisual($.extend(this.highlightVisualArgs(), {\n                  createVisual: function () {\n                    return this$1.createHighlight(highlightOptions);\n                  },\n                  sender: this.getSender(),\n                  series: this.series,\n                  dataItem: this.dataItem,\n                  category: this.category,\n                  value: this.value,\n                  percentage: this.percentage,\n                  runningTotal: this.runningTotal,\n                  total: this.total\n                }));\n\n                if (!highlight) {\n                  return;\n                }\n              } else {\n                highlight = this._highlight = this.createHighlight(highlightOptions);\n              }\n\n              if (!defined(highlight.options.zIndex)) {\n                highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n              }\n\n              this.appendVisual(highlight);\n            }\n\n            highlight.visible(show);\n          },\n          createGradientOverlay: function (element, options, gradientOptions) {\n            var overlay = new Path($.extend({\n              stroke: {\n                color: \"none\"\n              },\n              fill: this.createGradient(gradientOptions),\n              closed: element.options.closed\n            }, options));\n            overlay.segments.elements(element.segments.elements());\n            return overlay;\n          },\n          createGradient: function (options) {\n            if (this.parent) {\n              return this.parent.createGradient(options);\n            }\n          },\n          supportsPointInactiveOpacity: function () {\n            return true;\n          }\n        });\n        ChartElement.prototype.options = {};\n        var BoxElement = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n            this.options.margin = getSpacing(this.options.margin);\n            this.options.padding = getSpacing(this.options.padding);\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var shrinkToFit = options.shrinkToFit;\n            var hasSetSize = width && height;\n            var margin = options.margin;\n            var padding = options.padding;\n            var borderWidth = options.border.width;\n            var box;\n\n            var reflowPaddingBox = function () {\n              this$1.align(targetBox, X, options.align);\n              this$1.align(targetBox, Y, options.vAlign);\n              this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n            };\n\n            var contentBox = targetBox.clone();\n\n            if (hasSetSize) {\n              contentBox.x2 = contentBox.x1 + width;\n              contentBox.y2 = contentBox.y1 + height;\n            }\n\n            if (shrinkToFit) {\n              contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n            }\n\n            ChartElement.fn.reflow.call(this, contentBox);\n\n            if (hasSetSize) {\n              box = this.box = new Box(0, 0, width, height);\n            } else {\n              box = this.box;\n            }\n\n            if (shrinkToFit && hasSetSize) {\n              reflowPaddingBox();\n              contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n            } else {\n              contentBox = this.contentBox = box.clone();\n              box.pad(padding).pad(borderWidth).pad(margin);\n              reflowPaddingBox();\n            }\n\n            this.translateChildren(box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left, box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top);\n            var children = this.children;\n\n            for (var i = 0; i < children.length; i++) {\n              var item = children[i];\n              item.reflow(item.box);\n            }\n          },\n          align: function (targetBox, axis, alignment) {\n            this.box.align(targetBox, axis, alignment);\n          },\n          hasBox: function () {\n            var options = this.options;\n            return options.border.width || options.background;\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            var options = this.options;\n\n            if (options.visible && this.hasBox()) {\n              this.visual.append(Path.fromRect(this.paddingBox.toRect(), this.visualStyle()));\n            }\n          },\n          visualStyle: function () {\n            var options = this.options;\n            var border = options.border || {};\n            return {\n              stroke: {\n                width: border.width,\n                color: border.color,\n                opacity: valueOrDefault(border.opacity, options.opacity),\n                dashType: border.dashType\n              },\n              fill: {\n                color: options.background,\n                opacity: options.opacity\n              },\n              cursor: options.cursor\n            };\n          }\n        });\n        setDefaultOptions(BoxElement, {\n          align: LEFT,\n          vAlign: TOP,\n          margin: {},\n          padding: {},\n          border: {\n            color: BLACK,\n            width: 0\n          },\n          background: \"\",\n          shrinkToFit: false,\n          width: 0,\n          height: 0,\n          visible: true\n        });\n        var ShapeElement = BoxElement.extend({\n          init: function (options, pointData) {\n            BoxElement.fn.init.call(this, options);\n            this.pointData = pointData;\n          },\n          getElement: function () {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.paddingBox;\n            var type = options.type;\n            var rotation = options.rotation;\n            var center = box.center();\n            var halfWidth = box.width() / 2;\n            var halfHeight = box.height() / 2;\n\n            if (!options.visible || !this.hasBox()) {\n              return null;\n            }\n\n            var style = this.visualStyle();\n            var element;\n\n            if (type === CIRCLE) {\n              element = new drawing.Circle(new Circle([round(box.x1 + halfWidth, COORD_PRECISION), round(box.y1 + halfHeight, COORD_PRECISION)], Math.min(halfWidth, halfHeight)), style);\n            } else if (type === TRIANGLE) {\n              element = Path.fromPoints([[box.x1 + halfWidth, box.y1], [box.x1, box.y2], [box.x2, box.y2]], style).close();\n            } else if (type === CROSS) {\n              element = new drawing.MultiPath(style);\n              element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n              element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n            } else {\n              var rect = box.toRect();\n\n              if (type === ROUNDED_RECT) {\n                var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);\n                rect.setCornerRadius(borderRadius);\n              }\n\n              element = Path.fromRect(rect, style);\n            }\n\n            if (rotation) {\n              element.transform(geometryTransform().rotate(-rotation, [center.x, center.y]));\n            }\n\n            element.options.zIndex = options.zIndex;\n            return element;\n          },\n          createElement: function () {\n            var this$1 = this;\n            var customVisual = this.options.visual;\n            var pointData = this.pointData || {};\n            var visual;\n\n            if (customVisual) {\n              visual = customVisual({\n                value: pointData.value,\n                dataItem: pointData.dataItem,\n                sender: this.getSender(),\n                series: pointData.series,\n                category: pointData.category,\n                rect: this.paddingBox.toRect(),\n                options: this.visualOptions(),\n                createVisual: function () {\n                  return this$1.getElement();\n                }\n              });\n            } else {\n              visual = this.getElement();\n            }\n\n            return visual;\n          },\n          visualOptions: function () {\n            var options = this.options;\n            return {\n              background: options.background,\n              border: options.border,\n              margin: options.margin,\n              padding: options.padding,\n              type: options.type,\n              size: options.width,\n              visible: options.visible\n            };\n          },\n          createVisual: function () {\n            this.visual = this.createElement();\n          }\n        });\n        setDefaultOptions(ShapeElement, {\n          type: CIRCLE,\n          align: CENTER,\n          vAlign: CENTER\n        });\n        var LINEAR = \"linear\";\n        var RADIAL = \"radial\";\n        var GRADIENTS = {\n          glass: {\n            type: LINEAR,\n            rotation: 0,\n            stops: [{\n              offset: 0,\n              color: WHITE,\n              opacity: 0\n            }, {\n              offset: 0.25,\n              color: WHITE,\n              opacity: 0.3\n            }, {\n              offset: 1,\n              color: WHITE,\n              opacity: 0\n            }]\n          },\n          sharpBevel: {\n            type: RADIAL,\n            stops: [{\n              offset: 0,\n              color: WHITE,\n              opacity: 0.55\n            }, {\n              offset: 0.65,\n              color: WHITE,\n              opacity: 0\n            }, {\n              offset: 0.95,\n              color: WHITE,\n              opacity: 0.25\n            }]\n          },\n          roundedBevel: {\n            type: RADIAL,\n            stops: [{\n              offset: 0.33,\n              color: WHITE,\n              opacity: 0.06\n            }, {\n              offset: 0.83,\n              color: WHITE,\n              opacity: 0.2\n            }, {\n              offset: 0.95,\n              color: WHITE,\n              opacity: 0\n            }]\n          },\n          roundedGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [{\n              offset: 0,\n              color: WHITE,\n              opacity: 0\n            }, {\n              offset: 0.5,\n              color: WHITE,\n              opacity: 0.3\n            }, {\n              offset: 0.99,\n              color: WHITE,\n              opacity: 0\n            }]\n          },\n          sharpGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [{\n              offset: 0,\n              color: WHITE,\n              opacity: 0.2\n            }, {\n              offset: 0.15,\n              color: WHITE,\n              opacity: 0.15\n            }, {\n              offset: 0.17,\n              color: WHITE,\n              opacity: 0.35\n            }, {\n              offset: 0.85,\n              color: WHITE,\n              opacity: 0.05\n            }, {\n              offset: 0.87,\n              color: WHITE,\n              opacity: 0.15\n            }, {\n              offset: 0.99,\n              color: WHITE,\n              opacity: 0\n            }]\n          },\n          bubbleShadow: {\n            type: RADIAL,\n            center: [0.5, 0.5],\n            radius: 0.5\n          }\n        };\n\n        function boxDiff(r, s) {\n          if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n            return s;\n          }\n\n          var a = Math.min(r.x1, s.x1);\n          var b = Math.max(r.x1, s.x1);\n          var c = Math.min(r.x2, s.x2);\n          var d = Math.max(r.x2, s.x2);\n          var e = Math.min(r.y1, s.y1);\n          var f = Math.max(r.y1, s.y1);\n          var g = Math.min(r.y2, s.y2);\n          var h = Math.max(r.y2, s.y2);\n          var boxes = []; // X = intersection, 0-7 = possible difference areas\n          // h +-+-+-+\n          // . |5|6|7|\n          // g +-+-+-+\n          // . |3|X|4|\n          // f +-+-+-+\n          // . |0|1|2|\n          // e +-+-+-+\n          // . a b c d\n          // we'll always have rectangles 1, 3, 4 and 6\n\n          boxes[0] = new Box(b, e, c, f);\n          boxes[1] = new Box(a, f, b, g);\n          boxes[2] = new Box(c, f, d, g);\n          boxes[3] = new Box(b, g, c, h); // decide which corners\n\n          if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) {\n            // corners 0 and 7\n            boxes[4] = new Box(a, e, b, f);\n            boxes[5] = new Box(c, g, d, h);\n          } else {\n            // corners 2 and 5\n            boxes[4] = new Box(c, e, d, f);\n            boxes[5] = new Box(a, g, b, h);\n          }\n\n          return grep(boxes, function (box) {\n            return box.height() > 0 && box.width() > 0;\n          })[0];\n        }\n\n        var RootElement = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n            var rootOptions = this.options;\n            rootOptions.width = parseInt(rootOptions.width, 10);\n            rootOptions.height = parseInt(rootOptions.height, 10);\n            this.gradients = {};\n          },\n          reflow: function () {\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var currentBox = new Box(0, 0, options.width, options.height);\n            this.box = currentBox.unpad(options.margin);\n\n            for (var i = 0; i < children.length; i++) {\n              children[i].reflow(currentBox);\n              currentBox = boxDiff(currentBox, children[i].box) || new Box();\n            }\n          },\n          createVisual: function () {\n            this.visual = new Group();\n            this.createBackground();\n          },\n          createBackground: function () {\n            var options = this.options;\n            var border = options.border || {};\n            var box = this.box.clone().pad(options.margin).unpad(border.width);\n            var background = Path.fromRect(box.toRect(), {\n              stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n              },\n              fill: {\n                color: options.background,\n                opacity: options.opacity\n              },\n              zIndex: -10\n            });\n            this.visual.append(background);\n          },\n          getRoot: function () {\n            return this;\n          },\n          createGradient: function (options) {\n            var gradients = this.gradients;\n            var hashCode = objectKey(options);\n            var gradient = GRADIENTS[options.gradient];\n            var drawingGradient;\n\n            if (gradients[hashCode]) {\n              drawingGradient = gradients[hashCode];\n            } else {\n              var gradientOptions = $.extend({}, gradient, options);\n\n              if (gradient.type === \"linear\") {\n                drawingGradient = new drawing.LinearGradient(gradientOptions);\n              } else {\n                if (options.innerRadius) {\n                  gradientOptions.stops = innerRadialStops(gradientOptions);\n                }\n\n                drawingGradient = new drawing.RadialGradient(gradientOptions);\n                drawingGradient.supportVML = gradient.supportVML !== false;\n              }\n\n              gradients[hashCode] = drawingGradient;\n            }\n\n            return drawingGradient;\n          },\n          cleanGradients: function () {\n            var gradients = this.gradients;\n\n            for (var hashCode in gradients) {\n              gradients[hashCode]._observers = []; //add clear observers method in drawing ObserversMixin\n            }\n          },\n          size: function () {\n            var options = this.options;\n            return new Box(0, 0, options.width, options.height);\n          }\n        });\n        setDefaultOptions(RootElement, {\n          width: DEFAULT_WIDTH,\n          height: DEFAULT_HEIGHT,\n          background: WHITE,\n          border: {\n            color: BLACK,\n            width: 0\n          },\n          margin: getSpacing(5),\n          zIndex: -2\n        });\n\n        function innerRadialStops(options) {\n          var stops = options.stops;\n          var usedSpace = options.innerRadius / options.radius * 100;\n          var length = stops.length;\n          var currentStops = [];\n\n          for (var i = 0; i < length; i++) {\n            var currentStop = $.extend({}, stops[i]);\n            currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n            currentStops.push(currentStop);\n          }\n\n          return currentStops;\n        }\n\n        var FloatElement = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n\n            this._initDirection();\n          },\n          _initDirection: function () {\n            var options = this.options;\n\n            if (options.vertical) {\n              this.groupAxis = X;\n              this.elementAxis = Y;\n              this.groupSizeField = WIDTH;\n              this.elementSizeField = HEIGHT;\n              this.groupSpacing = options.spacing;\n              this.elementSpacing = options.vSpacing;\n            } else {\n              this.groupAxis = Y;\n              this.elementAxis = X;\n              this.groupSizeField = HEIGHT;\n              this.elementSizeField = WIDTH;\n              this.groupSpacing = options.vSpacing;\n              this.elementSpacing = options.spacing;\n            }\n          },\n          reflow: function (targetBox) {\n            this.box = targetBox.clone();\n            this.reflowChildren();\n          },\n          reflowChildren: function () {\n            var this$1 = this;\n            var ref = this;\n            var box = ref.box;\n            var elementAxis = ref.elementAxis;\n            var groupAxis = ref.groupAxis;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var ref$1 = this.groupOptions();\n            var groups = ref$1.groups;\n            var groupsSize = ref$1.groupsSize;\n            var maxGroupElementsSize = ref$1.maxGroupElementsSize;\n            var groupsCount = groups.length;\n            var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n            if (groupsCount) {\n              var groupStart = groupsStart;\n\n              for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                var group = groups[groupIdx];\n                var groupElements = group.groupElements;\n                var elementStart = box[elementAxis + 1];\n                var groupElementsCount = groupElements.length;\n\n                for (var idx = 0; idx < groupElementsCount; idx++) {\n                  var element = groupElements[idx];\n                  var elementSize$$1 = this$1.elementSize(element);\n                  var groupElementStart = groupStart + this$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\n                  var elementBox = new Box();\n                  elementBox[groupAxis + 1] = groupElementStart;\n                  elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\n                  elementBox[elementAxis + 1] = elementStart;\n                  elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\n                  element.reflow(elementBox);\n                  elementStart += elementSize$$1[elementSizeField] + this$1.elementSpacing;\n                }\n\n                groupStart += group.groupSize + this$1.groupSpacing;\n              }\n\n              box[groupAxis + 1] = groupsStart;\n              box[groupAxis + 2] = groupsStart + groupsSize;\n              box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n            }\n          },\n          alignStart: function (size, maxSize) {\n            var start = 0;\n            var align = this.options.align;\n\n            if (align === RIGHT || align === BOTTOM) {\n              start = maxSize - size;\n            } else if (align === CENTER) {\n              start = (maxSize - size) / 2;\n            }\n\n            return start;\n          },\n          groupOptions: function () {\n            var this$1 = this;\n            var ref = this;\n            var box = ref.box;\n            var children = ref.children;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var elementSpacing = ref.elementSpacing;\n            var groupSpacing = ref.groupSpacing;\n            var maxSize = round(box[elementSizeField]());\n            var childrenCount = children.length;\n            var groups = [];\n            var groupSize = 0;\n            var groupElementsSize = 0;\n            var groupsSize = 0;\n            var maxGroupElementsSize = 0;\n            var groupElements = [];\n\n            for (var idx = 0; idx < childrenCount; idx++) {\n              var element = children[idx];\n\n              if (!element.box) {\n                element.reflow(box);\n              }\n\n              var elementSize$$1 = this$1.elementSize(element);\n\n              if (this$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\n                groups.push({\n                  groupElements: groupElements,\n                  groupSize: groupSize,\n                  groupElementsSize: groupElementsSize\n                });\n                maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n                groupsSize += groupSpacing + groupSize;\n                groupSize = 0;\n                groupElementsSize = 0;\n                groupElements = [];\n              }\n\n              groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\n\n              if (groupElementsSize > 0) {\n                groupElementsSize += elementSpacing;\n              }\n\n              groupElementsSize += elementSize$$1[elementSizeField];\n              groupElements.push(element);\n            }\n\n            groups.push({\n              groupElements: groupElements,\n              groupSize: groupSize,\n              groupElementsSize: groupElementsSize\n            });\n            maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n            groupsSize += groupSize;\n            return {\n              groups: groups,\n              groupsSize: groupsSize,\n              maxGroupElementsSize: maxGroupElementsSize\n            };\n          },\n          elementSize: function (element) {\n            return {\n              width: element.box.width(),\n              height: element.box.height()\n            };\n          },\n          createVisual: function () {}\n        });\n        setDefaultOptions(FloatElement, {\n          vertical: true,\n          wrap: true,\n          vSpacing: 0,\n          spacing: 0\n        });\n        var DrawingText = drawing.Text;\n        var Text = ChartElement.extend({\n          init: function (content, options) {\n            ChartElement.fn.init.call(this, options);\n            this.content = content; // Calculate size\n\n            this.reflow(new Box());\n          },\n          reflow: function (targetBox) {\n            var options = this.options;\n            var size = options.size = util.measureText(this.content, {\n              font: options.font\n            });\n            this.baseline = size.baseline;\n            this.box = new Box(targetBox.x1, targetBox.y1, targetBox.x1 + size.width, targetBox.y1 + size.height);\n          },\n          createVisual: function () {\n            var ref = this.options;\n            var font = ref.font;\n            var color = ref.color;\n            var opacity = ref.opacity;\n            var cursor = ref.cursor;\n            this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n              font: font,\n              fill: {\n                color: color,\n                opacity: opacity\n              },\n              cursor: cursor\n            });\n          }\n        });\n        setDefaultOptions(Text, {\n          font: DEFAULT_FONT,\n          color: BLACK\n        });\n\n        function rectToBox(rect) {\n          var origin = rect.origin;\n          var bottomRight = rect.bottomRight();\n          return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n        }\n\n        var ROWS_SPLIT_REGEX = /\\n/m;\n        var TextBox = BoxElement.extend({\n          init: function (content, options, data) {\n            BoxElement.fn.init.call(this, options);\n            this.content = content;\n            this.data = data;\n\n            this._initContainer();\n\n            if (this.options._autoReflow !== false) {\n              this.reflow(new Box());\n            }\n          },\n          _initContainer: function () {\n            var options = this.options;\n            var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n            var floatElement = new FloatElement({\n              vertical: true,\n              align: options.align,\n              wrap: false\n            });\n            var textOptions = deepExtend({}, options, {\n              opacity: 1,\n              animation: null\n            });\n            this.container = floatElement;\n            this.append(floatElement);\n\n            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n              var text = new Text(rows[rowIdx].trim(), textOptions);\n              floatElement.append(text);\n            }\n          },\n          reflow: function (targetBox) {\n            var options = this.options;\n            var visualFn = options.visual;\n            this.container.options.align = options.align;\n\n            if (visualFn && !this._boxReflow) {\n              var visualBox = targetBox;\n\n              if (!visualBox.hasSize()) {\n                this._boxReflow = true;\n                this.reflow(visualBox);\n                this._boxReflow = false;\n                visualBox = this.box;\n              }\n\n              var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n              if (visual) {\n                visualBox = rectToBox(visual.clippedBBox() || new Rect());\n                visual.options.zIndex = options.zIndex;\n              }\n\n              this.box = this.contentBox = this.paddingBox = visualBox;\n            } else {\n              BoxElement.fn.reflow.call(this, targetBox);\n\n              if (options.rotation) {\n                var margin = getSpacing(options.margin);\n                var box = this.box.unpad(margin);\n                this.targetBox = targetBox;\n                this.normalBox = box.clone();\n                box = this.rotate();\n                box.translate(margin.left - margin.right, margin.top - margin.bottom);\n                this.rotatedBox = box.clone();\n                box.pad(margin);\n              }\n            }\n          },\n          createVisual: function () {\n            var options = this.options;\n            this.visual = new Group({\n              transform: this.rotationTransform(),\n              zIndex: options.zIndex,\n              noclip: options.noclip\n            });\n\n            if (this.hasBox()) {\n              var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n              this.visual.append(box);\n            }\n          },\n          renderVisual: function () {\n            if (!this.options.visible) {\n              return;\n            }\n\n            if (this.options.visual) {\n              var visual = this.visual;\n\n              if (visual && !defined(visual.options.noclip)) {\n                visual.options.noclip = this.options.noclip;\n              }\n\n              this.addVisual();\n              this.createAnimation();\n            } else {\n              BoxElement.fn.renderVisual.call(this);\n            }\n          },\n          visualContext: function (targetBox) {\n            var this$1 = this;\n            var context = {\n              text: this.content,\n              rect: targetBox.toRect(),\n              sender: this.getSender(),\n              options: this.options,\n              createVisual: function () {\n                this$1._boxReflow = true;\n                this$1.reflow(targetBox);\n                this$1._boxReflow = false;\n                return this$1.getDefaultVisual();\n              }\n            };\n\n            if (this.data) {\n              $.extend(context, this.data);\n            }\n\n            return context;\n          },\n          getDefaultVisual: function () {\n            this.createVisual();\n            this.renderChildren();\n            var visual = this.visual;\n            delete this.visual;\n            return visual;\n          },\n          rotate: function () {\n            var options = this.options;\n            this.box.rotate(options.rotation);\n            this.align(this.targetBox, X, options.align);\n            this.align(this.targetBox, Y, options.vAlign);\n            return this.box;\n          },\n          rotationTransform: function () {\n            var rotation = this.options.rotation;\n\n            if (!rotation) {\n              return null;\n            }\n\n            var ref = this.normalBox.center();\n            var cx = ref.x;\n            var cy = ref.y;\n            var boxCenter = this.rotatedBox.center();\n            return geometryTransform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);\n          }\n        });\n        var Title = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n            this.append(new TextBox(this.options.text, $.extend({}, this.options, {\n              vAlign: this.options.position\n            })));\n          },\n          reflow: function (targetBox) {\n            ChartElement.fn.reflow.call(this, targetBox);\n            this.box.snapTo(targetBox, X);\n          }\n        });\n\n        Title.buildTitle = function (options, parent, defaultOptions) {\n          var titleOptions = options;\n\n          if (typeof options === \"string\") {\n            titleOptions = {\n              text: options\n            };\n          }\n\n          titleOptions = $.extend({\n            visible: true\n          }, defaultOptions, titleOptions);\n          var title;\n\n          if (titleOptions && titleOptions.visible && titleOptions.text) {\n            title = new Title(titleOptions);\n            parent.append(title);\n          }\n\n          return title;\n        };\n\n        setDefaultOptions(Title, {\n          color: BLACK,\n          position: TOP,\n          align: CENTER,\n          margin: getSpacing(5),\n          padding: getSpacing(5)\n        });\n        var AxisLabel = TextBox.extend({\n          init: function (value, text, index, dataItem, options) {\n            TextBox.fn.init.call(this, text, options);\n            this.text = text;\n            this.value = value;\n            this.index = index;\n            this.dataItem = dataItem;\n            this.reflow(new Box());\n          },\n          visualContext: function (targetBox) {\n            var context = TextBox.fn.visualContext.call(this, targetBox);\n            context.value = this.value;\n            context.dataItem = this.dataItem;\n            context.format = this.options.format;\n            context.culture = this.options.culture;\n            return context;\n          },\n          click: function (widget, e) {\n            widget.trigger(AXIS_LABEL_CLICK, {\n              element: eventElement(e),\n              value: this.value,\n              text: this.text,\n              index: this.index,\n              dataItem: this.dataItem,\n              axis: this.parent.options\n            });\n          },\n          rotate: function () {\n            if (this.options.alignRotation !== CENTER) {\n              var box = this.normalBox.toRect();\n              var transform = this.rotationTransform();\n              this.box = rectToBox(box.bbox(transform.matrix()));\n            } else {\n              TextBox.fn.rotate.call(this);\n            }\n\n            return this.box;\n          },\n          rotationTransform: function () {\n            var options = this.options;\n            var rotation = options.rotation;\n\n            if (!rotation) {\n              return null;\n            }\n\n            if (options.alignRotation === CENTER) {\n              return TextBox.fn.rotationTransform.call(this);\n            }\n\n            var rotationMatrix = geometryTransform().rotate(rotation).matrix();\n            var box = this.normalBox.toRect();\n            var rect = this.targetBox.toRect();\n            var rotationOrigin = options.rotationOrigin || TOP;\n            var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n            var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n            var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n            var topLeft = box.topLeft().transformCopy(rotationMatrix);\n            var topRight = box.topRight().transformCopy(rotationMatrix);\n            var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n            var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n            var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n            var translate = {};\n            translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\n            var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n            var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n            var alignStart, alignEnd;\n\n            if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n              alignStart = topLeft;\n              alignEnd = topRight;\n            } else if (distanceRight < distanceLeft) {\n              alignStart = topRight;\n              alignEnd = bottomRight;\n            } else {\n              alignStart = topLeft;\n              alignEnd = bottomLeft;\n            }\n\n            var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n            translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n            return geometryTransform().translate(translate.x, translate.y).rotate(rotation);\n          }\n        });\n        setDefaultOptions(AxisLabel, {\n          _autoReflow: false\n        });\n        var DEFAULT_ICON_SIZE = 7;\n        var DEFAULT_LABEL_COLOR = \"#fff\";\n        var Note = BoxElement.extend({\n          init: function (fields, options, chartService) {\n            BoxElement.fn.init.call(this, options);\n            this.fields = fields;\n            this.chartService = chartService;\n            this.render();\n          },\n          hide: function () {\n            this.options.visible = false;\n          },\n          show: function () {\n            this.options.visible = true;\n          },\n          render: function () {\n            var this$1 = this;\n            var options = this.options;\n\n            if (options.visible) {\n              var label = options.label;\n              var icon = options.icon;\n              var box = new Box();\n\n              var childAlias = function () {\n                return this$1;\n              };\n\n              var size = icon.size;\n              var text = this.fields.text;\n              var width, height;\n\n              if (defined(label) && label.visible) {\n                var noteTemplate = getTemplate(label);\n\n                if (noteTemplate) {\n                  text = noteTemplate(this.fields);\n                } else if (label.format) {\n                  text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                  label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                }\n\n                this.label = new TextBox(text, deepExtend({}, label));\n                this.label.aliasFor = childAlias;\n\n                if (label.position === INSIDE && !defined(size)) {\n                  if (icon.type === CIRCLE) {\n                    size = Math.max(this.label.box.width(), this.label.box.height());\n                  } else {\n                    width = this.label.box.width();\n                    height = this.label.box.height();\n                  }\n\n                  box.wrap(this.label.box);\n                }\n              }\n\n              icon.width = width || size || DEFAULT_ICON_SIZE;\n              icon.height = height || size || DEFAULT_ICON_SIZE;\n              var marker = new ShapeElement(deepExtend({}, icon));\n              marker.aliasFor = childAlias;\n              this.marker = marker;\n              this.append(marker);\n\n              if (this.label) {\n                this.append(this.label);\n              }\n\n              marker.reflow(new Box());\n              this.wrapperBox = box.wrap(marker.box);\n            }\n          },\n          reflow: function (targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var label = ref.label;\n            var marker = ref.marker;\n            var wrapperBox = ref.wrapperBox;\n            var center = targetBox.center();\n            var length = options.line.length;\n            var position = options.position; // TODO: Review\n\n            if (options.visible) {\n              var lineStart, box, contentBox;\n\n              if (inArray(position, [LEFT, RIGHT])) {\n                if (position === LEFT) {\n                  contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                  if (options.line.visible) {\n                    lineStart = [targetBox.x1, center.y];\n                    this.linePoints = [lineStart, [contentBox.x2, center.y]];\n                    box = contentBox.clone().wrapPoint(lineStart);\n                  }\n                } else {\n                  contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                  if (options.line.visible) {\n                    lineStart = [targetBox.x2, center.y];\n                    this.linePoints = [lineStart, [contentBox.x1, center.y]];\n                    box = contentBox.clone().wrapPoint(lineStart);\n                  }\n                }\n              } else {\n                if (position === BOTTOM) {\n                  contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                  if (options.line.visible) {\n                    lineStart = [center.x, targetBox.y2];\n                    this.linePoints = [lineStart, [center.x, contentBox.y1]];\n                    box = contentBox.clone().wrapPoint(lineStart);\n                  }\n                } else {\n                  contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                  if (options.line.visible) {\n                    lineStart = [center.x, targetBox.y1];\n                    this.linePoints = [lineStart, [center.x, contentBox.y2]];\n                    box = contentBox.clone().wrapPoint(lineStart);\n                  }\n                }\n              }\n\n              if (marker) {\n                marker.reflow(contentBox);\n              }\n\n              if (label) {\n                label.reflow(contentBox);\n\n                if (marker) {\n                  if (options.label.position === OUTSIDE) {\n                    label.box.alignTo(marker.box, position);\n                  }\n\n                  label.reflow(label.box);\n                }\n              }\n\n              this.contentBox = contentBox;\n              this.targetBox = targetBox;\n              this.box = box || contentBox;\n            }\n          },\n          createVisual: function () {\n            BoxElement.fn.createVisual.call(this);\n            this.visual.options.noclip = this.options.noclip;\n\n            if (this.options.visible) {\n              this.createLine();\n            }\n          },\n          renderVisual: function () {\n            var this$1 = this;\n            var options = this.options;\n            var customVisual = options.visual;\n\n            if (options.visible && customVisual) {\n              this.visual = customVisual($.extend(this.fields, {\n                sender: this.getSender(),\n                rect: this.targetBox.toRect(),\n                options: {\n                  background: options.background,\n                  border: options.background,\n                  icon: options.icon,\n                  label: options.label,\n                  line: options.line,\n                  position: options.position,\n                  visible: options.visible\n                },\n                createVisual: function () {\n                  this$1.createVisual();\n                  this$1.renderChildren();\n                  var defaultVisual = this$1.visual;\n                  delete this$1.visual;\n                  return defaultVisual;\n                }\n              }));\n              this.addVisual();\n            } else {\n              BoxElement.fn.renderVisual.call(this);\n            }\n          },\n          createLine: function () {\n            var options = this.options.line;\n\n            if (this.linePoints) {\n              var path = Path.fromPoints(this.linePoints, {\n                stroke: {\n                  color: options.color,\n                  width: options.width,\n                  dashType: options.dashType\n                }\n              });\n              alignPathToPixel(path);\n              this.visual.append(path);\n            }\n          },\n          click: function (widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_CLICK, args)) {\n              e.preventDefault();\n            }\n          },\n          over: function (widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_HOVER, args)) {\n              e.preventDefault();\n            }\n          },\n          out: function (widget, e) {\n            var args = this.eventArgs(e);\n            widget.trigger(NOTE_LEAVE, args);\n          },\n          eventArgs: function (e) {\n            var options = this.options;\n            return $.extend(this.fields, {\n              element: eventElement(e),\n              text: defined(options.label) ? options.label.text : \"\",\n              visual: this.visual\n            });\n          }\n        });\n        setDefaultOptions(Note, {\n          icon: {\n            visible: true,\n            type: CIRCLE\n          },\n          label: {\n            position: INSIDE,\n            visible: true,\n            align: CENTER,\n            vAlign: CENTER\n          },\n          line: {\n            visible: true\n          },\n          visible: true,\n          position: TOP,\n          zIndex: 2\n        });\n        var defaultImplementation = {\n          format: function (format, value) {\n            return value;\n          },\n          toString: function (value) {\n            return value;\n          },\n          parseDate: function (value) {\n            return new Date(value);\n          },\n          firstDay: function () {\n            return 0;\n          }\n        };\n        var current$1 = defaultImplementation;\n        var IntlService = Class.extend({});\n\n        IntlService.register = function (userImplementation) {\n          current$1 = userImplementation;\n        };\n\n        if (Object.defineProperties) {\n          Object.defineProperties(IntlService, {\n            implementation: {\n              get: function () {\n                return current$1;\n              }\n            }\n          });\n        }\n\n        var FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n        var FormatService = Class.extend({\n          init: function (intlService) {\n            this._intlService = intlService;\n          },\n          auto: function (formatString) {\n            var values = [],\n                len = arguments.length - 1;\n\n            while (len-- > 0) values[len] = arguments[len + 1];\n\n            var intl = this.intl;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n              return intl.format.apply(intl, [formatString].concat(values));\n            }\n\n            return intl.toString(values[0], formatString);\n          },\n          localeAuto: function (formatString, values, locale) {\n            var intl = this.intl;\n            var result;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n              result = formatString.replace(FORMAT_REPLACE_REGEX, function (match, index, placeholderFormat) {\n                var value = values[parseInt(index, 10)];\n                return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\n              });\n            } else {\n              result = intl.toString(values[0], formatString, locale);\n            }\n\n            return result;\n          }\n        });\n\n        if (Object.defineProperties) {\n          Object.defineProperties(FormatService.fn, {\n            intl: {\n              get: function () {\n                return this._intlService || IntlService.implementation;\n              },\n              set: function (value) {\n                this._intlService = value;\n              }\n            }\n          });\n        }\n\n        var ChartService = Class.extend({\n          init: function (chart, context) {\n            if (context === void 0) {\n              context = {};\n            }\n\n            this._intlService = context.intlService;\n            this.sender = context.sender || chart;\n            this.format = new FormatService(context.intlService);\n            this.chart = chart;\n            this.rtl = Boolean(context.rtl);\n          },\n          notify: function (name, args) {\n            if (this.chart) {\n              this.chart.trigger(name, args);\n            }\n          },\n          isPannable: function (axis) {\n            var pannable = ((this.chart || {}).options || {}).pannable;\n            return pannable && pannable.lock !== axis;\n          }\n        });\n\n        if (Object.defineProperties) {\n          Object.defineProperties(ChartService.fn, {\n            intl: {\n              get: function () {\n                return this._intlService || IntlService.implementation;\n              },\n              set: function (value) {\n                this._intlService = value;\n                this.format.intl = value;\n              }\n            }\n          });\n        }\n\n        var current$2;\n        var DomEventsBuilder = Class.extend({});\n\n        DomEventsBuilder.register = function (userImplementation) {\n          current$2 = userImplementation;\n        };\n\n        DomEventsBuilder.create = function (element, events) {\n          if (current$2) {\n            return current$2.create(element, events);\n          }\n        };\n\n        var services = {\n          ChartService: ChartService,\n          DomEventsBuilder: DomEventsBuilder,\n          FormatService: FormatService,\n          IntlService: IntlService,\n          TemplateService: TemplateService\n        };\n\n        function createAxisTick(options, tickOptions) {\n          var tickX = options.tickX;\n          var tickY = options.tickY;\n          var position = options.position;\n          var tick = new Path({\n            stroke: {\n              width: tickOptions.width,\n              color: tickOptions.color\n            }\n          });\n\n          if (options.vertical) {\n            tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);\n          } else {\n            tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);\n          }\n\n          alignPathToPixel(tick);\n          return tick;\n        }\n\n        function createAxisGridLine(options, gridLine) {\n          var lineStart = options.lineStart;\n          var lineEnd = options.lineEnd;\n          var position = options.position;\n          var line = new Path({\n            stroke: {\n              width: gridLine.width,\n              color: gridLine.color,\n              dashType: gridLine.dashType\n            }\n          });\n\n          if (options.vertical) {\n            line.moveTo(lineStart, position).lineTo(lineEnd, position);\n          } else {\n            line.moveTo(position, lineStart).lineTo(position, lineEnd);\n          }\n\n          alignPathToPixel(line);\n          return line;\n        }\n\n        var Axis = ChartElement.extend({\n          init: function (options, chartService) {\n            if (chartService === void 0) {\n              chartService = new ChartService();\n            }\n\n            ChartElement.fn.init.call(this, options);\n            this.chartService = chartService;\n\n            if (!this.options.visible) {\n              this.options = deepExtend({}, this.options, {\n                labels: {\n                  visible: false\n                },\n                line: {\n                  visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n              });\n            }\n\n            this.options.minorTicks = deepExtend({}, {\n              color: this.options.line.color,\n              width: this.options.line.width,\n              visible: this.options.minorTickType !== NONE\n            }, this.options.minorTicks, {\n              size: this.options.minorTickSize,\n              align: this.options.minorTickType\n            });\n            this.options.majorTicks = deepExtend({}, {\n              color: this.options.line.color,\n              width: this.options.line.width,\n              visible: this.options.majorTickType !== NONE\n            }, this.options.majorTicks, {\n              size: this.options.majorTickSize,\n              align: this.options.majorTickType\n            });\n            this.initFields();\n\n            if (!this.options._deferLabels) {\n              this.createLabels();\n            }\n\n            this.createTitle();\n            this.createNotes();\n          },\n          initFields: function () {},\n          labelsRange: function () {\n            return {\n              min: this.options.labels.skip,\n              max: this.labelsCount()\n            };\n          },\n          normalizeLabelRotation: function (labelOptions) {\n            var rotation = labelOptions.rotation;\n\n            if (isObject(rotation)) {\n              labelOptions.alignRotation = rotation.align;\n              labelOptions.rotation = rotation.angle;\n            }\n          },\n          createLabels: function () {\n            var this$1 = this;\n            var options = this.options;\n            var align = options.vertical ? RIGHT : CENTER;\n            var labelOptions = deepExtend({}, options.labels, {\n              align: align,\n              zIndex: options.zIndex\n            });\n            var step = Math.max(1, labelOptions.step);\n            this.clearLabels();\n\n            if (labelOptions.visible) {\n              this.normalizeLabelRotation(labelOptions);\n\n              if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n              }\n\n              var range = this.labelsRange();\n\n              for (var idx = range.min; idx < range.max; idx += step) {\n                var labelContext = {\n                  index: idx,\n                  count: range.max\n                };\n                var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n\n                if (label) {\n                  this$1.append(label);\n                  this$1.labels.push(label);\n                }\n              }\n            }\n          },\n          clearLabels: function () {\n            this.children = grep(this.children, function (child) {\n              return !(child instanceof AxisLabel);\n            });\n            this.labels = [];\n          },\n          clearTitle: function () {\n            var this$1 = this;\n\n            if (this.title) {\n              this.children = grep(this.children, function (child) {\n                return child !== this$1.title;\n              });\n              this.title = undefined;\n            }\n          },\n          clear: function () {\n            this.clearLabels();\n            this.clearTitle();\n          },\n          lineBox: function () {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var axisX = mirror ? box.x1 : box.x2;\n            var axisY = mirror ? box.y2 : box.y1;\n            var lineWidth = options.line.width || 0;\n            return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n          },\n          createTitle: function () {\n            var options = this.options;\n            var titleOptions = deepExtend({\n              rotation: options.vertical ? -90 : 0,\n              text: \"\",\n              zIndex: 1,\n              visualSize: true\n            }, options.title);\n\n            if (titleOptions.visible && titleOptions.text) {\n              var title = new TextBox(titleOptions.text, titleOptions);\n              this.append(title);\n              this.title = title;\n            }\n          },\n          createNotes: function () {\n            var this$1 = this;\n            var options = this.options;\n            var notes = options.notes;\n            var items = notes.data || [];\n            this.notes = [];\n\n            for (var i = 0; i < items.length; i++) {\n              var item = deepExtend({}, notes, items[i]);\n              item.value = this$1.parseNoteValue(item.value);\n              var note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n              }, item, this$1.chartService);\n\n              if (note.options.visible) {\n                if (defined(note.options.position)) {\n                  if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n                    note.options.position = options.reverse ? LEFT : RIGHT;\n                  } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n                    note.options.position = options.reverse ? BOTTOM : TOP;\n                  }\n                } else {\n                  if (options.vertical) {\n                    note.options.position = options.reverse ? LEFT : RIGHT;\n                  } else {\n                    note.options.position = options.reverse ? BOTTOM : TOP;\n                  }\n                }\n\n                this$1.append(note);\n                this$1.notes.push(note);\n              }\n            }\n          },\n          parseNoteValue: function (value) {\n            return value;\n          },\n          renderVisual: function () {\n            ChartElement.fn.renderVisual.call(this);\n            this.createPlotBands();\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            this.createBackground();\n            this.createLine();\n          },\n          gridLinesVisual: function () {\n            var gridLines = this._gridLines;\n\n            if (!gridLines) {\n              gridLines = this._gridLines = new Group({\n                zIndex: -2\n              });\n              this.appendVisual(this._gridLines);\n            }\n\n            return gridLines;\n          },\n          createTicks: function (lineGroup) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var mirror = options.labels.mirror;\n            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n            var tickLineOptions = {\n              // TODO\n              // _alignLines: options._alignLines,\n              vertical: options.vertical\n            };\n\n            function render(tickPositions, tickOptions, skipUnit) {\n              var count = tickPositions.length;\n              var step = Math.max(1, tickOptions.step);\n\n              if (tickOptions.visible) {\n                for (var i = tickOptions.skip; i < count; i += step) {\n                  if (defined(skipUnit) && i % skipUnit === 0) {\n                    continue;\n                  }\n\n                  tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                  tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                  tickLineOptions.position = tickPositions[i];\n                  lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n              }\n            }\n\n            render(this.getMajorTickPositions(), options.majorTicks);\n            render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n          },\n          createLine: function () {\n            var options = this.options;\n            var line = options.line;\n            var lineBox = this.lineBox();\n\n            if (line.width > 0 && line.visible) {\n              var path = new Path({\n                stroke: {\n                  width: line.width,\n                  color: line.color,\n                  dashType: line.dashType\n                }\n                /* TODO\n                zIndex: line.zIndex,\n                */\n\n              });\n              path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\n              if (options._alignLines) {\n                alignPathToPixel(path);\n              }\n\n              var group = this._lineGroup = new Group();\n              group.append(path);\n              this.visual.append(group);\n              this.createTicks(group);\n            }\n          },\n          getActualTickSize: function () {\n            var options = this.options;\n            var tickSize = 0;\n\n            if (options.majorTicks.visible && options.minorTicks.visible) {\n              tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n            } else if (options.majorTicks.visible) {\n              tickSize = options.majorTicks.size;\n            } else if (options.minorTicks.visible) {\n              tickSize = options.minorTicks.size;\n            }\n\n            return tickSize;\n          },\n          createBackground: function () {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var background = options.background;\n\n            if (background) {\n              this._backgroundPath = Path.fromRect(box.toRect(), {\n                fill: {\n                  color: background\n                },\n                stroke: null\n              });\n              this.visual.append(this._backgroundPath);\n            }\n          },\n          createPlotBands: function () {\n            var this$1 = this;\n            var options = this.options;\n            var plotBands = options.plotBands || [];\n            var vertical = options.vertical;\n            var plotArea = this.plotArea;\n\n            if (plotBands.length === 0) {\n              return;\n            }\n\n            var group = this._plotbandGroup = new Group({\n              zIndex: -1\n            });\n            var altAxis = grep(this.pane.axes, function (axis) {\n              return axis.options.vertical !== this$1.options.vertical;\n            })[0];\n\n            for (var idx = 0; idx < plotBands.length; idx++) {\n              var item = plotBands[idx];\n              var slotX = void 0,\n                  slotY = void 0;\n              var labelOptions = item.label;\n              var label = void 0;\n\n              if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this$1.getSlot(item.from, item.to, true);\n              } else {\n                slotX = this$1.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n              }\n\n              if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this$1.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n              }\n\n              if (slotX.width() !== 0 && slotY.height() !== 0) {\n                var bandRect = new Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n                var path = Path.fromRect(bandRect, {\n                  fill: {\n                    color: item.color,\n                    opacity: item.opacity\n                  },\n                  stroke: null\n                });\n                group.append(path);\n\n                if (label) {\n                  group.append(label);\n                }\n              }\n            }\n\n            this.appendVisual(group);\n          },\n          createPlotBandLabel: function (label, item, box) {\n            if (label.visible === false) {\n              return null;\n            }\n\n            var text = label.text;\n            var textbox;\n\n            if (defined(label) && label.visible) {\n              var labelTemplate = getTemplate(label);\n\n              if (labelTemplate) {\n                text = labelTemplate({\n                  text: text,\n                  item: item\n                });\n              } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n              }\n\n              if (!label.color) {\n                label.color = this.options.labels.color;\n              }\n            }\n\n            textbox = new TextBox(text, label);\n            textbox.reflow(box);\n            textbox.renderVisual();\n            return textbox.visual;\n          },\n          createGridLines: function (altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var minorUnit = options.minorUnit;\n            var vertical = options.vertical;\n            var axisLineVisible = altAxis.options.line.visible;\n            var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n            var lineBox = altAxis.lineBox();\n            var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n            var lineOptions = {\n              lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n              lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n              vertical: vertical\n            };\n            var majorTicks = [];\n            var container = this.gridLinesVisual();\n\n            function render(tickPositions, gridLine, skipUnit) {\n              var count = tickPositions.length;\n              var step = Math.max(1, gridLine.step);\n\n              if (gridLine.visible) {\n                for (var i = gridLine.skip; i < count; i += step) {\n                  var pos = round(tickPositions[i]);\n\n                  if (!inArray(pos, majorTicks)) {\n                    if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                      lineOptions.position = pos;\n                      container.append(createAxisGridLine(lineOptions, gridLine));\n                      majorTicks.push(pos);\n                    }\n                  }\n                }\n              }\n            }\n\n            render(this.getMajorTickPositions(), majorGridLines);\n            render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n            return container.children;\n          },\n          reflow: function (box) {\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var title = ref.title;\n            var vertical = options.vertical;\n            var count = labels.length;\n            var sizeFn = vertical ? WIDTH : HEIGHT;\n            var titleSize = title ? title.box[sizeFn]() : 0;\n            var space = this.getActualTickSize() + options.margin + titleSize;\n            var rootBox = (this.getRoot() || {}).box || box;\n            var boxSize = rootBox[sizeFn]();\n            var maxLabelSize = 0;\n\n            for (var i = 0; i < count; i++) {\n              var labelSize = labels[i].box[sizeFn]();\n\n              if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n              }\n            }\n\n            if (vertical) {\n              this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n            } else {\n              this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n            }\n\n            this.arrangeTitle();\n            this.arrangeLabels();\n            this.arrangeNotes();\n          },\n          getLabelsTickPositions: function () {\n            return this.getMajorTickPositions();\n          },\n          labelTickIndex: function (label) {\n            return label.index;\n          },\n          arrangeLabels: function () {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var tickPositions = this.getLabelsTickPositions();\n\n            for (var idx = 0; idx < labels.length; idx++) {\n              var label = labels[idx];\n              var tickIx = this$1.labelTickIndex(label);\n              var labelSize = vertical ? label.box.height() : label.box.width();\n              var firstTickPosition = tickPositions[tickIx];\n              var nextTickPosition = tickPositions[tickIx + 1];\n              var positionStart = void 0,\n                  positionEnd = void 0;\n\n              if (vertical) {\n                if (labelsBetweenTicks) {\n                  var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                  positionStart = middle - labelSize / 2;\n                } else {\n                  positionStart = firstTickPosition - labelSize / 2;\n                }\n\n                positionEnd = positionStart;\n              } else {\n                if (labelsBetweenTicks) {\n                  positionStart = firstTickPosition;\n                  positionEnd = nextTickPosition;\n                } else {\n                  positionStart = firstTickPosition - labelSize / 2;\n                  positionEnd = positionStart + labelSize;\n                }\n              }\n\n              this$1.positionLabel(label, mirror, positionStart, positionEnd);\n            }\n          },\n          positionLabel: function (label, mirror, positionStart, positionEnd) {\n            if (positionEnd === void 0) {\n              positionEnd = positionStart;\n            }\n\n            var options = this.options;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var labelOffset = this.getActualTickSize() + options.margin;\n            var labelBox;\n\n            if (vertical) {\n              var labelX = lineBox.x2;\n\n              if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n              } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n              }\n\n              labelBox = label.box.move(labelX, positionStart);\n            } else {\n              var labelY = lineBox.y1;\n\n              if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n              } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n              }\n\n              labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n            }\n\n            label.reflow(labelBox);\n          },\n          autoRotateLabelAngle: function (labelBox, slotWidth) {\n            if (labelBox.width() < slotWidth) {\n              return 0;\n            }\n\n            if (labelBox.height() > slotWidth) {\n              return -90;\n            }\n\n            return -45;\n          },\n          autoRotateLabels: function () {\n            var this$1 = this;\n\n            if (!this.options.autoRotateLabels || this.options.vertical) {\n              return false;\n            }\n\n            var tickPositions = this.getMajorTickPositions();\n            var labels = this.labels;\n            var limit = Math.min(labels.length, tickPositions.length - 1);\n            var angle = 0;\n\n            for (var idx = 0; idx < limit; idx++) {\n              var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n              var labelBox = labels[idx].box;\n              var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n\n              if (labelAngle !== 0) {\n                angle = labelAngle;\n              }\n\n              if (angle === -90) {\n                break;\n              }\n            }\n\n            if (angle !== 0) {\n              for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                labels[idx$1].options.rotation = angle;\n                labels[idx$1].reflow(new Box());\n              }\n\n              return true;\n            }\n          },\n          arrangeTitle: function () {\n            var ref = this;\n            var options = ref.options;\n            var title = ref.title;\n            var mirror = options.labels.mirror;\n            var vertical = options.vertical;\n\n            if (title) {\n              if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n              } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n              }\n\n              title.reflow(this.box);\n            }\n          },\n          arrangeNotes: function () {\n            var this$1 = this;\n\n            for (var idx = 0; idx < this.notes.length; idx++) {\n              var item = this$1.notes[idx];\n              var value = item.options.value;\n              var slot = void 0;\n\n              if (defined(value)) {\n                if (this$1.shouldRenderNote(value)) {\n                  item.show();\n                } else {\n                  item.hide();\n                }\n\n                slot = this$1.noteSlot(value);\n              } else {\n                item.hide();\n              }\n\n              item.reflow(slot || this$1.lineBox());\n            }\n          },\n          noteSlot: function (value) {\n            return this.getSlot(value);\n          },\n          alignTo: function (secondAxis) {\n            var lineBox = secondAxis.lineBox();\n            var vertical = this.options.vertical;\n            var pos = vertical ? Y : X;\n            this.box.snapTo(lineBox, pos);\n\n            if (vertical) {\n              this.box.shrink(0, this.lineBox().height() - lineBox.height());\n            } else {\n              this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n            }\n\n            this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n            this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n          },\n          axisLabelText: function (value, options, context) {\n            var this$1 = this;\n            var text;\n            var tmpl = getTemplate(options);\n\n            var defaultText = function () {\n              if (!options.format) {\n                return value;\n              }\n\n              return this$1.chartService.format.localeAuto(options.format, [value], options.culture);\n            };\n\n            if (tmpl) {\n              var templateContext = $.extend({}, context, {\n                get text() {\n                  return defaultText();\n                },\n\n                value: value,\n                format: options.format,\n                culture: options.culture\n              });\n              text = tmpl(templateContext);\n            } else {\n              text = defaultText();\n            }\n\n            return text;\n          },\n          slot: function (from, to, limit) {\n            var slot = this.getSlot(from, to, limit);\n\n            if (slot) {\n              return slot.toRect();\n            }\n          },\n          contentBox: function () {\n            var box = this.box.clone();\n            var labels = this.labels;\n\n            if (labels.length) {\n              var axis = this.options.vertical ? Y : X;\n\n              if (this.chartService.isPannable(axis)) {\n                var offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n              } else {\n                if (labels[0].options.visible) {\n                  box.wrap(labels[0].box);\n                }\n\n                var lastLabel = labels[labels.length - 1];\n\n                if (lastLabel.options.visible) {\n                  box.wrap(lastLabel.box);\n                }\n              }\n            }\n\n            return box;\n          },\n          maxLabelOffset: function () {\n            var this$1 = this;\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var tickPositions = this.getLabelsTickPositions();\n            var offsetField = vertical ? Y : X;\n            var labels = this.labels;\n            var startPosition = reverse ? 1 : 0;\n            var endPosition = reverse ? 0 : 1;\n            var maxStartOffset = 0;\n            var maxEndOffset = 0;\n\n            for (var idx = 0; idx < labels.length; idx++) {\n              var label = labels[idx];\n              var tickIx = this$1.labelTickIndex(label);\n              var startTick = void 0,\n                  endTick = void 0;\n\n              if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n              } else {\n                startTick = endTick = tickPositions[tickIx];\n              }\n\n              maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n              maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n            }\n\n            return {\n              start: maxStartOffset,\n              end: maxEndOffset\n            };\n          },\n          limitRange: function (from, to, min, max, offset) {\n            var options = this.options;\n\n            if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n              return null;\n            }\n\n            if (to < min && offset > 0 || max < from && offset < 0) {\n              return {\n                min: from,\n                max: to\n              };\n            }\n\n            var rangeSize = to - from;\n            var minValue = from;\n            var maxValue = to;\n\n            if (from < min && offset < 0) {\n              minValue = limitValue(from, min, max);\n              maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n            } else if (to > max && offset > 0) {\n              maxValue = limitValue(to, min, max);\n              minValue = limitValue(to - rangeSize, min, max - rangeSize);\n            }\n\n            return {\n              min: minValue,\n              max: maxValue\n            };\n          },\n          valueRange: function () {\n            return {\n              min: this.seriesMin,\n              max: this.seriesMax\n            };\n          },\n          lineDir: function () {\n            /*\n             * Axis line direction:\n             *   * Vertical: up.\n             *   * Horizontal: right.\n             */\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n          },\n          lineInfo: function () {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = this.lineDir();\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n            return {\n              axis: axis,\n              axisOrigin: axisOrigin,\n              axisDir: axisDir,\n              lineBox: lineBox,\n              lineSize: lineSize,\n              lineStart: lineStart\n            };\n          },\n          pointOffset: function (point) {\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n            var offset = relative / lineSize;\n            return offset;\n          },\n          scaleToDelta: function (rawScale, range) {\n            // Scale >= 1 would result in axis range of 0.\n            // Scale <= -1 would reverse the scale direction.\n            var MAX_SCALE = 0.999;\n            var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n            var delta;\n\n            if (scale > 0) {\n              delta = range * Math.min(1, scale);\n            } else {\n              delta = range - range / (1 + scale);\n            }\n\n            return delta;\n          },\n          labelsBetweenTicks: function () {\n            return !this.options.justified;\n          },\n          prepareUserOptions: function () {}\n        });\n        setDefaultOptions(Axis, {\n          labels: {\n            visible: true,\n            rotation: 0,\n            mirror: false,\n            step: 1,\n            skip: 0\n          },\n          line: {\n            width: 1,\n            color: BLACK,\n            visible: true\n          },\n          title: {\n            visible: true,\n            position: CENTER\n          },\n          majorTicks: {\n            align: OUTSIDE,\n            size: 4,\n            skip: 0,\n            step: 1\n          },\n          minorTicks: {\n            align: OUTSIDE,\n            size: 3,\n            skip: 0,\n            step: 1\n          },\n          axisCrossingValue: 0,\n          majorTickType: OUTSIDE,\n          minorTickType: NONE,\n          majorGridLines: {\n            skip: 0,\n            step: 1\n          },\n          minorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK,\n            skip: 0,\n            step: 1\n          },\n          // TODO: Move to line or labels options\n          margin: 5,\n          visible: true,\n          reverse: false,\n          justified: true,\n          notes: {\n            label: {\n              text: \"\"\n            }\n          },\n          _alignLines: true,\n          _deferLabels: false\n        });\n        var MILLISECONDS = \"milliseconds\";\n        var SECONDS = \"seconds\";\n        var MINUTES = \"minutes\";\n        var HOURS = \"hours\";\n        var DAYS = \"days\";\n        var WEEKS = \"weeks\";\n        var MONTHS = \"months\";\n        var YEARS = \"years\";\n        var TIME_PER_MILLISECOND = 1;\n        var TIME_PER_SECOND = 1000;\n        var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\n        var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\n        var TIME_PER_DAY = 24 * TIME_PER_HOUR;\n        var TIME_PER_WEEK = 7 * TIME_PER_DAY;\n        var TIME_PER_MONTH = 31 * TIME_PER_DAY;\n        var TIME_PER_YEAR = 365 * TIME_PER_DAY;\n        var TIME_PER_UNIT = {\n          \"years\": TIME_PER_YEAR,\n          \"months\": TIME_PER_MONTH,\n          \"weeks\": TIME_PER_WEEK,\n          \"days\": TIME_PER_DAY,\n          \"hours\": TIME_PER_HOUR,\n          \"minutes\": TIME_PER_MINUTE,\n          \"seconds\": TIME_PER_SECOND,\n          \"milliseconds\": TIME_PER_MILLISECOND\n        };\n\n        function absoluteDateDiff(a, b) {\n          var diff = a.getTime() - b;\n          var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n          return diff - offsetDiff * TIME_PER_MINUTE;\n        }\n\n        function addTicks(date, ticks) {\n          return new Date(date.getTime() + ticks);\n        }\n\n        function toDate(value) {\n          var result;\n\n          if (value instanceof Date) {\n            result = value;\n          } else if (value) {\n            result = new Date(value);\n          }\n\n          return result;\n        }\n\n        function startOfWeek(date, weekStartDay) {\n          if (weekStartDay === void 0) {\n            weekStartDay = 0;\n          }\n\n          var daysToSubtract = 0;\n          var day = date.getDay();\n\n          if (!isNaN(day)) {\n            while (day !== weekStartDay) {\n              if (day === 0) {\n                day = 6;\n              } else {\n                day--;\n              }\n\n              daysToSubtract++;\n            }\n          }\n\n          return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n        }\n\n        function adjustDST(date, hours) {\n          if (hours === 0 && date.getHours() === 23) {\n            date.setHours(date.getHours() + 2);\n            return true;\n          }\n\n          return false;\n        }\n\n        function addHours(date, hours) {\n          var roundedDate = new Date(date);\n          roundedDate.setMinutes(0, 0, 0);\n          var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n          return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n        }\n\n        function addDuration(dateValue, value, unit, weekStartDay) {\n          var result = dateValue;\n\n          if (dateValue) {\n            var date = toDate(dateValue);\n            var hours = date.getHours();\n\n            if (unit === YEARS) {\n              result = new Date(date.getFullYear() + value, 0, 1);\n              adjustDST(result, 0);\n            } else if (unit === MONTHS) {\n              result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n              adjustDST(result, hours);\n            } else if (unit === WEEKS) {\n              result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n              adjustDST(result, hours);\n            } else if (unit === DAYS) {\n              result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n              adjustDST(result, hours);\n            } else if (unit === HOURS) {\n              result = addHours(date, value);\n            } else if (unit === MINUTES) {\n              result = addTicks(date, value * TIME_PER_MINUTE);\n\n              if (result.getSeconds() > 0) {\n                result.setSeconds(0);\n              }\n            } else if (unit === SECONDS) {\n              result = addTicks(date, value * TIME_PER_SECOND);\n            } else if (unit === MILLISECONDS) {\n              result = addTicks(date, value);\n            }\n\n            if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n              result.setMilliseconds(0);\n            }\n          }\n\n          return result;\n        }\n\n        function floorDate(date, unit, weekStartDay) {\n          return addDuration(toDate(date), 0, unit, weekStartDay);\n        }\n\n        function ceilDate(dateValue, unit, weekStartDay) {\n          var date = toDate(dateValue);\n\n          if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n            return date;\n          }\n\n          return addDuration(date, 1, unit, weekStartDay);\n        }\n\n        function dateComparer(a, b) {\n          if (a && b) {\n            return a.getTime() - b.getTime();\n          }\n\n          return -1;\n        }\n\n        function dateDiff(a, b) {\n          return a.getTime() - b;\n        }\n\n        function toTime(value) {\n          if (isArray(value)) {\n            var result = [];\n\n            for (var idx = 0; idx < value.length; idx++) {\n              result.push(toTime(value[idx]));\n            }\n\n            return result;\n          } else if (value) {\n            return toDate(value).getTime();\n          }\n        }\n\n        function dateEquals(a, b) {\n          if (a && b) {\n            return toTime(a) === toTime(b);\n          }\n\n          return a === b;\n        }\n\n        function timeIndex(date, start, baseUnit) {\n          return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n        }\n\n        function dateIndex(value, start, baseUnit, baseUnitStep) {\n          var date = toDate(value);\n          var startDate = toDate(start);\n          var index;\n\n          if (baseUnit === MONTHS) {\n            index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n          } else if (baseUnit === YEARS) {\n            index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n          } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n            index = timeIndex(date, startDate, baseUnit);\n          } else {\n            index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n          }\n\n          return index / baseUnitStep;\n        }\n\n        function duration(a, b, unit) {\n          var diff;\n\n          if (unit === YEARS) {\n            diff = b.getFullYear() - a.getFullYear();\n          } else if (unit === MONTHS) {\n            diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n          } else if (unit === DAYS) {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n          } else {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n          }\n\n          return diff;\n        }\n\n        function lteDateIndex(date, sortedDates) {\n          var low = 0;\n          var high = sortedDates.length - 1;\n          var index;\n\n          while (low <= high) {\n            index = Math.floor((low + high) / 2);\n            var currentDate = sortedDates[index];\n\n            if (currentDate < date) {\n              low = index + 1;\n              continue;\n            }\n\n            if (currentDate > date) {\n              high = index - 1;\n              continue;\n            }\n\n            while (dateEquals(sortedDates[index - 1], date)) {\n              index--;\n            }\n\n            return index;\n          }\n\n          if (sortedDates[index] <= date) {\n            return index;\n          }\n\n          return index - 1;\n        }\n\n        function parseDate(intlService, date) {\n          var result;\n\n          if (isString(date)) {\n            result = intlService.parseDate(date) || toDate(date);\n          } else {\n            result = toDate(date);\n          }\n\n          return result;\n        }\n\n        function parseDates(intlService, dates) {\n          if (isArray(dates)) {\n            var result = [];\n\n            for (var idx = 0; idx < dates.length; idx++) {\n              result.push(parseDate(intlService, dates[idx]));\n            }\n\n            return result;\n          }\n\n          return parseDate(intlService, dates);\n        }\n\n        function firstDay(options, intlService) {\n          if (isNumber(options.weekStartDay)) {\n            return options.weekStartDay;\n          }\n\n          if (intlService && intlService.firstDay) {\n            return intlService.firstDay();\n          }\n\n          return 0;\n        }\n\n        var MIN_CATEGORY_POINTS_RANGE = 0.01;\n        var MIN_CATEGORY_RANGE = 0.1;\n\n        function indexOf(value, arr) {\n          if (value instanceof Date) {\n            var length = arr.length;\n\n            for (var idx = 0; idx < length; idx++) {\n              if (dateEquals(arr[idx], value)) {\n                return idx;\n              }\n            }\n\n            return -1;\n          }\n\n          return arr.indexOf(value);\n        }\n\n        var CategoryAxis = Axis.extend({\n          initFields: function () {\n            this._ticks = {};\n          },\n          categoriesHash: function () {\n            return \"\";\n          },\n          clone: function () {\n            var copy = new CategoryAxis($.extend({}, this.options, {\n              categories: this.options.srcCategories\n            }), this.chartService);\n            copy.createLabels();\n            return copy;\n          },\n          initUserOptions: function (options) {\n            var categories = options.categories || [];\n            var definedMin = defined(options.min);\n            var definedMax = defined(options.max);\n            options.srcCategories = options.categories = categories;\n\n            if ((definedMin || definedMax) && categories.length) {\n              var min = definedMin ? Math.floor(options.min) : 0;\n              var max;\n\n              if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n              } else {\n                max = categories.length;\n              }\n\n              options.categories = options.categories.slice(min, max);\n            }\n\n            return options;\n          },\n          rangeIndices: function () {\n            var options = this.options;\n            var length = options.categories.length || 1;\n            var min = isNumber(options.min) ? options.min % 1 : 0;\n            var max;\n\n            if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n              max = length - (1 - options.max % 1);\n            } else {\n              max = length - (options.justified ? 1 : 0);\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          totalRangeIndices: function (limit) {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max;\n\n            if (isNumber(options.max)) {\n              max = options.max;\n            } else if (isNumber(options.min)) {\n              max = min + options.categories.length;\n            } else {\n              max = this.totalRange().max || 1;\n            }\n\n            if (limit) {\n              var totalRange = this.totalRange();\n              min = limitValue(min, 0, totalRange.max);\n              max = limitValue(max, 0, totalRange.max);\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          range: function () {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max = isNumber(options.max) ? options.max : this.totalRange().max;\n            return {\n              min: min,\n              max: max\n            };\n          },\n          roundedRange: function () {\n            return this.range();\n          },\n          totalRange: function () {\n            var options = this.options;\n            return {\n              min: 0,\n              max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)\n            };\n          },\n          scaleOptions: function () {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var lineBox = this.lineBox();\n            var size = this.options.vertical ? lineBox.height() : lineBox.width();\n            var scale = size / (max - min || 1);\n            return {\n              scale: scale * (this.options.reverse ? -1 : 1),\n              box: lineBox,\n              min: min,\n              max: max\n            };\n          },\n          arrangeLabels: function () {\n            Axis.fn.arrangeLabels.call(this);\n            this.hideOutOfRangeLabels();\n          },\n          hideOutOfRangeLabels: function () {\n            var ref = this;\n            var box = ref.box;\n            var labels = ref.labels;\n\n            if (labels.length > 0) {\n              var valueAxis = this.options.vertical ? Y : X;\n              var start = box[valueAxis + 1];\n              var end = box[valueAxis + 2];\n              var firstLabel = labels[0];\n              var lastLabel = last(labels);\n\n              if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n              }\n\n              if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n              }\n            }\n          },\n          getMajorTickPositions: function () {\n            return this.getTicks().majorTicks;\n          },\n          getMinorTickPositions: function () {\n            return this.getTicks().minorTicks;\n          },\n          getLabelsTickPositions: function () {\n            return this.getTicks().labelTicks;\n          },\n          tickIndices: function (stepSize) {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var limit = Math.ceil(max);\n            var current = Math.floor(min);\n            var indices = [];\n\n            while (current <= limit) {\n              indices.push(current);\n              current += stepSize;\n            }\n\n            return indices;\n          },\n          getTickPositions: function (stepSize) {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n            var indices = this.tickIndices(stepSize);\n            var positions = [];\n\n            for (var idx = 0; idx < indices.length; idx++) {\n              positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n            }\n\n            return positions;\n          },\n          getTicks: function () {\n            var options = this.options;\n            var cache = this._ticks;\n            var range = this.rangeIndices();\n            var lineBox = this.lineBox();\n            var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n            if (cache._hash !== hash) {\n              var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n              cache._hash = hash;\n              cache.labelTicks = this.getTickPositions(1);\n              cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n              cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n            }\n\n            return cache;\n          },\n          filterOutOfRangePositions: function (positions, lineBox) {\n            if (!positions.length) {\n              return positions;\n            }\n\n            var axis = this.options.vertical ? Y : X;\n\n            var inRange = function (position) {\n              return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n            };\n\n            var end = positions.length - 1;\n            var startIndex = 0;\n\n            while (!inRange(positions[startIndex]) && startIndex <= end) {\n              startIndex++;\n            }\n\n            var endIndex = end;\n\n            while (!inRange(positions[endIndex]) && endIndex >= 0) {\n              endIndex--;\n            }\n\n            return positions.slice(startIndex, endIndex + 1);\n          },\n          lineInfo: function () {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = reverse ? -1 : 1;\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n            return {\n              axis: axis,\n              axisOrigin: axisOrigin,\n              axisDir: axisDir,\n              lineBox: lineBox,\n              lineSize: lineSize,\n              lineStart: lineStart\n            };\n          },\n          lineDir: function () {\n            /*\n             *  Category axis line direction:\n             *    * Vertical: down.\n             *    * Horizontal: right.\n             */\n            var ref = this.options;\n            var reverse = ref.reverse;\n            return reverse ? -1 : 1;\n          },\n          getSlot: function (from, to, limit) {\n            var options = this.options;\n            var reverse = options.reverse;\n            var justified = options.justified;\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var box = ref.box;\n            var min = ref.min;\n            var ref$1 = this.lineInfo();\n            var valueAxis = ref$1.axis;\n            var lineStart = ref$1.lineStart;\n            var slotBox = box.clone();\n            var singleSlot = !defined(to);\n            var start = valueOrDefault(from, 0);\n            var end = valueOrDefault(to, start);\n            end = Math.max(end - 1, start); // Fixes transient bug caused by iOS 6.0 JIT\n            // (one can never be too sure)\n\n            end = Math.max(start, end);\n            var p1 = lineStart + (start - min) * scale;\n            var p2 = lineStart + (end + 1 - min) * scale;\n\n            if (singleSlot && justified) {\n              p2 = p1;\n            }\n\n            if (limit) {\n              p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n              p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n            }\n\n            slotBox[valueAxis + 1] = reverse ? p2 : p1;\n            slotBox[valueAxis + 2] = reverse ? p1 : p2;\n            return slotBox;\n          },\n          limitSlot: function (slot) {\n            var vertical = this.options.vertical;\n            var valueAxis = vertical ? Y : X;\n            var lineBox = this.lineBox();\n            var limittedSlot = slot.clone();\n            limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n            limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n            return limittedSlot;\n          },\n          slot: function (from, to, limit) {\n            var min = Math.floor(this.options.min || 0);\n            var start = from;\n            var end = to;\n\n            if (typeof start === \"string\") {\n              start = this.categoryIndex(start);\n            } else if (isNumber(start)) {\n              start -= min;\n            }\n\n            if (typeof end === \"string\") {\n              end = this.categoryIndex(end);\n            } else if (isNumber(end)) {\n              end -= min;\n            }\n\n            return Axis.fn.slot.call(this, start, end, limit);\n          },\n          pointCategoryIndex: function (point) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var justified = ref.justified;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var max = ref$1.max;\n            var startValue = reverse ? max : min;\n            var lineStart = box[valueAxis + 1];\n            var lineEnd = box[valueAxis + 2];\n            var pos = point[valueAxis];\n\n            if (pos < lineStart || pos > lineEnd) {\n              return null;\n            }\n\n            var value = startValue + (pos - lineStart) / scale;\n            var diff = value % 1;\n\n            if (justified) {\n              value = Math.round(value);\n            } else if (diff === 0 && value > 0) {\n              value--;\n            }\n\n            return Math.floor(value);\n          },\n          getCategory: function (point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n              return null;\n            }\n\n            return this.options.categories[index];\n          },\n          categoryIndex: function (value) {\n            return this.totalIndex(value) - Math.floor(this.options.min || 0);\n          },\n          categoryAt: function (index, total) {\n            var options = this.options;\n            return (total ? options.srcCategories : options.categories)[index];\n          },\n          categoriesCount: function () {\n            return (this.options.categories || []).length;\n          },\n          translateRange: function (delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var range = options.categories.length;\n            var scale = size / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            return {\n              min: offset,\n              max: range + offset\n            };\n          },\n          scaleRange: function (scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var rangeIndices = this.totalRangeIndices();\n            var range = rangeIndices.max - rangeIndices.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = rangeIndices.min + minDelta;\n            var max = rangeIndices.max - maxDelta;\n\n            if (max - min < MIN_CATEGORY_RANGE) {\n              max = min + MIN_CATEGORY_RANGE;\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          zoomRange: function (scale, cursor) {\n            var ref = this.totalRange();\n            var totalMin = ref.min;\n            var totalMax = ref.max;\n            var range = this.scaleRange(scale, cursor);\n            return {\n              min: limitValue(range.min, totalMin, totalMax),\n              max: limitValue(range.max, totalMin, totalMax)\n            };\n          },\n          labelsCount: function () {\n            var labelsRange = this.labelsRange();\n            return labelsRange.max - labelsRange.min;\n          },\n          labelsRange: function () {\n            var options = this.options;\n            var justified = options.justified;\n            var labelOptions = options.labels;\n            var ref = this.totalRangeIndices(true);\n            var min = ref.min;\n            var max = ref.max;\n            var start = Math.floor(min);\n\n            if (!justified) {\n              min = Math.floor(min);\n              max = Math.ceil(max);\n            } else {\n              min = Math.ceil(min);\n              max = Math.floor(max);\n            }\n\n            var skip;\n\n            if (min > labelOptions.skip) {\n              skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n            } else {\n              skip = labelOptions.skip;\n            }\n\n            return {\n              min: skip - start,\n              max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n            };\n          },\n          createAxisLabel: function (index, labelOptions, labelContext) {\n            var options = this.options;\n            var dataItem = options.dataItems ? options.dataItems[index] : null;\n            var category = valueOrDefault(options.categories[index], \"\");\n            labelContext.dataItem = dataItem;\n            var text = this.axisLabelText(category, labelOptions, labelContext);\n            return new AxisLabel(category, text, index, dataItem, labelOptions);\n          },\n          shouldRenderNote: function (value) {\n            var range = this.totalRangeIndices();\n            return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n          },\n          noteSlot: function (value) {\n            var options = this.options;\n            var index = value - Math.floor(options.min || 0);\n            return this.getSlot(index);\n          },\n          arrangeNotes: function () {\n            Axis.fn.arrangeNotes.call(this);\n            this.hideOutOfRangeNotes();\n          },\n          hideOutOfRangeNotes: function () {\n            var ref = this;\n            var notes = ref.notes;\n            var box = ref.box;\n\n            if (notes && notes.length) {\n              var valueAxis = this.options.vertical ? Y : X;\n              var start = box[valueAxis + 1];\n              var end = box[valueAxis + 2];\n\n              for (var idx = 0; idx < notes.length; idx++) {\n                var note = notes[idx];\n\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                  note.hide();\n                }\n              }\n            }\n          },\n          pan: function (delta) {\n            var range = this.totalRangeIndices(true);\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            var totalRange = this.totalRange();\n            var min = range.min + offset;\n            var max = range.max + offset;\n            return this.limitRange(min, max, 0, totalRange.max, offset);\n          },\n          pointsRange: function (start, end) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var range = this.totalRangeIndices(true);\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n            var diffStart = start[valueAxis] - lineStart;\n            var diffEnd = end[valueAxis] - lineStart;\n            var min = range.min + diffStart / scale;\n            var max = range.min + diffEnd / scale;\n            var rangeMin = Math.min(min, max);\n            var rangeMax = Math.max(min, max);\n\n            if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n              return {\n                min: rangeMin,\n                max: rangeMax\n              };\n            }\n          },\n          valueRange: function () {\n            return this.range();\n          },\n          totalIndex: function (value) {\n            var options = this.options;\n            var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n            return index;\n          },\n          currentRangeIndices: function () {\n            var options = this.options;\n            var min = 0;\n\n            if (isNumber(options.min)) {\n              min = Math.floor(options.min);\n            }\n\n            var max;\n\n            if (isNumber(options.max)) {\n              max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n            } else {\n              max = this.totalCount() - 1;\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          mapCategories: function () {\n            if (!this._categoriesMap) {\n              var map$$1 = this._categoriesMap = new HashMap();\n              var srcCategories = this.options.srcCategories;\n\n              for (var idx = 0; idx < srcCategories.length; idx++) {\n                map$$1.set(srcCategories[idx], idx);\n              }\n            }\n          },\n          totalCount: function () {\n            return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n          }\n        });\n        setDefaultOptions(CategoryAxis, {\n          type: \"category\",\n          vertical: false,\n          majorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK\n          },\n          labels: {\n            zIndex: 1\n          },\n          justified: false,\n          _deferLabels: true\n        });\n        var COORDINATE_LIMIT = 300000;\n        var DateLabelFormats = {\n          milliseconds: \"HH:mm:ss.fff\",\n          seconds: \"HH:mm:ss\",\n          minutes: \"HH:mm\",\n          hours: \"HH:mm\",\n          days: \"M/d\",\n          weeks: \"M/d\",\n          months: \"MMM 'yy\",\n          years: \"yyyy\"\n        };\n        var ZERO_THRESHOLD = 0.2;\n        var AUTO = \"auto\";\n        var BASE_UNITS = [MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS];\n        var FIT = \"fit\";\n\n        function categoryRange(categories) {\n          var range = categories._range;\n\n          if (!range) {\n            range = categories._range = sparseArrayLimits(categories);\n            range.min = toDate(range.min);\n            range.max = toDate(range.max);\n          }\n\n          return range;\n        }\n\n        var EmptyDateRange = Class.extend({\n          init: function (options) {\n            this.options = options;\n          },\n          displayIndices: function () {\n            return {\n              min: 0,\n              max: 1\n            };\n          },\n          displayRange: function () {\n            return {};\n          },\n          total: function () {\n            return {};\n          },\n          valueRange: function () {\n            return {};\n          },\n          valueIndex: function () {\n            return -1;\n          },\n          values: function () {\n            return [];\n          },\n          totalIndex: function () {\n            return -1;\n          },\n          valuesCount: function () {\n            return 0;\n          },\n          totalCount: function () {\n            return 0;\n          },\n          dateAt: function () {\n            return null;\n          }\n        });\n        var DateRange = Class.extend({\n          init: function (start, end, options) {\n            this.options = options;\n            options.baseUnitStep = options.baseUnitStep || 1;\n            var roundToBaseUnit = options.roundToBaseUnit;\n            var justified = options.justified;\n            this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n            var lowerEnd = this.roundToTotalStep(end);\n            var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n            this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n            var min = options.min || start;\n            this.valueStart = this.roundToTotalStep(min);\n            this.displayStart = roundToBaseUnit ? this.valueStart : min;\n            var max = options.max;\n\n            if (!max) {\n              this.valueEnd = lowerEnd;\n              this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n            } else {\n              var next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n              this.valueEnd = this.roundToTotalStep(max, false, next);\n              this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n            }\n\n            if (this.valueEnd < this.valueStart) {\n              this.valueEnd = this.valueStart;\n            }\n\n            if (this.displayEnd <= this.displayStart) {\n              this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n            }\n          },\n          displayRange: function () {\n            return {\n              min: this.displayStart,\n              max: this.displayEnd\n            };\n          },\n          displayIndices: function () {\n            if (!this._indices) {\n              var options = this.options;\n              var baseUnit = options.baseUnit;\n              var baseUnitStep = options.baseUnitStep;\n              var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n              var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n              this._indices = {\n                min: minIdx,\n                max: maxIdx\n              };\n            }\n\n            return this._indices;\n          },\n          total: function () {\n            return {\n              min: this.start,\n              max: this.end\n            };\n          },\n          totalCount: function () {\n            var last$$1 = this.totalIndex(this.end);\n            return last$$1 + (this.options.justified ? 1 : 0);\n          },\n          valueRange: function () {\n            return {\n              min: this.valueStart,\n              max: this.valueEnd\n            };\n          },\n          valueIndex: function (value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n          },\n          totalIndex: function (value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n          },\n          dateIndex: function (value) {\n            var options = this.options;\n            return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n          },\n          valuesCount: function () {\n            var maxIdx = this.valueIndex(this.valueEnd);\n            return maxIdx + 1;\n          },\n          values: function () {\n            var values = this._values;\n\n            if (!values) {\n              var options = this.options;\n              var range = this.valueRange();\n              this._values = values = [];\n\n              for (var date = range.min; date <= range.max;) {\n                values.push(date);\n                date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n              }\n            }\n\n            return values;\n          },\n          dateAt: function (index, total) {\n            var options = this.options;\n            return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n          },\n          roundToTotalStep: function (value, upper, next) {\n            var ref = this.options;\n            var baseUnit = ref.baseUnit;\n            var baseUnitStep = ref.baseUnitStep;\n            var weekStartDay = ref.weekStartDay;\n            var start = this.start;\n            var step = dateIndex(value, start, baseUnit, baseUnitStep);\n            var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n            if (next) {\n              roundedStep += next;\n            }\n\n            return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n          }\n        });\n\n        function autoBaseUnit(options, startUnit, startStep) {\n          var categoryLimits = categoryRange(options.categories);\n          var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n          var autoBaseUnitSteps = options.autoBaseUnitSteps;\n          var maxDateGroups = options.maxDateGroups;\n          var autoUnit = options.baseUnit === FIT;\n          var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n          var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n          var units = span / TIME_PER_UNIT[baseUnit];\n          var totalUnits = units;\n          var unitSteps, step, nextStep;\n\n          while (!step || units >= maxDateGroups) {\n            unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n            do {\n              nextStep = unitSteps.shift();\n            } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n            if (nextStep) {\n              step = nextStep;\n              units = totalUnits / step;\n            } else if (baseUnit === last(BASE_UNITS)) {\n              step = Math.ceil(totalUnits / maxDateGroups);\n              break;\n            } else if (autoUnit) {\n              baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n              totalUnits = span / TIME_PER_UNIT[baseUnit];\n              unitSteps = null;\n            } else {\n              if (units > maxDateGroups) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n              }\n\n              break;\n            }\n          }\n\n          options.baseUnitStep = step;\n          options.baseUnit = baseUnit;\n        }\n\n        function defaultBaseUnit(options) {\n          var categories = options.categories;\n          var count = defined(categories) ? categories.length : 0;\n          var minDiff = MAX_VALUE;\n          var lastCategory, unit;\n\n          for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n            var category = categories[categoryIx];\n\n            if (category && lastCategory) {\n              var diff = absoluteDateDiff(category, lastCategory);\n\n              if (diff > 0) {\n                minDiff = Math.min(minDiff, diff);\n\n                if (minDiff >= TIME_PER_YEAR) {\n                  unit = YEARS;\n                } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                  unit = MONTHS;\n                } else if (minDiff >= TIME_PER_WEEK) {\n                  unit = WEEKS;\n                } else if (minDiff >= TIME_PER_DAY) {\n                  unit = DAYS;\n                } else if (minDiff >= TIME_PER_HOUR) {\n                  unit = HOURS;\n                } else if (minDiff >= TIME_PER_MINUTE) {\n                  unit = MINUTES;\n                } else {\n                  unit = SECONDS;\n                }\n              }\n            }\n\n            lastCategory = category;\n          }\n\n          options.baseUnit = unit || DAYS;\n        }\n\n        function initUnit(options) {\n          var baseUnit = (options.baseUnit || \"\").toLowerCase();\n          var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n          if (useDefault) {\n            defaultBaseUnit(options);\n          }\n\n          if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n            autoBaseUnit(options);\n          }\n\n          return options;\n        }\n\n        var DateCategoryAxis = CategoryAxis.extend({\n          clone: function () {\n            var copy = new DateCategoryAxis($.extend({}, this.options), this.chartService);\n            copy.createLabels();\n            return copy;\n          },\n          categoriesHash: function () {\n            var start = this.dataRange.total().min;\n            return this.options.baseUnit + this.options.baseUnitStep + start;\n          },\n          initUserOptions: function (options) {\n            return options;\n          },\n          initFields: function () {\n            CategoryAxis.fn.initFields.call(this);\n            var chartService = this.chartService;\n            var intlService = chartService.intl;\n            var options = this.options;\n            var categories = options.categories || [];\n\n            if (!categories._parsed) {\n              categories = parseDates(intlService, categories);\n              categories._parsed = true;\n            }\n\n            options = deepExtend({\n              roundToBaseUnit: true\n            }, options, {\n              categories: categories,\n              min: parseDate(intlService, options.min),\n              max: parseDate(intlService, options.max),\n              weekStartDay: firstDay(options, intlService)\n            });\n\n            if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n              options.roundToBaseUnit = false;\n            }\n\n            options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n            options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n            this.options = options;\n            options.srcCategories = categories;\n\n            if (categories.length > 0) {\n              var range = categoryRange(categories);\n              var maxDivisions = options.maxDivisions;\n              this.dataRange = new DateRange(range.min, range.max, initUnit(options));\n\n              if (maxDivisions) {\n                var dataRange = this.dataRange.displayRange();\n                var divisionOptions = $.extend({}, options, {\n                  justified: true,\n                  roundToBaseUnit: false,\n                  baseUnit: 'fit',\n                  min: dataRange.min,\n                  max: dataRange.max,\n                  maxDateGroups: maxDivisions\n                });\n                var dataRangeOptions = this.dataRange.options;\n                autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n                this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n              } else {\n                this.divisionRange = this.dataRange;\n              }\n            } else {\n              options.baseUnit = options.baseUnit || DAYS;\n              this.dataRange = this.divisionRange = new EmptyDateRange(options);\n            }\n\n            this.rangeLabels = [];\n          },\n          tickIndices: function (stepSize) {\n            var ref = this;\n            var dataRange = ref.dataRange;\n            var divisionRange = ref.divisionRange;\n            var valuesCount = divisionRange.valuesCount();\n\n            if (!this.options.maxDivisions || !valuesCount) {\n              return CategoryAxis.fn.tickIndices.call(this, stepSize);\n            }\n\n            var indices = [];\n            var values = divisionRange.values();\n            var offset = 0;\n\n            if (!this.options.justified) {\n              values = values.concat(divisionRange.dateAt(valuesCount));\n              offset = 0.5; //align ticks to the center of not justified categories\n            }\n\n            for (var idx = 0; idx < values.length; idx++) {\n              indices.push(dataRange.dateIndex(values[idx]) + offset);\n\n              if (stepSize !== 1 && idx >= 1) {\n                var last$$1 = indices.length - 1;\n                indices.splice(idx, 0, indices[last$$1 - 1] + (indices[last$$1] - indices[last$$1 - 1]) * stepSize);\n              }\n            }\n\n            return indices;\n          },\n          shouldRenderNote: function (value) {\n            var range = this.range();\n            var categories = this.options.categories || [];\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n          },\n          parseNoteValue: function (value) {\n            return parseDate(this.chartService.intl, value);\n          },\n          noteSlot: function (value) {\n            return this.getSlot(value);\n          },\n          translateRange: function (delta) {\n            var options = this.options;\n            var baseUnit = options.baseUnit;\n            var weekStartDay = options.weekStartDay;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / (range.max - range.min);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if (range.min && range.max) {\n              var from = addTicks(options.min || range.min, offset);\n              var to = addTicks(options.max || range.max, offset);\n              range = {\n                min: addDuration(from, 0, baseUnit, weekStartDay),\n                max: addDuration(to, 0, baseUnit, weekStartDay)\n              };\n            }\n\n            return range;\n          },\n          labelsRange: function () {\n            return {\n              min: this.options.labels.skip,\n              max: this.divisionRange.valuesCount()\n            };\n          },\n          pan: function (delta) {\n            if (this.isEmpty()) {\n              return null;\n            }\n\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var ref = this.dataRange.displayRange();\n            var min = ref.min;\n            var max = ref.max;\n            var totalLimits = this.dataRange.total();\n            var scale = size / (max - min);\n            var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n            var from = addTicks(min, offset);\n            var to = addTicks(max, offset);\n            var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n            if (panRange) {\n              panRange.min = toDate(panRange.min);\n              panRange.max = toDate(panRange.max);\n              panRange.baseUnit = options.baseUnit;\n              panRange.baseUnitStep = options.baseUnitStep || 1;\n              panRange.userSetBaseUnit = options.userSetBaseUnit;\n              panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n              return panRange;\n            }\n          },\n          pointsRange: function (start, end) {\n            if (this.isEmpty()) {\n              return null;\n            }\n\n            var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\n            var datesRange = this.dataRange.displayRange();\n            var indicesRange = this.dataRange.displayIndices();\n            var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n            var options = this.options;\n            var min = addTicks(datesRange.min, pointsRange.min * scale);\n            var max = addTicks(datesRange.min, pointsRange.max * scale);\n            return {\n              min: min,\n              max: max,\n              baseUnit: options.userSetBaseUnit || options.baseUnit,\n              baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n          },\n          scaleRange: function (scale, cursor) {\n            if (this.isEmpty()) {\n              return {};\n            }\n\n            var options = this.options;\n            var fit = options.userSetBaseUnit === FIT;\n            var totalLimits = this.dataRange.total();\n            var ref = this.dataRange.displayRange();\n            var rangeMin = ref.min;\n            var rangeMax = ref.max;\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = rangeMax - rangeMin;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = Math.round(position * delta);\n            var maxDelta = Math.round((1 - position) * delta);\n            var ref$1 = this.dataRange.options;\n            var baseUnit = ref$1.baseUnit;\n            var min = new Date(rangeMin.getTime() + minDelta);\n            var max = new Date(rangeMax.getTime() - maxDelta);\n\n            if (fit) {\n              var autoBaseUnitSteps = options.autoBaseUnitSteps;\n              var maxDateGroups = options.maxDateGroups;\n              var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n              var rangeDiff = dateDiff(rangeMax, rangeMin);\n              var diff = dateDiff(max, min);\n              var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n              var autoBaseUnitStep, ticks;\n\n              if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                min = addTicks(rangeMin, ticks);\n                max = addTicks(rangeMax, -ticks);\n              } else if (diff > maxDiff && baseUnit !== YEARS) {\n                var stepIndex = 0;\n\n                do {\n                  baseUnitIndex++;\n                  baseUnit = BASE_UNITS[baseUnitIndex];\n                  stepIndex = 0;\n                  ticks = 2 * TIME_PER_UNIT[baseUnit];\n\n                  do {\n                    autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                    stepIndex++;\n                  } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n\n                if (ticks > 0) {\n                  min = addTicks(rangeMin, -ticks);\n                  max = addTicks(rangeMax, ticks);\n                  min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                  max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                }\n              }\n            }\n\n            if (min && max && dateDiff(max, min) > 0) {\n              return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n              };\n            }\n          },\n          zoomRange: function (scale, cursor) {\n            var totalLimits = this.dataRange.total();\n            var range = this.scaleRange(scale, cursor);\n\n            if (range) {\n              if (range.min < totalLimits.min) {\n                range.min = totalLimits.min;\n              }\n\n              if (range.max > totalLimits.max) {\n                range.max = totalLimits.max;\n              }\n            }\n\n            return range;\n          },\n          range: function () {\n            return this.dataRange.displayRange();\n          },\n          createLabels: function () {\n            CategoryAxis.fn.createLabels.call(this);\n            this.createRangeLabels();\n          },\n          clearLabels: function () {\n            CategoryAxis.fn.clearLabels.call(this);\n            this.rangeLabels = [];\n          },\n          arrangeLabels: function () {\n            this.arrangeRangeLabels();\n            CategoryAxis.fn.arrangeLabels.call(this);\n          },\n          arrangeRangeLabels: function () {\n            var ref = this;\n            var options = ref.options;\n            var rangeLabels = ref.rangeLabels;\n\n            if (rangeLabels.length === 0) {\n              return;\n            }\n\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var mirror = options.rangeLabels.mirror || options.labels.mirror;\n            var firstLabel = rangeLabels[0];\n\n            if (firstLabel) {\n              var position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;\n              this.positionLabel(firstLabel, mirror, position);\n            }\n\n            var lastLabel = rangeLabels[1];\n\n            if (lastLabel) {\n              var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;\n              this.positionLabel(lastLabel, mirror, position$1);\n            }\n          },\n          autoRotateLabels: function () {\n            CategoryAxis.fn.autoRotateLabels.call(this);\n            this.autoRotateRangeLabels();\n          },\n          hideOutOfRangeLabels: function () {\n            CategoryAxis.fn.hideOutOfRangeLabels.call(this);\n            this.hideOverlappingLabels();\n          },\n          hideOverlappingLabels: function () {\n            var ref = this;\n            var rangeLabels = ref.rangeLabels;\n            var labels = ref.labels;\n\n            if (rangeLabels.length === 0) {\n              return;\n            }\n\n            function clip(rangeLabel, label) {\n              if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                label.options.visible = false;\n                return true;\n              }\n\n              return false;\n            }\n\n            var firstRangeLabel = rangeLabels[0];\n\n            if (firstRangeLabel && firstRangeLabel.options.visible) {\n              for (var i = 0; i < labels.length; i++) {\n                var overlaps = clip(firstRangeLabel, labels[i]);\n\n                if (!overlaps) {\n                  break;\n                }\n              }\n            }\n\n            var lastRangeLabel = rangeLabels[1];\n\n            if (lastRangeLabel && lastRangeLabel.options.visible) {\n              for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {\n                var overlaps$1 = clip(lastRangeLabel, labels[i$1]);\n\n                if (!overlaps$1) {\n                  break;\n                }\n              }\n            }\n          },\n          contentBox: function () {\n            var box = CategoryAxis.fn.contentBox.call(this);\n            var rangeLabels = this.rangeLabels;\n\n            for (var i = 0; i < rangeLabels.length; i++) {\n              var label = rangeLabels[i];\n\n              if (label.options.visible) {\n                box.wrap(label.box);\n              }\n            }\n\n            return box;\n          },\n          createAxisLabel: function (index, labelOptions, labelContext) {\n            if (labelContext === void 0) {\n              labelContext = {};\n            }\n\n            var options = this.options;\n            var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n            var date = this.divisionRange.dateAt(index);\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n            labelContext.dataItem = dataItem;\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n\n            if (text) {\n              return new AxisLabel(date, text, index, dataItem, labelOptions);\n            }\n          },\n          createRangeLabels: function () {\n            var this$1 = this;\n            var ref = this.divisionRange;\n            var displayStart = ref.displayStart;\n            var displayEnd = ref.displayEnd;\n            var options = this.options;\n            var labelOptions = $.extend({}, options.labels, options.rangeLabels, {\n              align: CENTER,\n              zIndex: options.zIndex\n            });\n\n            if (labelOptions.visible !== true) {\n              return;\n            }\n\n            this.normalizeLabelRotation(labelOptions);\n            labelOptions.alignRotation = CENTER;\n\n            if (labelOptions.rotation === \"auto\") {\n              labelOptions.rotation = 0;\n              options.autoRotateRangeLabels = true;\n            }\n\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n\n            var createLabel = function (index, date, text) {\n              if (text) {\n                var label = new AxisLabel(date, text, index, null, labelOptions);\n                this$1.append(label);\n                this$1.rangeLabels.push(label);\n              }\n            };\n\n            var startText = this.axisLabelText(displayStart, labelOptions, {\n              index: 0,\n              count: 2\n            });\n            createLabel(0, displayStart, startText);\n            var endText = this.axisLabelText(displayEnd, labelOptions, {\n              index: 1,\n              count: 2\n            });\n            createLabel(1, displayEnd, endText);\n          },\n          autoRotateRangeLabels: function () {\n            var this$1 = this;\n            var labels = this.rangeLabels;\n\n            if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n              return;\n            }\n\n            var rotateLabel = function (label, tickPositions, index) {\n              var width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n              var angle = this$1.autoRotateLabelAngle(label.box, width);\n\n              if (angle !== 0) {\n                label.options.rotation = angle;\n                label.reflow(new Box());\n              }\n            };\n\n            var tickPositions = this.getMajorTickPositions();\n            rotateLabel(labels[0], tickPositions, 0);\n            rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n          },\n          categoryIndex: function (value) {\n            return this.dataRange.valueIndex(value);\n          },\n          slot: function (from, to, limit) {\n            var dateRange = this.dataRange;\n            var start = from;\n            var end = to;\n\n            if (start instanceof Date) {\n              start = dateRange.dateIndex(start);\n            }\n\n            if (end instanceof Date) {\n              end = dateRange.dateIndex(end);\n            }\n\n            var slot = this.getSlot(start, end, limit);\n\n            if (slot) {\n              return slot.toRect();\n            }\n          },\n          getSlot: function (a, b, limit) {\n            var start = a;\n            var end = b;\n\n            if (typeof start === OBJECT) {\n              start = this.categoryIndex(start);\n            }\n\n            if (typeof end === OBJECT) {\n              end = this.categoryIndex(end);\n            }\n\n            return CategoryAxis.fn.getSlot.call(this, start, end, limit);\n          },\n          valueRange: function () {\n            var options = this.options;\n            var range = categoryRange(options.srcCategories);\n            return {\n              min: toDate(range.min),\n              max: toDate(range.max)\n            };\n          },\n          categoryAt: function (index, total) {\n            return this.dataRange.dateAt(index, total);\n          },\n          categoriesCount: function () {\n            return this.dataRange.valuesCount();\n          },\n          rangeIndices: function () {\n            return this.dataRange.displayIndices();\n          },\n          labelsBetweenTicks: function () {\n            return !this.divisionRange.options.justified;\n          },\n          prepareUserOptions: function () {\n            if (this.isEmpty()) {\n              return;\n            }\n\n            this.options.categories = this.dataRange.values();\n          },\n          getCategory: function (point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n              return null;\n            }\n\n            return this.dataRange.dateAt(index);\n          },\n          totalIndex: function (value) {\n            return this.dataRange.totalIndex(value);\n          },\n          currentRangeIndices: function () {\n            var range = this.dataRange.valueRange();\n            return {\n              min: this.dataRange.totalIndex(range.min),\n              max: this.dataRange.totalIndex(range.max)\n            };\n          },\n          totalRange: function () {\n            return this.dataRange.total();\n          },\n          totalCount: function () {\n            return this.dataRange.totalCount();\n          },\n          isEmpty: function () {\n            return !this.options.srcCategories.length;\n          },\n          roundedRange: function () {\n            if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n              return this.range();\n            }\n\n            var options = this.options;\n            var datesRange = categoryRange(options.srcCategories);\n            var dateRange = new DateRange(datesRange.min, datesRange.max, $.extend({}, options, {\n              justified: false,\n              roundToBaseUnit: true,\n              justifyEnd: options.justified\n            }));\n            return dateRange.displayRange();\n          }\n        });\n        setDefaultOptions(DateCategoryAxis, {\n          type: DATE,\n          labels: {\n            dateFormats: DateLabelFormats\n          },\n          rangeLabels: {\n            visible: false\n          },\n          autoBaseUnitSteps: {\n            milliseconds: [1, 10, 100],\n            seconds: [1, 2, 5, 15, 30],\n            minutes: [1, 2, 5, 15, 30],\n            hours: [1, 2, 3],\n            days: [1, 2, 3],\n            weeks: [1, 2],\n            months: [1, 2, 3, 6],\n            years: [1, 2, 3, 5, 10, 25, 50]\n          },\n          maxDateGroups: 10\n        });\n\n        function autoAxisMin(min, max, narrow) {\n          if (!min && !max) {\n            return 0;\n          }\n\n          var axisMin;\n\n          if (min >= 0 && max >= 0) {\n            var minValue = min === max ? 0 : min;\n            var diff = (max - minValue) / max;\n\n            if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {\n              return 0;\n            }\n\n            axisMin = Math.max(0, minValue - (max - minValue) / 2);\n          } else {\n            axisMin = min;\n          }\n\n          return axisMin;\n        }\n\n        function autoAxisMax(min, max, narrow) {\n          if (!min && !max) {\n            return 1;\n          }\n\n          var axisMax;\n\n          if (min <= 0 && max <= 0) {\n            var maxValue = min === max ? 0 : max;\n            var diff = Math.abs((maxValue - min) / maxValue);\n\n            if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {\n              return 0;\n            }\n\n            axisMax = Math.min(0, maxValue - (min - maxValue) / 2);\n          } else {\n            axisMax = max;\n          }\n\n          return axisMax;\n        }\n\n        function floor(value, step) {\n          return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n        }\n\n        function ceil(value, step) {\n          return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n        }\n\n        function limitCoordinate(value) {\n          return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n        }\n\n        var MIN_VALUE_RANGE$1 = Math.pow(10, -DEFAULT_PRECISION + 1);\n        var NumericAxis = Axis.extend({\n          init: function (seriesMin, seriesMax, options, chartService) {\n            Axis.fn.init.call(this, $.extend({}, options, {\n              seriesMin: seriesMin,\n              seriesMax: seriesMax\n            }), chartService);\n          },\n          initUserOptions: function (options) {\n            var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n            this.totalOptions = totalAxisOptions(autoOptions, options);\n            return axisOptions(autoOptions, options);\n          },\n          initFields: function () {\n            this.totalMin = this.totalOptions.min;\n            this.totalMax = this.totalOptions.max;\n            this.totalMajorUnit = this.totalOptions.majorUnit;\n            this.seriesMin = this.options.seriesMin;\n            this.seriesMax = this.options.seriesMax;\n          },\n          clone: function () {\n            return new NumericAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n          },\n          startValue: function () {\n            return 0;\n          },\n          range: function () {\n            var options = this.options;\n            return {\n              min: options.min,\n              max: options.max\n            };\n          },\n          getDivisions: function (stepValue) {\n            if (stepValue === 0) {\n              return 1;\n            }\n\n            var options = this.options;\n            var range = options.max - options.min;\n            return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n          },\n          getTickPositions: function (unit, skipUnit) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var range = options.max - options.min;\n            var scale = lineSize / range;\n            var step = unit * scale;\n            var divisions = this.getDivisions(unit);\n            var positions = [];\n            var pos = lineBox[axisOrigin];\n            var skipStep = 0;\n\n            if (skipUnit) {\n              skipStep = skipUnit / unit;\n            }\n\n            for (var idx = 0; idx < divisions; idx++) {\n              if (idx % skipStep !== 0) {\n                positions.push(round(pos, COORD_PRECISION));\n              }\n\n              pos = pos + step * axisDir;\n            }\n\n            return positions;\n          },\n          getMajorTickPositions: function () {\n            return this.getTickPositions(this.options.majorUnit);\n          },\n          getMinorTickPositions: function () {\n            return this.getTickPositions(this.options.minorUnit);\n          },\n          getSlot: function (a, b, limit) {\n            if (limit === void 0) {\n              limit = false;\n            }\n\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var lineStart = ref.lineStart;\n            var step = axisDir * (lineSize / (options.max - options.min));\n            var start = valueOrDefault(a, b || 0);\n            var end = valueOrDefault(b, a || 0);\n\n            if (limit) {\n              start = limitValue(start, options.min, options.max);\n              end = limitValue(end, options.min, options.max);\n            }\n\n            var p1 = Math.min(start, end) - options.min;\n            var p2 = Math.max(start, end) - options.min;\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n            return slotBox;\n          },\n          getValue: function (point) {\n            var options = this.options;\n            var max = Number(options.max);\n            var min = Number(options.min);\n            var offset = this.pointOffset(point);\n            var valueOffset = offset * (max - min);\n\n            if (offset < 0 || offset > 1) {\n              return null;\n            }\n\n            var value = min + valueOffset;\n            return round(value, DEFAULT_PRECISION);\n          },\n          translateRange: function (delta) {\n            var options = this.options;\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var max = options.max;\n            var min = options.min;\n            var ref = this.lineInfo();\n            var lineSize = ref.lineSize;\n            var range = max - min;\n            var scale = lineSize / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse)) {\n              offset = -offset;\n            }\n\n            return {\n              min: min + offset,\n              max: max + offset,\n              offset: offset\n            };\n          },\n          labelsCount: function () {\n            return this.getDivisions(this.options.majorUnit);\n          },\n          createAxisLabel: function (index, labelOptions, labelContext) {\n            var options = this.options;\n            var value = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n            return new AxisLabel(value, text, index, null, labelOptions);\n          },\n          shouldRenderNote: function (value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n          },\n          pan: function (delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n          },\n          pointsRange: function (start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            if (this.isValidRange(min, max)) {\n              return {\n                min: min,\n                max: max\n              };\n            }\n          },\n          scaleRange: function (scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = round(this.options.min + minDelta, DEFAULT_PRECISION);\n            var max = round(this.options.max - maxDelta, DEFAULT_PRECISION);\n\n            if (max - min < MIN_VALUE_RANGE$1) {\n              max = min + MIN_VALUE_RANGE$1;\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          zoomRange: function (scale, cursor) {\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n            var range = this.scaleRange(scale, cursor);\n            return {\n              min: limitValue(range.min, totalMin, totalMax),\n              max: limitValue(range.max, totalMin, totalMax),\n              narrowRange: false\n            };\n          },\n          isValidRange: function (min, max) {\n            return max - min > MIN_VALUE_RANGE$1;\n          }\n        });\n\n        function autoAxisOptions(seriesMin, seriesMax, options) {\n          var narrowRange = options.narrowRange;\n          var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n          var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n          var majorUnit = autoMajorUnit(autoMin, autoMax);\n          var autoOptions = {\n            majorUnit: majorUnit\n          };\n\n          if (options.roundToMajorUnit !== false) {\n            if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n              autoMin -= majorUnit;\n            }\n\n            if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n              autoMax += majorUnit;\n            }\n          }\n\n          autoOptions.min = floor(autoMin, majorUnit);\n          autoOptions.max = ceil(autoMax, majorUnit);\n          return autoOptions;\n        }\n\n        function totalAxisOptions(autoOptions, options) {\n          return {\n            min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n            max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n            majorUnit: autoOptions.majorUnit\n          };\n        }\n\n        function clearNullValues(options, fields) {\n          for (var idx = 0; idx < fields.length; idx++) {\n            var field = fields[idx];\n\n            if (options[field] === null) {\n              options[field] = undefined;\n            }\n          }\n        }\n\n        function axisOptions(autoOptions, userOptions) {\n          var options = userOptions;\n          var userSetMin, userSetMax;\n\n          if (userOptions) {\n            clearNullValues(userOptions, ['min', 'max']);\n            userSetMin = defined(userOptions.min);\n            userSetMax = defined(userOptions.max);\n            var userSetLimits = userSetMin || userSetMax;\n\n            if (userSetLimits) {\n              if (userOptions.min === userOptions.max) {\n                if (userOptions.min > 0) {\n                  userOptions.min = 0;\n                } else {\n                  userOptions.max = 1;\n                }\n              }\n            }\n\n            if (userOptions.majorUnit) {\n              autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n              autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n            } else if (userSetLimits) {\n              options = deepExtend(autoOptions, userOptions); // Determine an auto major unit after min/max have been set\n\n              autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n            }\n          }\n\n          autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n          var result = deepExtend(autoOptions, options);\n\n          if (result.min >= result.max) {\n            if (userSetMin && !userSetMax) {\n              result.max = result.min + result.majorUnit;\n            } else if (!userSetMin && userSetMax) {\n              result.min = result.max - result.majorUnit;\n            }\n          }\n\n          return result;\n        }\n\n        function remainderClose(value, divisor, ratio) {\n          var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n          var threshold = divisor * (1 - ratio);\n          return remainder === 0 || remainder > threshold;\n        }\n\n        setDefaultOptions(NumericAxis, {\n          type: \"numeric\",\n          min: 0,\n          max: 1,\n          vertical: true,\n          majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n          },\n          labels: {\n            format: \"#.####################\"\n          },\n          zIndex: 1\n        });\n        var MIN_VALUE_RANGE = 1000;\n        var DateValueAxis = Axis.extend({\n          init: function (seriesMin, seriesMax, axisOptions, chartService) {\n            var min = toDate(seriesMin);\n            var max = toDate(seriesMax);\n            var intlService = chartService.intl;\n            var options = axisOptions || {};\n            options = deepExtend(options || {}, {\n              min: parseDate(intlService, options.min),\n              max: parseDate(intlService, options.max),\n              axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),\n              weekStartDay: firstDay(options, intlService)\n            });\n            options = applyDefaults(min, max, options);\n            Axis.fn.init.call(this, options, chartService);\n            this.intlService = intlService;\n            this.seriesMin = min;\n            this.seriesMax = max;\n            var weekStartDay = options.weekStartDay || 0;\n            this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n            this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n          },\n          clone: function () {\n            return new DateValueAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n          },\n          range: function () {\n            var options = this.options;\n            return {\n              min: options.min,\n              max: options.max\n            };\n          },\n          getDivisions: function (stepValue) {\n            var options = this.options;\n            return Math.floor(duration(options.min, options.max, options.baseUnit) / stepValue + 1);\n          },\n          getTickPositions: function (step) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var dir = ref.axisDir;\n            var lineSize = ref.lineSize;\n            var start = ref.lineStart;\n            var divisions = this.getDivisions(step);\n            var timeRange = dateDiff(options.max, options.min);\n            var scale = lineSize / timeRange;\n            var weekStartDay = options.weekStartDay || 0;\n            var positions = [start];\n\n            for (var i = 1; i < divisions; i++) {\n              var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n              var pos = start + dateDiff(date, options.min) * scale * dir;\n              positions.push(round(pos, COORD_PRECISION));\n            }\n\n            return positions;\n          },\n          getMajorTickPositions: function () {\n            return this.getTickPositions(this.options.majorUnit);\n          },\n          getMinorTickPositions: function () {\n            return this.getTickPositions(this.options.minorUnit);\n          },\n          getSlot: function (a, b, limit) {\n            return NumericAxis.prototype.getSlot.call(this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit);\n          },\n          getValue: function (point) {\n            var value = NumericAxis.prototype.getValue.call(this, point);\n            return value !== null ? toDate(value) : null;\n          },\n          labelsCount: function () {\n            return this.getDivisions(this.options.majorUnit);\n          },\n          createAxisLabel: function (index, labelOptions, labelContext) {\n            var options = this.options;\n            var offset = index * options.majorUnit;\n            var weekStartDay = options.weekStartDay || 0;\n            var date = options.min;\n\n            if (offset > 0) {\n              date = addDuration(date, offset, options.baseUnit, weekStartDay);\n            }\n\n            var unitFormat = labelOptions.dateFormats[options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n            return new AxisLabel(date, text, index, null, labelOptions);\n          },\n          translateRange: function (delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / dateDiff(range.max, range.min);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse)) {\n              offset = -offset;\n            }\n\n            var from = addTicks(options.min, offset);\n            var to = addTicks(options.max, offset);\n            return {\n              min: from,\n              max: to,\n              offset: offset\n            };\n          },\n          shouldRenderNote: function (value) {\n            var range = this.range();\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n          },\n          pan: function (delta) {\n            var range = this.translateRange(delta, true);\n            var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n            if (limittedRange) {\n              return {\n                min: toDate(limittedRange.min),\n                max: toDate(limittedRange.max)\n              };\n            }\n          },\n          pointsRange: function (start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n            return {\n              min: toDate(min),\n              max: toDate(max)\n            };\n          },\n          scaleRange: function (scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = toDate(toTime(this.options.min) + minDelta);\n            var max = toDate(toTime(this.options.max) - maxDelta);\n\n            if (max - min < MIN_VALUE_RANGE) {\n              max = toDate(toTime(min) + MIN_VALUE_RANGE);\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          zoomRange: function (scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n            var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n            return {\n              min: min,\n              max: max\n            };\n          }\n        });\n\n        function timeUnits(delta) {\n          var unit = HOURS;\n\n          if (delta >= TIME_PER_YEAR) {\n            unit = YEARS;\n          } else if (delta >= TIME_PER_MONTH) {\n            unit = MONTHS;\n          } else if (delta >= TIME_PER_WEEK) {\n            unit = WEEKS;\n          } else if (delta >= TIME_PER_DAY) {\n            unit = DAYS;\n          }\n\n          return unit;\n        }\n\n        function applyDefaults(seriesMin, seriesMax, options) {\n          var min = options.min || seriesMin;\n          var max = options.max || seriesMax;\n          var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n          var baseUnitTime = TIME_PER_UNIT[baseUnit];\n          var weekStartDay = options.weekStartDay || 0;\n          var autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n          var autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n          var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n          var majorUnit = userMajorUnit || ceil(autoMajorUnit(autoMin.getTime(), autoMax.getTime()), baseUnitTime) / baseUnitTime;\n          var actualUnits = duration(autoMin, autoMax, baseUnit);\n          var totalUnits = ceil(actualUnits, majorUnit);\n          var unitsToAdd = totalUnits - actualUnits;\n          var head = Math.floor(unitsToAdd / 2);\n          var tail = unitsToAdd - head;\n\n          if (!options.baseUnit) {\n            delete options.baseUnit;\n          }\n\n          options.baseUnit = options.baseUnit || baseUnit;\n          options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n          options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n          options.minorUnit = options.minorUnit || majorUnit / 5;\n          options.majorUnit = majorUnit;\n          return options;\n        }\n\n        setDefaultOptions(DateValueAxis, {\n          type: DATE,\n          majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n          },\n          labels: {\n            dateFormats: DateLabelFormats\n          }\n        });\n        var DEFAULT_MAJOR_UNIT = 10;\n        var MIN_VALUE_RANGE$2 = 1e-6;\n        var LogarithmicAxis = Axis.extend({\n          init: function (seriesMin, seriesMax, options, chartService) {\n            var axisOptions = deepExtend({\n              majorUnit: DEFAULT_MAJOR_UNIT,\n              min: seriesMin,\n              max: seriesMax\n            }, options);\n            var base = axisOptions.majorUnit;\n            var autoMax = autoAxisMax$1(seriesMax, base);\n            var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\n            var range = initRange(autoMin, autoMax, axisOptions, options);\n            axisOptions.max = range.max;\n            axisOptions.min = range.min;\n            axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n            Axis.fn.init.call(this, axisOptions, chartService);\n            this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n            this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n            this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n            this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n            this.seriesMin = seriesMin;\n            this.seriesMax = seriesMax;\n            this.createLabels();\n          },\n          clone: function () {\n            return new LogarithmicAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n          },\n          startValue: function () {\n            return this.options.min;\n          },\n          getSlot: function (a, b, limit) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var min = options.min;\n            var max = options.max;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineBox = ref$1.lineBox;\n            var lineSize = ref$1.lineSize;\n            var lineStart = ref$1.lineStart;\n            var step = axisDir * (lineSize / (logMax - logMin));\n            var start = valueOrDefault(a, b || 1);\n            var end = valueOrDefault(b, a || 1);\n\n            if (start <= 0 || end <= 0) {\n              return null;\n            }\n\n            if (limit) {\n              start = limitValue(start, min, max);\n              end = limitValue(end, min, max);\n            }\n\n            start = log(start, base);\n            end = log(end, base);\n            var p1 = Math.min(start, end) - logMin;\n            var p2 = Math.max(start, end) - logMin;\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n            return slotBox;\n          },\n          getValue: function (point) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineStart = ref$1.lineStart;\n            var lineSize = ref$1.lineSize;\n            var step = (logMax - logMin) / lineSize;\n            var offset = axisDir * (point[axis] - lineStart);\n            var valueOffset = offset * step;\n\n            if (offset < 0 || offset > lineSize) {\n              return null;\n            }\n\n            var value = logMin + valueOffset;\n            return round(Math.pow(base, value), DEFAULT_PRECISION);\n          },\n          range: function () {\n            var options = this.options;\n            return {\n              min: options.min,\n              max: options.max\n            };\n          },\n          translateRange: function (delta) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var reverse = options.reverse;\n            var vertical = options.vertical;\n            var base = options.majorUnit;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var scale = size / (logMax - logMin);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse)) {\n              offset = -offset;\n            }\n\n            return {\n              min: Math.pow(base, logMin + offset),\n              max: Math.pow(base, logMax + offset),\n              offset: offset\n            };\n          },\n          labelsCount: function () {\n            var floorMax = Math.floor(this.logMax);\n            var count = Math.floor(floorMax - this.logMin) + 1;\n            return count;\n          },\n          getMajorTickPositions: function () {\n            var ticks = [];\n            this.traverseMajorTicksPositions(function (position) {\n              ticks.push(position);\n            }, {\n              step: 1,\n              skip: 0\n            });\n            return ticks;\n          },\n          createTicks: function (lineGroup) {\n            var options = this.options;\n            var majorTicks = options.majorTicks;\n            var minorTicks = options.minorTicks;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var lineBox = this.lineBox();\n            var ticks = [];\n            var tickLineOptions = {\n              // TODO\n              // _alignLines: options._alignLines,\n              vertical: vertical\n            };\n\n            function render(tickPosition, tickOptions) {\n              tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n              tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n              tickLineOptions.position = tickPosition;\n              lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n            }\n\n            if (majorTicks.visible) {\n              this.traverseMajorTicksPositions(render, majorTicks);\n            }\n\n            if (minorTicks.visible) {\n              this.traverseMinorTicksPositions(render, minorTicks);\n            }\n\n            return ticks;\n          },\n          createGridLines: function (altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var vertical = options.vertical;\n            var lineBox = altAxis.lineBox();\n            var lineOptions = {\n              lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n              lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n              vertical: vertical\n            };\n            var majorTicks = [];\n            var container = this.gridLinesVisual();\n\n            function render(tickPosition, gridLine) {\n              if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n                majorTicks.push(tickPosition);\n              }\n            }\n\n            if (majorGridLines.visible) {\n              this.traverseMajorTicksPositions(render, majorGridLines);\n            }\n\n            if (minorGridLines.visible) {\n              this.traverseMinorTicksPositions(render, minorGridLines);\n            }\n\n            return container.children;\n          },\n          traverseMajorTicksPositions: function (callback, tickOptions) {\n            var ref = this.lineInfo();\n            var lineStart = ref.lineStart;\n            var step = ref.step;\n            var ref$1 = this;\n            var logMin = ref$1.logMin;\n            var logMax = ref$1.logMax;\n\n            for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n              var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n              callback(position, tickOptions);\n            }\n          },\n          traverseMinorTicksPositions: function (callback, tickOptions) {\n            var this$1 = this;\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var ref$1 = this.lineInfo();\n            var lineStart = ref$1.lineStart;\n            var step = ref$1.step;\n            var ref$2 = this;\n            var logMin = ref$2.logMin;\n            var logMax = ref$2.logMax;\n            var start = Math.floor(logMin);\n\n            for (var power = start; power < logMax; power++) {\n              var minorOptions = this$1._minorIntervalOptions(power);\n\n              for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                var value = minorOptions.value + idx * minorOptions.minorStep;\n\n                if (value > max) {\n                  break;\n                }\n\n                if (value >= min) {\n                  var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                  callback(position, tickOptions);\n                }\n              }\n            }\n          },\n          createAxisLabel: function (index, labelOptions, labelContext) {\n            var power = Math.ceil(this.logMin + index);\n            var value = Math.pow(this.options.majorUnit, power);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n            return new AxisLabel(value, text, index, null, labelOptions);\n          },\n          shouldRenderNote: function (value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n          },\n          pan: function (delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n          },\n          pointsRange: function (start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n            return {\n              min: min,\n              max: max\n            };\n          },\n          scaleRange: function (scale, cursor) {\n            var ref = this.options;\n            var base = ref.majorUnit;\n            var logMin = log(this.options.min, base);\n            var logMax = log(this.options.max, base);\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = logMax - logMin;\n            var delta = this.scaleToDelta(scale, range);\n            var min = Math.pow(base, logMin + position * delta);\n            var max = Math.pow(base, logMax - (1 - position) * delta);\n\n            if (max - min < MIN_VALUE_RANGE$2) {\n              max = min + MIN_VALUE_RANGE$2;\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          zoomRange: function (scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n            return {\n              min: limitValue(range.min, totalMin, totalMax),\n              max: limitValue(range.max, totalMin, totalMax)\n            };\n          },\n          _minorIntervalOptions: function (power) {\n            var ref = this.options;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var value = Math.pow(base, power);\n            var nextValue = Math.pow(base, power + 1);\n            var difference = nextValue - value;\n            var minorStep = difference / minorUnit;\n            return {\n              value: value,\n              minorStep: minorStep\n            };\n          },\n          lineInfo: function () {\n            var info = Axis.fn.lineInfo.call(this);\n            info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n            return info;\n          }\n        });\n\n        function initRange(autoMin, autoMax, axisOptions, options) {\n          var min = axisOptions.min;\n          var max = axisOptions.max;\n\n          if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n            throwNegativeValuesError();\n          }\n\n          if (!defined(options.max)) {\n            max = autoMax;\n          } else if (options.max <= 0) {\n            throwNegativeValuesError();\n          }\n\n          if (!defined(options.min)) {\n            min = autoMin;\n          } else if (options.min <= 0) {\n            throwNegativeValuesError();\n          }\n\n          return {\n            min: min,\n            max: max\n          };\n        }\n\n        function autoAxisMin$1(min, max, options) {\n          var base = options.majorUnit;\n          var autoMin = min;\n\n          if (min <= 0) {\n            autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n          } else if (!options.narrowRange) {\n            autoMin = Math.pow(base, Math.floor(log(min, base)));\n          }\n\n          return autoMin;\n        }\n\n        function autoAxisMax$1(max, base) {\n          var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n          var autoMax;\n\n          if (max <= 0) {\n            autoMax = base;\n          } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n            autoMax = Math.pow(base, log(max, base) + 0.2);\n          } else {\n            autoMax = Math.pow(base, Math.ceil(log(max, base)));\n          }\n\n          return autoMax;\n        }\n\n        function throwNegativeValuesError() {\n          throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n        }\n\n        function log(x, base) {\n          return Math.log(x) / Math.log(base);\n        }\n\n        setDefaultOptions(LogarithmicAxis, {\n          type: \"log\",\n          majorUnit: DEFAULT_MAJOR_UNIT,\n          minorUnit: 1,\n          axisCrossingValue: 1,\n          vertical: true,\n          majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n          },\n          zIndex: 1,\n          _deferLabels: true\n        });\n        var GridLinesMixin = {\n          createGridLines: function (altAxis) {\n            var options = this.options;\n            var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n            var gridLines = [];\n            var skipMajor = false;\n            var majorAngles, minorAngles;\n\n            if (options.majorGridLines.visible) {\n              majorAngles = this.majorGridLineAngles(altAxis);\n              skipMajor = true;\n              gridLines = this.renderMajorGridLines(majorAngles, radius, options.majorGridLines);\n            }\n\n            if (options.minorGridLines.visible) {\n              minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n              append(gridLines, this.renderMinorGridLines(minorAngles, radius, options.minorGridLines, altAxis, skipMajor));\n            }\n\n            return gridLines;\n          },\n          renderMajorGridLines: function (angles, radius, options) {\n            return this.renderGridLines(angles, radius, options);\n          },\n          renderMinorGridLines: function (angles, radius, options, altAxis, skipMajor) {\n            var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n            return this.renderGridLines(angles, radius, options, radiusCallback);\n          },\n          renderGridLines: function (angles, radius, options, radiusCallback) {\n            var style = {\n              stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n              }\n            };\n            var center = this.box.center();\n            var circle = new Circle([center.x, center.y], radius);\n            var container = this.gridLinesVisual();\n\n            for (var i = 0; i < angles.length; i++) {\n              var line = new Path(style);\n\n              if (radiusCallback) {\n                circle.radius = radiusCallback(angles[i]);\n              }\n\n              line.moveTo(circle.center).lineTo(circle.pointAt(angles[i] + 180));\n              container.append(line);\n            }\n\n            return container.children;\n          },\n          gridLineAngles: function (altAxis, size, skip, step, skipAngles) {\n            var this$1 = this;\n            var divs = this.intervals(size, skip, step, skipAngles);\n            var options = altAxis.options;\n            var altAxisVisible = options.visible && (options.line || {}).visible !== false;\n            return map(divs, function (d) {\n              var alpha = this$1.intervalAngle(d);\n\n              if (!altAxisVisible || alpha !== 90) {\n                return alpha;\n              }\n            });\n          }\n        };\n        var RadarCategoryAxis = CategoryAxis.extend({\n          range: function () {\n            return {\n              min: 0,\n              max: this.options.categories.length\n            };\n          },\n          reflow: function (box) {\n            this.box = box;\n            this.reflowLabels();\n          },\n          lineBox: function () {\n            return this.box;\n          },\n          reflowLabels: function () {\n            var this$1 = this;\n            var ref = this;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n            var measureBox = new Box();\n\n            for (var i = 0; i < labels.length; i++) {\n              labels[i].reflow(measureBox);\n              var labelBox = labels[i].box;\n              labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(0, labelBox.width(), labelBox.height()));\n            }\n          },\n          intervals: function (size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) {\n              skipAngles = false;\n            }\n\n            var options = this.options;\n            var categories = options.categories.length;\n            var divCount = categories / size || 1;\n            var divAngle = 360 / divCount;\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n            var divs = [];\n            var angle = 0;\n\n            for (var i = skip; i < divCount; i += step) {\n              if (options.reverse) {\n                angle = 360 - i * divAngle;\n              } else {\n                angle = i * divAngle;\n              }\n\n              angle = round(angle, COORD_PRECISION) % 360;\n\n              if (!(skipAngles && inArray(angle, skipAngles))) {\n                divs.push(angle);\n              }\n            }\n\n            return divs;\n          },\n          majorIntervals: function () {\n            return this.intervals(1);\n          },\n          minorIntervals: function () {\n            return this.intervals(0.5);\n          },\n          intervalAngle: function (interval) {\n            return (360 + interval + this.options.startAngle) % 360;\n          },\n          majorAngles: function () {\n            var this$1 = this;\n            return map(this.majorIntervals(), function (interval) {\n              return this$1.intervalAngle(interval);\n            });\n          },\n          createLine: function () {\n            return [];\n          },\n          majorGridLineAngles: function (altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n          },\n          minorGridLineAngles: function (altAxis, skipMajor) {\n            var ref = this.options;\n            var minorGridLines = ref.minorGridLines;\n            var majorGridLines = ref.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n            return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n          },\n          radiusCallback: function (radius, altAxis, skipMajor) {\n            if (altAxis.options.type !== ARC) {\n              var minorAngle = rad(360 / (this.options.categories.length * 2));\n              var minorRadius = Math.cos(minorAngle) * radius;\n              var majorAngles = this.majorAngles();\n\n              var radiusCallback = function (angle) {\n                if (!skipMajor && inArray(angle, majorAngles)) {\n                  return radius;\n                }\n\n                return minorRadius;\n              };\n\n              return radiusCallback;\n            }\n          },\n          createPlotBands: function () {\n            var this$1 = this;\n            var plotBands = this.options.plotBands || [];\n            var group = this._plotbandGroup = new Group({\n              zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n              var band = plotBands[i];\n              var slot = this$1.plotBandSlot(band);\n              var singleSlot = this$1.getSlot(band.from);\n              var head = band.from - Math.floor(band.from);\n              slot.startAngle += head * singleSlot.angle;\n              var tail = Math.ceil(band.to) - band.to;\n              slot.angle -= (tail + head) * singleSlot.angle;\n              var ring = ShapeBuilder.current.createRing(slot, {\n                fill: {\n                  color: band.color,\n                  opacity: band.opacity\n                },\n                stroke: {\n                  opacity: band.opacity\n                }\n              });\n              group.append(ring);\n            }\n\n            this.appendVisual(group);\n          },\n          plotBandSlot: function (band) {\n            return this.getSlot(band.from, band.to - 1);\n          },\n          getSlot: function (from, to) {\n            var options = this.options;\n            var justified = options.justified;\n            var box = this.box;\n            var divs = this.majorAngles();\n            var totalDivs = divs.length;\n            var slotAngle = 360 / totalDivs;\n            var fromValue = from;\n\n            if (options.reverse && !justified) {\n              fromValue = (fromValue + 1) % totalDivs;\n            }\n\n            fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n            var slotStart = divs[fromValue];\n\n            if (justified) {\n              slotStart = slotStart - slotAngle / 2;\n\n              if (slotStart < 0) {\n                slotStart += 360;\n              }\n            }\n\n            var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n            var slots = toValue - fromValue + 1;\n            var angle = slotAngle * slots;\n            return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n          },\n          slot: function (from, to) {\n            var slot = this.getSlot(from, to);\n            var startAngle = slot.startAngle + 180;\n            var endAngle = startAngle + slot.angle;\n            return new geometry.Arc([slot.center.x, slot.center.y], {\n              startAngle: startAngle,\n              endAngle: endAngle,\n              radiusX: slot.radius,\n              radiusY: slot.radius\n            });\n          },\n          pointCategoryIndex: function (point) {\n            var this$1 = this;\n            var length = this.options.categories.length;\n            var index = null;\n\n            for (var i = 0; i < length; i++) {\n              var slot = this$1.getSlot(i);\n\n              if (slot.containsPoint(point)) {\n                index = i;\n                break;\n              }\n            }\n\n            return index;\n          }\n        });\n        setDefaultOptions(RadarCategoryAxis, {\n          startAngle: 90,\n          labels: {\n            margin: getSpacing(10)\n          },\n          majorGridLines: {\n            visible: true\n          },\n          justified: true\n        });\n        deepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\n        var PolarAxis = Axis.extend({\n          init: function (options, chartService) {\n            Axis.fn.init.call(this, options, chartService);\n            var instanceOptions = this.options;\n            instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n          },\n          getDivisions: function (stepValue) {\n            return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n          },\n          reflow: function (box) {\n            this.box = box;\n            this.reflowLabels();\n          },\n          reflowLabels: function () {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n            var measureBox = new Box();\n            var divs = this.intervals(options.majorUnit, skip, step);\n\n            for (var i = 0; i < labels.length; i++) {\n              labels[i].reflow(measureBox);\n              var labelBox = labels[i].box;\n              labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n            }\n          },\n          lineBox: function () {\n            return this.box;\n          },\n          intervals: function (size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) {\n              skipAngles = false;\n            }\n\n            var min = this.options.min;\n            var divisions = this.getDivisions(size);\n            var divs = [];\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n\n            for (var i = skip; i < divisions; i += step) {\n              var current = (360 + min + i * size) % 360;\n\n              if (!(skipAngles && inArray(current, skipAngles))) {\n                divs.push(current);\n              }\n            }\n\n            return divs;\n          },\n          majorIntervals: function () {\n            return this.intervals(this.options.majorUnit);\n          },\n          minorIntervals: function () {\n            return this.intervals(this.options.minorUnit);\n          },\n          intervalAngle: function (i) {\n            return (540 - i - this.options.startAngle) % 360;\n          },\n          createLine: function () {\n            return [];\n          },\n          majorGridLineAngles: function (altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n          },\n          minorGridLineAngles: function (altAxis, skipMajor) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n            return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n          },\n          plotBandSlot: function (band) {\n            return this.getSlot(band.from, band.to);\n          },\n          getSlot: function (a, b) {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var startAngle = options.startAngle;\n            var start = limitValue(a, options.min, options.max);\n            var end = limitValue(b || start, start, options.max);\n\n            if (options.reverse) {\n              start *= -1;\n              end *= -1;\n            }\n\n            start = (540 - start - startAngle) % 360;\n            end = (540 - end - startAngle) % 360;\n\n            if (end < start) {\n              var tmp = start;\n              start = end;\n              end = tmp;\n            }\n\n            return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n          },\n          slot: function (from, to) {\n            if (to === void 0) {\n              to = from;\n            }\n\n            var options = this.options;\n            var start = 360 - options.startAngle;\n            var slot = this.getSlot(from, to);\n            var min = Math.min(from, to);\n            var max = Math.max(from, to);\n            var startAngle, endAngle;\n\n            if (options.reverse) {\n              startAngle = min;\n              endAngle = max;\n            } else {\n              startAngle = 360 - max;\n              endAngle = 360 - min;\n            }\n\n            startAngle = (startAngle + start) % 360;\n            endAngle = (endAngle + start) % 360;\n            return new geometry.Arc([slot.center.x, slot.center.y], {\n              startAngle: startAngle,\n              endAngle: endAngle,\n              radiusX: slot.radius,\n              radiusY: slot.radius\n            });\n          },\n          getValue: function (point) {\n            var options = this.options;\n            var center = this.box.center();\n            var dx = point.x - center.x;\n            var dy = point.y - center.y;\n            var theta = Math.round(deg(Math.atan2(dy, dx)));\n            var start = options.startAngle;\n\n            if (!options.reverse) {\n              theta *= -1;\n              start *= -1;\n            }\n\n            return (theta + start + 360) % 360;\n          },\n          valueRange: function () {\n            return {\n              min: 0,\n              max: Math.PI * 2\n            };\n          }\n        });\n        setDefaultOptions(PolarAxis, {\n          type: \"polar\",\n          startAngle: 0,\n          reverse: false,\n          majorUnit: 60,\n          min: 0,\n          max: 360,\n          labels: {\n            margin: getSpacing(10)\n          },\n          majorGridLines: {\n            color: BLACK,\n            visible: true,\n            width: 1\n          },\n          minorGridLines: {\n            color: \"#aaa\"\n          }\n        });\n        deepExtend(PolarAxis.prototype, GridLinesMixin, {\n          createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n          majorAngles: RadarCategoryAxis.prototype.majorAngles,\n          range: NumericAxis.prototype.range,\n          labelsCount: NumericAxis.prototype.labelsCount,\n          createAxisLabel: NumericAxis.prototype.createAxisLabel\n        });\n        var RadarNumericAxisMixin = {\n          options: {\n            majorGridLines: {\n              visible: true\n            }\n          },\n          createPlotBands: function () {\n            var this$1 = this;\n            var ref = this.options;\n            var type = ref.majorGridLines.type;\n            var plotBands = ref.plotBands;\n\n            if (plotBands === void 0) {\n              plotBands = [];\n            }\n\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var group = this._plotbandGroup = new Group({\n              zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n              var band = plotBands[i];\n              var bandStyle = {\n                fill: {\n                  color: band.color,\n                  opacity: band.opacity\n                },\n                stroke: {\n                  opacity: band.opacity\n                }\n              };\n              var slot = this$1.getSlot(band.from, band.to, true);\n              var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n              var shape = void 0;\n\n              if (type === ARC) {\n                shape = ShapeBuilder.current.createRing(ring, bandStyle);\n              } else {\n                shape = Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n              }\n\n              group.append(shape);\n            }\n\n            this.appendVisual(group);\n          },\n          plotBandPoints: function (ring, angles) {\n            var innerPoints = [];\n            var outerPoints = [];\n            var center = [ring.center.x, ring.center.y];\n            var innerCircle = new Circle(center, ring.innerRadius);\n            var outerCircle = new Circle(center, ring.radius);\n\n            for (var i = 0; i < angles.length; i++) {\n              innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n              outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n            }\n\n            innerPoints.reverse();\n            innerPoints.push(innerPoints[0]);\n            outerPoints.push(outerPoints[0]);\n            return outerPoints.concat(innerPoints);\n          },\n          createGridLines: function (altAxis) {\n            var options = this.options;\n            var majorTicks = this.radarMajorGridLinePositions();\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var gridLines = [];\n\n            if (options.majorGridLines.visible) {\n              gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);\n            }\n\n            if (options.minorGridLines.visible) {\n              var minorTicks = this.radarMinorGridLinePositions();\n              append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));\n            }\n\n            return gridLines;\n          },\n          renderGridLines: function (center, ticks, angles, options) {\n            var style = {\n              stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n              }\n            };\n            var skip = options.skip;\n\n            if (skip === void 0) {\n              skip = 0;\n            }\n\n            var step = options.step;\n\n            if (step === void 0) {\n              step = 0;\n            }\n\n            var container = this.gridLinesVisual();\n\n            for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n              var tickRadius = center.y - ticks[tickIx];\n\n              if (tickRadius > 0) {\n                var circle = new Circle([center.x, center.y], tickRadius);\n\n                if (options.type === ARC) {\n                  container.append(new drawing.Circle(circle, style));\n                } else {\n                  var line = new Path(style);\n\n                  for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n                    line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                  }\n\n                  line.close();\n                  container.append(line);\n                }\n              }\n            }\n\n            return container.children;\n          },\n          getValue: function (point) {\n            var lineBox = this.lineBox();\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var radius = point.distanceTo(center);\n            var distance = radius;\n\n            if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n              var dx = point.x - center.x;\n              var dy = point.y - center.y;\n              var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n              majorAngles.sort(function (a, b) {\n                return angularDistance(a, theta) - angularDistance(b, theta);\n              }); // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n              // Angles are derived from triangle (center, point, gridline X)\n\n              var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n              var alpha = angularDistance(theta, majorAngles[0]);\n              var gamma = 90 - midAngle;\n              var beta = 180 - alpha - gamma;\n              distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n            }\n\n            return this.axisType().prototype.getValue.call(this, new Point(lineBox.x1, lineBox.y2 - distance));\n          }\n        };\n\n        function angularDistance(a, b) {\n          return 180 - Math.abs(Math.abs(a - b) - 180);\n        }\n\n        var RadarNumericAxis = NumericAxis.extend({\n          radarMajorGridLinePositions: function () {\n            return this.getTickPositions(this.options.majorUnit);\n          },\n          radarMinorGridLinePositions: function () {\n            var options = this.options;\n            var minorSkipStep = 0;\n\n            if (options.majorGridLines.visible) {\n              minorSkipStep = options.majorUnit;\n            }\n\n            return this.getTickPositions(options.minorUnit, minorSkipStep);\n          },\n          axisType: function () {\n            return NumericAxis;\n          }\n        });\n        deepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\n        var RadarLogarithmicAxis = LogarithmicAxis.extend({\n          radarMajorGridLinePositions: function () {\n            var positions = [];\n            this.traverseMajorTicksPositions(function (position) {\n              positions.push(position);\n            }, this.options.majorGridLines);\n            return positions;\n          },\n          radarMinorGridLinePositions: function () {\n            var positions = [];\n            this.traverseMinorTicksPositions(function (position) {\n              positions.push(position);\n            }, this.options.minorGridLines);\n            return positions;\n          },\n          axisType: function () {\n            return LogarithmicAxis;\n          }\n        });\n        deepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\n        var WEIGHT = 0.333;\n        var EXTREMUM_ALLOWED_DEVIATION = 0.01;\n        var CurveProcessor = Class.extend({\n          init: function (closed) {\n            this.closed = closed;\n          },\n          process: function (dataPoints) {\n            var this$1 = this;\n            var points = dataPoints.slice(0);\n            var segments = [];\n            var closed = this.closed;\n            var length = points.length;\n\n            if (length > 2) {\n              this.removeDuplicates(0, points);\n              length = points.length;\n            }\n\n            if (length < 2 || length === 2 && points[0].equals(points[1])) {\n              return segments;\n            }\n\n            var p0 = points[0];\n            var p1 = points[1];\n            var p2 = points[2];\n            segments.push(new Segment(p0));\n\n            while (p0.equals(points[length - 1])) {\n              closed = true;\n              points.pop();\n              length--;\n            }\n\n            if (length === 2) {\n              var tangent = this.tangent(p0, p1, X, Y);\n              last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));\n              segments.push(new Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));\n              return segments;\n            }\n\n            var initialControlPoint, lastControlPoint;\n\n            if (closed) {\n              p0 = points[length - 1];\n              p1 = points[0];\n              p2 = points[1];\n              var controlPoints = this.controlPoints(p0, p1, p2);\n              initialControlPoint = controlPoints[1];\n              lastControlPoint = controlPoints[0];\n            } else {\n              var tangent$1 = this.tangent(p0, p1, X, Y);\n              initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n            }\n\n            var cp0 = initialControlPoint;\n\n            for (var idx = 0; idx <= length - 3; idx++) {\n              this$1.removeDuplicates(idx, points);\n              length = points.length;\n\n              if (idx + 3 <= length) {\n                p0 = points[idx];\n                p1 = points[idx + 1];\n                p2 = points[idx + 2];\n                var controlPoints$1 = this$1.controlPoints(p0, p1, p2);\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints$1[1];\n                var cp1 = controlPoints$1[0];\n                segments.push(new Segment(p1, cp1));\n              }\n            }\n\n            if (closed) {\n              p0 = points[length - 2];\n              p1 = points[length - 1];\n              p2 = points[0];\n              var controlPoints$2 = this.controlPoints(p0, p1, p2);\n              last(segments).controlOut(cp0);\n              segments.push(new Segment(p1, controlPoints$2[0]));\n              last(segments).controlOut(controlPoints$2[1]);\n              segments.push(new Segment(p2, lastControlPoint));\n            } else {\n              var tangent$2 = this.tangent(p1, p2, X, Y);\n              last(segments).controlOut(cp0);\n              segments.push(new Segment(p2, this.secondControlPoint(tangent$2, p1, p2, X, Y)));\n            }\n\n            return segments;\n          },\n          removeDuplicates: function (idx, points) {\n            while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n              points.splice(idx + 1, 1);\n            }\n          },\n          invertAxis: function (p0, p1, p2) {\n            var invertAxis = false;\n\n            if (p0.x === p1.x) {\n              invertAxis = true;\n            } else if (p1.x === p2.x) {\n              if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n                invertAxis = true;\n              }\n            } else {\n              var fn = this.lineFunction(p0, p1);\n              var y2 = this.calculateFunction(fn, p2.x);\n\n              if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n              }\n            }\n\n            return invertAxis;\n          },\n          isLine: function (p0, p1, p2) {\n            var fn = this.lineFunction(p0, p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n            return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n          },\n          lineFunction: function (p1, p2) {\n            var a = (p2.y - p1.y) / (p2.x - p1.x);\n            var b = p1.y - a * p1.x;\n            return [b, a];\n          },\n          controlPoints: function (p0, p1, p2) {\n            var xField = X;\n            var yField = Y;\n            var restrict = false;\n            var switchOrientation = false;\n            var tangent;\n\n            if (this.isLine(p0, p1, p2)) {\n              tangent = this.tangent(p0, p1, X, Y);\n            } else {\n              var monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n              };\n\n              if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n              } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                  xField = Y;\n                  yField = X;\n                }\n\n                if (monotonic[xField]) {\n                  tangent = 0;\n                } else {\n                  var sign;\n\n                  if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n                    sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                  } else {\n                    sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                  }\n\n                  tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                  switchOrientation = true;\n                }\n              }\n            }\n\n            var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n            if (switchOrientation) {\n              var oldXField = xField;\n              xField = yField;\n              yField = oldXField;\n            }\n\n            var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n            if (restrict) {\n              this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n              this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n            }\n\n            return [secondControlPoint, firstControlPoint];\n          },\n          restrictControlPoint: function (p1, p2, cp, tangent) {\n            if (p1.y < p2.y) {\n              if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n              } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n              }\n            } else {\n              if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n              } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n              }\n            }\n          },\n          tangent: function (p0, p1, xField, yField) {\n            var x = p1[xField] - p0[xField];\n            var y = p1[yField] - p0[yField];\n            var tangent;\n\n            if (x === 0) {\n              tangent = 0;\n            } else {\n              tangent = y / x;\n            }\n\n            return tangent;\n          },\n          isMonotonicByField: function (p0, p1, p2, field) {\n            return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n          },\n          firstControlPoint: function (tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n            return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n          },\n          secondControlPoint: function (tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n            return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n          },\n          point: function (xValue, yValue, xField, yField) {\n            var controlPoint = new geometry.Point();\n            controlPoint[xField] = xValue;\n            controlPoint[yField] = yValue;\n            return controlPoint;\n          },\n          calculateFunction: function (fn, x) {\n            var length = fn.length;\n            var result = 0;\n\n            for (var i = 0; i < length; i++) {\n              result += Math.pow(x, i) * fn[i];\n            }\n\n            return result;\n          }\n        });\n\n        function numberSign(value) {\n          return value <= 0 ? -1 : 1;\n        }\n\n        dataviz.Gradients = GRADIENTS;\n        kendo.deepExtend(kendo.dataviz, {\n          constants: constants,\n          services: services,\n          autoMajorUnit: autoMajorUnit,\n          Point: Point,\n          Box: Box,\n          Ring: Ring,\n          Sector: Sector,\n          ShapeBuilder: ShapeBuilder,\n          ShapeElement: ShapeElement,\n          ChartElement: ChartElement,\n          BoxElement: BoxElement,\n          RootElement: RootElement,\n          FloatElement: FloatElement,\n          Text: Text,\n          TextBox: TextBox,\n          Title: Title,\n          AxisLabel: AxisLabel,\n          Axis: Axis,\n          Note: Note,\n          CategoryAxis: CategoryAxis,\n          DateCategoryAxis: DateCategoryAxis,\n          DateValueAxis: DateValueAxis,\n          NumericAxis: NumericAxis,\n          LogarithmicAxis: LogarithmicAxis,\n          PolarAxis: PolarAxis,\n          RadarCategoryAxis: RadarCategoryAxis,\n          RadarNumericAxis: RadarNumericAxis,\n          RadarLogarithmicAxis: RadarLogarithmicAxis,\n          CurveProcessor: CurveProcessor,\n          rectToBox: rectToBox,\n          addClass: addClass,\n          removeClass: removeClass,\n          alignPathToPixel: alignPathToPixel,\n          clockwise: clockwise,\n          convertableToNumber: convertableToNumber,\n          deepExtend: deepExtend,\n          elementStyles: elementStyles,\n          getSpacing: getSpacing,\n          getTemplate: getTemplate,\n          getter: __common_getter_js,\n          grep: grep,\n          hasClasses: hasClasses,\n          HashMap: HashMap,\n          inArray: inArray,\n          interpolateValue: interpolateValue,\n          InstanceObserver: InstanceObserver,\n          isArray: isArray,\n          isFunction: isFunction,\n          isNumber: isNumber,\n          isObject: isObject,\n          isString: isString,\n          map: map,\n          mousewheelDelta: mousewheelDelta,\n          FontLoader: FontLoader,\n          setDefaultOptions: setDefaultOptions,\n          sparseArrayLimits: sparseArrayLimits,\n          styleValue: styleValue,\n          find: find,\n          elementScale: elementScale,\n          autoTextColor: autoTextColor,\n          createHashSet: createHashSet,\n          defaultErrorHandler: defaultErrorHandler,\n          keys: keys,\n          append: append,\n          bindEvents: bindEvents,\n          Class: Class,\n          defined: defined,\n          deg: deg,\n          elementOffset: elementOffset,\n          elementSize: elementSize,\n          eventCoordinates: eventCoordinates,\n          eventElement: eventElement,\n          hashKey: hashKey,\n          last: last,\n          limitValue: limitValue,\n          logToConsole: kendo.logToConsole,\n          objectKey: objectKey,\n          rad: rad,\n          round: round,\n          unbindEvents: unbindEvents,\n          valueOrDefault: valueOrDefault,\n          absoluteDateDiff: absoluteDateDiff,\n          addDuration: addDuration,\n          addTicks: addTicks,\n          ceilDate: ceilDate,\n          dateComparer: dateComparer,\n          dateDiff: dateDiff,\n          dateEquals: dateEquals,\n          dateIndex: dateIndex,\n          duration: duration,\n          floorDate: floorDate,\n          lteDateIndex: lteDateIndex,\n          startOfWeek: startOfWeek,\n          toDate: toDate,\n          parseDate: parseDate,\n          parseDates: parseDates,\n          toTime: toTime,\n          firstDay: firstDay\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}