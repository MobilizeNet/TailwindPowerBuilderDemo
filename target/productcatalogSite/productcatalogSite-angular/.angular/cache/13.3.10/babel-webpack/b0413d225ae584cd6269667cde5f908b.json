{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nclass Axis extends ChartElement {\n  constructor(options, chartService = new ChartService()) {\n    super(options);\n    this.chartService = chartService;\n\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n\n    this.createTitle();\n    this.createNotes();\n  }\n\n  initFields() {} // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n\n  labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  }\n\n  normalizeLabelRotation(labelOptions) {\n    const rotation = labelOptions.rotation;\n\n    if (isObject(rotation)) {\n      labelOptions.alignRotation = rotation.align;\n      labelOptions.rotation = rotation.angle;\n    }\n  }\n\n  createLabels() {\n    const options = this.options;\n    const align = options.vertical ? RIGHT : CENTER;\n    const labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    const step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n\n    if (labelOptions.visible) {\n      this.normalizeLabelRotation(labelOptions);\n\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n\n      const range = this.labelsRange();\n\n      for (let idx = range.min; idx < range.max; idx += step) {\n        const labelContext = {\n          index: idx,\n          count: range.max\n        };\n        let label = this.createAxisLabel(idx, labelOptions, labelContext);\n\n        if (label) {\n          this.append(label);\n          this.labels.push(label);\n        }\n      }\n    }\n  }\n\n  clearLabels() {\n    this.children = grep(this.children, child => !(child instanceof AxisLabel));\n    this.labels = [];\n  }\n\n  clearTitle() {\n    if (this.title) {\n      this.children = grep(this.children, child => child !== this.title);\n      this.title = undefined;\n    }\n  }\n\n  clear() {\n    this.clearLabels();\n    this.clearTitle();\n  }\n\n  lineBox() {\n    const {\n      options,\n      box\n    } = this;\n    const vertical = options.vertical;\n    const mirror = options.labels.mirror;\n    const axisX = mirror ? box.x1 : box.x2;\n    const axisY = mirror ? box.y2 : box.y1;\n    const lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  }\n\n  createTitle() {\n    const options = this.options;\n    const titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n\n    if (titleOptions.visible && titleOptions.text) {\n      const title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  }\n\n  createNotes() {\n    const options = this.options;\n    const notes = options.notes;\n    const items = notes.data || [];\n    this.notes = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const item = deepExtend({}, notes, items[i]);\n      item.value = this.parseNoteValue(item.value);\n      const note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this.chartService);\n\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n\n        this.append(note);\n        this.notes.push(note);\n      }\n    }\n  }\n\n  parseNoteValue(value) {\n    return value;\n  }\n\n  renderVisual() {\n    super.renderVisual();\n    this.createPlotBands();\n  }\n\n  createVisual() {\n    super.createVisual();\n    this.createBackground();\n    this.createLine();\n  }\n\n  gridLinesVisual() {\n    let gridLines = this._gridLines;\n\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n\n    return gridLines;\n  }\n\n  createTicks(lineGroup) {\n    const options = this.options;\n    const lineBox = this.lineBox();\n    const mirror = options.labels.mirror;\n    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    const tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n\n    function render(tickPositions, tickOptions, skipUnit) {\n      const count = tickPositions.length;\n      const step = Math.max(1, tickOptions.step);\n\n      if (tickOptions.visible) {\n        for (let i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  }\n\n  createLine() {\n    const options = this.options;\n    const line = options.line;\n    const lineBox = this.lineBox();\n\n    if (line.width > 0 && line.visible) {\n      const path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n        /* TODO\n        zIndex: line.zIndex,\n        */\n\n      });\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n\n      const group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  }\n\n  getActualTickSize() {\n    const options = this.options;\n    let tickSize = 0;\n\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n\n    return tickSize;\n  }\n\n  createBackground() {\n    const {\n      options,\n      box\n    } = this;\n    const background = options.background;\n\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  }\n\n  createPlotBands() {\n    const options = this.options;\n    const plotBands = options.plotBands || [];\n    const vertical = options.vertical;\n    const plotArea = this.plotArea;\n\n    if (plotBands.length === 0) {\n      return;\n    }\n\n    const group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    const altAxis = grep(this.pane.axes, axis => axis.options.vertical !== this.options.vertical)[0];\n\n    for (let idx = 0; idx < plotBands.length; idx++) {\n      let item = plotBands[idx];\n      let slotX, slotY;\n      let labelOptions = item.label;\n      let label;\n\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n\n      if (labelOptions) {\n        labelOptions.vAlign = labelOptions.position || LEFT;\n        label = this.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n      }\n\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        const bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        const path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n\n        if (label) {\n          group.append(label);\n        }\n      }\n    }\n\n    this.appendVisual(group);\n  }\n\n  createPlotBandLabel(label, item, box) {\n    if (label.visible === false) {\n      return null;\n    }\n\n    let text = label.text;\n    let textbox;\n\n    if (defined(label) && label.visible) {\n      const labelTemplate = getTemplate(label);\n\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: text,\n          item: item\n        });\n      } else if (label.format) {\n        text = this.chartService.format.auto(label.format, text);\n      }\n\n      if (!label.color) {\n        label.color = this.options.labels.color;\n      }\n    }\n\n    textbox = new TextBox(text, label);\n    textbox.reflow(box);\n    textbox.renderVisual();\n    return textbox.visual;\n  }\n\n  createGridLines(altAxis) {\n    const options = this.options;\n    const {\n      minorGridLines,\n      majorGridLines,\n      minorUnit,\n      vertical\n    } = options;\n    const axisLineVisible = altAxis.options.line.visible;\n    const majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    const lineBox = altAxis.lineBox();\n    const linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    const lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    const majorTicks = [];\n    const container = this.gridLinesVisual();\n\n    function render(tickPositions, gridLine, skipUnit) {\n      const count = tickPositions.length;\n      const step = Math.max(1, gridLine.step);\n\n      if (gridLine.visible) {\n        for (let i = gridLine.skip; i < count; i += step) {\n          let pos = round(tickPositions[i]);\n\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  }\n\n  reflow(box) {\n    const {\n      options,\n      labels,\n      title\n    } = this;\n    const vertical = options.vertical;\n    const count = labels.length;\n    const sizeFn = vertical ? WIDTH : HEIGHT;\n    const titleSize = title ? title.box[sizeFn]() : 0;\n    const space = this.getActualTickSize() + options.margin + titleSize;\n    const rootBox = (this.getRoot() || {}).box || box;\n    const boxSize = rootBox[sizeFn]();\n    let maxLabelSize = 0;\n\n    for (let i = 0; i < count; i++) {\n      let labelSize = labels[i].box[sizeFn]();\n\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  }\n\n  getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  }\n\n  labelTickIndex(label) {\n    return label.index;\n  }\n\n  arrangeLabels() {\n    const {\n      options,\n      labels\n    } = this;\n    const labelsBetweenTicks = this.labelsBetweenTicks();\n    const vertical = options.vertical;\n    const mirror = options.labels.mirror;\n    const tickPositions = this.getLabelsTickPositions();\n\n    for (let idx = 0; idx < labels.length; idx++) {\n      const label = labels[idx];\n      const tickIx = this.labelTickIndex(label);\n      const labelSize = vertical ? label.box.height() : label.box.width();\n      const firstTickPosition = tickPositions[tickIx];\n      const nextTickPosition = tickPositions[tickIx + 1];\n      let positionStart, positionEnd;\n\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          positionStart = middle - labelSize / 2;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n        }\n\n        positionEnd = positionStart;\n      } else {\n        if (labelsBetweenTicks) {\n          positionStart = firstTickPosition;\n          positionEnd = nextTickPosition;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n          positionEnd = positionStart + labelSize;\n        }\n      }\n\n      this.positionLabel(label, mirror, positionStart, positionEnd);\n    }\n  }\n\n  positionLabel(label, mirror, positionStart, positionEnd = positionStart) {\n    const options = this.options;\n    const vertical = options.vertical;\n    const lineBox = this.lineBox();\n    const labelOffset = this.getActualTickSize() + options.margin;\n    let labelBox;\n\n    if (vertical) {\n      let labelX = lineBox.x2;\n\n      if (mirror) {\n        labelX += labelOffset;\n        label.options.rotationOrigin = LEFT;\n      } else {\n        labelX -= labelOffset + label.box.width();\n        label.options.rotationOrigin = RIGHT;\n      }\n\n      labelBox = label.box.move(labelX, positionStart);\n    } else {\n      let labelY = lineBox.y1;\n\n      if (mirror) {\n        labelY -= labelOffset + label.box.height();\n        label.options.rotationOrigin = BOTTOM;\n      } else {\n        labelY += labelOffset;\n        label.options.rotationOrigin = TOP;\n      }\n\n      labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n    }\n\n    label.reflow(labelBox);\n  }\n\n  autoRotateLabelAngle(labelBox, slotWidth) {\n    if (labelBox.width() < slotWidth) {\n      return 0;\n    }\n\n    if (labelBox.height() > slotWidth) {\n      return -90;\n    }\n\n    return -45;\n  }\n\n  autoRotateLabels() {\n    if (!this.options.autoRotateLabels || this.options.vertical) {\n      return false;\n    }\n\n    const tickPositions = this.getMajorTickPositions();\n    const labels = this.labels;\n    const limit = Math.min(labels.length, tickPositions.length - 1);\n    let angle = 0;\n\n    for (let idx = 0; idx < limit; idx++) {\n      const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n      const labelBox = labels[idx].box;\n      const labelAngle = this.autoRotateLabelAngle(labelBox, width);\n\n      if (labelAngle !== 0) {\n        angle = labelAngle;\n      }\n\n      if (angle === -90) {\n        break;\n      }\n    }\n\n    if (angle !== 0) {\n      for (let idx = 0; idx < labels.length; idx++) {\n        labels[idx].options.rotation = angle;\n        labels[idx].reflow(new Box());\n      }\n\n      return true;\n    }\n  }\n\n  arrangeTitle() {\n    const {\n      options,\n      title\n    } = this;\n    const mirror = options.labels.mirror;\n    const vertical = options.vertical;\n\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n\n      title.reflow(this.box);\n    }\n  }\n\n  arrangeNotes() {\n    for (let idx = 0; idx < this.notes.length; idx++) {\n      const item = this.notes[idx];\n      const value = item.options.value;\n      let slot;\n\n      if (defined(value)) {\n        if (this.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n\n        slot = this.noteSlot(value);\n      } else {\n        item.hide();\n      }\n\n      item.reflow(slot || this.lineBox());\n    }\n  }\n\n  noteSlot(value) {\n    return this.getSlot(value);\n  }\n\n  alignTo(secondAxis) {\n    const lineBox = secondAxis.lineBox();\n    const vertical = this.options.vertical;\n    const pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  }\n\n  axisLabelText(value, options, context) {\n    let text;\n    const tmpl = getTemplate(options);\n\n    const defaultText = () => {\n      if (!options.format) {\n        return value;\n      }\n\n      return this.chartService.format.localeAuto(options.format, [value], options.culture);\n    };\n\n    if (tmpl) {\n      const templateContext = Object.assign({}, context, {\n        get text() {\n          return defaultText();\n        },\n\n        value,\n        format: options.format,\n        culture: options.culture\n      });\n      text = tmpl(templateContext);\n    } else {\n      text = defaultText();\n    }\n\n    return text;\n  }\n\n  slot(from, to, limit) {\n    const slot = this.getSlot(from, to, limit);\n\n    if (slot) {\n      return slot.toRect();\n    }\n  }\n\n  contentBox() {\n    const box = this.box.clone();\n    const labels = this.labels;\n\n    if (labels.length) {\n      const axis = this.options.vertical ? Y : X;\n\n      if (this.chartService.isPannable(axis)) {\n        const offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n\n        const lastLabel = labels[labels.length - 1];\n\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n\n    return box;\n  }\n\n  maxLabelOffset() {\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    const labelsBetweenTicks = this.labelsBetweenTicks();\n    const tickPositions = this.getLabelsTickPositions();\n    const offsetField = vertical ? Y : X;\n    const labels = this.labels;\n    const startPosition = reverse ? 1 : 0;\n    const endPosition = reverse ? 0 : 1;\n    let maxStartOffset = 0;\n    let maxEndOffset = 0;\n\n    for (let idx = 0; idx < labels.length; idx++) {\n      const label = labels[idx];\n      const tickIx = this.labelTickIndex(label);\n      let startTick, endTick;\n\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  }\n\n  limitRange(from, to, min, max, offset) {\n    const options = this.options;\n\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n\n    const rangeSize = to - from;\n    let minValue = from;\n    let maxValue = to;\n\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  }\n\n  valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  }\n\n  lineDir() {\n    /*\n     * Axis line direction:\n     *   * Vertical: up.\n     *   * Horizontal: right.\n     */\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n  }\n\n  lineInfo() {\n    const {\n      vertical\n    } = this.options;\n    const lineBox = this.lineBox();\n    const lineSize = vertical ? lineBox.height() : lineBox.width();\n    const axis = vertical ? Y : X;\n    const axisDir = this.lineDir();\n    const startEdge = axisDir === 1 ? 1 : 2;\n    const axisOrigin = axis + startEdge.toString();\n    const lineStart = lineBox[axisOrigin];\n    return {\n      axis,\n      axisOrigin,\n      axisDir,\n      lineBox,\n      lineSize,\n      lineStart\n    };\n  }\n\n  pointOffset(point) {\n    const {\n      axis,\n      axisDir,\n      axisOrigin,\n      lineBox,\n      lineSize\n    } = this.lineInfo();\n    const relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n    const offset = relative / lineSize;\n    return offset;\n  } // Computes the axis range change (delta) for a given scale factor.\n  // The delta is subtracted from the axis range:\n  //   * delta > 0 reduces the axis range (zoom-in)\n  //   * delta < 0 expands the axis range (zoom-out)\n\n\n  scaleToDelta(rawScale, range) {\n    // Scale >= 1 would result in axis range of 0.\n    // Scale <= -1 would reverse the scale direction.\n    const MAX_SCALE = 0.999;\n    const scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n    let delta;\n\n    if (scale > 0) {\n      delta = range * Math.min(1, scale);\n    } else {\n      delta = range - range / (1 + scale);\n    }\n\n    return delta;\n  }\n\n  labelsBetweenTicks() {\n    return !this.options.justified;\n  } //add legacy fields to the options that are no longer generated by default\n\n\n  prepareUserOptions() {}\n\n}\n\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":null,"metadata":{},"sourceType":"module"}