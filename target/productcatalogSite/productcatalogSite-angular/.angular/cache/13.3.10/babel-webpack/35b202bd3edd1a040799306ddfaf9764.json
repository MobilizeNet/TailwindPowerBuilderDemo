{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(895);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  891:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.dataviz.core\");\n    /***/\n  },\n\n  /***/\n  893:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.drawing\");\n    /***/\n  },\n\n  /***/\n  895:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n    /***********************************************************************\n    * WARNING: this file is auto-generated.  If you change it directly,\n    * your modifications will eventually be lost.  The source code is in\n    * `kendo-charts` repository, you should make your changes there and\n    * run `src-modules/sync.sh` in this repository.\n    */\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(896), __webpack_require__(897), __webpack_require__(893), __webpack_require__(891)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        /* jshint expr: true */\n        window.kendo.dataviz = window.kendo.dataviz || {};\n        var dataviz = kendo.dataviz;\n        var Class = dataviz.Class;\n        var isNumber = dataviz.isNumber;\n        var datavizConstants = dataviz.constants;\n        var MAX_VALUE = datavizConstants.MAX_VALUE;\n        var MIN_VALUE = datavizConstants.MIN_VALUE;\n        var VALUE = datavizConstants.VALUE;\n        var CENTER = datavizConstants.CENTER;\n        var TOP = datavizConstants.TOP;\n        var BOTTOM = datavizConstants.BOTTOM;\n        var LEFT = datavizConstants.LEFT;\n        var WHITE = datavizConstants.WHITE;\n        var CIRCLE = datavizConstants.CIRCLE;\n        var X = datavizConstants.X;\n        var Y = datavizConstants.Y;\n        var RIGHT = datavizConstants.RIGHT;\n        var BLACK = datavizConstants.BLACK;\n        var DATE = datavizConstants.DATE;\n        var DEFAULT_PRECISION = datavizConstants.DEFAULT_PRECISION;\n        var ARC = datavizConstants.ARC;\n        var defined = dataviz.defined;\n        var getter = dataviz.getter;\n        var isArray = dataviz.isArray;\n        var ChartElement = dataviz.ChartElement;\n        var Point = dataviz.Point;\n        var Box = dataviz.Box;\n        var alignPathToPixel = dataviz.alignPathToPixel;\n        var setDefaultOptions = dataviz.setDefaultOptions;\n        var inArray = dataviz.inArray;\n        var isFunction = dataviz.isFunction;\n        var valueOrDefault = dataviz.valueOrDefault;\n        var isObject = dataviz.isObject;\n        var deepExtend = dataviz.deepExtend;\n        var last = dataviz.last;\n        var eventElement = dataviz.eventElement;\n        var getTemplate = dataviz.getTemplate;\n        var TextBox = dataviz.TextBox;\n        var ShapeElement = dataviz.ShapeElement;\n        var getSpacing = dataviz.getSpacing;\n        var CurveProcessor = dataviz.CurveProcessor;\n        var append = dataviz.append;\n        var isString = dataviz.isString;\n        var parseDate = dataviz.parseDate;\n        var styleValue = dataviz.styleValue;\n        var CategoryAxis = dataviz.CategoryAxis;\n        var BoxElement = dataviz.BoxElement;\n        var round = dataviz.round;\n        var limitValue = dataviz.limitValue;\n        var grep = dataviz.grep;\n        var elementStyles = dataviz.elementStyles;\n        var hasClasses = dataviz.hasClasses;\n        var bindEvents = dataviz.bindEvents;\n        var services = dataviz.services;\n        var unbindEvents = dataviz.unbindEvents;\n        var support = kendo.support;\n        var drawing = kendo.drawing;\n        var Path = drawing.Path;\n        var Animation = drawing.Animation;\n        var AnimationFactory = drawing.AnimationFactory;\n        var Group = drawing.Group;\n        var Color = kendo.Color;\n        var geometry = kendo.geometry;\n        var GeometryPoint = geometry.Point;\n        var transform = geometry.transform;\n        var ChartAxis = Class.extend({\n          init: function (axis) {\n            this._axis = axis;\n            this.options = axis.options;\n          },\n          value: function (point) {\n            var axis = this._axis;\n            var value = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);\n            return value;\n          },\n          slot: function (from, to, limit) {\n            if (limit === void 0) {\n              limit = true;\n            }\n\n            return this._axis.slot(from, to, limit);\n          },\n          range: function () {\n            return this._axis.range();\n          },\n          valueRange: function () {\n            return this._axis.valueRange();\n          }\n        });\n\n        function findAxisByName(name, axes) {\n          for (var idx = 0; idx < axes.length; idx++) {\n            if (axes[idx].options.name === name) {\n              axes[idx].prepareUserOptions();\n              return new ChartAxis(axes[idx]);\n            }\n          }\n        }\n\n        var ChartPane = kendo.Class.extend({\n          init: function (pane) {\n            this.visual = pane.visual;\n            this.chartsVisual = pane.chartContainer.visual;\n            this._pane = pane;\n          },\n          findAxisByName: function (name) {\n            return findAxisByName(name, this._pane.axes);\n          }\n        });\n        var ChartPlotArea = Class.extend({\n          init: function (plotArea) {\n            this._plotArea = plotArea;\n            this.visual = plotArea.visual;\n            this.backgroundVisual = plotArea._bgVisual;\n          }\n        });\n\n        function countNumbers(values) {\n          var length = values.length;\n          var count = 0;\n\n          for (var i = 0; i < length; i++) {\n            var num = values[i];\n\n            if (isNumber(num)) {\n              count++;\n            }\n          }\n\n          return count;\n        }\n\n        var Aggregates = {\n          min: function (values) {\n            var length = values.length;\n            var min = MAX_VALUE;\n\n            for (var i = 0; i < length; i++) {\n              var value = values[i];\n\n              if (isNumber(value)) {\n                min = Math.min(min, value);\n              }\n            }\n\n            return min === MAX_VALUE ? values[0] : min;\n          },\n          max: function (values) {\n            var length = values.length;\n            var max = MIN_VALUE;\n\n            for (var i = 0; i < length; i++) {\n              var value = values[i];\n\n              if (isNumber(value)) {\n                max = Math.max(max, value);\n              }\n            }\n\n            return max === MIN_VALUE ? values[0] : max;\n          },\n          sum: function (values) {\n            var length = values.length;\n            var sum = 0;\n\n            for (var i = 0; i < length; i++) {\n              var value = values[i];\n\n              if (isNumber(value)) {\n                sum += value;\n              }\n            }\n\n            return sum;\n          },\n          sumOrNull: function (values) {\n            var result = null;\n\n            if (countNumbers(values)) {\n              result = Aggregates.sum(values);\n            }\n\n            return result;\n          },\n          count: function (values) {\n            var length = values.length;\n            var count = 0;\n\n            for (var i = 0; i < length; i++) {\n              var value = values[i];\n\n              if (value !== null && defined(value)) {\n                count++;\n              }\n            }\n\n            return count;\n          },\n          avg: function (values) {\n            var count = countNumbers(values);\n            var result = values[0];\n\n            if (count > 0) {\n              result = Aggregates.sum(values) / count;\n            }\n\n            return result;\n          },\n          first: function (values) {\n            var length = values.length;\n\n            for (var i = 0; i < length; i++) {\n              var value = values[i];\n\n              if (value !== null && defined(value)) {\n                return value;\n              }\n            }\n\n            return values[0];\n          }\n        };\n\n        function getField(field, row) {\n          if (row === null) {\n            return row;\n          }\n\n          var get = getter(field, true);\n          return get(row);\n        }\n\n        var SeriesBinder = Class.extend({\n          init: function () {\n            this._valueFields = {};\n            this._otherFields = {};\n            this._nullValue = {};\n            this._undefinedValue = {};\n          },\n          register: function (seriesTypes, valueFields, otherFields) {\n            var this$1 = this;\n\n            if (valueFields === void 0) {\n              valueFields = [VALUE];\n            }\n\n            if (otherFields === void 0) {\n              otherFields = {};\n            }\n\n            for (var i = 0; i < seriesTypes.length; i++) {\n              var type = seriesTypes[i];\n              this$1._valueFields[type] = valueFields;\n              this$1._otherFields[type] = otherFields;\n              this$1._nullValue[type] = this$1._makeValue(valueFields, null);\n              this$1._undefinedValue[type] = this$1._makeValue(valueFields, undefined);\n            }\n          },\n          canonicalFields: function (series) {\n            return this.valueFields(series).concat(this.otherFields(series));\n          },\n          valueFields: function (series) {\n            return this._valueFields[series.type] || [VALUE];\n          },\n          otherFields: function (series) {\n            return this._otherFields[series.type] || [VALUE];\n          },\n          bindPoint: function (series, pointIx, item) {\n            var data = series.data;\n            var pointData = defined(item) ? item : data[pointIx];\n            var result = {\n              valueFields: {\n                value: pointData\n              }\n            };\n            var valueFields = this.valueFields(series);\n            var otherFields = this._otherFields[series.type];\n            var fields, value;\n\n            if (pointData === null) {\n              value = this._nullValue[series.type];\n            } else if (!defined(pointData)) {\n              value = this._undefinedValue[series.type];\n            } else if (Array.isArray(pointData)) {\n              var fieldData = pointData.slice(valueFields.length);\n              value = this._bindFromArray(pointData, valueFields);\n              fields = this._bindFromArray(fieldData, otherFields);\n            } else if (typeof pointData === \"object\") {\n              var srcValueFields = this.sourceFields(series, valueFields);\n              var srcPointFields = this.sourceFields(series, otherFields);\n              value = this._bindFromObject(pointData, valueFields, srcValueFields);\n              fields = this._bindFromObject(pointData, otherFields, srcPointFields);\n            }\n\n            if (defined(value)) {\n              if (valueFields.length === 1) {\n                result.valueFields.value = value[valueFields[0]];\n              } else {\n                result.valueFields = value;\n              }\n            }\n\n            result.fields = fields || {};\n            return result;\n          },\n          _makeValue: function (fields, initialValue) {\n            var value = {};\n            var length = fields.length;\n\n            for (var i = 0; i < length; i++) {\n              var fieldName = fields[i];\n              value[fieldName] = initialValue;\n            }\n\n            return value;\n          },\n          _bindFromArray: function (array, fields) {\n            var value = {};\n\n            if (fields) {\n              var length = Math.min(fields.length, array.length);\n\n              for (var i = 0; i < length; i++) {\n                value[fields[i]] = array[i];\n              }\n            }\n\n            return value;\n          },\n          _bindFromObject: function (object, fields, srcFields) {\n            if (srcFields === void 0) {\n              srcFields = fields;\n            }\n\n            var value = {};\n\n            if (fields) {\n              var length = fields.length;\n\n              for (var i = 0; i < length; i++) {\n                var fieldName = fields[i];\n                var srcFieldName = srcFields[i];\n\n                if (srcFieldName !== null) {\n                  value[fieldName] = getField(srcFieldName, object);\n                }\n              }\n            }\n\n            return value;\n          },\n          sourceFields: function (series, canonicalFields) {\n            var sourceFields = [];\n\n            if (canonicalFields) {\n              var length = canonicalFields.length;\n\n              for (var i = 0; i < length; i++) {\n                var fieldName = canonicalFields[i];\n                var sourceFieldName = fieldName === VALUE ? \"field\" : fieldName + \"Field\";\n                sourceFields.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);\n              }\n            }\n\n            return sourceFields;\n          }\n        });\n        SeriesBinder.current = new SeriesBinder();\n        var STD_ERR = \"stderr\";\n        var STD_DEV = \"stddev\";\n        var percentRegex = /percent(?:\\w*)\\((\\d+)\\)/;\n        var standardDeviationRegex = new RegExp(\"^\" + STD_DEV + \"(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$\");\n        var ErrorRangeCalculator = Class.extend({\n          init: function (errorValue, series, field) {\n            this.initGlobalRanges(errorValue, series, field);\n          },\n          initGlobalRanges: function (errorValue, series, field) {\n            var data = series.data;\n            var deviationMatch = standardDeviationRegex.exec(errorValue);\n\n            if (deviationMatch) {\n              this.valueGetter = this.createValueGetter(series, field);\n              var average = this.getAverage(data);\n              var deviation = this.getStandardDeviation(data, average, false);\n              var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;\n              var errorRange = {\n                low: average.value - deviation * multiple,\n                high: average.value + deviation * multiple\n              };\n\n              this.globalRange = function () {\n                return errorRange;\n              };\n            } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {\n              this.valueGetter = this.createValueGetter(series, field);\n              var standardError = this.getStandardError(data, this.getAverage(data));\n\n              this.globalRange = function (value) {\n                return {\n                  low: value - standardError,\n                  high: value + standardError\n                };\n              };\n            }\n          },\n          createValueGetter: function (series, field) {\n            var data = series.data;\n            var binder = SeriesBinder.current;\n            var valueFields = binder.valueFields(series);\n            var item = defined(data[0]) ? data[0] : {};\n            var valueGetter;\n\n            if (isArray(item)) {\n              var index = field ? valueFields.indexOf(field) : 0;\n              valueGetter = getter(\"[\" + index + \"]\");\n            } else if (isNumber(item)) {\n              valueGetter = getter();\n            } else if (typeof item === datavizConstants.OBJECT) {\n              var srcValueFields = binder.sourceFields(series, valueFields);\n              valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);\n            }\n\n            return valueGetter;\n          },\n          getErrorRange: function (pointValue, errorValue) {\n            var low, high, value;\n\n            if (!defined(errorValue)) {\n              return null;\n            }\n\n            if (this.globalRange) {\n              return this.globalRange(pointValue);\n            }\n\n            if (isArray(errorValue)) {\n              low = pointValue - errorValue[0];\n              high = pointValue + errorValue[1];\n            } else if (isNumber(value = parseFloat(errorValue))) {\n              low = pointValue - value;\n              high = pointValue + value;\n            } else if (value = percentRegex.exec(errorValue)) {\n              var percentValue = pointValue * (parseFloat(value[1]) / 100);\n              low = pointValue - Math.abs(percentValue);\n              high = pointValue + Math.abs(percentValue);\n            } else {\n              throw new Error(\"Invalid ErrorBar value: \" + errorValue);\n            }\n\n            return {\n              low: low,\n              high: high\n            };\n          },\n          getStandardError: function (data, average) {\n            return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);\n          },\n          getStandardDeviation: function (data, average, isSample) {\n            var this$1 = this;\n            var length = data.length;\n            var total = isSample ? average.count - 1 : average.count;\n            var squareDifferenceSum = 0;\n\n            for (var idx = 0; idx < length; idx++) {\n              var value = this$1.valueGetter(data[idx]);\n\n              if (isNumber(value)) {\n                squareDifferenceSum += Math.pow(value - average.value, 2);\n              }\n            }\n\n            return Math.sqrt(squareDifferenceSum / total);\n          },\n          getAverage: function (data) {\n            var this$1 = this;\n            var length = data.length;\n            var sum = 0;\n            var count = 0;\n\n            for (var idx = 0; idx < length; idx++) {\n              var value = this$1.valueGetter(data[idx]);\n\n              if (isNumber(value)) {\n                sum += value;\n                count++;\n              }\n            }\n\n            return {\n              value: sum / count,\n              count: count\n            };\n          }\n        });\n        var browser = support.browser || {};\n        var INITIAL_ANIMATION_DURATION = 600;\n        var FADEIN = \"fadeIn\";\n        var GLASS = \"glass\";\n        var BORDER_BRIGHTNESS = 0.8;\n        var TOOLTIP_OFFSET = 5;\n        var START_SCALE = browser.msie ? 0.001 : 0;\n        var ERROR_LOW_FIELD = \"errorLow\";\n        var ERROR_HIGH_FIELD = \"errorHigh\";\n        var X_ERROR_LOW_FIELD = \"xErrorLow\";\n        var X_ERROR_HIGH_FIELD = \"xErrorHigh\";\n        var Y_ERROR_LOW_FIELD = \"yErrorLow\";\n        var Y_ERROR_HIGH_FIELD = \"yErrorHigh\";\n        var LINE_MARKER_SIZE = 8;\n        var ZERO = \"zero\";\n        var INTERPOLATE = \"interpolate\";\n        var GAP = \"gap\";\n        var ABOVE = \"above\";\n        var BELOW = \"below\";\n        var SMOOTH = \"smooth\";\n        var STEP = \"step\";\n        var AREA = \"area\";\n        var BAR = \"bar\";\n        var BOX_PLOT = \"boxPlot\";\n        var BUBBLE = \"bubble\";\n        var BULLET = \"bullet\";\n        var CANDLESTICK = \"candlestick\";\n        var COLUMN = \"column\";\n        var DONUT = \"donut\";\n        var FUNNEL = \"funnel\";\n        var HEATMAP = \"heatmap\";\n        var HORIZONTAL_WATERFALL = \"horizontalWaterfall\";\n        var LINE = \"line\";\n        var OHLC = \"ohlc\";\n        var PIE = \"pie\";\n        var POLAR_AREA = \"polarArea\";\n        var POLAR_LINE = \"polarLine\";\n        var POLAR_SCATTER = \"polarScatter\";\n        var RADAR_AREA = \"radarArea\";\n        var RADAR_COLUMN = \"radarColumn\";\n        var RADAR_LINE = \"radarLine\";\n        var RANGE_AREA = \"rangeArea\";\n        var RANGE_BAR = \"rangeBar\";\n        var RANGE_COLUMN = \"rangeColumn\";\n        var SCATTER = \"scatter\";\n        var SCATTER_LINE = \"scatterLine\";\n        var VERTICAL_AREA = \"verticalArea\";\n        var VERTICAL_BOX_PLOT = \"verticalBoxPlot\";\n        var VERTICAL_BULLET = \"verticalBullet\";\n        var VERTICAL_LINE = \"verticalLine\";\n        var VERTICAL_RANGE_AREA = \"verticalRangeArea\";\n        var WATERFALL = \"waterfall\";\n        var EQUALLY_SPACED_SERIES = [BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT, BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL];\n        var LEGEND_ITEM_CLICK = \"legendItemClick\";\n        var LEGEND_ITEM_HOVER = \"legendItemHover\";\n        var LEGEND_ITEM_LEAVE = \"legendItemLeave\";\n        var SERIES_CLICK = \"seriesClick\";\n        var SERIES_HOVER = \"seriesHover\";\n        var SERIES_OVER = \"seriesOver\";\n        var SERIES_LEAVE = \"seriesLeave\";\n        var PLOT_AREA_CLICK = \"plotAreaClick\";\n        var PLOT_AREA_HOVER = \"plotAreaHover\";\n        var PLOT_AREA_LEAVE = \"plotAreaLeave\";\n        var DRAG = \"drag\";\n        var DRAG_END = \"dragEnd\";\n        var DRAG_START = \"dragStart\";\n        var ZOOM_START = \"zoomStart\";\n        var ZOOM = \"zoom\";\n        var ZOOM_END = \"zoomEnd\";\n        var SELECT_START = \"selectStart\";\n        var SELECT = \"select\";\n        var SELECT_END = \"selectEnd\";\n        var RENDER = \"render\";\n        var SHOW_TOOLTIP = \"showTooltip\";\n        var HIDE_TOOLTIP = \"hideTooltip\";\n        var PANE_RENDER = \"paneRender\";\n        var LOGARITHMIC = \"log\";\n        var CATEGORY = \"category\";\n        var INSIDE_END = \"insideEnd\";\n        var INSIDE_BASE = \"insideBase\";\n        var OUTSIDE_END = \"outsideEnd\";\n        var MOUSEWHEEL = \"DOMMouseScroll mousewheel\";\n        var MOUSEWHEEL_DELAY = 150;\n        var MOUSEWHEEL_ZOOM_RATE = 0.3;\n        var constants = {\n          INITIAL_ANIMATION_DURATION: INITIAL_ANIMATION_DURATION,\n          FADEIN: FADEIN,\n          LEGEND_ITEM_CLICK: LEGEND_ITEM_CLICK,\n          LEGEND_ITEM_HOVER: LEGEND_ITEM_HOVER,\n          LEGEND_ITEM_LEAVE: LEGEND_ITEM_LEAVE,\n          SERIES_CLICK: SERIES_CLICK,\n          SERIES_HOVER: SERIES_HOVER,\n          SERIES_OVER: SERIES_OVER,\n          SERIES_LEAVE: SERIES_LEAVE,\n          GLASS: GLASS,\n          BORDER_BRIGHTNESS: BORDER_BRIGHTNESS,\n          TOOLTIP_OFFSET: TOOLTIP_OFFSET,\n          START_SCALE: START_SCALE,\n          ERROR_LOW_FIELD: ERROR_LOW_FIELD,\n          ERROR_HIGH_FIELD: ERROR_HIGH_FIELD,\n          X_ERROR_LOW_FIELD: X_ERROR_LOW_FIELD,\n          X_ERROR_HIGH_FIELD: X_ERROR_HIGH_FIELD,\n          Y_ERROR_LOW_FIELD: Y_ERROR_LOW_FIELD,\n          Y_ERROR_HIGH_FIELD: Y_ERROR_HIGH_FIELD,\n          LINE_MARKER_SIZE: LINE_MARKER_SIZE,\n          INTERPOLATE: INTERPOLATE,\n          ZERO: ZERO,\n          SMOOTH: SMOOTH,\n          STEP: STEP,\n          CATEGORY: CATEGORY,\n          FUNNEL: FUNNEL,\n          BAR: BAR,\n          CANDLESTICK: CANDLESTICK,\n          PIE: PIE,\n          COLUMN: COLUMN,\n          AREA: AREA,\n          VERTICAL_BULLET: VERTICAL_BULLET,\n          BOX_PLOT: BOX_PLOT,\n          OHLC: OHLC,\n          WATERFALL: WATERFALL,\n          LINE: LINE,\n          BULLET: BULLET,\n          VERTICAL_LINE: VERTICAL_LINE,\n          VERTICAL_AREA: VERTICAL_AREA,\n          RANGE_AREA: RANGE_AREA,\n          VERTICAL_RANGE_AREA: VERTICAL_RANGE_AREA,\n          RANGE_COLUMN: RANGE_COLUMN,\n          VERTICAL_BOX_PLOT: VERTICAL_BOX_PLOT,\n          RANGE_BAR: RANGE_BAR,\n          HORIZONTAL_WATERFALL: HORIZONTAL_WATERFALL,\n          SCATTER: SCATTER,\n          SCATTER_LINE: SCATTER_LINE,\n          BUBBLE: BUBBLE,\n          RADAR_AREA: RADAR_AREA,\n          RADAR_LINE: RADAR_LINE,\n          RADAR_COLUMN: RADAR_COLUMN,\n          POLAR_LINE: POLAR_LINE,\n          POLAR_AREA: POLAR_AREA,\n          POLAR_SCATTER: POLAR_SCATTER,\n          RENDER: RENDER,\n          PLOT_AREA_CLICK: PLOT_AREA_CLICK,\n          PLOT_AREA_HOVER: PLOT_AREA_HOVER,\n          PLOT_AREA_LEAVE: PLOT_AREA_LEAVE,\n          LOGARITHMIC: LOGARITHMIC,\n          DRAG: DRAG,\n          DRAG_START: DRAG_START,\n          DRAG_END: DRAG_END,\n          ZOOM_START: ZOOM_START,\n          ZOOM: ZOOM,\n          ZOOM_END: ZOOM_END,\n          SELECT_START: SELECT_START,\n          SELECT: SELECT,\n          SELECT_END: SELECT_END,\n          PANE_RENDER: PANE_RENDER,\n          GAP: GAP,\n          DONUT: DONUT,\n          INSIDE_END: INSIDE_END,\n          INSIDE_BASE: INSIDE_BASE,\n          OUTSIDE_END: OUTSIDE_END,\n          MOUSEWHEEL: MOUSEWHEEL,\n          MOUSEWHEEL_DELAY: MOUSEWHEEL_DELAY,\n          MOUSEWHEEL_ZOOM_RATE: MOUSEWHEEL_ZOOM_RATE,\n          SHOW_TOOLTIP: SHOW_TOOLTIP,\n          HIDE_TOOLTIP: HIDE_TOOLTIP,\n          EQUALLY_SPACED_SERIES: EQUALLY_SPACED_SERIES,\n          ABOVE: ABOVE,\n          BELOW: BELOW,\n          HEATMAP: HEATMAP\n        };\n        var DEFAULT_ERROR_BAR_WIDTH = 4;\n        var ErrorBarBase = ChartElement.extend({\n          init: function (low, high, isVertical, chart, series, options) {\n            ChartElement.fn.init.call(this, options);\n            this.low = low;\n            this.high = high;\n            this.isVertical = isVertical;\n            this.chart = chart;\n            this.series = series;\n          },\n          reflow: function (targetBox) {\n            var endCaps = this.options.endCaps;\n            var isVertical = this.isVertical;\n            var axis = this.getAxis();\n            var valueBox = axis.getSlot(this.low, this.high);\n            var centerBox = targetBox.center();\n            var capsWidth = this.getCapsWidth(targetBox, isVertical);\n            var capValue = isVertical ? centerBox.x : centerBox.y;\n            var capStart = capValue - capsWidth;\n            var capEnd = capValue + capsWidth;\n            var linePoints;\n\n            if (isVertical) {\n              linePoints = [new Point(centerBox.x, valueBox.y1), new Point(centerBox.x, valueBox.y2)];\n\n              if (endCaps) {\n                linePoints.push(new Point(capStart, valueBox.y1), new Point(capEnd, valueBox.y1), new Point(capStart, valueBox.y2), new Point(capEnd, valueBox.y2));\n              }\n\n              this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);\n            } else {\n              linePoints = [new Point(valueBox.x1, centerBox.y), new Point(valueBox.x2, centerBox.y)];\n\n              if (endCaps) {\n                linePoints.push(new Point(valueBox.x1, capStart), new Point(valueBox.x1, capEnd), new Point(valueBox.x2, capStart), new Point(valueBox.x2, capEnd));\n              }\n\n              this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);\n            }\n\n            this.linePoints = linePoints;\n          },\n          getCapsWidth: function (box, isVertical) {\n            var boxSize = isVertical ? box.width() : box.height();\n            var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n            return capsWidth;\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var options = this.options;\n            var visual = options.visual;\n\n            if (visual) {\n              this.visual = visual({\n                low: this.low,\n                high: this.high,\n                rect: this.box.toRect(),\n                sender: this.getSender(),\n                options: {\n                  endCaps: options.endCaps,\n                  color: options.color,\n                  line: options.line\n                },\n                createVisual: function () {\n                  this$1.createDefaultVisual();\n                  var defaultVisual = this$1.visual;\n                  delete this$1.visual;\n                  return defaultVisual;\n                }\n              });\n            } else {\n              this.createDefaultVisual();\n            }\n          },\n          createDefaultVisual: function () {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var linePoints = ref.linePoints;\n            var lineOptions = {\n              stroke: {\n                color: options.color,\n                width: options.line.width,\n                dashType: options.line.dashType\n              }\n            };\n            ChartElement.fn.createVisual.call(this);\n\n            for (var idx = 0; idx < linePoints.length; idx += 2) {\n              var line = new Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n              alignPathToPixel(line);\n              this$1.visual.append(line);\n            }\n          }\n        });\n        setDefaultOptions(ErrorBarBase, {\n          animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n          },\n          endCaps: true,\n          line: {\n            width: 2\n          },\n          zIndex: 1\n        });\n        var CategoricalErrorBar = ErrorBarBase.extend({\n          getAxis: function () {\n            var axis = this.chart.seriesValueAxis(this.series);\n            return axis;\n          }\n        });\n        var MAX_EXPAND_DEPTH = 5;\n\n        function evalOptions(options, context, state, dryRun) {\n          if (state === void 0) {\n            state = {};\n          }\n\n          if (dryRun === void 0) {\n            dryRun = false;\n          }\n\n          var defaults = state.defaults = state.defaults || {};\n          var depth = state.depth = state.depth || 0;\n          var needsEval = false;\n          state.excluded = state.excluded || [];\n\n          if (depth > MAX_EXPAND_DEPTH) {\n            return null;\n          }\n\n          for (var property in options) {\n            if (!inArray(property, state.excluded) && options.hasOwnProperty(property)) {\n              var propValue = options[property];\n\n              if (isFunction(propValue)) {\n                needsEval = true;\n\n                if (!dryRun) {\n                  options[property] = valueOrDefault(propValue(context), defaults[property]);\n                }\n              } else if (isObject(propValue)) {\n                if (!dryRun) {\n                  state.defaults = defaults[property];\n                }\n\n                state.depth++;\n                needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;\n                state.depth--;\n              }\n            }\n          }\n\n          return needsEval;\n        }\n\n        function categoriesCount(series) {\n          var seriesCount = series.length;\n          var categories = 0;\n\n          for (var i = 0; i < seriesCount; i++) {\n            categories = Math.max(categories, series[i].data.length);\n          }\n\n          return categories;\n        }\n\n        var CategoricalChart = ChartElement.extend({\n          init: function (plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]); // Value axis ranges grouped by axis name, e.g.:\n            // primary: { min: 0, max: 1 }\n\n            this.valueAxisRanges = {};\n            this.points = [];\n            this.categoryPoints = [];\n            this.seriesPoints = [];\n            this.seriesOptions = [];\n            this._evalSeries = [];\n            this.render();\n          },\n          render: function () {\n            this.traverseDataPoints(this.addValue.bind(this));\n          },\n          pointOptions: function (series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n\n            if (!options) {\n              var defaults = this.pointType().prototype.defaults;\n              this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                vertical: !this.options.invertAxes\n              }, series);\n            }\n\n            return options;\n          },\n          plotValue: function (point) {\n            if (!point) {\n              return 0;\n            }\n\n            if (this.options.isStacked100 && isNumber(point.value)) {\n              var categoryIx = point.categoryIx;\n              var categoryPoints = this.categoryPoints[categoryIx];\n              var otherValues = [];\n              var categorySum = 0;\n\n              for (var i = 0; i < categoryPoints.length; i++) {\n                var other = categoryPoints[i];\n\n                if (other) {\n                  var stack = point.series.stack;\n                  var otherStack = other.series.stack;\n\n                  if (stack && otherStack && stack.group !== otherStack.group) {\n                    continue;\n                  }\n\n                  if (isNumber(other.value)) {\n                    categorySum += Math.abs(other.value);\n                    otherValues.push(Math.abs(other.value));\n                  }\n                }\n              }\n\n              if (categorySum > 0) {\n                return point.value / categorySum;\n              }\n            }\n\n            return point.value;\n          },\n          plotRange: function (point, startValue) {\n            var this$1 = this;\n\n            if (startValue === void 0) {\n              startValue = 0;\n            }\n\n            var categoryPoints = this.categoryPoints[point.categoryIx];\n\n            if (this.options.isStacked) {\n              var plotValue = this.plotValue(point);\n              var positive = plotValue >= 0;\n              var prevValue = startValue;\n              var isStackedBar = false;\n\n              for (var i = 0; i < categoryPoints.length; i++) {\n                var other = categoryPoints[i];\n\n                if (point === other) {\n                  break;\n                }\n\n                var stack = point.series.stack;\n                var otherStack = other.series.stack;\n\n                if (stack && otherStack) {\n                  if (typeof stack === datavizConstants.STRING && stack !== otherStack) {\n                    continue;\n                  }\n\n                  if (stack.group && stack.group !== otherStack.group) {\n                    continue;\n                  }\n                }\n\n                var otherValue = this$1.plotValue(other);\n\n                if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n                  prevValue += otherValue;\n                  plotValue += otherValue;\n                  isStackedBar = true;\n\n                  if (this$1.options.isStacked100) {\n                    plotValue = Math.min(plotValue, 1);\n                  }\n                }\n              }\n\n              if (isStackedBar) {\n                prevValue -= startValue;\n              }\n\n              return [prevValue, plotValue];\n            }\n\n            var series = point.series;\n            var valueAxis = this.seriesValueAxis(series);\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n            return [axisCrossingValue, dataviz.convertableToNumber(point.value) ? point.value : axisCrossingValue];\n          },\n          stackLimits: function (axisName, stackName) {\n            var this$1 = this;\n            var min = MAX_VALUE;\n            var max = MIN_VALUE;\n\n            for (var i = 0; i < this.categoryPoints.length; i++) {\n              var categoryPoints = this$1.categoryPoints[i];\n\n              if (!categoryPoints) {\n                continue;\n              }\n\n              for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n                var point = categoryPoints[pIx];\n\n                if (point) {\n                  if (point.series.stack === stackName || point.series.axis === axisName) {\n                    var to = this$1.plotRange(point, 0)[1];\n\n                    if (defined(to) && isFinite(to)) {\n                      max = Math.max(max, to);\n                      min = Math.min(min, to);\n                    }\n                  }\n                }\n              }\n            }\n\n            return {\n              min: min,\n              max: max\n            };\n          },\n          updateStackRange: function () {\n            var this$1 = this;\n            var ref = this.options;\n            var isStacked = ref.isStacked;\n            var chartSeries = ref.series;\n            var limitsCache = {};\n\n            if (isStacked) {\n              for (var i = 0; i < chartSeries.length; i++) {\n                var series = chartSeries[i];\n                var axisName = series.axis;\n                var key = axisName + series.stack;\n                var limits = limitsCache[key];\n\n                if (!limits) {\n                  limits = this$1.stackLimits(axisName, series.stack);\n                  var errorTotals = this$1.errorTotals;\n\n                  if (errorTotals) {\n                    if (errorTotals.negative.length) {\n                      limits.min = Math.min(limits.min, dataviz.sparseArrayLimits(errorTotals.negative).min);\n                    }\n\n                    if (errorTotals.positive.length) {\n                      limits.max = Math.max(limits.max, dataviz.sparseArrayLimits(errorTotals.positive).max);\n                    }\n                  }\n\n                  if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n                    limitsCache[key] = limits;\n                  } else {\n                    limits = null;\n                  }\n                }\n\n                if (limits) {\n                  this$1.valueAxisRanges[axisName] = limits;\n                }\n              }\n            }\n          },\n          addErrorBar: function (point, data, categoryIx) {\n            var value = point.value;\n            var series = point.series;\n            var seriesIx = point.seriesIx;\n            var errorBars = point.options.errorBars;\n            var lowValue = data.fields[ERROR_LOW_FIELD];\n            var highValue = data.fields[ERROR_HIGH_FIELD];\n            var errorRange;\n\n            if (isNumber(lowValue) && isNumber(highValue)) {\n              errorRange = {\n                low: lowValue,\n                high: highValue\n              };\n            } else if (errorBars && defined(errorBars.value)) {\n              this.seriesErrorRanges = this.seriesErrorRanges || [];\n              this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n              errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n            }\n\n            if (errorRange) {\n              point.low = errorRange.low;\n              point.high = errorRange.high;\n              this.addPointErrorBar(point, categoryIx);\n            }\n          },\n          addPointErrorBar: function (point, categoryIx) {\n            var isVertical = !this.options.invertAxes;\n            var options = point.options.errorBars;\n            var series = point.series;\n            var low = point.low;\n            var high = point.high;\n\n            if (this.options.isStacked) {\n              var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n              low = stackedErrorRange.low;\n              high = stackedErrorRange.high;\n            } else {\n              var fields = {\n                categoryIx: categoryIx,\n                series: series\n              };\n              this.updateRange({\n                value: low\n              }, fields);\n              this.updateRange({\n                value: high\n              }, fields);\n            }\n\n            var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n            point.errorBars = [errorBar];\n            point.append(errorBar);\n          },\n          stackedErrorRange: function (point, categoryIx) {\n            var plotValue = this.plotRange(point, 0)[1] - point.value;\n            var low = point.low + plotValue;\n            var high = point.high + plotValue;\n            this.errorTotals = this.errorTotals || {\n              positive: [],\n              negative: []\n            };\n\n            if (low < 0) {\n              this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n            }\n\n            if (high > 0) {\n              this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n            }\n\n            return {\n              low: low,\n              high: high\n            };\n          },\n          addValue: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var categoryPoints = this.categoryPoints[categoryIx];\n\n            if (!categoryPoints) {\n              this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            var seriesPoints = this.seriesPoints[seriesIx];\n\n            if (!seriesPoints) {\n              this.seriesPoints[seriesIx] = seriesPoints = [];\n            }\n\n            var point = this.createPoint(data, fields);\n\n            if (point) {\n              $.extend(point, fields);\n              point.owner = this;\n              point.noteText = data.fields.noteText;\n\n              if (!defined(point.dataItem)) {\n                point.dataItem = series.data[categoryIx];\n              }\n\n              this.addErrorBar(point, data, categoryIx);\n            }\n\n            this.points.push(point);\n            seriesPoints.push(point);\n            categoryPoints.push(point);\n            this.updateRange(data.valueFields, fields);\n          },\n          evalPointOptions: function (options, value, category, categoryIx, series, seriesIx) {\n            var state = {\n              defaults: series._defaults,\n              excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n            };\n            var doEval = this._evalSeries[seriesIx];\n\n            if (!defined(doEval)) {\n              this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n\n            if (doEval) {\n              pointOptions = deepExtend({}, pointOptions);\n              evalOptions(pointOptions, {\n                value: value,\n                category: category,\n                index: categoryIx,\n                series: series,\n                dataItem: series.data[categoryIx]\n              }, state);\n            }\n\n            return pointOptions;\n          },\n          updateRange: function (data, fields) {\n            var axisName = fields.series.axis;\n            var value = data.value;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (isFinite(value) && value !== null) {\n              axisRange = this.valueAxisRanges[axisName] = axisRange || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n              axisRange.min = Math.min(axisRange.min, value);\n              axisRange.max = Math.max(axisRange.max, value);\n            }\n          },\n          seriesValueAxis: function (series) {\n            var plotArea = this.plotArea;\n            var axisName = series.axis;\n            var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n            if (!axis) {\n              throw new Error(\"Unable to locate value axis with name \" + axisName);\n            }\n\n            return axis;\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var categorySlots = this.categorySlots = [];\n            var chartPoints = this.points;\n            var categoryAxis = this.categoryAxis;\n            var pointIx = 0;\n            this.traverseDataPoints(function (data, fields) {\n              var categoryIx = fields.categoryIx;\n              var currentSeries = fields.series;\n              var valueAxis = this$1.seriesValueAxis(currentSeries);\n              var point = chartPoints[pointIx++];\n              var categorySlot = categorySlots[categoryIx];\n\n              if (!categorySlot) {\n                categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n              }\n\n              if (point) {\n                var plotRange = this$1.plotRange(point, valueAxis.startValue());\n                var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n\n                if (valueSlot) {\n                  var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n                  point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n                  point.stackValue = plotRange[1];\n\n                  if (this$1.options.isStacked100) {\n                    point.percentage = this$1.plotValue(point);\n                  }\n\n                  this$1.reflowPoint(point, pointSlot);\n                } else {\n                  point.visible = false;\n                }\n              }\n            });\n            this.reflowCategories(categorySlots);\n\n            if (!this.options.clip && this.options.limitPoints && this.points.length) {\n              this.limitPoints();\n            }\n\n            this.box = targetBox;\n          },\n          valueSlot: function (valueAxis, plotRange) {\n            return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n          },\n          limitPoints: function () {\n            var this$1 = this;\n            var categoryPoints = this.categoryPoints;\n            var points = categoryPoints[0].concat(last(categoryPoints));\n\n            for (var idx = 0; idx < points.length; idx++) {\n              if (points[idx]) {\n                this$1.limitPoint(points[idx]);\n              }\n            }\n          },\n          limitPoint: function (point) {\n            var limittedSlot = this.categoryAxis.limitSlot(point.box);\n\n            if (!limittedSlot.equals(point.box)) {\n              point.reflow(limittedSlot);\n            }\n          },\n          aboveAxis: function (point, valueAxis) {\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n            var value = point.value;\n            return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n          },\n          categoryAxisCrossingValue: function (valueAxis) {\n            var categoryAxis = this.categoryAxis;\n            var options = valueAxis.options;\n            var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n            return crossingValues[categoryAxis.axisIndex || 0] || 0;\n          },\n          reflowPoint: function (point, pointSlot) {\n            point.reflow(pointSlot);\n          },\n          reflowCategories: function () {},\n          pointSlot: function (categorySlot, valueSlot) {\n            var options = this.options;\n            var invertAxes = options.invertAxes;\n            var slotX = invertAxes ? valueSlot : categorySlot;\n            var slotY = invertAxes ? categorySlot : valueSlot;\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n          },\n          categorySlot: function (categoryAxis, categoryIx) {\n            return categoryAxis.getSlot(categoryIx);\n          },\n          traverseDataPoints: function (callback) {\n            var this$1 = this;\n            var series = this.options.series;\n            var count = categoriesCount(series);\n            var seriesCount = series.length;\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n              this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n            }\n\n            for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n              for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n                var currentSeries = series[seriesIx$1];\n                var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n\n                var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n\n                callback(pointData, {\n                  category: currentCategory,\n                  categoryIx: categoryIx,\n                  categoriesCount: count,\n                  series: currentSeries,\n                  seriesIx: seriesIx$1\n                });\n              }\n            }\n\n            for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n              this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n            }\n          },\n          _outOfRangeCallback: function (series, field, seriesIx, callback) {\n            var outOfRangePoint = series[field];\n\n            if (outOfRangePoint) {\n              var categoryIx = outOfRangePoint.categoryIx;\n\n              var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n              callback(pointData, {\n                category: outOfRangePoint.category,\n                categoryIx: categoryIx,\n                series: series,\n                seriesIx: seriesIx,\n                dataItem: outOfRangePoint.item\n              });\n            }\n          },\n          _bindPoint: function (series, seriesIx, categoryIx, item) {\n            if (!this._bindCache) {\n              this._bindCache = [];\n            }\n\n            var bindCache = this._bindCache[seriesIx];\n\n            if (!bindCache) {\n              bindCache = this._bindCache[seriesIx] = [];\n            }\n\n            var data = bindCache[categoryIx];\n\n            if (!data) {\n              data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n            }\n\n            return data;\n          },\n          formatPointValue: function (point, format) {\n            if (point.value === null) {\n              return \"\";\n            }\n\n            return this.chartService.format.auto(format, point.value);\n          },\n          pointValue: function (data) {\n            return data.valueFields.value;\n          }\n        });\n        setDefaultOptions(CategoricalChart, {\n          series: [],\n          invertAxes: false,\n          isStacked: false,\n          clip: true,\n          limitPoints: true\n        });\n        var PointEventsMixin = {\n          click: function (chart, e) {\n            return chart.trigger(SERIES_CLICK, this.eventArgs(e));\n          },\n          hover: function (chart, e) {\n            return chart.trigger(SERIES_HOVER, this.eventArgs(e));\n          },\n          over: function (chart, e) {\n            return chart.trigger(SERIES_OVER, this.eventArgs(e));\n          },\n          out: function (chart, e) {\n            return chart.trigger(SERIES_LEAVE, this.eventArgs(e));\n          },\n          eventArgs: function (e) {\n            return {\n              value: this.value,\n              percentage: this.percentage,\n              stackValue: this.stackValue,\n              category: this.category,\n              series: this.series,\n              dataItem: this.dataItem,\n              runningTotal: this.runningTotal,\n              total: this.total,\n              element: eventElement(e),\n              originalEvent: e,\n              point: this\n            };\n          }\n        };\n        var NoteMixin = {\n          createNote: function () {\n            var options = this.options.notes;\n            var text = this.noteText || options.label.text;\n\n            if (options.visible !== false && defined(text) && text !== null) {\n              this.note = new dataviz.Note({\n                value: this.value,\n                text: text,\n                dataItem: this.dataItem,\n                category: this.category,\n                series: this.series\n              }, this.options.notes, this.owner.chartService);\n              this.append(this.note);\n            }\n          }\n        };\n        var LinePoint = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this);\n            this.value = value;\n            this.options = options;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.tooltipTracking = true;\n          },\n          render: function () {\n            var ref = this.options;\n            var markers = ref.markers;\n            var labels = ref.labels;\n\n            if (this._rendered) {\n              return;\n            }\n\n            this._rendered = true;\n\n            if (markers.visible && markers.size) {\n              this.marker = this.createMarker();\n              this.append(this.marker);\n            }\n\n            if (labels.visible) {\n              var labelTemplate = getTemplate(labels);\n              var pointData = this.pointData();\n              var labelText = this.value;\n\n              if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n              } else if (labels.format) {\n                labelText = this.formatValue(labels.format);\n              }\n\n              this.label = new TextBox(labelText, deepExtend({\n                align: CENTER,\n                vAlign: CENTER,\n                margin: {\n                  left: 5,\n                  right: 5\n                },\n                zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n              }, labels), pointData);\n              this.append(this.label);\n            }\n\n            this.createNote();\n\n            if (this.errorBar) {\n              this.append(this.errorBar);\n            }\n          },\n          markerBorder: function () {\n            var options = this.options.markers;\n            var background = options.background;\n            var border = deepExtend({\n              color: this.color\n            }, options.border);\n\n            if (!defined(border.color)) {\n              border.color = new Color(background).brightness(BORDER_BRIGHTNESS).toHex();\n            }\n\n            return border;\n          },\n          createVisual: function () {},\n          createMarker: function () {\n            var options = this.options.markers;\n            var marker = new ShapeElement({\n              type: options.type,\n              width: options.size,\n              height: options.size,\n              rotation: options.rotation,\n              background: options.background,\n              border: this.markerBorder(),\n              opacity: this.series.opacity || options.opacity,\n              zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n              animation: options.animation,\n              visual: options.visual\n            }, {\n              dataItem: this.dataItem,\n              value: this.value,\n              series: this.series,\n              category: this.category\n            });\n            return marker;\n          },\n          markerBox: function () {\n            if (!this.marker) {\n              this.marker = this.createMarker();\n              this.marker.reflow(this._childBox);\n            }\n\n            return this.marker.box;\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var aboveAxis = ref.aboveAxis;\n            var vertical = options.vertical;\n            this.render();\n            this.box = targetBox;\n            var childBox = targetBox.clone();\n\n            if (vertical) {\n              if (aboveAxis) {\n                childBox.y1 -= childBox.height();\n              } else {\n                childBox.y2 += childBox.height();\n              }\n            } else {\n              if (aboveAxis) {\n                childBox.x1 += childBox.width();\n              } else {\n                childBox.x2 -= childBox.width();\n              }\n            }\n\n            this._childBox = childBox;\n\n            if (this.marker) {\n              this.marker.reflow(childBox);\n            }\n\n            this.reflowLabel(childBox);\n\n            if (this.errorBars) {\n              for (var i = 0; i < this.errorBars.length; i++) {\n                this$1.errorBars[i].reflow(childBox);\n              }\n            }\n\n            if (this.note) {\n              var noteTargetBox = this.markerBox();\n\n              if (!(options.markers.visible && options.markers.size)) {\n                var center = noteTargetBox.center();\n                noteTargetBox = new Box(center.x, center.y, center.x, center.y);\n              }\n\n              this.note.reflow(noteTargetBox);\n            }\n          },\n          reflowLabel: function (box) {\n            var ref = this;\n            var options = ref.options;\n            var label = ref.label;\n            var anchor = options.labels.position;\n\n            if (label) {\n              anchor = anchor === ABOVE ? TOP : anchor;\n              anchor = anchor === BELOW ? BOTTOM : anchor;\n              label.reflow(box);\n              label.box.alignTo(this.markerBox(), anchor);\n              label.reflow(label.box);\n            }\n          },\n          createHighlight: function () {\n            var markers = this.options.highlight.markers;\n            var defaultColor = this.markerBorder().color;\n            var options = this.options.markers;\n            var size = options.size + (options.border.width || 0) + (markers.border.width || 0);\n            var shadow = new ShapeElement({\n              type: options.type,\n              width: size,\n              height: size,\n              rotation: options.rotation,\n              background: markers.color || defaultColor,\n              border: {\n                color: markers.border.color,\n                width: markers.border.width,\n                opacity: valueOrDefault(markers.border.opacity, 1)\n              },\n              opacity: valueOrDefault(markers.opacity, 1)\n            });\n            shadow.reflow(this._childBox);\n            return shadow.getElement();\n          },\n          highlightVisual: function () {\n            return (this.marker || {}).visual;\n          },\n          highlightVisualArgs: function () {\n            var marker = this.marker;\n            var visual, rect;\n\n            if (marker) {\n              rect = marker.paddingBox.toRect();\n              visual = marker.visual;\n            } else {\n              var size = this.options.markers.size;\n              var halfSize = size / 2;\n              var center = this.box.center();\n              rect = new geometry.Rect([center.x - halfSize, center.y - halfSize], [size, size]);\n            }\n\n            return {\n              options: this.options,\n              rect: rect,\n              visual: visual\n            };\n          },\n          tooltipAnchor: function () {\n            var markerBox = this.markerBox();\n            var clipBox = this.owner.pane.clipBox();\n            var showTooltip = !clipBox || clipBox.overlaps(markerBox);\n\n            if (showTooltip) {\n              var x = markerBox.x2 + TOOLTIP_OFFSET;\n              var horizontalAlign = LEFT;\n              var y, verticalAlign;\n\n              if (this.aboveAxis) {\n                y = markerBox.y1;\n                verticalAlign = BOTTOM;\n              } else {\n                y = markerBox.y2;\n                verticalAlign = TOP;\n              }\n\n              return {\n                point: new Point(x, y),\n                align: {\n                  horizontal: horizontalAlign,\n                  vertical: verticalAlign\n                }\n              };\n            }\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          overlapsBox: function (box) {\n            var markerBox = this.markerBox();\n            return markerBox.overlaps(box);\n          },\n          unclipElements: function () {\n            if (this.label) {\n              this.label.options.noclip = true;\n            }\n\n            if (this.note) {\n              this.note.options.noclip = true;\n            }\n          },\n          pointData: function () {\n            return {\n              dataItem: this.dataItem,\n              category: this.category,\n              value: this.value,\n              percentage: this.percentage,\n              stackValue: this.stackValue,\n              series: this.series\n            };\n          }\n        });\n        LinePoint.prototype.defaults = {\n          vertical: true,\n          markers: {\n            visible: true,\n            background: WHITE,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            border: {\n              width: 2\n            },\n            opacity: 1\n          },\n          labels: {\n            visible: false,\n            position: ABOVE,\n            margin: getSpacing(3),\n            padding: getSpacing(4),\n            animation: {\n              type: FADEIN,\n              delay: INITIAL_ANIMATION_DURATION\n            }\n          },\n          notes: {\n            label: {}\n          },\n          highlight: {\n            markers: {\n              border: {\n                color: \"#fff\",\n                width: 2\n              }\n            },\n            zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n          },\n          errorBars: {\n            line: {\n              width: 1\n            }\n          }\n        };\n        deepExtend(LinePoint.prototype, PointEventsMixin);\n        deepExtend(LinePoint.prototype, NoteMixin);\n        var LineSegment = ChartElement.extend({\n          init: function (linePoints, series, seriesIx) {\n            ChartElement.fn.init.call(this);\n            this.linePoints = linePoints;\n            this.series = series;\n            this.seriesIx = seriesIx;\n          },\n          points: function () {\n            return this.toGeometryPoints(this.linePoints);\n          },\n          toGeometryPoints: function (points) {\n            var result = [];\n\n            for (var i = 0, length = points.length; i < length; i++) {\n              if (points[i] && points[i].visible !== false) {\n                result.push(points[i]._childBox.toRect().center());\n              }\n            }\n\n            return result;\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var customVisual = this.series.visual;\n\n            if (customVisual) {\n              this.visual = customVisual({\n                points: this.toGeometryPoints(this.linePoints),\n                series: this.series,\n                sender: this.getSender(),\n                createVisual: function () {\n                  this$1.segmentVisual();\n                  return this$1.visual;\n                }\n              });\n\n              if (this.visual && !defined(this.visual.options.zIndex)) {\n                this.visual.options.zIndex = this.series.zIndex;\n              }\n            } else {\n              this.segmentVisual();\n            }\n          },\n          segmentVisual: function () {\n            var ref = this;\n            var options = ref.options;\n            var series = ref.series;\n            var color = series.color;\n            var defaults = series._defaults;\n\n            if (isFunction(color) && defaults) {\n              color = defaults.color;\n            }\n\n            var line = Path.fromPoints(this.points(), {\n              stroke: {\n                color: color,\n                width: series.width,\n                opacity: series.opacity,\n                dashType: series.dashType\n              },\n              zIndex: series.zIndex\n            });\n\n            if (options.closed) {\n              line.close();\n            }\n\n            this.visual = line;\n          },\n          aliasFor: function (e, coords) {\n            return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n          }\n        });\n        setDefaultOptions(LineSegment, {\n          closed: false\n        });\n        var StepLineMixin = {\n          calculateStepPoints: function (points) {\n            var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);\n            var ref = categoryAxis.options;\n            var justified = ref.justified;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var stepAxis = vertical ? X : Y;\n            var axis = vertical ? Y : X;\n            var stepDir = reverse ? 2 : 1;\n            var dir = stepDir;\n            var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);\n            var result = [previousPoint];\n\n            for (var idx = 1; idx < points.length; idx++) {\n              var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);\n\n              if (previousPoint[stepAxis] !== point[stepAxis]) {\n                var stepPoint = new GeometryPoint();\n                stepPoint[stepAxis] = previousPoint[stepAxis];\n                stepPoint[axis] = point[axis];\n                result.push(stepPoint, point);\n              }\n\n              previousPoint = point;\n            }\n\n            if (!justified) {\n              result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));\n            } else if (previousPoint !== last(result)) {\n              result.push(previousPoint);\n            }\n\n            return result;\n          }\n        };\n\n        function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {\n          var box = lintPoint.box;\n          var result = new GeometryPoint();\n          result[stepAxis] = box[stepAxis + stepDir];\n          result[axis] = box[axis + dir];\n          return result;\n        }\n\n        var StepLineSegment = LineSegment.extend({\n          points: function () {\n            return this.calculateStepPoints(this.linePoints);\n          }\n        });\n        deepExtend(StepLineSegment.prototype, StepLineMixin);\n        var SplineSegment = LineSegment.extend({\n          segmentVisual: function () {\n            var series = this.series;\n            var defaults = series._defaults;\n            var color = series.color;\n\n            if (isFunction(color) && defaults) {\n              color = defaults.color;\n            }\n\n            var curveProcessor = new CurveProcessor(this.options.closed);\n            var segments = curveProcessor.process(this.points());\n            var curve = new Path({\n              stroke: {\n                color: color,\n                width: series.width,\n                opacity: series.opacity,\n                dashType: series.dashType\n              },\n              zIndex: series.zIndex\n            });\n            curve.segments.push.apply(curve.segments, segments);\n            this.visual = curve;\n          }\n        });\n        var LineChartMixin = {\n          renderSegments: function () {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var seriesPoints = ref.seriesPoints;\n            var series = options.series;\n            var seriesCount = seriesPoints.length;\n            var lastSegment;\n            this._segments = [];\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);\n              var pointCount = sortedPoints.length;\n              var linePoints = [];\n\n              for (var pointIx = 0; pointIx < pointCount; pointIx++) {\n                var point = sortedPoints[pointIx];\n\n                if (point) {\n                  linePoints.push(point);\n                } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n                  if (linePoints.length > 1) {\n                    lastSegment = this$1.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n\n                    this$1._addSegment(lastSegment);\n                  }\n\n                  linePoints = [];\n                }\n              }\n\n              if (linePoints.length > 1) {\n                lastSegment = this$1.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n\n                this$1._addSegment(lastSegment);\n              }\n            }\n\n            this.children.unshift.apply(this.children, this._segments);\n          },\n          _addSegment: function (segment) {\n            this._segments.push(segment);\n\n            segment.parent = this;\n          },\n          sortPoints: function (points) {\n            return points;\n          },\n          seriesMissingValues: function (series) {\n            var missingValues = series.missingValues;\n            var assumeZero = !missingValues && this.options.isStacked;\n            return assumeZero ? ZERO : missingValues || INTERPOLATE;\n          },\n          getNearestPoint: function (x, y, seriesIx) {\n            var target = new Point(x, y);\n            var allPoints = this.seriesPoints[seriesIx];\n            var nearestPointDistance = MAX_VALUE;\n            var nearestPoint;\n\n            for (var i = 0; i < allPoints.length; i++) {\n              var point = allPoints[i];\n\n              if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n                var pointBox = point.box;\n                var pointDistance = pointBox.center().distanceTo(target);\n\n                if (pointDistance < nearestPointDistance) {\n                  nearestPoint = point;\n                  nearestPointDistance = pointDistance;\n                }\n              }\n            }\n\n            return nearestPoint;\n          }\n        };\n        var ClipAnimation = Animation.extend({\n          setup: function () {\n            this._setEnd(this.options.box.x1);\n          },\n          step: function (pos) {\n            var box = this.options.box;\n\n            this._setEnd(dataviz.interpolateValue(box.x1, box.x2, pos));\n          },\n          _setEnd: function (x) {\n            var element = this.element;\n            var segments = element.segments;\n            var topRight = segments[1].anchor();\n            var bottomRight = segments[2].anchor();\n            element.suspend();\n            topRight.setX(x);\n            element.resume();\n            bottomRight.setX(x);\n          }\n        });\n        setDefaultOptions(ClipAnimation, {\n          duration: INITIAL_ANIMATION_DURATION\n        });\n        AnimationFactory.current.register(\"clip\", ClipAnimation);\n\n        function anyHasZIndex(elements) {\n          for (var idx = 0; idx < elements.length; idx++) {\n            if (defined(elements[idx].zIndex)) {\n              return true;\n            }\n          }\n        }\n\n        var ClipAnimationMixin = {\n          createAnimation: function () {\n            var root = this.getRoot();\n\n            if (root && (root.options || {}).transitions !== false) {\n              var box = root.size();\n              var clipPath = Path.fromRect(box.toRect());\n              this.visual.clip(clipPath);\n              this.animation = new ClipAnimation(clipPath, {\n                box: box\n              });\n\n              if (anyHasZIndex(this.options.series)) {\n                this._setChildrenAnimation(clipPath);\n              }\n            }\n          },\n          _setChildrenAnimation: function (clipPath) {\n            var points = this.animationPoints();\n\n            for (var idx = 0; idx < points.length; idx++) {\n              var point = points[idx];\n\n              if (point && point.visual && defined(point.visual.options.zIndex)) {\n                point.visual.clip(clipPath);\n              }\n            }\n          }\n        };\n        var LineChart = CategoricalChart.extend({\n          render: function () {\n            CategoricalChart.fn.render.call(this);\n            this.updateStackRange();\n            this.renderSegments();\n          },\n          pointType: function () {\n            return LinePoint;\n          },\n          createPoint: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var missingValues = this.seriesMissingValues(series);\n            var value = data.valueFields.value;\n\n            if (!defined(value) || value === null) {\n              if (missingValues === ZERO) {\n                value = 0;\n              } else {\n                return null;\n              }\n            }\n\n            var pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n            var color = data.fields.color || series.color;\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            var point = new LinePoint(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n          },\n          plotRange: function (point) {\n            var this$1 = this;\n            var plotValue = this.plotValue(point);\n\n            if (this.options.isStacked) {\n              var categoryIx = point.categoryIx;\n              var categoryPoints = this.categoryPoints[categoryIx];\n\n              for (var i = 0; i < categoryPoints.length; i++) {\n                var other = categoryPoints[i];\n\n                if (point === other) {\n                  break;\n                }\n\n                plotValue += this$1.plotValue(other);\n\n                if (this$1.options.isStacked100) {\n                  plotValue = Math.min(plotValue, 1);\n                }\n              }\n            }\n\n            return [plotValue, plotValue];\n          },\n          createSegment: function (linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === STEP) {\n              pointType = StepLineSegment;\n            } else if (style === SMOOTH) {\n              pointType = SplineSegment;\n            } else {\n              pointType = LineSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx);\n          },\n          animationPoints: function () {\n            var points = this.points;\n            var result = [];\n\n            for (var idx = 0; idx < points.length; idx++) {\n              result.push((points[idx] || {}).marker);\n            }\n\n            return result.concat(this._segments);\n          },\n          supportsPointInactiveOpacity: function () {\n            return false;\n          }\n        });\n        deepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);\n        var AreaSegment = LineSegment.extend({\n          init: function (linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n            LineSegment.fn.init.call(this, linePoints, currentSeries, seriesIx);\n            this.prevSegment = prevSegment;\n            this.stackPoints = stackPoints;\n          },\n          createVisual: function () {\n            var series = this.series;\n            var defaults = series._defaults;\n            var lineOptions = series.line || {};\n            var color = series.color;\n\n            if (isFunction(color) && defaults) {\n              color = defaults.color;\n            }\n\n            this.visual = new Group({\n              zIndex: series.zIndex\n            });\n            this.createFill({\n              fill: {\n                color: color,\n                opacity: series.opacity\n              },\n              stroke: null\n            });\n\n            if (lineOptions.width > 0 && lineOptions.visible !== false) {\n              this.createStroke({\n                stroke: deepExtend({\n                  color: color,\n                  opacity: series.opacity,\n                  lineCap: \"butt\"\n                }, lineOptions)\n              });\n            }\n          },\n          strokeSegments: function () {\n            var segments = this._strokeSegments;\n\n            if (!segments) {\n              segments = this._strokeSegments = this.createStrokeSegments();\n            }\n\n            return segments;\n          },\n          createStrokeSegments: function () {\n            return this.segmentsFromPoints(this.points());\n          },\n          stackSegments: function () {\n            if (this.prevSegment) {\n              return this.prevSegment.createStackSegments(this.stackPoints);\n            }\n\n            return this.createStackSegments(this.stackPoints);\n          },\n          createStackSegments: function (stackPoints) {\n            return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n          },\n          segmentsFromPoints: function (points) {\n            return points.map(function (point) {\n              return new geometry.Segment(point);\n            });\n          },\n          createStroke: function (style) {\n            var stroke = new Path(style);\n            stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n            this.visual.append(stroke);\n          },\n          hasStackSegment: function () {\n            return this.prevSegment || this.stackPoints && this.stackPoints.length;\n          },\n          createFill: function (style) {\n            var strokeSegments = this.strokeSegments();\n            var fillSegments = strokeSegments.slice(0);\n            var hasStackSegments = this.hasStackSegment();\n\n            if (hasStackSegments) {\n              var stackSegments = this.stackSegments();\n              append(fillSegments, stackSegments);\n            }\n\n            var fill = new Path(style);\n            fill.segments.push.apply(fill.segments, fillSegments);\n\n            if (!hasStackSegments && strokeSegments.length > 1) {\n              this.fillToAxes(fill);\n            }\n\n            this.visual.append(fill);\n          },\n          fillToAxes: function (fillPath) {\n            var chart = this.parent;\n            var invertAxes = chart.options.invertAxes;\n            var valueAxis = chart.seriesValueAxis(this.series);\n            var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n            var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n            var segments = this.strokeSegments();\n            var firstPoint = segments[0].anchor();\n            var lastPoint = last(segments).anchor();\n            var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n            if (invertAxes) {\n              fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);\n            } else {\n              fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);\n            }\n          }\n        });\n        var StepAreaSegment = AreaSegment.extend({\n          createStrokeSegments: function () {\n            return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));\n          },\n          createStackSegments: function (stackPoints) {\n            return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();\n          }\n        });\n        deepExtend(StepAreaSegment.prototype, StepLineMixin);\n        var SplineAreaSegment = AreaSegment.extend({\n          createStrokeSegments: function () {\n            var curveProcessor = new CurveProcessor(this.options.closed);\n            var linePoints = this.points();\n            return curveProcessor.process(linePoints);\n          },\n          createStackSegments: function () {\n            var strokeSegments = this.strokeSegments();\n            var stackSegments = [];\n\n            for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {\n              var segment = strokeSegments[idx];\n              stackSegments.push(new geometry.Segment(segment.anchor(), segment.controlOut(), segment.controlIn()));\n            }\n\n            return stackSegments;\n          }\n        });\n        var AreaChart = LineChart.extend({\n          createSegment: function (linePoints, currentSeries, seriesIx, prevSegment) {\n            var isStacked = this.options.isStacked;\n            var style = (currentSeries.line || {}).style;\n            var previousSegment;\n            var stackPoints;\n\n            if (isStacked && seriesIx > 0 && prevSegment) {\n              var missingValues = this.seriesMissingValues(currentSeries);\n\n              if (missingValues !== \"gap\") {\n                stackPoints = prevSegment.linePoints;\n                previousSegment = prevSegment;\n              } else {\n                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n              }\n            }\n\n            var pointType;\n\n            if (style === STEP) {\n              pointType = StepAreaSegment;\n            } else if (style === SMOOTH) {\n              pointType = SplineAreaSegment;\n            } else {\n              pointType = AreaSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            LineChart.fn.reflow.call(this, targetBox);\n            var stackPoints = this._stackPoints;\n\n            if (stackPoints) {\n              for (var idx = 0; idx < stackPoints.length; idx++) {\n                var stackPoint = stackPoints[idx];\n                var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n                stackPoint.reflow(pointSlot);\n              }\n            }\n          },\n          _gapStackPoints: function (linePoints, seriesIx, style) {\n            var this$1 = this;\n            var seriesPoints = this.seriesPoints;\n            var startIdx = linePoints[0].categoryIx;\n            var length = linePoints.length;\n\n            if (startIdx < 0) {\n              startIdx = 0;\n              length--;\n            }\n\n            var endIdx = startIdx + length;\n            var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n            var stackPoints = [];\n            this._stackPoints = this._stackPoints || [];\n\n            for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n              var pointIx = categoryIx + pointOffset;\n              var currentSeriesIx = seriesIx;\n              var point = void 0;\n\n              do {\n                currentSeriesIx--;\n                point = seriesPoints[currentSeriesIx][pointIx];\n              } while (currentSeriesIx > 0 && !point);\n\n              if (point) {\n                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                  stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                }\n\n                stackPoints.push(point);\n\n                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                  stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                }\n              } else {\n                var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n\n                this$1._stackPoints.push(gapStackPoint);\n\n                stackPoints.push(gapStackPoint);\n              }\n            }\n\n            return stackPoints;\n          },\n          _previousSegmentPoint: function (categoryIx, pointIx, segmentIx, seriesIdx) {\n            var seriesPoints = this.seriesPoints;\n            var index = seriesIdx;\n            var point;\n\n            while (index > 0 && !point) {\n              index--;\n              point = seriesPoints[index][segmentIx];\n            }\n\n            if (!point) {\n              point = this._createGapStackPoint(categoryIx);\n\n              this._stackPoints.push(point);\n            } else {\n              point = seriesPoints[index][pointIx];\n            }\n\n            return point;\n          },\n          _createGapStackPoint: function (categoryIx) {\n            var options = this.pointOptions({}, 0);\n            var point = new LinePoint(0, options);\n            point.categoryIx = categoryIx;\n            point.series = {};\n            return point;\n          },\n          seriesMissingValues: function (series) {\n            return series.missingValues || ZERO;\n          },\n          supportsPointInactiveOpacity: function () {\n            return false;\n          }\n        });\n        var AxisGroupRangeTracker = Class.extend({\n          init: function () {\n            this.axisRanges = {};\n          },\n          update: function (chartAxisRanges) {\n            var axisRanges = this.axisRanges;\n\n            for (var axisName in chartAxisRanges) {\n              var chartRange = chartAxisRanges[axisName];\n              var range = axisRanges[axisName];\n              axisRanges[axisName] = range = range || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n              range.min = Math.min(range.min, chartRange.min);\n              range.max = Math.max(range.max, chartRange.max);\n            }\n          },\n          reset: function (axisName) {\n            this.axisRanges[axisName] = undefined;\n          },\n          query: function (axisName) {\n            return this.axisRanges[axisName];\n          }\n        });\n        var BarLabel = ChartElement.extend({\n          init: function (content, options, pointData) {\n            ChartElement.fn.init.call(this, options);\n            this.textBox = new TextBox(content, this.options, pointData);\n            this.append(this.textBox);\n          },\n          createVisual: function () {\n            this.textBox.options.noclip = this.options.noclip;\n          },\n          reflow: function (targetBox) {\n            var options = this.options;\n            var vertical = options.vertical;\n            var aboveAxis = options.aboveAxis;\n            var text = this.children[0];\n            var textOptions = text.options;\n            var box = text.box;\n            var padding = text.options.padding;\n            var labelBox = targetBox;\n            textOptions.align = vertical ? CENTER : LEFT;\n            textOptions.vAlign = vertical ? TOP : CENTER;\n\n            if (options.position === INSIDE_END) {\n              if (vertical) {\n                textOptions.vAlign = TOP;\n\n                if (!aboveAxis && box.height() < targetBox.height()) {\n                  textOptions.vAlign = BOTTOM;\n                }\n              } else {\n                textOptions.align = aboveAxis ? RIGHT : LEFT;\n              }\n            } else if (options.position === CENTER) {\n              textOptions.vAlign = CENTER;\n              textOptions.align = CENTER;\n            } else if (options.position === INSIDE_BASE) {\n              if (vertical) {\n                textOptions.vAlign = aboveAxis ? BOTTOM : TOP;\n              } else {\n                textOptions.align = aboveAxis ? LEFT : RIGHT;\n              }\n            } else if (options.position === OUTSIDE_END) {\n              if (vertical) {\n                if (aboveAxis) {\n                  labelBox = new Box(targetBox.x1, targetBox.y1 - box.height(), targetBox.x2, targetBox.y1);\n                } else {\n                  labelBox = new Box(targetBox.x1, targetBox.y2, targetBox.x2, targetBox.y2 + box.height());\n                }\n              } else {\n                textOptions.align = CENTER;\n\n                if (aboveAxis) {\n                  labelBox = new Box(targetBox.x2, targetBox.y1, targetBox.x2 + box.width(), targetBox.y2);\n                } else {\n                  labelBox = new Box(targetBox.x1 - box.width(), targetBox.y1, targetBox.x1, targetBox.y2);\n                }\n              }\n            }\n\n            if (!options.rotation) {\n              if (vertical) {\n                padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;\n              } else {\n                padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;\n              }\n            }\n\n            text.reflow(labelBox);\n          },\n          alignToClipBox: function (clipBox) {\n            var vertical = this.options.vertical;\n            var field = vertical ? Y : X;\n            var start = field + \"1\";\n            var end = field + \"2\";\n            var text = this.children[0];\n            var parentBox = this.parent.box;\n\n            if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {\n              var targetBox = text.paddingBox.clone();\n              targetBox[start] = Math.max(parentBox[start], clipBox[start]);\n              targetBox[end] = Math.min(parentBox[end], clipBox[end]);\n              this.reflow(targetBox);\n            }\n          }\n        });\n        setDefaultOptions(BarLabel, {\n          position: OUTSIDE_END,\n          margin: getSpacing(3),\n          padding: getSpacing(4),\n          color: BLACK,\n          background: \"\",\n          border: {\n            width: 1,\n            color: \"\"\n          },\n          aboveAxis: true,\n          vertical: false,\n          animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n          },\n          zIndex: 2\n        });\n\n        function hasGradientOverlay(options) {\n          var overlay = options.overlay;\n          return overlay && overlay.gradient && overlay.gradient !== \"none\";\n        }\n\n        var BAR_ALIGN_MIN_WIDTH = 6;\n        var Bar = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this);\n            this.options = options;\n            this.color = options.color || WHITE;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.value = value;\n          },\n          render: function () {\n            if (this._rendered) {\n              return;\n            }\n\n            this._rendered = true;\n            this.createLabel();\n            this.createNote();\n\n            if (this.errorBar) {\n              this.append(this.errorBar);\n            }\n          },\n          createLabel: function () {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n              var pointData = this.pointData();\n              var labelTemplate = getTemplate(labels);\n              var labelText;\n\n              if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n              } else {\n                labelText = this.formatValue(labels.format);\n              }\n\n              this.label = new BarLabel(labelText, deepExtend({\n                vertical: options.vertical\n              }, labels), pointData);\n              this.append(this.label);\n            }\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            this.render();\n            var label = this.label;\n            this.box = targetBox;\n\n            if (label) {\n              label.options.aboveAxis = this.aboveAxis;\n              label.reflow(targetBox);\n            }\n\n            if (this.note) {\n              this.note.reflow(targetBox);\n            }\n\n            if (this.errorBars) {\n              for (var i = 0; i < this.errorBars.length; i++) {\n                this$1.errorBars[i].reflow(targetBox);\n              }\n            }\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var ref = this;\n            var box = ref.box;\n            var options = ref.options;\n            var customVisual = options.visual;\n\n            if (this.visible !== false) {\n              ChartElement.fn.createVisual.call(this);\n\n              if (customVisual) {\n                var visual = this.rectVisual = customVisual({\n                  category: this.category,\n                  dataItem: this.dataItem,\n                  value: this.value,\n                  sender: this.getSender(),\n                  series: this.series,\n                  percentage: this.percentage,\n                  stackValue: this.stackValue,\n                  runningTotal: this.runningTotal,\n                  total: this.total,\n                  rect: box.toRect(),\n                  createVisual: function () {\n                    var group = new Group();\n                    this$1.createRect(group);\n                    return group;\n                  },\n                  options: options\n                });\n\n                if (visual) {\n                  this.visual.append(visual);\n                }\n              } else if (box.width() > 0 && box.height() > 0) {\n                this.createRect(this.visual);\n              }\n            }\n          },\n          createRect: function (visual) {\n            var options = this.options;\n            var border = options.border;\n            var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n            var rect = this.box.toRect();\n            rect.size.width = Math.round(rect.size.width);\n            var path = this.rectVisual = Path.fromRect(rect, {\n              fill: {\n                color: this.color,\n                opacity: options.opacity\n              },\n              stroke: {\n                color: this.getBorderColor(),\n                width: border.width,\n                opacity: strokeOpacity,\n                dashType: border.dashType\n              }\n            });\n            var width = this.box.width();\n            var height = this.box.height();\n            var size = options.vertical ? width : height;\n\n            if (size > BAR_ALIGN_MIN_WIDTH) {\n              alignPathToPixel(path); // Fixes lineJoin issue in firefox when the joined lines are parallel\n\n              if (width < 1 || height < 1) {\n                path.options.stroke.lineJoin = \"round\";\n              }\n            }\n\n            visual.append(path);\n\n            if (hasGradientOverlay(options)) {\n              var overlay = this.createGradientOverlay(path, {\n                baseColor: this.color\n              }, deepExtend({\n                end: !options.vertical ? [0, 1] : undefined\n              }, options.overlay));\n              visual.append(overlay);\n            }\n          },\n          createHighlight: function (style) {\n            var highlight = Path.fromRect(this.box.toRect(), style);\n            return alignPathToPixel(highlight);\n          },\n          highlightVisual: function () {\n            return this.rectVisual;\n          },\n          highlightVisualArgs: function () {\n            return {\n              options: this.options,\n              rect: this.box.toRect(),\n              visual: this.rectVisual\n            };\n          },\n          getBorderColor: function () {\n            var color = this.color;\n            var border = this.options.border;\n            var brightness = border._brightness || BORDER_BRIGHTNESS;\n            var borderColor = border.color;\n\n            if (!defined(borderColor)) {\n              borderColor = new Color(color).brightness(brightness).toHex();\n            }\n\n            return borderColor;\n          },\n          tooltipAnchor: function () {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var aboveAxis = ref.aboveAxis;\n            var clipBox = this.owner.pane.clipBox() || box;\n            var horizontalAlign = LEFT;\n            var verticalAlign = TOP;\n            var x, y;\n\n            if (options.vertical) {\n              x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n\n              if (aboveAxis) {\n                y = Math.max(box.y1, clipBox.y1);\n              } else {\n                y = Math.min(box.y2, clipBox.y2);\n                verticalAlign = BOTTOM;\n              }\n            } else {\n              var x1 = Math.max(box.x1, clipBox.x1);\n              var x2 = Math.min(box.x2, clipBox.x2);\n\n              if (options.isStacked) {\n                verticalAlign = BOTTOM;\n\n                if (aboveAxis) {\n                  horizontalAlign = RIGHT;\n                  x = x2;\n                } else {\n                  x = x1;\n                }\n\n                y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n              } else {\n                if (aboveAxis) {\n                  x = x2 + TOOLTIP_OFFSET;\n                } else {\n                  x = x1 - TOOLTIP_OFFSET;\n                  horizontalAlign = RIGHT;\n                }\n\n                y = Math.max(box.y1, clipBox.y1);\n              }\n            }\n\n            return {\n              point: new Point(x, y),\n              align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n              }\n            };\n          },\n          overlapsBox: function (box) {\n            return this.box.overlaps(box);\n          },\n          pointData: function () {\n            return {\n              dataItem: this.dataItem,\n              category: this.category,\n              value: this.value,\n              percentage: this.percentage,\n              stackValue: this.stackValue,\n              runningTotal: this.runningTotal,\n              total: this.total,\n              series: this.series\n            };\n          }\n        });\n        deepExtend(Bar.prototype, PointEventsMixin);\n        deepExtend(Bar.prototype, NoteMixin);\n        Bar.prototype.defaults = {\n          border: {\n            width: 1\n          },\n          vertical: true,\n          overlay: {\n            gradient: \"glass\"\n          },\n          labels: {\n            visible: false,\n            format: \"{0}\"\n          },\n          opacity: 1,\n          notes: {\n            label: {}\n          }\n        };\n\n        function forEach(elements, callback) {\n          elements.forEach(callback);\n        }\n\n        function forEachReverse(elements, callback) {\n          var length = elements.length;\n\n          for (var idx = length - 1; idx >= 0; idx--) {\n            callback(elements[idx], idx - length - 1);\n          }\n        }\n\n        var ClusterLayout = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n            this.forEach = options.rtl ? forEachReverse : forEach;\n          },\n          reflow: function (box) {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var gap = ref.gap;\n            var spacing = ref.spacing;\n            var children = this.children;\n            var count = children.length;\n            var axis = vertical ? Y : X;\n            var slots = count + gap + spacing * (count - 1);\n            var slotSize = (vertical ? box.height() : box.width()) / slots;\n            var position = box[axis + 1] + slotSize * (gap / 2);\n            this.forEach(children, function (child, idx) {\n              var childBox = (child.box || box).clone();\n              childBox[axis + 1] = position;\n              childBox[axis + 2] = position + slotSize;\n              child.reflow(childBox);\n\n              if (idx < count - 1) {\n                position += slotSize * spacing;\n              }\n\n              position += slotSize;\n            });\n          }\n        });\n        setDefaultOptions(ClusterLayout, {\n          vertical: false,\n          gap: 0,\n          spacing: 0\n        });\n        var StackWrap = ChartElement.extend({\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var positionAxis = this.options.vertical ? X : Y;\n            var children = this.children;\n            var childrenCount = children.length;\n            var box = this.box = new Box();\n\n            for (var i = 0; i < childrenCount; i++) {\n              var currentChild = children[i];\n\n              if (currentChild.visible !== false) {\n                var childBox = currentChild.box.clone();\n                childBox.snapTo(targetBox, positionAxis);\n\n                if (i === 0) {\n                  box = this$1.box = childBox.clone();\n                }\n\n                currentChild.reflow(childBox);\n                box.wrap(childBox);\n              }\n            }\n          }\n        });\n        setDefaultOptions(StackWrap, {\n          vertical: true\n        });\n        var BarChart = CategoricalChart.extend({\n          render: function () {\n            CategoricalChart.fn.render.call(this);\n            this.updateStackRange();\n          },\n          pointType: function () {\n            return Bar;\n          },\n          clusterType: function () {\n            return ClusterLayout;\n          },\n          stackType: function () {\n            return StackWrap;\n          },\n          stackLimits: function (axisName, stackName) {\n            var limits = CategoricalChart.fn.stackLimits.call(this, axisName, stackName);\n            return limits;\n          },\n          createPoint: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var isStacked = options.isStacked;\n            var value = this.pointValue(data);\n            var pointOptions = this.pointOptions(series, seriesIx);\n            var labelOptions = pointOptions.labels;\n\n            if (isStacked) {\n              if (labelOptions.position === OUTSIDE_END) {\n                labelOptions.position = INSIDE_END;\n              }\n            }\n\n            pointOptions.isStacked = isStacked;\n            var color = data.fields.color || series.color;\n\n            if (value < 0 && pointOptions.negativeColor) {\n              color = pointOptions.negativeColor;\n            }\n\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            var pointType = this.pointType();\n            var point = new pointType(value, pointOptions);\n            point.color = color;\n            var cluster = children[categoryIx];\n\n            if (!cluster) {\n              var clusterType = this.clusterType();\n              cluster = new clusterType({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n              });\n              this.append(cluster);\n            }\n\n            if (isStacked) {\n              var stackWrap = this.getStackWrap(series, cluster);\n              stackWrap.append(point);\n            } else {\n              cluster.append(point);\n            }\n\n            return point;\n          },\n          getStackWrap: function (series, cluster) {\n            var stack = series.stack;\n            var stackGroup = stack ? stack.group || stack : stack;\n            var wraps = cluster.children;\n            var stackWrap;\n\n            if (typeof stackGroup === datavizConstants.STRING) {\n              for (var i = 0; i < wraps.length; i++) {\n                if (wraps[i]._stackGroup === stackGroup) {\n                  stackWrap = wraps[i];\n                  break;\n                }\n              }\n            } else {\n              stackWrap = wraps[0];\n            }\n\n            if (!stackWrap) {\n              var stackType = this.stackType();\n              stackWrap = new stackType({\n                vertical: !this.options.invertAxes\n              });\n              stackWrap._stackGroup = stackGroup;\n              cluster.append(stackWrap);\n            }\n\n            return stackWrap;\n          },\n          categorySlot: function (categoryAxis, categoryIx, valueAxis) {\n            var options = this.options;\n            var categorySlot = categoryAxis.getSlot(categoryIx);\n            var startValue = valueAxis.startValue();\n\n            if (options.isStacked) {\n              var zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n              var stackAxis = options.invertAxes ? X : Y;\n              categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n            }\n\n            return categorySlot;\n          },\n          reflowCategories: function (categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n              children[i].reflow(categorySlots[i]);\n            }\n          },\n          createAnimation: function () {\n            this._setAnimationOptions();\n\n            CategoricalChart.fn.createAnimation.call(this);\n\n            if (anyHasZIndex(this.options.series)) {\n              this._setChildrenAnimation();\n            }\n          },\n          _setChildrenAnimation: function () {\n            var this$1 = this;\n            var points = this.points;\n\n            for (var idx = 0; idx < points.length; idx++) {\n              var point = points[idx];\n              var pointVisual = point.visual;\n\n              if (pointVisual && defined(pointVisual.options.zIndex)) {\n                point.options.animation = this$1.options.animation;\n                point.createAnimation();\n              }\n            }\n          },\n          _setAnimationOptions: function () {\n            var options = this.options;\n            var animation = options.animation || {};\n            var origin;\n\n            if (options.isStacked) {\n              var valueAxis = this.seriesValueAxis(options.series[0]);\n              origin = valueAxis.getSlot(valueAxis.startValue());\n            } else {\n              origin = this.categoryAxis.getSlot(0);\n            }\n\n            animation.origin = new GeometryPoint(origin.x1, origin.y1);\n            animation.vertical = !options.invertAxes;\n          }\n        });\n        setDefaultOptions(BarChart, {\n          animation: {\n            type: BAR\n          }\n        });\n        var Candlestick = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this, options);\n            this.value = value;\n          },\n          reflow: function (box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var ocSlot = valueAxis.getSlot(value.open, value.close);\n            var lhSlot = valueAxis.getSlot(value.low, value.high);\n            ocSlot.x1 = lhSlot.x1 = box.x1;\n            ocSlot.x2 = lhSlot.x2 = box.x2;\n            this.realBody = ocSlot;\n            var mid = lhSlot.center().x;\n            var points = [];\n            points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);\n            points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);\n            this.lines = points;\n            this.box = lhSlot.clone().wrap(ocSlot);\n\n            if (!this._rendered) {\n              this._rendered = true;\n              this.createNote();\n            }\n\n            this.reflowNote();\n          },\n          reflowNote: function () {\n            if (this.note) {\n              this.note.reflow(this.box);\n            }\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            this._mainVisual = this.mainVisual(this.options);\n            this.visual.append(this._mainVisual);\n            this.createOverlay();\n          },\n          mainVisual: function (options) {\n            var group = new Group();\n            this.createBody(group, options);\n            this.createLines(group, options);\n            return group;\n          },\n          createBody: function (container, options) {\n            var body = Path.fromRect(this.realBody.toRect(), {\n              fill: {\n                color: this.color,\n                opacity: options.opacity\n              },\n              stroke: null\n            });\n\n            if (options.border.width > 0) {\n              body.options.set(\"stroke\", {\n                color: this.getBorderColor(),\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: valueOrDefault(options.border.opacity, options.opacity)\n              });\n            }\n\n            alignPathToPixel(body);\n            container.append(body);\n\n            if (hasGradientOverlay(options)) {\n              container.append(this.createGradientOverlay(body, {\n                baseColor: this.color\n              }, deepExtend({\n                end: !options.vertical ? [0, 1] : undefined\n              }, options.overlay)));\n            }\n          },\n          createLines: function (container, options) {\n            this.drawLines(container, options, this.lines, options.line);\n          },\n          drawLines: function (container, options, lines, lineOptions) {\n            if (!lines) {\n              return;\n            }\n\n            var lineStyle = {\n              stroke: {\n                color: lineOptions.color || this.color,\n                opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n                width: lineOptions.width,\n                dashType: lineOptions.dashType,\n                lineCap: \"butt\"\n              }\n            };\n\n            for (var i = 0; i < lines.length; i++) {\n              var line = Path.fromPoints(lines[i], lineStyle);\n              alignPathToPixel(line);\n              container.append(line);\n            }\n          },\n          getBorderColor: function () {\n            var border = this.options.border;\n            var borderColor = border.color;\n\n            if (!defined(borderColor)) {\n              borderColor = new Color(this.color).brightness(border._brightness).toHex();\n            }\n\n            return borderColor;\n          },\n          createOverlay: function () {\n            var overlay = Path.fromRect(this.box.toRect(), {\n              fill: {\n                color: WHITE,\n                opacity: 0\n              },\n              stroke: null\n            });\n            this.visual.append(overlay);\n          },\n          createHighlight: function () {\n            var highlight = this.options.highlight;\n            var normalColor = this.color;\n            this.color = highlight.color || this.color;\n            var overlay = this.mainVisual(deepExtend({}, this.options, {\n              line: {\n                color: this.getBorderColor()\n              }\n            }, highlight));\n            this.color = normalColor;\n            return overlay;\n          },\n          highlightVisual: function () {\n            return this._mainVisual;\n          },\n          highlightVisualArgs: function () {\n            return {\n              options: this.options,\n              rect: this.box.toRect(),\n              visual: this._mainVisual\n            };\n          },\n          tooltipAnchor: function () {\n            var box = this.box;\n            var clipBox = this.owner.pane.clipBox() || box;\n            return {\n              point: new Point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\n              align: {\n                horizontal: LEFT,\n                vertical: TOP\n              }\n            };\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          overlapsBox: function (box) {\n            return this.box.overlaps(box);\n          }\n        });\n        setDefaultOptions(Candlestick, {\n          vertical: true,\n          border: {\n            _brightness: 0.8\n          },\n          line: {\n            width: 2\n          },\n          overlay: {\n            gradient: \"glass\"\n          },\n          tooltip: {\n            format: \"<table>\" + \"<tr><th colspan='2'>{4:d}</th></tr>\" + \"<tr><td>Open:</td><td>{0:C}</td></tr>\" + \"<tr><td>High:</td><td>{1:C}</td></tr>\" + \"<tr><td>Low:</td><td>{2:C}</td></tr>\" + \"<tr><td>Close:</td><td>{3:C}</td></tr>\" + \"</table>\"\n          },\n          highlight: {\n            opacity: 1,\n            border: {\n              width: 1,\n              opacity: 1\n            },\n            line: {\n              width: 1,\n              opacity: 1\n            }\n          },\n          notes: {\n            visible: true,\n            label: {}\n          }\n        });\n        deepExtend(Candlestick.prototype, PointEventsMixin);\n        deepExtend(Candlestick.prototype, NoteMixin);\n\n        function areNumbers(values) {\n          return countNumbers(values) === values.length;\n        }\n\n        var CandlestickChart = CategoricalChart.extend({\n          reflowCategories: function (categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n              children[i].reflow(categorySlots[i]);\n            }\n          },\n          addValue: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var value = data.valueFields;\n            var valueParts = this.splitValue(value);\n            var hasValue = areNumbers(valueParts);\n            var dataItem = series.data[categoryIx];\n            var categoryPoints = this.categoryPoints[categoryIx];\n            var point;\n\n            if (!categoryPoints) {\n              this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            if (hasValue) {\n              point = this.createPoint(data, fields);\n            }\n\n            var cluster = children[categoryIx];\n\n            if (!cluster) {\n              cluster = new ClusterLayout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n              });\n              this.append(cluster);\n            }\n\n            if (point) {\n              this.updateRange(value, fields);\n              cluster.append(point);\n              point.categoryIx = categoryIx;\n              point.category = category;\n              point.series = series;\n              point.seriesIx = seriesIx;\n              point.owner = this;\n              point.dataItem = dataItem;\n              point.noteText = data.fields.noteText;\n            }\n\n            this.points.push(point);\n            categoryPoints.push(point);\n          },\n          pointType: function () {\n            return Candlestick;\n          },\n          createPoint: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var pointType = this.pointType();\n            var value = data.valueFields;\n            var pointOptions = deepExtend({}, series);\n            var color = data.fields.color || series.color;\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n\n            if (series.type === CANDLESTICK) {\n              if (value.open > value.close) {\n                color = data.fields.downColor || series.downColor || series.color;\n              }\n            }\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            pointOptions.vertical = !this.options.invertAxes;\n            var point = new pointType(value, pointOptions);\n            point.color = color;\n            return point;\n          },\n          splitValue: function (value) {\n            return [value.low, value.open, value.close, value.high];\n          },\n          updateRange: function (value, fields) {\n            var axisName = fields.series.axis;\n            var parts = this.splitValue(value);\n            var axisRange = this.valueAxisRanges[axisName];\n            axisRange = this.valueAxisRanges[axisName] = axisRange || {\n              min: MAX_VALUE,\n              max: MIN_VALUE\n            };\n            axisRange = this.valueAxisRanges[axisName] = {\n              min: Math.min.apply(Math, parts.concat([axisRange.min])),\n              max: Math.max.apply(Math, parts.concat([axisRange.max]))\n            };\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.open, value.high, value.low, value.close, point.category);\n          },\n          animationPoints: function () {\n            return this.points;\n          }\n        });\n        deepExtend(CandlestickChart.prototype, ClipAnimationMixin);\n        var BoxPlot = Candlestick.extend({\n          init: function (value, options) {\n            Candlestick.fn.init.call(this, value, options);\n            this.createNote();\n          },\n          reflow: function (box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var whiskerSlot, boxSlot;\n            this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\n            this.realBody = boxSlot;\n            this.reflowBoxSlot(box);\n            this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\n            this.reflowWhiskerSlot(box);\n            var medianSlot = valueAxis.getSlot(value.median);\n\n            if (value.mean) {\n              var meanSlot = valueAxis.getSlot(value.mean);\n              this.meanPoints = this.calcMeanPoints(box, meanSlot);\n            }\n\n            this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\n            this.medianPoints = this.calcMedianPoints(box, medianSlot);\n            this.box = whiskerSlot.clone().wrap(boxSlot);\n            this.reflowNote();\n          },\n          reflowBoxSlot: function (box) {\n            this.boxSlot.x1 = box.x1;\n            this.boxSlot.x2 = box.x2;\n          },\n          reflowWhiskerSlot: function (box) {\n            this.whiskerSlot.x1 = box.x1;\n            this.whiskerSlot.x2 = box.x2;\n          },\n          calcMeanPoints: function (box, meanSlot) {\n            return [[[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]];\n          },\n          calcWhiskerPoints: function (boxSlot, whiskerSlot) {\n            var mid = whiskerSlot.center().x;\n            return [[[mid - 5, whiskerSlot.y1], [mid + 5, whiskerSlot.y1], [mid, whiskerSlot.y1], [mid, boxSlot.y1]], [[mid - 5, whiskerSlot.y2], [mid + 5, whiskerSlot.y2], [mid, whiskerSlot.y2], [mid, boxSlot.y2]]];\n          },\n          calcMedianPoints: function (box, medianSlot) {\n            return [[[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]];\n          },\n          renderOutliers: function (options) {\n            var this$1 = this;\n            var value = this.value;\n            var outliers = value.outliers || [];\n            var outerFence = Math.abs(value.q3 - value.q1) * 3;\n            var elements = [];\n            var markers = options.markers || {};\n\n            for (var i = 0; i < outliers.length; i++) {\n              var outlierValue = outliers[i];\n\n              if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\n                markers = options.outliers;\n              } else {\n                markers = options.extremes;\n              }\n\n              var markersBorder = deepExtend({}, markers.border);\n\n              if (!defined(markersBorder.color)) {\n                if (defined(this$1.color)) {\n                  markersBorder.color = this$1.color;\n                } else {\n                  markersBorder.color = new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex();\n                }\n              }\n\n              var shape = new ShapeElement({\n                type: markers.type,\n                width: markers.size,\n                height: markers.size,\n                rotation: markers.rotation,\n                background: markers.background,\n                border: markersBorder,\n                opacity: markers.opacity\n              });\n              shape.value = outlierValue;\n              elements.push(shape);\n            }\n\n            this.reflowOutliers(elements);\n            return elements;\n          },\n          reflowOutliers: function (outliers) {\n            var this$1 = this;\n            var valueAxis = this.owner.seriesValueAxis(this.options);\n            var center = this.box.center();\n\n            for (var i = 0; i < outliers.length; i++) {\n              var outlierValue = outliers[i].value;\n              var markerBox = valueAxis.getSlot(outlierValue);\n\n              if (this$1.options.vertical) {\n                markerBox.move(center.x);\n              } else {\n                markerBox.move(undefined, center.y);\n              }\n\n              this$1.box = this$1.box.wrap(markerBox);\n              outliers[i].reflow(markerBox);\n            }\n          },\n          mainVisual: function (options) {\n            var group = Candlestick.fn.mainVisual.call(this, options);\n            var outliers = this.renderOutliers(options);\n\n            for (var i = 0; i < outliers.length; i++) {\n              var element = outliers[i].getElement();\n\n              if (element) {\n                group.append(element);\n              }\n            }\n\n            return group;\n          },\n          createLines: function (container, options) {\n            this.drawLines(container, options, this.whiskerPoints, options.whiskers);\n            this.drawLines(container, options, this.medianPoints, options.median);\n            this.drawLines(container, options, this.meanPoints, options.mean);\n          },\n          getBorderColor: function () {\n            if ((this.options.border || {}).color) {\n              return this.options.border.color;\n            }\n\n            if (this.color) {\n              return this.color;\n            }\n\n            return Candlestick.fn.getBorderColor.call(this);\n          }\n        });\n        setDefaultOptions(BoxPlot, {\n          border: {\n            _brightness: 0.8\n          },\n          line: {\n            width: 2\n          },\n          median: {\n            color: \"#f6f6f6\"\n          },\n          mean: {\n            width: 2,\n            dashType: \"dash\",\n            color: \"#f6f6f6\"\n          },\n          overlay: {\n            gradient: \"glass\"\n          },\n          tooltip: {\n            format: \"<table>\" + \"<tr><th colspan='2'>{6:d}</th></tr>\" + \"<tr><td>Lower:</td><td>{0:C}</td></tr>\" + \"<tr><td>Q1:</td><td>{1:C}</td></tr>\" + \"<tr><td>Median:</td><td>{2:C}</td></tr>\" + \"<tr><td>Mean:</td><td>{5:C}</td></tr>\" + \"<tr><td>Q3:</td><td>{3:C}</td></tr>\" + \"<tr><td>Upper:</td><td>{4:C}</td></tr>\" + \"</table>\"\n          },\n          highlight: {\n            opacity: 1,\n            border: {\n              width: 1,\n              opacity: 1\n            },\n            line: {\n              width: 1,\n              opacity: 1\n            }\n          },\n          notes: {\n            visible: true,\n            label: {}\n          },\n          outliers: {\n            visible: true,\n            size: LINE_MARKER_SIZE,\n            type: datavizConstants.CROSS,\n            background: WHITE,\n            border: {\n              width: 2,\n              opacity: 1\n            },\n            opacity: 0\n          },\n          extremes: {\n            visible: true,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            background: WHITE,\n            border: {\n              width: 2,\n              opacity: 1\n            },\n            opacity: 0\n          }\n        });\n        deepExtend(BoxPlot.prototype, PointEventsMixin);\n        var VerticalBoxPlot = BoxPlot.extend({\n          reflowBoxSlot: function (box) {\n            this.boxSlot.y1 = box.y1;\n            this.boxSlot.y2 = box.y2;\n          },\n          reflowWhiskerSlot: function (box) {\n            this.whiskerSlot.y1 = box.y1;\n            this.whiskerSlot.y2 = box.y2;\n          },\n          calcMeanPoints: function (box, meanSlot) {\n            return [[[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]];\n          },\n          calcWhiskerPoints: function (boxSlot, whiskerSlot) {\n            var mid = whiskerSlot.center().y;\n            return [[[whiskerSlot.x1, mid - 5], [whiskerSlot.x1, mid + 5], [whiskerSlot.x1, mid], [boxSlot.x1, mid]], [[whiskerSlot.x2, mid - 5], [whiskerSlot.x2, mid + 5], [whiskerSlot.x2, mid], [boxSlot.x2, mid]]];\n          },\n          calcMedianPoints: function (box, medianSlot) {\n            return [[[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]];\n          }\n        });\n        var BoxPlotChart = CandlestickChart.extend({\n          addValue: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var value = data.valueFields;\n            var valueParts = this.splitValue(value);\n            var hasValue = areNumbers(valueParts);\n            var dataItem = series.data[categoryIx];\n            var categoryPoints = this.categoryPoints[categoryIx];\n            var point;\n\n            if (!categoryPoints) {\n              this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            if (hasValue) {\n              point = this.createPoint(data, fields);\n            }\n\n            var cluster = children[categoryIx];\n\n            if (!cluster) {\n              cluster = new ClusterLayout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n              });\n              this.append(cluster);\n            }\n\n            if (point) {\n              this.updateRange(value, fields);\n              cluster.append(point);\n              point.categoryIx = categoryIx;\n              point.category = category;\n              point.series = series;\n              point.seriesIx = seriesIx;\n              point.owner = this;\n              point.dataItem = dataItem;\n            }\n\n            this.points.push(point);\n            categoryPoints.push(point);\n          },\n          pointType: function () {\n            if (this.options.invertAxes) {\n              return VerticalBoxPlot;\n            }\n\n            return BoxPlot;\n          },\n          splitValue: function (value) {\n            return [value.lower, value.q1, value.median, value.q3, value.upper];\n          },\n          updateRange: function (value, fields) {\n            var axisName = fields.series.axis;\n            var axisRange = this.valueAxisRanges[axisName];\n            var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\n\n            if (defined(value.mean)) {\n              parts = parts.concat(value.mean);\n            }\n\n            axisRange = this.valueAxisRanges[axisName] = axisRange || {\n              min: MAX_VALUE,\n              max: MIN_VALUE\n            };\n            axisRange = this.valueAxisRanges[axisName] = {\n              min: Math.min.apply(Math, parts.concat([axisRange.min])),\n              max: Math.max.apply(Math, parts.concat([axisRange.max]))\n            };\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.lower, value.q1, value.median, value.q3, value.upper, value.mean, point.category);\n          },\n          filterOutliers: function (items) {\n            var length = (items || []).length;\n            var result = [];\n\n            for (var i = 0; i < length; i++) {\n              var item = items[i];\n\n              if (defined(item) && item !== null) {\n                result.push(item);\n              }\n            }\n\n            return result;\n          },\n          supportsPointInactiveOpacity: function () {\n            return false;\n          }\n        });\n        var ScatterErrorBar = ErrorBarBase.extend({\n          getAxis: function () {\n            var axes = this.chart.seriesAxes(this.series);\n            var axis = this.isVertical ? axes.y : axes.x;\n            return axis;\n          }\n        });\n\n        function hasValue(value) {\n          return defined(value) && value !== null;\n        }\n\n        var ScatterChart = ChartElement.extend({\n          init: function (plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n\n            this._initFields();\n\n            this.render();\n          },\n          _initFields: function () {\n            // X and Y axis ranges grouped by name, e.g.:\n            // primary: { min: 0, max: 1 }\n            this.xAxisRanges = {};\n            this.yAxisRanges = {};\n            this.points = [];\n            this.seriesPoints = [];\n            this.seriesOptions = [];\n            this._evalSeries = [];\n          },\n          render: function () {\n            this.traverseDataPoints(this.addValue.bind(this));\n          },\n          addErrorBar: function (point, field, fields) {\n            var value = point.value[field];\n            var valueErrorField = field + \"Value\";\n            var lowField = field + \"ErrorLow\";\n            var highField = field + \"ErrorHigh\";\n            var seriesIx = fields.seriesIx;\n            var series = fields.series;\n            var errorBars = point.options.errorBars;\n            var lowValue = fields[lowField];\n            var highValue = fields[highField];\n\n            if (isNumber(value)) {\n              var errorRange;\n\n              if (isNumber(lowValue) && isNumber(highValue)) {\n                errorRange = {\n                  low: lowValue,\n                  high: highValue\n                };\n              }\n\n              if (errorBars && defined(errorBars[valueErrorField])) {\n                this.seriesErrorRanges = this.seriesErrorRanges || {\n                  x: [],\n                  y: []\n                };\n                this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n                errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n              }\n\n              if (errorRange) {\n                this.addPointErrorBar(errorRange, point, field);\n              }\n            }\n          },\n          addPointErrorBar: function (errorRange, point, field) {\n            var low = errorRange.low;\n            var high = errorRange.high;\n            var series = point.series;\n            var options = point.options.errorBars;\n            var isVertical = field === Y;\n            var item = {};\n            point[field + \"Low\"] = low;\n            point[field + \"High\"] = high;\n            point.errorBars = point.errorBars || [];\n            var errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n            point.errorBars.push(errorBar);\n            point.append(errorBar);\n            item[field] = low;\n            this.updateRange(item, series);\n            item[field] = high;\n            this.updateRange(item, series);\n          },\n          addValue: function (value, fields) {\n            var x = value.x;\n            var y = value.y;\n            var seriesIx = fields.seriesIx;\n            var series = this.options.series[seriesIx];\n            var missingValues = this.seriesMissingValues(series);\n            var seriesPoints = this.seriesPoints[seriesIx];\n            var pointValue = value;\n\n            if (!(hasValue(x) && hasValue(y))) {\n              pointValue = this.createMissingValue(pointValue, missingValues);\n            }\n\n            var point;\n\n            if (pointValue) {\n              point = this.createPoint(pointValue, fields);\n\n              if (point) {\n                $.extend(point, fields);\n                this.addErrorBar(point, X, fields);\n                this.addErrorBar(point, Y, fields);\n              }\n\n              this.updateRange(pointValue, fields.series);\n            }\n\n            this.points.push(point);\n            seriesPoints.push(point);\n          },\n          seriesMissingValues: function (series) {\n            return series.missingValues;\n          },\n          createMissingValue: function () {},\n          updateRange: function (value, series) {\n            var intlService = this.chartService.intl;\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var x = value.x;\n            var y = value.y;\n            var xAxisRange = this.xAxisRanges[xAxisName];\n            var yAxisRange = this.yAxisRanges[yAxisName];\n\n            if (hasValue(x)) {\n              xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n\n              if (isString(x)) {\n                x = parseDate(intlService, x);\n              }\n\n              xAxisRange.min = Math.min(xAxisRange.min, x);\n              xAxisRange.max = Math.max(xAxisRange.max, x);\n            }\n\n            if (hasValue(y)) {\n              yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n\n              if (isString(y)) {\n                y = parseDate(intlService, y);\n              }\n\n              yAxisRange.min = Math.min(yAxisRange.min, y);\n              yAxisRange.max = Math.max(yAxisRange.max, y);\n            }\n          },\n          evalPointOptions: function (options, value, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var state = {\n              defaults: series._defaults,\n              excluded: [\"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n            };\n            var doEval = this._evalSeries[seriesIx];\n\n            if (!defined(doEval)) {\n              this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n\n            if (doEval) {\n              pointOptions = deepExtend({}, options);\n              evalOptions(pointOptions, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem\n              }, state);\n            }\n\n            return pointOptions;\n          },\n          pointType: function () {\n            return LinePoint;\n          },\n          pointOptions: function (series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n\n            if (!options) {\n              var defaults = this.pointType().prototype.defaults;\n              this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                markers: {\n                  opacity: series.opacity\n                },\n                tooltip: {\n                  format: this.options.tooltip.format\n                },\n                labels: {\n                  format: this.options.labels.format\n                }\n              }, series);\n            }\n\n            return options;\n          },\n          createPoint: function (value, fields) {\n            var series = fields.series;\n            var pointOptions = this.pointOptions(series, fields.seriesIx);\n            var color = fields.color || series.color;\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            var point = new LinePoint(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n          },\n          seriesAxes: function (series) {\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var plotArea = this.plotArea;\n            var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n            var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n            if (!xAxis) {\n              throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n              throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return {\n              x: xAxis,\n              y: yAxis\n            };\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var chartPoints = this.points;\n            var limit = !this.options.clip;\n            var pointIx = 0;\n            this.traverseDataPoints(function (value, fields) {\n              var point = chartPoints[pointIx++];\n              var seriesAxes = this$1.seriesAxes(fields.series);\n              var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n              var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n              if (point) {\n                if (slotX && slotY) {\n                  var pointSlot = this$1.pointSlot(slotX, slotY);\n                  point.reflow(pointSlot);\n                } else {\n                  point.visible = false;\n                }\n              }\n            });\n            this.box = targetBox;\n          },\n          pointSlot: function (slotX, slotY) {\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n          },\n          traverseDataPoints: function (callback) {\n            var this$1 = this;\n            var ref = this;\n            var series = ref.options.series;\n            var seriesPoints = ref.seriesPoints;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var currentSeriesPoints = seriesPoints[seriesIx];\n\n              if (!currentSeriesPoints) {\n                seriesPoints[seriesIx] = [];\n              }\n\n              for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);\n\n                var value = ref$1.valueFields;\n                var fields = ref$1.fields;\n                callback(value, deepExtend({\n                  pointIx: pointIx,\n                  series: currentSeries,\n                  seriesIx: seriesIx,\n                  dataItem: currentSeries.data[pointIx],\n                  owner: this$1\n                }, fields));\n              }\n            }\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y);\n          },\n          animationPoints: function () {\n            var points = this.points;\n            var result = [];\n\n            for (var idx = 0; idx < points.length; idx++) {\n              result.push((points[idx] || {}).marker);\n            }\n\n            return result;\n          }\n        });\n        setDefaultOptions(ScatterChart, {\n          series: [],\n          tooltip: {\n            format: \"{0}, {1}\"\n          },\n          labels: {\n            format: \"{0}, {1}\"\n          },\n          clip: true\n        });\n        deepExtend(ScatterChart.prototype, ClipAnimationMixin, {\n          _bindPoint: CategoricalChart.prototype._bindPoint\n        });\n        var Bubble = LinePoint.extend({\n          init: function (value, options) {\n            LinePoint.fn.init.call(this, value, options);\n            this.category = value.category;\n          },\n          createHighlight: function () {\n            var highlight = this.options.highlight;\n            var border = highlight.border;\n            var markers = this.options.markers;\n            var center = this.box.center();\n            var radius = (markers.size + markers.border.width + border.width) / 2;\n            var highlightGroup = new Group();\n            var shadow = new drawing.Circle(new geometry.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {\n              stroke: {\n                color: 'none'\n              },\n              fill: this.createGradient({\n                gradient: 'bubbleShadow',\n                color: markers.background,\n                stops: [{\n                  offset: 0,\n                  color: markers.background,\n                  opacity: 0.3\n                }, {\n                  offset: 1,\n                  color: markers.background,\n                  opacity: 0\n                }]\n              })\n            });\n            var overlay = new drawing.Circle(new geometry.Circle([center.x, center.y], radius), {\n              stroke: {\n                color: border.color || new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),\n                width: border.width,\n                opacity: border.opacity\n              },\n              fill: {\n                color: markers.background,\n                opacity: highlight.opacity\n              }\n            });\n            highlightGroup.append(shadow, overlay);\n            return highlightGroup;\n          }\n        });\n        Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {\n          labels: {\n            position: CENTER\n          },\n          highlight: {\n            opacity: 1,\n            border: {\n              color: \"#fff\",\n              width: 2,\n              opacity: 1\n            }\n          }\n        });\n        Bubble.prototype.defaults.highlight.zIndex = undefined;\n        var BubbleChart = ScatterChart.extend({\n          _initFields: function () {\n            this._maxSize = MIN_VALUE;\n\n            ScatterChart.fn._initFields.call(this);\n          },\n          addValue: function (value, fields) {\n            if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {\n              this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n              ScatterChart.fn.addValue.call(this, value, fields);\n            } else {\n              this.points.push(null);\n              this.seriesPoints[fields.seriesIx].push(null);\n            }\n          },\n          reflow: function (box) {\n            this.updateBubblesSize(box);\n            ScatterChart.fn.reflow.call(this, box);\n          },\n          pointType: function () {\n            return Bubble;\n          },\n          createPoint: function (value, fields) {\n            var series = fields.series;\n            var pointsCount = series.data.length;\n            var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n            var animationOptions = {\n              delay: delay,\n              duration: INITIAL_ANIMATION_DURATION - delay,\n              type: BUBBLE\n            };\n            var color = fields.color || series.color;\n\n            if (value.size < 0 && series.negativeValues.visible) {\n              color = valueOrDefault(series.negativeValues.color, color);\n            }\n\n            var pointOptions = deepExtend({\n              labels: {\n                animation: {\n                  delay: delay,\n                  duration: INITIAL_ANIMATION_DURATION - delay\n                }\n              }\n            }, this.pointOptions(series, fields.seriesIx), {\n              markers: {\n                type: CIRCLE,\n                border: series.border,\n                opacity: series.opacity,\n                animation: animationOptions\n              }\n            });\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            pointOptions.markers.background = color;\n            var point = new Bubble(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n          },\n          updateBubblesSize: function (box) {\n            var this$1 = this;\n            var ref = this;\n            var series = ref.options.series;\n            var boxSize = Math.min(box.width(), box.height());\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var seriesPoints = this$1.seriesPoints[seriesIx];\n              var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n              var maxSize = currentSeries.maxSize || boxSize * 0.2;\n              var minR = minSize / 2;\n              var maxR = maxSize / 2;\n              var minArea = Math.PI * minR * minR;\n              var maxArea = Math.PI * maxR * maxR;\n              var areaRange = maxArea - minArea;\n              var areaRatio = areaRange / this$1._maxSize;\n\n              for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n                var point = seriesPoints[pointIx];\n\n                if (point) {\n                  var area = Math.abs(point.value.size) * areaRatio;\n                  var radius = Math.sqrt((minArea + area) / Math.PI);\n                  var baseZIndex = valueOrDefault(point.options.zIndex, 0);\n                  var zIndex = baseZIndex + (1 - radius / maxR);\n                  deepExtend(point.options, {\n                    zIndex: zIndex,\n                    markers: {\n                      size: radius * 2,\n                      zIndex: zIndex\n                    },\n                    labels: {\n                      zIndex: zIndex + 1\n                    }\n                  });\n                }\n              }\n            }\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n          },\n          createAnimation: function () {},\n          createVisual: function () {}\n        });\n        setDefaultOptions(BubbleChart, {\n          tooltip: {\n            format: \"{3}\"\n          },\n          labels: {\n            format: \"{3}\"\n          }\n        });\n        var Target = ShapeElement.extend({});\n        deepExtend(Target.prototype, PointEventsMixin);\n        var Bullet = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this, options);\n            this.aboveAxis = this.options.aboveAxis;\n            this.color = options.color || WHITE;\n            this.value = value;\n          },\n          render: function () {\n            var options = this.options;\n\n            if (!this._rendered) {\n              this._rendered = true;\n\n              if (defined(this.value.target)) {\n                this.target = new Target({\n                  type: options.target.shape,\n                  background: options.target.color || this.color,\n                  opacity: options.opacity,\n                  zIndex: options.zIndex,\n                  border: options.target.border,\n                  vAlign: TOP,\n                  align: RIGHT\n                });\n                this.target.value = this.value;\n                this.target.dataItem = this.dataItem;\n                this.target.series = this.series;\n                this.append(this.target);\n              }\n\n              this.createNote();\n            }\n          },\n          reflow: function (box) {\n            this.render();\n            var ref = this;\n            var options = ref.options;\n            var target = ref.target;\n            var chart = ref.owner;\n            var invertAxes = options.invertAxes;\n            var valueAxis = chart.seriesValueAxis(this.options);\n            var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);\n            var targetValueSlot = valueAxis.getSlot(this.value.target);\n            var targetSlotX = invertAxes ? targetValueSlot : categorySlot;\n            var targetSlotY = invertAxes ? categorySlot : targetValueSlot;\n\n            if (target) {\n              var targetSlot = new Box(targetSlotX.x1, targetSlotY.y1, targetSlotX.x2, targetSlotY.y2);\n              target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\n              target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\n              target.reflow(targetSlot);\n            }\n\n            if (this.note) {\n              this.note.reflow(box);\n            }\n\n            this.box = box;\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            var options = this.options;\n            var body = Path.fromRect(this.box.toRect(), {\n              fill: {\n                color: this.color,\n                opacity: options.opacity\n              },\n              stroke: null\n            });\n\n            if (options.border.width > 0) {\n              body.options.set(\"stroke\", {\n                color: options.border.color || this.color,\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: valueOrDefault(options.border.opacity, options.opacity)\n              });\n            }\n\n            this.bodyVisual = body;\n            alignPathToPixel(body);\n            this.visual.append(body);\n          },\n          createAnimation: function () {\n            if (this.bodyVisual) {\n              this.animation = Animation.create(this.bodyVisual, this.options.animation);\n            }\n          },\n          createHighlight: function (style) {\n            return Path.fromRect(this.box.toRect(), style);\n          },\n          highlightVisual: function () {\n            return this.bodyVisual;\n          },\n          highlightVisualArgs: function () {\n            return {\n              rect: this.box.toRect(),\n              visual: this.bodyVisual,\n              options: this.options\n            };\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          }\n        });\n        Bullet.prototype.tooltipAnchor = Bar.prototype.tooltipAnchor;\n        setDefaultOptions(Bullet, {\n          border: {\n            width: 1\n          },\n          vertical: false,\n          opacity: 1,\n          target: {\n            shape: \"\",\n            border: {\n              width: 0,\n              color: \"green\"\n            },\n            line: {\n              width: 2\n            }\n          },\n          tooltip: {\n            format: \"Current: {0}<br />Target: {1}\"\n          }\n        });\n        deepExtend(Bullet.prototype, PointEventsMixin);\n        deepExtend(Bullet.prototype, NoteMixin);\n        var BulletChart = CategoricalChart.extend({\n          init: function (plotArea, options) {\n            wrapData(options);\n            CategoricalChart.fn.init.call(this, plotArea, options);\n          },\n          reflowCategories: function (categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n              children[i].reflow(categorySlots[i]);\n            }\n          },\n          plotRange: function (point) {\n            var series = point.series;\n            var valueAxis = this.seriesValueAxis(series);\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n            return [axisCrossingValue, point.value.current || axisCrossingValue];\n          },\n          createPoint: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var value = data.valueFields;\n            var bulletOptions = deepExtend({\n              vertical: !options.invertAxes,\n              overlay: series.overlay,\n              categoryIx: categoryIx,\n              invertAxes: options.invertAxes\n            }, series);\n            var color = data.fields.color || series.color;\n            bulletOptions = this.evalPointOptions(bulletOptions, value, category, categoryIx, series, seriesIx);\n\n            if (isFunction(series.color)) {\n              color = bulletOptions.color;\n            }\n\n            var bullet = new Bullet(value, bulletOptions);\n            bullet.color = color;\n            var cluster = children[categoryIx];\n\n            if (!cluster) {\n              cluster = new ClusterLayout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n              });\n              this.append(cluster);\n            }\n\n            cluster.append(bullet);\n            return bullet;\n          },\n          updateRange: function (value, fields) {\n            var current = value.current;\n            var target = value.target;\n            var axisName = fields.series.axis;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\n              axisRange = this.valueAxisRanges[axisName] = axisRange || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n              axisRange.min = Math.min(axisRange.min, current, target);\n              axisRange.max = Math.max(axisRange.max, current, target);\n            }\n          },\n          formatPointValue: function (point, format) {\n            return this.chartService.format.auto(format, point.value.current, point.value.target);\n          },\n          pointValue: function (data) {\n            return data.valueFields.current;\n          },\n          aboveAxis: function (point) {\n            var value = point.value.current;\n            return value > 0;\n          },\n          createAnimation: function () {\n            var this$1 = this;\n            var points = this.points;\n\n            this._setAnimationOptions();\n\n            for (var idx = 0; idx < points.length; idx++) {\n              var point = points[idx];\n              point.options.animation = this$1.options.animation;\n              point.createAnimation();\n            }\n          }\n        });\n        BulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;\n        setDefaultOptions(BulletChart, {\n          animation: {\n            type: BAR\n          }\n        });\n\n        function wrapData(options) {\n          var series = options.series;\n\n          for (var i = 0; i < series.length; i++) {\n            var seriesItem = series[i];\n            var data = seriesItem.data;\n\n            if (data && !isArray(data[0]) && !isObject(data[0])) {\n              seriesItem.data = [data];\n            }\n          }\n        }\n\n        var BaseTooltip = Class.extend({\n          init: function (chartService, options) {\n            this.chartService = chartService;\n            this.options = deepExtend({}, this.options, options);\n          },\n          getStyle: function (options, point) {\n            var background = options.background;\n            var border = options.border.color;\n\n            if (point) {\n              var pointColor = point.color || point.options.color;\n              background = valueOrDefault(background, pointColor);\n              border = valueOrDefault(border, pointColor);\n            }\n\n            var padding = getSpacing(options.padding || {}, \"auto\");\n            return {\n              backgroundColor: background,\n              borderColor: border,\n              font: options.font,\n              color: options.color,\n              opacity: options.opacity,\n              borderWidth: styleValue(options.border.width),\n              paddingTop: styleValue(padding.top),\n              paddingBottom: styleValue(padding.bottom),\n              paddingLeft: styleValue(padding.left),\n              paddingRight: styleValue(padding.right)\n            };\n          },\n          show: function (options, tooltipOptions, point) {\n            options.format = tooltipOptions.format;\n            var style = this.getStyle(tooltipOptions, point);\n            options.style = style;\n            var background = new Color(style.backgroundColor);\n\n            if (!defined(tooltipOptions.color) && !background.isDark()) {\n              options.className = \"k-chart-tooltip-inverse\";\n            }\n\n            this.chartService.notify(SHOW_TOOLTIP, options);\n            this.visible = true;\n          },\n          hide: function () {\n            if (this.chartService) {\n              this.chartService.notify(HIDE_TOOLTIP);\n            }\n\n            this.visible = false;\n          },\n          destroy: function () {\n            delete this.chartService;\n          }\n        });\n        setDefaultOptions(BaseTooltip, {\n          border: {\n            width: 1\n          },\n          opacity: 1\n        });\n        var CrosshairTooltip = BaseTooltip.extend({\n          init: function (chartService, crosshair, options) {\n            BaseTooltip.fn.init.call(this, chartService, options);\n            this.crosshair = crosshair;\n            this.formatService = chartService.format;\n            this.initAxisName();\n          },\n          initAxisName: function () {\n            var axis = this.crosshair.axis;\n            var plotArea = axis.plotArea;\n            var name;\n\n            if (plotArea.categoryAxis) {\n              name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\n            } else {\n              name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\n            }\n\n            this.axisName = name;\n          },\n          showAt: function (point) {\n            var ref = this;\n            var axis = ref.crosshair.axis;\n            var options = ref.options;\n            var value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\n            var formattedValue = value;\n\n            if (options.format) {\n              formattedValue = this.formatService.auto(options.format, value);\n            } else if (axis.options.type === DATE) {\n              formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n            }\n\n            this.show({\n              point: point,\n              anchor: this.getAnchor(),\n              crosshair: this.crosshair,\n              value: formattedValue,\n              axisName: this.axisName,\n              axisIndex: this.crosshair.axis.axisIndex\n            }, this.options);\n          },\n          hide: function () {\n            this.chartService.notify(HIDE_TOOLTIP, {\n              crosshair: this.crosshair,\n              axisName: this.axisName,\n              axisIndex: this.crosshair.axis.axisIndex\n            });\n          },\n          getAnchor: function () {\n            var ref = this;\n            var crosshair = ref.crosshair;\n            var ref_options = ref.options;\n            var position = ref_options.position;\n            var padding = ref_options.padding;\n            var vertical = !crosshair.axis.options.vertical;\n            var lineBox = crosshair.line.bbox();\n            var horizontalAlign, verticalAlign, point;\n\n            if (vertical) {\n              horizontalAlign = CENTER;\n\n              if (position === BOTTOM) {\n                verticalAlign = TOP;\n                point = lineBox.bottomLeft().translate(0, padding);\n              } else {\n                verticalAlign = BOTTOM;\n                point = lineBox.topLeft().translate(0, -padding);\n              }\n            } else {\n              verticalAlign = CENTER;\n\n              if (position === LEFT) {\n                horizontalAlign = RIGHT;\n                point = lineBox.topLeft().translate(-padding, 0);\n              } else {\n                horizontalAlign = LEFT;\n                point = lineBox.topRight().translate(padding, 0);\n              }\n            }\n\n            return {\n              point: point,\n              align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n              }\n            };\n          }\n        });\n        setDefaultOptions(CrosshairTooltip, {\n          padding: 10\n        });\n        var Crosshair = ChartElement.extend({\n          init: function (chartService, axis, options) {\n            ChartElement.fn.init.call(this, options);\n            this.axis = axis;\n            this.stickyMode = axis instanceof CategoryAxis;\n            var tooltipOptions = this.options.tooltip;\n\n            if (tooltipOptions.visible) {\n              this.tooltip = new CrosshairTooltip(chartService, this, deepExtend({}, tooltipOptions, {\n                stickyMode: this.stickyMode\n              }));\n            }\n          },\n          showAt: function (point) {\n            this.point = point;\n            this.moveLine();\n            this.line.visible(true);\n\n            if (this.tooltip) {\n              this.tooltip.showAt(point);\n            }\n          },\n          hide: function () {\n            this.line.visible(false);\n\n            if (this.tooltip) {\n              this.tooltip.hide();\n            }\n          },\n          moveLine: function () {\n            var ref = this;\n            var axis = ref.axis;\n            var point = ref.point;\n            var vertical = axis.options.vertical;\n            var box = this.getBox();\n            var dim = vertical ? Y : X;\n            var lineStart = new GeometryPoint(box.x1, box.y1);\n            var lineEnd;\n\n            if (vertical) {\n              lineEnd = new GeometryPoint(box.x2, box.y1);\n            } else {\n              lineEnd = new GeometryPoint(box.x1, box.y2);\n            }\n\n            if (point) {\n              if (this.stickyMode) {\n                var slot = axis.getSlot(axis.pointCategoryIndex(point));\n                lineStart[dim] = lineEnd[dim] = slot.center()[dim];\n              } else {\n                lineStart[dim] = lineEnd[dim] = point[dim];\n              }\n            }\n\n            this.box = box;\n            this.line.moveTo(lineStart).lineTo(lineEnd);\n          },\n          getBox: function () {\n            var axis = this.axis;\n            var axes = axis.pane.axes;\n            var length = axes.length;\n            var vertical = axis.options.vertical;\n            var box = axis.lineBox().clone();\n            var dim = vertical ? X : Y;\n            var axisLineBox;\n\n            for (var i = 0; i < length; i++) {\n              var currentAxis = axes[i];\n\n              if (currentAxis.options.vertical !== vertical) {\n                if (!axisLineBox) {\n                  axisLineBox = currentAxis.lineBox().clone();\n                } else {\n                  axisLineBox.wrap(currentAxis.lineBox());\n                }\n              }\n            }\n\n            box[dim + 1] = axisLineBox[dim + 1];\n            box[dim + 2] = axisLineBox[dim + 2];\n            return box;\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            var options = this.options;\n            this.line = new Path({\n              stroke: {\n                color: options.color,\n                width: options.width,\n                opacity: options.opacity,\n                dashType: options.dashType\n              },\n              visible: false\n            });\n            this.moveLine();\n            this.visual.append(this.line);\n          },\n          destroy: function () {\n            if (this.tooltip) {\n              this.tooltip.destroy();\n            }\n\n            ChartElement.fn.destroy.call(this);\n          }\n        });\n        setDefaultOptions(Crosshair, {\n          color: BLACK,\n          width: 2,\n          zIndex: -1,\n          tooltip: {\n            visible: false\n          }\n        });\n        var ChartContainer = ChartElement.extend({\n          init: function (options, pane) {\n            ChartElement.fn.init.call(this, options);\n            this.pane = pane;\n          },\n          shouldClip: function () {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n              if (children[i].options.clip === true) {\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _clipBox: function () {\n            return this.pane.chartsBox();\n          },\n          createVisual: function () {\n            this.visual = new Group({\n              zIndex: 0\n            });\n\n            if (this.shouldClip()) {\n              var clipBox = this.clipBox = this._clipBox();\n\n              var clipRect = clipBox.toRect();\n              var clipPath = Path.fromRect(clipRect);\n              alignPathToPixel(clipPath);\n              this.visual.clip(clipPath);\n              this.unclipLabels();\n            }\n          },\n          stackRoot: function () {\n            return this;\n          },\n          unclipLabels: function () {\n            var ref = this;\n            var charts = ref.children;\n            var clipBox = ref.clipBox;\n\n            for (var i = 0; i < charts.length; i++) {\n              var points = charts[i].points || {};\n              var length = points.length;\n\n              for (var j = 0; j < length; j++) {\n                var point = points[j];\n\n                if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n                  if (point.unclipElements) {\n                    point.unclipElements();\n                  } else {\n                    var label = point.label;\n                    var note = point.note;\n\n                    if (label && label.options.visible) {\n                      if (label.alignToClipBox) {\n                        label.alignToClipBox(clipBox);\n                      }\n\n                      label.options.noclip = true;\n                    }\n\n                    if (note && note.options.visible) {\n                      note.options.noclip = true;\n                    }\n                  }\n                }\n              }\n            }\n          },\n          destroy: function () {\n            ChartElement.fn.destroy.call(this);\n            delete this.parent;\n          }\n        });\n        ChartContainer.prototype.isStackRoot = true;\n        var Pane = BoxElement.extend({\n          init: function (options) {\n            BoxElement.fn.init.call(this, options);\n            this.id = paneID();\n            this.createTitle();\n            this.content = new ChartElement();\n            this.chartContainer = new ChartContainer({}, this);\n            this.append(this.content);\n            this.axes = [];\n            this.charts = [];\n          },\n          createTitle: function () {\n            var titleOptions = this.options.title;\n\n            if (isObject(titleOptions)) {\n              titleOptions = deepExtend({}, titleOptions, {\n                align: titleOptions.position,\n                position: TOP\n              });\n            }\n\n            this.title = dataviz.Title.buildTitle(titleOptions, this, Pane.prototype.options.title);\n          },\n          appendAxis: function (axis) {\n            this.content.append(axis);\n            this.axes.push(axis);\n            axis.pane = this;\n          },\n          appendAxisAt: function (axis, pos) {\n            this.content.append(axis);\n            this.axes.splice(pos, 0, axis);\n            axis.pane = this;\n          },\n          appendChart: function (chart) {\n            if (this.chartContainer.parent !== this.content) {\n              this.content.append(this.chartContainer);\n            }\n\n            this.charts.push(chart);\n            this.chartContainer.append(chart);\n            chart.pane = this;\n          },\n          empty: function () {\n            var this$1 = this;\n            var plotArea = this.parent;\n\n            if (plotArea) {\n              for (var i = 0; i < this.axes.length; i++) {\n                plotArea.removeAxis(this$1.axes[i]);\n              }\n\n              for (var i$1 = 0; i$1 < this.charts.length; i$1++) {\n                plotArea.removeChart(this$1.charts[i$1]);\n              }\n            }\n\n            this.axes = [];\n            this.charts = [];\n            this.content.destroy();\n            this.content.children = [];\n            this.chartContainer.children = [];\n          },\n          reflow: function (targetBox) {\n            // Content (such as charts) is rendered, but excluded from reflows\n            var content;\n\n            if (last(this.children) === this.content) {\n              content = this.children.pop();\n            }\n\n            BoxElement.fn.reflow.call(this, targetBox);\n\n            if (content) {\n              this.children.push(content);\n            }\n\n            if (this.title) {\n              this.contentBox.y1 += this.title.box.height();\n            }\n          },\n          visualStyle: function () {\n            var style = BoxElement.fn.visualStyle.call(this);\n            style.zIndex = -10;\n            return style;\n          },\n          renderComplete: function () {\n            if (this.options.visible) {\n              this.createGridLines();\n            }\n          },\n          stackRoot: function () {\n            return this;\n          },\n          clipRoot: function () {\n            return this;\n          },\n          createGridLines: function () {\n            var axes = this.axes;\n            var allAxes = axes.concat(this.parent.axes);\n            var vGridLines = [];\n            var hGridLines = []; // TODO\n            // Is full combination really necessary?\n\n            for (var i = 0; i < axes.length; i++) {\n              var axis = axes[i];\n              var vertical = axis.options.vertical;\n              var gridLines = vertical ? vGridLines : hGridLines;\n\n              for (var j = 0; j < allAxes.length; j++) {\n                if (gridLines.length === 0) {\n                  var altAxis = allAxes[j];\n\n                  if (vertical !== altAxis.options.vertical) {\n                    append(gridLines, axis.createGridLines(altAxis));\n                  }\n                }\n              }\n            }\n          },\n          refresh: function () {\n            this.visual.clear();\n            this.content.parent = null;\n            this.content.createGradient = this.createGradient.bind(this);\n            this.content.renderVisual();\n            this.content.parent = this;\n\n            if (this.title) {\n              this.visual.append(this.title.visual);\n            }\n\n            this.visual.append(this.content.visual);\n            this.renderComplete();\n            this.notifyRender();\n          },\n          chartsBox: function () {\n            var axes = this.axes;\n            var length = axes.length;\n            var chartsBox = new Box();\n\n            for (var idx = 0; idx < length; idx++) {\n              var axis = axes[idx];\n              var axisValueField = axis.options.vertical ? Y : X;\n              var lineBox = axis.lineBox();\n              chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\n              chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\n            }\n\n            if (chartsBox.x2 === 0) {\n              var allAxes = this.parent.axes;\n              var length$1 = allAxes.length;\n\n              for (var idx$1 = 0; idx$1 < length$1; idx$1++) {\n                var axis$1 = allAxes[idx$1];\n\n                if (!axis$1.options.vertical) {\n                  var lineBox$1 = axis$1.lineBox();\n                  chartsBox.x1 = lineBox$1.x1;\n                  chartsBox.x2 = lineBox$1.x2;\n                }\n              }\n            }\n\n            return chartsBox;\n          },\n          clipBox: function () {\n            return this.chartContainer.clipBox;\n          },\n          notifyRender: function () {\n            var service = this.getService();\n\n            if (service) {\n              service.notify(PANE_RENDER, {\n                pane: new ChartPane(this),\n                index: this.paneIndex,\n                name: this.options.name\n              });\n            }\n          }\n        });\n        var ID = 1;\n\n        function paneID() {\n          return \"pane\" + ID++;\n        }\n\n        Pane.prototype.isStackRoot = true;\n        setDefaultOptions(Pane, {\n          zIndex: -1,\n          shrinkToFit: true,\n          title: {\n            align: LEFT\n          },\n          visible: true\n        });\n\n        function appendIfNotNull(array, element) {\n          if (element !== null) {\n            array.push(element);\n          }\n        }\n\n        function segmentVisible(series, fields, index) {\n          var visible = fields.visible;\n\n          if (defined(visible)) {\n            return visible;\n          }\n\n          var pointVisibility = series.pointVisibility;\n\n          if (pointVisibility) {\n            return pointVisibility[index];\n          }\n        }\n\n        function bindSegments(series) {\n          var data = series.data;\n          var points = [];\n          var sum = 0;\n          var count = 0;\n\n          for (var idx = 0; idx < data.length; idx++) {\n            var pointData = SeriesBinder.current.bindPoint(series, idx);\n            var value = pointData.valueFields.value;\n\n            if (isString(value)) {\n              value = parseFloat(value);\n            }\n\n            if (isNumber(value)) {\n              pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;\n              pointData.value = Math.abs(value);\n              points.push(pointData);\n\n              if (pointData.visible) {\n                sum += pointData.value;\n              }\n\n              if (value !== 0) {\n                count++;\n              }\n            } else {\n              points.push(null);\n            }\n          }\n\n          return {\n            total: sum,\n            points: points,\n            count: count\n          };\n        }\n\n        function equalsIgnoreCase(a, b) {\n          if (a && b) {\n            return a.toLowerCase() === b.toLowerCase();\n          }\n\n          return a === b;\n        }\n\n        function filterSeriesByType(series, types) {\n          var result = [];\n          var seriesTypes = [].concat(types);\n\n          for (var idx = 0; idx < series.length; idx++) {\n            var currentSeries = series[idx];\n\n            if (inArray(currentSeries.type, seriesTypes)) {\n              result.push(currentSeries);\n            }\n          }\n\n          return result;\n        }\n\n        function getDateField(field, row, intlService) {\n          if (row === null) {\n            return row;\n          }\n\n          var key = \"_date_\" + field;\n          var value = row[key];\n\n          if (!value) {\n            value = parseDate(intlService, getter(field, true)(row));\n            row[key] = value;\n          }\n\n          return value;\n        }\n\n        function isDateAxis(axisOptions, sampleCategory) {\n          var type = axisOptions.type;\n          var dateCategory = sampleCategory instanceof Date;\n          return !type && dateCategory || equalsIgnoreCase(type, DATE);\n        }\n\n        function singleItemOrArray(array) {\n          return array.length === 1 ? array[0] : array;\n        }\n\n        var AREA_REGEX = /area/i;\n\n        function seriesMissingValues(series) {\n          if (series.missingValues) {\n            return series.missingValues;\n          }\n\n          return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n        }\n\n        function hasValue$1(series, item) {\n          var fields = SeriesBinder.current.bindPoint(series, null, item);\n          var valueFields = fields.valueFields;\n\n          for (var field in valueFields) {\n            if (dataviz.convertableToNumber(valueFields[field])) {\n              return true;\n            }\n          }\n        }\n\n        function findNext(ref) {\n          var start = ref.start;\n          var dir = ref.dir;\n          var min = ref.min;\n          var max = ref.max;\n          var getter$$1 = ref.getter;\n          var hasItem = ref.hasItem;\n          var series = ref.series;\n          var pointHasValue, outPoint;\n          var idx = start;\n\n          do {\n            idx += dir; //aggregating and binding the item takes too much time for large number of categories\n            //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n\n            if (hasItem(idx)) {\n              outPoint = getter$$1(idx);\n              pointHasValue = hasValue$1(series, outPoint.item);\n            }\n          } while (min <= idx && idx <= max && !pointHasValue);\n\n          if (pointHasValue) {\n            return outPoint;\n          }\n        }\n\n        function createOutOfRangePoints(series, range, count, getter$$1, hasItem) {\n          var min = range.min;\n          var max = range.max;\n          var hasMinPoint = min > 0 && min < count;\n          var hasMaxPoint = max + 1 < count;\n\n          if (hasMinPoint || hasMaxPoint) {\n            var missingValues = seriesMissingValues(series);\n            var minPoint, maxPoint;\n\n            if (missingValues !== INTERPOLATE) {\n              if (hasMinPoint) {\n                minPoint = getter$$1(min - 1);\n              }\n\n              if (hasMaxPoint) {\n                maxPoint = getter$$1(max + 1);\n              }\n            } else {\n              var outPoint, pointHasValue;\n\n              if (hasMinPoint) {\n                outPoint = getter$$1(min - 1);\n                pointHasValue = hasValue$1(series, outPoint.item);\n\n                if (!pointHasValue) {\n                  minPoint = findNext({\n                    start: min,\n                    dir: -1,\n                    min: 0,\n                    max: count - 1,\n                    getter: getter$$1,\n                    hasItem: hasItem,\n                    series: series\n                  });\n                } else {\n                  minPoint = outPoint;\n                }\n              }\n\n              if (hasMaxPoint) {\n                outPoint = getter$$1(max + 1);\n                pointHasValue = hasValue$1(series, outPoint.item);\n\n                if (!pointHasValue) {\n                  maxPoint = findNext({\n                    start: max,\n                    dir: 1,\n                    min: 0,\n                    max: count - 1,\n                    getter: getter$$1,\n                    hasItem: hasItem,\n                    series: series\n                  });\n                } else {\n                  maxPoint = outPoint;\n                }\n              }\n            }\n\n            if (minPoint) {\n              series._outOfRangeMinPoint = minPoint;\n            }\n\n            if (maxPoint) {\n              series._outOfRangeMaxPoint = maxPoint;\n            }\n          }\n        }\n\n        var PlotAreaBase = ChartElement.extend({\n          init: function (series, options, chartService) {\n            ChartElement.fn.init.call(this, options);\n            this.initFields(series, options);\n            this.series = series;\n            this.initSeries();\n            this.charts = [];\n            this.options.legend = this.options.legend || {};\n            this.options.legend.items = [];\n            this.axes = [];\n            this.crosshairs = [];\n            this.chartService = chartService;\n            this.originalOptions = options;\n            this.createPanes();\n            this.render();\n            this.createCrosshairs();\n          },\n          initFields: function () {},\n          initSeries: function () {\n            var series = this.series;\n\n            for (var i = 0; i < series.length; i++) {\n              series[i].index = i;\n            }\n          },\n          createPanes: function () {\n            var this$1 = this;\n            var titleOptions = this.options.title || {};\n            var paneDefaults = this.options.paneDefaults;\n            var paneOptions = this.options.panes || [];\n            var panesLength = Math.max(paneOptions.length, 1);\n            var panes = [];\n            var defaults = deepExtend({\n              title: {\n                color: titleOptions.color\n              }\n            }, paneDefaults);\n\n            for (var i = 0; i < panesLength; i++) {\n              var options = deepExtend({}, defaults, paneOptions[i]);\n\n              if (isString(options.title)) {\n                options.title = deepExtend({\n                  text: options.title\n                }, defaults.title);\n              }\n\n              var currentPane = new Pane(options);\n              currentPane.paneIndex = i;\n              panes.push(currentPane);\n              this$1.append(currentPane);\n            }\n\n            this.panes = panes;\n          },\n          crosshairOptions: function (axis) {\n            return axis.options.crosshair;\n          },\n          createCrosshairs: function (panes) {\n            var this$1 = this;\n\n            if (panes === void 0) {\n              panes = this.panes;\n            }\n\n            for (var i = 0; i < panes.length; i++) {\n              var pane = panes[i];\n\n              for (var j = 0; j < pane.axes.length; j++) {\n                var axis = pane.axes[j];\n                var options = this$1.crosshairOptions(axis);\n\n                if (options && options.visible) {\n                  var currentCrosshair = new Crosshair(this$1.chartService, axis, options);\n                  this$1.crosshairs.push(currentCrosshair);\n                  pane.content.append(currentCrosshair);\n                }\n              }\n            }\n          },\n          removeCrosshairs: function (pane) {\n            var crosshairs = this.crosshairs;\n            var axes = pane.axes;\n\n            for (var i = crosshairs.length - 1; i >= 0; i--) {\n              for (var j = 0; j < axes.length; j++) {\n                if (crosshairs[i].axis === axes[j]) {\n                  crosshairs.splice(i, 1);\n                  break;\n                }\n              }\n            }\n          },\n          hideCrosshairs: function () {\n            var crosshairs = this.crosshairs;\n\n            for (var idx = 0; idx < crosshairs.length; idx++) {\n              crosshairs[idx].hide();\n            }\n          },\n          findPane: function (name) {\n            var panes = this.panes;\n            var matchingPane;\n\n            for (var i = 0; i < panes.length; i++) {\n              if (panes[i].options.name === name) {\n                matchingPane = panes[i];\n                break;\n              }\n            }\n\n            return matchingPane || panes[0];\n          },\n          findPointPane: function (point) {\n            var panes = this.panes;\n            var matchingPane;\n\n            for (var i = 0; i < panes.length; i++) {\n              if (panes[i].box.containsPoint(point)) {\n                matchingPane = panes[i];\n                break;\n              }\n            }\n\n            return matchingPane;\n          },\n          appendAxis: function (axis) {\n            var pane = this.findPane(axis.options.pane);\n            pane.appendAxis(axis);\n            this.axes.push(axis);\n            axis.plotArea = this;\n          },\n          removeAxis: function (axisToRemove) {\n            var this$1 = this;\n            var filteredAxes = [];\n\n            for (var i = 0; i < this.axes.length; i++) {\n              var axis = this$1.axes[i];\n\n              if (axisToRemove !== axis) {\n                filteredAxes.push(axis);\n              } else {\n                axis.destroy();\n              }\n            }\n\n            this.axes = filteredAxes;\n          },\n          appendChart: function (chart, pane) {\n            this.charts.push(chart);\n\n            if (pane) {\n              pane.appendChart(chart);\n            } else {\n              this.append(chart);\n            }\n          },\n          removeChart: function (chartToRemove) {\n            var this$1 = this;\n            var filteredCharts = [];\n\n            for (var i = 0; i < this.charts.length; i++) {\n              var chart = this$1.charts[i];\n\n              if (chart !== chartToRemove) {\n                filteredCharts.push(chart);\n              } else {\n                chart.destroy();\n              }\n            }\n\n            this.charts = filteredCharts;\n          },\n          addToLegend: function (series) {\n            var count = series.length;\n            var legend = this.options.legend;\n            var labels = legend.labels || {};\n            var inactiveItems = legend.inactiveItems || {};\n            var inactiveItemsLabels = inactiveItems.labels || {};\n            var data = [];\n\n            for (var i = 0; i < count; i++) {\n              var currentSeries = series[i];\n              var seriesVisible = currentSeries.visible !== false;\n\n              if (currentSeries.visibleInLegend === false) {\n                continue;\n              }\n\n              var text = currentSeries.name;\n              var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n\n              if (labelTemplate) {\n                text = labelTemplate({\n                  text: hasValue(text) ? text : \"\",\n                  series: currentSeries\n                });\n              }\n\n              var defaults = currentSeries._defaults;\n              var color = currentSeries.color;\n\n              if (isFunction(color) && defaults) {\n                color = defaults.color;\n              }\n\n              var itemLabelOptions = void 0,\n                  markerColor = void 0;\n\n              if (seriesVisible) {\n                itemLabelOptions = {};\n                markerColor = color;\n              } else {\n                itemLabelOptions = {\n                  color: inactiveItemsLabels.color,\n                  font: inactiveItemsLabels.font\n                };\n                markerColor = inactiveItems.markers.color;\n              }\n\n              if (hasValue(text) && text !== \"\") {\n                data.push({\n                  text: text,\n                  labels: itemLabelOptions,\n                  markerColor: markerColor,\n                  series: currentSeries,\n                  active: seriesVisible\n                });\n              }\n            }\n\n            append(legend.items, data);\n          },\n          groupAxes: function (panes) {\n            var xAxes = [];\n            var yAxes = [];\n\n            for (var paneIx = 0; paneIx < panes.length; paneIx++) {\n              var paneAxes = panes[paneIx].axes;\n\n              for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n                var axis = paneAxes[axisIx];\n\n                if (axis.options.vertical) {\n                  yAxes.push(axis);\n                } else {\n                  xAxes.push(axis);\n                }\n              }\n            }\n\n            return {\n              x: xAxes,\n              y: yAxes,\n              any: xAxes.concat(yAxes)\n            };\n          },\n          groupSeriesByPane: function () {\n            var this$1 = this;\n            var series = this.series;\n            var seriesByPane = {};\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n              var pane = this$1.seriesPaneName(currentSeries);\n\n              if (seriesByPane[pane]) {\n                seriesByPane[pane].push(currentSeries);\n              } else {\n                seriesByPane[pane] = [currentSeries];\n              }\n            }\n\n            return seriesByPane;\n          },\n          filterVisibleSeries: function (series) {\n            var result = [];\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n\n              if (currentSeries.visible !== false) {\n                result.push(currentSeries);\n              }\n            }\n\n            return result;\n          },\n          reflow: function (targetBox) {\n            var options = this.options.plotArea;\n            var panes = this.panes;\n            var margin = getSpacing(options.margin);\n            this.box = targetBox.clone().unpad(margin);\n            this.reflowPanes();\n            this.detachLabels();\n            this.reflowAxes(panes);\n            this.reflowCharts(panes);\n          },\n          redraw: function (panes) {\n            var this$1 = this;\n            var panesArray = [].concat(panes);\n            this.initSeries(); //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n\n            var root = this.getRoot();\n\n            if (root) {\n              root.cleanGradients();\n            }\n\n            for (var i = 0; i < panesArray.length; i++) {\n              this$1.removeCrosshairs(panesArray[i]);\n              panesArray[i].empty();\n            }\n\n            this.render(panesArray);\n            this.detachLabels();\n            this.reflowAxes(this.panes);\n            this.reflowCharts(panesArray);\n            this.createCrosshairs(panesArray);\n\n            for (var i$1 = 0; i$1 < panesArray.length; i$1++) {\n              panesArray[i$1].refresh();\n            }\n          },\n          axisCrossingValues: function (axis, crossingAxes) {\n            var options = axis.options;\n            var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n            var valuesToAdd = crossingAxes.length - crossingValues.length;\n            var defaultValue = crossingValues[0] || 0;\n\n            for (var i = 0; i < valuesToAdd; i++) {\n              crossingValues.push(defaultValue);\n            }\n\n            return crossingValues;\n          },\n          alignAxisTo: function (axis, targetAxis, crossingValue, targetCrossingValue) {\n            var slot = axis.getSlot(crossingValue, crossingValue, true);\n            var slotEdge = axis.options.reverse ? 2 : 1;\n            var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n            var targetEdge = targetAxis.options.reverse ? 2 : 1;\n            var axisBox = axis.box.translate(targetSlot[X + targetEdge] - slot[X + slotEdge], targetSlot[Y + targetEdge] - slot[Y + slotEdge]);\n\n            if (axis.pane !== targetAxis.pane) {\n              axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n            }\n\n            axis.reflow(axisBox);\n          },\n          alignAxes: function (xAxes, yAxes) {\n            var this$1 = this;\n            var xAnchor = xAxes[0];\n            var yAnchor = yAxes[0];\n            var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n            var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n            var leftAnchors = {};\n            var rightAnchors = {};\n            var topAnchors = {};\n            var bottomAnchors = {};\n\n            for (var i = 0; i < yAxes.length; i++) {\n              var axis = yAxes[i];\n              var pane = axis.pane;\n              var paneId = pane.id;\n              var visible = axis.options.visible !== false; // Locate pane anchor, if any, and use its axisCrossingValues\n\n              var anchor = paneAnchor(xAxes, pane) || xAnchor;\n              var anchorCrossings = xAnchorCrossings;\n\n              if (anchor !== xAnchor) {\n                anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);\n              }\n\n              this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n              if (axis.options._overlap) {\n                continue;\n              }\n\n              if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n                // Push the axis to the left the previous y-axis so they don't overlap\n                if (leftAnchors[paneId]) {\n                  axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0));\n                }\n\n                if (visible) {\n                  leftAnchors[paneId] = axis;\n                }\n              }\n\n              if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n                // Flip the labels on the right if we're at the right end of the pane\n                if (!axis._mirrored) {\n                  axis.options.labels.mirror = !axis.options.labels.mirror;\n                  axis._mirrored = true;\n                }\n\n                this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]); // Push the axis to the right the previous y-axis so they don't overlap\n\n                if (rightAnchors[paneId]) {\n                  axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0));\n                }\n\n                if (visible) {\n                  rightAnchors[paneId] = axis;\n                }\n              }\n\n              if (i !== 0 && yAnchor.pane === axis.pane) {\n                axis.alignTo(yAnchor);\n                axis.reflow(axis.box);\n              }\n            }\n\n            for (var i$1 = 0; i$1 < xAxes.length; i$1++) {\n              var axis$1 = xAxes[i$1];\n              var pane$1 = axis$1.pane;\n              var paneId$1 = pane$1.id;\n              var visible$1 = axis$1.options.visible !== false; // Locate pane anchor and use its axisCrossingValues\n\n              var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;\n              var anchorCrossings$1 = yAnchorCrossings;\n\n              if (anchor$1 !== yAnchor) {\n                anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);\n              }\n\n              this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n              if (axis$1.options._overlap) {\n                continue;\n              }\n\n              if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {\n                // Flip the labels on top if we're at the top of the pane\n                if (!axis$1._mirrored) {\n                  axis$1.options.labels.mirror = !axis$1.options.labels.mirror;\n                  axis$1._mirrored = true;\n                }\n\n                this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]); // Push the axis above the previous x-axis so they don't overlap\n\n                if (topAnchors[paneId$1]) {\n                  axis$1.reflow(axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin));\n                }\n\n                if (visible$1) {\n                  topAnchors[paneId$1] = axis$1;\n                }\n              }\n\n              if (round(axis$1.lineBox().y2, datavizConstants.COORD_PRECISION) === round(anchor$1.lineBox().y2, datavizConstants.COORD_PRECISION)) {\n                // Push the axis below the previous x-axis so they don't overlap\n                if (bottomAnchors[paneId$1]) {\n                  axis$1.reflow(axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin));\n                }\n\n                if (visible$1) {\n                  bottomAnchors[paneId$1] = axis$1;\n                }\n              }\n\n              if (i$1 !== 0) {\n                axis$1.alignTo(xAnchor);\n                axis$1.reflow(axis$1.box);\n              }\n            }\n          },\n          shrinkAxisWidth: function (panes) {\n            var axes = this.groupAxes(panes).any;\n            var axisBox = axisGroupBox(axes);\n            var overflowX = 0;\n\n            for (var i = 0; i < panes.length; i++) {\n              var currentPane = panes[i];\n\n              if (currentPane.axes.length > 0) {\n                overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());\n              }\n            }\n\n            if (overflowX !== 0) {\n              for (var i$1 = 0; i$1 < axes.length; i$1++) {\n                var currentAxis = axes[i$1];\n\n                if (!currentAxis.options.vertical) {\n                  currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n                }\n              }\n            }\n          },\n          shrinkAxisHeight: function (panes) {\n            var shrinked;\n\n            for (var i = 0; i < panes.length; i++) {\n              var currentPane = panes[i];\n              var axes = currentPane.axes;\n              var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n              if (overflowY !== 0) {\n                for (var j = 0; j < axes.length; j++) {\n                  var currentAxis = axes[j];\n\n                  if (currentAxis.options.vertical) {\n                    currentAxis.reflow(currentAxis.box.shrink(0, overflowY));\n                  }\n                }\n\n                shrinked = true;\n              }\n            }\n\n            return shrinked;\n          },\n          fitAxes: function (panes) {\n            var axes = this.groupAxes(panes).any;\n            var offsetX = 0;\n\n            for (var i = 0; i < panes.length; i++) {\n              var currentPane = panes[i];\n              var paneAxes = currentPane.axes;\n              var paneBox = currentPane.contentBox;\n\n              if (paneAxes.length > 0) {\n                var axisBox = axisGroupBox(paneAxes); // OffsetY is calculated and applied per pane\n\n                var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2); // OffsetX is calculated and applied globally\n\n                offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n                for (var j = 0; j < paneAxes.length; j++) {\n                  var currentAxis = paneAxes[j];\n                  currentAxis.reflow(currentAxis.box.translate(0, offsetY));\n                }\n              }\n            }\n\n            for (var i$1 = 0; i$1 < axes.length; i$1++) {\n              var currentAxis$1 = axes[i$1];\n              currentAxis$1.reflow(currentAxis$1.box.translate(offsetX, 0));\n            }\n          },\n          reflowAxes: function (panes) {\n            var this$1 = this;\n            var axes = this.groupAxes(panes);\n\n            for (var i = 0; i < panes.length; i++) {\n              this$1.reflowPaneAxes(panes[i]);\n            }\n\n            if (axes.x.length > 0 && axes.y.length > 0) {\n              this.alignAxes(axes.x, axes.y);\n              this.shrinkAxisWidth(panes);\n              this.autoRotateAxisLabels(axes);\n              this.alignAxes(axes.x, axes.y);\n\n              if (this.shrinkAxisWidth(panes)) {\n                this.alignAxes(axes.x, axes.y);\n              }\n\n              this.shrinkAxisHeight(panes);\n              this.alignAxes(axes.x, axes.y);\n\n              if (this.shrinkAxisHeight(panes)) {\n                this.alignAxes(axes.x, axes.y);\n              }\n\n              this.fitAxes(panes);\n            }\n          },\n          autoRotateAxisLabels: function (groupedAxes) {\n            var this$1 = this;\n            var ref = this;\n            var panes = ref.panes;\n            var axes = allPaneAxes(panes);\n            var rotated;\n\n            for (var idx = 0; idx < axes.length; idx++) {\n              var axis = axes[idx];\n\n              if (axis.autoRotateLabels()) {\n                rotated = true;\n              }\n            }\n\n            if (rotated) {\n              for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {\n                this$1.reflowPaneAxes(panes[idx$1]);\n              }\n\n              if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n                this.alignAxes(groupedAxes.x, groupedAxes.y);\n                this.shrinkAxisWidth(panes);\n              }\n            }\n          },\n          reflowPaneAxes: function (pane) {\n            var axes = pane.axes;\n            var length = axes.length;\n\n            if (length > 0) {\n              for (var i = 0; i < length; i++) {\n                axes[i].reflow(pane.contentBox);\n              }\n            }\n          },\n          reflowCharts: function (panes) {\n            var charts = this.charts;\n            var count = charts.length;\n            var box = this.box;\n\n            for (var i = 0; i < count; i++) {\n              var chartPane = charts[i].pane;\n\n              if (!chartPane || inArray(chartPane, panes)) {\n                charts[i].reflow(box);\n              }\n            }\n          },\n          reflowPanes: function () {\n            var ref = this;\n            var box = ref.box;\n            var panes = ref.panes;\n            var panesLength = panes.length;\n            var remainingHeight = box.height();\n            var remainingPanes = panesLength;\n            var autoHeightPanes = 0;\n            var top = box.y1;\n\n            for (var i = 0; i < panesLength; i++) {\n              var currentPane = panes[i];\n              var height = currentPane.options.height;\n              currentPane.options.width = box.width();\n\n              if (!currentPane.options.height) {\n                autoHeightPanes++;\n              } else {\n                if (height.indexOf && height.indexOf(\"%\")) {\n                  var percents = parseInt(height, 10) / 100;\n                  currentPane.options.height = percents * box.height();\n                }\n\n                currentPane.reflow(box.clone());\n                remainingHeight -= currentPane.options.height;\n              }\n            }\n\n            for (var i$1 = 0; i$1 < panesLength; i$1++) {\n              var currentPane$1 = panes[i$1];\n\n              if (!currentPane$1.options.height) {\n                currentPane$1.options.height = remainingHeight / autoHeightPanes;\n              }\n            }\n\n            for (var i$2 = 0; i$2 < panesLength; i$2++) {\n              var currentPane$2 = panes[i$2];\n              var paneBox = box.clone().move(box.x1, top);\n              currentPane$2.reflow(paneBox);\n              remainingPanes--;\n              top += currentPane$2.options.height;\n            }\n          },\n          backgroundBox: function () {\n            var axes = this.axes;\n            var axesCount = axes.length;\n            var box;\n\n            for (var i = 0; i < axesCount; i++) {\n              var axisA = axes[i];\n\n              for (var j = 0; j < axesCount; j++) {\n                var axisB = axes[j];\n\n                if (axisA.options.vertical !== axisB.options.vertical) {\n                  var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n                  if (!box) {\n                    box = lineBox;\n                  } else {\n                    box = box.wrap(lineBox);\n                  }\n                }\n              }\n            }\n\n            return box || this.box;\n          },\n          chartsBoxes: function () {\n            var panes = this.panes;\n            var boxes = [];\n\n            for (var idx = 0; idx < panes.length; idx++) {\n              boxes.push(panes[idx].chartsBox());\n            }\n\n            return boxes;\n          },\n          addBackgroundPaths: function (multipath) {\n            var boxes = this.chartsBoxes();\n\n            for (var idx = 0; idx < boxes.length; idx++) {\n              multipath.paths.push(Path.fromRect(boxes[idx].toRect()));\n            }\n          },\n          backgroundContainsPoint: function (point) {\n            var boxes = this.chartsBoxes();\n\n            for (var idx = 0; idx < boxes.length; idx++) {\n              if (boxes[idx].containsPoint(point)) {\n                return true;\n              }\n            }\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            var options = this.options.plotArea;\n            var opacity = options.opacity;\n            var background = options.background;\n            var border = options.border;\n\n            if (border === void 0) {\n              border = {};\n            }\n\n            if (isTransparent(background)) {\n              background = WHITE;\n              opacity = 0;\n            }\n\n            var bg = this._bgVisual = new drawing.MultiPath({\n              fill: {\n                color: background,\n                opacity: opacity\n              },\n              stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n              },\n              zIndex: -1\n            });\n            this.addBackgroundPaths(bg);\n            this.appendVisual(bg);\n          },\n          pointsByCategoryIndex: function (categoryIndex) {\n            var charts = this.charts;\n            var result = [];\n\n            if (categoryIndex !== null) {\n              for (var i = 0; i < charts.length; i++) {\n                var chart = charts[i];\n\n                if (chart.pane.options.name === \"_navigator\") {\n                  continue;\n                }\n\n                var points = charts[i].categoryPoints[categoryIndex];\n\n                if (points && points.length) {\n                  for (var j = 0; j < points.length; j++) {\n                    var point = points[j];\n\n                    if (point && defined(point.value) && point.value !== null) {\n                      result.push(point);\n                    }\n                  }\n                }\n              }\n            }\n\n            return result;\n          },\n          pointsBySeriesIndex: function (seriesIndex) {\n            return this.filterPoints(function (point) {\n              return point.series.index === seriesIndex;\n            });\n          },\n          pointsBySeriesName: function (name) {\n            return this.filterPoints(function (point) {\n              return point.series.name === name;\n            });\n          },\n          filterPoints: function (callback) {\n            var charts = this.charts;\n            var result = [];\n\n            for (var i = 0; i < charts.length; i++) {\n              var chart = charts[i];\n              var points = chart.points;\n\n              for (var j = 0; j < points.length; j++) {\n                var point = points[j];\n\n                if (point && point.visible !== false && callback(point)) {\n                  result.push(point);\n                }\n              }\n            }\n\n            return result;\n          },\n          findPoint: function (callback) {\n            var charts = this.charts;\n\n            for (var i = 0; i < charts.length; i++) {\n              var chart = charts[i];\n              var points = chart.points;\n\n              for (var j = 0; j < points.length; j++) {\n                var point = points[j];\n\n                if (point && point.visible !== false && callback(point)) {\n                  return point;\n                }\n              }\n            }\n          },\n          paneByPoint: function (point) {\n            var panes = this.panes;\n\n            for (var i = 0; i < panes.length; i++) {\n              var pane = panes[i];\n\n              if (pane.box.containsPoint(point)) {\n                return pane;\n              }\n            }\n          },\n          detachLabels: function () {\n            var axes = this.groupAxes(this.panes);\n            var xAxes = axes.x;\n            var yAxes = axes.y;\n            this.detachAxisGroupLabels(yAxes, xAxes);\n            this.detachAxisGroupLabels(xAxes, yAxes);\n          },\n          detachAxisGroupLabels: function (axes, crossingAxes) {\n            var this$1 = this;\n            var labelAxisCount = 0;\n\n            for (var i = 0; i < axes.length; i++) {\n              var axis = axes[i];\n              var pane = axis.pane;\n              var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n              var axisIndex = i + labelAxisCount;\n              var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);\n\n              if (labelAxis) {\n                labelAxisCount++;\n                var pos = pane.axes.indexOf(axis) + labelAxisCount;\n                pane.appendAxisAt(labelAxis, pos);\n              }\n            }\n          },\n          createLabelAxis: function (axis, axisIndex, anchor) {\n            var labelOptions = axis.options.labels;\n            var position = labelOptions.position;\n            var onAxis = position !== datavizConstants.END && position !== datavizConstants.START;\n            var visible = labelOptions.visible;\n\n            if (onAxis || visible === false) {\n              return null;\n            }\n\n            var allAxes = this.groupAxes(this.panes);\n            var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n            var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n            var end = position === datavizConstants.END;\n            var range = anchor.range();\n            var edge = end ? range.max : range.min;\n            var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n            if (crossingValue - edge === 0) {\n              return null;\n            }\n\n            anchorCrossings.splice(axisIndex + 1, 0, edge);\n            anchor.options.axisCrossingValues = anchorCrossings;\n            var labelAxis = axis.clone();\n            axis.clear();\n            labelAxis.options.name = undefined;\n            labelAxis.options.line.visible = false;\n            labelAxis.options.crosshair = undefined;\n            labelAxis.options.notes = undefined;\n            labelAxis.options.plotBands = undefined;\n            return labelAxis;\n          }\n        });\n\n        function isSingleAxis(axis) {\n          return !axis.pane.axes.some(function (a) {\n            return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false;\n          });\n        }\n\n        function axisGroupBox(axes) {\n          var length = axes.length;\n          var box;\n\n          for (var i = 0; i < length; i++) {\n            var axis = axes[i];\n            var visible = axis.options.visible !== false;\n\n            if (visible || isSingleAxis(axis)) {\n              var axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n              if (!box) {\n                box = axisBox.clone();\n              } else {\n                box.wrap(axisBox);\n              }\n            }\n          }\n\n          return box || new Box();\n        }\n\n        function paneAnchor(axes, pane) {\n          for (var i = 0; i < axes.length; i++) {\n            var anchor = axes[i];\n\n            if (anchor && anchor.pane === pane) {\n              return anchor;\n            }\n          }\n        }\n\n        function isTransparent(color) {\n          return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n        }\n\n        var allPaneAxes = function (panes) {\n          return panes.reduce(function (acc, pane) {\n            return acc.concat(pane.axes);\n          }, []);\n        };\n\n        setDefaultOptions(PlotAreaBase, {\n          series: [],\n          plotArea: {\n            margin: {}\n          },\n          background: \"\",\n          border: {\n            color: BLACK,\n            width: 0\n          },\n          paneDefaults: {\n            title: {}\n          },\n          legend: {\n            inactiveItems: {\n              labels: {\n                color: \"#919191\"\n              },\n              markers: {\n                color: \"#919191\"\n              }\n            }\n          }\n        });\n        var PlotAreaEventsMixin = {\n          hover: function (chart, e) {\n            this._dispatchEvent(chart, e, PLOT_AREA_HOVER);\n          },\n          click: function (chart, e) {\n            this._dispatchEvent(chart, e, PLOT_AREA_CLICK);\n          }\n        };\n        var SeriesAggregator = Class.extend({\n          init: function (series, binder, defaultAggregates) {\n            var canonicalFields = binder.canonicalFields(series);\n            var valueFields = binder.valueFields(series);\n            var sourceFields = binder.sourceFields(series, canonicalFields);\n            var seriesFields = this._seriesFields = [];\n            var defaults = defaultAggregates.query(series.type);\n            var rootAggregate = series.aggregate || defaults;\n            this._series = series;\n            this._binder = binder;\n\n            for (var i = 0; i < canonicalFields.length; i++) {\n              var field = canonicalFields[i];\n              var fieldAggregate = void 0;\n\n              if (isObject(rootAggregate)) {\n                fieldAggregate = rootAggregate[field];\n              } else if (i === 0 || inArray(field, valueFields)) {\n                fieldAggregate = rootAggregate;\n              } else {\n                break;\n              }\n\n              if (fieldAggregate) {\n                seriesFields.push({\n                  canonicalName: field,\n                  name: sourceFields[i],\n                  transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\n                });\n              }\n            }\n          },\n          aggregatePoints: function (srcPoints, group) {\n            var this$1 = this;\n            var ref = this;\n            var series = ref._series;\n            var seriesFields = ref._seriesFields;\n\n            var data = this._bindPoints(srcPoints || []);\n\n            var firstDataItem = data.dataItems[0];\n            var result = {};\n\n            if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n              var fn = function () {};\n\n              fn.prototype = firstDataItem;\n              result = new fn();\n            }\n\n            for (var i = 0; i < seriesFields.length; i++) {\n              var field = seriesFields[i];\n\n              var srcValues = this$1._bindField(data.values, field.canonicalName);\n\n              var value = field.transform(srcValues, series, data.dataItems, group);\n\n              if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n                result = value;\n                break;\n              } else {\n                if (defined(value)) {\n                  setValue(field.name, result, value);\n                }\n              }\n            }\n\n            return result;\n          },\n          _bindPoints: function (points) {\n            var ref = this;\n            var binder = ref._binder;\n            var series = ref._series;\n            var values = [];\n            var dataItems = [];\n\n            for (var i = 0; i < points.length; i++) {\n              var pointIx = points[i];\n              values.push(binder.bindPoint(series, pointIx));\n              dataItems.push(series.data[pointIx]);\n            }\n\n            return {\n              values: values,\n              dataItems: dataItems\n            };\n          },\n          _bindField: function (data, field) {\n            var values = [];\n            var count = data.length;\n\n            for (var i = 0; i < count; i++) {\n              var item = data[i];\n              var valueFields = item.valueFields;\n              var value = void 0;\n\n              if (defined(valueFields[field])) {\n                value = valueFields[field];\n              } else {\n                value = item.fields[field];\n              }\n\n              values.push(value);\n            }\n\n            return values;\n          }\n        });\n\n        function setValue(fieldName, target, value) {\n          var parentObj = target;\n          var field = fieldName;\n\n          if (fieldName.indexOf(\".\") > -1) {\n            var parts = fieldName.split(\".\");\n\n            while (parts.length > 1) {\n              field = parts.shift();\n\n              if (!defined(parentObj[field])) {\n                parentObj[field] = {};\n              }\n\n              parentObj = parentObj[field];\n            }\n\n            field = parts.shift();\n          }\n\n          parentObj[field] = value;\n        }\n\n        var DefaultAggregates = Class.extend({\n          init: function () {\n            this._defaults = {};\n          },\n          register: function (seriesTypes, aggregates) {\n            var this$1 = this;\n\n            for (var i = 0; i < seriesTypes.length; i++) {\n              this$1._defaults[seriesTypes[i]] = aggregates;\n            }\n          },\n          query: function (seriesType) {\n            return this._defaults[seriesType];\n          }\n        });\n        DefaultAggregates.current = new DefaultAggregates();\n        var RangeBar = Bar.extend({\n          createLabel: function () {\n            var labels = this.options.labels;\n            var fromOptions = deepExtend({}, labels, labels.from);\n            var toOptions = deepExtend({}, labels, labels.to);\n\n            if (fromOptions.visible) {\n              this.labelFrom = this._createLabel(fromOptions);\n              this.append(this.labelFrom);\n            }\n\n            if (toOptions.visible) {\n              this.labelTo = this._createLabel(toOptions);\n              this.append(this.labelTo);\n            }\n          },\n          _createLabel: function (options) {\n            var labelTemplate = getTemplate(options);\n            var pointData = this.pointData();\n            var labelText;\n\n            if (labelTemplate) {\n              labelText = labelTemplate(pointData);\n            } else {\n              labelText = this.formatValue(options.format);\n            }\n\n            return new BarLabel(labelText, deepExtend({\n              vertical: this.options.vertical\n            }, options), pointData);\n          },\n          reflow: function (targetBox) {\n            this.render();\n            var ref = this;\n            var labelFrom = ref.labelFrom;\n            var labelTo = ref.labelTo;\n            var value = ref.value;\n            this.box = targetBox;\n\n            if (labelFrom) {\n              labelFrom.options.aboveAxis = value.from > value.to;\n              labelFrom.reflow(targetBox);\n            }\n\n            if (labelTo) {\n              labelTo.options.aboveAxis = value.to > value.from;\n              labelTo.reflow(targetBox);\n            }\n\n            if (this.note) {\n              this.note.reflow(targetBox);\n            }\n          }\n        });\n        RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {\n          labels: {\n            format: \"{0} - {1}\"\n          },\n          tooltip: {\n            format: \"{1}\"\n          }\n        });\n        var RangeBarChart = BarChart.extend({\n          pointType: function () {\n            return RangeBar;\n          },\n          pointValue: function (data) {\n            return data.valueFields;\n          },\n          formatPointValue: function (point, format) {\n            if (point.value.from === null && point.value.to === null) {\n              return \"\";\n            }\n\n            return this.chartService.format.auto(format, point.value.from, point.value.to);\n          },\n          plotRange: function (point) {\n            if (!point) {\n              return 0;\n            }\n\n            return [point.value.from, point.value.to];\n          },\n          updateRange: function (value, fields) {\n            var axisName = fields.series.axis;\n            var from = value.from;\n            var to = value.to;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (value !== null && isNumber(from) && isNumber(to)) {\n              axisRange = this.valueAxisRanges[axisName] = axisRange || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n              axisRange.min = Math.min(axisRange.min, from);\n              axisRange.max = Math.max(axisRange.max, from);\n              axisRange.min = Math.min(axisRange.min, to);\n              axisRange.max = Math.max(axisRange.max, to);\n            }\n          },\n          aboveAxis: function (point) {\n            var value = point.value;\n            return value.from < value.to;\n          }\n        });\n        RangeBarChart.prototype.plotLimits = CategoricalChart.prototype.plotLimits;\n        var RangeLinePoint = LinePoint.extend({\n          aliasFor: function () {\n            return this.parent;\n          }\n        });\n        var AUTO = 'auto';\n        var DEFAULT_FROM_FORMAT = '{0}';\n        var DEFAULT_TO_FORMAT = '{1}';\n        var RangeAreaPoint = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this);\n            this.value = value;\n            this.options = options;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.tooltipTracking = true;\n            this.initLabelsFormat();\n          },\n          render: function () {\n            if (this._rendered) {\n              return;\n            }\n\n            this._rendered = true;\n            var ref = this.options;\n            var markers = ref.markers;\n            var labels = ref.labels;\n            var value = this.value;\n            var fromPoint = this.fromPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n              labels: labels.from,\n              markers: markers.from\n            }));\n            var toPoint = this.toPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n              labels: labels.to,\n              markers: markers.to\n            }));\n            this.copyFields(fromPoint);\n            this.copyFields(toPoint);\n            this.append(fromPoint);\n            this.append(toPoint);\n          },\n          reflow: function (targetBox) {\n            this.render();\n            var fromBox = targetBox.from;\n            var toBox = targetBox.to;\n            this.positionLabels(fromBox, toBox);\n            this.fromPoint.reflow(fromBox);\n            this.toPoint.reflow(toBox);\n            this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());\n          },\n          createHighlight: function () {\n            var group = new Group();\n            group.append(this.fromPoint.createHighlight());\n            group.append(this.toPoint.createHighlight());\n            return group;\n          },\n          highlightVisual: function () {\n            return this.visual;\n          },\n          highlightVisualArgs: function () {\n            return {\n              options: this.options,\n              from: this.fromPoint.highlightVisualArgs(),\n              to: this.toPoint.highlightVisualArgs()\n            };\n          },\n          tooltipAnchor: function () {\n            var clipBox = this.owner.pane.clipBox();\n            var showTooltip = !clipBox || clipBox.overlaps(this.box);\n\n            if (showTooltip) {\n              var box = this.box;\n              var center = box.center();\n              var horizontalAlign = LEFT;\n              var x, y, verticalAlign;\n\n              if (this.options.vertical) {\n                x = center.x;\n                y = box.y1 - TOOLTIP_OFFSET;\n                verticalAlign = BOTTOM;\n              } else {\n                x = box.x2 + TOOLTIP_OFFSET;\n                y = center.y;\n                verticalAlign = CENTER;\n              }\n\n              return {\n                point: new Point(x, y),\n                align: {\n                  horizontal: horizontalAlign,\n                  vertical: verticalAlign\n                }\n              };\n            }\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          overlapsBox: function (box) {\n            return this.box.overlaps(box);\n          },\n          unclipElements: function () {\n            this.fromPoint.unclipElements();\n            this.toPoint.unclipElements();\n          },\n          initLabelsFormat: function () {\n            var labels = this.options.labels;\n\n            if (!labels.format) {\n              if (!labels.from || !labels.from.format) {\n                labels.from = $.extend({}, labels.from, {\n                  format: DEFAULT_FROM_FORMAT\n                });\n              }\n\n              if (!labels.to || !labels.to.format) {\n                labels.to = $.extend({}, labels.to, {\n                  format: DEFAULT_TO_FORMAT\n                });\n              }\n            }\n          },\n          positionLabels: function (fromBox, toBox) {\n            var ref = this.options;\n            var labels = ref.labels;\n            var vertical = ref.vertical;\n\n            if (labels.position === AUTO) {\n              var fromLabelPosition, toLabelPosition;\n\n              if (vertical) {\n                if (toBox.y1 <= fromBox.y1) {\n                  toLabelPosition = ABOVE;\n                  fromLabelPosition = BELOW;\n                } else {\n                  toLabelPosition = BELOW;\n                  fromLabelPosition = ABOVE;\n                }\n              } else {\n                if (toBox.x1 <= fromBox.x1) {\n                  toLabelPosition = LEFT;\n                  fromLabelPosition = RIGHT;\n                } else {\n                  toLabelPosition = RIGHT;\n                  fromLabelPosition = LEFT;\n                }\n              }\n\n              if (!labels.from || !labels.from.position) {\n                this.fromPoint.options.labels.position = fromLabelPosition;\n              }\n\n              if (!labels.to || !labels.to.position) {\n                this.toPoint.options.labels.position = toLabelPosition;\n              }\n            }\n          },\n          copyFields: function (point) {\n            point.dataItem = this.dataItem;\n            point.category = this.category;\n            point.series = this.series;\n            point.color = this.color;\n            point.owner = this.owner;\n          }\n        });\n        deepExtend(RangeAreaPoint.prototype, PointEventsMixin);\n        deepExtend(RangeAreaPoint.prototype, NoteMixin);\n        RangeAreaPoint.prototype.defaults = {\n          markers: {\n            visible: false,\n            background: WHITE,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            border: {\n              width: 2\n            },\n            opacity: 1\n          },\n          labels: {\n            visible: false,\n            margin: getSpacing(3),\n            padding: getSpacing(4),\n            animation: {\n              type: FADEIN,\n              delay: INITIAL_ANIMATION_DURATION\n            },\n            position: AUTO\n          },\n          notes: {\n            label: {}\n          },\n          highlight: {\n            markers: {\n              border: {\n                color: WHITE,\n                width: 2\n              }\n            },\n            zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n          },\n          tooltip: {\n            format: '{0} - {1}'\n          }\n        };\n        var RangeAreaSegment = AreaSegment.extend({\n          createStrokeSegments: function () {\n            return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));\n          },\n          stackSegments: function () {\n            var fromSegments = this.fromSegments;\n\n            if (!this.fromSegments) {\n              fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));\n            }\n\n            return fromSegments;\n          },\n          createStroke: function (style) {\n            var toPath = new Path(style);\n            var fromPath = new Path(style);\n            toPath.segments.push.apply(toPath.segments, this.strokeSegments());\n            fromPath.segments.push.apply(fromPath.segments, this.stackSegments());\n            this.visual.append(toPath);\n            this.visual.append(fromPath);\n          },\n          hasStackSegment: function () {\n            return true;\n          },\n          fromPoints: function () {\n            return this.linePoints.map(function (point) {\n              return point.fromPoint;\n            });\n          },\n          toPoints: function () {\n            return this.linePoints.map(function (point) {\n              return point.toPoint;\n            });\n          }\n        });\n        var SplineRangeAreaSegment = RangeAreaSegment.extend({\n          createStrokeSegments: function () {\n            return this.createCurveSegments(this.toPoints());\n          },\n          stackSegments: function () {\n            var fromSegments = this.fromSegments;\n\n            if (!this.fromSegments) {\n              fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());\n            }\n\n            return fromSegments;\n          },\n          createCurveSegments: function (points) {\n            var curveProcessor = new CurveProcessor();\n            return curveProcessor.process(this.toGeometryPoints(points));\n          }\n        });\n        var StepRangeAreaSegment = RangeAreaSegment.extend({\n          createStrokeSegments: function () {\n            return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));\n          },\n          stackSegments: function () {\n            var fromSegments = this.fromSegments;\n\n            if (!this.fromSegments) {\n              fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));\n              fromSegments.reverse();\n            }\n\n            return fromSegments;\n          }\n        });\n        deepExtend(StepRangeAreaSegment.prototype, StepLineMixin);\n        var RangeAreaChart = CategoricalChart.extend({\n          render: function () {\n            CategoricalChart.fn.render.call(this);\n            this.renderSegments();\n          },\n          pointType: function () {\n            return RangeAreaPoint;\n          },\n          createPoint: function (data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var value = data.valueFields;\n\n            if (!hasValue(value.from) && !hasValue(value.to)) {\n              if (this.seriesMissingValues(series) === ZERO) {\n                value = {\n                  from: 0,\n                  to: 0\n                };\n              } else {\n                return null;\n              }\n            }\n\n            var pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n            var color = data.fields.color || series.color;\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            }\n\n            var point = new RangeAreaPoint(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n          },\n          createSegment: function (linePoints, currentSeries, seriesIx) {\n            var style = (currentSeries.line || {}).style;\n            var segmentType;\n\n            if (style === \"smooth\") {\n              segmentType = SplineRangeAreaSegment;\n            } else if (style === \"step\") {\n              segmentType = StepRangeAreaSegment;\n            } else {\n              segmentType = RangeAreaSegment;\n            }\n\n            return new segmentType(linePoints, currentSeries, seriesIx);\n          },\n          plotRange: function (point, startValue) {\n            if (!point) {\n              return [startValue, startValue];\n            }\n\n            return [point.value.from, point.value.to];\n          },\n          valueSlot: function (valueAxis, plotRange) {\n            var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\n            var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\n\n            if (fromSlot && toSlot) {\n              return {\n                from: fromSlot,\n                to: toSlot\n              };\n            }\n          },\n          pointSlot: function (categorySlot, valueSlot) {\n            var from = valueSlot.from;\n            var to = valueSlot.to;\n            var fromSlot, toSlot;\n\n            if (this.options.invertAxes) {\n              fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\n              toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\n            } else {\n              fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\n              toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\n            }\n\n            return {\n              from: fromSlot,\n              to: toSlot\n            };\n          },\n          addValue: function (data, fields) {\n            var valueFields = data.valueFields;\n\n            if (!isNumber(valueFields.from)) {\n              valueFields.from = valueFields.to;\n            }\n\n            if (!isNumber(valueFields.to)) {\n              valueFields.to = valueFields.from;\n            }\n\n            CategoricalChart.fn.addValue.call(this, data, fields);\n          },\n          updateRange: function (value, fields) {\n            if (value !== null && isNumber(value.from) && isNumber(value.to)) {\n              var axisName = fields.series.axis;\n              var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || {\n                min: MAX_VALUE,\n                max: MIN_VALUE\n              };\n              var from = value.from;\n              var to = value.to;\n              axisRange.min = Math.min(axisRange.min, from, to);\n              axisRange.max = Math.max(axisRange.max, from, to);\n            }\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.from, value.to);\n          },\n          animationPoints: function () {\n            var points = this.points;\n            var result = [];\n\n            for (var idx = 0; idx < points.length; idx++) {\n              var point = points[idx];\n\n              if (point) {\n                result.push((point.fromPoint || {}).marker);\n                result.push((point.toPoint || {}).marker);\n              }\n            }\n\n            return result.concat(this._segments);\n          }\n        });\n        deepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);\n        var OHLCPoint = Candlestick.extend({\n          reflow: function (box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var oPoints = [];\n            var cPoints = [];\n            var lhPoints = [];\n            var lhSlot = valueAxis.getSlot(value.low, value.high);\n            var oSlot = valueAxis.getSlot(value.open, value.open);\n            var cSlot = valueAxis.getSlot(value.close, value.close);\n            oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;\n            oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;\n            var mid = lhSlot.center().x;\n            oPoints.push([oSlot.x1, oSlot.y1]);\n            oPoints.push([mid, oSlot.y1]);\n            cPoints.push([mid, cSlot.y1]);\n            cPoints.push([cSlot.x2, cSlot.y1]);\n            lhPoints.push([mid, lhSlot.y1]);\n            lhPoints.push([mid, lhSlot.y2]);\n            this.lines = [oPoints, cPoints, lhPoints];\n            this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));\n            this.reflowNote();\n          },\n          createBody: function () {}\n        });\n        var OHLCChart = CandlestickChart.extend({\n          pointType: function () {\n            return OHLCPoint;\n          }\n        });\n        var WaterfallSegment = ChartElement.extend({\n          init: function (from, to, series) {\n            ChartElement.fn.init.call(this);\n            this.from = from;\n            this.to = to;\n            this.series = series;\n          },\n          linePoints: function () {\n            var from = this.from;\n            var ref = this;\n            var fromBox = ref.from.box;\n            var toBox = ref.to.box;\n            var points = [];\n\n            if (from.isVertical) {\n              var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;\n              points.push([fromBox.x1, y], [toBox.x2, y]);\n            } else {\n              var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;\n              points.push([x, fromBox.y1], [x, toBox.y2]);\n            }\n\n            return points;\n          },\n          createVisual: function () {\n            ChartElement.fn.createVisual.call(this);\n            var line = this.series.line || {};\n            var path = Path.fromPoints(this.linePoints(), {\n              stroke: {\n                color: line.color,\n                width: line.width,\n                opacity: line.opacity,\n                dashType: line.dashType\n              }\n            });\n            alignPathToPixel(path);\n            this.visual.append(path);\n          }\n        });\n        setDefaultOptions(WaterfallSegment, {\n          animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n          }\n        });\n        var WaterfallChart = BarChart.extend({\n          render: function () {\n            BarChart.fn.render.call(this);\n            this.createSegments();\n          },\n          traverseDataPoints: function (callback) {\n            var this$1 = this;\n            var series = this.options.series;\n            var totalCategories = categoriesCount(series);\n            var isVertical = !this.options.invertAxes;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var total = 0;\n              var runningTotal = 0;\n\n              for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n                var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n                var value = data.valueFields.value;\n                var summary = data.fields.summary;\n                var from = total;\n                var to = void 0;\n\n                if (summary) {\n                  if (summary.toLowerCase() === \"total\") {\n                    data.valueFields.value = total;\n                    from = 0;\n                    to = total;\n                  } else {\n                    data.valueFields.value = runningTotal;\n                    to = from - runningTotal;\n                    runningTotal = 0;\n                  }\n                } else if (isNumber(value)) {\n                  runningTotal += value;\n                  total += value;\n                  to = total;\n                }\n\n                callback(data, {\n                  category: this$1.categoryAxis.categoryAt(categoryIx),\n                  categoryIx: categoryIx,\n                  series: currentSeries,\n                  seriesIx: seriesIx,\n                  total: total,\n                  runningTotal: runningTotal,\n                  from: from,\n                  to: to,\n                  isVertical: isVertical\n                });\n              }\n            }\n          },\n          updateRange: function (value, fields) {\n            BarChart.fn.updateRange.call(this, {\n              value: fields.to\n            }, fields);\n          },\n          aboveAxis: function (point) {\n            return point.value >= 0;\n          },\n          plotRange: function (point) {\n            return [point.from, point.to];\n          },\n          createSegments: function () {\n            var this$1 = this;\n            var series = this.options.series;\n            var seriesPoints = this.seriesPoints;\n            var segments = this.segments = [];\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var points = seriesPoints[seriesIx];\n\n              if (points) {\n                var prevPoint = void 0;\n\n                for (var pointIx = 0; pointIx < points.length; pointIx++) {\n                  var point = points[pointIx];\n\n                  if (point && prevPoint) {\n                    var segment = new WaterfallSegment(prevPoint, point, currentSeries);\n                    segments.push(segment);\n                    this$1.append(segment);\n                  }\n\n                  prevPoint = point;\n                }\n              }\n            }\n          }\n        });\n        var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];\n        var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);\n        var CategoricalPlotArea = PlotAreaBase.extend({\n          initFields: function (series) {\n            var this$1 = this;\n            this.namedCategoryAxes = {};\n            this.namedValueAxes = {};\n            this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n\n            if (series.length > 0) {\n              this.invertAxes = inArray(series[0].type, [BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA, RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT]);\n\n              for (var i = 0; i < series.length; i++) {\n                var stack = series[i].stack;\n\n                if (stack && stack.type === \"100%\") {\n                  this$1.stack100 = true;\n                  break;\n                }\n              }\n            }\n          },\n          render: function (panes) {\n            if (panes === void 0) {\n              panes = this.panes;\n            }\n\n            this.createCategoryAxes(panes);\n            this.aggregateCategories(panes);\n            this.createCategoryAxesLabels(panes);\n            this.createCharts(panes);\n            this.createValueAxes(panes);\n          },\n          removeAxis: function (axis) {\n            var axisName = axis.options.name;\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis instanceof CategoryAxis) {\n              delete this.namedCategoryAxes[axisName];\n            } else {\n              this.valueAxisRangeTracker.reset(axisName);\n              delete this.namedValueAxes[axisName];\n            }\n\n            if (axis === this.categoryAxis) {\n              delete this.categoryAxis;\n            }\n\n            if (axis === this.valueAxis) {\n              delete this.valueAxis;\n            }\n          },\n          createCharts: function (panes) {\n            var this$1 = this;\n            var seriesByPane = this.groupSeriesByPane();\n\n            for (var i = 0; i < panes.length; i++) {\n              var pane = panes[i];\n              var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n              this$1.addToLegend(paneSeries);\n              var visibleSeries = this$1.filterVisibleSeries(paneSeries);\n\n              if (!visibleSeries) {\n                continue;\n              }\n\n              var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);\n\n              for (var groupIx = 0; groupIx < groups.length; groupIx++) {\n                this$1.createChartGroup(groups[groupIx], pane);\n              }\n            }\n          },\n          createChartGroup: function (series, pane) {\n            this.createAreaChart(filterSeriesByType(series, [AREA, VERTICAL_AREA]), pane);\n            this.createRangeAreaChart(filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]), pane);\n            this.createBarChart(filterSeriesByType(series, [COLUMN, BAR]), pane);\n            this.createRangeBarChart(filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]), pane);\n            this.createBulletChart(filterSeriesByType(series, [BULLET, VERTICAL_BULLET]), pane);\n            this.createCandlestickChart(filterSeriesByType(series, CANDLESTICK), pane);\n            this.createBoxPlotChart(filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]), pane);\n            this.createOHLCChart(filterSeriesByType(series, OHLC), pane);\n            this.createWaterfallChart(filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]), pane);\n            this.createLineChart(filterSeriesByType(series, [LINE, VERTICAL_LINE]), pane);\n          },\n          aggregateCategories: function (panes) {\n            var this$1 = this;\n            var series = this.srcSeries || this.series;\n            var processedSeries = [];\n            this._currentPointsCache = {};\n            this._seriesPointsCache = this._seriesPointsCache || {};\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n              var categoryAxis = this$1.seriesCategoryAxis(currentSeries);\n              var axisPane = this$1.findPane(categoryAxis.options.pane);\n              var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n              if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n                currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);\n              } else {\n                currentSeries = this$1.filterSeries(currentSeries, categoryAxis);\n              }\n\n              processedSeries.push(currentSeries);\n            }\n\n            this._seriesPointsCache = this._currentPointsCache;\n            this._currentPointsCache = null;\n            this.srcSeries = series;\n            this.series = processedSeries;\n          },\n          filterSeries: function (series, categoryAxis) {\n            var dataLength = (series.data || {}).length;\n            categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n            if (!(isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max))) {\n              return series;\n            }\n\n            var range = categoryAxis.currentRangeIndices();\n            var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n            var currentSeries = deepExtend({}, series);\n            currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n            if (outOfRangePoints) {\n              createOutOfRangePoints(currentSeries, range, dataLength, function (idx) {\n                return {\n                  item: series.data[idx],\n                  category: categoryAxis.categoryAt(idx, true),\n                  categoryIx: idx - range.min\n                };\n              }, function (idx) {\n                return defined(series.data[idx]);\n              });\n            }\n\n            return currentSeries;\n          },\n          clearSeriesPointsCache: function () {\n            this._seriesPointsCache = {};\n          },\n          seriesSourcePoints: function (series, categoryAxis) {\n            var this$1 = this;\n            var key = series.index + \";\" + categoryAxis.categoriesHash();\n\n            if (this._seriesPointsCache[key]) {\n              this._currentPointsCache[key] = this._seriesPointsCache[key];\n              return this._seriesPointsCache[key];\n            }\n\n            var axisOptions = categoryAxis.options;\n            var srcCategories = axisOptions.srcCategories;\n            var dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n            var srcData = series.data;\n            var getFn = dateAxis ? getDateField : getField;\n            var result = [];\n\n            if (!dateAxis) {\n              categoryAxis.mapCategories(); //fixes major performance issue caused by searching for the index for large data\n            }\n\n            for (var idx = 0; idx < srcData.length; idx++) {\n              var category = void 0;\n\n              if (series.categoryField) {\n                category = getFn(series.categoryField, srcData[idx], this$1.chartService.intl);\n              } else {\n                category = srcCategories[idx];\n              }\n\n              if (defined(category) && category !== null) {\n                var categoryIx = categoryAxis.totalIndex(category);\n                result[categoryIx] = result[categoryIx] || {\n                  items: [],\n                  category: category\n                };\n                result[categoryIx].items.push(idx);\n              }\n            }\n\n            this._currentPointsCache[key] = result;\n            return result;\n          },\n          aggregateSeries: function (series, categoryAxis) {\n            var srcData = series.data;\n\n            if (!srcData.length) {\n              return series;\n            }\n\n            var srcPoints = this.seriesSourcePoints(series, categoryAxis);\n            var result = deepExtend({}, series);\n            var aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n            var data = result.data = [];\n            var dataItems = categoryAxis.options.dataItems || [];\n            var range = categoryAxis.currentRangeIndices();\n\n            var categoryItem = function (idx) {\n              var categoryIdx = idx - range.min;\n              var point = srcPoints[idx];\n\n              if (!point) {\n                point = srcPoints[idx] = {};\n              }\n\n              point.categoryIx = categoryIdx;\n\n              if (!point.item) {\n                var category = categoryAxis.categoryAt(idx, true);\n                point.category = category;\n                point.item = aggregator.aggregatePoints(point.items, category);\n              }\n\n              return point;\n            };\n\n            for (var idx = range.min; idx <= range.max; idx++) {\n              var point = categoryItem(idx);\n              data[point.categoryIx] = point.item;\n\n              if (point.items && point.items.length) {\n                dataItems[point.categoryIx] = point.item;\n              }\n            }\n\n            if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n              createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function (idx) {\n                return srcPoints[idx];\n              });\n            }\n\n            categoryAxis.options.dataItems = dataItems;\n            return result;\n          },\n          appendChart: function (chart, pane) {\n            var series = chart.options.series;\n            var categoryAxis = this.seriesCategoryAxis(series[0]);\n            var categories = categoryAxis.options.categories;\n            var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n            if (categoriesToAdd > 0) {\n              //consider setting an option to axis instead of adding fake categories\n              categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n\n              while (categoriesToAdd--) {\n                categories.push(\"\");\n              }\n            }\n\n            this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n          },\n          seriesPaneName: function (series) {\n            var options = this.options;\n            var axisName = series.axis;\n            var axisOptions = [].concat(options.valueAxis);\n            var axis = grep(axisOptions, function (a) {\n              return a.name === axisName;\n            })[0];\n            var panes = options.panes || [{}];\n            var defaultPaneName = (panes[0] || {}).name || \"default\";\n            var paneName = (axis || {}).pane || defaultPaneName;\n            return paneName;\n          },\n          seriesCategoryAxis: function (series) {\n            var axisName = series.categoryAxis;\n            var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n            if (!axis) {\n              throw new Error(\"Unable to locate category axis with name \" + axisName);\n            }\n\n            return axis;\n          },\n          stackableChartOptions: function (firstSeries, pane) {\n            var stack = firstSeries.stack;\n            var isStacked100 = stack && stack.type === \"100%\";\n            var clip = pane.options.clip;\n            return {\n              isStacked: stack,\n              isStacked100: isStacked100,\n              clip: clip\n            };\n          },\n          groupSeriesByCategoryAxis: function (series) {\n            var categoryAxes = [];\n            var unique = {};\n\n            for (var idx = 0; idx < series.length; idx++) {\n              var name = series[idx].categoryAxis || \"$$default$$\";\n\n              if (!unique.hasOwnProperty(name)) {\n                unique[name] = true;\n                categoryAxes.push(name);\n              }\n            }\n\n            var groups = [];\n\n            for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n              var axis = categoryAxes[axisIx];\n              var axisSeries = groupSeries(series, axis, axisIx);\n\n              if (axisSeries.length === 0) {\n                continue;\n              }\n\n              groups.push(axisSeries);\n            }\n\n            return groups;\n          },\n          createBarChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var barChart = new BarChart(this, $.extend({\n              series: series,\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              spacing: firstSeries.spacing\n            }, this.stackableChartOptions(firstSeries, pane)));\n            this.appendChart(barChart, pane);\n          },\n          createRangeBarChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var rangeColumnChart = new RangeBarChart(this, {\n              series: series,\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              spacing: firstSeries.spacing\n            });\n            this.appendChart(rangeColumnChart, pane);\n          },\n          createBulletChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var bulletChart = new BulletChart(this, {\n              series: series,\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              spacing: firstSeries.spacing,\n              clip: pane.options.clip\n            });\n            this.appendChart(bulletChart, pane);\n          },\n          createLineChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var lineChart = new LineChart(this, $.extend({\n              invertAxes: this.invertAxes,\n              series: series\n            }, this.stackableChartOptions(firstSeries, pane)));\n            this.appendChart(lineChart, pane);\n          },\n          createAreaChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var areaChart = new AreaChart(this, $.extend({\n              invertAxes: this.invertAxes,\n              series: series\n            }, this.stackableChartOptions(firstSeries, pane)));\n            this.appendChart(areaChart, pane);\n          },\n          createRangeAreaChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var rangeAreaChart = new RangeAreaChart(this, {\n              invertAxes: this.invertAxes,\n              series: series,\n              clip: pane.options.clip\n            });\n            this.appendChart(rangeAreaChart, pane);\n          },\n          createOHLCChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new OHLCChart(this, {\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              series: series,\n              spacing: firstSeries.spacing,\n              clip: pane.options.clip\n            });\n            this.appendChart(chart, pane);\n          },\n          createCandlestickChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new CandlestickChart(this, {\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              series: series,\n              spacing: firstSeries.spacing,\n              clip: pane.options.clip\n            });\n            this.appendChart(chart, pane);\n          },\n          createBoxPlotChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new BoxPlotChart(this, {\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              series: series,\n              spacing: firstSeries.spacing,\n              clip: pane.options.clip\n            });\n            this.appendChart(chart, pane);\n          },\n          createWaterfallChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var waterfallChart = new WaterfallChart(this, {\n              series: series,\n              invertAxes: this.invertAxes,\n              gap: firstSeries.gap,\n              spacing: firstSeries.spacing\n            });\n            this.appendChart(waterfallChart, pane);\n          },\n          axisRequiresRounding: function (categoryAxisName, categoryAxisIndex) {\n            var this$1 = this;\n            var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n            for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n              var currentSeries = this$1.series[seriesIx];\n\n              if (inArray(currentSeries.type, AREA_SERIES)) {\n                var line = currentSeries.line;\n\n                if (line && line.style === STEP) {\n                  centeredSeries.push(currentSeries);\n                }\n              }\n            }\n\n            for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {\n              var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || \"\";\n\n              if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {\n                return true;\n              }\n            }\n          },\n          aggregatedAxis: function (categoryAxisName, categoryAxisIndex) {\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var seriesAxis = series[seriesIx].categoryAxis || \"\";\n\n              if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {\n                return true;\n              }\n            }\n          },\n          createCategoryAxesLabels: function () {\n            var axes = this.axes;\n\n            for (var i = 0; i < axes.length; i++) {\n              if (axes[i] instanceof CategoryAxis) {\n                axes[i].createLabels();\n              }\n            }\n          },\n          createCategoryAxes: function (panes) {\n            var this$1 = this;\n            var invertAxes = this.invertAxes;\n            var definitions = [].concat(this.options.categoryAxis);\n            var axes = [];\n\n            for (var i = 0; i < definitions.length; i++) {\n              var axisOptions = definitions[i];\n              var axisPane = this$1.findPane(axisOptions.pane);\n\n              if (inArray(axisPane, panes)) {\n                var name = axisOptions.name;\n                var categories = axisOptions.categories;\n\n                if (categories === void 0) {\n                  categories = [];\n                }\n\n                axisOptions = deepExtend({\n                  vertical: invertAxes,\n                  reverse: !invertAxes && this$1.chartService.rtl,\n                  axisCrossingValue: invertAxes ? MAX_VALUE : 0\n                }, axisOptions);\n\n                if (!defined(axisOptions.justified)) {\n                  axisOptions.justified = this$1.isJustified();\n                }\n\n                if (this$1.axisRequiresRounding(name, i)) {\n                  axisOptions.justified = false;\n                }\n\n                var categoryAxis = void 0;\n\n                if (isDateAxis(axisOptions, categories[0])) {\n                  categoryAxis = new dataviz.DateCategoryAxis(axisOptions, this$1.chartService);\n                } else {\n                  categoryAxis = new CategoryAxis(axisOptions, this$1.chartService);\n                }\n\n                definitions[i].categories = categoryAxis.options.srcCategories;\n\n                if (name) {\n                  if (this$1.namedCategoryAxes[name]) {\n                    throw new Error(\"Category axis with name \" + name + \" is already defined\");\n                  }\n\n                  this$1.namedCategoryAxes[name] = categoryAxis;\n                }\n\n                categoryAxis.axisIndex = i;\n                axes.push(categoryAxis);\n                this$1.appendAxis(categoryAxis);\n              }\n            }\n\n            var primaryAxis = this.categoryAxis || axes[0];\n            this.categoryAxis = primaryAxis;\n\n            if (invertAxes) {\n              this.axisY = primaryAxis;\n            } else {\n              this.axisX = primaryAxis;\n            }\n          },\n          isJustified: function () {\n            var series = this.series;\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n\n              if (!inArray(currentSeries.type, AREA_SERIES)) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          createValueAxes: function (panes) {\n            var this$1 = this;\n            var tracker = this.valueAxisRangeTracker;\n            var defaultRange = tracker.query();\n            var definitions = [].concat(this.options.valueAxis);\n            var invertAxes = this.invertAxes;\n            var baseOptions = {\n              vertical: !invertAxes,\n              reverse: invertAxes && this.chartService.rtl\n            };\n            var axes = [];\n\n            if (this.stack100) {\n              baseOptions.roundToMajorUnit = false;\n              baseOptions.labels = {\n                format: \"P0\"\n              };\n            }\n\n            for (var i = 0; i < definitions.length; i++) {\n              var axisOptions = definitions[i];\n              var axisPane = this$1.findPane(axisOptions.pane);\n\n              if (inArray(axisPane, panes)) {\n                var name = axisOptions.name;\n                var defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? {\n                  min: 0.1,\n                  max: 1\n                } : {\n                  min: 0,\n                  max: 1\n                };\n                var range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n                if (i === 0 && range && defaultRange) {\n                  range.min = Math.min(range.min, defaultRange.min);\n                  range.max = Math.max(range.max, defaultRange.max);\n                }\n\n                var axisType = void 0;\n\n                if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n                  axisType = dataviz.LogarithmicAxis;\n                } else {\n                  axisType = dataviz.NumericAxis;\n                }\n\n                var valueAxis = new axisType(range.min, range.max, deepExtend({}, baseOptions, axisOptions), this$1.chartService);\n\n                if (name) {\n                  if (this$1.namedValueAxes[name]) {\n                    throw new Error(\"Value axis with name \" + name + \" is already defined\");\n                  }\n\n                  this$1.namedValueAxes[name] = valueAxis;\n                }\n\n                valueAxis.axisIndex = i;\n                axes.push(valueAxis);\n                this$1.appendAxis(valueAxis);\n              }\n            }\n\n            var primaryAxis = this.valueAxis || axes[0];\n            this.valueAxis = primaryAxis;\n\n            if (invertAxes) {\n              this.axisX = primaryAxis;\n            } else {\n              this.axisY = primaryAxis;\n            }\n          },\n          _dispatchEvent: function (chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n\n            var point = new Point(coords.x, coords.y);\n            var pane = this.pointPane(point);\n            var categories = [];\n            var values = [];\n\n            if (!pane) {\n              return;\n            }\n\n            var allAxes = pane.axes;\n\n            for (var i = 0; i < allAxes.length; i++) {\n              var axis = allAxes[i];\n\n              if (axis.getValue) {\n                appendIfNotNull(values, axis.getValue(point));\n              } else {\n                appendIfNotNull(categories, axis.getCategory(point));\n              }\n            }\n\n            if (categories.length === 0) {\n              appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n            }\n\n            if (categories.length > 0 && values.length > 0) {\n              chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                category: singleItemOrArray(categories),\n                value: singleItemOrArray(values)\n              });\n            }\n          },\n          pointPane: function (point) {\n            var panes = this.panes;\n\n            for (var i = 0; i < panes.length; i++) {\n              var currentPane = panes[i];\n\n              if (currentPane.contentBox.containsPoint(point)) {\n                return currentPane;\n              }\n            }\n          },\n          updateAxisOptions: function (axis, options) {\n            updateAxisOptions(this.options, axis, options);\n            updateAxisOptions(this.originalOptions, axis, options);\n          }\n        });\n\n        function updateAxisOptions(targetOptions, axis, options) {\n          var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n          deepExtend(axesOptions[axis.axisIndex], options);\n        }\n\n        function groupSeries(series, axis, axisIx) {\n          return grep(series, function (s) {\n            return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;\n          });\n        }\n\n        setDefaultOptions(CategoricalPlotArea, {\n          categoryAxis: {},\n          valueAxis: {}\n        });\n        deepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\n        var Highlight = Class.extend({\n          init: function () {\n            this._points = [];\n          },\n          destroy: function () {\n            this._points = [];\n          },\n          show: function (points, opacity) {\n            var this$1 = this;\n            var arrayPoints = [].concat(points);\n            this.hide();\n\n            for (var i = 0; i < arrayPoints.length; i++) {\n              var point = arrayPoints[i];\n\n              if (point && point.toggleHighlight && point.hasHighlight()) {\n                this$1.togglePointHighlight(point, true, opacity);\n\n                this$1._points.push(point);\n              }\n            }\n          },\n          togglePointHighlight: function (point, show, opacity) {\n            var toggleHandler = (point.options.highlight || {}).toggle;\n\n            if (toggleHandler) {\n              var eventArgs = {\n                category: point.category,\n                series: point.series,\n                dataItem: point.dataItem,\n                value: point.value,\n                stackValue: point.stackValue,\n                preventDefault: preventDefault,\n                visual: point.highlightVisual(),\n                show: show\n              };\n              toggleHandler(eventArgs);\n\n              if (!eventArgs._defaultPrevented) {\n                point.toggleHighlight(show, opacity);\n              }\n            } else {\n              point.toggleHighlight(show, opacity);\n            }\n          },\n          hide: function () {\n            var this$1 = this;\n            var points = this._points;\n\n            while (points.length) {\n              this$1.togglePointHighlight(points.pop(), false);\n            }\n          },\n          isHighlighted: function (element) {\n            var points = this._points;\n\n            for (var i = 0; i < points.length; i++) {\n              var point = points[i];\n\n              if (element === point) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n\n        function preventDefault() {\n          this._defaultPrevented = true;\n        }\n\n        function acceptKey(e, mouseKey) {\n          var key = (mouseKey || \"\").toLowerCase();\n          var event = e.event;\n          var accept = key === \"none\" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + \"Key\"];\n          return accept;\n        }\n\n        function toChartAxisRanges(axisRanges) {\n          var ranges = {};\n\n          for (var idx = 0; idx < axisRanges.length; idx++) {\n            var axisRange = axisRanges[idx];\n\n            if (axisRange.axis.options.name) {\n              ranges[axisRange.axis.options.name] = {\n                min: axisRange.range.min,\n                max: axisRange.range.max\n              };\n            }\n          }\n\n          return ranges;\n        }\n\n        var Pannable = Class.extend({\n          init: function (plotArea, options) {\n            this.plotArea = plotArea;\n            this.options = deepExtend({}, this.options, options);\n          },\n          start: function (e) {\n            this._active = acceptKey(e, this.options.key);\n            return this._active;\n          },\n          move: function (e) {\n            if (this._active) {\n              var axisRanges = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));\n\n              if (axisRanges.length) {\n                this.axisRanges = axisRanges;\n                return toChartAxisRanges(axisRanges);\n              }\n            }\n          },\n          end: function () {\n            var active = this._active;\n            this._active = false;\n            return active;\n          },\n          pan: function () {\n            var ref = this;\n            var plotArea = ref.plotArea;\n            var axisRanges = ref.axisRanges;\n\n            if (axisRanges.length) {\n              for (var idx = 0; idx < axisRanges.length; idx++) {\n                var range = axisRanges[idx];\n                plotArea.updateAxisOptions(range.axis, range.range);\n              }\n\n              plotArea.redraw(plotArea.panes);\n            }\n          },\n          destroy: function () {\n            delete this.plotArea;\n          },\n          _panAxes: function (e, position) {\n            var plotArea = this.plotArea;\n            var delta = -e[position].delta;\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var updatedAxes = [];\n\n            if (delta !== 0 && (lock || \"\").toLowerCase() !== position) {\n              var axes = plotArea.axes;\n\n              for (var idx = 0; idx < axes.length; idx++) {\n                var axis = axes[idx];\n\n                if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {\n                  var range = axis.pan(delta);\n\n                  if (range) {\n                    range.limitRange = true;\n                    updatedAxes.push({\n                      axis: axis,\n                      range: range\n                    });\n                  }\n                }\n              }\n            }\n\n            return updatedAxes;\n          }\n        });\n        Pannable.prototype.options = {\n          key: \"none\",\n          lock: \"none\"\n        };\n        var ZoomSelection = Class.extend({\n          init: function (chart, options) {\n            this.chart = chart;\n            this.options = deepExtend({}, this.options, options);\n            this.createElement();\n          },\n          createElement: function () {\n            var marquee = this._marquee = document.createElement(\"div\");\n            marquee.className = \"k-marquee\";\n            var marqueeColor = document.createElement(\"div\");\n            marqueeColor.className = \"k-marquee-color\";\n            marquee.appendChild(marqueeColor);\n          },\n          removeElement: function () {\n            if (this._marquee.parentNode) {\n              this._marquee.parentNode.removeChild(this._marquee);\n            }\n          },\n          setStyles: function (styles) {\n            elementStyles(this._marquee, styles);\n          },\n          start: function (e) {\n            if (acceptKey(e, this.options.key)) {\n              var chart = this.chart;\n\n              var point = chart._eventCoordinates(e);\n\n              var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);\n\n              var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;\n\n              if (zoomPane && clipBox) {\n                var offset = this._elementOffset();\n\n                clipBox.translate(offset.left, offset.top);\n                this._zoomPaneClipBox = clipBox;\n                document.body.appendChild(this._marquee);\n                this.setStyles({\n                  left: e.pageX + 1,\n                  top: e.pageY + 1,\n                  width: 0,\n                  height: 0\n                });\n                return true;\n              }\n            }\n\n            return false;\n          },\n          _elementOffset: function () {\n            var chartElement = this.chart.element;\n            var ref = elementStyles(chartElement, [\"paddingLeft\", \"paddingTop\"]);\n            var paddingLeft = ref.paddingLeft;\n            var paddingTop = ref.paddingTop;\n            var offset = dataviz.elementOffset(chartElement);\n            return {\n              left: paddingLeft + offset.left,\n              top: paddingTop + offset.top\n            };\n          },\n          move: function (e) {\n            var zoomPane = this._zoomPane;\n\n            if (zoomPane) {\n              this.setStyles(this._selectionPosition(e));\n            }\n          },\n          end: function (e) {\n            var zoomPane = this._zoomPane;\n\n            if (zoomPane) {\n              var elementOffset$$1 = this._elementOffset();\n\n              var selectionPosition = this._selectionPosition(e);\n\n              selectionPosition.left -= elementOffset$$1.left;\n              selectionPosition.top -= elementOffset$$1.top;\n              var start = {\n                x: selectionPosition.left,\n                y: selectionPosition.top\n              };\n              var end = {\n                x: selectionPosition.left + selectionPosition.width,\n                y: selectionPosition.top + selectionPosition.height\n              };\n\n              this._updateAxisRanges(start, end);\n\n              this.removeElement();\n              delete this._zoomPane;\n              return toChartAxisRanges(this.axisRanges);\n            }\n          },\n          zoom: function () {\n            var axisRanges = this.axisRanges;\n\n            if (axisRanges && axisRanges.length) {\n              var plotArea = this.chart._plotArea;\n\n              for (var idx = 0; idx < axisRanges.length; idx++) {\n                var axisRange = axisRanges[idx];\n                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n              }\n\n              plotArea.redraw(plotArea.panes);\n            }\n          },\n          destroy: function () {\n            this.removeElement();\n            delete this._marquee;\n            delete this.chart;\n          },\n          _updateAxisRanges: function (start, end) {\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var axisRanges = [];\n            var axes = this._zoomPane.axes;\n\n            for (var idx = 0; idx < axes.length; idx++) {\n              var axis = axes[idx];\n              var vertical = axis.options.vertical;\n\n              if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {\n                var range = axis.pointsRange(start, end);\n\n                if (range) {\n                  axisRanges.push({\n                    axis: axis,\n                    range: range\n                  });\n                }\n              }\n            }\n\n            this.axisRanges = axisRanges;\n          },\n          _selectionPosition: function (e) {\n            var clipBox = this._zoomPaneClipBox;\n            var startLocation = {\n              x: e.x.startLocation,\n              y: e.y.startLocation\n            };\n            var pageX = e.x.location;\n            var pageY = e.y.location;\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var left = Math.min(startLocation.x, pageX);\n            var top = Math.min(startLocation.y, pageY);\n            var width = Math.abs(startLocation.x - pageX);\n            var height = Math.abs(startLocation.y - pageY);\n\n            if (lock === X) {\n              left = clipBox.x1;\n              width = clipBox.width();\n            }\n\n            if (lock === Y) {\n              top = clipBox.y1;\n              height = clipBox.height();\n            }\n\n            if (pageX > clipBox.x2) {\n              width = clipBox.x2 - startLocation.x;\n            }\n\n            if (pageX < clipBox.x1) {\n              width = startLocation.x - clipBox.x1;\n            }\n\n            if (pageY > clipBox.y2) {\n              height = clipBox.y2 - startLocation.y;\n            }\n\n            if (pageY < clipBox.y1) {\n              height = startLocation.y - clipBox.y1;\n            }\n\n            return {\n              left: Math.max(left, clipBox.x1),\n              top: Math.max(top, clipBox.y1),\n              width: width,\n              height: height\n            };\n          }\n        });\n        ZoomSelection.prototype.options = {\n          key: \"shift\",\n          lock: \"none\"\n        };\n        var ref = drawing.util;\n        var limitValue$1 = ref.limitValue; // Limit the zoom rate between 1% and 90% per mousewheel event.\n        // At zoom rates close to 100% the axis range quickly becomes 0.\n\n        var MIN_RATE = 0.01;\n        var MAX_RATE = 0.9;\n        var DEFAULT_RATE = 0.3;\n        var MousewheelZoom = Class.extend({\n          init: function (chart, options) {\n            this.chart = chart;\n            this.options = deepExtend({\n              rate: DEFAULT_RATE\n            }, this.options, options);\n          },\n          updateRanges: function (delta, coords) {\n            var this$1 = this;\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var axisRanges = [];\n            var axes = this.chart._plotArea.axes;\n\n            for (var idx = 0; idx < axes.length; idx++) {\n              var axis = axes[idx];\n              var vertical = axis.options.vertical;\n\n              if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {\n                var rate = limitValue$1(this$1.options.rate, MIN_RATE, MAX_RATE);\n                var range = axis.zoomRange(-delta * rate, coords);\n\n                if (range) {\n                  axisRanges.push({\n                    axis: axis,\n                    range: range\n                  });\n                }\n              }\n            }\n\n            this.axisRanges = axisRanges;\n            return toChartAxisRanges(axisRanges);\n          },\n          zoom: function () {\n            var axisRanges = this.axisRanges;\n            var plotArea = this.chart._plotArea;\n\n            if (axisRanges && axisRanges.length && plotArea.updateAxisOptions) {\n              for (var idx = 0; idx < axisRanges.length; idx++) {\n                var axisRange = axisRanges[idx];\n                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n              }\n\n              plotArea.redraw(plotArea.panes);\n            }\n          },\n          destroy: function () {\n            delete this.chart;\n          }\n        });\n        var LegendLayout = ChartElement.extend({\n          init: function (options, chartService) {\n            ChartElement.fn.init.call(this, options);\n            this.chartService = chartService;\n          },\n          render: function () {\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var vertical = options.vertical;\n            this.visual = new drawing.Layout(null, {\n              spacing: vertical ? 0 : options.spacing,\n              lineSpacing: vertical ? options.spacing : 0,\n              orientation: vertical ? \"vertical\" : \"horizontal\",\n              reverse: options.rtl,\n              alignItems: vertical ? \"start\" : \"center\"\n            });\n\n            for (var idx = 0; idx < children.length; idx++) {\n              var legendItem = children[idx];\n              legendItem.reflow(new Box());\n              legendItem.renderVisual();\n            }\n          },\n          reflow: function (box) {\n            this.visual.rect(box.toRect());\n            this.visual.reflow();\n            var bbox = this.visual.clippedBBox();\n\n            if (bbox) {\n              this.box = dataviz.rectToBox(bbox);\n            } else {\n              this.box = new Box();\n            }\n          },\n          renderVisual: function () {\n            this.addVisual();\n          },\n          createVisual: function () {}\n        });\n        var LegendItem = BoxElement.extend({\n          init: function (options) {\n            BoxElement.fn.init.call(this, options);\n            this.createContainer();\n\n            if (!options.rtl) {\n              this.createMarker();\n              this.createLabel();\n            } else {\n              this.createLabel();\n              this.createMarker();\n            }\n          },\n          createContainer: function () {\n            this.container = new dataviz.FloatElement({\n              vertical: false,\n              wrap: false,\n              align: CENTER,\n              spacing: this.options.spacing\n            });\n            this.append(this.container);\n          },\n          createMarker: function () {\n            this.container.append(new ShapeElement(this.markerOptions()));\n          },\n          markerOptions: function () {\n            var options = this.options;\n            var markerColor = options.markerColor;\n            return deepExtend({}, options.markers, {\n              background: markerColor,\n              border: {\n                color: markerColor\n              }\n            });\n          },\n          createLabel: function () {\n            var options = this.options;\n            var labelOptions = deepExtend({}, options.labels);\n            this.container.append(new TextBox(options.text, labelOptions));\n          },\n          renderComplete: function () {\n            BoxElement.fn.renderComplete.call(this);\n            var cursor = this.options.cursor || {};\n            var eventSink = this._itemOverlay = Path.fromRect(this.container.box.toRect(), {\n              fill: {\n                color: WHITE,\n                opacity: 0\n              },\n              stroke: null,\n              cursor: cursor.style || cursor\n            });\n            this.appendVisual(eventSink);\n          },\n          click: function (widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === 'contextmenu') {\n              e.preventDefault();\n            }\n          },\n          over: function (widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {\n              widget._legendItemHover(args.seriesIndex, args.pointIndex);\n            } // Don't trigger point hover for legend items\n\n\n            return true;\n          },\n          out: function (widget, e) {\n            widget._unsetActivePoint();\n\n            widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));\n          },\n          eventArgs: function (e) {\n            var options = this.options;\n            return {\n              element: eventElement(e),\n              text: options.text,\n              series: options.series,\n              seriesIndex: options.series.index,\n              pointIndex: options.pointIndex\n            };\n          },\n          renderVisual: function () {\n            var this$1 = this;\n            var options = this.options;\n            var customVisual = options.visual;\n\n            if (customVisual) {\n              this.visual = customVisual({\n                active: options.active,\n                series: options.series,\n                sender: this.getSender(),\n                pointIndex: options.pointIndex,\n                options: {\n                  markers: this.markerOptions(),\n                  labels: options.labels\n                },\n                createVisual: function () {\n                  this$1.createVisual();\n                  this$1.renderChildren();\n                  this$1.renderComplete();\n                  var defaultVisual = this$1.visual;\n                  delete this$1.visual;\n                  return defaultVisual;\n                }\n              });\n              this.addVisual();\n            } else {\n              BoxElement.fn.renderVisual.call(this);\n            }\n          }\n        });\n        var HORIZONTAL = \"horizontal\";\n        var POINTER = \"pointer\";\n        var CUSTOM = \"custom\";\n        var Legend = ChartElement.extend({\n          init: function (options, chartService) {\n            if (chartService === void 0) {\n              chartService = {};\n            }\n\n            ChartElement.fn.init.call(this, options);\n            this.chartService = chartService;\n\n            if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {\n              this.options.position = RIGHT;\n            }\n\n            this.createContainers();\n            this.createLegendTitle(options.title);\n            this.createItems();\n          },\n          createContainers: function () {\n            var options = this.options;\n            var position = options.position;\n            var userAlign = options.align;\n            var align = position;\n            var vAlign = CENTER;\n\n            if (position === CUSTOM) {\n              align = LEFT;\n            } else if (inArray(position, [TOP, BOTTOM])) {\n              if (userAlign === \"start\") {\n                align = LEFT;\n              } else if (userAlign === \"end\") {\n                align = RIGHT;\n              } else {\n                align = CENTER;\n              }\n\n              vAlign = position;\n            } else if (userAlign) {\n              if (userAlign === \"start\") {\n                vAlign = TOP;\n              } else if (userAlign === \"end\") {\n                vAlign = BOTTOM;\n              }\n            }\n\n            this.container = new BoxElement({\n              margin: options.margin,\n              padding: options.padding,\n              background: options.background,\n              border: options.border,\n              vAlign: vAlign,\n              align: align,\n              zIndex: options.zIndex,\n              shrinkToFit: true\n            });\n\n            if (this.hasTitle()) {\n              this.itemsContainer = new BoxElement({\n                vAlign: vAlign,\n                align: align,\n                zIndex: options.zIndex,\n                shrinkToFit: true\n              });\n            } else {\n              this.itemsContainer = this.container;\n            }\n\n            this.append(this.container);\n          },\n          createItems: function () {\n            var chartService = this.getService();\n            var options = this.options;\n            var vertical = this.isVertical();\n            var innerElement = new LegendLayout({\n              vertical: vertical,\n              spacing: options.spacing,\n              rtl: chartService.rtl\n            }, chartService);\n            var items = options.items;\n\n            if (options.reverse) {\n              items = items.slice(0).reverse();\n            }\n\n            var count = items.length;\n\n            for (var i = 0; i < count; i++) {\n              var item = items[i];\n              innerElement.append(new LegendItem(deepExtend({}, {\n                markers: options.markers,\n                labels: options.labels,\n                rtl: chartService.rtl\n              }, options.item, item)));\n            }\n\n            innerElement.render();\n            this.itemsContainer.append(innerElement);\n          },\n          isVertical: function () {\n            var ref = this.options;\n            var orientation = ref.orientation;\n            var position = ref.position;\n            var vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));\n            return vertical;\n          },\n          hasItems: function () {\n            return this.container.children[0].children.length > 0;\n          },\n          reflow: function (targetBox) {\n            var options = this.options;\n            var legendBox = targetBox.clone();\n\n            if (!this.hasItems()) {\n              this.box = legendBox;\n              return;\n            }\n\n            if (options.position === CUSTOM) {\n              this.containerCustomReflow(legendBox);\n              this.box = legendBox;\n            } else {\n              this.containerReflow(legendBox);\n            }\n\n            if (this.hasTitle()) {\n              this.title.reflow(new Box(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));\n            }\n          },\n          containerReflow: function (targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var container = ref.container;\n            var position = options.position;\n            var width = options.width;\n            var height = options.height;\n            var pos = position === TOP || position === BOTTOM ? X : Y;\n            var vertical = this.isVertical();\n            var alignTarget = targetBox.clone();\n            var containerBox = targetBox.clone();\n\n            if (position === LEFT || position === RIGHT) {\n              containerBox.y1 = alignTarget.y1 = 0;\n            }\n\n            if (vertical && height) {\n              containerBox.y2 = containerBox.y1 + height;\n              containerBox.align(alignTarget, Y, container.options.vAlign);\n            } else if (!vertical && width) {\n              containerBox.x2 = containerBox.x1 + width;\n              containerBox.align(alignTarget, X, container.options.align);\n            }\n\n            container.reflow(containerBox);\n            containerBox = container.box;\n            var box = containerBox.clone();\n\n            if (options.offsetX || options.offsetY) {\n              containerBox.translate(options.offsetX, options.offsetY);\n              container.reflow(containerBox);\n            }\n\n            box[pos + 1] = targetBox[pos + 1];\n            box[pos + 2] = targetBox[pos + 2];\n            this.box = box;\n          },\n          containerCustomReflow: function (targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var container = ref.container;\n            var offsetX = options.offsetX;\n            var offsetY = options.offsetY;\n            var width = options.width;\n            var height = options.height;\n            var vertical = this.isVertical();\n            var containerBox = targetBox.clone();\n\n            if (vertical && height) {\n              containerBox.y2 = containerBox.y1 + height;\n            } else if (!vertical && width) {\n              containerBox.x2 = containerBox.x1 + width;\n            }\n\n            container.reflow(containerBox);\n            containerBox = container.box;\n            container.reflow(new Box(offsetX, offsetY, offsetX + containerBox.width(), offsetY + containerBox.height()));\n          },\n          renderVisual: function () {\n            if (this.hasItems()) {\n              ChartElement.fn.renderVisual.call(this);\n            }\n          },\n          createLegendTitle: function (title) {\n            var titleOptions = deepExtend({}, {\n              color: BLACK,\n              position: TOP,\n              align: CENTER\n            }, title);\n            var text = titleOptions.text;\n\n            if (!title || title.visible === false) {\n              return;\n            }\n\n            if (defined(titleOptions) && titleOptions.visible) {\n              var labelTemplate = getTemplate(titleOptions);\n\n              if (labelTemplate) {\n                text = labelTemplate({\n                  text: text\n                });\n              } else if (titleOptions.format) {\n                text = this.chartService.format.auto(titleOptions.format, text);\n              }\n            }\n\n            this.title = new TextBox(text, titleOptions);\n            this.createTitleLayout();\n            this.appendTitleLayoutContent();\n          },\n          createTitleLayout: function () {\n            this.layout = new dataviz.FloatElement({\n              vertical: true,\n              wrap: false\n            });\n            this.container.append(this.layout);\n          },\n          hasTitle: function () {\n            return Boolean(this.options.title && this.options.title.visible !== false);\n          },\n          appendTitleLayoutContent: function () {\n            var options = this.options;\n\n            if (options.title.position === BOTTOM) {\n              this.layout.append(this.itemsContainer);\n              this.layout.append(this.title);\n            } else {\n              this.layout.append(this.title);\n              this.layout.append(this.itemsContainer);\n            }\n          }\n        });\n        setDefaultOptions(Legend, {\n          position: RIGHT,\n          items: [],\n          offsetX: 0,\n          offsetY: 0,\n          margin: getSpacing(5),\n          padding: getSpacing(5),\n          border: {\n            color: BLACK,\n            width: 0\n          },\n          item: {\n            cursor: POINTER,\n            spacing: 6\n          },\n          spacing: 6,\n          background: \"\",\n          zIndex: 1,\n          markers: {\n            border: {\n              width: 0\n            },\n            width: 15,\n            height: 3,\n            type: \"rect\",\n            align: LEFT,\n            vAlign: CENTER\n          }\n        });\n        var PlotAreaFactory = Class.extend({\n          init: function () {\n            this._registry = [];\n          },\n          register: function (type, seriesTypes) {\n            this._registry.push({\n              type: type,\n              seriesTypes: seriesTypes\n            });\n          },\n          create: function (srcSeries, options, chartService) {\n            var registry = this._registry;\n            var match = registry[0];\n            var series;\n\n            for (var idx = 0; idx < registry.length; idx++) {\n              var entry = registry[idx];\n              series = filterSeriesByType(srcSeries, entry.seriesTypes);\n\n              if (series.length > 0) {\n                match = entry;\n                break;\n              }\n            }\n\n            return new match.type(series, options, chartService);\n          }\n        });\n        PlotAreaFactory.current = new PlotAreaFactory();\n        var ZOOM_ACCELERATION = 3;\n        var SELECTOR_HEIGHT_ADJUST = 0.1;\n\n        function createDiv(className) {\n          var element = document.createElement(\"div\");\n\n          if (className) {\n            element.className = className;\n          }\n\n          return element;\n        }\n\n        function closestHandle(element) {\n          var current = element;\n\n          while (current && !hasClasses(current, \"k-handle\")) {\n            current = current.parentNode;\n          }\n\n          return current;\n        }\n\n        var Selection = Class.extend({\n          init: function (chart, categoryAxis, options, observer) {\n            var chartElement = chart.element;\n            this.options = deepExtend({}, this.options, options);\n            this.chart = chart;\n            this.observer = observer;\n            this.chartElement = chartElement;\n            this.categoryAxis = categoryAxis;\n            this._dateAxis = this.categoryAxis instanceof dataviz.DateCategoryAxis;\n            this.initOptions();\n            this.visible = this.options.visible && chartElement.offsetHeight;\n\n            if (this.visible) {\n              this.createElements();\n              this.set(this._index(this.options.from), this._index(this.options.to));\n              this.bindEvents();\n            }\n          },\n          onPane: function (pane) {\n            return this.categoryAxis.pane === pane;\n          },\n          createElements: function () {\n            var options = this.options;\n            var wrapper = this.wrapper = createDiv(\"k-selector\");\n            elementStyles(wrapper, {\n              top: options.offset.top,\n              left: options.offset.left,\n              width: options.width,\n              height: options.height,\n              direction: 'ltr'\n            });\n            var selection = this.selection = createDiv(\"k-selection\");\n            this.leftMask = createDiv(\"k-mask\");\n            this.rightMask = createDiv(\"k-mask\");\n            wrapper.appendChild(this.leftMask);\n            wrapper.appendChild(this.rightMask);\n            wrapper.appendChild(selection);\n            selection.appendChild(createDiv(\"k-selection-bg\"));\n            var leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle\");\n            var rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle\");\n            leftHandle.appendChild(createDiv());\n            rightHandle.appendChild(createDiv());\n            selection.appendChild(leftHandle);\n            selection.appendChild(rightHandle);\n            this.chartElement.appendChild(wrapper);\n            var selectionStyles = elementStyles(selection, [\"borderLeftWidth\", \"borderRightWidth\", \"height\"]);\n            var leftHandleHeight = elementStyles(leftHandle, \"height\").height;\n            var rightHandleHeight = elementStyles(rightHandle, \"height\").height;\n            options.selection = {\n              border: {\n                left: selectionStyles.borderLeftWidth,\n                right: selectionStyles.borderRightWidth\n              }\n            };\n            elementStyles(leftHandle, {\n              top: (selectionStyles.height - leftHandleHeight) / 2\n            });\n            elementStyles(rightHandle, {\n              top: (selectionStyles.height - rightHandleHeight) / 2\n            });\n            wrapper.style.cssText = wrapper.style.cssText;\n          },\n          bindEvents: function () {\n            if (this.options.mousewheel !== false) {\n              this._mousewheelHandler = this._mousewheel.bind(this);\n              var obj;\n              bindEvents(this.wrapper, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));\n            }\n\n            this._domEvents = services.DomEventsBuilder.create(this.wrapper, {\n              stopPropagation: true,\n              // applicable for the jQuery UserEvents\n              start: this._start.bind(this),\n              move: this._move.bind(this),\n              end: this._end.bind(this),\n              tap: this._tap.bind(this),\n              press: this._press.bind(this),\n              gesturestart: this._gesturestart.bind(this),\n              gesturechange: this._gesturechange.bind(this),\n              gestureend: this._gestureend.bind(this)\n            });\n          },\n          initOptions: function () {\n            var ref = this;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var box = categoryAxis.pane.chartsBox();\n            var intlService = this.chart.chartService.intl;\n\n            if (this._dateAxis) {\n              deepExtend(options, {\n                min: parseDate(intlService, options.min),\n                max: parseDate(intlService, options.max),\n                from: parseDate(intlService, options.from),\n                to: parseDate(intlService, options.to)\n              });\n            }\n\n            var ref$1 = elementStyles(this.chartElement, [\"paddingLeft\", \"paddingTop\"]);\n            var paddingLeft = ref$1.paddingLeft;\n            var paddingTop = ref$1.paddingTop;\n            this.options = deepExtend({}, {\n              width: box.width(),\n              height: box.height() + SELECTOR_HEIGHT_ADJUST,\n              //workaround for sub-pixel hover on the paths in chrome\n              padding: {\n                left: paddingLeft,\n                top: paddingTop\n              },\n              offset: {\n                left: box.x1 + paddingLeft,\n                top: box.y1 + paddingTop\n              },\n              from: options.min,\n              to: options.max\n            }, options);\n          },\n          destroy: function () {\n            if (this._domEvents) {\n              this._domEvents.destroy();\n\n              delete this._domEvents;\n            }\n\n            clearTimeout(this._mwTimeout);\n            this._state = null;\n\n            if (this.wrapper) {\n              if (this._mousewheelHandler) {\n                var obj;\n                unbindEvents(this.wrapper, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));\n                this._mousewheelHandler = null;\n              }\n\n              this.chartElement.removeChild(this.wrapper);\n              this.wrapper = null;\n            }\n          },\n          _rangeEventArgs: function (range) {\n            return {\n              axis: this.categoryAxis.options,\n              from: this._value(range.from),\n              to: this._value(range.to)\n            };\n          },\n          _start: function (e) {\n            var options = this.options;\n            var target = eventElement(e);\n\n            if (this._state || !target) {\n              return;\n            }\n\n            this.chart._unsetActivePoint();\n\n            this._state = {\n              moveTarget: closestHandle(target) || target,\n              startLocation: e.x ? e.x.location : 0,\n              range: {\n                from: this._index(options.from),\n                to: this._index(options.to)\n              }\n            };\n\n            var args = this._rangeEventArgs({\n              from: this._index(options.from),\n              to: this._index(options.to)\n            });\n\n            if (this.trigger(SELECT_START, args)) {\n              this._state = null;\n            }\n          },\n          _press: function (e) {\n            var handle;\n\n            if (this._state) {\n              handle = this._state.moveTarget;\n            } else {\n              handle = closestHandle(eventElement(e));\n            }\n\n            if (handle) {\n              dataviz.addClass(handle, \"k-handle-active\");\n            }\n          },\n          _move: function (e) {\n            if (!this._state) {\n              return;\n            }\n\n            var ref = this;\n            var state = ref._state;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var range = state.range;\n            var target = state.moveTarget;\n            var reverse = categoryAxis.options.reverse;\n\n            var from = this._index(options.from);\n\n            var to = this._index(options.to);\n\n            var min = this._index(options.min);\n\n            var max = this._index(options.max);\n\n            var delta = state.startLocation - e.x.location;\n            var oldRange = {\n              from: range.from,\n              to: range.to\n            };\n            var span = range.to - range.from;\n            var scale = elementStyles(this.wrapper, \"width\").width / (categoryAxis.categoriesCount() - 1);\n            var offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n\n            if (!target) {\n              return;\n            }\n\n            var leftHandle = hasClasses(target, \"k-left-handle\");\n            var rightHandle = hasClasses(target, \"k-right-handle\");\n\n            if (hasClasses(target, \"k-selection k-selection-bg\")) {\n              range.from = Math.min(Math.max(min, from - offset), max - span);\n              range.to = Math.min(range.from + span, max);\n            } else if (leftHandle && !reverse || rightHandle && reverse) {\n              range.from = Math.min(Math.max(min, from - offset), max - 1);\n              range.to = Math.max(range.from + 1, range.to);\n            } else if (leftHandle && reverse || rightHandle && !reverse) {\n              range.to = Math.min(Math.max(min + 1, to - offset), max);\n              range.from = Math.min(range.to - 1, range.from);\n            }\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n              this.move(range.from, range.to);\n              this.trigger(SELECT, this._rangeEventArgs(range));\n            }\n          },\n          _end: function () {\n            if (this._state) {\n              var moveTarget = this._state.moveTarget;\n\n              if (moveTarget) {\n                dataviz.removeClass(moveTarget, \"k-handle-active\");\n              }\n\n              var range = this._state.range;\n              this.set(range.from, range.to);\n              this.trigger(SELECT_END, this._rangeEventArgs(range));\n              delete this._state;\n            }\n          },\n          _tap: function (e) {\n            var ref = this;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n\n            var coords = this.chart._eventCoordinates(e);\n\n            var categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\n\n            var from = this._index(options.from);\n\n            var to = this._index(options.to);\n\n            var min = this._index(options.min);\n\n            var max = this._index(options.max);\n\n            var span = to - from;\n            var mid = from + span / 2;\n            var range = {};\n            var rightClick = e.event.which === 3;\n            var offset = Math.round(mid - categoryIx);\n\n            if (this._state || rightClick) {\n              return;\n            }\n\n            this.chart._unsetActivePoint();\n\n            if (!categoryAxis.options.justified) {\n              offset--;\n            }\n\n            range.from = Math.min(Math.max(min, from - offset), max - span);\n            range.to = Math.min(range.from + span, max);\n\n            this._start(e);\n\n            if (this._state) {\n              this._state.range = range;\n              this.trigger(SELECT, this._rangeEventArgs(range));\n\n              this._end();\n            }\n          },\n          _mousewheel: function (e) {\n            var this$1 = this;\n            var delta = dataviz.mousewheelDelta(e);\n\n            this._start({\n              target: this.selection\n            });\n\n            if (this._state) {\n              var range = this._state.range;\n              e.preventDefault();\n              e.stopPropagation();\n\n              if (Math.abs(delta) > 1) {\n                delta *= ZOOM_ACCELERATION;\n              }\n\n              if (this.options.mousewheel.reverse) {\n                delta *= -1;\n              }\n\n              if (this.expand(delta)) {\n                this.trigger(SELECT, {\n                  axis: this.categoryAxis.options,\n                  delta: delta,\n                  originalEvent: e,\n                  from: this._value(range.from),\n                  to: this._value(range.to)\n                });\n              }\n\n              if (this._mwTimeout) {\n                clearTimeout(this._mwTimeout);\n              }\n\n              this._mwTimeout = setTimeout(function () {\n                this$1._end();\n              }, MOUSEWHEEL_DELAY);\n            }\n          },\n          _gesturestart: function (e) {\n            var options = this.options;\n            this._state = {\n              range: {\n                from: this._index(options.from),\n                to: this._index(options.to)\n              }\n            };\n\n            var args = this._rangeEventArgs(this._state.range);\n\n            if (this.trigger(SELECT_START, args)) {\n              this._state = null;\n            } else {\n              e.preventDefault();\n            }\n          },\n          _gestureend: function () {\n            if (this._state) {\n              this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n              delete this._state;\n            }\n          },\n          _gesturechange: function (e) {\n            var ref = this;\n            var chart = ref.chart;\n            var state = ref._state;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var range = state.range;\n\n            var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n\n            var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n\n            var left = Math.min(p0, p1);\n            var right = Math.max(p0, p1);\n            e.preventDefault();\n            range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\n            range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\n            this.move(range.from, range.to);\n            this.trigger(SELECT, this._rangeEventArgs(range));\n          },\n          _index: function (value) {\n            var index = value;\n\n            if (value instanceof Date) {\n              index = this.categoryAxis.categoryIndex(value);\n            }\n\n            return index;\n          },\n          _value: function (index) {\n            var value = index;\n\n            if (this._dateAxis) {\n              value = this.categoryAxis.categoryAt(index);\n\n              if (value > this.options.max) {\n                value = this.options.max;\n              }\n            }\n\n            return value;\n          },\n          _slot: function (value) {\n            var categoryAxis = this.categoryAxis;\n\n            var index = this._index(value);\n\n            return categoryAxis.getSlot(index, index, true);\n          },\n          move: function (from, to) {\n            var options = this.options;\n            var reverse = this.categoryAxis.options.reverse;\n            var offset = options.offset;\n            var padding = options.padding;\n            var border = options.selection.border;\n            var left = reverse ? to : from;\n            var right = reverse ? from : to;\n            var edge = 'x' + (reverse ? 2 : 1);\n\n            var box = this._slot(left);\n\n            var leftMaskWidth = round(box[edge] - offset.left + padding.left);\n            elementStyles(this.leftMask, {\n              width: leftMaskWidth\n            });\n            elementStyles(this.selection, {\n              left: leftMaskWidth\n            });\n            box = this._slot(right);\n            var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n            elementStyles(this.rightMask, {\n              width: rightMaskWidth\n            });\n            var distance = options.width - rightMaskWidth;\n\n            if (distance !== options.width) {\n              distance += border.right;\n            }\n\n            elementStyles(this.rightMask, {\n              left: distance\n            });\n            elementStyles(this.selection, {\n              width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n            });\n          },\n          set: function (from, to) {\n            var options = this.options;\n\n            var min = this._index(options.min);\n\n            var max = this._index(options.max);\n\n            var fromValue = limitValue(this._index(from), min, max);\n            var toValue = limitValue(this._index(to), fromValue + 1, max);\n\n            if (options.visible) {\n              this.move(fromValue, toValue);\n            }\n\n            options.from = this._value(fromValue);\n            options.to = this._value(toValue);\n          },\n          expand: function (delta) {\n            var options = this.options;\n\n            var min = this._index(options.min);\n\n            var max = this._index(options.max);\n\n            var zDir = options.mousewheel.zoom;\n\n            var from = this._index(options.from);\n\n            var to = this._index(options.to);\n\n            var range = {\n              from: from,\n              to: to\n            };\n            var oldRange = deepExtend({}, range);\n\n            if (this._state) {\n              range = this._state.range;\n            }\n\n            if (zDir !== RIGHT) {\n              range.from = limitValue(limitValue(from - delta, 0, to - 1), min, max);\n            }\n\n            if (zDir !== LEFT) {\n              range.to = limitValue(limitValue(to + delta, range.from + 1, max), min, max);\n            }\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n              this.set(range.from, range.to);\n              return true;\n            }\n          },\n          zoom: function (delta, coords) {\n            var options = this.options;\n\n            var min = this._index(options.min);\n\n            var max = this._index(options.max);\n\n            var from = this._index(options.from);\n\n            var to = this._index(options.to);\n\n            var range = {\n              from: from,\n              to: to\n            };\n            var oldRange = deepExtend({}, range);\n            var ref = this.categoryAxis.options;\n            var reverse = ref.reverse;\n            var origin = X + (reverse ? '2' : '1');\n            var lineBox = this.categoryAxis.lineBox();\n            var relative = Math.abs(lineBox[origin] - coords[X]);\n            var size = lineBox.width();\n            var position = round(relative / size, 2);\n            var minDelta = round(position * delta);\n            var maxDelta = round((1 - position) * delta);\n\n            if (this._state) {\n              range = this._state.range;\n            }\n\n            range.from = limitValue(limitValue(from - minDelta, 0, to - 1), min, max);\n            range.to = limitValue(limitValue(to + maxDelta, range.from + 1, max), min, max);\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n              this.set(range.from, range.to);\n              return true;\n            }\n          },\n          trigger: function (name, args) {\n            return (this.observer || this.chart).trigger(name, args);\n          }\n        });\n        setDefaultOptions(Selection, {\n          visible: true,\n          mousewheel: {\n            zoom: \"both\"\n          },\n          min: MIN_VALUE,\n          max: MAX_VALUE\n        });\n        var Tooltip = BaseTooltip.extend({\n          show: function (point) {\n            if (!point || !point.tooltipAnchor || this._current && this._current === point) {\n              return;\n            }\n\n            var options = deepExtend({}, this.options, point.options.tooltip);\n            var anchor = point.tooltipAnchor();\n\n            if (anchor) {\n              this._current = point;\n              BaseTooltip.fn.show.call(this, {\n                point: point,\n                anchor: anchor\n              }, options, point);\n            } else {\n              this.hide();\n            }\n          },\n          hide: function () {\n            delete this._current;\n            BaseTooltip.fn.hide.call(this);\n          }\n        });\n        var SharedTooltip = BaseTooltip.extend({\n          init: function (plotArea, options) {\n            BaseTooltip.fn.init.call(this, plotArea.chartService, options);\n            this.plotArea = plotArea;\n            this.formatService = plotArea.chartService.format;\n          },\n          showAt: function (points, coords) {\n            var tooltipPoints = grep(points, function (point) {\n              var tooltip = point.series.tooltip;\n              var excluded = tooltip && tooltip.visible === false;\n              return !excluded;\n            });\n\n            if (tooltipPoints.length > 0) {\n              var point = tooltipPoints[0];\n              var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);\n              var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);\n              this.show({\n                anchor: anchor,\n                shared: true,\n                points: points,\n                category: point.category,\n                categoryText: this.formatService.auto(this.options.categoryFormat, point.category),\n                series: this.plotArea.series\n              }, this.options);\n            }\n          },\n          _slotAnchor: function (point, slot) {\n            var axis = this.plotArea.categoryAxis;\n            var align = {\n              horizontal: \"left\",\n              vertical: \"center\"\n            };\n\n            if (!axis.options.vertical) {\n              point.x = slot.center().x;\n            }\n\n            return {\n              point: point,\n              align: align\n            };\n          },\n          _defaultAnchor: function (point, slot) {\n            var box = point.owner.pane.chartsBox();\n            var vertical = this.plotArea.categoryAxis.options.vertical;\n            var center = box.center();\n            var slotCenter = slot.center();\n            var align = {\n              horizontal: \"center\",\n              vertical: \"center\"\n            };\n            var centerPoint;\n\n            if (vertical) {\n              centerPoint = new Point(center.x, slotCenter.y);\n            } else {\n              centerPoint = new Point(slotCenter.x, center.y);\n            }\n\n            return {\n              point: centerPoint,\n              align: align\n            };\n          }\n        });\n        setDefaultOptions(SharedTooltip, {\n          categoryFormat: '{0:d}'\n        });\n        var BarChartAnimation = Animation.extend({\n          setup: function () {\n            var ref = this;\n            var element = ref.element;\n            var options = ref.options;\n            var bbox = element.bbox();\n\n            if (bbox) {\n              this.origin = options.origin;\n              var axis = options.vertical ? Y : X;\n              var fromScale = this.fromScale = new GeometryPoint(1, 1);\n              fromScale[axis] = START_SCALE;\n              element.transform(transform().scale(fromScale.x, fromScale.y));\n            } else {\n              this.abort();\n            }\n          },\n          step: function (pos) {\n            var scaleX = dataviz.interpolateValue(this.fromScale.x, 1, pos);\n            var scaleY = dataviz.interpolateValue(this.fromScale.y, 1, pos);\n            this.element.transform(transform().scale(scaleX, scaleY, this.origin));\n          },\n          abort: function () {\n            Animation.fn.abort.call(this);\n            this.element.transform(null);\n          }\n        });\n        setDefaultOptions(BarChartAnimation, {\n          duration: INITIAL_ANIMATION_DURATION\n        });\n        AnimationFactory.current.register(BAR, BarChartAnimation);\n        var BubbleAnimation = Animation.extend({\n          setup: function () {\n            var center = this.center = this.element.bbox().center();\n            this.element.transform(transform().scale(START_SCALE, START_SCALE, center));\n          },\n          step: function (pos) {\n            this.element.transform(transform().scale(pos, pos, this.center));\n          }\n        });\n        setDefaultOptions(BubbleAnimation, {\n          easing: \"easeOutElastic\"\n        });\n        AnimationFactory.current.register(BUBBLE, BubbleAnimation);\n        var FadeInAnimation = Animation.extend({\n          setup: function () {\n            this.fadeTo = this.element.opacity();\n            this.element.opacity(0);\n          },\n          step: function (pos) {\n            this.element.opacity(pos * this.fadeTo);\n          }\n        });\n        setDefaultOptions(FadeInAnimation, {\n          duration: 200,\n          easing: \"linear\"\n        });\n        AnimationFactory.current.register(FADEIN, FadeInAnimation);\n        var PieAnimation = Animation.extend({\n          setup: function () {\n            this.element.transform(transform().scale(START_SCALE, START_SCALE, this.options.center));\n          },\n          step: function (pos) {\n            this.element.transform(transform().scale(pos, pos, this.options.center));\n          }\n        });\n        setDefaultOptions(PieAnimation, {\n          easing: \"easeOutElastic\",\n          duration: INITIAL_ANIMATION_DURATION\n        });\n        AnimationFactory.current.register(PIE, PieAnimation);\n        var ScatterLineChart = ScatterChart.extend({\n          render: function () {\n            ScatterChart.fn.render.call(this);\n            this.renderSegments();\n          },\n          createSegment: function (linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === SMOOTH) {\n              pointType = SplineSegment;\n            } else {\n              pointType = LineSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx);\n          },\n          animationPoints: function () {\n            var points = ScatterChart.fn.animationPoints.call(this);\n            return points.concat(this._segments);\n          },\n          createMissingValue: function (value, missingValues) {\n            if (missingValues === ZERO) {\n              var missingValue = {\n                x: value.x,\n                y: value.y\n              };\n\n              if (!hasValue(missingValue.x)) {\n                missingValue.x = 0;\n              }\n\n              if (!hasValue(missingValue.y)) {\n                missingValue.y = 0;\n              }\n\n              return missingValue;\n            }\n          }\n        });\n        deepExtend(ScatterLineChart.prototype, LineChartMixin);\n        var XYPlotArea = PlotAreaBase.extend({\n          initFields: function () {\n            this.namedXAxes = {};\n            this.namedYAxes = {};\n            this.xAxisRangeTracker = new AxisGroupRangeTracker();\n            this.yAxisRangeTracker = new AxisGroupRangeTracker();\n          },\n          render: function (panes) {\n            var this$1 = this;\n\n            if (panes === void 0) {\n              panes = this.panes;\n            }\n\n            var seriesByPane = this.groupSeriesByPane();\n\n            for (var i = 0; i < panes.length; i++) {\n              var pane = panes[i];\n              var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n              this$1.addToLegend(paneSeries);\n              var filteredSeries = this$1.filterVisibleSeries(paneSeries);\n\n              if (!filteredSeries) {\n                continue;\n              }\n\n              this$1.createScatterChart(filterSeriesByType(filteredSeries, SCATTER), pane);\n              this$1.createScatterLineChart(filterSeriesByType(filteredSeries, SCATTER_LINE), pane);\n              this$1.createBubbleChart(filterSeriesByType(filteredSeries, BUBBLE), pane);\n            }\n\n            this.createAxes(panes);\n          },\n          appendChart: function (chart, pane) {\n            this.xAxisRangeTracker.update(chart.xAxisRanges);\n            this.yAxisRangeTracker.update(chart.yAxisRanges);\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n          },\n          removeAxis: function (axis) {\n            var axisName = axis.options.name;\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis.options.vertical) {\n              this.yAxisRangeTracker.reset(axisName);\n              delete this.namedYAxes[axisName];\n            } else {\n              this.xAxisRangeTracker.reset(axisName);\n              delete this.namedXAxes[axisName];\n            }\n\n            if (axis === this.axisX) {\n              delete this.axisX;\n            }\n\n            if (axis === this.axisY) {\n              delete this.axisY;\n            }\n          },\n          seriesPaneName: function (series) {\n            var options = this.options;\n            var xAxisName = series.xAxis;\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxis = grep(xAxisOptions, function (a) {\n              return a.name === xAxisName;\n            })[0];\n            var yAxisName = series.yAxis;\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxis = grep(yAxisOptions, function (a) {\n              return a.name === yAxisName;\n            })[0];\n            var panes = options.panes || [{}];\n            var defaultPaneName = panes[0].name || \"default\";\n            var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n            return paneName;\n          },\n          createScatterChart: function (series, pane) {\n            if (series.length > 0) {\n              this.appendChart(new ScatterChart(this, {\n                series: series,\n                clip: pane.options.clip\n              }), pane);\n            }\n          },\n          createScatterLineChart: function (series, pane) {\n            if (series.length > 0) {\n              this.appendChart(new ScatterLineChart(this, {\n                series: series,\n                clip: pane.options.clip\n              }), pane);\n            }\n          },\n          createBubbleChart: function (series, pane) {\n            if (series.length > 0) {\n              this.appendChart(new BubbleChart(this, {\n                series: series,\n                clip: pane.options.clip\n              }), pane);\n            }\n          },\n          createXYAxis: function (options, vertical, axisIndex) {\n            var axisName = options.name;\n            var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n            var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n            var axisOptions = deepExtend({\n              reverse: !vertical && this.chartService.rtl\n            }, options, {\n              vertical: vertical\n            });\n            var isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n            var defaultRange = tracker.query();\n            var defaultAxisRange = isLog ? {\n              min: 0.1,\n              max: 1\n            } : {\n              min: 0,\n              max: 1\n            };\n            var range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n            var typeSamples = [axisOptions.min, axisOptions.max];\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n\n              if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n                var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n                typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n                break;\n              }\n            }\n\n            if (axisIndex === 0 && defaultRange) {\n              range.min = Math.min(range.min, defaultRange.min);\n              range.max = Math.max(range.max, defaultRange.max);\n            }\n\n            var inferredDate;\n\n            for (var i = 0; i < typeSamples.length; i++) {\n              if (typeSamples[i] instanceof Date) {\n                inferredDate = true;\n                break;\n              }\n            }\n\n            var axisType;\n\n            if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n              axisType = dataviz.DateValueAxis;\n            } else if (isLog) {\n              axisType = dataviz.LogarithmicAxis;\n            } else {\n              axisType = dataviz.NumericAxis;\n            }\n\n            var axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n            axis.axisIndex = axisIndex;\n\n            if (axisName) {\n              if (namedAxes[axisName]) {\n                throw new Error((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\");\n              }\n\n              namedAxes[axisName] = axis;\n            }\n\n            this.appendAxis(axis);\n            return axis;\n          },\n          createAxes: function (panes) {\n            var this$1 = this;\n            var options = this.options;\n            var xAxesOptions = [].concat(options.xAxis);\n            var xAxes = [];\n            var yAxesOptions = [].concat(options.yAxis);\n            var yAxes = [];\n\n            for (var idx = 0; idx < xAxesOptions.length; idx++) {\n              var axisPane = this$1.findPane(xAxesOptions[idx].pane);\n\n              if (inArray(axisPane, panes)) {\n                xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\n              }\n            }\n\n            for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n              var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\n\n              if (inArray(axisPane$1, panes)) {\n                yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n              }\n            }\n\n            this.axisX = this.axisX || xAxes[0];\n            this.axisY = this.axisY || yAxes[0];\n          },\n          _dispatchEvent: function (chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n\n            var point = new Point(coords.x, coords.y);\n            var allAxes = this.axes;\n            var length = allAxes.length;\n            var xValues = [];\n            var yValues = [];\n\n            for (var i = 0; i < length; i++) {\n              var axis = allAxes[i];\n              var values = axis.options.vertical ? yValues : xValues;\n              var currentValue = axis.getValue(point);\n\n              if (currentValue !== null) {\n                values.push(currentValue);\n              }\n            }\n\n            if (xValues.length > 0 && yValues.length > 0) {\n              chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                x: singleItemOrArray(xValues),\n                y: singleItemOrArray(yValues)\n              });\n            }\n          },\n          updateAxisOptions: function (axis, options) {\n            var vertical = axis.options.vertical;\n            var axes = this.groupAxes(this.panes);\n            var index = (vertical ? axes.y : axes.x).indexOf(axis);\n            updateAxisOptions$1(this.options, index, vertical, options);\n            updateAxisOptions$1(this.originalOptions, index, vertical, options);\n          }\n        });\n\n        function updateAxisOptions$1(targetOptions, axisIndex, vertical, options) {\n          var axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n          deepExtend(axisOptions, options);\n        }\n\n        setDefaultOptions(XYPlotArea, {\n          xAxis: {},\n          yAxis: {}\n        });\n        deepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\n        var PieSegment = ChartElement.extend({\n          init: function (value, sector, options) {\n            ChartElement.fn.init.call(this, options);\n            this.value = value;\n            this.sector = sector;\n          },\n          render: function () {\n            var labels = this.options.labels;\n            var chartService = this.owner.chartService;\n            var labelText = this.value;\n\n            if (this._rendered || this.visible === false) {\n              return;\n            }\n\n            this._rendered = true;\n            var labelTemplate = getTemplate(labels);\n            var pointData = this.pointData();\n\n            if (labelTemplate) {\n              labelText = labelTemplate(pointData);\n            } else if (labels.format) {\n              labelText = chartService.format.auto(labels.format, labelText);\n            }\n\n            if (labels.visible && (labelText || labelText === 0)) {\n              if (labels.position === CENTER || labels.position === INSIDE_END) {\n                if (!labels.color) {\n                  labels.color = dataviz.autoTextColor(this.options.color);\n                }\n\n                if (!labels.background) {\n                  labels.background = this.options.color;\n                }\n              } else {\n                var themeLabels = chartService.theme.seriesDefaults.labels;\n                labels.color = labels.color || themeLabels.color;\n                labels.background = labels.background || themeLabels.background;\n              }\n\n              this.label = new TextBox(labelText, deepExtend({}, labels, {\n                align: CENTER,\n                vAlign: \"\",\n                animation: {\n                  type: FADEIN,\n                  delay: this.animationDelay\n                }\n              }), pointData);\n              this.append(this.label);\n            }\n          },\n          reflow: function (targetBox) {\n            this.render();\n            this.box = targetBox;\n            this.reflowLabel();\n          },\n          reflowLabel: function () {\n            var ref = this;\n            var labelsOptions = ref.options.labels;\n            var label = ref.label;\n            var sector = this.sector.clone();\n            var labelsDistance = labelsOptions.distance;\n            var angle = sector.middle();\n\n            if (label) {\n              var labelHeight = label.box.height();\n              var labelWidth = label.box.width();\n              var lp;\n\n              if (labelsOptions.position === CENTER) {\n                sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n                lp = sector.point(angle);\n                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n              } else if (labelsOptions.position === INSIDE_END) {\n                sector.radius = sector.radius - labelHeight / 2;\n                lp = sector.point(angle);\n                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n              } else {\n                var x1;\n                lp = sector.clone().expand(labelsDistance).point(angle);\n\n                if (lp.x >= sector.center.x) {\n                  x1 = lp.x + labelWidth;\n                  label.orientation = RIGHT;\n                } else {\n                  x1 = lp.x - labelWidth;\n                  label.orientation = LEFT;\n                }\n\n                label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\n              }\n            }\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var ref = this;\n            var sector = ref.sector;\n            var options = ref.options;\n            ChartElement.fn.createVisual.call(this);\n\n            if (this.value) {\n              if (options.visual) {\n                var startAngle = (sector.startAngle + 180) % 360;\n                var visual = options.visual({\n                  category: this.category,\n                  dataItem: this.dataItem,\n                  value: this.value,\n                  series: this.series,\n                  percentage: this.percentage,\n                  center: new GeometryPoint(sector.center.x, sector.center.y),\n                  radius: sector.radius,\n                  innerRadius: sector.innerRadius,\n                  startAngle: startAngle,\n                  endAngle: startAngle + sector.angle,\n                  options: options,\n                  sender: this.getSender(),\n                  createVisual: function () {\n                    var group = new Group();\n                    this$1.createSegmentVisual(group);\n                    return group;\n                  }\n                });\n\n                if (visual) {\n                  this.visual.append(visual);\n                }\n              } else {\n                this.createSegmentVisual(this.visual);\n              }\n            }\n          },\n          createSegmentVisual: function (group) {\n            var ref = this;\n            var sector = ref.sector;\n            var options = ref.options;\n            var borderOptions = options.border || {};\n            var border = borderOptions.width > 0 ? {\n              stroke: {\n                color: borderOptions.color,\n                width: borderOptions.width,\n                opacity: borderOptions.opacity,\n                dashType: borderOptions.dashType\n              }\n            } : {};\n            var color = options.color;\n            var fill = {\n              color: color,\n              opacity: options.opacity\n            };\n            var visual = this.createSegment(sector, deepExtend({\n              fill: fill,\n              stroke: {\n                opacity: options.opacity\n              },\n              zIndex: options.zIndex\n            }, border));\n            group.append(visual);\n\n            if (hasGradientOverlay(options)) {\n              group.append(this.createGradientOverlay(visual, {\n                baseColor: color,\n                fallbackFill: fill\n              }, deepExtend({\n                center: [sector.center.x, sector.center.y],\n                innerRadius: sector.innerRadius,\n                radius: sector.radius,\n                userSpace: true\n              }, options.overlay)));\n            }\n          },\n          createSegment: function (sector, options) {\n            if (options.singleSegment) {\n              return new drawing.Circle(new geometry.Circle(new GeometryPoint(sector.center.x, sector.center.y), sector.radius), options);\n            }\n\n            return dataviz.ShapeBuilder.current.createRing(sector, options);\n          },\n          createAnimation: function () {\n            var ref = this;\n            var options = ref.options;\n            var center = ref.sector.center;\n            deepExtend(options, {\n              animation: {\n                center: [center.x, center.y],\n                delay: this.animationDelay\n              }\n            });\n            ChartElement.fn.createAnimation.call(this);\n          },\n          createHighlight: function (options) {\n            var highlight = this.options.highlight || {};\n            var border = highlight.border || {};\n            return this.createSegment(this.sector, deepExtend({}, options, {\n              fill: {\n                color: highlight.color,\n                opacity: highlight.opacity\n              },\n              stroke: {\n                opacity: border.opacity,\n                width: border.width,\n                color: border.color\n              }\n            }));\n          },\n          highlightVisual: function () {\n            return this.visual.children[0];\n          },\n          highlightVisualArgs: function () {\n            var sector = this.sector;\n            return {\n              options: this.options,\n              radius: sector.radius,\n              innerRadius: sector.innerRadius,\n              center: new GeometryPoint(sector.center.x, sector.center.y),\n              startAngle: sector.startAngle,\n              endAngle: sector.angle + sector.startAngle,\n              visual: this.visual\n            };\n          },\n          tooltipAnchor: function () {\n            var sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n            var midAndle = sector.middle();\n            var midPoint = sector.point(midAndle);\n            return {\n              point: midPoint,\n              align: tooltipAlignment(midAndle + 180)\n            };\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          pointData: function () {\n            return {\n              dataItem: this.dataItem,\n              category: this.category,\n              value: this.value,\n              series: this.series,\n              percentage: this.percentage\n            };\n          }\n        });\n        var RAD_30 = round(dataviz.rad(30), DEFAULT_PRECISION);\n        var RAD_60 = round(dataviz.rad(60), DEFAULT_PRECISION);\n\n        function tooltipAlignment(angle) {\n          var radians = dataviz.rad(angle);\n          var sine = round(Math.sin(radians), DEFAULT_PRECISION);\n          var cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n          var horizontal;\n\n          if (Math.abs(sine) > RAD_60) {\n            horizontal = CENTER;\n          } else if (cosine < 0) {\n            horizontal = RIGHT;\n          } else {\n            horizontal = LEFT;\n          }\n\n          var vertical;\n\n          if (Math.abs(sine) < RAD_30) {\n            vertical = CENTER;\n          } else if (sine < 0) {\n            vertical = BOTTOM;\n          } else {\n            vertical = TOP;\n          }\n\n          return {\n            horizontal: horizontal,\n            vertical: vertical\n          };\n        }\n\n        setDefaultOptions(PieSegment, {\n          color: WHITE,\n          overlay: {\n            gradient: \"roundedBevel\"\n          },\n          border: {\n            width: 0.5\n          },\n          labels: {\n            visible: false,\n            distance: 35,\n            font: datavizConstants.DEFAULT_FONT,\n            margin: getSpacing(0.5),\n            align: CIRCLE,\n            zIndex: 1,\n            position: OUTSIDE_END\n          },\n          animation: {\n            type: PIE\n          },\n          highlight: {\n            visible: true,\n            border: {\n              width: 1\n            }\n          },\n          visible: true\n        });\n        deepExtend(PieSegment.prototype, PointEventsMixin);\n        var PieChartMixin = {\n          createLegendItem: function (value, point, options) {\n            var legendOptions = this.options.legend || {};\n            var labelsOptions = legendOptions.labels || {};\n            var inactiveItems = legendOptions.inactiveItems || {};\n            var inactiveItemsLabels = inactiveItems.labels || {};\n\n            if (options && options.visibleInLegend !== false) {\n              var pointVisible = options.visible !== false;\n              var labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);\n              var text = options.category;\n\n              if (labelTemplate) {\n                text = labelTemplate({\n                  text: text,\n                  series: options.series,\n                  dataItem: options.dataItem,\n                  percentage: options.percentage,\n                  value: value\n                });\n              }\n\n              var itemLabelOptions, markerColor;\n\n              if (pointVisible) {\n                itemLabelOptions = {};\n                markerColor = point.color;\n              } else {\n                itemLabelOptions = {\n                  color: inactiveItemsLabels.color,\n                  font: inactiveItemsLabels.font\n                };\n                markerColor = (inactiveItems.markers || {}).color;\n              }\n\n              if (hasValue(text) && text !== \"\") {\n                this.legendItems.push({\n                  active: pointVisible,\n                  pointIndex: options.index,\n                  text: text,\n                  series: options.series,\n                  markerColor: markerColor,\n                  labels: itemLabelOptions\n                });\n              }\n            }\n          }\n        };\n        var PIE_SECTOR_ANIM_DELAY = 70;\n        var PieChart = ChartElement.extend({\n          init: function (plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this.points = [];\n            this.legendItems = [];\n            this.render();\n          },\n          render: function () {\n            this.traverseDataPoints(this.addValue.bind(this));\n          },\n          traverseDataPoints: function (callback) {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var seriesColors = ref.plotArea.options.seriesColors;\n\n            if (seriesColors === void 0) {\n              seriesColors = [];\n            }\n\n            var colorsCount = seriesColors.length;\n            var series = options.series;\n            var seriesCount = series.length;\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var data = currentSeries.data;\n              var ref$1 = bindSegments(currentSeries);\n              var total = ref$1.total;\n              var points = ref$1.points;\n              var count = ref$1.count;\n              var anglePerValue = 360 / total;\n              var constantAngle = void 0;\n\n              if (!isFinite(anglePerValue)) {\n                constantAngle = 360 / count;\n              }\n\n              var currentAngle = void 0;\n\n              if (defined(currentSeries.startAngle)) {\n                currentAngle = currentSeries.startAngle;\n              } else {\n                currentAngle = options.startAngle;\n              }\n\n              if (seriesIx !== seriesCount - 1) {\n                if (currentSeries.labels.position === OUTSIDE_END) {\n                  currentSeries.labels.position = CENTER;\n                }\n              }\n\n              for (var i = 0; i < points.length; i++) {\n                var pointData = points[i];\n\n                if (!pointData) {\n                  continue;\n                }\n\n                var fields = pointData.fields;\n                var value = pointData.value;\n                var visible = pointData.visible;\n                var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n                var explode = data.length !== 1 && Boolean(fields.explode);\n\n                if (!isFunction(currentSeries.color)) {\n                  currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                }\n\n                callback(pointData.valueFields.value, new dataviz.Ring(null, 0, 0, currentAngle, angle), {\n                  owner: this$1,\n                  category: defined(fields.category) ? fields.category : \"\",\n                  index: i,\n                  series: currentSeries,\n                  seriesIx: seriesIx,\n                  dataItem: data[i],\n                  percentage: total !== 0 ? value / total : 0,\n                  explode: explode,\n                  visibleInLegend: fields.visibleInLegend,\n                  visible: visible,\n                  zIndex: seriesCount - seriesIx,\n                  animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n                });\n\n                if (visible !== false) {\n                  currentAngle += angle;\n                }\n              }\n            }\n          },\n          evalSegmentOptions: function (options, value, fields) {\n            var series = fields.series;\n            evalOptions(options, {\n              value: value,\n              series: series,\n              dataItem: fields.dataItem,\n              category: fields.category,\n              percentage: fields.percentage\n            }, {\n              defaults: series._defaults,\n              excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n            });\n          },\n          addValue: function (value, sector, fields) {\n            var segmentOptions = deepExtend({}, fields.series, {\n              index: fields.index\n            });\n            this.evalSegmentOptions(segmentOptions, value, fields);\n            this.createLegendItem(value, segmentOptions, fields);\n\n            if (fields.visible === false) {\n              return;\n            }\n\n            var segment = new PieSegment(value, sector, segmentOptions);\n            $.extend(segment, fields);\n            this.append(segment);\n            this.points.push(segment);\n          },\n          reflow: function (targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var points = ref.points;\n            var seriesConfigs = ref.seriesConfigs;\n\n            if (seriesConfigs === void 0) {\n              seriesConfigs = [];\n            }\n\n            var count = points.length;\n            var box = targetBox.clone();\n            var space = 5;\n            var minWidth = Math.min(box.width(), box.height());\n            var halfMinWidth = minWidth / 2;\n            var defaultPadding = minWidth - minWidth * 0.85;\n            var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n            var newBoxCenter = newBox.center();\n            var boxCenter = box.center();\n            var seriesCount = options.series.length;\n            var leftSideLabels = [];\n            var rightSideLabels = [];\n            var padding = valueOrDefault(options.padding, defaultPadding);\n            this.targetBox = targetBox;\n            padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n            newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n            var radius = halfMinWidth - padding;\n            var center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n\n            for (var i = 0; i < count; i++) {\n              var segment = points[i];\n              var sector = segment.sector;\n              var seriesIndex = segment.seriesIx;\n              sector.radius = radius;\n              sector.center = center;\n\n              if (seriesConfigs.length) {\n                var seriesConfig = seriesConfigs[seriesIndex];\n                sector.innerRadius = seriesConfig.innerRadius;\n                sector.radius = seriesConfig.radius;\n              }\n\n              if (seriesIndex === seriesCount - 1 && segment.explode) {\n                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n              }\n\n              segment.reflow(newBox);\n              var label = segment.label;\n\n              if (label) {\n                if (label.options.position === OUTSIDE_END) {\n                  if (seriesIndex === seriesCount - 1) {\n                    if (label.orientation === RIGHT) {\n                      rightSideLabels.push(label);\n                    } else {\n                      leftSideLabels.push(label);\n                    }\n                  }\n                }\n              }\n            }\n\n            if (leftSideLabels.length > 0) {\n              leftSideLabels.sort(this.labelComparator(true));\n              this.leftLabelsReflow(leftSideLabels);\n            }\n\n            if (rightSideLabels.length > 0) {\n              rightSideLabels.sort(this.labelComparator(false));\n              this.rightLabelsReflow(rightSideLabels);\n            }\n\n            this.box = newBox;\n          },\n          leftLabelsReflow: function (labels) {\n            var distances = this.distanceBetweenLabels(labels);\n            this.distributeLabels(distances, labels);\n          },\n          rightLabelsReflow: function (labels) {\n            var distances = this.distanceBetweenLabels(labels);\n            this.distributeLabels(distances, labels);\n          },\n          distanceBetweenLabels: function (labels) {\n            var segment = last(this.points);\n            var sector = segment.sector;\n            var count = labels.length - 1;\n            var lr = sector.radius + segment.options.labels.distance;\n            var distances = [];\n            var firstBox = labels[0].box;\n            var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n            distances.push(distance);\n\n            for (var i = 0; i < count; i++) {\n              var secondBox = labels[i + 1].box;\n              firstBox = labels[i].box;\n              distance = round(secondBox.y1 - firstBox.y2);\n              distances.push(distance);\n            }\n\n            distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n            distances.push(distance);\n            return distances;\n          },\n          distributeLabels: function (distances, labels) {\n            var this$1 = this;\n            var count = distances.length;\n            var left, right, remaining;\n\n            for (var i = 0; i < count; i++) {\n              remaining = -distances[i];\n              left = right = i;\n\n              while (remaining > 0 && (left >= 0 || right < count)) {\n                remaining = this$1._takeDistance(distances, i, --left, remaining);\n                remaining = this$1._takeDistance(distances, i, ++right, remaining);\n              }\n            }\n\n            this.reflowLabels(distances, labels);\n          },\n          _takeDistance: function (distances, anchor, position, amount) {\n            var result = amount;\n\n            if (distances[position] > 0) {\n              var available = Math.min(distances[position], result);\n              result -= available;\n              distances[position] -= available;\n              distances[anchor] += available;\n            }\n\n            return result;\n          },\n          reflowLabels: function (distances, labels) {\n            var this$1 = this;\n            var segment = last(this.points);\n            var sector = segment.sector;\n            var labelOptions = segment.options.labels;\n            var labelsCount = labels.length;\n            var labelDistance = labelOptions.distance;\n            var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n            var boxX;\n            distances[0] += 2;\n\n            for (var i = 0; i < labelsCount; i++) {\n              var label = labels[i];\n              var box = label.box;\n              boxY += distances[i];\n              boxX = this$1.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n\n              if (label.orientation === RIGHT) {\n                if (labelOptions.align !== CIRCLE) {\n                  boxX = sector.radius + sector.center.x + labelDistance;\n                }\n\n                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n              } else {\n                if (labelOptions.align !== CIRCLE) {\n                  boxX = sector.center.x - sector.radius - labelDistance;\n                }\n\n                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n              }\n\n              boxY += box.height();\n            }\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var ref = this;\n            var connectors = ref.options.connectors;\n            var points = ref.points;\n            var count = points.length;\n            var space = 4;\n            ChartElement.fn.createVisual.call(this);\n            this._connectorLines = [];\n\n            for (var i = 0; i < count; i++) {\n              var segment = points[i];\n              var sector = segment.sector;\n              var label = segment.label;\n              var angle = sector.middle();\n              var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n              if (label) {\n                var connectorLine = new Path({\n                  stroke: {\n                    color: connectorsColor,\n                    width: connectors.width\n                  },\n                  animation: {\n                    type: FADEIN,\n                    delay: segment.animationDelay\n                  }\n                });\n\n                if (label.options.position === OUTSIDE_END) {\n                  var box = label.box;\n                  var centerPoint = sector.center;\n                  var start = sector.point(angle);\n                  var middle = new Point(box.x1, box.center().y);\n                  var sr = void 0,\n                      end = void 0,\n                      crossing = void 0;\n                  start = sector.clone().expand(connectors.padding).point(angle);\n                  connectorLine.moveTo(start.x, start.y); // TODO: Extract into a method to remove duplication\n\n                  if (label.orientation === RIGHT) {\n                    end = new Point(box.x1 - connectors.padding, box.center().y);\n                    crossing = intersection(centerPoint, start, middle, end);\n                    middle = new Point(end.x - space, end.y);\n                    crossing = crossing || middle;\n                    crossing.x = Math.min(crossing.x, middle.x);\n\n                    if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n                      sr = sector.center.x + sector.radius + space;\n\n                      if (segment.options.labels.align !== COLUMN) {\n                        if (sr < middle.x) {\n                          connectorLine.lineTo(sr, start.y);\n                        } else {\n                          connectorLine.lineTo(start.x + space * 2, start.y);\n                        }\n                      } else {\n                        connectorLine.lineTo(sr, start.y);\n                      }\n\n                      connectorLine.lineTo(middle.x, end.y);\n                    } else {\n                      crossing.y = end.y;\n                      connectorLine.lineTo(crossing.x, crossing.y);\n                    }\n                  } else {\n                    end = new Point(box.x2 + connectors.padding, box.center().y);\n                    crossing = intersection(centerPoint, start, middle, end);\n                    middle = new Point(end.x + space, end.y);\n                    crossing = crossing || middle;\n                    crossing.x = Math.max(crossing.x, middle.x);\n\n                    if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n                      sr = sector.center.x - sector.radius - space;\n\n                      if (segment.options.labels.align !== COLUMN) {\n                        if (sr > middle.x) {\n                          connectorLine.lineTo(sr, start.y);\n                        } else {\n                          connectorLine.lineTo(start.x - space * 2, start.y);\n                        }\n                      } else {\n                        connectorLine.lineTo(sr, start.y);\n                      }\n\n                      connectorLine.lineTo(middle.x, end.y);\n                    } else {\n                      crossing.y = end.y;\n                      connectorLine.lineTo(crossing.x, crossing.y);\n                    }\n                  }\n\n                  connectorLine.lineTo(end.x, end.y);\n\n                  this$1._connectorLines.push(connectorLine);\n\n                  this$1.visual.append(connectorLine);\n                }\n              }\n            }\n          },\n          renderVisual: function () {\n            ChartElement.fn.renderVisual.call(this);\n\n            if (dataviz.find(this.options.series, function (options) {\n              return options.autoFit;\n            })) {\n              var targetBox = this.targetBox;\n              var pieCenter = this.box.center();\n              var bbox = this.visual.bbox();\n\n              if (!bbox) {\n                return;\n              }\n\n              var bboxBottom = bbox.bottomRight();\n              var scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));\n\n              if (scale < 1) {\n                this.visual.transform(transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));\n              }\n            }\n          },\n          labelComparator: function (reverse) {\n            var reverseValue = reverse ? -1 : 1;\n            return function (a, b) {\n              var first = (a.parent.sector.middle() + 270) % 360;\n              var second = (b.parent.sector.middle() + 270) % 360;\n              return (first - second) * reverseValue;\n            };\n          },\n          hAlignLabel: function (originalX, sector, y1, y2, direction) {\n            var radius = sector.radius;\n            var sector_center = sector.center;\n            var cx = sector_center.x;\n            var cy = sector_center.y;\n            var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n            if (t > radius) {\n              return originalX;\n            }\n\n            return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n          },\n          pointInCircle: function (point, center, radius) {\n            return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n          },\n          formatPointValue: function (point, format) {\n            return this.chartService.format.auto(format, point.value);\n          },\n          animationDelay: function (categoryIndex) {\n            return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n          },\n          stackRoot: function () {\n            return this;\n          }\n        });\n\n        function intersection(a1, a2, b1, b2) {\n          var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n          var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n          var result;\n\n          if (ub !== 0) {\n            var ua = uat / ub;\n            result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n          }\n\n          return result;\n        }\n\n        setDefaultOptions(PieChart, {\n          startAngle: 90,\n          connectors: {\n            width: 2,\n            color: \"#939393\",\n            padding: 8\n          },\n          inactiveItems: {\n            markers: {},\n            labels: {}\n          }\n        });\n        deepExtend(PieChart.prototype, PieChartMixin);\n        PieChart.prototype.isStackRoot = true;\n        var PiePlotArea = PlotAreaBase.extend({\n          render: function () {\n            this.createPieChart(this.series);\n          },\n          createPieChart: function (series) {\n            var firstSeries = series[0];\n            var pieChart = new PieChart(this, {\n              series: series,\n              padding: firstSeries.padding,\n              startAngle: firstSeries.startAngle,\n              connectors: firstSeries.connectors,\n              legend: this.options.legend\n            });\n            this.appendChart(pieChart);\n          },\n          appendChart: function (chart, pane) {\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n            append(this.options.legend.items, chart.legendItems);\n          }\n        });\n        var DonutSegment = PieSegment.extend({\n          reflowLabel: function () {\n            var ref = this;\n            var labelsOptions = ref.options.labels;\n            var label = ref.label;\n            var sector = this.sector.clone();\n            var angle = sector.middle();\n\n            if (label) {\n              var labelHeight = label.box.height();\n\n              if (labelsOptions.position === CENTER) {\n                sector.radius -= (sector.radius - sector.innerRadius) / 2;\n                var lp = sector.point(angle);\n                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n              } else {\n                PieSegment.fn.reflowLabel.call(this);\n              }\n            }\n          },\n          createSegment: function (sector, options) {\n            return dataviz.ShapeBuilder.current.createRing(sector, options);\n          }\n        });\n        setDefaultOptions(DonutSegment, {\n          overlay: {\n            gradient: \"roundedGlass\"\n          },\n          labels: {\n            position: CENTER\n          },\n          animation: {\n            type: PIE\n          }\n        });\n        deepExtend(DonutSegment.prototype, PointEventsMixin);\n        var DONUT_SECTOR_ANIM_DELAY = 50;\n        var DonutChart = PieChart.extend({\n          addValue: function (value, sector, fields) {\n            var segmentOptions = deepExtend({}, fields.series, {\n              index: fields.index\n            });\n            this.evalSegmentOptions(segmentOptions, value, fields);\n            this.createLegendItem(value, segmentOptions, fields);\n\n            if (!value || fields.visible === false) {\n              return;\n            }\n\n            var segment = new DonutSegment(value, sector, segmentOptions);\n            $.extend(segment, fields);\n            this.append(segment);\n            this.points.push(segment);\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var options = this.options;\n            var box = targetBox.clone();\n            var space = 5;\n            var minWidth = Math.min(box.width(), box.height());\n            var halfMinWidth = minWidth / 2;\n            var defaultPadding = minWidth - minWidth * 0.85;\n            var series = options.series;\n            var seriesCount = series.length;\n            var padding = valueOrDefault(options.padding, defaultPadding);\n            padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n            var totalSize = halfMinWidth - padding;\n            var seriesWithoutSize = 0;\n            var holeSize;\n\n            for (var i = 0; i < seriesCount; i++) {\n              var currentSeries = series[i];\n\n              if (i === 0) {\n                if (defined(currentSeries.holeSize)) {\n                  holeSize = currentSeries.holeSize;\n                  totalSize -= currentSeries.holeSize;\n                }\n              }\n\n              if (defined(currentSeries.size)) {\n                totalSize -= currentSeries.size;\n              } else {\n                seriesWithoutSize++;\n              }\n\n              if (defined(currentSeries.margin) && i !== seriesCount - 1) {\n                totalSize -= currentSeries.margin;\n              }\n            }\n\n            if (!defined(holeSize)) {\n              var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);\n              holeSize = currentSize * 0.75;\n              totalSize -= holeSize;\n            }\n\n            var innerRadius = holeSize;\n            var margin = 0;\n            var size, radius;\n            this.seriesConfigs = [];\n\n            for (var i$1 = 0; i$1 < seriesCount; i$1++) {\n              var currentSeries$1 = series[i$1];\n              size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);\n              innerRadius += margin;\n              radius = innerRadius + size;\n              this$1.seriesConfigs.push({\n                innerRadius: innerRadius,\n                radius: radius\n              });\n              margin = currentSeries$1.margin || 0;\n              innerRadius = radius;\n            }\n\n            PieChart.fn.reflow.call(this, targetBox);\n          },\n          animationDelay: function (categoryIndex, seriesIndex, seriesCount) {\n            return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);\n          }\n        });\n        setDefaultOptions(DonutChart, {\n          startAngle: 90,\n          connectors: {\n            width: 2,\n            color: \"#939393\",\n            padding: 8\n          }\n        });\n        var DonutPlotArea = PiePlotArea.extend({\n          render: function () {\n            this.createDonutChart(this.series);\n          },\n          createDonutChart: function (series) {\n            var firstSeries = series[0];\n            var donutChart = new DonutChart(this, {\n              series: series,\n              padding: firstSeries.padding,\n              connectors: firstSeries.connectors,\n              legend: this.options.legend\n            });\n            this.appendChart(donutChart);\n          }\n        });\n        var DEFAULT_PADDING = 0.15;\n        var PolarPlotAreaBase = PlotAreaBase.extend({\n          initFields: function () {\n            this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n          },\n          render: function () {\n            this.addToLegend(this.series);\n            this.createPolarAxis();\n            this.createCharts();\n            this.createValueAxis();\n          },\n          alignAxes: function () {\n            var axis = this.valueAxis;\n            var range = axis.range();\n            var crossingValue = axis.options.reverse ? range.max : range.min;\n            var slot = axis.getSlot(crossingValue);\n            var center = this.polarAxis.getSlot(0).center;\n            var axisBox = axis.box.translate(center.x - slot.x1, center.y - slot.y1);\n            axis.reflow(axisBox);\n          },\n          createValueAxis: function () {\n            var tracker = this.valueAxisRangeTracker;\n            var defaultRange = tracker.query();\n            var axisOptions = this.valueAxisOptions({\n              roundToMajorUnit: false,\n              zIndex: -1\n            });\n            var axisType, axisDefaultRange;\n\n            if (axisOptions.type === LOGARITHMIC) {\n              axisType = dataviz.RadarLogarithmicAxis;\n              axisDefaultRange = {\n                min: 0.1,\n                max: 1\n              };\n            } else {\n              axisType = dataviz.RadarNumericAxis;\n              axisDefaultRange = {\n                min: 0,\n                max: 1\n              };\n            }\n\n            var range = tracker.query(name) || defaultRange || axisDefaultRange;\n\n            if (range && defaultRange) {\n              range.min = Math.min(range.min, defaultRange.min);\n              range.max = Math.max(range.max, defaultRange.max);\n            }\n\n            var valueAxis = new axisType(range.min, range.max, axisOptions, this.chartService);\n            this.valueAxis = valueAxis;\n            this.appendAxis(valueAxis);\n          },\n          reflowAxes: function () {\n            var ref = this;\n            var options = ref.options.plotArea;\n            var valueAxis = ref.valueAxis;\n            var polarAxis = ref.polarAxis;\n            var box = ref.box;\n            var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;\n            var padding = getSpacing(options.padding || {}, defaultPadding);\n            var paddingBox = box.clone().unpad(padding);\n            var axisBox = paddingBox.clone();\n            axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());\n            axisBox.align(paddingBox, Y, CENTER);\n            var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);\n            polarAxis.reflow(axisBox);\n            valueAxis.reflow(valueAxisBox);\n            var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();\n            valueAxis.reflow(valueAxis.box.unpad({\n              top: heightDiff\n            }));\n            this.axisBox = axisBox;\n            this.alignAxes(axisBox);\n          },\n          backgroundBox: function () {\n            return this.box;\n          },\n          detachLabels: function () {}\n        });\n        var PolarScatterChart = ScatterChart.extend({\n          pointSlot: function (slotX, slotY) {\n            var valueRadius = slotX.center.y - slotY.y1;\n            var slot = Point.onCircle(slotX.center, slotX.startAngle, valueRadius);\n            return new Box(slot.x, slot.y, slot.x, slot.y);\n          }\n        });\n        setDefaultOptions(PolarScatterChart, {\n          clip: false\n        });\n        var PolarLineChart = ScatterLineChart.extend({});\n        PolarLineChart.prototype.pointSlot = PolarScatterChart.prototype.pointSlot;\n        setDefaultOptions(PolarLineChart, {\n          clip: false\n        });\n        var SplinePolarAreaSegment = SplineAreaSegment.extend({\n          fillToAxes: function (fillPath) {\n            var center = this._polarAxisCenter();\n\n            fillPath.lineTo(center.x, center.y);\n          },\n          _polarAxisCenter: function () {\n            var polarAxis = this.parent.plotArea.polarAxis;\n            var center = polarAxis.box.center();\n            return center;\n          },\n          strokeSegments: function () {\n            var segments = this._strokeSegments;\n\n            if (!segments) {\n              var center = this._polarAxisCenter();\n\n              var curveProcessor = new CurveProcessor(false);\n              var linePoints = this.points();\n              linePoints.push(center);\n              segments = this._strokeSegments = curveProcessor.process(linePoints);\n              segments.pop();\n            }\n\n            return segments;\n          }\n        });\n        var PolarAreaSegment = AreaSegment.extend({\n          fillToAxes: function (fillPath) {\n            var polarAxis = this.parent.plotArea.polarAxis;\n            var center = polarAxis.box.center();\n            var centerSegment = new geometry.Segment([center.x, center.y]);\n            fillPath.segments.unshift(centerSegment);\n            fillPath.segments.push(centerSegment);\n          }\n        });\n        var PolarAreaChart = PolarLineChart.extend({\n          createSegment: function (linePoints, currentSeries, seriesIx) {\n            var style = (currentSeries.line || {}).style;\n            var segment;\n\n            if (style === SMOOTH) {\n              segment = new SplinePolarAreaSegment(linePoints, currentSeries, seriesIx);\n            } else {\n              segment = new PolarAreaSegment(linePoints, currentSeries, seriesIx);\n            }\n\n            return segment;\n          },\n          createMissingValue: function (value, missingValues) {\n            var missingValue;\n\n            if (hasValue(value.x) && missingValues !== INTERPOLATE) {\n              missingValue = {\n                x: value.x,\n                y: value.y\n              };\n\n              if (missingValues === ZERO) {\n                missingValue.y = 0;\n              }\n            }\n\n            return missingValue;\n          },\n          seriesMissingValues: function (series) {\n            return series.missingValues || ZERO;\n          },\n          _hasMissingValuesGap: function () {\n            var this$1 = this;\n            var series = this.options.series;\n\n            for (var idx = 0; idx < series.length; idx++) {\n              if (this$1.seriesMissingValues(series[idx]) === GAP) {\n                return true;\n              }\n            }\n          },\n          sortPoints: function (points) {\n            var this$1 = this;\n            points.sort(xComparer);\n\n            if (this._hasMissingValuesGap()) {\n              for (var idx = 0; idx < points.length; idx++) {\n                var point = points[idx];\n\n                if (point) {\n                  var value = point.value;\n\n                  if (!hasValue(value.y) && this$1.seriesMissingValues(point.series) === GAP) {\n                    delete points[idx];\n                  }\n                }\n              }\n            }\n\n            return points;\n          }\n        });\n\n        function xComparer(a, b) {\n          return a.value.x - b.value.x;\n        }\n\n        var PolarPlotArea = PolarPlotAreaBase.extend({\n          createPolarAxis: function () {\n            var polarAxis = new dataviz.PolarAxis(this.options.xAxis, this.chartService);\n            this.polarAxis = polarAxis;\n            this.axisX = polarAxis;\n            this.appendAxis(polarAxis);\n          },\n          valueAxisOptions: function (defaults) {\n            return deepExtend(defaults, {\n              majorGridLines: {\n                type: ARC\n              },\n              minorGridLines: {\n                type: ARC\n              }\n            }, this.options.yAxis);\n          },\n          createValueAxis: function () {\n            PolarPlotAreaBase.fn.createValueAxis.call(this);\n            this.axisY = this.valueAxis;\n          },\n          appendChart: function (chart, pane) {\n            this.valueAxisRangeTracker.update(chart.yAxisRanges);\n            PlotAreaBase.prototype.appendChart.call(this, chart, pane);\n          },\n          createCharts: function () {\n            var series = this.filterVisibleSeries(this.series);\n            var pane = this.panes[0];\n            this.createLineChart(filterSeriesByType(series, [POLAR_LINE]), pane);\n            this.createScatterChart(filterSeriesByType(series, [POLAR_SCATTER]), pane);\n            this.createAreaChart(filterSeriesByType(series, [POLAR_AREA]), pane);\n          },\n          createLineChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var lineChart = new PolarLineChart(this, {\n              series: series\n            });\n            this.appendChart(lineChart, pane);\n          },\n          createScatterChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var scatterChart = new PolarScatterChart(this, {\n              series: series\n            });\n            this.appendChart(scatterChart, pane);\n          },\n          createAreaChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var areaChart = new PolarAreaChart(this, {\n              series: series\n            });\n            this.appendChart(areaChart, pane);\n          },\n          _dispatchEvent: function (chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n\n            var point = new Point(coords.x, coords.y);\n            var xValue = this.axisX.getValue(point);\n            var yValue = this.axisY.getValue(point);\n\n            if (xValue !== null && yValue !== null) {\n              chart.trigger(eventType, {\n                element: eventElement(e),\n                x: xValue,\n                y: yValue\n              });\n            }\n          },\n          createCrosshairs: function () {}\n        });\n        setDefaultOptions(PolarPlotArea, {\n          xAxis: {},\n          yAxis: {}\n        });\n        deepExtend(PolarPlotArea.prototype, PlotAreaEventsMixin);\n\n        function groupBySeriesIx(segments) {\n          var seriesSegments = [];\n\n          for (var idx = 0; idx < segments.length; idx++) {\n            var segment = segments[idx];\n            seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];\n            seriesSegments[segment.seriesIx].push(segment);\n          }\n\n          return seriesSegments;\n        }\n\n        var RadarLineChart = LineChart.extend({\n          pointSlot: function (categorySlot, valueSlot) {\n            var valueRadius = categorySlot.center.y - valueSlot.y1;\n            var slot = Point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\n            return new Box(slot.x, slot.y, slot.x, slot.y);\n          },\n          renderSegments: function () {\n            LineChart.fn.renderSegments.call(this);\n\n            if (this._segments && this._segments.length > 1) {\n              var seriesSegments = groupBySeriesIx(this._segments);\n\n              for (var idx = 0; idx < seriesSegments.length; idx++) {\n                var segments = seriesSegments[idx];\n\n                if (segments && segments.length > 1) {\n                  var firstPoint = segments[0].linePoints[0];\n                  var lastSegment = last(segments);\n                  var lastPoint = last(lastSegment.linePoints);\n                  var isFirstDataPoint = firstPoint.categoryIx === 0;\n                  var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;\n\n                  if (isFirstDataPoint && isLastDataPoint) {\n                    last(segments).linePoints.push(firstPoint);\n                  }\n                }\n              }\n            }\n          },\n          createSegment: function (linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === SMOOTH) {\n              pointType = SplineSegment;\n            } else {\n              pointType = LineSegment;\n            }\n\n            var segment = new pointType(linePoints, currentSeries, seriesIx);\n            var missingValues = this.seriesMissingValues(currentSeries);\n\n            if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {\n              segment.options.closed = true;\n            }\n\n            return segment;\n          }\n        });\n        setDefaultOptions(RadarLineChart, {\n          clip: false,\n          limitPoints: false\n        });\n        var SplineRadarAreaSegment = SplineAreaSegment.extend({\n          fillToAxes: function () {}\n        });\n        var RadarAreaSegment = AreaSegment.extend({\n          fillToAxes: function () {}\n        });\n        var RadarAreaChart = RadarLineChart.extend({\n          createSegment: function (linePoints, currentSeries, seriesIx, prevSegment) {\n            var isStacked = this.options.isStacked;\n            var style = (currentSeries.line || {}).style;\n            var previousSegment;\n            var stackPoints;\n            var segment;\n\n            if (isStacked && seriesIx > 0 && prevSegment) {\n              stackPoints = prevSegment.linePoints.slice(0);\n              previousSegment = prevSegment;\n            }\n\n            if (style === SMOOTH) {\n              segment = new SplineRadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n              segment.options.closed = true;\n            } else {\n              linePoints.push(linePoints[0]);\n              segment = new RadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n            }\n\n            return segment;\n          },\n          seriesMissingValues: function (series) {\n            return series.missingValues || ZERO;\n          }\n        });\n        var RadarSegment = DonutSegment.extend({\n          init: function (value, options) {\n            DonutSegment.fn.init.call(this, value, null, options);\n          }\n        });\n        setDefaultOptions(RadarSegment, {\n          overlay: {\n            gradient: \"none\"\n          },\n          labels: {\n            distance: 10\n          }\n        });\n        var RadarClusterLayout = ChartElement.extend({\n          init: function (options) {\n            ChartElement.fn.init.call(this, options);\n            this.forEach = options.rtl ? forEachReverse : forEach;\n          },\n          reflow: function (sector) {\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var gap = options.gap;\n            var spacing = options.spacing;\n            var count = children.length;\n            var slots = count + gap + spacing * (count - 1);\n            var slotAngle = sector.angle / slots;\n            var angle = sector.startAngle + slotAngle * (gap / 2);\n            this.forEach(children, function (child) {\n              var slotSector = sector.clone();\n              slotSector.startAngle = angle;\n              slotSector.angle = slotAngle;\n\n              if (child.sector) {\n                slotSector.radius = child.sector.radius;\n              }\n\n              child.reflow(slotSector);\n              child.sector = slotSector;\n              angle += slotAngle + slotAngle * spacing;\n            });\n          }\n        });\n        setDefaultOptions(RadarClusterLayout, {\n          gap: 1,\n          spacing: 0\n        });\n        var RadarStackLayout = ChartElement.extend({\n          reflow: function (sector) {\n            var ref = this;\n            var reverse = ref.options.reverse;\n            var children = ref.children;\n            var childrenCount = children.length;\n            var first = reverse ? childrenCount - 1 : 0;\n            var step = reverse ? -1 : 1;\n            this.box = new Box();\n\n            for (var i = first; i >= 0 && i < childrenCount; i += step) {\n              var childSector = children[i].sector;\n              childSector.startAngle = sector.startAngle;\n              childSector.angle = sector.angle;\n            }\n          }\n        });\n        var RadarBarChart = BarChart.extend({\n          pointType: function () {\n            return RadarSegment;\n          },\n          clusterType: function () {\n            return RadarClusterLayout;\n          },\n          stackType: function () {\n            return RadarStackLayout;\n          },\n          categorySlot: function (categoryAxis, categoryIx) {\n            return categoryAxis.getSlot(categoryIx);\n          },\n          pointSlot: function (categorySlot, valueSlot) {\n            var slot = categorySlot.clone();\n            var y = categorySlot.center.y;\n            slot.radius = y - valueSlot.y1;\n            slot.innerRadius = y - valueSlot.y2;\n            return slot;\n          },\n          reflowPoint: function (point, pointSlot) {\n            point.sector = pointSlot;\n            point.reflow();\n          },\n          createAnimation: function () {\n            this.options.animation.center = this.box.toRect().center();\n            BarChart.fn.createAnimation.call(this);\n          }\n        });\n        RadarBarChart.prototype.reflow = CategoricalChart.prototype.reflow;\n        setDefaultOptions(RadarBarChart, {\n          clip: false,\n          limitPoints: false,\n          animation: {\n            type: \"pie\"\n          }\n        });\n        var RadarPlotArea = PolarPlotAreaBase.extend({\n          createPolarAxis: function () {\n            var categoryAxis = new dataviz.RadarCategoryAxis(this.options.categoryAxis, this.chartService);\n            this.polarAxis = categoryAxis;\n            this.categoryAxis = categoryAxis;\n            this.appendAxis(categoryAxis);\n            this.aggregateCategories();\n            this.createCategoryAxesLabels();\n          },\n          valueAxisOptions: function (defaults) {\n            if (this._hasBarCharts) {\n              deepExtend(defaults, {\n                majorGridLines: {\n                  type: ARC\n                },\n                minorGridLines: {\n                  type: ARC\n                }\n              });\n            }\n\n            if (this._isStacked100) {\n              deepExtend(defaults, {\n                roundToMajorUnit: false,\n                labels: {\n                  format: \"P0\"\n                }\n              });\n            }\n\n            return deepExtend(defaults, this.options.valueAxis);\n          },\n          aggregateCategories: function () {\n            // No separate panes in radar charts\n            CategoricalPlotArea.prototype.aggregateCategories.call(this, this.panes);\n          },\n          createCategoryAxesLabels: function () {\n            CategoricalPlotArea.prototype.createCategoryAxesLabels.call(this, this.panes);\n          },\n          filterSeries: function (currentSeries) {\n            // Not supported for radar charts\n            return currentSeries;\n          },\n          createCharts: function () {\n            var series = this.filterVisibleSeries(this.series);\n            var pane = this.panes[0];\n            this.createAreaChart(filterSeriesByType(series, [RADAR_AREA]), pane);\n            this.createLineChart(filterSeriesByType(series, [RADAR_LINE]), pane);\n            this.createBarChart(filterSeriesByType(series, [RADAR_COLUMN]), pane);\n          },\n          chartOptions: function (series) {\n            var options = {\n              series: series\n            };\n            var firstSeries = series[0];\n\n            if (firstSeries) {\n              var filteredSeries = this.filterVisibleSeries(series);\n              var stack = firstSeries.stack;\n              options.isStacked = stack && filteredSeries.length > 1;\n              options.isStacked100 = stack && stack.type === \"100%\" && filteredSeries.length > 1;\n\n              if (options.isStacked100) {\n                this._isStacked100 = true;\n              }\n            }\n\n            return options;\n          },\n          createAreaChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var areaChart = new RadarAreaChart(this, this.chartOptions(series));\n            this.appendChart(areaChart, pane);\n          },\n          createLineChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var lineChart = new RadarLineChart(this, this.chartOptions(series));\n            this.appendChart(lineChart, pane);\n          },\n          createBarChart: function (series, pane) {\n            if (series.length === 0) {\n              return;\n            }\n\n            var firstSeries = series[0];\n            var options = this.chartOptions(series);\n            options.gap = firstSeries.gap;\n            options.spacing = firstSeries.spacing;\n            var barChart = new RadarBarChart(this, options);\n            this.appendChart(barChart, pane);\n            this._hasBarCharts = true;\n          },\n          seriesCategoryAxis: function () {\n            return this.categoryAxis;\n          },\n          _dispatchEvent: function (chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n\n            var point = new Point(coords.x, coords.y);\n            var category = this.categoryAxis.getCategory(point);\n            var value = this.valueAxis.getValue(point);\n\n            if (category !== null && value !== null) {\n              chart.trigger(eventType, {\n                element: eventElement(e),\n                category: category,\n                value: value\n              });\n            }\n          },\n          createCrosshairs: function () {}\n        });\n        deepExtend(RadarPlotArea.prototype, PlotAreaEventsMixin, {\n          appendChart: CategoricalPlotArea.prototype.appendChart,\n          aggregateSeries: CategoricalPlotArea.prototype.aggregateSeries,\n          seriesSourcePoints: CategoricalPlotArea.prototype.seriesSourcePoints\n        });\n        setDefaultOptions(RadarPlotArea, {\n          categoryAxis: {\n            categories: []\n          },\n          valueAxis: {}\n        });\n        var FunnelSegment = ChartElement.extend({\n          init: function (value, options, segmentOptions) {\n            ChartElement.fn.init.call(this, options);\n            this.value = value;\n            this.options.index = segmentOptions.index;\n          },\n          reflow: function (chartBox) {\n            var points = this.points;\n            var label = this.children[0];\n            this.box = new Box(points[0].x, points[0].y, points[1].x, points[2].y);\n\n            if (label) {\n              label.reflow(new Box(chartBox.x1, points[0].y, chartBox.x2, points[2].y));\n            }\n          },\n          createVisual: function () {\n            var this$1 = this;\n            var options = this.options;\n            var visual;\n            ChartElement.fn.createVisual.call(this);\n\n            if (options.visual) {\n              visual = options.visual({\n                category: this.category,\n                dataItem: this.dataItem,\n                value: this.value,\n                series: this.series,\n                percentage: this.percentage,\n                points: this.points,\n                options: options,\n                sender: this.getSender(),\n                createVisual: function () {\n                  return this$1.createPath();\n                }\n              });\n            } else {\n              visual = this.createPath();\n            }\n\n            if (visual) {\n              this.visual.append(visual);\n            }\n          },\n          createPath: function () {\n            var options = this.options;\n            var border = options.border;\n            var path = Path.fromPoints(this.points, {\n              fill: {\n                color: options.color,\n                opacity: options.opacity\n              },\n              stroke: {\n                color: border.color,\n                opacity: border.opacity,\n                width: border.width\n              }\n            }).close();\n            return path;\n          },\n          createHighlight: function (style) {\n            return Path.fromPoints(this.points, style);\n          },\n          highlightVisual: function () {\n            return this.visual.children[0];\n          },\n          highlightVisualArgs: function () {\n            var path = Path.fromPoints(this.points).close();\n            return {\n              options: this.options,\n              path: path\n            };\n          },\n          tooltipAnchor: function () {\n            var box = this.box;\n            return {\n              point: new Point(box.center().x, box.y1),\n              align: {\n                horizontal: \"center\",\n                vertical: \"top\"\n              }\n            };\n          },\n          formatValue: function (format) {\n            var point = this;\n            return point.owner.formatPointValue(point, format);\n          }\n        });\n        setDefaultOptions(FunnelSegment, {\n          color: WHITE,\n          border: {\n            width: 1\n          }\n        });\n        deepExtend(FunnelSegment.prototype, PointEventsMixin);\n        var FunnelChart = ChartElement.extend({\n          init: function (plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n            this.plotArea = plotArea;\n            this.points = [];\n            this.labels = [];\n            this.legendItems = [];\n            this.render();\n          },\n          formatPointValue: function (point, format) {\n            return this.chartService.format.auto(format, point.value);\n          },\n          render: function () {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var seriesColors = ref.plotArea.options.seriesColors;\n\n            if (seriesColors === void 0) {\n              seriesColors = [];\n            }\n\n            var series = options.series[0];\n            var data = series.data;\n\n            if (!data) {\n              return;\n            }\n\n            var ref$1 = bindSegments(series);\n            var total = ref$1.total;\n            var points = ref$1.points;\n\n            for (var i = 0; i < points.length; i++) {\n              var pointData = points[i];\n\n              if (!pointData) {\n                continue;\n              }\n\n              var fields = pointData.fields;\n\n              if (!isFunction(series.color)) {\n                series.color = fields.color || seriesColors[i % seriesColors.length];\n              }\n\n              fields = deepExtend({\n                index: i,\n                owner: this$1,\n                series: series,\n                dataItem: data[i],\n                percentage: pointData.value / total\n              }, fields, {\n                visible: pointData.visible\n              });\n              var value = pointData.valueFields.value;\n              var segment = this$1.createSegment(value, fields);\n              var label = this$1.createLabel(value, fields);\n\n              if (segment && label) {\n                segment.append(label);\n              }\n            }\n          },\n          evalSegmentOptions: function (options, value, fields) {\n            var series = fields.series;\n            evalOptions(options, {\n              value: value,\n              series: series,\n              dataItem: fields.dataItem,\n              index: fields.index\n            }, {\n              defaults: series._defaults,\n              excluded: [\"data\", \"content\", \"template\", \"toggle\", \"visual\"]\n            });\n          },\n          createSegment: function (value, fields) {\n            var seriesOptions = deepExtend({}, fields.series);\n            this.evalSegmentOptions(seriesOptions, value, fields);\n            this.createLegendItem(value, seriesOptions, fields);\n\n            if (fields.visible !== false) {\n              var segment = new FunnelSegment(value, seriesOptions, fields);\n              $.extend(segment, fields);\n              this.append(segment);\n              this.points.push(segment);\n              return segment;\n            }\n          },\n          createLabel: function (value, fields) {\n            var series = fields.series;\n            var dataItem = fields.dataItem;\n            var labels = deepExtend({}, this.options.labels, series.labels);\n            var text = value;\n\n            if (labels.visible) {\n              var labelTemplate = getTemplate(labels);\n              var data = {\n                dataItem: dataItem,\n                value: value,\n                percentage: fields.percentage,\n                category: fields.category,\n                series: series\n              };\n\n              if (labelTemplate) {\n                text = labelTemplate(data);\n              } else if (labels.format) {\n                text = this.plotArea.chartService.format.auto(labels.format, text);\n              }\n\n              if (!labels.color) {\n                labels.color = dataviz.autoTextColor(series.color);\n\n                if (!labels.background) {\n                  labels.background = series.color;\n                }\n              }\n\n              this.evalSegmentOptions(labels, value, fields);\n              var textBox = new TextBox(text, deepExtend({\n                vAlign: labels.position\n              }, labels), data);\n              this.labels.push(textBox);\n              return textBox;\n            }\n          },\n          labelPadding: function () {\n            var labels = this.labels;\n            var padding = {\n              left: 0,\n              right: 0\n            };\n\n            for (var i = 0; i < labels.length; i++) {\n              var label = labels[i];\n              var align = label.options.align;\n\n              if (align !== CENTER) {\n                var width = labels[i].box.width();\n\n                if (align === LEFT) {\n                  padding.left = Math.max(padding.left, width);\n                } else {\n                  padding.right = Math.max(padding.right, width);\n                }\n              }\n            }\n\n            return padding;\n          },\n          dynamicSlopeReflow: function (box, width, totalHeight) {\n            var ref = this;\n            var options = ref.options;\n            var segments = ref.points;\n            var count = segments.length;\n            var firstSegment = segments[0];\n            var maxSegment = firstSegment;\n\n            for (var idx = 0; idx < segments.length; idx++) {\n              if (segments[idx].percentage > maxSegment.percentage) {\n                maxSegment = segments[idx];\n              }\n            }\n\n            var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;\n            var previousOffset = (width - lastUpperSide) / 2;\n            var previousHeight = 0;\n\n            for (var idx$1 = 0; idx$1 < count; idx$1++) {\n              var percentage = segments[idx$1].percentage;\n              var nextSegment = segments[idx$1 + 1];\n              var nextPercentage = nextSegment ? nextSegment.percentage : percentage;\n              var points = segments[idx$1].points = [];\n              var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n              var offset = void 0;\n\n              if (!percentage) {\n                offset = nextPercentage ? 0 : width / 2;\n              } else {\n                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n              }\n\n              offset = limitValue(offset, 0, width);\n              points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n              points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n              points.push(new GeometryPoint(box.x1 + width - offset, box.y1 + height + previousHeight));\n              points.push(new GeometryPoint(box.x1 + offset, box.y1 + height + previousHeight));\n              previousOffset = offset;\n              previousHeight += height + options.segmentSpacing;\n              lastUpperSide = limitValue(width - 2 * offset, 0, width);\n            }\n          },\n          constantSlopeReflow: function (box, width, totalHeight) {\n            var ref = this;\n            var options = ref.options;\n            var segments = ref.points;\n            var count = segments.length;\n            var decreasingWidth = options.neckRatio <= 1;\n            var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n            var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n            var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n            var finalNarrow = (topMostWidth - neckRatio) / 2;\n            var previousHeight = 0;\n\n            for (var idx = 0; idx < count; idx++) {\n              var points = segments[idx].points = [];\n              var percentage = segments[idx].percentage;\n              var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;\n              var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n              points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n              points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n              points.push(new GeometryPoint(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n              points.push(new GeometryPoint(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));\n              previousOffset += offset;\n              previousHeight += height + options.segmentSpacing;\n            }\n          },\n          reflow: function (chartBox) {\n            var points = this.points;\n            var count = points.length;\n\n            if (!count) {\n              return;\n            }\n\n            var options = this.options;\n            var box = chartBox.clone().unpad(this.labelPadding());\n            var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n            var width = box.width();\n\n            if (options.dynamicSlope) {\n              this.dynamicSlopeReflow(box, width, totalHeight);\n            } else {\n              this.constantSlopeReflow(box, width, totalHeight);\n            }\n\n            for (var idx = 0; idx < count; idx++) {\n              points[idx].reflow(chartBox);\n            }\n          }\n        });\n        setDefaultOptions(FunnelChart, {\n          neckRatio: 0.3,\n          width: 300,\n          dynamicSlope: false,\n          dynamicHeight: true,\n          segmentSpacing: 0,\n          labels: {\n            visible: false,\n            align: CENTER,\n            position: CENTER,\n            zIndex: 1\n          }\n        });\n        deepExtend(FunnelChart.prototype, PieChartMixin);\n        var FunnelPlotArea = PlotAreaBase.extend({\n          render: function () {\n            this.createFunnelChart(this.series);\n          },\n          createFunnelChart: function (series) {\n            var firstSeries = series[0];\n            var funnelChart = new FunnelChart(this, {\n              series: series,\n              legend: this.options.legend,\n              neckRatio: firstSeries.neckRatio,\n              dynamicHeight: firstSeries.dynamicHeight,\n              dynamicSlope: firstSeries.dynamicSlope,\n              segmentSpacing: firstSeries.segmentSpacing,\n              highlight: firstSeries.highlight\n            });\n            this.appendChart(funnelChart);\n          },\n          appendChart: function (chart, pane) {\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n            append(this.options.legend.items, chart.legendItems);\n          }\n        }); // Linear color scale from the given color to white minus minimum lightness offset.\n\n        var colorScale = function (color, minLightnessOffset) {\n          if (minLightnessOffset === void 0) {\n            minLightnessOffset = 0.05;\n          }\n\n          var baseColor = kendo.parseColor(color);\n          var offset = 1 - minLightnessOffset;\n          return function (value) {\n            var hsl = baseColor.toHSL();\n            var range = 100 - hsl.l;\n            var point = offset - value;\n            hsl.l += Math.min(point * range, range);\n            return hsl.toCss();\n          };\n        };\n\n        var HeatmapPoint = ChartElement.extend({\n          init: function (value, options) {\n            ChartElement.fn.init.call(this);\n            this.options = options;\n            this.color = options.color || WHITE;\n            this.value = value;\n          },\n          render: function () {\n            if (this._rendered) {\n              return;\n            }\n\n            this._rendered = true;\n            this.createMarker();\n            this.createLabel();\n            this.createNote();\n          },\n          createLabel: function () {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n              var pointData = this.pointData();\n              var labelTemplate = getTemplate(labels);\n              var labelText;\n              var labelColor = labels.color;\n\n              if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n              } else {\n                labelText = this.formatValue(labels.format);\n              }\n\n              if (!labelColor) {\n                labelColor = dataviz.autoTextColor(this.color);\n              }\n\n              this.label = new TextBox(labelText, deepExtend({\n                align: CENTER,\n                vAlign: CENTER,\n                margin: {\n                  left: 5,\n                  right: 5\n                },\n                zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n              }, labels, {\n                color: labelColor\n              }), pointData);\n              this.append(this.label);\n            }\n          },\n          formatValue: function (format) {\n            return this.owner.formatPointValue(this, format);\n          },\n          reflow: function (targetBox) {\n            this.render();\n            var label = this.label;\n            this.box = targetBox;\n\n            if (label) {\n              label.reflow(this.markerBox());\n            }\n\n            if (this.note) {\n              this.note.reflow(targetBox);\n            }\n\n            this.marker.reflow(this.markerBox());\n          },\n          markerBox: function () {\n            var options = this.options;\n            var markers = options.markers;\n            var border = markers.border;\n            var rect = this.box.toRect();\n            var type = valueOrDefault(markers.type, 'rect');\n            var isRoundRect = type === datavizConstants.ROUNDED_RECT;\n            var borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);\n            var halfBorderWidth = Math.round(borderWidth / 2);\n\n            if (markers.size) {\n              var center = rect.center();\n              rect.size.width = rect.size.height = markers.size;\n              rect.origin.x = Math.round(center.x - rect.size.width / 2);\n              rect.origin.y = Math.round(center.y - rect.size.height / 2);\n            }\n\n            rect.size.width -= borderWidth;\n            rect.size.height -= borderWidth;\n            rect.origin.y += halfBorderWidth + 0.5;\n            rect.origin.x += halfBorderWidth + 0.5;\n            return dataviz.rectToBox(rect);\n          },\n          markerBorder: function () {\n            var options = this.options;\n            var markers = options.markers;\n            var border = markers.border;\n            var opacity = valueOrDefault(border.opacity, options.opacity);\n            return {\n              color: border.color || this.color,\n              width: border.width,\n              opacity: opacity,\n              dashType: border.dashType\n            };\n          },\n          createMarker: function () {\n            var options = this.options;\n            var markerOptions = options.markers;\n            var marker = new ShapeElement({\n              type: valueOrDefault(markerOptions.type, 'rect'),\n              width: markerOptions.size,\n              height: markerOptions.size,\n              rotation: markerOptions.rotation,\n              background: this.color,\n              border: this.markerBorder(),\n              borderRadius: markerOptions.borderRadius,\n              opacity: this.series.opacity || options.opacity,\n              zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n              animation: options.animation,\n              visual: options.visual\n            }, {\n              dataItem: this.dataItem,\n              value: this.value,\n              series: this.series,\n              category: this.category\n            });\n            this.marker = marker;\n            this.append(marker);\n          },\n          createHighlight: function (style) {\n            var options = this.options;\n            var markerOptions = this.options.highlight.markers || this.options.markers;\n            var highlight = new ShapeElement({\n              type: valueOrDefault(markerOptions.type, 'rect'),\n              width: markerOptions.size,\n              height: markerOptions.size,\n              rotation: markerOptions.rotation,\n              background: markerOptions.color || this.color,\n              border: this.markerBorder(),\n              borderRadius: markerOptions.borderRadius,\n              opacity: this.series.opacity || options.opacity,\n              zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n            });\n            highlight.reflow(this.markerBox());\n            var visual = highlight.getElement();\n            visual.options.fill = style.fill;\n            visual.options.stroke = style.stroke;\n            return visual;\n          },\n          highlightVisual: function () {\n            return this.rectVisual;\n          },\n          highlightVisualArgs: function () {\n            return {\n              options: this.options,\n              rect: this.box.toRect(),\n              visual: this.rectVisual\n            };\n          },\n          tooltipAnchor: function () {\n            var left = this.box.center().x;\n            var top = this.box.y1 - TOOLTIP_OFFSET;\n            return {\n              point: new Point(left, top),\n              align: {\n                horizontal: CENTER,\n                vertical: BOTTOM\n              }\n            };\n          },\n          overlapsBox: function (box) {\n            return this.box.overlaps(box);\n          },\n          unclipElements: function () {\n            /* noop, clip labels */\n          },\n          pointData: function () {\n            return {\n              x: this.value.x,\n              y: this.value.y,\n              value: this.value.value,\n              dataItem: this.dataItem,\n              series: this.series\n            };\n          }\n        });\n        deepExtend(HeatmapPoint.prototype, PointEventsMixin);\n        deepExtend(HeatmapPoint.prototype, NoteMixin);\n        HeatmapPoint.prototype.defaults = {\n          markers: {\n            type: 'rect',\n            borderRadius: 4,\n            border: {\n              color: 'transparent'\n            }\n          },\n          padding: {\n            top: 1\n          },\n          labels: {\n            visible: false,\n            padding: 3\n          },\n          opacity: 1,\n          notes: {\n            label: {}\n          }\n        };\n        var HeatmapChart = ChartElement.extend({\n          init: function (plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n\n            this._initFields();\n\n            this.render();\n          },\n          _initFields: function () {\n            this.points = [];\n            this.seriesOptions = [];\n            this.valueRange = {\n              min: MAX_VALUE,\n              max: MIN_VALUE\n            };\n            this._evalSeries = [];\n          },\n          render: function () {\n            this.setRange();\n            this.traverseDataPoints(this.addValue.bind(this));\n          },\n          setRange: function () {\n            var this$1 = this;\n            var ref = this;\n            var series = ref.options.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n\n              for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);\n\n                var valueFields = ref$1.valueFields;\n\n                if (defined(valueFields.value) && valueFields.value !== null) {\n                  this$1.valueRange.min = Math.min(this$1.valueRange.min, valueFields.value);\n                  this$1.valueRange.max = Math.max(this$1.valueRange.max, valueFields.value);\n                }\n              }\n            }\n          },\n          addValue: function (value, fields) {\n            var point;\n\n            if (value && defined(value.value) && value.value !== null) {\n              point = this.createPoint(value, fields);\n\n              if (point) {\n                $.extend(point, fields);\n              }\n            }\n\n            this.points.push(point);\n          },\n          evalPointOptions: function (options, value, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var state = {\n              defaults: series._defaults,\n              excluded: [\"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\"]\n            };\n            var doEval = this._evalSeries[seriesIx];\n\n            if (!defined(doEval)) {\n              this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n\n            if (doEval) {\n              pointOptions = deepExtend({}, options);\n              evalOptions(pointOptions, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem,\n                min: this.valueRange.min,\n                max: this.valueRange.max\n              }, state);\n            }\n\n            return pointOptions;\n          },\n          pointType: function () {\n            return HeatmapPoint;\n          },\n          pointOptions: function (series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n\n            if (!options) {\n              var defaults = this.pointType().prototype.defaults;\n              this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                markers: {\n                  opacity: series.opacity\n                },\n                tooltip: {\n                  format: this.options.tooltip.format\n                },\n                labels: {\n                  format: this.options.labels.format\n                }\n              }, series);\n            }\n\n            return options;\n          },\n          createPoint: function (value, fields) {\n            var series = fields.series;\n            var pointOptions = this.pointOptions(series, fields.seriesIx);\n            var color = fields.color || series.color;\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (isFunction(series.color)) {\n              color = pointOptions.color;\n            } else if (this.valueRange.max !== 0) {\n              var scale = colorScale(color);\n              color = scale(value.value / this.valueRange.max);\n            }\n\n            var point = new HeatmapPoint(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n          },\n          seriesAxes: function (series) {\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var plotArea = this.plotArea;\n            var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n            var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n            if (!xAxis) {\n              throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n              throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return {\n              xAxis: xAxis,\n              yAxis: yAxis\n            };\n          },\n          reflow: function (targetBox) {\n            var this$1 = this;\n            var chartPoints = this.points;\n            var limit = !this.options.clip;\n            var pointIx = 0;\n            this.traverseDataPoints(function (value, fields) {\n              var point = chartPoints[pointIx++];\n              var ref = this$1.seriesAxes(fields.series);\n              var xAxis = ref.xAxis;\n              var yAxis = ref.yAxis;\n              var indexX = xAxis.categoryIndex(value.x);\n              var indexY = yAxis.categoryIndex(value.y);\n              var slotX = xAxis.getSlot(indexX, indexX, limit);\n              var slotY = yAxis.getSlot(indexY, indexY, limit);\n\n              if (point) {\n                if (slotX && slotY) {\n                  var pointSlot = this$1.pointSlot(slotX, slotY);\n                  point.reflow(pointSlot);\n                } else {\n                  point.visible = false;\n                }\n              }\n            });\n            this.box = targetBox;\n          },\n          pointSlot: function (slotX, slotY) {\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n          },\n          traverseDataPoints: function (callback) {\n            var this$1 = this;\n            var ref = this;\n            var series = ref.options.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var ref$1 = this$1.seriesAxes(currentSeries);\n              var xAxis = ref$1.xAxis;\n              var yAxis = ref$1.yAxis;\n              var xRange = xAxis.currentRangeIndices();\n              var yRange = yAxis.currentRangeIndices();\n\n              for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                var ref$2 = this$1._bindPoint(currentSeries, seriesIx, pointIx);\n\n                var value = ref$2.valueFields;\n                var fields = ref$2.fields;\n                var xIndex = xAxis.totalIndex(value.x);\n                var yIndex = yAxis.totalIndex(value.y);\n                var xIn = xRange.min <= xIndex && xIndex <= xRange.max;\n                var yIn = yRange.min <= yIndex && yIndex <= yRange.max;\n\n                if (xIn && yIn) {\n                  callback(value, deepExtend({\n                    pointIx: pointIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: currentSeries.data[pointIx],\n                    owner: this$1\n                  }, fields));\n                }\n              }\n            }\n          },\n          formatPointValue: function (point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y, value.value);\n          },\n          animationPoints: function () {\n            var points = this.points;\n            var result = [];\n\n            for (var idx = 0; idx < points.length; idx++) {\n              result.push((points[idx] || {}).marker);\n            }\n\n            return result;\n          }\n        });\n        setDefaultOptions(HeatmapChart, {\n          series: [],\n          tooltip: {\n            format: \"{0}, {1}: {2}\"\n          },\n          labels: {\n            format: \"{2}\"\n          },\n          clip: true\n        });\n        deepExtend(HeatmapChart.prototype, {\n          _bindPoint: CategoricalChart.prototype._bindPoint\n        });\n        var HeatmapPlotArea = PlotAreaBase.extend({\n          initFields: function () {\n            this.namedXAxes = {};\n            this.namedYAxes = {};\n          },\n          render: function (panes) {\n            if (panes === void 0) {\n              panes = this.panes;\n            }\n\n            this.bindCategories();\n            this.createAxes(panes);\n            this.createCharts(panes);\n            this.createAxisLabels();\n          },\n          bindCategories: function () {\n            var this$1 = this;\n            var series = this.srcSeries || this.series;\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n              var data = currentSeries.data || [];\n              var ref = this$1.seriesAxes(currentSeries);\n              var xAxis = ref.xAxis;\n              var yAxis = ref.yAxis;\n              var xCategories = dataviz.createHashSet(xAxis.categories || []);\n              var yCategories = dataviz.createHashSet(yAxis.categories || []);\n\n              for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {\n                var ref$1 = SeriesBinder.current.bindPoint(currentSeries, pointIndex).valueFields;\n                var x = ref$1.x;\n                var y = ref$1.y;\n\n                if (!xCategories.has(x)) {\n                  xCategories.add(x);\n                }\n\n                if (!yCategories.has(y)) {\n                  yCategories.add(y);\n                }\n              }\n\n              xAxis.categories = xCategories.values();\n              yAxis.categories = yCategories.values();\n            }\n          },\n          createCharts: function (panes) {\n            var this$1 = this;\n            var seriesByPane = this.groupSeriesByPane();\n\n            for (var i = 0; i < panes.length; i++) {\n              var pane = panes[i];\n              var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n              this$1.addToLegend(paneSeries);\n              var filteredSeries = this$1.filterVisibleSeries(paneSeries);\n\n              if (!filteredSeries) {\n                continue;\n              }\n\n              this$1.createHeatmapChart(filterSeriesByType(filteredSeries, [HEATMAP]), pane);\n            }\n          },\n          createHeatmapChart: function (series, pane) {\n            var chart = new HeatmapChart(this, {\n              series: series\n            });\n            this.appendChart(chart, pane);\n          },\n          seriesPaneName: function (series) {\n            var options = this.options;\n            var xAxisName = series.xAxis;\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxis = grep(xAxisOptions, function (a) {\n              return a.name === xAxisName;\n            })[0];\n            var yAxisName = series.yAxis;\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxis = grep(yAxisOptions, function (a) {\n              return a.name === yAxisName;\n            })[0];\n            var panes = options.panes || [{}];\n            var defaultPaneName = panes[0].name || \"default\";\n            var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n            return paneName;\n          },\n          seriesAxes: function (series) {\n            var xAxis;\n            var yAxis;\n            var options = this.options;\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxisName = series.xAxis;\n\n            if (xAxisName) {\n              xAxis = xAxisOptions.find(function (axis) {\n                return axis.name === xAxisName;\n              });\n            } else {\n              xAxis = xAxisOptions[0];\n            }\n\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxisName = series.yAxis;\n\n            if (yAxisName) {\n              yAxis = yAxisOptions.find(function (axis) {\n                return axis.name === yAxisName;\n              });\n            } else {\n              yAxis = yAxisOptions[0];\n            }\n\n            if (!xAxis) {\n              throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n              throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return {\n              xAxis: xAxis,\n              yAxis: yAxis\n            };\n          },\n          createAxisLabels: function () {\n            var axes = this.axes;\n\n            for (var i = 0; i < axes.length; i++) {\n              axes[i].createLabels();\n            }\n          },\n          createXYAxis: function (options, vertical, axisIndex) {\n            var axisName = options.name;\n            var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n            var axisOptions = $.extend({\n              axisCrossingValue: 0\n            }, options, {\n              vertical: vertical,\n              reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,\n              justified: false\n            });\n            var firstCategory = axisOptions.categories ? axisOptions.categories[0] : null;\n            var typeSamples = [axisOptions.min, axisOptions.max, firstCategory];\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n              var currentSeries = series[seriesIx];\n              var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n\n              if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n                var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n                typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n                break;\n              }\n            }\n\n            var inferredDate;\n\n            for (var i = 0; i < typeSamples.length; i++) {\n              if (typeSamples[i] instanceof Date) {\n                inferredDate = true;\n                break;\n              }\n            }\n\n            var axisType;\n\n            if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n              axisType = dataviz.DateCategoryAxis;\n            } else {\n              axisType = CategoryAxis;\n            }\n\n            var axis = new axisType(axisOptions, this.chartService);\n            axis.axisIndex = axisIndex;\n\n            if (axisName) {\n              if (namedAxes[axisName]) {\n                throw new Error((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\");\n              }\n\n              namedAxes[axisName] = axis;\n            }\n\n            this.appendAxis(axis);\n            axis.mapCategories();\n            return axis;\n          },\n          createAxes: function (panes) {\n            var this$1 = this;\n            var options = this.options;\n            var xAxesOptions = [].concat(options.xAxis);\n            var xAxes = [];\n            var yAxesOptions = [].concat(options.yAxis);\n            var yAxes = [];\n\n            for (var idx = 0; idx < xAxesOptions.length; idx++) {\n              var axisPane = this$1.findPane(xAxesOptions[idx].pane);\n\n              if (inArray(axisPane, panes)) {\n                xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\n              }\n            }\n\n            for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n              var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\n\n              if (inArray(axisPane$1, panes)) {\n                yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n              }\n            }\n\n            this.axisX = this.axisX || xAxes[0];\n            this.axisY = this.axisY || yAxes[0];\n          },\n          removeAxis: function (axis) {\n            var axisName = axis.options.name;\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis.options.vertical) {\n              delete this.namedYAxes[axisName];\n            } else {\n              delete this.namedXAxes[axisName];\n            }\n\n            if (axis === this.axisX) {\n              delete this.axisX;\n            }\n\n            if (axis === this.axisY) {\n              delete this.axisY;\n            }\n          },\n          _dispatchEvent: function (chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n\n            var point = new Point(coords.x, coords.y);\n            var allAxes = this.axes;\n            var length = allAxes.length;\n            var xValues = [];\n            var yValues = [];\n\n            for (var i = 0; i < length; i++) {\n              var axis = allAxes[i];\n              var values = axis.options.vertical ? yValues : xValues;\n              appendIfNotNull(values, axis.getCategory(point));\n            }\n\n            if (xValues.length > 0 && yValues.length > 0) {\n              chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                x: singleItemOrArray(xValues),\n                y: singleItemOrArray(yValues)\n              });\n            }\n          },\n          updateAxisOptions: function (axis, options) {\n            var vertical = axis.options.vertical;\n            var axes = this.groupAxes(this.panes);\n            var index = (vertical ? axes.y : axes.x).indexOf(axis);\n            updateAxisOptions$2(this.options, index, vertical, options);\n            updateAxisOptions$2(this.originalOptions, index, vertical, options);\n          },\n          crosshairOptions: function (axis) {\n            // Stack the crosshair above the series points.\n            return $.extend({}, axis.options.crosshair, {\n              zIndex: 0\n            });\n          }\n        });\n\n        function updateAxisOptions$2(targetOptions, axisIndex, vertical, options) {\n          var axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n          deepExtend(axisOptions, options);\n        }\n\n        setDefaultOptions(HeatmapPlotArea, {\n          xAxis: {},\n          yAxis: {}\n        });\n        deepExtend(HeatmapPlotArea.prototype, PlotAreaEventsMixin);\n        var COLOR = \"color\";\n        var FIRST = \"first\";\n        var FROM = \"from\";\n        var MAX = \"max\";\n        var MIN = \"min\";\n        var NOTE_TEXT = \"noteText\";\n        var SUMMARY_FIELD = \"summary\";\n        var TO = \"to\";\n        PlotAreaFactory.current.register(CategoricalPlotArea, [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA]);\n        PlotAreaFactory.current.register(XYPlotArea, [SCATTER, SCATTER_LINE, BUBBLE]);\n        PlotAreaFactory.current.register(PiePlotArea, [PIE]);\n        PlotAreaFactory.current.register(DonutPlotArea, [DONUT]);\n        PlotAreaFactory.current.register(FunnelPlotArea, [FUNNEL]);\n        PlotAreaFactory.current.register(PolarPlotArea, [POLAR_AREA, POLAR_LINE, POLAR_SCATTER]);\n        PlotAreaFactory.current.register(RadarPlotArea, [RADAR_AREA, RADAR_COLUMN, RADAR_LINE]);\n        PlotAreaFactory.current.register(HeatmapPlotArea, [HEATMAP]);\n        SeriesBinder.current.register([BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA], [VALUE], [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD]);\n        SeriesBinder.current.register([RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA], [FROM, TO], [CATEGORY, COLOR, NOTE_TEXT]);\n        SeriesBinder.current.register([WATERFALL, HORIZONTAL_WATERFALL], [VALUE], [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD]);\n        SeriesBinder.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR]);\n        SeriesBinder.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [COLOR]);\n        SeriesBinder.current.register([FUNNEL], [VALUE], [CATEGORY, COLOR, \"visibleInLegend\", \"visible\"]);\n        DefaultAggregates.current.register([BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL], {\n          value: MAX,\n          color: FIRST,\n          noteText: FIRST,\n          errorLow: MIN,\n          errorHigh: MAX\n        });\n        DefaultAggregates.current.register([RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA], {\n          from: MIN,\n          to: MAX,\n          color: FIRST,\n          noteText: FIRST\n        });\n        DefaultAggregates.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], {\n          value: MAX,\n          color: FIRST\n        });\n        SeriesBinder.current.register([SCATTER, SCATTER_LINE, BUBBLE], [X, Y], [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]);\n        SeriesBinder.current.register([BUBBLE], [X, Y, \"size\"], [COLOR, CATEGORY, NOTE_TEXT]);\n        SeriesBinder.current.register([HEATMAP], [X, Y, VALUE], [COLOR, NOTE_TEXT]);\n        SeriesBinder.current.register([CANDLESTICK, OHLC], [\"open\", \"high\", \"low\", \"close\"], [CATEGORY, COLOR, \"downColor\", NOTE_TEXT]);\n        DefaultAggregates.current.register([CANDLESTICK, OHLC], {\n          open: MAX,\n          high: MAX,\n          low: MIN,\n          close: MAX,\n          color: FIRST,\n          downColor: FIRST,\n          noteText: FIRST\n        });\n        SeriesBinder.current.register([BOX_PLOT, VERTICAL_BOX_PLOT], [\"lower\", \"q1\", \"median\", \"q3\", \"upper\", \"mean\", \"outliers\"], [CATEGORY, COLOR, NOTE_TEXT]);\n        DefaultAggregates.current.register([BOX_PLOT, VERTICAL_BOX_PLOT], {\n          lower: MAX,\n          q1: MAX,\n          median: MAX,\n          q3: MAX,\n          upper: MAX,\n          mean: MAX,\n          outliers: FIRST,\n          color: FIRST,\n          noteText: FIRST\n        });\n        SeriesBinder.current.register([BULLET, VERTICAL_BULLET], [\"current\", \"target\"], [CATEGORY, COLOR, \"visibleInLegend\", NOTE_TEXT]);\n        DefaultAggregates.current.register([BULLET, VERTICAL_BULLET], {\n          current: MAX,\n          target: MAX,\n          color: FIRST,\n          noteText: FIRST\n        });\n        SeriesBinder.current.register([PIE, DONUT], [VALUE], [CATEGORY, COLOR, \"explode\", \"visibleInLegend\", \"visible\"]);\n        var AXIS_NAMES = [CATEGORY, VALUE, X, Y];\n        var MOUSEMOVE = \"mousemove\";\n        var CONTEXTMENU = \"contextmenu\";\n        var MOUSELEAVE = \"mouseleave\";\n        var MOUSEMOVE_DELAY = 20;\n        var Chart = Class.extend({\n          init: function (element, userOptions, themeOptions, context) {\n            var this$1 = this;\n\n            if (context === void 0) {\n              context = {};\n            }\n\n            this.observers = [];\n            this.addObserver(context.observer);\n            this.chartService = new services.ChartService(this, context);\n            this.chartService.theme = themeOptions;\n\n            this._initElement(element);\n\n            var options = deepExtend({}, this.options, userOptions);\n            this._originalOptions = deepExtend({}, options);\n            this._theme = themeOptions;\n\n            this._initTheme(options, themeOptions);\n\n            this._initHandlers();\n\n            this._initSurface();\n\n            this.bindCategories();\n            dataviz.FontLoader.preloadFonts(userOptions, function () {\n              this$1.fontLoaded = true;\n\n              if (!this$1._destroyed) {\n                this$1.trigger('init');\n\n                this$1._redraw();\n\n                this$1._attachEvents();\n              }\n            });\n          },\n          _initElement: function (element) {\n            this._setElementClass(element);\n\n            element.style.position = \"relative\";\n\n            while (element.firstChild) {\n              element.removeChild(element.firstChild);\n            }\n\n            this.element = element;\n          },\n          _setElementClass: function (element) {\n            dataviz.addClass(element, \"k-chart\");\n          },\n          _initTheme: function (options, themeOptions) {\n            var seriesCopies = [];\n            var series = options.series || [];\n\n            for (var i = 0; i < series.length; i++) {\n              seriesCopies.push($.extend({}, series[i]));\n            }\n\n            options.series = seriesCopies;\n            resolveAxisAliases(options);\n            this.applyDefaults(options, themeOptions); // Clean up default if not overriden by data attributes\n\n            if (options.seriesColors === null) {\n              delete options.seriesColors;\n            }\n\n            this.options = deepExtend({}, themeOptions, options);\n            this.applySeriesColors();\n          },\n          getSize: function () {\n            var chartArea = this.options.chartArea || {};\n            var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n            var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n            return {\n              width: width,\n              height: height\n            };\n          },\n          resize: function (force) {\n            var size = this.getSize();\n            var currentSize = this._size;\n            var hasSize = size.width > 0 || size.height > 0;\n\n            if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n              this._size = size;\n\n              this._resize(size, force);\n\n              this.trigger(\"resize\", size);\n            } else if (hasSize && this._selections && dataviz.find(this._selections, function (s) {\n              return !s.visible;\n            })) {\n              this._destroySelections();\n\n              this._setupSelection();\n            }\n          },\n          _resize: function () {\n            this._noTransitionsRedraw();\n          },\n          redraw: function (paneName) {\n            this.applyDefaults(this.options);\n            this.applySeriesColors();\n\n            if (paneName) {\n              var plotArea = this._model._plotArea;\n              var pane = plotArea.findPane(paneName);\n              plotArea.redraw(pane);\n            } else {\n              this._redraw();\n            }\n          },\n          getAxis: function (name) {\n            return findAxisByName(name, this._plotArea.axes);\n          },\n          findAxisByName: function (name) {\n            return this.getAxis(name);\n          },\n          findPaneByName: function (name) {\n            var panes = this._plotArea.panes;\n\n            for (var idx = 0; idx < panes.length; idx++) {\n              if (panes[idx].options.name === name) {\n                return new ChartPane(panes[idx]);\n              }\n            }\n          },\n          findPaneByIndex: function (idx) {\n            var panes = this._plotArea.panes;\n\n            if (panes[idx]) {\n              return new ChartPane(panes[idx]);\n            }\n          },\n          plotArea: function () {\n            return new ChartPlotArea(this._plotArea);\n          },\n          toggleHighlight: function (show, filter) {\n            var plotArea = this._plotArea;\n            var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n            var points;\n\n            if (isFunction(filter)) {\n              points = plotArea.filterPoints(filter);\n            } else {\n              var seriesName, categoryName;\n\n              if (isObject(filter)) {\n                seriesName = filter.series;\n                categoryName = filter.category;\n              } else {\n                seriesName = categoryName = filter;\n              }\n\n              if (firstSeries.type === DONUT) {\n                points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n              } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\n                points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n              } else {\n                points = plotArea.pointsBySeriesName(seriesName);\n              }\n            }\n\n            if (points) {\n              this.togglePointsHighlight(show, points);\n            }\n          },\n          togglePointsHighlight: function (show, points) {\n            var highlight = this._highlight;\n\n            for (var idx = 0; idx < points.length; idx++) {\n              highlight.togglePointHighlight(points[idx], show);\n            }\n          },\n          showTooltip: function (filter) {\n            var shared = this._sharedTooltip();\n\n            var ref = this;\n            var tooltip = ref._tooltip;\n            var plotArea = ref._plotArea;\n            var point, categoryIndex;\n\n            if (isFunction(filter)) {\n              point = plotArea.findPoint(filter);\n\n              if (point && shared) {\n                categoryIndex = point.categoryIx;\n              }\n            } else if (shared && defined(filter)) {\n              categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n            }\n\n            if (shared) {\n              if (categoryIndex >= 0) {\n                var points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n\n                tooltip.showAt(points);\n              }\n            } else if (point) {\n              tooltip.show(point);\n            }\n          },\n          hideTooltip: function () {\n            this._tooltip.hide();\n          },\n          _initSurface: function () {\n            var surface = this.surface;\n\n            var wrap = this._surfaceWrap();\n\n            var chartArea = this.options.chartArea || {};\n\n            if (chartArea.width) {\n              dataviz.elementSize(wrap, {\n                width: chartArea.width\n              });\n            }\n\n            if (chartArea.height) {\n              dataviz.elementSize(wrap, {\n                height: chartArea.height\n              });\n            }\n\n            if (!surface || surface.options.type !== this.options.renderAs) {\n              this._destroySurface();\n\n              this.surface = drawing.Surface.create(wrap, {\n                type: this.options.renderAs\n              });\n              this.surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\n              this.surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\n            } else {\n              this.surface.clear();\n              this.surface.resize();\n            }\n          },\n          _surfaceWrap: function () {\n            return this.element;\n          },\n          _redraw: function () {\n            var model = this._getModel();\n\n            this._size = {\n              width: model.options.width,\n              height: model.options.height\n            };\n\n            this._destroyView();\n\n            this._model = model;\n            this._plotArea = model._plotArea;\n            model.renderVisual();\n\n            if (this.options.transitions !== false) {\n              model.traverse(function (element) {\n                if (element.animation) {\n                  element.animation.setup();\n                }\n              });\n            }\n\n            this._initSurface();\n\n            this.surface.draw(model.visual);\n\n            if (this.options.transitions !== false) {\n              model.traverse(function (element) {\n                if (element.animation) {\n                  element.animation.play();\n                }\n              });\n            }\n\n            this._tooltip = this._createTooltip();\n            this._highlight = new Highlight();\n\n            this._setupSelection();\n\n            this._createPannable();\n\n            this._createZoomSelection();\n\n            this._createMousewheelZoom();\n\n            this.trigger(RENDER);\n            triggerPaneRender(this._plotArea.panes);\n\n            if (!this._navState) {\n              this._cancelDomEvents();\n            }\n          },\n          exportVisual: function (exportOptions) {\n            var visual;\n\n            if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n              var currentOptions = this.options;\n              var options = deepExtend({}, exportOptions.options, {\n                chartArea: {\n                  width: exportOptions.width,\n                  height: exportOptions.height\n                }\n              });\n              clearMissingValues(this._originalOptions, options);\n              this.options = deepExtend({}, this._originalOptions, options);\n\n              this._initTheme(this.options, this._theme);\n\n              this.bindCategories();\n\n              var model = this._getModel();\n\n              model.renderVisual();\n              triggerPaneRender(model._plotArea.panes);\n              visual = model.visual;\n              this.options = currentOptions;\n            } else {\n              visual = this.surface.exportVisual();\n            }\n\n            return visual;\n          },\n          _sharedTooltip: function () {\n            return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;\n          },\n          _createPannable: function () {\n            var options = this.options;\n\n            if (options.pannable !== false) {\n              this._pannable = new Pannable(this._plotArea, options.pannable);\n            }\n          },\n          _createZoomSelection: function () {\n            var zoomable = this.options.zoomable;\n            var selection = (zoomable || {}).selection;\n\n            if (zoomable !== false && selection !== false) {\n              this._zoomSelection = new ZoomSelection(this, selection);\n            }\n          },\n          _createMousewheelZoom: function () {\n            var zoomable = this.options.zoomable;\n            var mousewheel = (zoomable || {}).mousewheel;\n\n            if (zoomable !== false && mousewheel !== false) {\n              this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\n            }\n          },\n          _toggleDragZoomEvents: function () {\n            var pannable = this.options.pannable;\n            var zoomable = this.options.zoomable;\n            var selection = (zoomable || {}).selection;\n            var mousewheel = (zoomable || {}).mousewheel;\n            var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);\n            var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);\n            var element = this.element;\n\n            if (this._dragZoomEnabled && allowDrag && allowZoom) {\n              element.style.touchAction = this._touchAction || '';\n              this._dragZoomEnabled = false;\n            } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n              element.style.touchAction = \"none\";\n              this._dragZoomEnabled = true;\n            }\n\n            this._toggleDomEvents(!allowDrag, !allowZoom);\n          },\n          _toggleDomEvents: function (drag, zoom) {\n            var domEvents = this.domEvents;\n\n            if (!domEvents) {\n              return;\n            }\n\n            if (domEvents.toggleDrag) {\n              domEvents.toggleDrag(drag);\n            }\n\n            if (domEvents.toggleZoom) {\n              domEvents.toggleZoom(zoom);\n            }\n          },\n          _createTooltip: function () {\n            var ref = this;\n            var tooltipOptions = ref.options.tooltip;\n            var tooltip;\n\n            if (this._sharedTooltip()) {\n              tooltip = this._createSharedTooltip(tooltipOptions);\n            } else {\n              tooltip = new Tooltip(this.chartService, tooltipOptions);\n            }\n\n            return tooltip;\n          },\n          _createSharedTooltip: function (options) {\n            return new SharedTooltip(this._plotArea, options);\n          },\n          applyDefaults: function (options, themeOptions) {\n            applyAxisDefaults(options, themeOptions);\n            applySeriesDefaults(options, themeOptions);\n          },\n          applySeriesColors: function () {\n            var options = this.options;\n            var series = options.series;\n            var colors = options.seriesColors || [];\n\n            for (var i = 0; i < series.length; i++) {\n              var currentSeries = series[i];\n              var seriesColor = colors[i % colors.length];\n              var defaults = currentSeries._defaults;\n              currentSeries.color = currentSeries.color || seriesColor;\n\n              if (defaults) {\n                defaults.color = defaults.color || seriesColor;\n              }\n            }\n          },\n          _getModel: function () {\n            var options = this.options;\n\n            var plotArea = this._createPlotArea();\n\n            var model = new dataviz.RootElement(this._modelOptions());\n            model.chart = this;\n            model._plotArea = plotArea;\n            dataviz.Title.buildTitle(options.title, model);\n\n            if (options.legend && options.legend.visible) {\n              model.append(new Legend(plotArea.options.legend, this.chartService));\n            }\n\n            model.append(plotArea);\n            model.reflow();\n            return model;\n          },\n          _modelOptions: function () {\n            var options = this.options;\n            var size = this.getSize();\n            return deepExtend({\n              transitions: options.transitions,\n              width: size.width || datavizConstants.DEFAULT_WIDTH,\n              height: size.height || datavizConstants.DEFAULT_HEIGHT\n            }, options.chartArea);\n          },\n          _createPlotArea: function (skipSeries) {\n            var options = this.options;\n            var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n            return plotArea;\n          },\n          _setupSelection: function () {\n            var this$1 = this;\n            var ref = this;\n            var axes = ref._plotArea.axes;\n            var selections = this._selections = [];\n\n            for (var i = 0; i < axes.length; i++) {\n              var axis = axes[i];\n              var options = axis.options;\n\n              if (axis instanceof CategoryAxis && options.select && !options.vertical) {\n                var range = axis.range();\n                var selection = new Selection(this$1, axis, deepExtend({\n                  min: range.min,\n                  max: range.max\n                }, options.select));\n                selections.push(selection);\n              }\n            }\n          },\n          _selectStart: function (e) {\n            return this.trigger(SELECT_START, e);\n          },\n          _select: function (e) {\n            return this.trigger(SELECT, e);\n          },\n          _selectEnd: function (e) {\n            return this.trigger(SELECT_END, e);\n          },\n          _initHandlers: function () {\n            this._clickHandler = this._click.bind(this);\n            this._mousewheelHandler = this._mousewheel.bind(this);\n            this._mouseleaveHandler = this._mouseleave.bind(this);\n            this._surfaceMouseenterHandler = this._mouseover.bind(this);\n            this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n            this._mousemove = kendo.throttle(this._mousemove.bind(this), MOUSEMOVE_DELAY);\n          },\n          addObserver: function (observer) {\n            if (observer) {\n              this.observers.push(observer);\n            }\n          },\n          removeObserver: function (observer) {\n            var index = this.observers.indexOf(observer);\n\n            if (index >= 0) {\n              this.observers.splice(index, 1);\n            }\n          },\n          requiresHandlers: function (eventNames) {\n            var observers = this.observers;\n\n            for (var idx = 0; idx < observers.length; idx++) {\n              if (observers[idx].requiresHandlers(eventNames)) {\n                return true;\n              }\n            }\n          },\n          trigger: function (name, args) {\n            if (args === void 0) {\n              args = {};\n            }\n\n            if (name === SHOW_TOOLTIP) {\n              args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n            }\n\n            args.sender = this;\n            var observers = this.observers;\n            var isDefaultPrevented = false;\n\n            for (var idx = 0; idx < observers.length; idx++) {\n              if (observers[idx].trigger(name, args)) {\n                isDefaultPrevented = true;\n              }\n            }\n\n            return isDefaultPrevented;\n          },\n          _attachEvents: function () {\n            var element = this.element;\n            this._touchAction = element.style.touchAction;\n            var obj;\n            bindEvents(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));\n\n            if (this._shouldAttachMouseMove()) {\n              var obj$1;\n              bindEvents(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));\n            }\n\n            this.domEvents = services.DomEventsBuilder.create(this.element, {\n              start: this._start.bind(this),\n              move: this._move.bind(this),\n              end: this._end.bind(this),\n              tap: this._tap.bind(this),\n              gesturestart: this._gesturestart.bind(this),\n              gesturechange: this._gesturechange.bind(this),\n              gestureend: this._gestureend.bind(this)\n            });\n\n            this._toggleDragZoomEvents();\n          },\n          _mouseleave: function (e) {\n            if (this._hoveredPoint) {\n              this._hoveredPoint.out(this, e);\n\n              this._hoveredPoint = null;\n            }\n\n            if (this._plotArea.hovered) {\n              this.trigger(PLOT_AREA_LEAVE);\n              this._plotArea.hovered = false;\n            }\n          },\n          _cancelDomEvents: function () {\n            if (this.domEvents && this.domEvents.cancel) {\n              this.domEvents.cancel();\n            }\n          },\n          _gesturestart: function (e) {\n            if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n              this._gestureDistance = e.distance;\n\n              this._unsetActivePoint();\n\n              this.surface.suspendTracking();\n            }\n          },\n          _gestureend: function (e) {\n            if (this._zooming && !this._stopChartHandlers(e)) {\n              if (this.surface) {\n                this.surface.resumeTracking();\n              }\n\n              this._zooming = false;\n              this.trigger(ZOOM_END, {});\n            }\n          },\n          _gesturechange: function (e) {\n            var mousewheelZoom = this._mousewheelZoom;\n\n            if (mousewheelZoom && !this._stopChartHandlers(e)) {\n              e.preventDefault();\n              var previousGestureDistance = this._gestureDistance;\n              var scaleDelta = -e.distance / previousGestureDistance + 1;\n\n              if (Math.abs(scaleDelta) >= 0.1) {\n                scaleDelta = Math.round(scaleDelta * 10);\n                this._gestureDistance = e.distance;\n                var args = {\n                  delta: scaleDelta,\n                  axisRanges: axisRanges(this._plotArea.axes),\n                  originalEvent: e\n                };\n\n                if (this._zooming || !this.trigger(ZOOM_START, args)) {\n                  var coords = this._eventCoordinates(e);\n\n                  if (!this._zooming) {\n                    this._zooming = true;\n                  }\n\n                  var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);\n\n                  if (ranges && !this.trigger(ZOOM, args)) {\n                    mousewheelZoom.zoom();\n                  }\n                }\n              }\n            }\n          },\n          _mouseout: function (e) {\n            if (e.element) {\n              var element = this._drawingChartElement(e.element, e);\n\n              if (element && element.leave) {\n                element.leave(this, e.originalEvent);\n              }\n            }\n          },\n          _start: function (e) {\n            var coords = this._eventCoordinates(e);\n\n            if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n              return;\n            }\n\n            if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {\n              this._startNavigation(e, coords, DRAG_START);\n            }\n\n            if (this._pannable && this._pannable.start(e)) {\n              this.surface.suspendTracking();\n\n              this._unsetActivePoint();\n\n              this._suppressHover = true;\n              this.chartService.panning = true;\n            }\n\n            if (this._zoomSelection) {\n              if (this._zoomSelection.start(e)) {\n                this.trigger(ZOOM_START, {\n                  axisRanges: axisRanges(this._plotArea.axes),\n                  originalEvent: e\n                });\n              }\n            }\n          },\n          _move: function (e) {\n            var ref = this;\n            var state = ref._navState;\n            var pannable = ref._pannable;\n\n            if (this._stopChartHandlers(e)) {\n              return;\n            }\n\n            if (pannable) {\n              var ranges = pannable.move(e);\n\n              if (ranges && !this.trigger(DRAG, {\n                axisRanges: ranges,\n                originalEvent: e\n              })) {\n                pannable.pan();\n              }\n            } else if (state) {\n              var ranges$1 = {};\n              var axes = state.axes;\n\n              for (var i = 0; i < axes.length; i++) {\n                var currentAxis = axes[i];\n                var axisName = currentAxis.options.name;\n\n                if (axisName) {\n                  var axis = currentAxis.options.vertical ? e.y : e.x;\n                  var delta = axis.startLocation - axis.location;\n\n                  if (delta !== 0) {\n                    ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);\n                  }\n                }\n              }\n\n              state.axisRanges = ranges$1;\n              this.trigger(DRAG, {\n                axisRanges: ranges$1,\n                originalEvent: e\n              });\n            }\n\n            if (this._zoomSelection) {\n              this._zoomSelection.move(e);\n            }\n          },\n          _end: function (e) {\n            if (this._stopChartHandlers(e)) {\n              return;\n            }\n\n            var pannable = this._pannable;\n\n            if (pannable && pannable.end(e)) {\n              this.surface.resumeTracking();\n              this.trigger(DRAG_END, {\n                axisRanges: axisRanges(this._plotArea.axes),\n                originalEvent: e\n              });\n              this._suppressHover = false;\n              this.chartService.panning = false;\n            } else {\n              this._endNavigation(e, DRAG_END);\n            }\n\n            if (this._zoomSelection) {\n              var ranges = this._zoomSelection.end(e);\n\n              if (ranges && !this.trigger(ZOOM, {\n                axisRanges: ranges,\n                originalEvent: e\n              })) {\n                this._zoomSelection.zoom();\n\n                this.trigger(ZOOM_END, {\n                  axisRanges: ranges,\n                  originalEvent: e\n                });\n              }\n            }\n          },\n          _stopChartHandlers: function (e) {\n            var selections = this._selections || [];\n\n            if (!selections.length) {\n              return false;\n            }\n\n            var coords = this._eventCoordinates(e);\n\n            var pane = this._plotArea.paneByPoint(coords);\n\n            if (pane) {\n              for (var idx = 0; idx < selections.length; idx++) {\n                if (selections[idx].onPane(pane)) {\n                  return true;\n                }\n              }\n            }\n          },\n          _mousewheelZoomRate: function () {\n            var zoomable = this.options.zoomable;\n            var mousewheel = (zoomable || {}).mousewheel || {};\n            return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);\n          },\n          _mousewheel: function (e) {\n            var this$1 = this;\n            var delta = dataviz.mousewheelDelta(e);\n            var mousewheelZoom = this._mousewheelZoom;\n\n            var coords = this._eventCoordinates(e);\n\n            if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n              return;\n            }\n\n            if (mousewheelZoom) {\n              var args = {\n                delta: delta,\n                axisRanges: axisRanges(this._plotArea.axes),\n                originalEvent: e\n              };\n\n              if (this._zooming || !this.trigger(ZOOM_START, args)) {\n                e.preventDefault();\n\n                if (!this._zooming) {\n                  this._unsetActivePoint();\n\n                  this.surface.suspendTracking();\n                  this._zooming = true;\n                }\n\n                if (this._mwTimeout) {\n                  clearTimeout(this._mwTimeout);\n                }\n\n                args.axisRanges = mousewheelZoom.updateRanges(delta, coords);\n\n                if (args.axisRanges && !this.trigger(ZOOM, args)) {\n                  mousewheelZoom.zoom();\n                }\n\n                this._mwTimeout = setTimeout(function () {\n                  this$1.trigger(ZOOM_END, args);\n                  this$1._zooming = false;\n\n                  if (this$1.surface) {\n                    this$1.surface.resumeTracking();\n                  }\n                }, MOUSEWHEEL_DELAY);\n              }\n            } else {\n              var state = this._navState;\n\n              if (!state) {\n                var prevented = this._startNavigation(e, coords, ZOOM_START);\n\n                if (!prevented) {\n                  state = this._navState;\n                }\n              }\n\n              if (state) {\n                var totalDelta = state.totalDelta || delta;\n                state.totalDelta = totalDelta + delta;\n                var axes = this._navState.axes;\n                var ranges = {};\n\n                for (var i = 0; i < axes.length; i++) {\n                  var currentAxis = axes[i];\n                  var axisName = currentAxis.options.name;\n\n                  if (axisName) {\n                    ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);\n                  }\n                }\n\n                this.trigger(ZOOM, {\n                  delta: delta,\n                  axisRanges: ranges,\n                  originalEvent: e\n                });\n\n                if (this._mwTimeout) {\n                  clearTimeout(this._mwTimeout);\n                }\n\n                this._mwTimeout = setTimeout(function () {\n                  this$1._endNavigation(e, ZOOM_END);\n                }, MOUSEWHEEL_DELAY);\n              }\n            }\n          },\n          _startNavigation: function (e, coords, chartEvent) {\n            var plotArea = this._model._plotArea;\n            var pane = plotArea.findPointPane(coords);\n            var axes = plotArea.axes.slice(0);\n\n            if (!pane) {\n              return;\n            }\n\n            var ranges = axisRanges(axes);\n            var prevented = this.trigger(chartEvent, {\n              axisRanges: ranges,\n              originalEvent: e\n            });\n\n            if (prevented) {\n              this._cancelDomEvents();\n            } else {\n              this._suppressHover = true;\n\n              this._unsetActivePoint();\n\n              this._navState = {\n                axisRanges: ranges,\n                pane: pane,\n                axes: axes\n              };\n            }\n          },\n          _endNavigation: function (e, chartEvent) {\n            if (this._navState) {\n              this.trigger(chartEvent, {\n                axisRanges: this._navState.axisRanges,\n                originalEvent: e\n              });\n              this._suppressHover = false;\n              this._navState = null;\n            }\n          },\n          _getChartElement: function (e, match) {\n            var element = this.surface.eventTarget(e);\n\n            if (element) {\n              return this._drawingChartElement(element, e, match);\n            }\n          },\n          _drawingChartElement: function (element, e, match) {\n            var current = element;\n            var chartElement;\n\n            while (current && !chartElement) {\n              chartElement = current.chartElement;\n              current = current.parent;\n            }\n\n            if (chartElement) {\n              if (chartElement.aliasFor) {\n                chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n              }\n\n              if (match) {\n                chartElement = chartElement.closest(match);\n\n                if (chartElement && chartElement.aliasFor) {\n                  chartElement = chartElement.aliasFor();\n                }\n              }\n\n              return chartElement;\n            }\n          },\n          _eventCoordinates: function (e) {\n            var coordinates = dataviz.eventCoordinates(e);\n            return this._toModelCoordinates(coordinates.x, coordinates.y);\n          },\n          _elementPadding: function () {\n            if (!this._padding) {\n              var ref = elementStyles(this.element, [\"paddingLeft\", \"paddingTop\"]);\n              var paddingLeft = ref.paddingLeft;\n              var paddingTop = ref.paddingTop;\n              this._padding = {\n                top: paddingTop,\n                left: paddingLeft\n              };\n            }\n\n            return this._padding;\n          },\n          _toDocumentCoordinates: function (point) {\n            var padding = this._elementPadding();\n\n            var offset = dataviz.elementOffset(this.element);\n            return {\n              left: round(point.x + padding.left + offset.left),\n              top: round(point.y + padding.top + offset.top)\n            };\n          },\n          _toModelCoordinates: function (clientX, clientY) {\n            var element = this.element;\n            var offset = dataviz.elementOffset(element);\n\n            var padding = this._elementPadding();\n\n            var inverseTransform = dataviz.elementScale(element).invert();\n            var point = new GeometryPoint(clientX - offset.left - padding.left, clientY - offset.top - padding.top).transform(inverseTransform);\n            return new Point(point.x, point.y);\n          },\n          _tap: function (e) {\n            var this$1 = this;\n            var drawingElement = this.surface.eventTarget(e);\n\n            var element = this._drawingChartElement(drawingElement, e);\n\n            var sharedTooltip = this._sharedTooltip();\n\n            if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n              this._unsetActivePoint();\n            }\n\n            if (sharedTooltip) {\n              this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n            }\n\n            this._propagateClick(element, e); //part of fix for hover issue on windows touch\n\n\n            this.handlingTap = true;\n            setTimeout(function () {\n              this$1.handlingTap = false;\n            }, 0);\n          },\n          _click: function (e) {\n            var element = this._getChartElement(e);\n\n            this._propagateClick(element, e);\n          },\n          _propagateClick: function (element, e) {\n            var this$1 = this;\n            var current = element;\n\n            while (current) {\n              if (current.click) {\n                current.click(this$1, e);\n              }\n\n              current = current.parent;\n            }\n          },\n          _startHover: function (element, e) {\n            if (this._suppressHover) {\n              return false;\n            }\n\n            var point = this._drawingChartElement(element, e, function (element) {\n              return (element.hover || element.over) && !(element instanceof PlotAreaBase);\n            });\n\n            var activePoint = this._activePoint;\n            var multipleSeries = this._plotArea.series.length > 1;\n\n            var hasInactiveOpacity = this._hasInactiveOpacity();\n\n            this._updateHoveredPoint(point, e);\n\n            if (point && activePoint !== point && point.hover) {\n              this._activePoint = point;\n\n              if (!this._sharedTooltip() && !point.hover(this, e)) {\n                this._displayTooltip(point);\n\n                if (hasInactiveOpacity) {\n                  this._displayInactiveOpacity(point, multipleSeries);\n                } else {\n                  this._highlight.show(point);\n                }\n              }\n            } else if (!point && hasInactiveOpacity) {\n              if (multipleSeries && this._activeChartInstance) {\n                this._updateSeriesOpacity(point, true);\n\n                this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n\n                this._activeChartInstance = null;\n              }\n\n              this._highlight && this._highlight.hide();\n              this._activePoint = null;\n            }\n\n            return point;\n          },\n          _displayTooltip: function (point) {\n            var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n\n            if (tooltipOptions.visible) {\n              this._tooltip.show(point);\n            }\n          },\n          _displayInactiveOpacity: function (activePoint, multipleSeries, highlightPoints) {\n            var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);\n\n            if (!chartInstance) {\n              return;\n            }\n\n            if (multipleSeries) {\n              this._updateSeriesOpacity(activePoint);\n\n              this._applySeriesOpacity(chartInstance.children, null, true);\n\n              this._applySeriesOpacity(chartInstance.children, activePoint.series);\n\n              this._highlight.show(highlightPoints || activePoint);\n            } else {\n              var inactivePoints;\n\n              if (!chartInstance.supportsPointInactiveOpacity()) {\n                this._highlight.show(activePoint);\n\n                return;\n              }\n\n              inactivePoints = this._getInactivePoints(activePoint, chartInstance);\n\n              if (inactivePoints && inactivePoints.length) {\n                this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));\n              }\n            }\n          },\n          _getInactivePoints: function (activePoint, chartInstance) {\n            var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);\n\n            return allPoints.filter(function (point) {\n              return point !== activePoint;\n            });\n          },\n          _getAllPointsOfType: function (container, type) {\n            var this$1 = this;\n            var points = [];\n\n            for (var i = 0; i < container.children.length; i++) {\n              var element = container.children[i];\n\n              if (element.constructor === type) {\n                points.push(element);\n              } else if (element.children && element.children.length) {\n                points = points.concat(this$1._getAllPointsOfType(element, type));\n              }\n            }\n\n            return points;\n          },\n          _updateHoveredPoint: function (point, e) {\n            var hoveredPoint = this._hoveredPoint;\n\n            if (hoveredPoint && hoveredPoint !== point) {\n              hoveredPoint.out(this, e);\n              this._hoveredPoint = null;\n            }\n\n            if (point && hoveredPoint !== point && point.over) {\n              this._hoveredPoint = point;\n              point.over(this, e);\n            }\n          },\n          _updateSeriesOpacity: function (point, resetOpacity) {\n            var this$1 = this;\n            var plotArea = this._plotArea;\n            var length = plotArea.series.length;\n\n            for (var i = 0; i < length; i++) {\n              var currSeries = plotArea.series[i];\n\n              var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);\n\n              var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);\n\n              if (!resetOpacity && currSeries !== point.series) {\n                currSeries.defaultOpacity = defaultOpacity;\n                currSeries.opacity = inactiveOpacity;\n\n                if (currSeries.line) {\n                  currSeries.line.opacity = inactiveOpacity;\n                }\n              } else {\n                currSeries.opacity = defaultOpacity;\n\n                if (currSeries.line) {\n                  currSeries.line.opacity = defaultOpacity;\n                }\n              }\n            }\n          },\n          _applySeriesOpacity: function (elements, activeSeries, reset, series) {\n            var this$1 = this;\n\n            for (var i = 0; i < elements.length; i++) {\n              var element = elements[i];\n              var currSeries = element.series || series;\n              var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;\n\n              if (shouldHighlight && element.visual) {\n                var opacity = series ? series.opacity : element.series.opacity;\n\n                if (currSeries !== activeSeries || reset) {\n                  element.visual.opacity(reset ? 1 : opacity);\n                }\n              }\n\n              if (element.children && element.children.length) {\n                this$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);\n              }\n            }\n          },\n          _chartInstanceFromPoint: function (point) {\n            var chartInstance = point.parent;\n\n            while (chartInstance && !chartInstance.plotArea) {\n              chartInstance = chartInstance.parent;\n            }\n\n            return chartInstance;\n          },\n          _hasInactiveOpacity: function () {\n            var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== undefined;\n            var hasInactiveOpacity = this.options.series.filter(function (s) {\n              return s.highlight.inactiveOpacity !== undefined;\n            }).length > 0;\n            return hasDefaultInactiveOpacity || hasInactiveOpacity;\n          },\n          _getInactiveOpacityForSeries: function (series) {\n            var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;\n            var seriesInactiveOpacity = series.highlight.inactiveOpacity;\n            return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || datavizConstants.DEFAULT_SERIES_OPACITY;\n          },\n          _getDefaultOpacityForSeries: function (series) {\n            return series.defaultOpacity || series.opacity || datavizConstants.DEFAULT_SERIES_OPACITY;\n          },\n          _mouseover: function (e) {\n            var point = this._startHover(e.element, e.originalEvent);\n\n            if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n              this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n              var obj;\n              bindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));\n            }\n          },\n          _mouseMoveTracking: function (e) {\n            var ref = this;\n            var options = ref.options;\n            var tooltip = ref._tooltip;\n            var highlight = ref._highlight;\n            var point = ref._activePoint;\n\n            var coords = this._eventCoordinates(e);\n\n            if (this._plotArea.box.containsPoint(coords)) {\n              if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n                var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n\n                if (seriesPoint && seriesPoint !== point) {\n                  this._activePoint = seriesPoint;\n\n                  if (!seriesPoint.hover(this, e)) {\n                    var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n\n                    if (tooltipOptions.visible) {\n                      tooltip.show(seriesPoint);\n                    }\n\n                    highlight.show(seriesPoint);\n                  }\n                }\n              }\n            } else {\n              var obj;\n              unbindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));\n\n              this._unsetActivePoint();\n\n              this._mouseMoveTrackHandler = null;\n            }\n          },\n          _mousemove: function (e) {\n            var coords = this._eventCoordinates(e);\n\n            var plotArea = this._plotArea;\n\n            this._trackCrosshairs(coords);\n\n            if (plotArea.hover) {\n              var overPlotArea = plotArea.backgroundContainsPoint(coords);\n\n              if (overPlotArea) {\n                plotArea.hovered = true;\n\n                this._plotArea.hover(this, e);\n              } else if (plotArea.hovered && !overPlotArea) {\n                this.trigger(PLOT_AREA_LEAVE);\n                plotArea.hovered = false;\n              }\n            }\n\n            if (this._sharedTooltip()) {\n              this._trackSharedTooltip(coords, e);\n            }\n          },\n          _trackCrosshairs: function (coords) {\n            var crosshairs = this._plotArea.crosshairs;\n\n            for (var i = 0; i < crosshairs.length; i++) {\n              var current = crosshairs[i];\n\n              if (current.box.containsPoint(coords)) {\n                current.showAt(coords);\n              } else {\n                current.hide();\n              }\n            }\n          },\n          _trackSharedTooltip: function (coords, e, toggle) {\n            if (this._suppressHover) {\n              return;\n            }\n\n            var ref = this;\n            var tooltipOptions = ref.options.tooltip;\n            var plotArea = ref._plotArea;\n            var categoryAxis = ref._plotArea.categoryAxis;\n            var tooltip = ref._tooltip;\n            var highlight = ref._highlight;\n\n            if (plotArea.backgroundContainsPoint(coords)) {\n              var index = categoryAxis.pointCategoryIndex(coords);\n\n              if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {\n                var points = plotArea.pointsByCategoryIndex(index);\n                var pointArgs = points.map(function (point) {\n                  return point.eventArgs(e);\n                });\n                var hoverArgs = pointArgs[0] || {};\n                hoverArgs.categoryPoints = pointArgs;\n\n                if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n                  if (tooltipOptions.visible) {\n                    tooltip.showAt(points, coords);\n                  }\n\n                  highlight.show(points);\n                  this._sharedHighlight = true;\n                } else {\n                  tooltip.hide();\n                }\n\n                this._tooltipCategoryIx = index;\n              } else if (toggle && this._sharedHighlight) {\n                highlight.hide();\n                tooltip.hide();\n                this._sharedHighlight = false;\n              }\n            } else if (this._sharedHighlight) {\n              highlight.hide();\n              tooltip.hide();\n              this._tooltipCategoryIx = null;\n              this._sharedHighlight = false;\n            }\n          },\n          hideElements: function (options) {\n            var plotArea = this._plotArea;\n\n            this._mousemove.cancel();\n\n            plotArea.hideCrosshairs();\n\n            this._unsetActivePoint(options);\n          },\n          _unsetActivePoint: function (options) {\n            var ref = this;\n            var tooltip = ref._tooltip;\n            var highlight = ref._highlight;\n            this._activePoint = null;\n            this._hoveredPoint = null;\n\n            if (tooltip && !(options && options.keepTooltipOpen)) {\n              tooltip.hide();\n            }\n\n            this._tooltipCategoryIx = null;\n            this._sharedHighlight = false;\n\n            if (highlight) {\n              highlight.hide();\n            }\n          },\n          _deferRedraw: function () {\n            this._redraw();\n          },\n          _clearRedrawTimeout: function () {\n            if (this._redrawTimeout) {\n              clearInterval(this._redrawTimeout);\n              this._redrawTimeout = null;\n            }\n          },\n          bindCategories: function () {\n            var this$1 = this;\n            var options = this.options;\n            var definitions = [].concat(options.categoryAxis);\n\n            for (var axisIx = 0; axisIx < definitions.length; axisIx++) {\n              var axis = definitions[axisIx];\n\n              if (axis.autoBind !== false) {\n                this$1.bindCategoryAxisFromSeries(axis, axisIx);\n              }\n            }\n          },\n          bindCategoryAxisFromSeries: function (axis, axisIx) {\n            var this$1 = this;\n            var series = this.options.series;\n            var seriesLength = series.length;\n            var uniqueCategories = new dataviz.HashMap(); //perf improvement in case type category with dates\n\n            var items = [];\n            var bindable = false;\n            var dateAxis;\n\n            for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n              var s = series[seriesIx];\n              var onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;\n              var data = s.data;\n              var dataLength = data.length;\n              var bind = s.categoryField && onAxis;\n              bindable = bind || bindable;\n\n              if (bind && dataLength > 0) {\n                dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\n                var getFn = dateAxis ? getDateField : getField;\n\n                for (var dataIx = 0; dataIx < dataLength; dataIx++) {\n                  var dataRow = data[dataIx];\n                  var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);\n\n                  if (dateAxis || !uniqueCategories.get(category)) {\n                    items.push([category, dataRow]);\n\n                    if (!dateAxis) {\n                      uniqueCategories.set(category, true);\n                    }\n                  }\n                }\n              }\n            }\n\n            if (items.length > 0) {\n              if (dateAxis) {\n                items = uniqueDates(items, function (a, b) {\n                  return dataviz.dateComparer(a[0], b[0]);\n                });\n              }\n\n              var result = transpose(items);\n              axis.categories = result[0];\n            } else if (bindable) {\n              axis.categories = [];\n            }\n          },\n          _isBindable: function (series) {\n            var valueFields = SeriesBinder.current.valueFields(series);\n            var result = true;\n\n            for (var i = 0; i < valueFields.length; i++) {\n              var field = valueFields[i];\n\n              if (field === VALUE) {\n                field = \"field\";\n              } else {\n                field = field + \"Field\";\n              }\n\n              if (!defined(series[field])) {\n                result = false;\n                break;\n              }\n            }\n\n            return result;\n          },\n          _noTransitionsRedraw: function () {\n            var options = this.options;\n            var transitionsState;\n\n            if (options.transitions !== false) {\n              options.transitions = false;\n              transitionsState = true;\n            }\n\n            this._redraw();\n\n            if (transitionsState) {\n              options.transitions = true;\n            }\n          },\n          _legendItemHover: function (seriesIndex, pointIndex) {\n            var ref = this;\n            var plotArea = ref._plotArea;\n            var highlight = ref._highlight;\n            var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n            var items;\n\n            if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL])) {\n              items = plotArea.findPoint(function (point) {\n                return point.series.index === seriesIndex && point.index === pointIndex;\n              });\n            } else {\n              items = plotArea.pointsBySeriesIndex(seriesIndex);\n            }\n\n            if (this._hasInactiveOpacity() && currentSeries.visible && items) {\n              var multipleSeries = plotArea.series.length > 1;\n              var point = items.length ? items[0] : items;\n\n              this._displayInactiveOpacity(point, multipleSeries, items);\n            } else {\n              highlight.show(items);\n            }\n          },\n          _shouldAttachMouseMove: function () {\n            return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);\n          },\n          updateMouseMoveHandler: function () {\n            var obj;\n            unbindEvents(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));\n\n            if (this._shouldAttachMouseMove()) {\n              var obj$1;\n              bindEvents(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));\n            }\n          },\n          applyOptions: function (options, theme) {\n            clearMissingValues(this._originalOptions, options);\n            this._originalOptions = deepExtend(this._originalOptions, options);\n            this.options = deepExtend({}, this._originalOptions);\n\n            if (theme) {\n              this._theme = theme;\n              this.chartService.theme = theme;\n            }\n\n            this._initTheme(this.options, this._theme);\n\n            this._toggleDragZoomEvents();\n          },\n          setOptions: function (options, theme) {\n            this.applyOptions(options, theme);\n            this.bindCategories();\n            this.redraw();\n            this.updateMouseMoveHandler();\n          },\n          setDirection: function (rtl) {\n            this.chartService.rtl = Boolean(rtl);\n\n            if (this.surface && this.surface.type === 'svg') {\n              this._destroySurface();\n            }\n          },\n          setIntlService: function (intl) {\n            this.chartService.intl = intl;\n          },\n          noTransitionsRedraw: function () {\n            this._noTransitionsRedraw();\n          },\n          destroy: function () {\n            this._destroyed = true;\n            var obj;\n            unbindEvents(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));\n\n            if (this.domEvents) {\n              this.domEvents.destroy();\n              delete this.domEvents;\n            }\n\n            if (this._mouseMoveTrackHandler) {\n              var obj$1;\n              unbindEvents(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));\n            }\n\n            this._destroyView();\n\n            this._destroySurface();\n\n            this._clearRedrawTimeout();\n          },\n          _destroySurface: function () {\n            var surface = this.surface;\n\n            if (surface) {\n              surface.unbind(\"mouseenter\", this._surfaceMouseenterHandler);\n              surface.unbind(\"mouseleave\", this._surfaceMouseleaveHandler);\n              surface.destroy();\n              this.surface = null;\n            }\n          },\n          _destroySelections: function () {\n            var selections = this._selections;\n\n            if (selections) {\n              while (selections.length > 0) {\n                selections.shift().destroy();\n              }\n            }\n          },\n          _destroyView: function () {\n            var model = this._model;\n\n            if (model) {\n              model.destroy();\n              this._model = null;\n            }\n\n            this._unsetActivePoint();\n\n            this._destroySelections();\n\n            if (this._tooltip) {\n              this._tooltip.destroy();\n            }\n\n            if (this._highlight) {\n              this._highlight.destroy();\n            }\n\n            if (this._zoomSelection) {\n              this._zoomSelection.destroy();\n\n              delete this._zoomSelection;\n            }\n\n            if (this._pannable) {\n              this._pannable.destroy();\n\n              delete this._pannable;\n            }\n\n            if (this._mousewheelZoom) {\n              this._mousewheelZoom.destroy();\n\n              delete this._mousewheelZoom;\n            }\n          }\n        });\n\n        function resolveAxisAliases(options) {\n          var aliases = AXIS_NAMES;\n\n          for (var idx = 0; idx < aliases.length; idx++) {\n            var alias = aliases[idx] + \"Axes\";\n\n            if (options[alias]) {\n              options[aliases[idx] + \"Axis\"] = options[alias];\n              delete options[alias];\n            }\n          }\n        }\n\n        function pointByCategoryName(points, name) {\n          if (points) {\n            for (var idx = 0; idx < points.length; idx++) {\n              if (points[idx].category === name) {\n                return [points[idx]];\n              }\n            }\n          }\n        }\n\n        function applyAxisDefaults(options, themeOptions) {\n          var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};\n          var axisName, axisDefaults, axes;\n\n          function mapAxisOptions(axisOptions) {\n            var axisColor = (axisOptions || {}).color || axisDefaults.color;\n            var result = deepExtend({}, themeAxisDefaults, themeAxisDefaults[axisName], axisDefaults, axisDefaults[axisName], {\n              line: {\n                color: axisColor\n              },\n              labels: {\n                color: axisColor\n              },\n              title: {\n                color: axisColor\n              }\n            }, axisOptions);\n            delete result[axisName];\n            return result;\n          }\n\n          for (var idx = 0; idx < AXIS_NAMES.length; idx++) {\n            axisName = AXIS_NAMES[idx] + \"Axis\";\n            axisDefaults = options.axisDefaults || {};\n            axes = [].concat(options[axisName]);\n            axes = axes.map(mapAxisOptions);\n            options[axisName] = axes.length > 1 ? axes : axes[0];\n          }\n        }\n\n        function applySeriesDefaults(options, themeOptions) {\n          var series = options.series;\n          var seriesLength = series.length;\n          var seriesDefaults = options.seriesDefaults;\n          var commonDefaults = deepExtend({}, options.seriesDefaults);\n          var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n          var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n          cleanupNestedSeriesDefaults(commonDefaults);\n          cleanupNestedSeriesDefaults(commonThemeDefaults);\n\n          for (var i = 0; i < seriesLength; i++) {\n            var seriesType = series[i].type || options.seriesDefaults.type;\n            var baseOptions = deepExtend({\n              data: []\n            }, commonThemeDefaults, themeSeriesDefaults[seriesType], {\n              tooltip: options.tooltip\n            }, commonDefaults, seriesDefaults[seriesType]);\n            series[i]._defaults = baseOptions;\n            series[i] = deepExtend({}, baseOptions, series[i]);\n            series[i].data = series[i].data || [];\n          }\n        }\n\n        function cleanupNestedSeriesDefaults(seriesDefaults) {\n          delete seriesDefaults.bar;\n          delete seriesDefaults.column;\n          delete seriesDefaults.rangeColumn;\n          delete seriesDefaults.line;\n          delete seriesDefaults.verticalLine;\n          delete seriesDefaults.pie;\n          delete seriesDefaults.donut;\n          delete seriesDefaults.area;\n          delete seriesDefaults.verticalArea;\n          delete seriesDefaults.scatter;\n          delete seriesDefaults.scatterLine;\n          delete seriesDefaults.bubble;\n          delete seriesDefaults.candlestick;\n          delete seriesDefaults.ohlc;\n          delete seriesDefaults.boxPlot;\n          delete seriesDefaults.bullet;\n          delete seriesDefaults.verticalBullet;\n          delete seriesDefaults.polarArea;\n          delete seriesDefaults.polarLine;\n          delete seriesDefaults.radarArea;\n          delete seriesDefaults.radarLine;\n          delete seriesDefaults.waterfall;\n        }\n\n        function axisRanges(axes) {\n          var ranges = {};\n\n          for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i];\n            var axisName = axis.options.name;\n\n            if (axisName) {\n              ranges[axisName] = axis.range();\n            }\n          }\n\n          return ranges;\n        }\n\n        function sortDates(dates, comparer) {\n          if (comparer === void 0) {\n            comparer = dataviz.dateComparer;\n          }\n\n          for (var i = 1, length = dates.length; i < length; i++) {\n            if (comparer(dates[i], dates[i - 1]) < 0) {\n              dates.sort(comparer);\n              break;\n            }\n          }\n\n          return dates;\n        }\n\n        function uniqueDates(srcDates, comparer) {\n          if (comparer === void 0) {\n            comparer = dataviz.dateComparer;\n          }\n\n          var dates = sortDates(srcDates, comparer);\n          var length = dates.length;\n          var result = length > 0 ? [dates[0]] : [];\n\n          for (var i = 1; i < length; i++) {\n            if (comparer(dates[i], last(result)) !== 0) {\n              result.push(dates[i]);\n            }\n          }\n\n          return result;\n        }\n\n        function transpose(rows) {\n          var rowCount = rows.length;\n          var result = [];\n\n          for (var rowIx = 0; rowIx < rowCount; rowIx++) {\n            var row = rows[rowIx];\n            var colCount = row.length;\n\n            for (var colIx = 0; colIx < colCount; colIx++) {\n              result[colIx] = result[colIx] || [];\n              result[colIx].push(row[colIx]);\n            }\n          }\n\n          return result;\n        }\n\n        var DATA_FIELDS = ['data', 'categories'];\n\n        function clearMissingValues(originalOptions, options) {\n          for (var field in options) {\n            if (!inArray(field, DATA_FIELDS) && options.hasOwnProperty(field)) {\n              var fieldValue = options[field];\n              var originalValue = originalOptions[field];\n\n              if (defined(originalValue)) {\n                var nullValue = fieldValue === null;\n\n                if (nullValue || !defined(fieldValue)) {\n                  delete originalOptions[field];\n\n                  if (nullValue) {\n                    delete options[field];\n                  }\n                } else if (originalValue && isObject(fieldValue)) {\n                  if (isObject(originalValue)) {\n                    clearMissingValues(originalValue, fieldValue);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        function triggerPaneRender(panes) {\n          for (var idx = 0; idx < panes.length; idx++) {\n            panes[idx].notifyRender();\n          }\n        }\n\n        setDefaultOptions(Chart, {\n          renderAs: \"\",\n          chartArea: {},\n          legend: {\n            visible: true,\n            labels: {}\n          },\n          categoryAxis: {},\n          seriesDefaults: {\n            type: COLUMN,\n            data: [],\n            highlight: {\n              visible: true\n            },\n            labels: {},\n            negativeValues: {\n              visible: false\n            }\n          },\n          series: [],\n          seriesColors: null,\n          tooltip: {\n            visible: false\n          },\n          transitions: true,\n          valueAxis: {},\n          plotArea: {},\n          title: {},\n          xAxis: {},\n          yAxis: {},\n          panes: [{}],\n          pannable: false,\n          zoomable: false\n        });\n        kendo.deepExtend(kendo.dataviz, {\n          constants: constants,\n          Aggregates: Aggregates,\n          AreaChart: AreaChart,\n          AreaSegment: AreaSegment,\n          AxisGroupRangeTracker: AxisGroupRangeTracker,\n          Bar: Bar,\n          BarChart: BarChart,\n          BarLabel: BarLabel,\n          BoxPlotChart: BoxPlotChart,\n          BoxPlot: BoxPlot,\n          BubbleChart: BubbleChart,\n          Bullet: Bullet,\n          BulletChart: BulletChart,\n          CandlestickChart: CandlestickChart,\n          Candlestick: Candlestick,\n          CategoricalChart: CategoricalChart,\n          CategoricalErrorBar: CategoricalErrorBar,\n          CategoricalPlotArea: CategoricalPlotArea,\n          Chart: Chart,\n          ChartContainer: ChartContainer,\n          ClipAnimation: ClipAnimation,\n          ClusterLayout: ClusterLayout,\n          Crosshair: Crosshair,\n          CrosshairTooltip: CrosshairTooltip,\n          DefaultAggregates: DefaultAggregates,\n          DonutChart: DonutChart,\n          DonutPlotArea: DonutPlotArea,\n          DonutSegment: DonutSegment,\n          ErrorBarBase: ErrorBarBase,\n          ErrorRangeCalculator: ErrorRangeCalculator,\n          Highlight: Highlight,\n          SharedTooltip: SharedTooltip,\n          Legend: Legend,\n          LegendItem: LegendItem,\n          LegendLayout: LegendLayout,\n          LineChart: LineChart,\n          LinePoint: LinePoint,\n          LineSegment: LineSegment,\n          Pane: Pane,\n          PieAnimation: PieAnimation,\n          PieChart: PieChart,\n          PieChartMixin: PieChartMixin,\n          PiePlotArea: PiePlotArea,\n          PieSegment: PieSegment,\n          PlotAreaBase: PlotAreaBase,\n          PlotAreaEventsMixin: PlotAreaEventsMixin,\n          PlotAreaFactory: PlotAreaFactory,\n          PointEventsMixin: PointEventsMixin,\n          RangeBar: RangeBar,\n          RangeBarChart: RangeBarChart,\n          RangeAreaPoint: RangeAreaPoint,\n          RangeAreaChart: RangeAreaChart,\n          ScatterChart: ScatterChart,\n          ScatterErrorBar: ScatterErrorBar,\n          ScatterLineChart: ScatterLineChart,\n          Selection: Selection,\n          SeriesAggregator: SeriesAggregator,\n          SeriesBinder: SeriesBinder,\n          SplineSegment: SplineSegment,\n          SplineAreaSegment: SplineAreaSegment,\n          StackWrap: StackWrap,\n          Tooltip: Tooltip,\n          OHLCChart: OHLCChart,\n          OHLCPoint: OHLCPoint,\n          WaterfallChart: WaterfallChart,\n          WaterfallSegment: WaterfallSegment,\n          XYPlotArea: XYPlotArea,\n          MousewheelZoom: MousewheelZoom,\n          ZoomSelection: ZoomSelection,\n          Pannable: Pannable,\n          ChartAxis: ChartAxis,\n          ChartPane: ChartPane,\n          ChartPlotArea: ChartPlotArea,\n          findAxisByName: findAxisByName,\n          anyHasZIndex: anyHasZIndex,\n          appendIfNotNull: appendIfNotNull,\n          areNumbers: areNumbers,\n          bindSegments: bindSegments,\n          categoriesCount: categoriesCount,\n          countNumbers: countNumbers,\n          equalsIgnoreCase: equalsIgnoreCase,\n          evalOptions: evalOptions,\n          filterSeriesByType: filterSeriesByType,\n          getDateField: getDateField,\n          getField: getField,\n          hasGradientOverlay: hasGradientOverlay,\n          hasValue: hasValue,\n          isDateAxis: isDateAxis,\n          segmentVisible: segmentVisible,\n          singleItemOrArray: singleItemOrArray,\n          createOutOfRangePoints: createOutOfRangePoints\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  896:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.core\");\n    /***/\n  },\n\n  /***/\n  897:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../../kendo.color\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}