{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(998);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  989:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./format\");\n    /***/\n  },\n\n  /***/\n  998:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(989)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            Editor = kendo.ui.editor,\n            formats = kendo.ui.Editor.fn.options.formats,\n            EditorUtils = Editor.EditorUtils,\n            Tool = Editor.Tool,\n            ToolTemplate = Editor.ToolTemplate,\n            FormatTool = Editor.FormatTool,\n            dom = Editor.Dom,\n            RangeUtils = Editor.RangeUtils,\n            extend = $.extend,\n            registerTool = Editor.EditorUtils.registerTool,\n            registerFormat = Editor.EditorUtils.registerFormat,\n            MOUSEDOWN_NS = \"mousedown.kendoEditor\",\n            KEYDOWN_NS = \"keydown.kendoEditor\",\n            KMARKER = \"k-marker\";\n        var InlineFormatFinder = Class.extend({\n          init: function (format) {\n            this.format = format;\n          },\n          numberOfSiblings: function (referenceNode) {\n            var textNodesCount = 0,\n                elementNodesCount = 0,\n                markerCount = 0,\n                parentNode = referenceNode.parentNode,\n                node;\n\n            for (node = parentNode.firstChild; node; node = node.nextSibling) {\n              if (node != referenceNode) {\n                if (node.className == KMARKER) {\n                  markerCount++;\n                } else if (node.nodeType == 3) {\n                  textNodesCount++;\n                } else {\n                  elementNodesCount++;\n                }\n              }\n            }\n\n            if (markerCount > 1 && parentNode.firstChild.className == KMARKER && parentNode.lastChild.className == KMARKER) {\n              // full node selection\n              return 0;\n            } else {\n              return elementNodesCount + textNodesCount;\n            }\n          },\n          findSuitable: function (sourceNode, skip) {\n            if (!skip && this.numberOfSiblings(sourceNode) > 0) {\n              return null;\n            }\n\n            var node = sourceNode.parentNode;\n            var tags = this.format[0].tags;\n\n            while (!dom.ofType(node, tags)) {\n              if (this.numberOfSiblings(node) > 0) {\n                return null;\n              }\n\n              node = node.parentNode;\n            }\n\n            return node;\n          },\n          findFormat: function (sourceNode) {\n            var format = this.format,\n                attrEquals = dom.attrEquals,\n                i,\n                len,\n                node,\n                tags,\n                attributes;\n\n            for (i = 0, len = format.length; i < len; i++) {\n              node = sourceNode;\n              tags = format[i].tags;\n              attributes = format[i].attr;\n\n              if (node && dom.ofType(node, tags) && attrEquals(node, attributes)) {\n                return node;\n              }\n\n              while (node) {\n                node = dom.parentOfType(node, tags);\n\n                if (node && attrEquals(node, attributes)) {\n                  return node;\n                }\n              }\n            }\n\n            return null;\n          },\n          isFormatted: function (nodes) {\n            var i, len;\n\n            for (i = 0, len = nodes.length; i < len; i++) {\n              if (this.findFormat(nodes[i])) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        var InlineFormatter = Class.extend({\n          init: function (format, values) {\n            this.finder = new InlineFormatFinder(format);\n            this.attributes = extend({}, format[0].attr, values);\n            this.tag = format[0].tags[0];\n          },\n          wrap: function (node) {\n            return dom.wrap(node, dom.create(node.ownerDocument, this.tag, this.attributes));\n          },\n          activate: function (range, nodes) {\n            if (this.finder.isFormatted(nodes)) {\n              this.split(range);\n              this.remove(nodes);\n            } else {\n              this.apply(nodes);\n            }\n          },\n          toggle: function (range) {\n            var textNodes = this.immutables() ? RangeUtils.editableTextNodes : RangeUtils.textNodes;\n            var nodes = textNodes(range);\n\n            if (nodes.length > 0) {\n              this.activate(range, nodes);\n            }\n          },\n          immutables: function () {\n            return this.editor && this.editor.options.immutables;\n          },\n          apply: function (nodes) {\n            var formatNodes = [];\n            var i, l, node, formatNode;\n\n            if (nodes.length > 1) {\n              for (i = 0, l = nodes.length; i < l; i++) {\n                node = nodes[i];\n                formatNode = this.format(node, true);\n                formatNodes.push(formatNode);\n              }\n            } else {\n              node = nodes[0];\n              formatNode = this.format(node, false);\n            }\n\n            this.consolidate(formatNodes);\n          },\n          format: function (node, outerMostInline) {\n            var formatNode = this.finder.findSuitable(node);\n            var attributes = this.attributes;\n            var styleAttr = attributes ? attributes.style || {} : {};\n\n            if (formatNode) {\n              if (dom.is(formatNode, \"font\")) {\n                if (styleAttr.color) {\n                  formatNode.removeAttribute(\"color\");\n                }\n\n                if (styleAttr.fontName) {\n                  formatNode.removeAttribute(\"face\");\n                }\n\n                if (styleAttr.fontSize) {\n                  formatNode.removeAttribute(\"size\");\n                }\n              }\n\n              dom.attr(formatNode, attributes);\n            } else {\n              while (!dom.isBlock(node.parentNode) && node.parentNode.childNodes.length == 1 && node.parentNode.contentEditable !== 'true' && outerMostInline) {\n                node = node.parentNode;\n              }\n\n              formatNode = this.wrap(node);\n            }\n\n            return formatNode;\n          },\n          remove: function (nodes) {\n            var i, l, formatNode;\n\n            for (i = 0, l = nodes.length; i < l; i++) {\n              formatNode = this.finder.findFormat(nodes[i]);\n\n              if (formatNode) {\n                if (this.attributes && this.attributes.style) {\n                  dom.unstyle(formatNode, this.attributes.style);\n\n                  if (!formatNode.style.cssText && !formatNode.attributes[\"class\"]) {\n                    dom.unwrap(formatNode);\n                  }\n                } else {\n                  dom.unwrap(formatNode);\n                }\n              }\n            }\n          },\n          split: function (range) {\n            var nodes = RangeUtils.textNodes(range);\n            var l = nodes.length;\n            var i, formatNode;\n\n            if (l > 0) {\n              for (i = 0; i < l; i++) {\n                formatNode = this.finder.findFormat(nodes[i]);\n\n                if (formatNode) {\n                  RangeUtils.split(range, formatNode, true);\n                }\n              }\n            }\n          },\n          consolidate: function (nodes) {\n            var node, last;\n\n            while (nodes.length > 1) {\n              node = nodes.pop();\n              last = nodes[nodes.length - 1];\n\n              if (node.previousSibling && node.previousSibling.className == KMARKER) {\n                last.appendChild(node.previousSibling);\n              }\n\n              if (node.tagName == last.tagName && node.previousSibling == last && node.style.cssText == last.style.cssText && node.className === last.className) {\n                while (node.firstChild) {\n                  last.appendChild(node.firstChild);\n                }\n\n                dom.remove(node);\n              }\n            }\n          }\n        });\n        var GreedyInlineFormatFinder = InlineFormatFinder.extend({\n          init: function (format, greedyProperty, fontAttr) {\n            this.format = format;\n            this.greedyProperty = greedyProperty;\n            this.fontAttr = fontAttr;\n            InlineFormatFinder.fn.init.call(this, format);\n          },\n          getInlineCssValue: function (node) {\n            var attributes = node.attributes;\n            var trim = kendo.trim;\n            var i, l, attribute, name, attributeValue, css, pair, cssIndex, len;\n            var propertyAndValue, property, value;\n\n            if (!attributes) {\n              return;\n            }\n\n            for (i = 0, l = attributes.length; i < l; i++) {\n              attribute = attributes[i];\n              name = attribute.nodeName;\n              attributeValue = attribute.nodeValue;\n\n              if (attribute.specified && name == \"style\") {\n                css = trim(attributeValue || node.style.cssText).split(\";\");\n\n                for (cssIndex = 0, len = css.length; cssIndex < len; cssIndex++) {\n                  pair = css[cssIndex];\n\n                  if (pair.length) {\n                    propertyAndValue = pair.split(\":\");\n                    property = trim(propertyAndValue[0].toLowerCase());\n                    value = trim(propertyAndValue[1]);\n\n                    if (property != this.greedyProperty) {\n                      continue;\n                    }\n\n                    return property.indexOf(\"color\") >= 0 ? dom.toHex(value) : value;\n                  }\n                }\n              }\n\n              if (this.fontAttr && attribute.specified && name == this.fontAttr) {\n                property = attribute.nodeValue;\n                value = attribute.nodeValue;\n                return property.indexOf(\"color\") >= 0 ? dom.toHex(value) : value;\n              }\n            }\n          },\n          getFormatInner: function (node) {\n            var $node = $(dom.isDataNode(node) ? node.parentNode : node);\n            var parents = $node.parentsUntil(\"[contentEditable]\").addBack().toArray().reverse();\n            var i, len, value;\n\n            for (i = 0, len = parents.length; i < len; i++) {\n              value = this.greedyProperty == \"className\" ? parents[i].className : this.getInlineCssValue(parents[i]);\n\n              if (value) {\n                return value;\n              }\n            }\n\n            return \"inherit\";\n          },\n          getFormat: function (nodes) {\n            var result = this.getFormatInner(nodes[0]),\n                i,\n                len;\n\n            for (i = 1, len = nodes.length; i < len; i++) {\n              if (result != this.getFormatInner(nodes[i])) {\n                return \"\";\n              }\n            }\n\n            return result;\n          },\n          isFormatted: function (nodes) {\n            return this.getFormat(nodes) !== \"\";\n          }\n        });\n        var GreedyInlineFormatter = InlineFormatter.extend({\n          init: function (format, values, greedyProperty) {\n            InlineFormatter.fn.init.call(this, format, values);\n            this.values = values;\n            this.finder = new GreedyInlineFormatFinder(format, greedyProperty);\n\n            if (greedyProperty) {\n              this.greedyProperty = kendo.toCamelCase(greedyProperty);\n            }\n          },\n          activate: function (range, nodes) {\n            var greedyProperty = this.greedyProperty;\n            var action = \"apply\";\n            this.split(range);\n\n            if (greedyProperty && this.values.style[greedyProperty] == \"inherit\") {\n              action = \"remove\";\n            }\n\n            this[action](nodes);\n          }\n        });\n        var InlineFormatTool = FormatTool.extend({\n          init: function (options) {\n            FormatTool.fn.init.call(this, extend(options, {\n              finder: new InlineFormatFinder(options.format),\n              formatter: function () {\n                return new InlineFormatter(options.format);\n              }\n            }));\n          }\n        });\n        var DelayedExecutionTool = Tool.extend({\n          update: function (ui, nodes) {\n            var list = ui.data(this.type);\n            list.close();\n            list.value(this.finder.getFormat(nodes));\n          }\n        });\n        var FontTool = DelayedExecutionTool.extend({\n          init: function (options) {\n            Tool.fn.init.call(this, options); // IE has single selection hence we are using select box instead of combobox\n\n            this.type = kendo.support.browser.msie || kendo.support.touch ? \"kendoDropDownList\" : \"kendoComboBox\";\n            this.format = [{\n              tags: [\"span\", \"font\"]\n            }];\n            this.finder = new GreedyInlineFormatFinder(this.format, options.cssAttr, options.fontAttr);\n          },\n          command: function (commandArguments) {\n            var options = this.options,\n                format = this.format,\n                style = {};\n            return new Editor.FormatCommand(extend(commandArguments, {\n              formatter: function () {\n                style[options.domAttr] = commandArguments.value;\n                return new GreedyInlineFormatter(format, {\n                  style: style\n                }, options.cssAttr);\n              }\n            }));\n          },\n          initialize: function (ui, initOptions) {\n            var editor = initOptions.editor,\n                options = this.options,\n                toolName = options.name,\n                dataSource,\n                range,\n                defaultValue = [];\n\n            if (options.defaultValue) {\n              defaultValue = [{\n                text: editor.options.messages[options.defaultValue[0].text],\n                value: options.defaultValue[0].value\n              }];\n            }\n\n            dataSource = defaultValue.concat(options.items ? options.items : editor.options[toolName] || []);\n            ui.attr({\n              title: initOptions.title\n            });\n            ui[this.type]({\n              dataTextField: \"text\",\n              dataValueField: \"value\",\n              dataSource: dataSource,\n              change: function () {\n                editor._range = range;\n                Tool.exec(editor, toolName, this.value());\n              },\n              close: function () {\n                setTimeout(function () {\n                  editor._deleteSavedRange();\n                }, 0);\n              },\n              highlightFirst: false\n            });\n            ui.closest(\".k-combobox\").removeClass(\"k-\" + toolName).find(\"*\").addBack().attr(\"unselectable\", \"on\");\n            var widget = ui.data(this.type);\n            widget.value(\"inherit\");\n            widget.wrapper.on(MOUSEDOWN_NS, \".k-select,.k-input-button,.k-input\", function () {\n              var newRange = editor.getRange();\n              range = editor._containsRange(newRange) ? newRange : range;\n            }).on(KEYDOWN_NS, function (e) {\n              if (e.keyCode === kendo.keys.ENTER) {\n                editor._deleteSavedRange();\n\n                e.preventDefault();\n              }\n            });\n          }\n        });\n        var ColorTool = Tool.extend({\n          init: function (options) {\n            Tool.fn.init.call(this, options);\n            this.format = [{\n              tags: [\"span\", \"font\"]\n            }];\n            this.finder = new GreedyInlineFormatFinder(this.format, options.cssAttr);\n          },\n          options: {\n            palette: \"websafe\",\n            columns: 18\n          },\n          update: function () {\n            this._widget.close();\n          },\n          command: function (commandArguments) {\n            var options = this.options,\n                format = this.format,\n                style = {};\n            return new Editor.FormatCommand(extend(commandArguments, {\n              formatter: function () {\n                style[options.domAttr] = commandArguments.value;\n                return new GreedyInlineFormatter(format, {\n                  style: style\n                }, options.cssAttr);\n              }\n            }));\n          },\n          initialize: function (ui, initOptions) {\n            var that = this,\n                editor = initOptions.editor,\n                toolName = this.name,\n                options = extend({}, ColorTool.fn.options, this.options),\n                palette = options.palette,\n                columns = options.columns;\n            ui = this._widget = new kendo.ui.ColorPicker(ui, {\n              closeOnSelect: true,\n              views: [\"palette\"],\n              preview: false,\n              input: false,\n              buttons: false,\n              toolIcon: \"k-icon k-i-\" + EditorUtils.getToolCssClass(options.name),\n              palette: palette,\n              columns: columns,\n              change: function () {\n                var color = ui.value();\n\n                if (kendo.support.browser.msie && that.storedRange && that._inputFocused) {\n                  editor.selectRange(that.storedRange);\n                }\n\n                if (color) {\n                  Tool.exec(editor, toolName, color);\n                }\n\n                delete that.storedRange;\n                delete that._inputFocused;\n                editor.focus();\n              },\n              open: function (e) {\n                var picker = e.sender;\n                that.storedRange = editor.getRange();\n\n                picker._popup.element.on(MOUSEDOWN_NS, function (e) {\n                  if (!$(e.target).is(\"input.k-color-value\")) {\n                    e.preventDefault();\n                  }\n                });\n\n                if (!picker._popup.element.is(\"[unselectable='on']\")) {\n                  picker._popup.element.attr({\n                    unselectable: \"on\"\n                  }).find(\"*:not(input)\").attr(\"unselectable\", \"on\").end().find(\"input\").on(\"focus\", function () {\n                    that._inputFocused = true;\n                  });\n                }\n\n                setTimeout(function () {\n                  picker._popup.element.find(\".k-colorpalette\").trigger(\"focus\");\n                });\n              },\n              close: function (e) {\n                e.sender._popup.element.off(MOUSEDOWN_NS);\n\n                if (kendo.support.browser.msie && that.storedRange && that._inputFocused) {\n                  editor.selectRange(that.storedRange);\n                }\n              },\n              activate: function (e) {\n                e.preventDefault();\n\n                if (e.sender._value.toCssRgba() === \"rgba(255, 255, 255, 0)\") {\n                  return;\n                }\n\n                ui.trigger(\"change\");\n              }\n            });\n            ui.wrapper.attr({\n              title: initOptions.title,\n              unselectable: \"on\"\n            }).find(\"*:not(input)\").attr(\"unselectable\", \"on\");\n            ui.value(\"transparent\");\n          }\n        });\n        extend(Editor, {\n          InlineFormatFinder: InlineFormatFinder,\n          InlineFormatter: InlineFormatter,\n          DelayedExecutionTool: DelayedExecutionTool,\n          GreedyInlineFormatFinder: GreedyInlineFormatFinder,\n          GreedyInlineFormatter: GreedyInlineFormatter,\n          InlineFormatTool: InlineFormatTool,\n          FontTool: FontTool,\n          ColorTool: ColorTool\n        });\n        registerFormat(\"bold\", [{\n          tags: [\"strong\", \"b\"]\n        }, {\n          tags: [\"span\"],\n          attr: {\n            style: {\n              fontWeight: \"bold\"\n            }\n          }\n        }]);\n        registerTool(\"bold\", new InlineFormatTool({\n          key: \"B\",\n          ctrl: true,\n          format: formats.bold,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Bold\"\n          })\n        }));\n        registerFormat(\"italic\", [{\n          tags: [\"em\", \"i\"]\n        }, {\n          tags: [\"span\"],\n          attr: {\n            style: {\n              fontStyle: \"italic\"\n            }\n          }\n        }]);\n        registerTool(\"italic\", new InlineFormatTool({\n          key: \"I\",\n          ctrl: true,\n          format: formats.italic,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Italic\"\n          })\n        }));\n        registerFormat(\"underline\", [{\n          tags: [\"span\"],\n          attr: {\n            style: {\n              textDecoration: \"underline\"\n            }\n          }\n        }, {\n          tags: [\"u\"]\n        }]);\n        registerTool(\"underline\", new InlineFormatTool({\n          key: \"U\",\n          ctrl: true,\n          format: formats.underline,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Underline\"\n          })\n        }));\n        registerFormat(\"strikethrough\", [{\n          tags: [\"del\", \"strike\"]\n        }, {\n          tags: [\"span\"],\n          attr: {\n            style: {\n              textDecoration: \"line-through\"\n            }\n          }\n        }]);\n        registerTool(\"strikethrough\", new InlineFormatTool({\n          format: formats.strikethrough,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Strikethrough\"\n          })\n        }));\n        registerFormat(\"superscript\", [{\n          tags: [\"sup\"]\n        }]);\n        registerTool(\"superscript\", new InlineFormatTool({\n          format: formats.superscript,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Superscript\"\n          })\n        }));\n        registerFormat(\"subscript\", [{\n          tags: [\"sub\"]\n        }]);\n        registerTool(\"subscript\", new InlineFormatTool({\n          format: formats.subscript,\n          template: new ToolTemplate({\n            template: EditorUtils.buttonTemplate,\n            title: \"Subscript\"\n          })\n        }));\n        registerTool(\"foreColor\", new ColorTool({\n          cssAttr: \"color\",\n          fontAttr: \"color\",\n          domAttr: \"color\",\n          name: \"foreColor\",\n          template: new ToolTemplate({\n            template: EditorUtils.colorPickerTemplate,\n            title: \"Color\"\n          })\n        }));\n        registerTool(\"backColor\", new ColorTool({\n          cssAttr: \"background-color\",\n          domAttr: \"backgroundColor\",\n          name: \"backColor\",\n          template: new ToolTemplate({\n            template: EditorUtils.colorPickerTemplate,\n            title: \"Background Color\"\n          })\n        }));\n        registerTool(\"fontName\", new FontTool({\n          cssAttr: \"font-family\",\n          fontAttr: \"face\",\n          domAttr: \"fontFamily\",\n          name: \"fontName\",\n          defaultValue: [{\n            text: \"fontNameInherit\",\n            value: \"inherit\"\n          }],\n          template: new ToolTemplate({\n            template: EditorUtils.comboBoxTemplate,\n            title: \"Font Name\"\n          })\n        }));\n        registerTool(\"fontSize\", new FontTool({\n          cssAttr: \"font-size\",\n          fontAttr: \"size\",\n          domAttr: \"fontSize\",\n          name: \"fontSize\",\n          defaultValue: [{\n            text: \"fontSizeInherit\",\n            value: \"inherit\"\n          }],\n          template: new ToolTemplate({\n            template: EditorUtils.comboBoxTemplate,\n            title: \"Font Size\"\n          })\n        }));\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}