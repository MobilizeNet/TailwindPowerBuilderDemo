{"ast":null,"code":"import { ZERO, INTERPOLATE } from '../constants';\nimport { Point } from '../../core';\nimport { MAX_VALUE } from '../../common/constants';\nimport { defined } from '../../common';\nconst LineChartMixin = {\n  renderSegments: function () {\n    const {\n      options,\n      seriesPoints\n    } = this;\n    const series = options.series;\n    const seriesCount = seriesPoints.length;\n    let lastSegment;\n    this._segments = [];\n\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const sortedPoints = this.sortPoints(seriesPoints[seriesIx]);\n      const pointCount = sortedPoints.length;\n      let linePoints = [];\n\n      for (let pointIx = 0; pointIx < pointCount; pointIx++) {\n        const point = sortedPoints[pointIx];\n\n        if (point) {\n          linePoints.push(point);\n        } else if (this.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n          if (linePoints.length > 1) {\n            lastSegment = this.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n\n            this._addSegment(lastSegment);\n          }\n\n          linePoints = [];\n        }\n      }\n\n      if (linePoints.length > 1) {\n        lastSegment = this.createSegment(linePoints, currentSeries, seriesIx, lastSegment);\n\n        this._addSegment(lastSegment);\n      }\n    }\n\n    this.children.unshift.apply(this.children, this._segments);\n  },\n  _addSegment: function (segment) {\n    this._segments.push(segment);\n\n    segment.parent = this;\n  },\n  sortPoints: function (points) {\n    return points;\n  },\n  seriesMissingValues: function (series) {\n    const missingValues = series.missingValues;\n    const assumeZero = !missingValues && this.options.isStacked;\n    return assumeZero ? ZERO : missingValues || INTERPOLATE;\n  },\n  getNearestPoint: function (x, y, seriesIx) {\n    const target = new Point(x, y);\n    const allPoints = this.seriesPoints[seriesIx];\n    let nearestPointDistance = MAX_VALUE;\n    let nearestPoint;\n\n    for (let i = 0; i < allPoints.length; i++) {\n      const point = allPoints[i];\n\n      if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n        const pointBox = point.box;\n        const pointDistance = pointBox.center().distanceTo(target);\n\n        if (pointDistance < nearestPointDistance) {\n          nearestPoint = point;\n          nearestPointDistance = pointDistance;\n        }\n      }\n    }\n\n    return nearestPoint;\n  }\n};\nexport default LineChartMixin;","map":null,"metadata":{},"sourceType":"module"}