{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1000);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  980:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../command\");\n    /***/\n  },\n\n  /***/\n  1000:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(980)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      (function ($) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            Class = kendo.Class,\n            editorNS = kendo.ui.editor,\n            RangeUtils = editorNS.RangeUtils,\n            dom = editorNS.Dom,\n            RestorePoint = editorNS.RestorePoint,\n            Marker = editorNS.Marker,\n            browser = kendo.support.browser,\n            bomSpan = \"<span  class='k-br'>\\ufeff</span>\",\n            extend = $.extend;\n        var nodeTypes = dom.nodeTypes;\n        var PREVIOUS_SIBLING = \"previousSibling\";\n\n        function selected(node, range) {\n          return range.startContainer === node && range.endContainer === node && range.startOffset === 0 && range.endOffset == node.childNodes.length;\n        }\n\n        function getSibling(node, direction, condition) {\n          var sibling = node ? node[direction] : null;\n\n          while (sibling && !condition(sibling)) {\n            sibling = sibling[direction];\n          }\n\n          return sibling;\n        }\n\n        var tableCells = \"td,th,caption\";\n        var tableCellsWrappers = \"table,tbody,thead,tfoot,tr\";\n        var tableElements = tableCellsWrappers + \",\" + tableCells;\n\n        var inTable = function (range) {\n          return !range.collapsed && $(range.commonAncestorContainer).is(tableCellsWrappers);\n        };\n\n        var RemoveTableContent = Class.extend({\n          remove: function (range) {\n            var that = this;\n            var marker = new Marker();\n            marker.add(range, false);\n            var nodes = RangeUtils.getAll(range, function (node) {\n              return $(node).is(tableElements);\n            });\n            var doc = RangeUtils.documentFromRange(range);\n            var start = marker.start;\n            var end = marker.end;\n            var cellsTypes = tableCells.split(\",\");\n            var startCell = dom.parentOfType(start, cellsTypes);\n            var endCell = dom.parentOfType(end, cellsTypes);\n\n            that._removeContent(start, startCell, true);\n\n            that._removeContent(end, endCell, false);\n\n            $(nodes).each(function (i, node) {\n              node = $(node);\n              (node.is(tableCells) ? node : node.find(tableCells)).each(function (j, cell) {\n                cell.innerHTML = \"&#65279;\";\n              });\n            });\n\n            if (startCell && !start.previousSibling) {\n              dom.insertBefore(doc.createTextNode(\"\\ufeff\"), start);\n            }\n\n            if (endCell && !end.nextSibling) {\n              dom.insertAfter(doc.createTextNode(\"\\ufeff\"), end);\n            }\n\n            if (startCell) {\n              range.setStartBefore(start);\n            } else if (nodes[0]) {\n              startCell = $(nodes[0]);\n              startCell = startCell.is(tableCells) ? startCell : startCell.find(tableCells).first();\n\n              if (startCell.length) {\n                range.setStart(startCell.get(0), 0);\n              }\n            }\n\n            range.collapse(true);\n            dom.remove(start);\n            dom.remove(end);\n          },\n          _removeContent: function (start, top, forwards) {\n            if (top) {\n              var sibling = forwards ? \"nextSibling\" : \"previousSibling\",\n                  next,\n                  getNext = function (node) {\n                while (node && !node[sibling]) {\n                  node = node.parentNode;\n                }\n\n                return node && $.contains(top, node) ? node[sibling] : null;\n              };\n\n              start = getNext(start);\n\n              while (start) {\n                next = getNext(start);\n                dom.remove(start);\n                start = next;\n              }\n            }\n          }\n        });\n        var TypingHandler = Class.extend({\n          init: function (editor) {\n            this.editor = editor;\n          },\n          keydown: function (e) {\n            var that = this,\n                editor = that.editor,\n                keyboard = editor.keyboard,\n                isTypingKey = keyboard.isTypingKey(e),\n                evt = extend($.Event(), e);\n            that.editor.trigger(\"keydown\", evt);\n\n            if (evt.isDefaultPrevented()) {\n              e.preventDefault();\n              return true;\n            }\n\n            if (!evt.isDefaultPrevented() && isTypingKey && !keyboard.isTypingInProgress()) {\n              var range = editor.getRange();\n              var body = editor.body;\n              that.startRestorePoint = new RestorePoint(range, body);\n\n              if (inTable(range)) {\n                var removeTableContent = new RemoveTableContent(editor);\n                removeTableContent.remove(range);\n                editor.selectRange(range);\n              }\n\n              if (browser.webkit && !range.collapsed && selected(body, range)) {\n                body.innerHTML = \"\";\n              }\n\n              if (editor.immutables && editorNS.Immutables.immutablesContext(range)) {\n                var backspaceHandler = new editorNS.BackspaceHandler(editor);\n                backspaceHandler.deleteSelection(range);\n              }\n\n              keyboard.startTyping(function () {\n                that._removeBomSpan();\n\n                that.endRestorePoint = editorNS._finishUpdate(editor, that.startRestorePoint);\n              });\n              return true;\n            }\n\n            return false;\n          },\n          keyup: function (e) {\n            var keyboard = this.editor.keyboard;\n            this.editor.trigger(\"keyup\", e);\n\n            if (keyboard.isTypingInProgress()) {\n              keyboard.endTyping();\n              return true;\n            }\n\n            return false;\n          },\n          _removeBomSpan: function () {\n            var node = this.editor.getRange().commonAncestorContainer;\n\n            if (!dom.emptyNode(node)) {\n              if (node.nodeType === 3) {\n                node = node.parentNode;\n              }\n\n              if (dom.insignificant(node)) {\n                // typing in an insignificant node\n                // make it significant\n                node.textContent = dom.stripBom(node.textContent);\n                dom.unwrap(node);\n              }\n            }\n          }\n        });\n        var BackspaceHandler = Class.extend({\n          init: function (editor) {\n            this.editor = editor;\n          },\n          _addCaret: function (container) {\n            var caret = dom.create(this.editor.document, \"a\"); // Only if not Chrome: Make sure to include cared in the formatted inline node\n\n            if (!kendo.support.browser.chrome && container.firstChild && container.firstChild.nodeType === nodeTypes.ELEMENT_NODE) {\n              container = container.firstChild;\n            }\n\n            dom.insertAt(container, caret, 0);\n            dom.stripBomNode(caret.previousSibling);\n            dom.stripBomNode(caret.nextSibling);\n            return caret;\n          },\n          _restoreCaret: function (caret) {\n            var range = this.editor.createRange();\n\n            if (!caret.nextSibling && dom.isDataNode(caret.previousSibling)) {\n              range.setStart(caret.previousSibling, caret.previousSibling.length);\n            } else {\n              range.setStartAfter(caret);\n            }\n\n            range.collapse(true);\n            this.editor.selectRange(range);\n            dom.remove(caret);\n          },\n          _handleDelete: function (range) {\n            var node = range.endContainer;\n            var block = dom.closestEditableOfType(node, dom.blockElements);\n\n            if (block && editorNS.RangeUtils.isEndOf(range, block)) {\n              // join with next sibling\n              var next = dom.next(block);\n\n              if (!next || dom.name(next) != \"p\") {\n                return false;\n              }\n\n              var caretPlaceholder = dom.significantChildNodes(next)[0];\n              caretPlaceholder = caretPlaceholder && dom.isInline(caretPlaceholder) ? caretPlaceholder : next;\n\n              var caret = this._addCaret(caretPlaceholder);\n\n              this._merge(block, next);\n\n              this._restoreCaret(caret);\n\n              return true;\n            }\n\n            return false;\n          },\n          _cleanBomBefore: function (range) {\n            var offset = range.startOffset;\n            var node = range.startContainer;\n            var text = node.nodeValue;\n            var count = 0;\n\n            while (offset - count >= 0 && text[offset - count - 1] == \"\\ufeff\") {\n              count++;\n            }\n\n            if (count > 0) {\n              node.deleteData(offset - count, count);\n              range.setStart(node, Math.max(0, offset - count));\n              range.collapse(true);\n              this.editor.selectRange(range);\n            }\n          },\n          _handleBackspace: function (range) {\n            var node = range.startContainer;\n            var li = dom.closestEditableOfType(node, ['li']);\n            var block = dom.closestEditableOfType(node, 'p,h1,h2,h3,h4,h5,h6'.split(','));\n            var editor = this.editor;\n            var previousSibling;\n\n            if (dom.isDataNode(node)) {\n              if (range.collapsed && /^\\s[\\ufeff]+$/.test(node.nodeValue)) {\n                range.setStart(node, 0);\n                range.setEnd(node, node.length);\n                editor.selectRange(range);\n                return false;\n              }\n\n              this._cleanBomBefore(range);\n            }\n\n            previousSibling = getSibling(block, PREVIOUS_SIBLING, function (sibling) {\n              return !dom.htmlIndentSpace(sibling);\n            }); //deleting the first list item with empty content in IE results in invalid range\n\n            if (range.collapsed && range.startOffset !== range.endOffset && range.startOffset < 0) {\n              range.startOffset = 0;\n              range.endOffset = 0;\n              editor.selectRange(range);\n            }\n\n            var startAtLi = li && editorNS.RangeUtils.isStartOf(range, li);\n            var liIndex = li && $(li).index();\n            var startAtNonFirstLi = startAtLi && liIndex > 0;\n\n            if (startAtNonFirstLi) {\n              block = li;\n              previousSibling = dom.prev(li);\n            }\n\n            if (block && previousSibling && dom.is(previousSibling, 'table') && editorNS.RangeUtils.isStartOf(range, block)) {\n              if (block.innerText === '') {\n                block.innerHTML = '\\ufeff';\n              }\n\n              return true;\n            } // outdent\n\n\n            if (editorNS.RangeUtils.isStartOf(range, block) && parseInt(block.style.marginLeft, 10) > 0) {\n              editor.exec(\"outdent\");\n              return true;\n            } // unwrap block\n\n\n            if (block && previousSibling && editorNS.RangeUtils.isStartOf(range, block) || startAtNonFirstLi) {\n              var caretPlaceholder = dom.significantChildNodes(block)[0];\n              caretPlaceholder = caretPlaceholder && dom.isInline(caretPlaceholder) ? caretPlaceholder : block;\n\n              var caret = this._addCaret(caretPlaceholder);\n\n              this._merge(previousSibling, block);\n\n              this._restoreCaret(caret);\n\n              return true;\n            } // unwrap li element\n\n\n            if (startAtLi && liIndex === 0) {\n              var child = li.firstChild;\n\n              if (!child) {\n                li.innerHTML = editorNS.emptyElementContent;\n                child = li.firstChild;\n              }\n\n              var formatter = new editorNS.ListFormatter(dom.name(li.parentNode), \"p\");\n              range.selectNodeContents(li);\n              formatter.toggle(range);\n\n              if (dom.insignificant(child)) {\n                range.setStartBefore(child);\n              } else {\n                range.setStart(child, 0);\n              }\n\n              editor.selectRange(range);\n              return true;\n            }\n\n            var rangeStartNode = node.childNodes[range.startOffset - 1];\n            var linkRange = range;\n            var anchor = rangeStartNode && dom.closestEditableOfType(rangeStartNode, ['a']);\n            var previousNode = getSibling(rangeStartNode || node, PREVIOUS_SIBLING, function (sibling) {\n              return !dom.isDataNode(sibling) || !dom.isBom(sibling) && sibling.length > 0;\n            });\n\n            if (anchor || (range.startOffset === 0 || rangeStartNode) && dom.is(previousNode, \"a\")) {\n              anchor = anchor || previousNode;\n              linkRange = editor.createRange();\n              linkRange.setStart(anchor, anchor.childNodes.length);\n              linkRange.collapse(true);\n            }\n\n            anchor = anchor || dom.closestEditableOfType(rangeStartNode || linkRange.startContainer, ['a']);\n            var isEndOfLink = anchor && editorNS.RangeUtils.isEndOf(linkRange, anchor);\n\n            if (isEndOfLink) {\n              var command = new editorNS.UnlinkCommand({\n                range: linkRange,\n                body: editor.body,\n                immutables: !!editor.immutables\n              });\n              editor.execCommand(command);\n\n              editor._selectionChange();\n            }\n\n            return false;\n          },\n          _handleSelection: function (range) {\n            var ancestor = range.commonAncestorContainer;\n            var table = dom.closest(ancestor, \"table\");\n            var emptyParagraphContent = editorNS.emptyElementContent;\n            var editor = this.editor;\n            var parentElementOrNode;\n\n            if (inTable(range)) {\n              var removeTableContent = new RemoveTableContent(editor);\n              removeTableContent.remove(range);\n              editor.selectRange(range);\n              return true;\n            }\n\n            var marker = new Marker();\n            marker.add(range, false);\n\n            if (range.commonAncestorContainer === editor.body) {\n              this._surroundFullyContent(marker, range);\n            }\n\n            if (editor.immutables) {\n              this._handleImmutables(marker);\n            }\n\n            this._surroundFullySelectedAnchor(marker, range);\n\n            range.setStartAfter(marker.start);\n            range.setEndBefore(marker.end);\n            var start = range.startContainer;\n            var end = range.endContainer;\n            range.deleteContents();\n\n            if (end.tagName.toLocaleLowerCase() === \"li\" && dom.emptyNode(end)) {\n              range.selectNode(end);\n              range.deleteContents();\n            }\n\n            if (table && $(table).text() === \"\") {\n              range.selectNode(table);\n              range.deleteContents();\n            }\n\n            ancestor = range.commonAncestorContainer;\n\n            if (dom.name(ancestor) === \"p\" && ancestor.innerHTML === \"\") {\n              ancestor.innerHTML = emptyParagraphContent;\n              range.setStart(ancestor, 0);\n            }\n\n            this._join(start, end);\n\n            dom.insertAfter(editor.document.createTextNode(\"\\ufeff\"), marker.start);\n            marker.remove(range);\n            start = range.startContainer;\n\n            if (dom.name(start) == \"tr\") {\n              start = start.childNodes[Math.max(0, range.startOffset - 1)];\n              range.setStart(start, dom.getNodeLength(start));\n            }\n\n            range.collapse(true);\n            editor.selectRange(range);\n            parentElementOrNode = start.parentElement || start.parentNode;\n\n            if (dom.isDataNode(start) && !dom.emptyNode(parentElementOrNode)) {\n              this._cleanBomBefore(range);\n            }\n\n            return true;\n          },\n          _handleImmutables: function (marker) {\n            var immutableParent = editorNS.Immutables.immutableParent;\n            var startImmutable = immutableParent(marker.start);\n            var endImmutable = immutableParent(marker.start);\n\n            if (startImmutable) {\n              dom.insertBefore(marker.start, startImmutable);\n            }\n\n            if (endImmutable) {\n              dom.insertAfter(marker.end, endImmutable);\n            }\n\n            if (startImmutable) {\n              dom.remove(startImmutable);\n            }\n\n            if (endImmutable && endImmutable.parentNode) {\n              dom.remove(endImmutable);\n            }\n          },\n          _surroundFullyContent: function (marker, range) {\n            var children = range.commonAncestorContainer.children,\n                startParent = children[0],\n                endParent = children[children.length - 1];\n\n            this._moveMarker(marker, range, startParent, endParent);\n          },\n          _surroundFullySelectedAnchor: function (marker, range) {\n            var start = marker.start,\n                startParent = $(start).closest(\"a\").get(0),\n                end = marker.end,\n                endParent = $(end).closest(\"a\").get(0);\n\n            this._moveMarker(marker, range, startParent, endParent);\n          },\n          _moveMarker: function (marker, range, startParent, endParent) {\n            var start = marker.start,\n                end = marker.end;\n\n            if (startParent && RangeUtils.isStartOf(range, startParent)) {\n              dom.insertBefore(start, startParent);\n            }\n\n            if (endParent && RangeUtils.isEndOf(range, endParent)) {\n              dom.insertAfter(end, endParent);\n            }\n          },\n          _root: function (node) {\n            while (node && dom.name(node) != \"body\" && node.parentNode && dom.name(node.parentNode) != \"body\") {\n              node = node.parentNode;\n            }\n\n            return node;\n          },\n          _join: function (start, end) {\n            start = this._root(start);\n            end = this._root(end);\n\n            if (start != end && dom.is(end, \"p\")) {\n              this._merge(start, end);\n            }\n          },\n          _merge: function (dest, src) {\n            dom.removeTrailingBreak(dest);\n\n            while (dest && src.firstChild) {\n              if (dest.nodeType == 1) {\n                dest = dom.list(dest) ? dest.children[dest.children.length - 1] : dest;\n\n                if (dest) {\n                  dest.appendChild(src.firstChild);\n                }\n              } else if (dest.nodeType === nodeTypes.TEXT_NODE) {\n                this._mergeWithTextNode(dest, src.firstChild);\n              } else {\n                dest.parentNode.appendChild(src.firstChild);\n              }\n            }\n\n            dom.remove(src);\n          },\n          _mergeWithTextNode: function (textNode, appendedNode) {\n            if (textNode && textNode.nodeType === nodeTypes.TEXT_NODE) {\n              if (textNode.nextSibling && this._isCaret(textNode.nextSibling)) {\n                dom.insertAfter(appendedNode, textNode.nextSibling);\n              } else {\n                dom.insertAfter(appendedNode, textNode);\n              }\n            }\n          },\n          _isCaret: function (element) {\n            return $(element).is(\"a\");\n          },\n          keydown: function (e) {\n            var method, startRestorePoint;\n            var editor = this.editor;\n            var range = editor.getRange();\n            var keyCode = e.keyCode;\n            var keys = kendo.keys;\n            var backspace = keyCode === keys.BACKSPACE;\n            var del = keyCode == keys.DELETE;\n\n            if (editor.immutables && editor.immutables.keydown(e, range)) {\n              return;\n            }\n\n            if ((backspace || del) && !range.collapsed) {\n              method = \"_handleSelection\";\n            } else if (backspace) {\n              method = \"_handleBackspace\";\n            } else if (del) {\n              method = \"_handleDelete\";\n            }\n\n            if (!method) {\n              return;\n            }\n\n            startRestorePoint = new RestorePoint(range, editor.body);\n\n            if (this[method](range)) {\n              e.preventDefault();\n\n              editorNS._finishUpdate(editor, startRestorePoint);\n            }\n          },\n          deleteSelection: function (range) {\n            this._handleSelection(range);\n          },\n          keyup: $.noop\n        });\n        var SystemHandler = Class.extend({\n          init: function (editor) {\n            this.editor = editor;\n            this.systemCommandIsInProgress = false;\n          },\n          createUndoCommand: function () {\n            this.startRestorePoint = this.endRestorePoint = editorNS._finishUpdate(this.editor, this.startRestorePoint);\n          },\n          changed: function () {\n            if (this.startRestorePoint) {\n              return this.startRestorePoint.html != this.editor.body.innerHTML;\n            }\n\n            return false;\n          },\n          keydown: function (e) {\n            var that = this,\n                editor = that.editor,\n                keyboard = editor.keyboard;\n\n            if (keyboard.isModifierKey(e)) {\n              if (keyboard.isTypingInProgress()) {\n                keyboard.endTyping(true);\n              }\n\n              that.startRestorePoint = new RestorePoint(editor.getRange(), editor.body);\n              return true;\n            }\n\n            if (keyboard.isSystem(e)) {\n              that.systemCommandIsInProgress = true;\n\n              if (that.changed()) {\n                that.systemCommandIsInProgress = false;\n                that.createUndoCommand();\n              }\n\n              return true;\n            }\n\n            return false;\n          },\n          keyup: function () {\n            var that = this;\n\n            if (that.systemCommandIsInProgress && that.changed()) {\n              that.systemCommandIsInProgress = false;\n              that.createUndoCommand();\n              return true;\n            }\n\n            return false;\n          }\n        });\n        var SelectAllHandler = Class.extend({\n          init: function (editor) {\n            this.editor = editor;\n          },\n          keydown: function (e) {\n            if (!browser.webkit || e.isDefaultPrevented() || !(e.ctrlKey && e.keyCode == 65 && !e.altKey && !e.shiftKey)) {\n              return;\n            }\n\n            if (this.editor.options.immutables) {\n              this._toSelectableImmutables();\n            }\n\n            this._selectEditorBody();\n          },\n          _selectEditorBody: function () {\n            var editor = this.editor;\n            var range = editor.getRange();\n            range.selectNodeContents(editor.body);\n            setTimeout(function () {\n              editor.selectRange(range);\n            });\n          },\n          _toSelectableImmutables: function () {\n            var editor = this.editor,\n                body = editor.body,\n                immutable = editorNS.Immutables.immutable,\n                emptyTextNode = dom.emptyTextNode,\n                first = body.firstChild,\n                last = body.lastChild;\n\n            while (emptyTextNode(first)) {\n              first = first.nextSibling;\n            }\n\n            while (emptyTextNode(last)) {\n              last = last.previousSibling;\n            }\n\n            if (first && immutable(first)) {\n              $(bomSpan).prependTo(body);\n            }\n\n            if (last && immutable(last)) {\n              $(bomSpan).appendTo(body);\n            }\n          },\n          keyup: $.noop\n        });\n        var Keyboard = Class.extend({\n          init: function (handlers) {\n            this.handlers = handlers;\n            this.typingInProgress = false;\n          },\n          isCharacter: function (keyCode) {\n            return keyCode >= 48 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222 || keyCode == 229;\n          },\n          toolFromShortcut: function (tools, e) {\n            var key = String.fromCharCode(e.keyCode),\n                toolName,\n                toolOptions,\n                modifier = this._getShortcutModifier(e, navigator.platform);\n\n            for (toolName in tools) {\n              toolOptions = $.extend({\n                ctrl: false,\n                alt: false,\n                shift: false\n              }, tools[toolName].options);\n\n              if ((toolOptions.key == key || toolOptions.key == e.keyCode) && toolOptions.ctrl == modifier && toolOptions.alt == e.altKey && toolOptions.shift == e.shiftKey) {\n                return toolName;\n              }\n            }\n          },\n          _getShortcutModifier: function (e, platform) {\n            var mac = platform.toUpperCase().indexOf('MAC') >= 0;\n            return mac ? e.metaKey : e.ctrlKey;\n          },\n          toolsFromShortcut: function (tools, e) {\n            var key = String.fromCharCode(e.keyCode),\n                toolName,\n                o,\n                matchesKey,\n                found = [];\n\n            var matchKey = function (toolKey) {\n              return toolKey == key || toolKey == e.keyCode || toolKey == e.charCode;\n            };\n\n            for (toolName in tools) {\n              o = $.extend({\n                ctrl: false,\n                alt: false,\n                shift: false\n              }, tools[toolName].options);\n              matchesKey = Array.isArray(o.key) ? $.grep(o.key, matchKey).length > 0 : matchKey(o.key);\n\n              if (matchesKey && o.ctrl == e.ctrlKey && o.alt == e.altKey && o.shift == e.shiftKey) {\n                found.push(tools[toolName]);\n              }\n            }\n\n            return found;\n          },\n          isTypingKey: function (e) {\n            var keyCode = e.keyCode;\n            return this.isCharacter(keyCode) && !e.ctrlKey && !e.altKey || keyCode == 32 || keyCode == 13 || keyCode == 8 || keyCode == 46 && !e.shiftKey && !e.ctrlKey && !e.altKey;\n          },\n          isModifierKey: function (e) {\n            var keyCode = e.keyCode;\n            return keyCode == 17 && !e.shiftKey && !e.altKey || keyCode == 16 && !e.ctrlKey && !e.altKey || keyCode == 18 && !e.ctrlKey && !e.shiftKey;\n          },\n          isSystem: function (e) {\n            return e.keyCode == 46 && e.ctrlKey && !e.altKey && !e.shiftKey;\n          },\n          startTyping: function (callback) {\n            this.onEndTyping = callback;\n            this.typingInProgress = true;\n          },\n          stopTyping: function () {\n            if (this.typingInProgress && this.onEndTyping) {\n              this.onEndTyping();\n            }\n\n            this.typingInProgress = false;\n          },\n          endTyping: function (force) {\n            var that = this;\n            that.clearTimeout();\n\n            if (force) {\n              that.stopTyping();\n            } else {\n              that.timeout = window.setTimeout(that.stopTyping.bind(that), 1000);\n            }\n          },\n          isTypingInProgress: function () {\n            return this.typingInProgress;\n          },\n          clearTimeout: function () {\n            window.clearTimeout(this.timeout);\n          },\n          notify: function (e, what) {\n            var i,\n                handlers = this.handlers;\n\n            for (i = 0; i < handlers.length; i++) {\n              if (handlers[i][what](e)) {\n                break;\n              }\n            }\n          },\n          keydown: function (e) {\n            this.notify(e, 'keydown');\n          },\n          keyup: function (e) {\n            this.notify(e, 'keyup');\n          }\n        });\n        extend(editorNS, {\n          TypingHandler: TypingHandler,\n          SystemHandler: SystemHandler,\n          BackspaceHandler: BackspaceHandler,\n          SelectAllHandler: SelectAllHandler,\n          Keyboard: Keyboard\n        });\n      })(window.kendo.jQuery);\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}