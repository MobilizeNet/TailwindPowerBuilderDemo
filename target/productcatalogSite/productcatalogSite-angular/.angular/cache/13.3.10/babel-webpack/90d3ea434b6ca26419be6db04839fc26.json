{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1695);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  957:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.color\");\n    /***/\n  },\n\n  /***/\n  1695:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(957), __webpack_require__(1696), __webpack_require__(1697)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      \"use strict\";\n      /* global JSZip */\n      // WARNING: removing the following jshint declaration and turning\n      // == into === to make JSHint happy will break functionality.\n\n      /* jshint eqnull:true, laxbreak:true */\n\n      /* jshint latedef: nofunc */\n\n      var $ = kendo.jQuery;\n      var parseXML = kendo.util.parseXML;\n      var parseReference = kendo.spreadsheet.calc.parseReference;\n      var MAP_EXCEL_OPERATOR = {\n        // includes only what differs; key is Excel's operator, value\n        // is our operator.\n        greaterThanOrEqual: \"greaterThanOrEqualTo\",\n        lessThanOrEqual: \"lessThanOrEqualTo\"\n      };\n      var ERROR_LOG = null;\n\n      function readExcel(file, workbook, deferred) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n          var zip = new JSZip(e.target.result);\n          readWorkbook(zip, workbook, deferred);\n        };\n\n        reader.readAsArrayBuffer(file);\n      }\n\n      var SEL_CELL = [\"sheetData\", \"row\", \"c\"];\n      var SEL_COL = [\"cols\", \"col\"];\n      var SEL_DEFINED_NAME = [\"definedNames\", \"definedName\"];\n      var SEL_FORMULA = [\"sheetData\", \"row\", \"c\", \"f\"];\n      var SEL_MERGE = [\"mergeCells\", \"mergeCell\"];\n      var SEL_PANE = [\"sheetViews\", \"sheetView\", \"pane\"];\n      var SEL_ROW = [\"sheetData\", \"row\"];\n      var SEL_SELECTION = [\"sheetViews\", \"sheetView\", \"selection\"];\n      var SEL_SHEET = [\"sheets\", \"sheet\"];\n      var SEL_STRING = [\"sheetData\", \"row\", \"c\", \"is\"];\n      var SEL_TEXT = [\"t\"];\n      var SEL_SHARED_STRING = [\"si\"];\n      var SEL_VALUE = [\"sheetData\", \"row\", \"c\", \"v\"];\n      var SEL_VIEW = [\"bookViews\", \"workbookView\"];\n      var SEL_SHEET_VIEW = [\"sheetViews\", \"sheetView\"];\n      var SEL_HYPERLINK = [\"hyperlinks\", \"hyperlink\"];\n      /* A validation section looks like this:\n       *\n       * <dataValidations count=\"1\">\n       *   <dataValidation type=\"list\" allowBlank=\"1\" showInputMessage=\"1\" showErrorMessage=\"1\" sqref=\"B2\">\n       *     <formula1>$E$2:$E$5</formula1>\n       *   </dataValidation>\n       * </dataValidations>\n       */\n\n      var SEL_VALIDATION = [\"dataValidations\", \"dataValidation\"];\n      var SEL_VALIDATION_FORMULA1 = [\"dataValidations\", \"dataValidation\", \"formula1\"];\n      var SEL_VALIDATION_FORMULA2 = [\"dataValidations\", \"dataValidation\", \"formula2\"];\n      /* However, when a validation formula in one sheet references\n       * cells from another sheet, Excel produces this version instead:\n       *\n       * <extLst>\n       *   <ext xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" uri=\"{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}\">\n       *     <x14:dataValidations xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\" count=\"1\">\n       *       <x14:dataValidation type=\"list\" allowBlank=\"1\" showInputMessage=\"1\" showErrorMessage=\"1\">\n       *         <x14:formula1>\n       *           <xm:f>Sheet2!$B$3:$B$6</xm:f>\n       *         </x14:formula1>\n       *         <xm:sqref>B1</xm:sqref>\n       *       </x14:dataValidation>\n       *     </x14:dataValidations>\n       *   </ext>\n       * </extLst>\n       *\n       * I call it the \"insane version\", because that's what it is.\n       * Barring the case that the engineers who produced this horror\n       * were on LSD, the only plausible reason for it is that Microsoft\n       * does not want third party software to be compatible with Excel\n       * (sentiment I've had over and over while working on the\n       * Spreadsheet widget).\n       */\n      // XXX: technically, the aliases `x14` and `xm` below could be\n      // different, but Excel seems to be hard-coded on these; our\n      // parser does not support proper namespaces for now anyway, so\n      // hard-coded they are.\n\n      var SEL_VALIDATION_INSANE = [\"x14:dataValidations\", \"x14:dataValidation\"];\n      var SEL_VALIDATION_SQREF_INSANE = [\"x14:dataValidations\", \"x14:dataValidation\", \"xm:sqref\"];\n      var SEL_VALIDATION_FORMULA1_INSANE = [\"x14:dataValidations\", \"x14:dataValidation\", \"x14:formula1\", \"xm:f\"];\n      var SEL_VALIDATION_FORMULA2_INSANE = [\"x14:dataValidations\", \"x14:dataValidation\", \"x14:formula2\", \"xm:f\"]; // comment selectors (in files like comments1.xml)\n\n      var SEL_COMMENT = [\"commentList\", \"comment\"];\n      var SEL_AUTHOR = [\"authors\", \"author\"];\n      var SEL_COMMENT_TEXT = [\"t\"];\n\n      function xl(file) {\n        if (!/^\\//.test(file)) {\n          if (!/^xl\\//.test(file)) {\n            file = \"xl/\" + file;\n          }\n        } else {\n          file = file.substr(1);\n        }\n\n        return file;\n      }\n\n      function readWorkbook(zip, workbook, progress) {\n        ERROR_LOG = workbook.excelImportErrors = [];\n        var strings = readStrings(zip);\n        var relationships = readRelationships(zip, \"_rels/workbook.xml\");\n        var theme = readTheme(zip, relationships.byType.theme[0]);\n        var styles = readStyles(zip, theme);\n        var items = [];\n        var activeSheet = 0;\n        parse(zip, \"xl/workbook.xml\", {\n          enter: function (tag, attrs) {\n            if (this.is(SEL_SHEET)) {\n              var relId = attrs[\"r:id\"];\n              var file = relationships.byId[relId];\n              var name = attrs.name;\n              var dim = sheetDimensions(zip, file);\n              workbook.options.columnWidth = dim.columnWidth || workbook.options.columnWidth;\n              workbook.options.rowHeight = dim.rowHeight || workbook.options.rowHeight;\n              items.push({\n                workbook: workbook,\n                zip: zip,\n                strings: strings,\n                styles: styles,\n                file: file,\n                options: {\n                  name: name,\n                  rows: Math.max(workbook.options.rows || 0, dim.rows),\n                  columns: Math.max(workbook.options.columns || 0, dim.cols),\n                  columnWidth: dim.columnWidth,\n                  rowHeight: dim.rowHeight\n                }\n              });\n            } else if (this.is(SEL_VIEW)) {\n              if (attrs.activeTab) {\n                activeSheet = integer(attrs.activeTab);\n              }\n            }\n          },\n          text: function (text) {\n            var attrs = this.is(SEL_DEFINED_NAME);\n\n            if (attrs && !(bool(attrs[\"function\"]) || bool(attrs.vbProcedure))) {\n              var localSheetId = attrs.localSheetId;\n              var sheet = null;\n\n              if (localSheetId != null) {\n                sheet = items[localSheetId].options.name;\n              }\n\n              var name = attrs.name;\n\n              if (name != \"_xlnm._FilterDatabase\") {\n                if (sheet) {\n                  name = \"'\" + sheet.replace(/\\'/g, \"\\\\'\") + \"'!\" + name;\n                }\n\n                withErrorLog(sheet, null, function () {\n                  workbook.defineName(name, text, bool(attrs.hidden));\n                }, \"reading user-defined name: \" + name);\n              }\n            }\n          }\n        });\n        var loading = new $.Deferred();\n        loading.progress(function (args) {\n          if (progress) {\n            progress.notify(args);\n          }\n        }).then(function () {\n          var sheets = workbook.sheets();\n          recalcSheets(sheets);\n          workbook.activeSheet(sheets[activeSheet]);\n\n          if (progress) {\n            progress.resolve();\n          }\n        });\n        loadSheets(items, workbook, loading);\n      }\n\n      function loadSheets(items, workbook, progress) {\n        var ready = new $.Deferred().resolve();\n\n        for (var i = 0; i < items.length; i++) {\n          /*jshint -W083 */\n          (function (entry, i) {\n            ready = ready.then(function () {\n              var sheet = workbook.insertSheet(entry.options);\n              sheet.suspendChanges(true);\n              var promise = queueSheet(sheet, entry);\n              var args = {\n                sheet: sheet,\n                progress: i / (items.length - 1)\n              };\n              promise.then(function () {\n                progress.notify(args);\n              });\n              return promise;\n            });\n          })(items[i], i);\n        }\n\n        ready.then(function () {\n          progress.resolve();\n        });\n      }\n\n      function queueSheet(sheet, ctx) {\n        var deferred = new $.Deferred();\n        setTimeout(function () {\n          readSheet(ctx.zip, ctx.file, sheet, ctx.strings, ctx.styles);\n          deferred.resolve();\n        }, 0);\n        return deferred;\n      }\n\n      function recalcSheets(sheets) {\n        for (var i = 0; i < sheets.length; i++) {\n          sheets[i].suspendChanges(false).triggerChange({\n            recalc: true\n          });\n        }\n      }\n\n      function sheetDimensions(zip, file) {\n        var ref,\n            dim = {\n          rows: 0,\n          cols: 0\n        };\n        parse(zip, xl(file), {\n          enter: function (tag, attrs) {\n            if (tag == \"dimension\") {\n              ref = parseReference(attrs.ref);\n\n              if (ref.bottomRight) {\n                dim.cols = ref.bottomRight.col + 1;\n                dim.rows = ref.bottomRight.row + 1;\n              }\n            } else if (tag === \"sheetFormatPr\") {\n              if (attrs.defaultColWidth) {\n                dim.columnWidth = toColWidth(parseFloat(attrs.defaultColWidth));\n              }\n\n              if (attrs.defaultRowHeight) {\n                dim.rowHeight = toRowHeight(parseFloat(attrs.defaultRowHeight));\n              }\n            } else if (this.is(SEL_ROW) && attrs.r) {\n              dim.rows = Math.max(dim.rows, +attrs.r);\n            } else if (this.is(SEL_CELL) && attrs.r) {\n              ref = parseReference(attrs.r);\n              dim.rows = Math.max(dim.rows, ref.row + 1);\n              dim.cols = Math.max(dim.cols, ref.col + 1);\n            }\n          }\n        });\n        return dim;\n      }\n\n      function toColWidth(size) {\n        // No font to compute agains, hence the magic number\n        var maximumDigitWidth = 7; // The formula below is taken from the OOXML spec\n\n        var fraction = (256 * size + Math.floor(128 / maximumDigitWidth)) / 256;\n        return fraction * maximumDigitWidth;\n      }\n\n      function toRowHeight(pts) {\n        return pts * (4 / 3);\n      }\n\n      function readSheet(zip, file, sheet, strings, styles) {\n        var sharedFormulas = {};\n        var ref, type, value, formula, formulaRange, isArrayFormula;\n        var nCols = sheet._columns._count;\n        var prevCellRef = null;\n        var relsFile = file.replace(/worksheets\\//, \"worksheets/_rels/\");\n        var relationships = readRelationships(zip, relsFile);\n        var formula1, formula2;\n        var filterRef;\n        var filterColumn;\n        var customFilterLogic;\n        var customFilterCriteria;\n        var valueFilterBlanks;\n        var valueFilterValues;\n        var filters = [];\n        ERROR_LOG = sheet._workbook.excelImportErrors;\n        file = xl(file);\n        parse(zip, file, {\n          enter: function (tag, attrs, closed) {\n            var tmp;\n\n            if (this.is(SEL_FORMULA)) {\n              if (closed) {\n                if (attrs.t == \"shared\" && attrs.si != null) {\n                  formula = sheet.range(sharedFormulas[attrs.si])._get(\"formula\");\n                }\n              }\n            } else if (this.is(SEL_CELL)) {\n              value = null;\n              formula = null;\n              ref = attrs.r;\n              formulaRange = null;\n\n              if (ref == null) {\n                // apparently some tools omit the `r` for\n                // consecutive cells in a row, so we'll figure\n                // it out from the previous cell's reference.\n                // XXX: this could be slightly optimized by\n                // keeping it parsed instead of stringifying\n                // it to parse it again later.\n                ref = parseReference(prevCellRef);\n                ref.col++;\n                ref = ref.toString();\n              }\n\n              prevCellRef = ref; // XXX: can't find no type actually, so everything is\n              // interpreted as string.  Additionally, cells having\n              // a formula will contain both <f> and <v> nodes,\n              // which makes the value take precedence because it's\n              // the second node; hence, the hack is to keep note of\n              // them in the `text` handler, and apply the\n              // appropriate one in the `leave` handler below.\n\n              type = attrs.t;\n              var styleIndex = attrs.s;\n\n              if (styleIndex != null) {\n                applyStyle(sheet, ref, styles, styleIndex);\n              }\n            } else if (this.is(SEL_MERGE)) {\n              sheet.range(attrs.ref).merge();\n            } else if (this.is(SEL_COL)) {\n              var start = integer(attrs.min) - 1;\n              var stop = Math.min(nCols, integer(attrs.max)) - 1;\n              var width;\n\n              if (attrs.width) {\n                width = toColWidth(parseFloat(attrs.width));\n\n                if (width !== 0) {\n                  sheet._columns.values.value(start, stop, width);\n                }\n              }\n\n              if (attrs.hidden === \"1\" || width === 0) {\n                for (var ci = start; ci <= stop; ci++) {\n                  sheet.hideColumn(ci);\n                }\n              }\n\n              if (attrs.style != null) {\n                // apply style on a whole range of columns\n                applyStyle(sheet, new kendo.spreadsheet.RangeRef(new kendo.spreadsheet.CellRef(-Infinity, start), new kendo.spreadsheet.CellRef(+Infinity, stop)), styles, attrs.style);\n              }\n            } else if (this.is(SEL_ROW)) {\n              var row = integer(attrs.r) - 1;\n              var height;\n\n              if (attrs.ht) {\n                height = toRowHeight(parseFloat(attrs.ht));\n\n                if (height !== 0) {\n                  sheet._rows.values.value(row, row, height);\n                }\n              }\n\n              if (attrs.hidden === \"1\" || height === 0) {\n                sheet.hideRow(row);\n              }\n            } else if (this.is(SEL_SELECTION)) {\n              if (attrs.activeCell) {\n                var acRef = parseReference(attrs.activeCell);\n                sheet.select(acRef, true);\n              }\n            } else if (this.is(SEL_PANE)) {\n              if (attrs.state && attrs.state.indexOf(\"frozen\") > -1) {\n                if (attrs.xSplit) {\n                  sheet.frozenColumns(integer(attrs.xSplit));\n                }\n\n                if (attrs.ySplit) {\n                  sheet.frozenRows(integer(attrs.ySplit));\n                }\n              }\n            } else if (this.is(SEL_SHEET_VIEW)) {\n              sheet.showGridLines(bool(attrs.showGridLines, true));\n            } else if (this.is(SEL_HYPERLINK)) {\n              var relId = attrs[\"r:id\"];\n              var target = relationships.byId[relId];\n\n              if (target) {\n                sheet.range(attrs.ref).link(target);\n              }\n            } else if (this.is([\"autoFilter\"])) {\n              filterRef = attrs.ref;\n\n              if (closed) {\n                addAutoFilter();\n              }\n            } else if (filterRef) {\n              if (this.is([\"filterColumn\"])) {\n                filterColumn = parseInt(attrs.colId, 10);\n              } else if (this.is([\"customFilters\"])) {\n                customFilterLogic = bool(attrs.and) ? \"and\" : \"or\";\n                customFilterCriteria = [];\n              } else if (this.is([\"customFilter\"])) {\n                tmp = getCustomFilter(attrs.operator, attrs.val);\n\n                if (tmp) {\n                  customFilterCriteria.push({\n                    operator: tmp.operator,\n                    value: tmp.value\n                  });\n                }\n              } else if (this.is([\"dynamicFilter\"])) {\n                filters.push({\n                  column: filterColumn,\n                  filter: new kendo.spreadsheet.DynamicFilter({\n                    type: dynamicFilterType(attrs.type)\n                  })\n                });\n              } else if (this.is([\"top10\"])) {\n                filters.push({\n                  column: filterColumn,\n                  filter: new kendo.spreadsheet.TopFilter({\n                    value: getFilterVal(attrs.val),\n                    type: function (percent, top) {\n                      return percent && top ? \"topPercent\" : top ? \"topNumber\" : percent ? \"bottomPercent\" : \"bottomNumber\";\n                    }(bool(attrs.percent), bool(attrs.top))\n                  })\n                });\n              } else if (this.is([\"filters\"])) {\n                valueFilterBlanks = bool(attrs.blank);\n                valueFilterValues = [];\n              } else if (this.is([\"filter\"])) {\n                valueFilterValues.push(getFilterVal(attrs.val));\n              }\n            }\n          },\n          leave: function (tag, attrs) {\n            if (this.is(SEL_FORMULA)) {\n              if (!formula && attrs.t == \"shared\" && attrs.si != null) {\n                formula = sheet.range(sharedFormulas[attrs.si])._get(\"formula\");\n              }\n            } else if (this.is(SEL_CELL)) {\n              if (formula != null) {\n                var failed = withErrorLog(sheet, formulaRange || ref, function () {\n                  sheet.range(formulaRange || ref).formula(formula, isArrayFormula);\n                }, \"parsing formula\");\n\n                if (failed) {\n                  sheet.range(formulaRange || ref).value(formula).background(\"#ffaaaa\");\n                }\n              } else if (value != null) {\n                var range = sheet.range(ref);\n\n                if (!range._get(\"formula\")) {\n                  // Check for \"shared\" formulas before applying a value.\n                  if (!type || type == \"n\") {\n                    value = parseFloat(value);\n                  } else if (type == \"s\") {\n                    value = strings[integer(value)];\n                  } else if (type == \"b\") {\n                    value = value === \"1\";\n                  } else if (type == \"d\") {\n                    value = kendo.parseDate(value);\n                  }\n\n                  if (value != null) {\n                    range.value(value);\n                  }\n                }\n              }\n            } else if (this.is(SEL_VALIDATION) || this.is(SEL_VALIDATION_INSANE)) {\n              (function () {\n                var refs = kendo.spreadsheet.calc.parseSqref(attrs.sqref);\n                var type = attrs.type.toLowerCase();\n                var operator = attrs.operator;\n\n                if (/^(?:whole|decimal)$/.test(type)) {\n                  // we only support \"number\"\n                  type = \"number\";\n                } else if (type == \"list\") {\n                  // there'll be no operator from Excel for lists\n                  operator = \"list\";\n                }\n\n                if (!operator && /^(?:number|date)$/.test(type)) {\n                  // Excel skips setting the operator for\n                  // \"between\", because why not.\n                  operator = \"between\";\n                }\n\n                refs.forEach(function (ref) {\n                  withErrorLog(sheet, ref, function () {\n                    sheet.range(ref).validation({\n                      type: bool(attrs.showErrorMessage, true) ? \"reject\" : \"warning\",\n                      from: formula1,\n                      to: formula2,\n                      dataType: type,\n                      comparerType: MAP_EXCEL_OPERATOR[operator] || operator,\n                      allowNulls: bool(attrs.allowBlank),\n                      showButton: bool(attrs.showDropDown) || type == \"date\" || type == \"list\",\n                      messageTemplate: attrs.error,\n                      titleTemplate: attrs.errorTitle\n                    });\n                  }, \"parsing validation\");\n                });\n              })();\n            } else if (tag == \"cols\") {\n              sheet._columns._refresh();\n            } else if (tag == \"sheetData\") {\n              sheet._rows._refresh();\n            } else if (tag == \"autoFilter\") {\n              addAutoFilter();\n            } else if (filterRef) {\n              if (tag == \"customFilters\") {\n                filters.push({\n                  column: filterColumn,\n                  filter: new kendo.spreadsheet.CustomFilter({\n                    logic: customFilterLogic,\n                    criteria: customFilterCriteria\n                  })\n                });\n              } else if (tag == \"filters\") {\n                filters.push({\n                  column: filterColumn,\n                  filter: new kendo.spreadsheet.ValueFilter({\n                    values: valueFilterValues,\n                    blanks: valueFilterBlanks\n                  })\n                });\n              }\n            }\n          },\n          text: function (text) {\n            var attrs;\n\n            if (this.is(SEL_VALUE) || this.is(SEL_STRING)) {\n              value = text;\n            } else if (attrs = this.is(SEL_FORMULA)) {\n              formula = text;\n              isArrayFormula = attrs.t == \"array\";\n\n              if (isArrayFormula) {\n                formulaRange = attrs.ref;\n              } else if (attrs.t == \"shared\") {\n                sharedFormulas[attrs.si] = ref;\n              }\n            } else if (this.is(SEL_VALIDATION_FORMULA1) || this.is(SEL_VALIDATION_FORMULA1_INSANE)) {\n              formula1 = text;\n            } else if (this.is(SEL_VALIDATION_FORMULA2) || this.is(SEL_VALIDATION_FORMULA2_INSANE)) {\n              formula2 = text;\n            } else if (this.is(SEL_VALIDATION_SQREF_INSANE)) {\n              // put it in <dataValidation>'s attributes where it should be\n              this.stack[this.stack.length - 2].sqref = text;\n            }\n          }\n        });\n\n        if (relationships.byType.comments) {\n          var commentFile = relative_file(file, relationships.byType.comments[0]);\n          readComments(zip, commentFile, sheet);\n        }\n\n        if (relationships.byType.drawing) {\n          var drawingFile = relative_file(file, relationships.byType.drawing[0]);\n          readDrawings(zip, drawingFile, sheet);\n        }\n\n        function addAutoFilter() {\n          sheet.range(filterRef).filter(filters);\n          filterRef = null;\n        }\n      }\n\n      function getContentType(filename) {\n        var m = /\\.([^.]+)$/.exec(filename);\n\n        if (m && m[1]) {\n          return {\n            jpg: \"image/jpeg\",\n            jpeg: \"image/jpeg\",\n            png: \"image/png\",\n            gif: \"image/gif\"\n          }[m[1].toLowerCase()];\n        }\n      }\n\n      function getFileName(filename) {\n        var m = /[^/]+$/.exec(filename);\n        return m && m[0];\n      }\n\n      function readDrawings(zip, file, sheet) {\n        var sel_two_cell_anchor = [\"xdr:twoCellAnchor\"];\n        var sel_ext = [\"xdr:ext\"];\n        var sel_one_cell_anchor = [\"xdr:oneCellAnchor\"];\n        var sel_from = [\"xdr:from\"];\n        var sel_to = [\"xdr:to\"];\n        var sel_row = [\"xdr:row\"];\n        var sel_col = [\"xdr:col\"];\n        var sel_row_offset = [\"xdr:rowOff\"];\n        var sel_col_offset = [\"xdr:colOff\"];\n        var sel_blip = [\"xdr:blipFill\", \"a:blip\"];\n        var relsFile = file.replace(/drawings\\//, \"drawings/_rels/\");\n        var relationships = readRelationships(zip, relsFile);\n\n        if (relationships.byType.image) {\n          Object.keys(relationships.byId).forEach(function (id) {\n            var img = relative_file(file, relationships.byId[id]);\n            var type = getContentType(img);\n\n            if (type) {\n              // XXX: file.asArrayBuffer() is deprecated in JSZip 3\n              var data = zip.files[img].asArrayBuffer();\n              var name = getFileName(img);\n              var blob = name && !(kendo.support.browser.msie || kendo.support.browser.edge) ? new window.File([data], name, {\n                type: type\n              }) : new window.Blob([data], {\n                type: type\n              });\n              relationships.byId[id] = sheet._workbook.addImage(blob);\n            }\n          });\n        }\n\n        var cdr, ref, width, height;\n        parse(zip, file, {\n          enter: function (tag, attrs) {\n            if (this.is(sel_two_cell_anchor) || this.is(sel_one_cell_anchor)) {\n              cdr = {};\n            } else if (this.is(sel_from) || this.is(sel_to)) {\n              ref = {};\n            } else if (this.is(sel_blip)) {\n              var id = attrs[\"r:embed\"];\n              cdr.image = relationships.byId[id];\n            } else if (this.is(sel_ext)) {\n              width = excelToPixels(parseFloat(attrs.cx));\n              height = excelToPixels(parseFloat(attrs.cy));\n            }\n          },\n          leave: function () {\n            if (this.is(sel_from)) {\n              cdr.topLeftCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);\n              cdr.offsetX = excelToPixels(ref.colOffset);\n              cdr.offsetY = excelToPixels(ref.rowOffset);\n            } else if (this.is(sel_to)) {\n              cdr.brCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);\n              cdr.brX = excelToPixels(ref.colOffset);\n              cdr.brY = excelToPixels(ref.rowOffset);\n            } // Add drawing only when it is image\n            else if (this.is(sel_two_cell_anchor) && cdr.image) {\n              var left = sheet._columns.sum(0, cdr.topLeftCell.col - 1) + cdr.offsetX;\n              var top = sheet._rows.sum(0, cdr.topLeftCell.row - 1) + cdr.offsetY;\n              var right = sheet._columns.sum(0, cdr.brCell.col - 1) + cdr.brX;\n              var bottom = sheet._rows.sum(0, cdr.brCell.row - 1) + cdr.brY;\n              sheet.addDrawing({\n                topLeftCell: cdr.topLeftCell,\n                offsetX: cdr.offsetX,\n                offsetY: cdr.offsetY,\n                width: width != null ? width : right - left,\n                height: height != null ? height : bottom - top,\n                image: cdr.image,\n                opacity: 1\n              });\n            } // Add drawing only when it is image\n            else if (this.is(sel_one_cell_anchor) && cdr.image) {\n              sheet.addDrawing({\n                topLeftCell: cdr.topLeftCell,\n                offsetX: cdr.offsetX,\n                offsetY: cdr.offsetY,\n                width: width,\n                height: height,\n                image: cdr.image,\n                opacity: 1\n              });\n            }\n          },\n          text: function (text) {\n            if (this.is(sel_row)) {\n              ref.row = parseFloat(text);\n            } else if (this.is(sel_col)) {\n              ref.col = parseFloat(text);\n            } else if (this.is(sel_row_offset)) {\n              ref.rowOffset = parseFloat(text);\n            } else if (this.is(sel_col_offset)) {\n              ref.colOffset = parseFloat(text);\n            }\n          }\n        });\n      }\n\n      function readComments(zip, file, sheet) {\n        var authors = [];\n        var author;\n        var comment;\n        parse(zip, file, {\n          enter: function (tag, attrs) {\n            if (this.is(SEL_COMMENT)) {\n              comment = {\n                author: authors[attrs.authorId],\n                ref: attrs.ref,\n                text: \"\"\n              };\n            } else if (this.is(SEL_AUTHOR)) {\n              author = \"\";\n            }\n          },\n          leave: function () {\n            if (this.is(SEL_COMMENT)) {\n              sheet.range(comment.ref).comment(comment.text);\n            } else if (this.is(SEL_AUTHOR)) {\n              authors.push(author);\n            }\n          },\n          text: function (text) {\n            if (this.is(SEL_COMMENT_TEXT)) {\n              comment.text += text;\n            } else if (this.is(SEL_AUTHOR)) {\n              author += text;\n            }\n          }\n        });\n      }\n\n      function getCustomFilter(op, value) {\n        var ourOp = {\n          equal: \"eq\",\n          notEqual: \"ne\",\n          greaterThan: \"gt\",\n          greaterThanOrEqual: \"gte\",\n          lessThan: \"lt\",\n          lessThanOrEqual: \"lte\"\n        }[op];\n        value = getFilterVal(value);\n\n        if (ourOp && typeof value == \"number\") {\n          return {\n            operator: ourOp,\n            value: value\n          };\n        }\n\n        if ((op == \"notEqual\" || !op) && typeof value == \"string\") {\n          // Excel text operators support * and ? wildcards.  Since\n          // our startswith/endswith/contains filters do not, we\n          // can't really use them here, so we'll apply the more\n          // generic \"matches\" and \"doesnotmatch\" filters.\n          return {\n            operator: op ? \"doesnotmatch\" : \"matches\",\n            value: value\n          };\n        }\n      }\n\n      function dynamicFilterType(type) {\n        return {\n          Q1: \"quarter1\",\n          Q2: \"quarter2\",\n          Q3: \"quarter3\",\n          Q4: \"quarter4\",\n          M1: \"january\",\n          M2: \"february\",\n          M3: \"march\",\n          M4: \"april\",\n          M5: \"may\",\n          M6: \"june\",\n          M7: \"july\",\n          M8: \"august\",\n          M9: \"september\",\n          M10: \"october\",\n          M11: \"november\",\n          M12: \"december\"\n        }[type.toUpperCase()] || type;\n      }\n\n      function getFilterVal(val) {\n        var tmp = parseFloat(val);\n\n        if (!isNaN(tmp) && tmp == val) {\n          return tmp;\n        }\n\n        return val;\n      }\n\n      function withErrorLog(sheet, ref, func, context) {\n        try {\n          func();\n          return false;\n        } catch (ex) {\n          var err = {\n            context: context,\n            error: String(ex)\n          };\n\n          if (sheet && sheet.name) {\n            err.sheet = sheet.name();\n          } else if (sheet) {\n            err.sheet = sheet;\n          }\n\n          if (ref) {\n            err.location = String(ref);\n          }\n\n          ERROR_LOG.push(err);\n          return true;\n        }\n      }\n\n      var BORDER_WIDTHS = {\n        \"none\": 0,\n        \"thin\": 1,\n        \"medium\": 2,\n        \"dashed\": 1,\n        \"dotted\": 1,\n        \"thick\": 3,\n        \"double\": 3,\n        \"hair\": 1,\n        \"mediumDashed\": 2,\n        \"dashDot\": 1,\n        \"mediumDashDot\": 2,\n        \"dashDotDot\": 1,\n        \"mediumDashDotDot\": 2,\n        \"slantDashDot\": 1\n      };\n      var DEFAULT_FORMATS = {\n        0: \"General\",\n        1: \"0\",\n        2: \"0.00\",\n        3: \"#,##0\",\n        4: \"#,##0.00\",\n        9: \"0%\",\n        10: \"0.00%\",\n        11: \"0.00E+00\",\n        12: \"# ?/?\",\n        13: \"# ??/??\",\n        14: \"mm-dd-yy\",\n        15: \"d-mmm-yy\",\n        16: \"d-mmm\",\n        17: \"mmm-yy\",\n        18: \"h:mm AM/PM\",\n        19: \"h:mm:ss AM/PM\",\n        20: \"h:mm\",\n        21: \"h:mm:ss\",\n        22: \"m/d/yy h:mm\",\n        37: \"#,##0 ;(#,##0)\",\n        38: \"#,##0 ;[Red](#,##0)\",\n        39: \"#,##0.00;(#,##0.00)\",\n        40: \"#,##0.00;[Red](#,##0.00)\",\n        45: \"mm:ss\",\n        46: \"[h]:mm:ss\",\n        47: \"mmss.0\",\n        48: \"##0.0E+0\",\n        49: \"@\"\n      };\n\n      function applyStyle(sheet, ref, styles, styleIndex) {\n        var range = sheet.range(ref);\n        var xf = styles.inlineStyles[styleIndex],\n            base,\n            value;\n\n        if (xf.xfId) {\n          base = styles.namedStyles[xf.xfId];\n        }\n\n        if (shouldSet(\"applyBorder\", \"borderId\")) {\n          setBorder(styles.borders[value]);\n        }\n\n        if (shouldSet(\"applyFont\", \"fontId\")) {\n          setFont(styles.fonts[value]);\n        }\n\n        if (shouldSet(\"applyAlignment\", \"textAlign\")) {\n          range.textAlign(value);\n        }\n\n        if (shouldSet(\"applyAlignment\", \"verticalAlign\")) {\n          range.verticalAlign(value);\n        }\n\n        if (shouldSet(\"applyAlignment\", \"indent\")) {\n          range.indent(value);\n        }\n\n        if (shouldSet(\"applyAlignment\", \"wrapText\")) {\n          // don't use range.wrap to avoid recomputing row height\n          range._property(\"wrap\", value);\n        }\n\n        if (shouldSet(\"applyFill\", \"fillId\")) {\n          setFill(styles.fills[value]);\n        }\n\n        if (shouldSet(\"applyNumberFormat\", \"numFmtId\")) {\n          setFormat(styles.numFmts[value] || DEFAULT_FORMATS[value]);\n        }\n\n        function setFormat(f) {\n          var format = typeof f == \"string\" ? f : f.formatCode;\n\n          if (format != null && !/^general$/i.test(format)) {\n            // XXX: drop locale info.\n            // http://stackoverflow.com/questions/894805/excel-number-format-what-is-409\n            // not supported by the formatting library.\n            format = format.replace(/^\\[\\$-[0-9]+\\]/, \"\");\n            range.format(format);\n          }\n        }\n\n        function setFill(f) {\n          if (f.type == \"solid\") {\n            range.background(f.color);\n          }\n        }\n\n        function setFont(f) {\n          range.fontFamily(f.name); //range.fontSize(f.size); //XXX: will recalc row height.\n          // converting from points to pixels\n\n          if (f.size) {\n            range._property(\"fontSize\", f.size * 4 / 3);\n          }\n\n          if (f.bold) {\n            range.bold(true);\n          }\n\n          if (f.italic) {\n            range.italic(true);\n          }\n\n          if (f.underline) {\n            range.underline(true);\n          }\n\n          if (f.color) {\n            range.color(f.color);\n          }\n        }\n\n        function setBorder(b) {\n          function set(side, prop) {\n            var border = b[side];\n\n            if (!border) {\n              return;\n            }\n\n            var width = BORDER_WIDTHS[border.style];\n\n            if (width === 0) {\n              return;\n            }\n\n            var color = border.color;\n\n            if (color == null) {\n              color = \"#000\";\n            }\n\n            range._property(prop, {\n              size: width,\n              color: color\n            });\n          }\n\n          set(\"left\", \"borderLeft\");\n          set(\"top\", \"borderTop\");\n          set(\"right\", \"borderRight\");\n          set(\"bottom\", \"borderBottom\");\n        }\n\n        function shouldSet(applyName, propName) {\n          var t = xf[applyName];\n\n          if (t != null && !t) {\n            return false;\n          }\n\n          value = xf[propName];\n\n          if (base && value == null) {\n            t = base[applyName];\n\n            if (t != null && !t) {\n              return false;\n            }\n\n            value = base[propName];\n          }\n\n          return value != null;\n        }\n      }\n\n      function parse(zip, file, callbacks) {\n        var part = zip.files[file];\n\n        if (part) {\n          parseXML(part.asUint8Array(), callbacks);\n        }\n      }\n\n      function readStrings(zip) {\n        var strings = [];\n        var current = null;\n        parse(zip, \"xl/sharedStrings.xml\", {\n          leave: function () {\n            if (this.is(SEL_SHARED_STRING)) {\n              strings.push(current);\n              current = null;\n            }\n          },\n          text: function (text) {\n            if (this.is(SEL_TEXT)) {\n              if (current == null) {\n                current = \"\";\n              }\n\n              current += text;\n            }\n          }\n        });\n        return strings;\n      }\n\n      function readRelationships(zip, file) {\n        var map = {\n          byId: {},\n          byType: {\n            theme: []\n          }\n        };\n        parse(zip, xl(file) + \".rels\", {\n          enter: function (tag, attrs) {\n            if (tag == \"Relationship\") {\n              map.byId[attrs.Id] = attrs.Target;\n              var type = attrs.Type.match(/\\w+$/)[0];\n              var entries = map.byType[type] || [];\n              entries.push(attrs.Target);\n              map.byType[type] = entries;\n            }\n          }\n        });\n        return map;\n      }\n\n      var SEL_BORDER = [\"borders\", \"border\"];\n      var SEL_FILL = [\"fills\", \"fill\"];\n      var SEL_FONT = [\"fonts\", \"font\"];\n      var SEL_INLINE_STYLE = [\"cellXfs\", \"xf\"];\n      var SEL_NAMED_STYLE = [\"cellStyleXfs\", \"xf\"];\n      var SEL_NUM_FMT = [\"numFmts\", \"numFmt\"];\n      var INDEXED_COLORS = [toCSSColor(\"FF000000\"), toCSSColor(\"FFFFFFFF\"), toCSSColor(\"FFFF0000\"), toCSSColor(\"FF00FF00\"), toCSSColor(\"FF0000FF\"), toCSSColor(\"FFFFFF00\"), toCSSColor(\"FFFF00FF\"), toCSSColor(\"FF00FFFF\"), toCSSColor(\"FF000000\"), toCSSColor(\"FFFFFFFF\"), toCSSColor(\"FFFF0000\"), toCSSColor(\"FF00FF00\"), toCSSColor(\"FF0000FF\"), toCSSColor(\"FFFFFF00\"), toCSSColor(\"FFFF00FF\"), toCSSColor(\"FF00FFFF\"), toCSSColor(\"FF800000\"), toCSSColor(\"FF008000\"), toCSSColor(\"FF000080\"), toCSSColor(\"FF808000\"), toCSSColor(\"FF800080\"), toCSSColor(\"FF008080\"), toCSSColor(\"FFC0C0C0\"), toCSSColor(\"FF808080\"), toCSSColor(\"FF9999FF\"), toCSSColor(\"FF993366\"), toCSSColor(\"FFFFFFCC\"), toCSSColor(\"FFCCFFFF\"), toCSSColor(\"FF660066\"), toCSSColor(\"FFFF8080\"), toCSSColor(\"FF0066CC\"), toCSSColor(\"FFCCCCFF\"), toCSSColor(\"FF000080\"), toCSSColor(\"FFFF00FF\"), toCSSColor(\"FFFFFF00\"), toCSSColor(\"FF00FFFF\"), toCSSColor(\"FF800080\"), toCSSColor(\"FF800000\"), toCSSColor(\"FF008080\"), toCSSColor(\"FF0000FF\"), toCSSColor(\"FF00CCFF\"), toCSSColor(\"FFCCFFFF\"), toCSSColor(\"FFCCFFCC\"), toCSSColor(\"FFFFFF99\"), toCSSColor(\"FF99CCFF\"), toCSSColor(\"FFFF99CC\"), toCSSColor(\"FFCC99FF\"), toCSSColor(\"FFFFCC99\"), toCSSColor(\"FF3366FF\"), toCSSColor(\"FF33CCCC\"), toCSSColor(\"FF99CC00\"), toCSSColor(\"FFFFCC00\"), toCSSColor(\"FFFF9900\"), toCSSColor(\"FFFF6600\"), toCSSColor(\"FF666699\"), toCSSColor(\"FF969696\"), toCSSColor(\"FF003366\"), toCSSColor(\"FF339966\"), toCSSColor(\"FF003300\"), toCSSColor(\"FF333300\"), toCSSColor(\"FF993300\"), toCSSColor(\"FF993366\"), toCSSColor(\"FF333399\"), toCSSColor(\"FF333333\"), toCSSColor(\"FF000000\"), // System Foreground\n      toCSSColor(\"FFFFFFFF\") // System Background\n      ];\n\n      function readStyles(zip, theme) {\n        var styles = {\n          fonts: [],\n          numFmts: {},\n          fills: [],\n          borders: [],\n          namedStyles: [],\n          inlineStyles: []\n        };\n        var font = null;\n        var fill = null;\n        var border = null;\n        var xf = null;\n        parse(zip, \"xl/styles.xml\", {\n          enter: function (tag, attrs, closed) {\n            if (this.is(SEL_NUM_FMT)) {\n              styles.numFmts[attrs.numFmtId] = attrs;\n            } else if (this.is(SEL_FONT)) {\n              styles.fonts.push(font = {});\n\n              if (closed) {\n                // apparently, there's XLSX in the wild with\n                // <font/>, because why not (also, <border/>).\n                // if we don't null the variable, we always\n                // enter below and effectively ignore the rest\n                // of the file.\n                font = null;\n              }\n            } else if (font) {\n              if (tag == \"sz\") {\n                font.size = parseFloat(attrs.val);\n              } else if (tag == \"name\") {\n                font.name = attrs.val;\n              } else if (tag == \"b\") {\n                font.bold = bool(attrs.val, true);\n              } else if (tag == \"i\") {\n                font.italic = bool(attrs.val, true);\n              } else if (tag == \"u\") {\n                font.underline = attrs.val == null || attrs.val == \"single\";\n              } else if (tag == \"color\") {\n                font.color = getColor(attrs, null);\n              }\n            } else if (this.is(SEL_FILL)) {\n              styles.fills.push(fill = {});\n\n              if (closed) {\n                fill = null;\n              }\n            } else if (fill) {\n              if (tag == \"patternFill\") {\n                fill.type = attrs.patternType;\n              } else if (tag == \"fgColor\" && fill.type === \"solid\") {\n                fill.color = getColor(attrs, INDEXED_COLORS[0]);\n              } else if (tag == \"bgColor\" && fill.type !== \"solid\") {\n                fill.color = getColor(attrs, INDEXED_COLORS[0]);\n              }\n            } else if (this.is(SEL_BORDER)) {\n              styles.borders.push(border = {});\n\n              if (closed) {\n                border = null;\n              }\n            } else if (border) {\n              if (/^(?:left|top|right|bottom)$/.test(tag)) {\n                border[tag] = {\n                  style: attrs.style || \"none\"\n                };\n              }\n\n              if (tag == \"color\") {\n                var side = this.stack[this.stack.length - 2].$tag;\n                border[side].color = getColor(attrs, INDEXED_COLORS[0]);\n              }\n            } else if (this.is(SEL_NAMED_STYLE)) {\n              xf = getXf(attrs);\n              styles.namedStyles.push(xf);\n\n              if (closed) {\n                xf = null;\n              }\n            } else if (this.is(SEL_INLINE_STYLE)) {\n              xf = getXf(attrs);\n              styles.inlineStyles.push(xf);\n\n              if (closed) {\n                xf = null;\n              }\n            } else if (xf) {\n              if (tag == \"alignment\") {\n                if (/^(?:left|center|right|justify)$/.test(attrs.horizontal)) {\n                  xf.textAlign = attrs.horizontal;\n                }\n\n                if (/^(?:top|center|bottom)$/.test(attrs.vertical)) {\n                  xf.verticalAlign = attrs.vertical;\n                }\n\n                if (attrs.wrapText != null) {\n                  xf.wrapText = bool(attrs.wrapText);\n                }\n\n                if (attrs.indent != null) {\n                  xf.indent = integer(attrs.indent);\n                }\n              }\n            }\n          },\n          leave: function (tag) {\n            if (this.is(SEL_FONT)) {\n              font = null;\n            } else if (this.is(SEL_FILL)) {\n              fill = null;\n            } else if (this.is(SEL_BORDER)) {\n              border = null;\n            } else if (tag == \"xf\") {\n              xf = null;\n            }\n          }\n        });\n\n        function getXf(attrs) {\n          var xf = {\n            borderId: integer(attrs.borderId),\n            fillId: integer(attrs.fillId),\n            fontId: integer(attrs.fontId),\n            numFmtId: integer(attrs.numFmtId),\n            pivotButton: bool(attrs.pivotButton),\n            quotePrefix: bool(attrs.quotePrefix),\n            xfId: integer(attrs.xfId)\n          };\n          addBool(\"applyAlignment\");\n          addBool(\"applyBorder\");\n          addBool(\"applyFill\");\n          addBool(\"applyFont\");\n          addBool(\"applyNumberFormat\");\n          addBool(\"applyProtection\");\n\n          function addBool(name) {\n            if (attrs[name] != null) {\n              xf[name] = bool(attrs[name]);\n            }\n          }\n\n          return xf;\n        }\n\n        function getColor(attrs, defaultThemeColor) {\n          if (attrs.rgb) {\n            return toCSSColor(attrs.rgb);\n          } else if (attrs.indexed) {\n            return INDEXED_COLORS[integer(attrs.indexed)];\n          } else if (attrs.theme) {\n            var themeColor = theme.colorScheme[integer(attrs.theme)];\n\n            if (!themeColor) {\n              // returning black by default for font color causes\n              // https://github.com/telerik/kendo-ui-core/issues/5826\n              // in default cell style, color is undefined\n              return defaultThemeColor;\n            }\n\n            var color = kendo.parseColor(themeColor);\n\n            if (attrs.tint) {\n              color = color.toHSL();\n              var tint = parseFloat(attrs.tint);\n\n              if (tint < 0) {\n                color.l = color.l * (1 + tint);\n              } else {\n                color.l = color.l * (1 - tint) + (100 - 100 * (1 - tint));\n              }\n            }\n\n            return color.toCssRgba();\n          }\n        }\n\n        return styles;\n      }\n\n      var SEL_SCHEME_RGBCLR = [\"a:clrScheme\", \"*\", \"a:srgbClr\"];\n      var SEL_SCHEME_SYSCLR = [\"a:clrScheme\", \"*\", \"a:sysClr\"];\n\n      function readTheme(zip, rel) {\n        var scheme = [];\n        var theme = {\n          colorScheme: scheme\n        };\n        var file = xl(rel);\n\n        if (zip.files[file]) {\n          parse(zip, file, {\n            enter: function (tag, attrs) {\n              if (this.is(SEL_SCHEME_SYSCLR)) {\n                scheme.push(toCSSColor(attrs.val == \"window\" ? \"FFFFFFFF\" : \"FF000000\"));\n              } else if (this.is(SEL_SCHEME_RGBCLR)) {\n                scheme.push(toCSSColor(\"FF\" + attrs.val));\n              }\n            }\n          });\n\n          if (scheme.length > 3) {\n            // lt1 <-> dk1\n            swap(scheme, 0, 1); // lt2 <-> dk2\n\n            swap(scheme, 2, 3);\n          }\n        }\n\n        function swap(arr, a, b) {\n          var tmp = arr[a];\n          arr[a] = arr[b];\n          arr[b] = tmp;\n        }\n\n        return theme;\n      }\n\n      function integer(val) {\n        return val == null ? null : parseInt(val, 10);\n      }\n\n      function bool(val, def) {\n        if (val == null) {\n          return def;\n        }\n\n        return val == \"true\" || val === true || val == 1;\n      }\n\n      function toCSSColor(rgb) {\n        var m = /^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(rgb);\n        return \"rgba(\" + parseInt(m[2], 16) + \", \" + parseInt(m[3], 16) + \", \" + parseInt(m[4], 16) + \", \" + parseInt(m[1], 16) / 255 + \")\";\n      }\n\n      function relative_file(base, name) {\n        base = base.split(/\\/+/);\n        name = name.split(/\\/+/);\n        base.pop();\n\n        while (name.length) {\n          var part = name.shift();\n\n          if (part === \"\") {\n            base = []; // absolute\n          } else if (part === \".\") {\n            continue;\n          } else if (part === \"..\") {\n            base.pop();\n          } else {\n            base.push(part);\n          }\n        }\n\n        return base.join(\"/\");\n      }\n\n      function excelToPixels(val) {\n        return val / 9525;\n      }\n\n      kendo.spreadsheet.readExcel = readExcel;\n      kendo.spreadsheet._readSheet = readSheet;\n      kendo.spreadsheet._readStrings = readStrings;\n      kendo.spreadsheet._readStyles = readStyles;\n      kendo.spreadsheet._readTheme = readTheme;\n      kendo.spreadsheet._readWorkbook = readWorkbook;\n    }, __webpack_require__(3));\n    /***/\n\n  },\n\n  /***/\n  1696:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../util/parse-xml\");\n    /***/\n  },\n\n  /***/\n  1697:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"./calc\");\n    /***/\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}