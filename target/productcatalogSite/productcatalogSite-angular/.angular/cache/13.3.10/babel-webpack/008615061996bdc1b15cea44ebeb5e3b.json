{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}\n/************************************************************************/\n\n/******/\n({\n  /***/\n  0:\n  /***/\n  function (module, exports, __webpack_require__) {\n    module.exports = __webpack_require__(1719);\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = function () {\n      throw new Error(\"define cannot be used indirect\");\n    };\n    /***/\n\n  },\n\n  /***/\n  20:\n  /***/\n  function (module, exports) {\n    module.exports = require(\"../kendo.core\");\n    /***/\n  },\n\n  /***/\n  1719:\n  /***/\n  function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n    (function (f, define) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    })(function () {\n      // WARNING: removing the following jshint declaration and turning\n      // == into === to make JSHint happy will break functionality.\n\n      /* jshint eqnull:true, laxbreak:true */\n      \"use strict\";\n\n      var spreadsheet = kendo.spreadsheet;\n      var Class = kendo.Class;\n\n      function columnName(colIndex) {\n        var letter = Math.floor(colIndex / 26) - 1;\n        return (letter >= 0 ? columnName(letter) : \"\") + String.fromCharCode(65 + colIndex % 26);\n      }\n\n      function displaySheet(sheet) {\n        if (/^[a-z_][a-z0-9_]*$/i.test(sheet)) {\n          return sheet;\n        }\n\n        return \"'\" + sheet.replace(/\\x27/g, \"\\\\'\") + \"'\";\n      }\n\n      function displayRef(sheet, row, col, rel) {\n        var aa = \"\";\n        ++row;\n\n        if (!isFinite(row)) {\n          row = \"\";\n        } else if (rel != null && !(rel & 2)) {\n          row = \"$\" + row;\n        }\n\n        if (!isFinite(col)) {\n          col = \"\";\n        } else {\n          aa = columnName(col);\n\n          if (rel != null && !(rel & 1)) {\n            aa = \"$\" + aa;\n          }\n        }\n\n        if (sheet) {\n          return displaySheet(sheet) + \"!\" + aa + row;\n        } else {\n          return aa + row;\n        }\n      }\n      /* -----[ References ]----- */\n\n\n      var Ref = Class.extend({\n        type: \"ref\",\n        sheet: \"\",\n        clone: function () {\n          return this;\n        },\n        hasSheet: function () {\n          return this._hasSheet;\n        },\n        simplify: function () {\n          return this;\n        },\n        setSheet: function (sheet, hasSheet) {\n          this.sheet = sheet;\n\n          if (hasSheet != null) {\n            this._hasSheet = hasSheet;\n          }\n\n          return this;\n        },\n        absolute: function () {\n          return this;\n        },\n        relative: function () {\n          return this;\n        },\n        adjust: function () {\n          return this;\n        },\n        toString: function () {\n          return this.relative(0, 0, 3, 3).print(0, 0);\n        },\n        forEach: function (callback, obj) {\n          callback.call(obj, this);\n        },\n        map: function (callback, obj) {\n          return callback.call(obj, this);\n        },\n        intersects: function (ref) {\n          return this.intersect(ref) !== NULL;\n        },\n        isCell: function () {\n          return false;\n        },\n        toRow: function () {\n          return this;\n        },\n        toColumn: function () {\n          return this;\n        },\n        // UnionRef overrides these, to access its subranges.\n        first: function () {\n          return this;\n        },\n        lastRange: function () {\n          return this;\n        },\n        size: function () {\n          return 1;\n        },\n        rangeAt: function () {\n          return this;\n        },\n        nextRangeIndex: function () {\n          return 0;\n        },\n        previousRangeIndex: function () {\n          return 0;\n        },\n        eq: function (reference) {\n          var r1 = this;\n          var r2 = reference;\n\n          if (r1 === NULL || r2 === NULL) {\n            return r1 === r2;\n          } // make positions consistent\n\n\n          if (r2 instanceof CellRef || r2 instanceof RangeRef && !(r1 instanceof CellRef)) {\n            r1 = reference;\n            r2 = this;\n          }\n\n          if (r1 instanceof CellRef) {\n            // cell eq *\n            r2 = r2.simplify();\n            return r2 instanceof CellRef && r1.row == r2.row && r1.col == r2.col && r1.sheet == r2.sheet;\n          } else if (r1 instanceof RangeRef) {\n            // range eq range/union\n            if (r2 instanceof RangeRef) {\n              return r2.topLeft.eq(r1.topLeft) && r2.bottomRight.eq(r1.bottomRight);\n            }\n\n            if (r2 instanceof UnionRef) {\n              return r2.single() && r1.eq(r2.refs[0]);\n            }\n          } else if (r1 instanceof UnionRef && r2 instanceof UnionRef) {\n            // union eq union\n            var refs1 = r1.refs;\n            var refs2 = r2.refs;\n\n            if (refs1.length != refs2.length) {\n              return false;\n            }\n\n            for (var i = 0, len = refs1.length; i < len; i++) {\n              if (!refs1[i].eq(refs2[i])) {\n                return false;\n              }\n            }\n\n            return true;\n          }\n\n          return r1 === r2; // XXX: possibly NameRef when we'll support it.\n        },\n        concat: function (ref) {\n          return new UnionRef([this, ref]);\n        },\n        replaceAt: function (index, ref) {\n          return ref;\n        },\n        forEachColumnIndex: function (callback) {\n          this.forEachAxisIndex('col', callback);\n        },\n        forEachRowIndex: function (callback) {\n          this.forEachAxisIndex('row', callback);\n        },\n        forEachAxisIndex: function (axis, callback) {\n          var sorted = [];\n          var method = axis === 'row' ? 'forEachRow' : 'forEachColumn';\n          this[method](function (ref) {\n            var index = ref.first()[axis];\n\n            if (sorted.indexOf(index) === -1) {\n              sorted.push(index);\n            }\n          });\n          sorted.sort(function (a, b) {\n            return a > b ? 1 : a < b ? -1 : 0;\n          }).forEach(callback);\n        },\n        valid: function () {\n          return false;\n        },\n        renameSheet: function (oldSheetName, newSheetName) {\n          if (this.sheet && this.sheet.toLowerCase() == oldSheetName.toLowerCase()) {\n            this.sheet = newSheetName;\n            return true;\n          }\n        }\n      });\n      Ref.display = displayRef;\n      /* -----[ Null reference ]----- */\n\n      var NULL = new (Ref.extend({\n        init: function NullRef() {},\n        print: function () {\n          return \"#NULL!\";\n        },\n        eq: function (ref) {\n          return ref === this;\n        },\n        forEach: function () {}\n      }))();\n      /* -----[ Name reference ]----- */\n\n      var NameRef = Ref.extend({\n        ref: \"name\",\n        init: function NameRef(name) {\n          this.name = name;\n        },\n        clone: function () {\n          return new NameRef(this.name).setSheet(this.sheet, this.hasSheet());\n        },\n        print: function () {\n          var ret = displaySheet(this.name);\n\n          if (this.hasSheet()) {\n            ret = displaySheet(this.sheet) + \"!\" + ret;\n          }\n\n          return ret;\n        }\n      });\n      /* -----[ Cell reference ]----- */\n\n      var CellRef = Ref.extend({\n        ref: \"cell\",\n        init: function CellRef(row, col, rel) {\n          this.row = row;\n          this.col = col;\n          this.rel = rel || 0;\n        },\n        clone: function () {\n          return new CellRef(this.row, this.col, this.rel).setSheet(this.sheet, this.hasSheet());\n        },\n        intersect: function (ref) {\n          if (ref instanceof CellRef) {\n            if (this.eq(ref)) {\n              return this;\n            } else {\n              return NULL;\n            }\n          }\n\n          return ref.intersect(this);\n        },\n        print: function (trow, tcol, mod) {\n          var col = this.col,\n              row = this.row,\n              rel = this.rel,\n              abs;\n\n          if (trow == null && rel) {\n            var sheet = this.hasSheet() ? displaySheet(this.sheet) + \"!\" : \"\";\n\n            if (isFinite(col)) {\n              col = rel & 1 ? \"C[\" + col + \"]\" : \"C\" + (col + 1);\n            } else {\n              col = \"\";\n            }\n\n            if (isFinite(row)) {\n              row = rel & 2 ? \"R[\" + row + \"]\" : \"R\" + (row + 1);\n            } else {\n              row = \"\";\n            }\n\n            return sheet + row + col;\n          } else {\n            abs = this.absolute(trow, tcol);\n\n            if (mod) {\n              // Hacks: see the big comment below in `absolute()`\n              row = abs.row % 0x100000;\n              col = abs.col % 0x4000;\n\n              if (row < 0) {\n                row += 0x100000;\n              }\n\n              if (col < 0) {\n                col += 0x4000;\n              }\n\n              return displayRef(this._hasSheet && this.sheet, row, col, rel);\n            }\n\n            return abs.valid() ? displayRef(this._hasSheet && this.sheet, abs.row, abs.col, rel) : \"#REF!\";\n          }\n        },\n        absolute: function (arow, acol) {\n          var ret = this.clone();\n\n          if (ret.rel & 3 === 0) {\n            return ret; // already absolute\n          } // Hacks: we make coordinates modulo 0x4000 (max col) and 0x100000 (max row).  This\n          // fixes importing relative references in definedName-s from Excel.  Example in\n          // Excel: select cell E3, open the Name Manager (in Formula tab) and define name\n          // TEST with value Sheet1!A1:C3.  The serialization of this name in XLSX is:\n          //\n          //     <definedName name=\"TEST\">Sheet1!XFA1048575:XFC1</definedName>\n          //\n          // This is insane, of course, but oh well.  Excel.  If you type in E3 =SUM(TEST) it\n          // works (it actually sums the cells), but if you type =SUM(Sheet1!XFA1048575:XFC1)\n          // you get back zero.  Let's see why SUM(TEST) works:\n          //\n          //     XFA1048575:XFC1                   E3\n          //     (zero-based indexes below)\n          //\n          //     R[1048574]C[16380]:R[0]C[16382] + R2C4 = R1048576C16384:R2C16386\n          //                                            % (0x100000, 0x4000)\n          //                                            = R0C0:R2C2 (== A1:C3)\n          //\n          // So XFA1048575:XFC1 is relocated to E3 at evaluation time, and because we take\n          // rows modulo 0x100000 and cols modulo 0x4000, we get back the correct range.\n          //\n          // IMO Excel should disallow A1-style relative references in name definitions\n          // (simply because the meaning of the A1:C3 you type in Name Manager depends on the\n          // active cell) and only allow R1C1 notation — that's unambiguous.  But it doesn't.\n          // Moreover, R1C1-style refs in XLSX are explicitly forbidden by the spec, and the\n          // hacks above are not documented — how else could we have fun implementing a XLSX\n          // reader?\n\n\n          if (ret.rel & 1) {\n            // relative col, add anchor\n            ret.col = (ret.col + acol) % 0x4000;\n          }\n\n          if (ret.rel & 2) {\n            // relative row, add anchor\n            ret.row = (ret.row + arow) % 0x100000;\n          }\n\n          ret.rel = 0;\n          return ret;\n        },\n        toRangeRef: function () {\n          return new RangeRef(this, this);\n        },\n        relative: function (arow, acol, rel) {\n          if (rel == null) {\n            rel = this.rel;\n          }\n\n          var row = rel & 2 ? this.row - arow : this.row;\n          var col = rel & 1 ? this.col - acol : this.col;\n          return new CellRef(row, col, rel).setSheet(this.sheet, this.hasSheet());\n        },\n        height: function () {\n          return 1;\n        },\n        width: function () {\n          return 1;\n        },\n        toString: function () {\n          return displayRef(null, this.row, this.col, 3);\n        },\n        isCell: function () {\n          return true;\n        },\n        leftColumn: function () {\n          return this;\n        },\n        rightColumn: function () {\n          return this;\n        },\n        topRow: function () {\n          return this;\n        },\n        bottomRow: function () {\n          return this;\n        },\n        forEachRow: function (callback) {\n          callback(this.toRangeRef());\n        },\n        forEachColumn: function (callback) {\n          callback(this.toRangeRef());\n        },\n        adjust: function (row, col, trow, tcol, forRow, start, delta) {\n          var ref = this.absolute(row, col);\n\n          if (forRow) {\n            if (ref.row >= start) {\n              if (delta < 0 && ref.row < start - delta) {\n                return NULL;\n              }\n\n              ref.row += delta;\n            }\n          } else {\n            if (ref.col >= start) {\n              if (delta < 0 && ref.col < start - delta) {\n                return NULL;\n              }\n\n              ref.col += delta;\n            }\n          }\n\n          if (trow != null && tcol != null) {\n            ref = ref.relative(trow, tcol, this.rel);\n          }\n\n          return ref;\n        },\n        valid: function () {\n          if (this.rel) {\n            throw new Error(\"valid() called on relative reference\");\n          }\n\n          var col = this.col,\n              row = this.row;\n          return !(isFinite(col) && col < 0 || isFinite(row) && row < 0);\n        }\n      });\n      /* -----[ Range reference ]----- */\n\n      var RangeRef = Ref.extend({\n        ref: \"range\",\n        init: function RangeRef(tl, br) {\n          if (tl._hasSheet && br._hasSheet && tl.sheet.toLowerCase() != br.sheet.toLowerCase()) {\n            // \"3D\" reference\n            this.endSheet = br.sheet;\n          } // we want to drop any sheet information from the cells here.\n\n\n          this.topLeft = new CellRef(tl.row, tl.col, tl.rel);\n          this.bottomRight = new CellRef(br.row, br.col, br.rel);\n          this.normalize();\n        },\n        clone: function () {\n          return new RangeRef(this.topLeft.clone(), this.bottomRight.clone()).setSheet(this.sheet, this.hasSheet());\n        },\n        _containsRange: function (range) {\n          return this._containsCell(range.topLeft) && this._containsCell(range.bottomRight);\n        },\n        _containsCell: function (cell) {\n          return cell.sheet == this.sheet && cell.row >= this.topLeft.row && cell.col >= this.topLeft.col && cell.row <= this.bottomRight.row && cell.col <= this.bottomRight.col;\n        },\n        contains: function (ref) {\n          if (ref instanceof Array) {\n            var that = this;\n            return ref.some(function (_ref) {\n              return that.contains(_ref);\n            });\n          }\n\n          if (ref instanceof CellRef) {\n            return this._containsCell(ref);\n          }\n\n          if (ref instanceof RangeRef) {\n            return this._containsRange(ref);\n          }\n\n          return false;\n        },\n        _intersectRange: function (ref) {\n          if (this.sheet != ref.sheet) {\n            return NULL;\n          }\n\n          var a_left = this.topLeft.col;\n          var a_top = this.topLeft.row;\n          var a_right = this.bottomRight.col;\n          var a_bottom = this.bottomRight.row;\n          var b_left = ref.topLeft.col;\n          var b_top = ref.topLeft.row;\n          var b_right = ref.bottomRight.col;\n          var b_bottom = ref.bottomRight.row;\n\n          if (a_left <= b_right && b_left <= a_right && a_top <= b_bottom && b_top <= a_bottom) {\n            return new RangeRef( // topLeft\n            new CellRef(Math.max(a_top, b_top), Math.max(a_left, b_left)), // bottomRight\n            new CellRef(Math.min(a_bottom, b_bottom), Math.min(a_right, b_right))).setSheet(this.sheet, this.hasSheet());\n          } else {\n            return NULL;\n          }\n        },\n        intersect: function (ref) {\n          if (ref instanceof CellRef) {\n            return this._containsCell(ref) ? ref : NULL;\n          }\n\n          if (ref instanceof RangeRef) {\n            return this._intersectRange(ref).simplify();\n          }\n\n          if (ref instanceof UnionRef) {\n            return ref.intersect(this);\n          }\n\n          return NULL; // can't handle NameRef-s here.\n        },\n        simplify: function () {\n          if (this.isCell()) {\n            return new CellRef(this.topLeft.row, this.topLeft.col, this.topLeft.rel).setSheet(this.sheet, this.hasSheet());\n          }\n\n          return this;\n        },\n        normalize: function () {\n          var a = this.topLeft,\n              b = this.bottomRight;\n          var r1 = a.row,\n              c1 = a.col,\n              r2 = b.row,\n              c2 = b.col;\n          var rr1 = a.rel & 2,\n              rc1 = a.rel & 1;\n          var rr2 = b.rel & 2,\n              rc2 = b.rel & 1;\n          var tmp,\n              changes = false; // do not attempt to normalize unless relativeness of rows and cols are the same.\n          // https://github.com/telerik/kendo-ui-core/issues/4278\n\n          if (rr1 === rr2 && rc1 === rc2) {\n            if (r1 > r2) {\n              changes = true;\n              tmp = r1;\n              r1 = r2;\n              r2 = tmp;\n              tmp = rr1;\n              rr1 = rr2;\n              rr2 = tmp;\n            }\n\n            if (c1 > c2) {\n              changes = true;\n              tmp = c1;\n              c1 = c2;\n              c2 = tmp;\n              tmp = rc1;\n              rc1 = rc2;\n              rc2 = tmp;\n            }\n\n            if (changes) {\n              this.topLeft = new CellRef(r1, c1, rc1 | rr1);\n              this.bottomRight = new CellRef(r2, c2, rc2 | rr2);\n            }\n          }\n\n          return this;\n        },\n        print: function (trow, tcol, mod) {\n          if (mod || this.absolute(trow, tcol).valid()) {\n            var ret = this.topLeft.print(trow, tcol, mod) + \":\" + this.bottomRight.print(trow, tcol, mod);\n\n            if (this.hasSheet()) {\n              ret = displaySheet(this.sheet) + (this.endSheet ? \":\" + displaySheet(this.endSheet) : \"\") + \"!\" + ret;\n            }\n\n            return ret;\n          }\n\n          return \"#REF!\";\n        },\n        absolute: function (arow, acol) {\n          return new RangeRef(this.topLeft.absolute(arow, acol), this.bottomRight.absolute(arow, acol)).setSheet(this.sheet, this.hasSheet());\n        },\n        relative: function (arow, acol, relTL, relBR) {\n          if (relBR == null) {\n            relBR = relTL;\n          }\n\n          return new RangeRef(this.topLeft.relative(arow, acol, relTL), this.bottomRight.relative(arow, acol, relBR)).setSheet(this.sheet, this.hasSheet());\n        },\n        height: function () {\n          if (this.topLeft.rel != this.bottomRight.rel) {\n            throw new Error(\"Mixed relative/absolute references\");\n          }\n\n          return this.bottomRight.row - this.topLeft.row + 1;\n        },\n        width: function () {\n          if (this.topLeft.rel != this.bottomRight.rel) {\n            throw new Error(\"Mixed relative/absolute references\");\n          }\n\n          return this.bottomRight.col - this.topLeft.col + 1;\n        },\n        collapse: function () {\n          return this.topLeft.toRangeRef();\n        },\n        leftColumn: function () {\n          return new RangeRef(this.topLeft, new CellRef(this.bottomRight.row, this.topLeft.col));\n        },\n        rightColumn: function () {\n          return new RangeRef(new CellRef(this.topLeft.row, this.bottomRight.col), this.bottomRight);\n        },\n        topRow: function () {\n          return new RangeRef(this.topLeft, new CellRef(this.topLeft.row, this.bottomRight.col));\n        },\n        bottomRow: function () {\n          return new RangeRef(new CellRef(this.bottomRight.row, this.topLeft.col), this.bottomRight);\n        },\n        toRangeRef: function () {\n          return this;\n        },\n        toRow: function (row) {\n          row += Math.max(0, this.topLeft.row);\n          return new RangeRef(new CellRef(row, this.topLeft.col), new CellRef(row, this.bottomRight.col)).setSheet(this.sheet, this.hasSheet());\n        },\n        toColumn: function (col) {\n          col += Math.max(0, this.topLeft.col);\n          return new RangeRef(new CellRef(this.topLeft.row, col), new CellRef(this.bottomRight.row, col)).setSheet(this.sheet, this.hasSheet());\n        },\n        toCell: function (row, col) {\n          row += Math.max(0, this.topLeft.row);\n          col += Math.max(0, this.topLeft.col);\n          return new CellRef(row, col, 0).setSheet(this.sheet, this.hasSheet());\n        },\n        forEachRow: function (callback) {\n          var startRow = this.topLeft.row;\n          var endRow = this.bottomRight.row;\n          var startCol = this.topLeft.col;\n          var endCol = this.bottomRight.col;\n\n          for (var i = startRow; i <= endRow; i++) {\n            callback(new RangeRef(new CellRef(i, startCol), new CellRef(i, endCol)));\n          }\n        },\n        forEachColumn: function (callback) {\n          var startRow = this.topLeft.row;\n          var endRow = this.bottomRight.row;\n          var startCol = this.topLeft.col;\n          var endCol = this.bottomRight.col;\n\n          for (var i = startCol; i <= endCol; i++) {\n            callback(new RangeRef(new CellRef(startRow, i), new CellRef(endRow, i)));\n          }\n        },\n        intersecting: function (refs) {\n          return refs.filter(function (ref) {\n            return ref.toRangeRef().intersects(this);\n          }, this);\n        },\n        union: function (refs, callback) {\n          var intersecting = this.intersecting(refs);\n          var topLeftRow = this.topLeft.row;\n          var topLeftCol = this.topLeft.col;\n          var bottomRightRow = this.bottomRight.row;\n          var bottomRightCol = this.bottomRight.col;\n          var modified = false;\n          intersecting.forEach(function (ref) {\n            ref = ref.toRangeRef();\n\n            if (ref.topLeft.row < topLeftRow) {\n              modified = true;\n              topLeftRow = ref.topLeft.row;\n            }\n\n            if (ref.topLeft.col < topLeftCol) {\n              modified = true;\n              topLeftCol = ref.topLeft.col;\n            }\n\n            if (ref.bottomRight.row > bottomRightRow) {\n              modified = true;\n              bottomRightRow = ref.bottomRight.row;\n            }\n\n            if (ref.bottomRight.col > bottomRightCol) {\n              modified = true;\n              bottomRightCol = ref.bottomRight.col;\n            }\n\n            if (callback) {\n              callback(ref);\n            }\n          });\n          var result = new RangeRef(new CellRef(topLeftRow, topLeftCol), new CellRef(bottomRightRow, bottomRightCol));\n\n          if (modified) {\n            return result.union(refs, callback);\n          } else {\n            return result;\n          }\n        },\n        resize: function (options) {\n          var limit = Math.max.bind(Math, 0);\n\n          function num(value) {\n            return value || 0;\n          }\n\n          var top = this.topLeft.row + num(options.top);\n          var left = this.topLeft.col + num(options.left);\n          var bottom = this.bottomRight.row + num(options.bottom);\n          var right = this.bottomRight.col + num(options.right);\n\n          if (left < 0 && right < 0 || top < 0 && bottom < 0) {\n            return NULL;\n          } else if (top <= bottom && left <= right) {\n            return new RangeRef(new CellRef(limit(top), limit(left)), new CellRef(limit(bottom), limit(right)));\n          } else {\n            return NULL;\n          }\n        },\n        move: function (rows, cols) {\n          return new RangeRef(new CellRef(this.topLeft.row + rows, this.topLeft.col + cols), new CellRef(this.bottomRight.row + rows, this.bottomRight.col + cols));\n        },\n        first: function () {\n          return this.topLeft.clone().setSheet(this.sheet, this.hasSheet());\n        },\n        isCell: function () {\n          return !this.endSheet && this.topLeft.eq(this.bottomRight);\n        },\n        toString: function () {\n          return this.topLeft + \":\" + this.bottomRight;\n        },\n        adjust: function (row, col, trow, tcol, forRow, start, delta) {\n          var tl = this.topLeft.adjust(row, col, trow, tcol, forRow, start, delta);\n          var tr = this.bottomRight.adjust(row, col, trow, tcol, forRow, start, delta);\n\n          if (tl === NULL && tr === NULL) {\n            return NULL;\n          }\n\n          if (tl === NULL) {\n            tl = this.topLeft.absolute(row, col);\n\n            if (forRow) {\n              tl.row = start;\n            } else {\n              tl.col = start;\n            }\n\n            if (trow != null && tcol != null) {\n              tl = tl.relative(trow, tcol, this.topLeft.rel);\n            }\n          } else if (tr === NULL) {\n            tr = this.bottomRight.absolute(row, col);\n\n            if (forRow) {\n              tr.row = start - 1;\n            } else {\n              tr.col = start - 1;\n            }\n\n            if (trow != null && tcol != null) {\n              tr = tr.relative(trow, tcol, this.bottomRight.rel);\n            }\n          }\n\n          return new RangeRef(tl, tr).setSheet(this.sheet, this.hasSheet()).simplify();\n        },\n        valid: function () {\n          return this.topLeft.valid() && this.bottomRight.valid();\n        }\n      });\n      /* -----[ Union reference ]----- */\n\n      var UnionRef = Ref.extend({\n        init: function UnionRef(refs) {\n          this.refs = refs;\n          this.length = refs.length;\n        },\n        clone: function () {\n          return new UnionRef(this.refs.slice());\n        },\n        intersect: function (ref) {\n          var a = [];\n\n          for (var i = 0; i < this.length; ++i) {\n            var x = ref.intersect(this.refs[i]);\n\n            if (x !== NULL) {\n              a.push(x);\n            }\n          }\n\n          if (a.length > 0) {\n            return new UnionRef(a).simplify();\n          }\n\n          return NULL;\n        },\n        simplify: function () {\n          var u = new UnionRef(this.refs.reduce(function (a, ref) {\n            ref = ref.simplify();\n\n            if (ref !== NULL) {\n              a.push(ref);\n            }\n\n            return a;\n          }, []));\n\n          if (u.empty()) {\n            return NULL;\n          }\n\n          if (u.single()) {\n            return u.refs[0];\n          }\n\n          return u;\n        },\n        absolute: function (arow, acol) {\n          return new UnionRef(this.refs.map(function (ref) {\n            return ref.absolute(arow, acol);\n          }));\n        },\n        forEach: function (callback, obj) {\n          this.refs.forEach(function (ref) {\n            if (ref instanceof UnionRef) {\n              ref.forEach(callback, obj);\n            } else {\n              callback.call(obj, ref);\n            }\n          }, obj);\n        },\n        toRangeRef: function () {\n          return this.refs[0].toRangeRef();\n        },\n        contains: function (theRef) {\n          return this.refs.some(function (ref) {\n            return ref.contains(theRef);\n          });\n        },\n        map: function (callback, obj) {\n          var refs = [];\n          this.forEach(function (ref) {\n            refs.push(callback.call(obj, ref));\n          });\n          return new UnionRef(refs);\n        },\n        first: function () {\n          return this.refs[0].first();\n        },\n        lastRange: function () {\n          return this.refs[this.length - 1];\n        },\n        size: function () {\n          return this.length;\n        },\n        single: function () {\n          return this.length == 1;\n        },\n        empty: function () {\n          return this.length === 0;\n        },\n        isCell: function () {\n          return this.single() && this.refs[0].isCell();\n        },\n        rangeAt: function (index) {\n          return this.refs[index];\n        },\n        nextRangeIndex: function (index) {\n          if (index === this.length - 1) {\n            return 0;\n          } else {\n            return index + 1;\n          }\n        },\n        previousRangeIndex: function (index) {\n          if (index === 0) {\n            return this.length - 1;\n          } else {\n            return index - 1;\n          }\n        },\n        concat: function (ref) {\n          return new UnionRef(this.refs.concat([ref]));\n        },\n        print: function (row, col, mod) {\n          return this.refs.map(function (ref) {\n            return ref.print(row, col, mod);\n          }).join(\",\");\n        },\n        replaceAt: function (index, ref) {\n          var newRefs = this.refs.slice();\n          newRefs.splice(index, 1, ref);\n          return new UnionRef(newRefs);\n        },\n        leftColumn: function () {\n          return this.map(function (ref) {\n            return ref.leftColumn();\n          });\n        },\n        rightColumn: function () {\n          return this.map(function (ref) {\n            return ref.rightColumn();\n          });\n        },\n        topRow: function () {\n          return this.map(function (ref) {\n            return ref.topRow();\n          });\n        },\n        bottomRow: function () {\n          return this.map(function (ref) {\n            return ref.bottomRow();\n          });\n        },\n        forEachRow: function (callback) {\n          this.forEach(function (ref) {\n            ref.forEachRow(callback);\n          });\n        },\n        forEachColumn: function (callback) {\n          this.forEach(function (ref) {\n            ref.forEachColumn(callback);\n          });\n        },\n        adjust: function (row, col, trow, tcol, forRow, start, delta) {\n          return this.map(function (ref) {\n            return ref.adjust(row, col, trow, tcol, forRow, start, delta);\n          }).simplify();\n        },\n        toString: function () {\n          return this.refs.map(function (ref) {\n            return ref.toString();\n          }).join(\", \");\n        },\n        valid: function () {\n          for (var i = this.refs.length; --i >= 0;) {\n            if (this.refs[i].valid()) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        renameSheet: function (oldSheetName, newSheetName) {\n          this.refs.forEach(function (ref) {\n            ref.renameSheet(oldSheetName, newSheetName);\n          });\n        }\n      });\n      /* -----[ exports ]----- */\n\n      spreadsheet.NULLREF = NULL;\n      spreadsheet.SHEETREF = new RangeRef(new CellRef(0, 0), new CellRef(Infinity, Infinity));\n      spreadsheet.FIRSTREF = new CellRef(0, 0);\n      spreadsheet.Ref = Ref;\n      spreadsheet.NameRef = NameRef;\n      spreadsheet.CellRef = CellRef;\n      spreadsheet.RangeRef = RangeRef;\n      spreadsheet.UnionRef = UnionRef;\n\n      spreadsheet.SHEETREF.print = function () {\n        return \"#SHEET\";\n      };\n    }, __webpack_require__(3));\n    /***/\n\n  }\n  /******/\n\n});","map":null,"metadata":{},"sourceType":"script"}